"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[15598],{3905:(e,n,r)=>{r.d(n,{Zo:()=>p,kt:()=>f});var t=r(67294);function o(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function a(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function i(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?a(Object(r),!0).forEach((function(n){o(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function s(e,n){if(null==e)return{};var r,t,o=function(e,n){if(null==e)return{};var r,t,o={},a=Object.keys(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||(o[r]=e[r]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=t.createContext({}),l=function(e){var n=t.useContext(c),r=n;return e&&(r="function"==typeof e?e(n):i(i({},n),e)),r},p=function(e){var n=l(e.components);return t.createElement(c.Provider,{value:n},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},h=t.forwardRef((function(e,n){var r=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(r),h=o,f=u["".concat(c,".").concat(h)]||u[h]||m[h]||a;return r?t.createElement(f,i(i({ref:n},p),{},{components:r})):t.createElement(f,i({ref:n},p))}));function f(e,n){var r=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=h;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s[u]="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=r[l];return t.createElement.apply(null,i)}return t.createElement.apply(null,r)}h.displayName="MDXCreateElement"},86369:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>p,contentTitle:()=>c,default:()=>f,frontMatter:()=>s,metadata:()=>l,toc:()=>u});var t=r(87462),o=r(63366),a=(r(67294),r(3905)),i=["components"],s={"^title":"K Nearest Neighbors"},c=void 0,l={unversionedId:"K_Nearest_Neighbors",id:"K_Nearest_Neighbors",title:"K_Nearest_Neighbors",description:"Path: Library models/Toy Models/K Nearest Neighbours/models/knn.gaml",source:"@site/../docs/K_Nearest_Neighbors.md",sourceDirName:".",slug:"/K_Nearest_Neighbors",permalink:"/wiki/next/K_Nearest_Neighbors",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/K_Nearest_Neighbors/_edit",tags:[],version:"current",frontMatter:{"^title":"K Nearest Neighbors"}},p={},u=[],m={toc:u},h="wrapper";function f(e){var n=e.components,r=(0,o.Z)(e,i);return(0,a.kt)(h,(0,t.Z)({},m,r,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("img",{width:"960",alt:"Annotation 2023-04-16 061122_masKNN",src:"https://user-images.githubusercontent.com/4437331/232266668-9e1340f4-1e81-4f34-b34a-e5e9c94078c1.png"}),(0,a.kt)("p",null,"Path: Library models/Toy Models/K Nearest Neighbours/models/knn.gaml"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'\n/**\n* Name: K Nearest Neighbors\n* Description: This model represents how the K Nearest Neighbors Algorithm work. Whenever the user click on any location, a point will\n* be generated and its color will be based on the colors of its k-nearest points. The user can also let the point generated dynamically and \n* the colors of these points will also based on the colors of their k-nearest points\n* Author: Minh Nguyen Dich Nhat\n* Tags: \n*/\n\n/**\n * There will be four parameters\n * The first one is "Number of group", it will specify the number of group in our model. Different groups have different colors.\n * The second one is "Radius", this parameter is the radius of the circles which contain the groups. \n * The third one is "Initial number of point for each group". \n * And the final one is "Number of neighbors", this will specify the number of neighbors that we want to use for our "k_nearest_neighbors" operator,\n * the "k_nearest_neighbors" have one parameter called k, this parameter specify the number of agents we want to compare with our agent. The \n * "Number of neighbours" parameter is the parameter k in the "k_nearest_neighbors" operator.\n */\n\n\nmodel KNearestNeighbors\n\n\nglobal {\n\n    map<unknown, unknown> store;\n    list<rgb> colour <- [#red, #blue, #green, #yellow, #purple, #orange, #pink, #magenta, #cyan];\n    int init_amount <- 10;\n    int nb_group <- 2;\n    float radius <- 10.0;\n    int k <- 10;\n    init {\n        loop i from: 0 to: nb_group - 1{\n            special_point center;\n            create special_point{\n                color <- colour[i];\n                center <- self;\n            }\n            geometry around <- circle(radius, center.location) intersection world.shape;\n            create special_point number: init_amount - 1{\n                location <- any_location_in(around);\n                color <- center.color;\n            }\n        }\n        store <- world.special_point as_map (each::each.color);\n    }\n\n    action createAgent{\n        create special_point{\n            location <- #user_location;\n            color <- self k_nearest_neighbors (store, k);\n            store <+ (self::color);\n        }\n    }\n\n    reflex auto{\n        create special_point{\n            color <- self k_nearest_neighbors (store, k);\n            store <+ self::color;\n        }\n    }\n}\n\nspecies special_point {\n    float size <- 0.5;\n    rgb color;\n    aspect base{\n        draw circle(size) color:color;\n    }\n    \n}\n\nexperiment demo {\n    parameter "Number of groups: " var:nb_group min: 2 max: 9;\n    parameter "Radius: " var: radius min:10.0 max:30.0;\n    parameter "Initial numbers of agent for each group: " var:init_amount min:1 max:50;\n    parameter "Number of neighbours considered (K)" var:k min:1;\n    output {\n        display main {\n            species special_point aspect: base;\n            event #mouse_down action:createAgent;\n        }\n    }\n}\n\n')))}f.isMDXComponent=!0}}]);