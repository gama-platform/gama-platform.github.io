[{"id":"wiki/Contribute.md","title":" Contribute","content":"Contribute  Since GAMA is a free opensource software, we are proud to share the source code with anyone who wants to contribute to the platform. Note that GAMA is easy to extand through the use of additionnal plugins.  Table of content     Developer documentation   Source code   GAMA Dev mailing list   Developers   Citing GAMA   Developer documentation  A more complete documentation exists on Github at the following address : https://github.com/gama-platform/gama/wiki. You can find here the last updated version of the documentation (the documentation of the latest git version), and also a developer documentation (which is not available in the  regular  website).  Source Code  GAMA can be downloaded as a regular application or built from source, which is necessary if you want to contribute to the platform. The source code is available from this GITHub repository:   https://github.com/gama-platform/gama   Which you can also browse from the web here. It is, in any case, recommended to follow the instructions on this page in order to build GAMA from source.  GAMA Dev mailing list  If you want to contribute to the platform, you can send a request to the developping team to be in the gama-dev@googlegroups.com mailing list.  Developers  GAMA is being designed, developed and maintained by an active group of researchers coming from different institutions in France and Vietnam. Please find below a short introduction to each of them and a summary of their contributions to the platform:     Alexis Drogoul, Senior Researcher at the IRD, member of the UMMISCO International Research Unit. Mostly working on agent-based modeling and simulation. Has contributed and still contributes to the original design of the platform, including the GAML language (from the meta-model to the editor) and simulation facilities like Java2D displays.   Patrick Taillandier, Associate Professor at the University of Rouen, member of the IDEES CNRS Mixed Research Unit. Contributes since 2008 to the spatial and graph features (GIS integration, spatial operators) and to parameter space search algorithms. Currently working on new features related to graphical modeling and traffic simulation.   Benoit Gaudou, Associate Professor at the University Toulouse 1 Capitole, member of the IRIT CNRS Mixed Research Unit. Contributes since 2010 to documentation and unit test generation and coupling mathematical (ODE and PDE) and agent paradigms.   Arnaud Grignard, software engineer and PhD fellow (PDI-MSC) at UPMC. Contributes since 2011 to the development of new features related to visualization (3D Display), online analysis and interaction.   Huynh Quang Nghi, software engineering lecturer at CTU and PhD fellow (PDI-MSC) at UPMC. Contributes since 2012 to the development of new features related to GAML parser, coupling formalisms in EBM-ABM and ABM-ABM.   Truong Minh Thai, software engineering lecturer at CTU and PhD fellow (PRJ322-MOET) at IRIT-UT1. Contributes since 2012 to the development of new features related to data management and analysis.   Nicolas Marilleau, Researcher at the IRD, member of the UMMISCO International Research Unit and associate researcher at DISC team of FEMTO-ST institute. Contributes since 2010 to the development of headless mode and the high performance computing module.   Philippe Caillou, Associate professor at the University Paris Sud 11, member of the LRI and INRIA project-team TAO. Contributes since 2012 and actually working on charts, simulation analysis and BDI agents.   Vo Duc An, Post-doctoral Researcher, working on synthetic population generation in agent-based modelling, at the UMMISCO International Research Unit of the IRD. Has contributed to bringing the platform to the Eclipse RCP environment and to the development of several features (e.g., the FIPA-compliant agent communication capability, the multi-level architecture).   Truong Xuan Viet, software engineering lecturer at CTU and PhD fellow (PDI-MSC) at UPMC. Contributes since 2011 to the development of new features related to R caller, online GIS (OPENGIS: Web Map Service - WMS, Web Feature Services - WMS, Google map, etc).  Samuel Thiriot Citing GAMA If you use GAMA in your research and want to cite it (in a paper, presentation, whatever), please use this reference:     A. Grignard, P. Taillandier, B. Gaudou, D-A. Vo, N-Q. Huynh, A. Drogoul (2013), GAMA 1.6: Advancing the Art of Complex Agent-Based Modeling and Simulation. In  PRIMA 2013: Principles and Practice of Multi-Agent Systems , Lecture Notes in Computer Science, Vol. 8291, Springer, pp. 117-131.   or you can choose to cite the website instead:     GAMA Platform website, http://gama-platform.org   A complete list of references (papers and PhD theses on or using GAMA) is available on the references page. ","url":"wiki/Contribute.md"},{"id":"wiki/Projects.md","title":" Projects","content":"Projects    References  This page contains a subset of the scientific papers that have been written either about GAMA or using the platform as an experimental/modeling support.  If you happen to publish a paper that uses or discusses GAMA, please let us know, so that we can include it in this list.  If you need to cite GAMA in a paper, we kindly ask you to use this reference:     A. Grignard, P. Taillandier, B. Gaudou, D-A. Vo, N-Q. Huynh, A. Drogoul (2013), GAMA 1.6: Advancing the Art of Complex Agent-Based Modeling and Simulation. In  PRIMA 2013: Principles and Practice of Multi-Agent Systems , Lecture Notes in Computer Science, Vol. 8291, Springer, pp. 117-131.   Papers about GAMA  Taillandier, Patrick, Arnaud Grignard, Benoit Gaudou, and Alexis Drogoul.  Des données géographiques à la simulation à base d agents: application de la plate-forme GAMA.  Cybergeo: European Journal of Geography (2014). A. Grignard, P. Taillandier, B. Gaudou, D-A. Vo, N-Q. Huynh, A. Drogoul (2013), GAMA 1.6: Advancing the Art of Complex Agent-Based Modeling and Simulation. In  PRIMA 2013: Principles and Practice of Multi-Agent Systems , Lecture Notes in Computer Science, Vol. 8291, Springer, pp. 117-131. Grignard, Arnaud, Alexis Drogoul, and Jean-Daniel Zucker.  Online analysis and visualization of agent based models.  Computational Science and Its Applications–ICCSA 2013. Springer Berlin Heidelberg, 2013. 662-672. Taillandier, P., Drogoul, A., Vo, D.A. and Amouroux, E. (2012), GAMA: a simulation platform that integrates geographical information data, agent-based modeling and multi-scale control. In  The 13th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA) , India, Volume 7057/2012, pp 242-258. Taillandier, P. & Drogoul, A. (2011), From Grid Environment to Geographic Vector Agents, Modeling with the GAMA simulation platform. In  25th Conference of the International Cartographic Association , Paris, France. Taillandier, P. ; Drogoul A. ; Vo D.A. & Amouroux, E. (2010), GAMA : bringing GIS and multi-level capabilities to multi-agent simulation, in  the 8th European Workshop on Multi-Agent Systems , Paris, France. Amouroux, E., Taillandier, P. &  Drogoul, A. (2010), Complex environment representation in epidemiology ABM: application on H5N1 propagation. In  the 3rd International Conference on Theories and Applications of Computer Science  (ICTACS 10). Amouroux, E., Chu, T.Q., Boucher, A. and Drogoul, A. (2007), GAMA: an environment for implementing and running spatially explicit multi-agent simulations. In  Pacific Rim International Workshop on Multi-Agents , Bangkoku, Thailand, pp. 359–371.      PhD theses  Truong Xuan Viet,  Optimization by Simulation of an Environmental Surveillance Network: Application to the Fight against Rice Pests in the Mekong Delta (Vietnam) , University of Paris 6 & Ho Chi Minh University of Technology, defended June 24th, 2014. Nguyen Nhi Gia Vinh,  Designing multi-scale models to support environmental decision: application to the control of Brown Plant Hopper invasions in the Mekong Delta (Vietnam) , University of Paris 6, defended Oct. 31st, 2013. Vo Duc An,  An operational architecture to handle multiple levels of representation in agent-based models , University of Paris 6, defended Nov. 30th 2012. Amouroux Edouard,  KIMONO: a descriptive agent-based modeling methodology for the exploration of complex systems: an application to epidemiology , University of Paris 6, defended Sept. 30th, 2011. Chu Thanh Quang,  Using agent-based models and machine learning to enhance spatial decision support systems: Application to resource allocation in situations of urban catastrophes , University of Paris 6, defended July 1st, 2011. Nguyen Ngoc Doanh,  Coupling Equation-Based and Individual-Based Models in the Study of Complex Systems: A Case Study in Theoretical Population Ecology , University of Paris 6, defended Dec. 14th, 2010.      Research papers that use GAMA as modeling/simulation support 2014   E. G. Macatulad , A. C. Blanco (2014) 3DGIS-BASED MULTI-AGENT GEOSIMULATION AND VISUALIZATION OF BUILDING EVACUATION USING GAMA PLATFORM. The International Archives of the Photogrammetry, Remote Sensing and Spatial Information Sciences, Volume XL-2, 2014. ISPRS Technical Commission II Symposium, 6 – 8 October 2014, Toronto, Canada. Retrieved from http://www.int-arch-photogramm-remote-sens-spatial-inf-sci.net/XL-2/87/2014/isprsarchives-XL-2-87-2014.pdf S. Bhamidipati (2014) A simulation framework for asset management in climate-change adaptation of transportation infrastructure. In: Proceedings of 42nd European Transport Conference. Frankfurt, Germany. Retrieved from http://abstracts.aetransport.org/paper/download/id/4317 Gaudou, B., Sibertin-Blanc, C., Thérond, O., Amblard, F., Auda, Y., Arcangeli, J.-P., Balestrat, M., Charron-Moirez, M.-H., Gondet, E., Hong, Y., Lardy, R., Louail, T., Mayor, E., Panzoli, D., Sauvage, S., Sanchez-Perez, J., Taillandier, P., Nguyen, V. B., Vavasseur, M., Mazzega, P. (2014). The MAELIA multi-agent platform for integrated assessment of low-water management issues. In: International Workshop on Multi-Agent-Based Simulation (MABS 2013), Saint-Paul, MN, USA, 06/05/2013-07/05/2013, Vol. 8235, Shah Jamal Alam, H. Van Dyke Parunak, (Eds.), Springer, Lecture Notes in Computer Science, p. 85-110. Gaudou, B., Lorini, E., Mayor, E. (2014.) Moral Guilt: An Agent-Based Model Analysis. In: Conference of the European Social Simulation Association (ESSA 2013), Warsaw, 16/09/2013-20/09/2013, Vol. 229, Springer, Advances in Intelligent Systems and Computing, p. 95-106.      2013   * Drogoul, A., Gaudou, B., Grignard, A., Taillandier, P., & Vo, D. A. (2013). Practical Approach To Agent-Based Modelling. In: Water and its Many Issues. Methods and Cross-cutting Analysis. Stéphane Lagrée (Eds.), Journées de Tam Dao, p. 277-300, Regional Social Sciences Summer University.   Drogoul, A., Gaudou, B. (2013) Methods for Agent-Based Computer Modelling. In: Water and its Many Issues. Methods and Cross-cutting Analysis. Stéphane Lagrée (Eds.), Journées de Tam Dao, 1.6, p. 130-154, Regional Social Sciences Summer University.  Truong, M.-T., Amblard, F., Gaudou, B., Sibertin-Blanc, C., Truong, V. X., Drogoul, A., Hyunh, X. H., Le, M. N. (2013). An implementation of framework of business intelligence for agent-based simulation. In: Symposium on Information and Communication Technology (SoICT 2013), Da Nang, Viet Nam, 05/12/2013-06/12/2013, Quyet Thang Huynh, Thanh Binh Nguyen, Van Tien Do, Marc Bui, Hong Son Ngo (Eds.), ACM, p. 35-44. Le, V. M., Gaudou, B., Taillandier, P., Vo, D. A (2013). A New BDI Architecture To Formalize Cognitive Agent Behaviors Into Simulations. In: Advanced Methods and Technologies for Agent and Multi-Agent Systems (KES-AMSTA 2013), Hue, Vietnam, 27/05/2013-29/05/2013, Vol. 252, Dariusz Barbucha, Manh Thanh Le, Robert J. Howlett, C. Jain Lakhmi (Eds.), IOS Press, Frontiers in Artificial Intelligence and Applications, p. 395-403.      2012   * Taillandier, P., Therond, O., Gaudou B. (2012), A new BDI agent architecture based on the belief theory. Application to the modelling of cropping plan decision-making. In  International Environmental Modelling and Software Society , Germany, pp. 107-116.   Taillandier, P., Therond, O., Gaudou B. (2012), Une architecture d agent BDI basée sur la théorie des fonctions de croyance: application à la simulation du comportement des agriculteurs. In  Journées Francophones sur les Systèmes Multi-Agents , France, pp. 107-116. NGUYEN, Quoc Tuan, Alain BOUJU, and Pascal ESTRAILLIER.  Multi-agent architecture with space-time components for the simulation of urban transportation systems.  (2012). Cisse, A., Bah, A., Drogoul, A., Cisse, A.T., Ndione, J.A., Kebe, C.M.F. & Taillandier P. (2012), Un modèle à base d agents sur la transmission et la diffusion de la fièvre de la Vallée du Rift à Barkédji (Ferlo, Sénégal), Studia Informatica Universalis 10 (1), pp. 77-97. Taillandier, P., Amouroux, E., Vo, D.A. and Olteanu-Raimond A.M. (2012), Using Belief Theory to formalize the agent behavior: application to the simulation of avian flu propagation. In  The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS) , India, Volume 7057/2012, pp. 575-587. Le, V.M., Adam, C., Canal, R., Gaudou, B., Ho, T.V. and Taillandier, P. (2012), Simulation of the emotion dynamics in a group of agents in an evacuation situation. In  The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS) , India, Volume 7057/2012, pp. 604-619. Nguyen Vu, Q. A., Canal, R., Gaudou, B., Hassas, S., Armetta, F. (2012), TrustSets - Using trust to detect deceitful agents in a distributed information collecting system. In: Journal of Ambient Intelligence and Humanized Computing, Springer-Verlag, Vol. 3 N. 4, p. 251-263.      2011   * Taillandier, P. & Therond, O. (2011), Use of the Belief Theory to formalize Agent Decision Making Processes : Application to cropping Plan Decision Making. In  25th European Simulation and Modelling Conference , Guimaraes, Portugal, pp. 138-142.   Taillandier, P. & Amblard, F. (2011), Cartography of Multi-Agent Model Parameter Space through a reactive Dicotomous Approach. In  25th European Simulation and Modelling Conference , Guimaraes, Portugal, pp. 38-42. Taillandier, P. & Stinckwich, S. (2011), Using the PROMETHEE Multi-Criteria Decision Making Method to Define New Exploration Strategies for Rescue Robots , IEEE International Symposium on Safety, Security, and Rescue Robotics, Kyoto, Japon, pp. 321 - 326.      2010   * Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S. and Armetta, F. (2010), A cluster-based approach for disturbed, spatialized, distributed information gathering systems,  in  The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS) , India, pp. 588-603.   Nguyen, N.D., Taillandier, P., Drogoul, A. and Augier, P. (2010), Inferring Equation-Based Models from Agent-Based Models: A Case Study in Competition Dynamics.In  The 13th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA) , India, Volume 7057/2012, pp. 413-427. Amouroux, E., Gaudou, B. Desvaux, S. and Drogoul, A. (2010), O.D.D.: a Promising but Incomplete Formalism For Individual-Based Model Specification. in  IEEE International Conference on Computing and Telecommunication Technologies  (2010 IEEE RIVF ), pp. 1-4. Nguyen, N.D., Phan, T.H.D., Nguyen, T.N.A., Drogoul, A. and Zucker, J-D. (2010), Disk Graph-Based Model for Competition Dynamic, Paper to appear in  IEEE International Conference on Computing and Telecommunication Technologies  (2010 IEEE RIVF ). Nguyen, T.K., Marilleau, N., Ho T.V. and El Fallah Seghrouchni, A. (2010), A meta-model for specifying collaborative simulation, Paper to appear in  IEEE International Conference on Computing and Telecommunication Technologies  (2010 IEEE RIVF ). Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S. and Armetta, F. (2010), TrustSets - Using trust to detect deceitful agents in a distributed information collecting system, Paper to appear in  IEEE International Conference on Computing and Telecommunication Technologies  (2010 IEEE RIVF ), the best student paper award. Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S., Armetta, F. and Stinckwich, S. (2010), Using trust and cluster organisation to improve robot swarm mapping, Paper to appear in  Workshop on Robots and Sensors integration in future rescue INformation system   (ROSIN 2010).      2009   * Taillandier, P. and Buard, E. (2009), Designing Agent Behaviour in Agent-Based Simulation through participatory method. In  The 12th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA) , Nagoya, Japan, pp. 571–578.   Taillandier, P. and Chu, T.Q. (2009), Using Participatory Paradigm to Learn Human Behaviour. In  International Conference on Knowledge and Systems Engineering , Ha noi, Viet Nam, pp. 55–60. Gaudou, B., Ho, T.V. and Marilleau, N. (2009), Introduce collaboration in methodologies of modeling and simulation of Complex Systems. In  International Conference on Intelligent Networking and Collaborative Systems (INCOS  09) . Barcelona, pp. 1–8. Nguyen, T.K., Gaudou B., Ho T.V. and Marilleau N. (2009), Application of PAMS Collaboration Platform to Simulation-Based Researches in Soil Science: The Case of the MIcro-ORganism Project. In  IEEE International Conference on Computing and Telecommunication Technologies (IEEE-RIVF 09) . Da Nang, Viet Nam, pp. 296–303. Nguyen, V.Q., Gaudou B., Canal R., Hassas S. and Armetta F. (2009), Stratégie de communication dans un système de collecte d information à base d agents perturbés. In  Journées Francophones sur les Systèmes Multi-Agents (JFSMA 09) .      2008   * Chu, T.Q., Boucher, A., Drogoul, A., Vo, D.A., Nguyen, H.P. and Zucker, J.D. (2008). Interactive Learning of Expert Criteria for Rescue Simulations. In  Pacific Rim International Workshop on Multi-Agents , Ha Noi, Viet Nam, pp. 127–138.     Amouroux, E., Desvaux, S. and Drogoul, A. (2008), Towards Virtual Epidemiology: An Agent-Based Approach to the Modeling of H5N1 Propagation and Persistence in North-Vietnam. In  Pacific Rim International Workshop on Multi-Agents , Ha Noi, Viet Nam, pp. 26–33.  ","url":"wiki/Projects.md"},{"id":"wiki/TrainingSession.md","title":" Training Session","content":"Training Session  Modeling for supporting decision in urban management issues  7-11 December 2015 - Siem Reap (Cambodia)    This training session took place at the Apsara Authorities, where we introduced how to build a model with agent-based approach, using GAMA. In a new and very fast growing city such as Siem Reap, some measures have to be taken to anticipate the future of the city, and modeling is a science that can give some solutions to face those problems.  The training session was divided into 2 parts : * A theoretical part (3 days) dealing with the following subjects :   * Urban issues and introduction to Agent-Based Modeling   * Presentation of the modeling methodology   * Introduction to GAMA with a model on urban segregation   * GIS datas and graphs to model urban mobility   * GIS, Raster datas and graphs to model urban growth   * Use of experiments to calibrate and explore models * A practical part (2 days) to build a model about urban mobility in Siem Reap (by groups of 4/5 people)  ||| |—|—|  Trainers : Drogoul Alexis, Gaudou Benoit, Trung Quang, Philippon Damien, Mazars Julien.  Here the link to download the different projects (Gama version : 1.61)  A Glance at Sustainable Urban Development (JTD)  July 2014 - Da lat (Vietnam)  The JTD (Journées de Tam Dao) is an annual gathering of french-talkers researchers during the summer for one week, dealing with a specific subject related to sustainable development. For this 8th JTD, the topic was about sustainable urban development, and a workshop has been made especially about how to use tools as GAMA to build models in order to explore and understand urban spatial dynamics.  Trainers : Drogoul Alexis, Banos Arnaud, Huỳnh Quang Nghi, Trương Chí Quang, Võ Đức Ân.  Here is the link to download the pdf report of the JTD 2014 : https://drive.google.com/file/d/0B2Go6pohIhQcbERhczZRd253UUU/view.  The perception and Management of Risk (JTD)  July 2013 - Da lat (Vietnam)  The JTD (Journées de Tam Dao) is an annual gathering of french-talkers researchers during the summer for one week, dealing with a specific subject related to sustainable development. For this 7th JTD, the topic was about the perception and management of risks, and a workshop has been made especially about how to use tools as GAMA to build models in order to understand past crises to better understand the present.  Trainers : Alexis Drogoul, Benoit Gaudou, Nasser Gasmi, Arnaud Grignard, Patrick Taillandier, Olivier Tessier, Võ Đức Ân  Here is the link to download the pdf report of the JTD 2013 : https://drive.google.com/file/d/0B2Go6pohIhQcNXFwVllHd2pFdlk/view.  Water and its many Issues (JTD)  July 2012 - Vietnam  The JTD (Journées de Tam Dao) is an annual gathering of french-talkers researchers during the summer for one week, dealing with a specific subject related to sustainable development. For this 6th JTD, the topic was about the perception and management of risks, and a workshop has been made especially about how to use tools as GAMA to build models with an agent-based approach.  Trainers : Alexis Drogoul, Benoit Gaudou, Arnaud Grignard, Patrick Taillandier, Vỗ Đức Ân  Here is the link to download the pdf report of the JTD 2012 : https://docs.google.com/file/d/0B2Go6pohIhQcUWRKU2hPelNqQmc/view. ","url":"wiki/TrainingSession.md"},{"id":"wiki/AgentBuiltIn.md","title":" The 'agent' built-in species (Under Construction)","content":"The  agent  built-in species (Under Construction)  As described in the presentation of GAML, the hierarchy of species derives from a single built-in species called agent. All its components (attributes, actions) will then be inherited by all direct or indirect children species (including model and experiment), with the exception of species that explicitly mention use_minimal_agents: true as a facet, which inherit from a stripped-down version of agent (see below).  agent attributes agent defines several attributes, which form the minimal set of knowledge any agent will have in a model.   *  agent actions ","url":"wiki/AgentBuiltIn.md"},{"id":"wiki/BuiltInArchitectures.md","title":" Built-in Architectures","content":"Built-in Architectures    This file is automatically generated from java files. Do Not Edit It.    INTRODUCTION    Table of Contents   [fsm](#fsm), [parallel_bdi](#parallel_bdi), [probabilistic_tasks](#probabilistic_tasks), [reflex](#reflex), [simple_bdi](#simple_bdi), [sorted_tasks](#sorted_tasks), [user_first](#user_first), [user_last](#user_last), [user_only](#user_only), [weighted_tasks](#weighted_tasks),      ## fsm  ### Variables     state (string): Returns the current state in which the agent is   states (list): Returns the list of all possible states the agents can be in   Actions    ## parallel_bdi  ### Variables  Actions    ## probabilistic_tasks  ### Variables  Actions    ## reflex  ### Variables  Actions    ## simple_bdi  ### Variables     belief_base (list):   charisma (float):   current_plan (any type):   desire_base (list):   emotion_base (list):   intention_base (list):   intention_persistence (float): intention persistence   plan_base (list):   plan_persistence (float): plan persistence   probabilistic_choice (boolean):   receptivity (float):   social_link_base (list):   thinking (list):   uncertainty_base (list):   use_emotions_architecture (boolean):   use_social_architecture (boolean):   Actions  add_belief add the predicate in the belief base. * returns: bool     * predicate (546704): predicate to add as a belief  add_desire adds the predicates is in the desire base. * returns: bool     * predicate (546704): predicate to add     * todo (546704): add the desire as a subintention of this parameter  add_emotion add the emotion to the emotion base. * returns: bool     * emotion (546706): emotion to add to the base  add_intention check if the predicates is in the desire base. * returns: bool     * predicate (map): predicate to check  add_social_link add the social link to the social link base. * returns: bool     * social_link (546707): social link to add to the base  add_subintention adds the predicates is in the desire base. * returns: bool     * predicate (546704): predicate name     * subintentions (546704): the subintention to add to the predicate     * add_as_desire (boolean): add the subintention as a desire as well (by default, false)  add_uncertainty add a predicate in the uncertainty base. * returns: bool     * predicate (546704): predicate to check  clear_beliefs clear the belief base * returns: bool  clear_desires clear the desire base * returns: bool  clear_emotions clear the emotion base * returns: bool  clear_intentions clear the intention base * returns: bool  clear_social_links clear the intention base * returns: bool  clear_uncertainties clear the uncertainty base * returns: bool  current_intention_on_hold puts the current intention on hold until the specified condition is reached or all subintentions are reached (not in desire base anymore). * returns: bool     * until (any type): the current intention is put on hold (fited plan are not considered) until specific condition is reached. Can be an expression (which will be tested), a list (of subintentions), or nil (by default the condition will be the current list of subintentions of the intention)  get_belief get the predicate in the belief base (if several, returns the first one). * returns: predicate     * predicate (546704): predicate to get  get_belief_with_name get the predicates is in the belief base (if several, returns the first one). * returns: predicate     * name (string): name of the predicate to check  get_beliefs get the list of predicates is in the belief base * returns: msi.gama.util.IList     * ** predicate ** (546704): name of the predicates to check  get_beliefs_with_name get the list of predicates is in the belief base with the given name. * returns: msi.gama.util.IList     * ** name ** (string): name of the predicates to check  get_current_intention returns the current intention (last entry of intention base). * returns: predicate  get_desire get the predicates is in the desire base (if several, returns the first one). * returns: predicate     * predicate (546704): predicate to check  get_desire_with_name get the predicates is in the belief base (if several, returns the first one). * returns: predicate     * name (string): name of the predicate to check  get_desires get the list of predicates is in the belief base * returns: msi.gama.util.IList     * ** predicate ** (546704): name of the predicates to check  get_desires_with_name get the list of predicates is in the belief base with the given name. * returns: java.util.List     * ** name ** (string): name of the predicates to check  get_emotion get the emotion in the emotion base (if several, returns the first one). * returns: emotion     * emotion (546706): emotion to get  get_intention get the predicates is in the belief base (if several, returns the first one). * returns: predicate     * predicate (546704): predicate to check  get_intention_with_name get the predicates is in the belief base (if several, returns the first one). * returns: predicate     * name (string): name of the predicate to check  get_intentions get the list of predicates is in the belief base * returns: msi.gama.util.IList     * ** predicate ** (546704): name of the predicates to check  get_intentions_with_name get the list of predicates is in the belief base with the given name. * returns: java.util.List     * ** name ** (string): name of the predicates to check  get_plans get the list of plans. * returns: java.util.List  get_social_link get the social linke (if several, returns the first one). * returns: msi.gaml.architecture.simplebdi.SocialLink     * social_link (546707): social link to check  get_uncertainty get the predicates is in the uncertainty base (if several, returns the first one). * returns: predicate     * predicate (546704): predicate to check  has_belief check if the predicates is in the belief base. * returns: bool     * predicate (546704): predicate to check  has_desire check if the predicates is in the desire base. * returns: bool     * predicate (546704): predicate to check  has_emotion check if the emotion is in the belief base. * returns: bool     * emotion (546706): emotion to check  has_social_link check if the social link base. * returns: bool     * social_link (546707): social link to check  has_uncertainty check if the predicates is in the uncertainty base. * returns: bool     * predicate (546704): predicate to check  is_current_intention check if the predicates is the current intention (last entry of intention base). * returns: bool     * predicate (546704): predicate to check  remove_all_beliefs removes the predicates from the belief base. * returns: bool     * predicate (546704): predicate to remove  remove_belief removes the predicate from the belief base. * returns: bool     * predicate (546704): predicate to remove  remove_desire removes the predicates from the desire base. * returns: bool     * predicate (546704): predicate to add  remove_emotion removes the emotion from the emotion base. * returns: bool     * emotion (546706): emotion to remove  remove_intention removes the predicates from the desire base. * returns: bool     * predicate (546704): predicate to add     * desire_also (boolean): removes also desire  remove_social_link removes the social link from the social relation base. * returns: bool     * social_link (546707): social link to remove  remove_uncertainty removes the predicates from the desire base. * returns: bool     * predicate (546704): predicate to add  replace_belief replace the old predicate by the new one. * returns: bool     * old_predicate (546704): predicate to remove     * predicate (546704): predicate to add    ## sorted_tasks  ### Variables  Actions    ## user_first  ### Variables  Actions    ## user_last  ### Variables  Actions    ## user_only  ### Variables  Actions    ## weighted_tasks  ### Variables  Actions  ","url":"wiki/BuiltInArchitectures.md"},{"id":"wiki/BuiltInSkills.md","title":" Built-in Skills","content":"Built-in Skills    This file is automatically generated from java files. Do Not Edit It.    Introduction  Skills are built-in modules, written in Java, that provide a set of related built-in variables and built-in actions (in addition to those already provided by GAMA) to the species that declare them. A declaration of skill is done by filling the skills attribute in the species definition:   species my_species skills: [skill1, skill2] {     ... }   Skills have been designed to be mutually compatible so that any combination of them will result in a functional species. An example of skill is the moving skill.  So, for instance, if a species is declared as:   species foo skills: [moving]{ ... }   Its agents will automatically be provided with the following variables : speed, heading, destination and the following actions: move, goto, wander, follow in addition to those built-in in species and declared by the modeller. Most of these variables, except the ones marked read-only, can be customized and modified like normal variables by the modeller. For instance, one could want to set a maximum for the speed; this would be done by redeclaring it like this:   float speed max:100 min:0;   Or, to obtain a speed increasing at each simulation step:   float speed max:100 min:0  <- 1 update: speed * 1.01;   Or, to change the speed in a behavior:   if speed = 5 {     speed <- 10; }     Table of Contents   advanced_driving, driving, fipa, GAMASQL, grid, MDXSKILL, messaging, moving, moving3D, network, physics, skill_road, skill_road_node, SQLSKILL,    ## advanced_driving  Variables     current_index (int): the current index of the agent target (according to the targets list)   current_lane (int): the current lane on which the agent is   current_path (path): the current path that tha agent follow   current_road (agent): current road on which the agent is   current_target (point): the current target of the agent   distance_to_goal (float): euclidean distance to the next point of the current segment   final_target (point): the final target of the agent   max_acceleration (float): maximum acceleration of the car for a cycle   max_speed (float): maximal speed of the vehicle   on_linked_road (boolean): is the agent on the linked road?   proba_block_node (float): probability to block a node (do not let other driver cross the crossroad)   proba_lane_change_down (float): probability to change lane to a lower lane (right lane if right side driving) if necessary   proba_lane_change_up (float): probability to change lane to a upper lane (left lane if right side driving) if necessary   proba_respect_priorities (float): probability to respect priority (right or left) laws   proba_respect_stops (list): probability to respect stop laws - one value for each type of stop   proba_use_linked_road (float): probability to change lane to a linked road lane if necessary   real_speed (float): the actual speed of the agent (in meter/second)   right_side_driving (boolean): are drivers driving on the right size of the road?   security_distance_coeff (float): the coefficient for the computation of the the min distance between two drivers (according to the vehicle speed - security_distance = 1#m + security_distance_coeff * real_speed )   segment_index_on_road (int): current segment index of the agent on the current road   speed (float): the speed of the agent (in meter/second)   speed_coeff (float): speed coefficient for the speed that the driver want to reach (according to the max speed of the road)   targets (list): the current list of points that the agent has to reach (path)   vehicle_length (float): the length of the vehicle (in meters)   Actions  advanced_follow_driving moves the agent towards along the path passed in the arguments while considering the other agents in the network (only for graph topology)     returns: float   path (path): a path to be followed.   target (point): the target to reach   speed (float): the speed to use for this move (replaces the current value of speed)   time (float): time to travel   compute_path action to compute a path to a target location according to a given graph     returns: path   graph (graph): the graph on wich compute the path   target (agent): the target node to reach   source (agent): the source node (optional, if not defined, closest node to the agent location)   on_road (agent): the road on which the agent is located (optional)   drive action to drive toward the final target     returns: void   drive_random action to drive by chosen randomly the next road     returns: void   proba_roads (map): a map containing for each road (key), the probability to be selected as next road (value)   external_factor_impact action that allows to define how the remaining time is impacted by external factor     returns: float   new_road (agent): the road on which to the driver wants to go   remaining_time (float): the remaining time   is_ready_next_road action to test if the driver can take the given road at the given lane     returns: bool   new_road (agent): the road to test   lane (int): the lane to test   lane_choice action to choose a lane     returns: int   new_road (agent): the road on which to choose the lane   path_from_nodes action to compute a path from a list of nodes according to a given graph     returns: path   graph (graph): the graph on wich compute the path   nodes (list): the list of nodes composing the path   speed_choice action to choose a speed     returns: float   new_road (agent): the road on which to choose the speed   test_next_road action to test if the driver can take the given road     returns: bool   new_road (agent): the road to test     ## driving  Variables     lanes_attribute (string): the name of the attribut of the road agent that determine the number of road lanes   living_space (float): the min distance between the agent and an obstacle (in meter)   obstacle_species (list): the list of species that are considered as obstacles   speed (float): the speed of the agent (in meter/second)   tolerance (float): the tolerance distance used for the computation (in meter)   Actions  follow_driving moves the agent along a given path passed in the arguments while considering the other agents in the network.     returns: path   speed (float): the speed to use for this move (replaces the current value of speed)   path (path): a path to be followed.   return_path (boolean): if true, return the path followed (by default: false)   move_weights (map): Weigths used for the moving.   living_space (float): min distance between the agent and an obstacle (replaces the current value of living_space)   tolerance (float): tolerance distance used for the computation (replaces the current value of tolerance)   lanes_attribute (string): the name of the attribut of the road agent that determine the number of road lanes (replaces the current value of lanes_attribute)   goto_driving moves the agent towards the target passed in the arguments while considering the other agents in the network (only for graph topology)     returns: path   target (geometry): the location or entity towards which to move.   speed (float): the speed to use for this move (replaces the current value of speed)   on (any type): list, agent, graph, geometry that restrains this move (the agent moves inside this geometry)   return_path (boolean): if true, return the path followed (by default: false)   move_weights (map): Weigths used for the moving.   living_space (float): min distance between the agent and an obstacle (replaces the current value of living_space)   tolerance (float): tolerance distance used for the computation (replaces the current value of tolerance)   lanes_attribute (string): the name of the attribut of the road agent that determine the number of road lanes (replaces the current value of lanes_attribute)     ## fipa The fipa skill offers some primitives and built-in variables which enable agent to communicate with each other using the FIPA interaction protocol.  Variables     accept_proposals (list): A list of  accept_proposal  performative messages of the agent s mailbox having .   agrees (list): A list of  accept_proposal  performative messages.   cancels (list): A list of  cancel  performative messages.   cfps (list): A list of  cfp  (call for proposal) performative messages.   conversations (list): A list containing the current conversations of agent. Ended conversations are automatically removed from this list.   failures (list): A list of  failure  performative messages.   informs (list): A list of  inform  performative messages.   proposes (list): A list of  propose  performative messages .   queries (list): A list of  query  performative messages.   refuses (list): A list of  propose  performative messages.   reject_proposals (list): A list of  reject_proposals  performative messages.   requests (list): A list of  request  performative messages.   requestWhens (list): A list of  request-when  performative messages.   subscribes (list): A list of  subscribe  performative messages.   Actions  accept_proposal Replies a message with an  accept_proposal  performative message.     returns: unknown   message (24): The message to be replied   contents (list): The content of the replying message   agree Replies a message with an  agree  performative message.     returns: unknown   message (24): The message to be replied   contents (list): The content of the replying message   cancel Replies a message with a  cancel  peformative message.     returns: unknown   message (24): The message to be replied   contents (list): The content of the replying message   cfp Replies a message with a  cfp  performative message.     returns: unknown   message (24): The message to be replied   contents (list): The content of the replying message   end_conversation Reply a message with an  end_conversation  peprformative message. This message marks the end of a conversation. In a  no-protocol  conversation, it is the responsible of the modeler to explicitly send this message to mark the end of a conversation/interaction protocol.     returns: unknown   message (24): The message to be replied   contents (list): The content of the replying message   failure Replies a message with a  failure  performative message.     returns: unknown   message (24): The message to be replied   contents (list): The content of the replying message   inform Replies a message with an  inform  performative message.     returns: unknown   message (24): The message to be replied   contents (list): The content of the replying message   propose Replies a message with a  propose  performative message.     returns: unknown   message (24): The message to be replied   contents (list): The content of the replying message   query Replies a message with a  query  performative message.     returns: unknown   message (24): The message to be replied   contents (list): The content of the replying message   refuse Replies a message with a  refuse  performative message.     returns: unknown   message (24): The message to be replied   contents (list): The contents of the replying message   reject_proposal Replies a message with a  reject_proposal  performative message.     returns: unknown   message (24): The message to be replied   contents (list): The content of the replying message   reply Replies a message. This action should be only used to reply a message in a  no-protocol  conversation and with a  user defined performative . For performatives supported by GAMA (i.e., standard FIPA performatives), please use the  action  with the same name of  performative . For example, to reply a message with a  request  performative message, the modeller should use the  request  action.     returns: unknown   message (24): The message to be replied   performative (string): The performative of the replying message   contents (list): The content of the replying message   request Replies a message with a  request  performative message.     returns: unknown   message (24): The message to be replied   contents (list): The content of the replying message   send Starts a conversation/interaction protocol.     returns: msi.gaml.extensions.fipa.FIPAMessage   to (list): A list of receiver agents   contents (list): The content of the message. A list of any GAML type   performative (string): A string, representing the message performative   protocol (string): A string representing the name of interaction protocol   start_conversation Starts a conversation/interaction protocol.     returns: msi.gaml.extensions.fipa.FIPAMessage   to (list): A list of receiver agents   contents (list): The content of the message. A list of any GAML type   performative (string): A string, representing the message performative   protocol (string): A string representing the name of interaction protocol   subscribe Replies a message with a  subscribe  performative message.     returns: unknown   message (24): The message to be replied   contents (list): The content of the replying message     ## GAMASQL  Variables  Actions  read     returns: void   params (map): Connection parameters   table (string): select string with question marks   filter (list): List of values that are used to replace question marks   SqlObject     returns: msi.gama.database.geosql.GamaSqlConnection   params (map): Connection parameters   table (string): select string with question marks   filter (string): Filter for select   testConnection     returns: bool   params (map): Connection parameters     ## grid  Variables     bands (list): Represents the values of the different bands of the cell (list of floating point value automatically set when the grid is initialized from a grid file)   color (rgb): Represents the color of the cell, used by default to represent the grid on displays   grid_value (float): Represents a floating point value (automatically set when the grid is initialized from a grid file, and used by default to represent the elevation of the cell when displaying it on a display)   grid_x (int): Returns the 0-based index of the column of the cell in the grid   grid_y (int): Returns the 0-based index of the row of the cell in the grid   neighbors (list): Represents the neighbor at distance 1 of the cell   Actions    ## MDXSKILL  Variables  Actions  select     returns: list   params (map): Connection parameters   onColumns (string): select string with question marks   onRows (list): List of values that are used to replace question marks   from (list): List of values that are used to replace question marks   where (list): List of values that are used to replace question marks   values (list): List of values that are used to replace question marks   testConnection     returns: bool   params (map): Connection parameters   timeStamp     returns: float     ## messaging A simple skill that provides agents with a mailbox than can be filled with messages  Variables     mailbox (list): The list of messages that can be consulted by the agent   Actions  send     returns: msi.gama.extensions.messaging.GamaMessage   to (any type): The agent, or server, to which this message will be sent to   contents (any type): The contents of the message, an arbitrary object     ## moving The moving skill is intended to define the minimal set of behaviours required for agents that are able to move on different topologies  Variables     current_edge (geometry): Represents the agent/geometry on which the agent is located (only used with a graph)   current_path (path): Represents the path on which the agent is moving on (goto action on a graph)   destination (point): Represents the next location of the agent if it keeps its current speed and heading (read-only)   heading (int): Represents the absolute heading of the agent in degrees.   location (point): Represents the current position of the agent   real_speed (float): Represents the actual speed of the agent (in meter/second)   speed (float): Represents the speed of the agent (in meter/second)   Actions  follow moves the agent along a given path passed in the arguments.     returns: path   speed (float): the speed to use for this move (replaces the current value of speed)   path (path): a path to be followed.   move_weights (map): Weights used for the moving.   return_path (boolean): if true, return the path followed (by default: false)   goto moves the agent towards the target passed in the arguments.     returns: path   target (geometry): the location or entity towards which to move.   speed (float): the speed to use for this move (replaces the current value of speed)   on (any type): graph, topology, list of geometries that restrain this move   recompute_path (boolean): if false, the path is not recompute even if the graph is modified (by default: true)   return_path (boolean): if true, return the path followed (by default: false)   move_weights (map): Weights used for the moving.   move moves the agent forward, the distance being computed with respect to its speed and heading. The value of the corresponding variables are used unless arguments are passed.     returns: path   speed (float): the speed to use for this move (replaces the current value of speed)   heading (int): the angle (in degree) of the target direction.   bounds (geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry   wander Moves the agent towards a random location at the maximum distance (with respect to its speed). The heading of the agent is chosen randomly if no amplitude is specified. This action changes the value of heading.     returns: void   speed (float): the speed to use for this move (replaces the current value of speed)   amplitude (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2)   bounds (geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry)   on (graph): the graph that restrains this move (the agent moves on the graph   proba_edges (map): When the agent moves on a graph, the probability to choose another edge. If not defined, each edge has the same probability to be chosen     ## moving3D The moving skill 3D is intended to define the minimal set of behaviours required for agents that are able to move on different topologies  Variables     destination (point): continuously updated destination of the agent with respect to its speed and heading (read-only)   heading (int): the absolute heading of the agent in degrees (in the range 0-359)   pitch (int): the absolute pitch of the agent in degrees (in the range 0-359)   roll (int): the absolute roll of the agent in degrees (in the range 0-359)   speed (float): the speed of the agent (in meter/second)   Actions  move moves the agent forward, the distance being computed with respect to its speed and heading. The value of the corresponding variables are used unless arguments are passed.     returns: path   speed (float): the speed to use for this move (replaces the current value of speed)   heading (int): int, optional, the direction to take for this move (replaces the current value of heading)   pitch (int): int, optional, the direction to take for this move (replaces the current value of pitch)   heading (int): int, optional, the direction to take for this move (replaces the current value of roll)   bounds (geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry     ## network  Variables     network_groups (list): Net ID of the agent   network_name (string): Net ID of the agent   network_server (list): Net ID of the agent   Actions  connect     returns: void   protocol (string): protocol type (udp, tcp, mqqt)   port (int): port number   with_name (string): server nameL   login (string): server nameL   password (string): server nameL   to (string): server URL   execute     returns: string   command (string): command to execute   fetch_message     returns: msi.gama.extensions.messaging.GamaMessage   has_more_message     returns: bool   leave_the_group leave a group of agent     returns: void   with_name (string): name of the group agent want to leave     ## physics  Variables     collisionBound (map):   density (float):   mass (float):   motor (point):   space (agent):   velocity (list):   Actions    ## skill_road  Variables     agents_on (list): for each lane of the road, the list of agents for each segment   all_agents (list): the list of agents on the road   lanes (int): the number of lanes   linked_road (-18): the linked road: the lanes of this linked road will be usable by drivers on the road   maxspeed (float): the maximal speed on the road   source_node (agent): the source node of the road   target_node (agent): the target node of the road   Actions  register register the agent on the road at the given lane     returns: void   agent (agent): the agent to register on the road.   lane (int): the lane index on which to register; if lane index >= number of lanes, then register on the linked road   unregister unregister the agent on the road     returns: void   agent (agent): the agent to unregister on the road.     ## skill_road_node  Variables     block (map): define the list of agents blocking the node, and for each agent, the list of concerned roads   priority_roads (list): the list of priority roads   roads_in (list): the list of input roads   roads_out (list): the list of output roads   stop (list): define for each type of stop, the list of concerned roads   Actions    ## SQLSKILL  Variables  Actions  executeUpdate     returns: int   params (map): Connection parameters   updateComm (string): SQL commands such as Create, Update, Delete, Drop with question mark   values (list): List of values that are used to replace question mark   getCurrentDateTime     returns: string   dateFormat (string): date format examples:  yyyy-MM-dd  ,  yyyy-MM-dd HH:mm:ss    getDateOffset     returns: string   dateFormat (string): date format examples:  yyyy-MM-dd  ,  yyyy-MM-dd HH:mm:ss    dateStr (string): Start date   offset (string): number on day to increase or decrease   insert     returns: int   params (map): Connection parameters   into (string): Table name   columns (list): List of column name of table   values (list): List of values that are used to insert into table. Columns and values must have same size   list2Matrix     returns: matrix   param (list): Param: a list of records and metadata   getName (boolean): getType: a boolean value, optional parameter   getType (boolean): getType: a boolean value, optional parameter   select     returns: container   params (map): Connection parameters   select (string): select string with question marks   values (list): List of values that are used to replace question marks   testConnection     returns: bool   params (map): Connection parameters   timeStamp     returns: float  ","url":"wiki/BuiltInSkills.md"},{"id":"wiki/BuiltInSpecies.md","title":" Built-in Species","content":"Built-in Species    This file is automatically generated from java files. Do Not Edit It.    It is possible to use in the models a set of built-in agents. These agents allow to directly use some advance features like clustering, multi-criteria analysis, etc. The creation of these agents are similar as for other kinds of agents:   create species: my_built_in_agent returns: the_agent;   So, for instance, to be able to use clustering techniques in the model:   create cluster_builder returns: clusterer;   Table of Contents   agent, AgentDB, base_edge, experiment, graph_edge, graph_node, model, physical_world,    ## agent  Actions  _init_     returns: unknown   _step_     returns: unknown     ## AgentDB  Actions  close     returns: unknown   connect   returns: unknown → params (map): Connection parameters      executeUpdate   returns: int      → updateComm (string): SQL commands such as Create, Update, Delete, Drop with question mark   → values (list): List of values that are used to replace question mark   getParameter     returns: unknown   insert   returns: int      → into (string): Table name   → columns (list): List of column name of table   → values (list): List of values that are used to insert into table. Columns and values must have same size   isConnected     returns: bool   select   returns: container      → select (string): select string   → values (list): List of values that are used to replace question marks   setParameter   returns: unknown → params (map): Connection parameters      testConnection   returns: bool → params (map): Connection parameters      timeStamp     returns: float     ## base_edge  Actions    ## experiment  Actions  update_outputs Forces all outputs to refresh, optionally recomputing their values * returns: unknown     → recompute (boolean): Whether or not to force the outputs to make a computation step     ## graph_edge  Actions    ## graph_node  Actions  related_to   returns: bool → other (agent): ## model  Actions  halt Allows to stop the current simulation so that cannot be continued after. All the behaviors and updates are stopped. * returns: unknown  pause Allows to pause the current simulation ACTUALLY EXPERIMENT FOR THE MOMENT. It can be set to continue with the manual intervention of the user. * returns: unknown    ## physical_world  Actions  compute_forces     returns: unknown  ","url":"wiki/BuiltInSpecies.md"},{"id":"wiki/DataTypes.md","title":" Types","content":"Types  A variable s or expression s type (or data type) determines the values it can take, plus the operations that can be performed on or with it. GAML is a statically-typed language, which means that the type of an expression is always known at compile time, and is even enforced with casting operations. There are 4 categories of types:     primitive types, declared as keyword in the language,   complex types, also declared as keyword in the language,   parametric types, a refinement of complex types (mainly children of container) that is dynamically constructed using an enclosing type, a contents type and a key type,   species types, dynamically constructed from the species declarations made by the modeler (and the built-in species present).   The hierarchy of types in GAML (only primitive and complex types are displayed here, of course, as the other ones are model-dependent) is the following:    Table of contents     Types (Under Construction)  Primitive built-in types   bool float int string   Complex built-in types   agent container file geometry graph list map matrix pair path point rgb species Species names as types topology   Defining custom types Primitive built-in types  bool    Definition: primitive datatype providing two values: true or false.   Litteral declaration: both true or false are interpreted as boolean constants.   Other declarations: expressions that require a boolean operand often directly apply a casting to bool to their operand. It is a convenient way to directly obtain a bool value.    bool (0) -> false  Top of the page  ### float   * Definition: primitive datatype holding floating point values, its absolute value is comprised between 4.9E-324 and 1.8E308.   * Comments: this datatype is internally backed up by the Java double datatype.   * Litteral declaration: decimal notation 123.45 or exponential notation 123e45 are supported.   * Other declarations: expressions that require an integer operand often directly apply a casting to float to their operand. Using it is a way to obtain a float constant.   float (12) -> 12.0  Top of the page  ### int   * Definition: primitive datatype holding integer values comprised between -2147483648 and 2147483647 (i.e. between -2^31 and 2^31 - 1.   * Comments: this datatype is internally backed up by the Java int datatype.   * Litteral declaration: decimal notation like 1, 256790 or hexadecimal notation like #1209FF are automatically interpreted.   * Other declarations: expressions that require an integer operand often directly apply a casting to int to their operand. Using it is a way to obtain an integer constant.   int (234.5) -> 234.  Top of the page  ### string   * Definition: a datatype holding a sequence of characters.   * Comments: this datatype is internally backed up by the Java String class. However, contrary to Java, strings are considered as a primitive type, which means they do not contain character objects. This can be seen when casting a string to a list using the list operator: the result is a list of one-character strings, not a list of characters.   * Litteral declaration: a sequence of characters enclosed in quotes, like  this is a string  . If one wants to literally declare strings that contain quotes, one has to double these quotes in the declaration. Strings accept escape characters like \\n (newline),   (carriage return),   (tabulation), as well as any Unicode character (\\uXXXX).   * Other declarations: see string   * Example: see string operators.  Top of the page  Complex built-in types  Contrarily to primitive built-in types, complex types have often various attributes. They can be accessed in the same way as attributes of agents:  complex_type nom_var <- init_var; ltype_attr attr_var <- nom_var.attr_name;  For example:  file fileText <- file(../data/cell.Data); bool fileTextReadable <- fileText.readable;   ### agent   * Definition: a generic datatype that represents an agent whatever its actual species.   * Comments: This datatype is barely used, since species can be directly used as datatypes themselves.   * Declaration: the agent casting operator can be applied to an int (to get the agent with this unique index), a string (to get the agent with this name).  Top of the page  ### container   * Definition: a generic datatype that represents a collection of data.   * Comments:  a container variable can be a list, a matrix, a map… Conversely each list, matrix and map is a kind of container. In consequence every container can be used in container-related operators.   * See also: Container operators   * Declaration:  container c  <- [1,2,3]; container c  <- matrix [[1,2,3],[4,5,6]]; container c  <- map [x::5, y::12]; container c  <- list species1;  Top of the page  ### file   * Definition: a datatype that represents a file.   * Built-in attributes:     * name (type = string): the name of the represented file (with its extension)     * extension(type = string): the extension of the file     * path (type = string): the absolute path of the file     * readable (type = bool, read-only): a flag expressing whether the file is readable     * writable (type = bool, read-only): a flag expressing whether the file is writable     * exists (type = bool, read-only): a flag expressing whether the file exists     * is_folder (type = bool, read-only): a flag expressing whether the file is folder     * contents (type = container): a container storing the content of the file   * Comments: a variable with the file type can handle any kind of file (text, image or shape files…). The type of the content attribute will depend on the kind of file. Note that the allowed kinds of file are the followings:     * text files: files with the extensions .txt, .data, .csv, .text, .tsv, .asc. The content is by default a list of string.     * image files: files with the extensions .pgm, .tif, .tiff, .jpg, .jpeg, .png, .gif, .pict, .bmp. The content is by default a matrix of int.     * shapefiles: files with the extension .shp. The content is by default a list of geometry.     * properties files: files with the extension .properties. The content is by default a map of string::string.     * folders. The content is by default a list of string.   * Remark: Files are also a particular kind of container and can thus be read, written or iterated using the container operators and commands.   * See also: File operators   * Declaration: a file can be created using the generic file (that opens a file in read only mode and tries to determine its contents), folder or the new_folder (to open an existing folder or create a new one) unary operators. But things can be specialized with the combination of the read/write and image/text/shapefile/properties unary operators.      folder(a_string)  // returns a file managing a existing folder file(a_string) // returns any kind of file in read-only mode read(text(a_string)) // returns a text file in read-only mode read(image(a_string)) // does the same with an image file. write(properties(a_string)) // returns a property file which is available for writing   // (if it exists, contents will be appended unless it is cleared   // using the standard container operations).       Top of the page  ### geometry   * Definition: a datatype that represents a vector geometry, i.e. a list of georeferenced points.   * Built-in attributes:     * location (type = point): the centroid of the geometry     * area (type = float): the area of the geometry     * perimeter (type = float): the perimeter of the geometry     * holes (type = list of geometry): the list of the hole inside the given geometry     * contour (type = geometry): the exterior ring of the given geometry and of his holes     * envelope (type = geometry): the geometry bounding box     * width (type = float): the width of the bounding box     * height (type = float): the height of the bounding box     * points (type = list of point): the set of the points composing the geometry   * Comments: a geometry can be either a point, a polyline or a polygon. Operators working on geometries handle transparently these three kinds of geometry. The envelope (a.k.a. the bounding box) of the geometry depends on the kind of geometry:     * If this Geometry is the empty geometry, it is an empty point.     * If the Geometry is a point, it is a non-empty point.     * Otherwise, it is a Polygon whose points are (minx, miny), (maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny).   * See also: Spatial operators   * Declaration: geometries can be built from a point, a list of points or by using specific operators (circle, square, triangle…).   geometry varGeom <- circle(5); geometry polygonGeom <- polygon([{3,5}, {5,6},{1,4}]);   Top of the page  ### graph   * Definition: a datatype that represents a graph composed of vertices linked by edges.   * Built-in attributes:     * edges(type = list of agent/geometry): the list of all edges     * vertices(type = list of agent/geometry): the list of all vertices     * circuit (type = path): an approximate minimal traveling salesman tour (hamiltonian cycle)     * spanning_tree (type = list of agent/geometry): minimum spanning tree of the graph, i.e. a sub-graph such as every vertex lies in the tree, and as much edges lies in it but no cycles (or loops) are formed.     * connected(type = bool): test whether the graph is connected   * Remark:     * graphs are also a particular kind of container and can thus be manipulated using the container operators and commands.     * This algorithm used to compute the circuit requires that the graph be complete and the triangle inequality exists (if x,y,z are vertices then d(x,y)+d(y,z)<d(x,z) for all x,y,z) then this algorithm will guarantee a hamiltonian cycle such that the total weight of the cycle is less than or equal to double the total weight of the optimal hamiltonian cycle.     * The computation of the spanning tree uses an implementation of  the Kruskal s minimum spanning tree algorithm. If the given graph is connected it computes the minimum spanning tree, otherwise it computes the minimum spanning forest.   * See also: Graph operators   * Declaration: graphs can be built from a list of vertices (agents or geometries) or from a list of edges (agents or geometries) by using specific operators. They are often used to deal with a road network and are built from a shapefile.      create road from: shape_file_road; graph the_graph <- as_edge_graph(road);  graph([1,9,5]) –: ([1: in[] + out[], 5: in[] + out[], 9: in[] + out[]], []) graph([node(0), node(1), node(2)]      // if node is a species graph([ a ::345,  b ::13])  –:  ([b: in[] + out[b::13], a: in[] + out[a::345], 13: in[b::13] + out[], 345: in[a::345] + out[]], [a::345=(a,345), b::13=(b,13)]) graph(a_graph)  –: a_graph graph(node1)    –: null      Top of the page  ### list   * Definition: a composite datatype holding an ordered collection of values.   * Comments: lists are more or less equivalent to instances of ArrayList in Java (although they are backed up by a specific class). They grow and shrink as needed, can be accessed via an index (see @ or index_of), support set operations (like union and difference), and provide the modeller with a number of utilities that make it easy to deal with collections of agents (see, for instance, shuffle, reverse,where,sort_by,…).   * Remark: lists can contain values of any datatypes, including other lists. Note, however, that due to limitations in the current parser, lists of lists cannot be declared litteraly; they have to be built using assignments. Lists are also a particular kind of container and can thus be manipulated using the container operators and commands.   * Litteral declaration: a set of expressions separated by commas, enclosed in square brackets, like [12, 14,  abc , self]. An empty list is noted .   * Other declarations: lists can be build litteraly from a point, or a string, or any other element by using the list casting operator.   list (1) -> [1]   list<int> myList <- [1,2,3,4];  myList[2] => 3  Top of the page  ### map   * Definition: a composite datatype holding an ordered collection of pairs (a key, and its associated value).   * Built-in attributes:     * keys (type = list): the list of all keys     * values (type = list): the list of all values     * pairs (type = list of pairs): the list of all pairs key::value   * Comments: maps are more or less equivalent to instances of Hashtable in Java (although they are backed up by a specific class).   * Remark: maps can contain values of any datatypes, including other maps or lists. Maps are also a particular kind of container and can thus be manipulated using the container operators and commands.   * Litteral declaration: a set of pair expressions separated by commas, enclosed in square brackets; each pair is represented by a key and a value sperarated by  :: . An example of map is [agentA:: big , agentB:: small , agentC:: big ]. An empty map is noted .   * Other declarations: lists can be built litteraly from a point, or a string, or any other element by using the map casting operator.   map (1) -> [1::1] map ({1,5}) -> [x::1, y::5] []   // empty map   Top of the page  ### matrix   * Definition: a composite datatype that represents either a two-dimension array (matrix) or a one-dimension array (vector), holding any type of data (including other matrices).   * Comments: Matrices are fixed-size structures that can be accessed by index (point for two-dimensions matrices, integer for vectors).   * Litteral declaration: Matrices cannot be defined literally. One-dimensions matrices can be built by using the matrix casting operator applied on a list. Two-dimensions matrices need to to be declared as variables first, before being filled.   //builds a one-dimension matrix, of size 5 matrix mat1 <- matrix ([10, 20, 30, 40, 50]); //  builds a two-dimensions matrix with 10 columns and 5 rows, where each cell is initialized to 0.0 matrix mat2 <- 0.0 as_matrix({10,5});  // builds a two-dimensions matrix with 2 columns and 3 rows, with initialized cells matrix mat3 <- matrix([[c11,c12,c13],[c21,c22,c23]]);   -> c11;c21 c12;c22 c13;c23  Top of the page  ### pair   * Definition: a datatype holding a key and its associated value.   * Built-in attributes:     * key (type = string): the key of the pair, i.e. the first element of the pair     * value (type = string): the value of the pair, i.e. the second element of the pair   * Remark: pairs are also a particular kind of container and can thus be manipulated using the container operators and commands.   * Litteral declaration: a pair is defined by a key and a value sperarated by  :: .   * Other declarations: a pair can also be built from:     * a point,     * a map (in this case the first element of the pair is the list of all the keys of the map and the second element is the list of all the values of the map),     * a list (in this case the two first element of the list are used to built the pair)   pair testPair <- key::56; pair testPairPoint <- {3,5};   // 3::5 pair testPairList2 <- [6,7,8]; // 6::7 pair testPairMap <- [2::6,5::8,12::45];  // [12,5,2]::[45,8,6]  Top of the page  ### path   * Definition: a datatype representing a path linking two agents or geometries in a graph.   * Built-in attributes:     * source (type = point): the source point, i.e. the first point of the path     * target (type = point): the target point, i.e. the last point of the path     * graph (type = graph): the current topology (in the case it is a spatial graph), null otherwise     * edges (type = list of agents/geometries) :  the edges of the graph composing the path     * vertices (type = list of agents/geometries) :  the vertices of the graph composing the path     * segments (type = list of geometries): the list of the geometries composing the path     * shape (type = geometry) : the global geometry of the path (polyline)   * Comments: the path created between two agents/geometries or locations will strongly depends on the topology in which it is created.   * Remark: a path is immutable, i.e. it can not be modified after it is created.   * Declaration: paths are very barely defined litterally. We can nevertheless use the path unary operator on a list of points to build a path. Operators dedicated to the computation of paths (such as path_to or path_between) are often used to build a path.      path([{1,5},{2,9},{5,8}]) // a path from {1,5} to {5,8} through {2,9}  geometry rect <- rectangle(5); geometry poly <- polygon([{10,20},{11,21},{10,21},{11,22}]); path pa <- rect path_to poly;  // built a path between rect and poly, in the topolopy      // of the current agent (i.e. a line in a& continuous topology,      // a path in a graph  in a graph topology )  a_topology path_between a_container_of_geometries // idem with an explicit topology and the possiblity     // to have more than 2 geometries     // (the path is then built incrementally)  path_between (a_graph, a_source, a_target) // idem with a the given graph as topology       Top of the page  ### point   * Definition: a datatype normally holding two positive float values. Represents the absolute coordinates of agents in the model.   * Built-in attributes:     * x (type = float): coordinate of the point on the x-axis     * y (type = float): coordinate of the point on the y-axis   * Comments: point coordinates should be positive, if a negative value is used in its declaration, the point is built with the absolute value.   * Remark: points are particular cases of geometries and containers. Thus they have also all the built-in attributes of both the geometry and the container datatypes and can be used with every kind of operator or command admitting geometry and container.   * Litteral declaration: two numbers, separated by a comma, enclosed in braces, like {12.3, 14.5}   * Other declarations: points can be built litteraly from a list, or from an integer or float value by using the point casting operator.   point ([12,123.45]) -> {12.0, 123.45}  point (2) -> {2.0, 2.0}  Top of the page  ### rgb   * Definition: a datatype that represents a color in the RGB space.   * Built-in attributes:     * red(type = int): the red component of the color     * green(type = int): the green component of the color     * blue(type = int): the blue component of the color     * darker(type = rgb): a new color that is a darker version of this color     * brighter(type = rgb): a new color that is a brighter version of this color   * Remark: rgbs are also a particular kind of container and can thus be manipulated using the container operators and commands.   * Litteral declaration: there exist lot of ways to declare a color. We use the rgb casting operator applied to:     * a string. The allowed color names are the constants defined in the Color Java class, i.e.: black, blue, cyan, darkGray, lightGray, gray, green, magenta, orange, pink, red, white, yellow.     * a list. The integer value associated to the three first elements of the list are used to define the three red (element 0 of the list), green (element 1 of the list) and blue (element 2 of the list) components of the color.     * a map. The red, green, blue compoenents take the value associated to the keys  r ,  g ,  b  in the map.     * an integer <- the decimal integer is translated into a hexadecimal <- OxRRGGBB. The red (resp. green, blue) component of the color take the value RR (resp. GG, BB) translated in decimal.     * Since GAMA 1.6.1, colors can be directly obtained like units, by using the ° or # symbol followed by the name in lowercase of one of the 147 CSS colors (see http://www.cssportal.com/css3-color-names/).   * Declaration:   rgb cssRed <- #red;   // Since 1.6.1 rgb testColor <- rgb( white );       // rgb [255,255,255] rgb test <- rgb(3,5,67);    // rgb [3,5,67] rgb te <- rgb(340); // rgb [0,1,84] rgb tete <- rgb([r::34, g::56, b::345]); // rgb [34,56,255]  Top of the page  ### species   * Definition: a generic datatype that represents a species   * Built-in attributes:     * topology (type=topology): the topology is which lives the population of agents   * Comments: this datatype is actually a  meta-type . It allows to manipulate (in a rather limited fashion, however) the species themselves as any other values.   * Litteral declaration: the name of a declared species is already a litteral declaration of species.   * Other declarations: the species casting operator, or its variant called species_of can be applied to an agent in order to get its species.  Top of the page  Species names as types  Once a species has been declared in a model, it automatically becomes a datatype. This means that :   * It can be used to declare variables, parameters or constants,   * It can be used as an operand to commands or operators that require species parameters,   * It can be used as a casting operator (with the same capabilities as the built-in type agent)  In the simple following example, we create a set of  humans  and initialize a random  friendship network  among them. See how the name of the species, human, is used in the create command, as an argument to the list casting operator, and as the type of the variable named friend.   global {     init {   create human number: 10;   ask human {      friend <- one_of (human - self);   }      } } entities {     species human {  human friend <- nil;     } }   Top of the page  ### topology   * Definition: a topology is basically on neighborhoods, distance,… structures in which agents evolves. It is the environment or the context in which all these values are computed. It also provides the access to the spatial index shared by all the agents. And it maintains a (eventually dynamic) link with the  environment  which is a geometrical border.   * Built-in attributes:     * places(type = container): the collection of places (geometry) defined by this topology.     * environment(type = geometry): the environment of this topology (i.e. the geometry that defines its boundaries)   * Comments: the attributes places depends on the kind of the considered topolopy.  For continuous topologies, it is a list with their environment. For discrete topologies, it can be any of the container supporting the inclusion of geometries (list, graph, map, matrix)   * Remark: There exist various kinds of topology: continuous topology and discrete topology (e.g. grid, graph…)   * Declaration: To create a topology, we can use the topology unary casting operator applied to:     * an agent: returns a continuous topology built from the agent s geometry     * a species name: returns the topology defined for this species population     * a geometry: returns a continuous topology built on this geometry     * a geometry container (list, map, shapefile): returns an half-discrete (with corresponding places), half-continuous topology (to compute distances…)     * a geometry matrix (i.e. a grid): returns a grid topology which computes specifically neighborhood and distances     * a geometry graph: returns a graph topology which computes specifically neighborhood and distances More complex topologies can also be built using dedicated operators, e.g. to decompose a geometry…  Top of the page  Defining custom types  Sometimes, besides the species of agents that compose the model, it can be necessary to declare custom datatypes. Species serve this purpose as well, and can be seen as  classes  that can help to instantiate simple  objects . In the following example, we declare a new kind of  object , bottle, that lacks the skills habitually associated with agents (moving, visible, etc.), but can nevertheless group together attributes and behaviors within the same closure. The following example demonstrates how to create the species:   species bottle {     float volume <- 0.0 max:1 min:0.0;     bool is_empty -> {volume = 0.0};     action fill {   volume <- 1.0;     } }   How to use this species to declare new bottles :   create bottle {     volume <- 0.5; }   And how to use bottles as any other agent in a species (a drinker owns a bottle; when he gets thirsty, it drinks a random quantity from it; when it is empty, it refills it):   species drinker {      ...     bottle my_bottle<- nil;     float quantity <- rnd (100) / 100;     bool thirsty <- false update: flip (0.1);     ...     action drink {   if condition: ! bottle.is_empty {     bottle.volume <-bottle.volume - quantity;     thirsty <- false;   }     }     ...     init { create bottle return: created_bottle;     volume <- 0.5; } my_bottle <- first(created_bottle);     }     ...     reflex filling_bottle when: bottle.is_empty {   ask  my_bottle {     do fill;   }     }     ...     reflex drinking when: thirsty {   do drink;     } }  Top of the page ","url":"wiki/DataTypes.md"},{"id":"wiki/ExperimentBuiltIn.md","title":" The 'experiment' built-in species (Under Construction)","content":"The  experiment  built-in species (Under Construction)  As described in the presentation of GAML, any experiment attached to a model is a species (introduced by the keyword experiment which directly or indirectly inherits from an abstract species called experiment itself. This abstract species (sub-species of agent) defines several attributes and actions that can then be used in any experiment.  experiment attributes experiment defines several attributes, which, in addition to the attributes inherited from agent, form the minimal set of knowledge any experiment will have access to.  experiment actions ","url":"wiki/ExperimentBuiltIn.md"},{"id":"wiki/Expressions.md","title":" Expressions","content":"Expressions  Expressions in GAML are the value part of the statements  facets. They represent or compute data that will be used as the value of the facet when the statement will be executed.  An expression can be either a literal, a unit, a constant, a variable, an attribute or the application of one or several operators to compose a complex expression. ","url":"wiki/Expressions.md"},{"id":"wiki/FileTypes.md","title":" File Types","content":"# File Types  GAMA provides modelers with a generic type for files called file. It is possible to load a file using the file operator:   file my_file <- file(../includes/data.csv);   However, internally, GAMA makes the difference between the different types of files. Indeed, for instance:  global {  init {   file my_file <- file(../includes/data.csv);   loop el over: my_file {    write el;   }  } }   will give:  sepallength sepalwidth petallength petalwidth type 5.1 3.5 1.4 0.2 Iris-setosa 4.9 3.0 1.4 0.2 Iris-setosa ...  Indeed, the content of CSV file is a matrix: each row of the matrix is a line of the file; each column of the matrix is value delimited by the separator (by default  , ).  In contrary:  global {  init {   file my_file <- file(../includes/data.shp);   loop el over: my_file {    write el;   }  } }   will give:  Polygon Polygon Polygon Polygon Polygon Polygon Polygon  The content of a shapefile is a list of geometries corresponding to the objects of the shapefile.  In order to know how to load a file, GAMA analyzes its extension. For instance for a file with a  .csv  extension, GAMA knows that the file is a csv one and will try to split each line with the , separator. However, if the modeler wants to split each line with a different separator (for instance ;) or load it as a text file, he/she will have to use a specific file operator.  Indeed, GAMA integrates specific operators corresponding to different types of files.  Table of contents     File Types  Text File   Extensions Content Operators   CSV File   Extensions Content Operators   Shapefile   Extensions Content Operators   OSM File   Extensions Content Operators   Grid File   Extensions Content Operators   Image File   Extensions Content Operators   SVG File   Extensions Content Operators   Property File   Extensions Content Operators   R File   Extensions Content Operators   3DS File   Extensions Content Operators   OBJ File   Extensions Content Operators       Text File ### Extensions Here the list of possible extensions for text file:   *  txt    *  data    *  csv    *  text    *  tsv    *  xml   Note that when trying to define the type of a file with the default file loading operator (file), GAMA will first try to test the other type of file. For example, for files with  .csv  extension, GAMA will cast them as csv file and not as text file.  Content The content of a text file is a list of string corresponding to each line of the text file. For example:  global {  init {   file my_file <- text_file(../includes/data.txt);   loop el over: my_file {    write el;   }  } }   will give:  sepallength,sepalwidth,petallength,petalwidth,type 5.1,3.5,1.4,0.2,Iris-setosa 4.9,3.0,1.4,0.2,Iris-setosa 4.7,3.2,1.3,0.2,Iris-setosa   Operators List of operators related to text files:   * text_file(string path): load a file (with an authorized extension) as a text file.   * text_file(string path, list content): load a file (with an authorized extension) as a text file and fill it with the given content.   * is_text(op): tests whether the operand is a text file  CSV File ### Extensions Here the list of possible extensions for csv file:     *  csv      *  tsv   Content The content of a csv file is a matrix of string: each row of the matrix is a line of the file; each column of the matrix is value delimited by the separator (by default  , ). For example:  global {  init {   file my_file <- csv_file(../includes/data.csv);   loop el over: my_file {    write el;   }  } }   will give:  sepallength sepalwidth petallength petalwidth type 5.1 3.5 1.4 0.2 Iris-setosa 4.9 3.0 1.4 0.2 Iris-setosa ...   Operators List of operators related to csv files:   * csv_file(string path): load a file (with an authorized extension) as a csv file with default separator ( , ).   * csv_file(string path, string separator): load a file (with an authorized extension) as a csv file with the given separator.  file my_file <- csv_file(../includes/data.csv, ;);      csv_file(string path, matrix content): load a file (with an authorized extension) as a csv file and fill it with the given content.   is_csv(op): tests whether the operand is a csv file   Shapefile Shapefiles are classical GIS data files. A shapefile is not simple file, but a set of several files (source: wikipedia):   * Mandatory files :     * .shp — shape format; the feature geometry itself     * .shx — shape index format; a positional index of the feature geometry to allow seeking forwards and backwards quickly     * .dbf — attribute format; columnar attributes for each shape, in dBase IV format     Optional files :  .prj — projection format; the coordinate system and projection information, a plain text file describing the projection using well-known text format       .sbn and .sbx — a spatial index of the features       .fbn and .fbx — a spatial index of the features for shapefiles that are read-only       .ain and .aih — an attribute index of the active fields in a table       .ixs — a geocoding index for read-write shapefiles       .mxs — a geocoding index for read-write shapefiles (ODB format)       .atx — an attribute index for the .dbf file in the form of shapefile.columnname.atx (ArcGIS 8 and later)       .shp.xml — geospatial metadata in XML format, such as ISO 19115 or other XML schema       .cpg — used to specify the code page (only for .dbf) for identifying the character encoding to be used More details about shapefiles can be found here.  Extensions Here the list of possible extension for shapefile:   *  shp   Content The content of a shapefile is a list of geometries corresponding to the objects of the shapefile. For example:  global {  init {   file my_file <- shape_file(../includes/data.shp);   loop el over: my_file {    write el;   }  } }   will give:  Polygon Polygon Polygon Polygon Polygon Polygon Polygon ...   Note that the attributes of each object of the shapefile is stored in their corresponding GAMA geometry. The operator  get  (or  read ) allows to get the value of a corresponding attributes.  For example:  file my_file <- shape_file(../includes/data.shp); write my_file:  + my_file.contents; loop el over: my_file {  write (el get TYPE); }   Operators List of operators related to shapefiles:   * shape_file(string path): load a file (with an authorized extension) as a shapefile with default projection (if a prj file is defined, use it, otherwise use the default projection defined in the preference).   * shape_file(string path, string code): load a file (with an authorized extension) as a shapefile with the given projection (GAMA will automatically decode the code. For a list of the possible projections see: http://spatialreference.org/ref/)   * shape_file(string path, int EPSG_ID): load a file (with an authorized extension) as a shapefile with the given projection (GAMA will automatically decode the epsg code. For a list of the possible projections see: http://spatialreference.org/ref/)  file my_file <- shape_file(../includes/data.shp, EPSG:32601);      shape_file(string path, list content): load a file (with an authorized extension) as a shapefile and fill it with the given content.   is_shape(op): tests whether the operand is a shapefile   OSM File OSM (Open Street Map) is a collaborative project to create a free editable map of the world. The data produced in this project (OSM File)  represent physical features on the ground (e.g., roads or buildings) using tags attached to its basic data structures (its nodes, ways, and relations). Each tag describes a geographic attribute of the feature being shown by that specific node, way or relation (source: openstreetmap.org).  More details about OSM data can be found here.  Extensions Here the list of possible extension for shapefile:   *  osm    *  pbf    *  bz2    *  gz   Content The content of a OSM data is a list of geometries corresponding to the objects of the OSM file. For example:  global {  init {   file my_file <- osm_file(../includes/data.gz);   loop el over: my_file {    write el;   }  } }   will give:  Point Point Point Point Point LineString LineString Polygon Polygon Polygon ...   Note that like for shapefiles, the attributes of each object of the osm file is stored in their corresponding GAMA geometry. The operator  get  (or  read ) allows to get the value of a corresponding attributes.  Operators List of operators related to osm file:   * osm_file(string path): load a file (with an authorized extension) as a osm file with default projection (if a prj file is defined, use it, otherwise use the default projection defined in the preference). In this case, all the nodes and ways of the OSM file will becomes a geometry.   * osm_file(string path, string code): load a file (with an authorized extension) as a osm file with the given projection (GAMA will automatically decode the code. For a list of the possible projections see: http://spatialreference.org/ref/). In this case, all the nodes and ways of the OSM file will becomes a geometry.   * osm_file(string path, int EPSG_ID): load a file (with an authorized extension) as a osm file with the given projection (GAMA will automatically decode the epsg code. For a list of the possible projections see: http://spatialreference.org/ref/). In this case, all the nodes and ways of the OSM file will becomes a geometry.  file my_file <- osm_file(../includes/data.gz, EPSG:32601);    * osm_file(string path, map filter): load a file (with an authorized extension) as a osm file with default projection (if a prj file is defined, use it, otherwise use the default projection defined in the preference). In this case, only the elements with the defined values are loaded from the file.     //map used to filter the object to build from the OSM file according to attributes.  map filtering <- map([ highway ::[ primary ,  secondary ,  tertiary ,  motorway ,  living_street , residential ,  unclassified ],  building ::[ yes ]]);  //OSM file to load file osmfile <-  file<geometry (osm_file(../includes/rouen.gz, filtering))  ;       * **osm\\_file(string path, map filter, string code)**: load a file (with an authorized extension) as a osm file with the given projection (GAMA will automatically decode the code. For a list of the possible projections see: http://spatialreference.org/ref/). In this case, only the elements with the defined values are loaded from the file.   * **osm\\_file(string path, map filter, int EPSG\\_ID)**: load a file (with an authorized extension) as a osm file with the given projection (GAMA will automatically decode the epsg code. For a list of the possible projections see: http://spatialreference.org/ref/). In this case, only the elements with the defined values are loaded from the file.   * **is\\_osm(op)**: tests whether the operand is a osm file  Grid File Esri ASCII Grid files are classic text raster GIS data.  More details about Esri ASCII grid file can be found here.  Note that grid files can be used to initialize a grid species. The number of rows and columns will be read from the file. Similarly, the values of each cell contained in the grid file will be accessible through the grid_value attribute.   grid cell file: grid_file { }   Extensions Here the list of possible extension for grid file:   *  asc   Content The content of a grid file is a list of geometries corresponding to the cells of the grid. For example:  global {  init {   file my_file <- grid_file(../includes/data.asc);   loop el over: my_file {    write el;   }  } }   will give:  Polygon Polygon Polygon Polygon Polygon Polygon Polygon ...   Note that the values of each cell of the grid file is stored in their corresponding GAMA geometry (grid_value attribute). The operator  get  (or  read ) allows to get the value of this attribute.  For example:  file my_file <- grid_file(../includes/data.asc); write my_file:  + my_file.contents; loop el over: my_file {  write el get grid_value; }   Operators List of operators related to shapefiles:   * grid_file(string path): load a file (with an authorized extension) as a grid file with default projection (if a prj file is defined, use it, otherwise use the default projection defined in the preference).   * grid_file(string path, string code): load a file (with an authorized extension) as a grid file with the given projection (GAMA will automatically decode the code. For a list of the possible projections see: http://spatialreference.org/ref/)   * grid_file(string path, int EPSG_ID): load a file (with an authorized extension) as a grid file with the given projection (GAMA will automatically decode the epsg code. For a list of the possible projections see: http://spatialreference.org/ref/)  file my_file <- grid_file(../includes/data.shp, EPSG:32601);      is_grid(op): tests whether the operand is a grid file.   Image File ### Extensions Here the list of possible extensions for image file:   *  tif    *  tiff    *  jpg    *  jpeg    *  png    *  gif    *  pict    *  bmp   Content The content of an image file is a matrix of int: each pixel is a value in the matrix.  For example:  global {  init {   file my_file <- image_file(../includes/DEM.png);   loop el over: my_file {    write el;   }  } }   will give:  -9671572 -9671572 -9671572 -9671572 -9934744 -9934744 -9868951 -9868951 -10000537 -10000537 ...   Operators List of operators related to csv files:   * image_file(string path): load a file (with an authorized extension) as an image file.   * image_file(string path, matrix content): load a file (with an authorized extension) as an image file and fill it with the given content.   * is_image(op): tests whether the operand is an image file  SVG File  Scalable Vector Graphics (SVG) is an XML-based vector image format for two-dimensional graphics with support for interactivity and animation. Note that interactivity and animation features are not supported in GAMA.  More details about SVG file can be found here.  Extensions Here the list of possible extension for SVG file:   *  svg   Content The content of a SVG file is a list of geometries. For example:  global {  init {   file my_file <- svg_file(../includes/data.svg);   loop el over: my_file {    write el;   }  } }   will give:  Polygon   Operators List of operators related to svg files:   * shape_file(string path): load a file (with an authorized extension) as a SVG file.   * shape_file(string path, point size): load a file (with an authorized extension) as a SVG file with the given size:   file my_file <- svg_file(../includes/data.svg, {5.0,5.0});      is_svg(op): tests whether the operand is a SVG file   Property File ### Extensions Here the list of possible extensions for property file:   *  properties   Content The content of a property file is a map of string corresponding to the content of the file. For example:  global {  init {   file my_file <- property_file(../includes/data.properties);   loop el over: my_file {    write el;   }  } }  with the given property file:  sepallength = 5.0 sepalwidth = 3.0 petallength = 4.0 petalwidth = 2.5 type = Iris-setosa   will give:  3.0 4.0 5.0 Iris-setosa 2.5   Operators List of operators related to text files:   * property_file(string path): load a file (with an authorized extension) as a property file.   * is_property(op): tests whether the operand is a property file  R File R is a free software environment for statistical computing and graphics. GAMA allows to execute R script (if R is installed on the computer).  More details about R can be found here.  Note that GAMA also integrates some operators to manage R scripts:   * R_compute   * R_compute_param  Extensions Here the list of possible extensions for R file:   *  r   Content The content of a R file corresponds to the results of the application of the script contained in the file.  For example:  global {  init {   file my_file <- R_file(../includes/data.r);   loop el over: my_file {    write el;   }  } }   will give:  3.0   Operators List of operators related to R files:   * R_file(string path): load a file (with an authorized extension) as a R file.   * is_R(op): tests whether the operand is a R file.  3DS File  3DS is one of the file formats used by the Autodesk 3ds Max 3D modeling, animation and rendering software. 3DS files can be used in GAMA to load 3D geometries.  More details about 3DS file can be found here.  Extensions Here the list of possible extension for 3DS file:   *  3ds    *  max   Content The content of a 3DS file is a list of geometries. For example:  global {  init {   file my_file <- threeds_file(../includes/data.3ds);   loop el over: my_file {    write el;   }  } }   will give:  Polygon   Operators List of operators related to 3ds files:   * threeds_file(string path): load a file (with an authorized extension) as a 3ds file.   * is_threeds(op): tests whether the operand is a 3DS file  OBJ File OBJ file is a geometry definition file format first developed by Wavefront Technologies for its Advanced Visualizer animation package. The file format is open and has been adopted by other 3D graphics application vendors.  More details about Obj file can be found here.  Extensions Here the list of possible extension for OBJ files:   *  obj   Content The content of a OBJ file is a list of geometries. For example:  global {  init {   file my_file <- obj_file(../includes/data.obj);   loop el over: my_file {    write el;   }  } }   will give:  Polygon   Operators List of operators related to obj files:   * obj_file(string path): load a file (with an authorized extension) as a obj file.   * is_obj(op): tests whether the operand is a OBJ file //: # (endConcept|load_complex_datas) ","url":"wiki/FileTypes.md"},{"id":"wiki/Literals.md","title":" Literals","content":"Literals  (some literal expressions are also described in data types)  A literal is a way to specify an unnamed constant value corresponding to a given data type. GAML supports various types of literals for often — or less often — used data types.  Table of contents     Literals  Simple Types       Literal Constructors       Universal Literal Simple Types Values of simple (i.e. not composed) types can all be expressed using literal expressions. Namely:     bool: true and false.   int: decimal value, such as 100, or hexadecimal value if preceded by  #  (e.g. #AAAAAA, which returns the int 11184810)   float: the value in plain digits, using  .  for the decimal point (e.g. 123.297)   string: a sequence of characters enclosed between quotes ( my string ) or double quotes (my string)   Literal Constructors Although they are not strictly literals in the sense given above, some special constructs (called literal constructors) allow the modeler to declare constants of other data types. They are actually operators but can be thought of literals when used with constant operands.     pair: the key and the value separated by :: (e.g. 12:: abc )   list: the elements, separated by commas, enclosed inside square brackets (e.g. [12,15,15])   map: a list of pairs (e.g. [12:: abc , 13:: def ])   point: 2 or 3 int or float ordinates enclosed inside curly brackets (e.g. {10.0,10.0,10.0})   ## Universal Literal Finally, a special literal, of type unknown, is shared between the data types and all the agent types (aka species). Only bool, int and float, which do not derive from unknown, do not accept this literal. All the others will accept it (e.g. string s <- nil; is ok).     unknown: nil, which represents the non-initialized (or, literally, unknown) value.  ","url":"wiki/Literals.md"},{"id":"wiki/ModelBuiltIn.md","title":" The 'model' built-in species (Under Construction)","content":"The  model  built-in species (Under Construction)  As described in the presentation of GAML, any model in GAMA is a species (introduced by the keyword global) which directly inherits from an abstract species called model. This abstract species (sub-species of agent) defines several attributes and actions that can then be used in any global section of any model.  model attributes model defines several attributes, which, in addition to the attributes inherited from agent, form the minimal set of knowledge a model can manipulate.   *  model actions ","url":"wiki/ModelBuiltIn.md"},{"id":"wiki/Operators.md","title":" Operators ","content":"Operators    This file is automatically generated from java files. Do Not Edit It.    Definition  Operators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function.  Most of them use a classical prefixed functional syntax (i.e. operator_name(operand1, operand2, operand3), see below), with the exception of arithmetic (e.g. +, /), logical (and, or), comparison (e.g. >, <), access (., [..]) and pair (::) operators, which require an infixed notation (i.e. operand1 operator_symbol operand1).  The ternary functional if-else operator, ? :, uses a special infixed syntax composed with two symbols (e.g. operand1 ? operand2 : operand3). Two unary operators (- and !) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g.   - 10, ! (operand1 or operand2) ).  Finally, special constructor operators ({...} for constructing points, [...] for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. {1,2,3}, [operand1, operand2, ..., operandn] or [key1::value1, key2::value2... keyn::valuen]).  With the exception of these special cases above, the following rules apply to the syntax of operators: * if they only have one operand, the functional prefixed syntax is mandatory (e.g. operator_name(operand1)) * if they have two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2)) or the infixed syntax (e.g. operand1 operator_name operand2) can be used. * if they have more than two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2, ..., operand)) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. operand1 operator_name(operand2, ..., operand)) can be used.  All of these alternative syntaxes are completely equivalent.  Operators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.    Priority between operators  The priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.  GAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely: * the constructor operators, like ::, used to compose pairs of operands, have the lowest priority of all operators (e.g. a > b :: b > c will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, [a > 10, b > 5] will return a list of boolean values. * it is followed by the ?: operator, the functional if-else (e.g.   a > b ? a + 10 : a - 10 will return the result of the if-else). * next are the logical operators, and and or (e.g. a > b or b > c will return the value of the test) * next are the comparison operators (i.e. >, <, <=, >=, =, !=) * next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators) * next the unary operators - and ! * next the access operators . and [] (e.g. {1,2,3}.x > 20 + {4,5,6}.y  will return the result of the comparison between the x and y ordinates of the two points) * and finally the functional operators, which have the highest priority of all.    Using actions as operators  Actions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.  For instance, if the following species is defined:   species spec1 {  int min(int x, int y) {       return x > y ? x : y;  } }   Any agent instance of spec1 can use min as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:   global {  init {       create spec1;       spec1 my_agent <- spec1[0];       int the_min <- my_agent min(10,20); // or min(my_agent, 10, 20);  } }   If the action doesn t have any operands, the syntax to use is my_agent the_action(). Finally, if it does not return a value, it might still be used but is considering as returning a value of type unknown (e.g. unknown result <- my_agent the_action(op1, op2);).  Note that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).    Table of Contents    Operators by categories    3D box, cone3D, cube, cylinder, dem, hexagon, pyramid, rgb_to_xyz, set_z, sphere, teapot,    Arithmetic operators -, /, [^](#^), [](#), +, abs, acos, asin, atan, atan2, ceil, cos, cos_rad, div, even, exp, fact, floor, hypot, is_finite, is_number, ln, log, mod, round, signum, sin, sin_rad, sqrt, tan, tan_rad, tanh, with_precision,    BDI and, eval_when, get_about, get_agent, get_agent_cause, get_decay, get_dominance, get_familiarity, get_intensity, get_lifetime, get_liking, get_praiseworthiness, get_priority, get_solidarity, get_super_intention, new_emotion, new_predicate, new_social_link, or, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_liking, set_solidarity, set_truth, with_lifetime, with_praiseworthiness, with_priority, with_values,    Casting operators as, as_int, as_matrix, font, is, is_skill, list_with, matrix_with, species, to_gaml, topology,    Color-related operators -, /, [](#), +, blend, brewer_colors, brewer_palettes, grayscale, hsb, mean, median, rgb, rnd_color, sum,    Comparison operators !=, <, <=, =, >, >=, between,    Containers-related operators -, ::, +, accumulate, among, at, collect, contains, contains_all, contains_any, count, distinct, empty, every, first, first_with, get, group_by, in, index_by, inter, interleave, internal_at, internal_integrated_value, last, last_with, length, max, max_of, mean, mean_of, median, min, min_of, mul, one_of, product_of, range, reverse, shuffle, sort_by, sum, sum_of, union, variance_of, where, with_max_of, with_min_of,    Date-related operators -, !=, +, <, <=, =, >, >=, after, before, between, every, milliseconds_between, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_weeks, minus_years, months_between, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_weeks, plus_years, since, to, until, years_between,    Dates    Driving operators as_driving_graph,    edge edge_between,    EDP-related operators diff, diff2, internal_zero_order_equation,    Files-related operators crs, file, file_exists, folder, get, new_folder, osm_file, read, writable,    FIPA-related operators conversation, message,    Graphs-related operators add_edge, add_node, adjacency, agent_from_geometry, all_pairs_shortest_path, alpha_index, as_distance_graph, as_edge_graph, as_intersection_graph, as_path, beta_index, betweenness_centrality, biggest_cliques_of, connected_components_of, connectivity_index, contains_edge, contains_vertex, degree_of, directed, edge, edge_between, edge_betweenness, edges, gamma_index, generate_barabasi_albert, generate_complete_graph, generate_watts_strogatz, grid_cells_to_graph, in_degree_of, in_edges_of, layout, load_graph_from_file, load_shortest_paths, maximal_cliques_of, nb_cycles, neighbors_of, node, nodes, out_degree_of, out_edges_of, path_between, paths_between, predecessors_of, remove_node_from, rewire_n, source_of, spatial_graph, successors_of, sum, target_of, undirected, use_cache, weight_of, with_optimizer_type, with_weights,    Grid-related operators as_4_grid, as_grid, as_hexagonal_grid, grid_at, path_between,    Iterator operators accumulate, as_map, collect, count, distribution_of, distribution_of, distribution_of, distribution2d_of, distribution2d_of, distribution2d_of, first_with, frequency_of, group_by, index_by, last_with, max_of, mean_of, min_of, product_of, sort_by, sum_of, variance_of, where, with_max_of, with_min_of,    List-related operators copy_between, index_of, last_index_of,    Logical operators :, !, ?, and, or,    Map comparaison operators fuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,    Map-related operators as_map, index_of, last_index_of,    Material material,    Matrix-related operators -, /, ., [](#), +, append_horizontally, append_vertically, column_at, columns_list, determinant, eigenvalues, index_of, inverse, last_index_of, row_at, rows_list, shuffle, trace, transpose,    multicriteria operators electre_DM, evidence_theory_DM, promethee_DM, weighted_means_DM,    Path-related operators agent_from_geometry, all_pairs_shortest_path, as_path, load_shortest_paths, path_between, path_to, paths_between, use_cache,    Points-related operators -, /, [](#), +, <, <=, >, >=, add_point, angle_between, any_location_in, centroid, closest_points_with, farthest_point_to, grid_at, norm, point, points_along, points_at, points_on,    Random operators binomial, flip, gauss, poisson, rnd, rnd_choice, sample, shuffle, skew_gauss, truncated_gauss,    ReverseOperators    Shape arc, box, circle, cone, cone3D, cross, cube, curve, cylinder, ellipse, envelope, geometry_collection, hexagon, line, link, plan, polygon, polyhedron, pyramid, rectangle, sphere, square, squircle, teapot, triangle,    Spatial operators -, [](#), +, add_point, agent_closest_to, agent_farthest_to, agents_at_distance, agents_inside, agents_overlapping, angle_between, any_location_in, arc, around, as_4_grid, as_grid, as_hexagonal_grid, at_distance, at_location, box, centroid, circle, clean, closest_points_with, closest_to, cone, cone3D, convex_hull, covers, cross, crosses, crs, CRS_transform, cube, curve, cylinder, dem, direction_between, disjoint_from, distance_between, distance_to, ellipse, envelope, farthest_point_to, farthest_to, geometry_collection, gini, hexagon, hierarchical_clustering, IDW, inside, inter, intersects, line, link, masked_by, moran, neighbors_at, neighbors_of, overlapping, overlaps, partially_overlaps, path_between, path_to, plan, points_along, points_at, points_on, polygon, polyhedron, pyramid, rectangle, rgb_to_xyz, rotated_by, round, scaled_to, set_z, simple_clustering_by_distance, simplification, skeletonize, smooth, sphere, split_at, split_geometry, split_lines, square, squircle, teapot, to_GAMA_CRS, to_rectangles, to_squares, touches, towards, transformed_by, translated_by, triangle, triangulate, union, using, voronoi, with_precision, without_holes,    Spatial properties operators covers, crosses, intersects, partially_overlaps, touches,    Spatial queries operators agent_closest_to, agent_farthest_to, agents_at_distance, agents_inside, agents_overlapping, at_distance, closest_to, farthest_to, inside, neighbors_at, neighbors_of, overlapping,    Spatial relations operators direction_between, distance_between, distance_to, path_between, path_to, towards,    Spatial statistical operators hierarchical_clustering, simple_clustering_by_distance,    Spatial transformations operators -, [](#), +, as_4_grid, as_grid, as_hexagonal_grid, at_location, clean, convex_hull, CRS_transform, rotated_by, scaled_to, simplification, skeletonize, smooth, split_geometry, split_lines, to_GAMA_CRS, to_rectangles, to_squares, transformed_by, translated_by, triangulate, voronoi, without_holes,    Species-related operators index_of, last_index_of, of_generic_species, of_species,    Statistical operators build, corR, dbscan, distribution_of, distribution2d_of, frequency_of, gamma_rnd, geometric_mean, gini, harmonic_mean, hierarchical_clustering, kmeans, kurtosis, max, mean, mean_deviation, meanR, median, min, moran, mul, predict, simple_clustering_by_distance, skewness, standard_deviation, sum, variance,    Strings-related operators +, <, <=, >, >=, at, char, contains, contains_all, contains_any, copy_between, date, empty, first, in, indented_by, index_of, is_number, last, last_index_of, length, lower_case, replace, replace_regex, reverse, sample, shuffle, split_with, string, upper_case,    System ., command, copy, dead, eval_gaml, every, user_input,    Time-related operators date, string,    Types-related operators    User control operators user_input,    Operators    ### -  Possible use:    - (int) —>  int   - (point) —>  point   - (float) —>  float   int - float —>  float   - (int , float) —>  float   int - int —>  int   - (int , int) —>  int   matrix - float —>  matrix   - (matrix , float) —>  matrix   float - matrix —>  matrix   - (float , matrix) —>  matrix   date - float —>  date   - (date , float) —>  date   species - agent —>  container   - (species , agent) —>  container   date - date —>  float   - (date , date) —>  float   matrix - matrix —>  matrix   - (matrix , matrix) —>  matrix   point - int —>  point   - (point , int) —>  point   date - int —>  date   - (date , int) —>  date   point - float —>  point   - (point , float) —>  point   float - float —>  float   - (float , float) —>  float   rgb - rgb —>  rgb   - (rgb , rgb) —>  rgb   int - matrix —>  matrix   - (int , matrix) —>  matrix   container - container —>  container   - (container , container) —>  container   rgb - int —>  rgb   - (rgb , int) —>  rgb   container - unknown —>  container   - (container , unknown) —>  container   point - point —>  point   - (point , point) —>  point   float - int —>  float   - (float , int) —>  float   geometry - geometry —>  geometry   - (geometry , geometry) —>  geometry   matrix - int —>  matrix   - (matrix , int) —>  matrix   geometry - float —>  geometry   - (geometry , float) —>  geometry   map - map —>  map   - (map , map) —>  map   map - pair —>  map   - (map , pair) —>  map   geometry - container<geometry> —>  geometry   - (geometry , container<geometry>) —>  geometry   Result: Returns the difference of the two operands. If it is used as an unary operator, it returns the opposite of the operand.  Comment: The behavior of the operator depends on the type of the operands.  Special cases:    if the left operand is a species and the right operand is an agent of the species, - returns a list containing all the agents of the species minus this agent   if both operands are containers and the right operand is empty, - returns the left operand   if both operands are numbers, performs a normal arithmetic difference and returns a float if one of them is a float.       int var7 <- 1 - 1;  // var7 equals 0 int var8 <- 1.0 - 1;  // var8 equals 0.0 int var9 <- 3.7 - 1.2;  // var9 equals 2.5 int var10 <- 3 - 1.2;  // var10 equals 1.8          if both operands are dates, returns the duration in seconds between  date2 and date1. To obtain a more precise duration, in milliseconds, use milliseconds_between(date1, date2)       float var11 <- date1 - date2;  // var11 equals 598          if one of the operands is a date and the other a number, returns a date corresponding to the date minus the given number as duration (in seconds)       date1 - 200          if left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the difference of the operand coordinate with this number.       point var13 <- {1, 2} - 4.5;  // var13 equals {-3.5, -2.5, -4.5} point var14 <- {1, 2} - 4;  // var14 equals {-3.0,-2.0,-4.0}          if both operands are colors, returns a new color resulting from the subtraction of the two operands, component by component       rgb var15 <- rgb([255, 128, 32]) - rgb( red );  // var15 equals rgb([0,128,32])          if one operand is a matrix and the other a number (float or int), performs a normal arithmetic difference of the number with each element of the matrix (results are float if the number is a float.       matrix var16 <- 3.5 - matrix([[2,5],[3,4]]);  // var16 equals matrix([[1.5,-1.5],[0.5,-0.5]])          if both operands are containers, returns a new list in which all the elements of the right operand have been removed from the left one       list var17 <- [1,2,3,4,5,6] - [2,4,9];  // var17 equals [1,3,5,6] list var18 <- [1,2,3,4,5,6] - [0,8];  // var18 equals [1,2,3,4,5,6]          if one operand is a color and the other an integer, returns a new color resulting from the subtraction of each component of the color with the right operand       rgb var19 <- rgb([255, 128, 32]) - 3;  // var19 equals rgb([252,125,29])          if the left operand is a list and the right operand is an object of any type (except list), - returns a list containing the elements of the left operand minus all the occurrences of this object       list var20 <- [1,2,3,4,5,6] - 2;  // var20 equals [1,3,4,5,6] list var21 <- [1,2,3,4,5,6] - 0;  // var21 equals [1,2,3,4,5,6]          if both operands are points, returns their difference (coordinates per coordinates).       point var22 <- {1, 2} - {4, 5};  // var22 equals {-3.0, -3.0}          if both operands are a point, a geometry or an agent, returns the geometry resulting from the difference between both geometries       geometry var23 <- geom1 - geom2;  // var23 equals a geometry corresponding to difference between geom1 and geom2          if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) reduced by the right-hand operand distance       geometry var24 <- shape - 5;  // var24 equals a geometry corresponding to the geometry of the agent applying the operator reduced by a distance of 5          if the right-operand is a list of points, geometries or agents, returns the geometry resulting from the difference between the left-geometry and all of the right-geometries       geometry var25 <- rectangle(10,10) - [circle(2), square(2)];  // var25 equals rectangle(10,10) - (circle(2) + square(2))       Examples:  int var0 <- - (-56);  // var0 equals 56 point var1 <- -{3.0,5.0};  // var1 equals {-3.0,-5.0} point var2 <- -{1.0,6.0,7.0};  // var2 equals {-1.0,-6.0,-7.0} map var3 <- [ a ::1, b ::2] - [ b ::2];  // var3 equals [ a ::1] map var4 <- [ a ::1, b ::2] - [ b ::2, c ::3];  // var4 equals [ a ::1] map var5 <- [ a ::1, b ::2] - ( b ::2);  // var5 equals [ a ::1] map var6 <- [ a ::1, b ::2] - ( c ::3);  // var6 equals [ a ::1, b ::2]   See also: +, [](#), /, milliseconds_between, -,    ### :  Possible use:    unknown : unknown —>  unknown   : (unknown , unknown) —>  unknown   See also: ?,    ### ::  Possible use:    any expression :: any expression —>  pair   :: (any expression , any expression) —>  pair   Result: produces a new pair combining the left and the right operands  Special cases:    nil is not acceptable as a key (although it is as a value). If such a case happens, :: will throw an appropriate error     ### !  Possible use:    ! (bool) —>  bool   Result: opposite boolean value.  Special cases:    if the parameter is not boolean, it is casted to a boolean value.   Examples:  bool var0 <- ! (true);  // var0 equals false   See also: bool, and, or,    ### !=  Possible use:    float != float —>  bool   != (float , float) —>  bool   unknown != unknown —>  bool   != (unknown , unknown) —>  bool   date != date —>  bool   != (date , date) —>  bool   float != int —>  bool   != (float , int) —>  bool   int != float —>  bool   != (int , float) —>  bool   Result: true if both operands are different, false otherwise  Examples:  bool var0 <- 3.0 != 3.0;  // var0 equals false bool var1 <- 4.0 != 4.7;  // var1 equals true bool var2 <- [2,3] != [2,3];  // var2 equals false bool var3 <- [2,4] != [2,3];  // var3 equals true #now != #now minus_hours 1 :- true bool var5 <- 3.0 != 3;  // var5 equals false bool var6 <- 4.7 != 4;  // var6 equals true bool var7 <- 3 != 3.0;  // var7 equals false bool var8 <- 4 != 4.7;  // var8 equals true   See also: =, >, <, >=, <=,    ### ?  Possible use:    bool ? any expression —>  unknown   ? (bool , any expression) —>  unknown   Result: It is used in combination with the : operator: if the left-hand operand evaluates to true, returns the value of the left-hand operand of the :, otherwise that of the right-hand operand of the :  Comment: These functional tests can be combined together.  Examples:  list<string> var0 <- [10, 19, 43, 12, 7, 22] collect ((each > 20) ?  above  :  below );  // var0 equals [ below ,  below ,  above ,  below ,  below ,  above ] rgb color <- (flip(0.3) ? #red : (flip(0.9) ? #blue : #green));   See also: :,    ### /  Possible use:    rgb / float —>  rgb   / (rgb , float) —>  rgb   float / int —>  float   / (float , int) —>  float   point / float —>  point   / (point , float) —>  point   int / int —>  float   / (int , int) —>  float   int / float —>  float   / (int , float) —>  float   matrix / float —>  matrix   / (matrix , float) —>  matrix   point / int —>  point   / (point , int) —>  point   matrix / matrix —>  matrix   / (matrix , matrix) —>  matrix   matrix / int —>  matrix   / (matrix , int) —>  matrix   float / float —>  float   / (float , float) —>  float   rgb / int —>  rgb   / (rgb , int) —>  rgb   Result: Returns the division of the two operands.  Special cases:    if the right-hand operand is equal to zero, raises a  Division by zero  exception   if one operand is a color and the other a double, returns a new color resulting from the division of each component of the color by the right operand. The result on each component is then truncated.       rgb var0 <- rgb([255, 128, 32]) / 2.5;  // var0 equals rgb([102,51,13])          if the left operand is a point, returns a new point with coordinates divided by the right operand       point var1 <- {5, 7.5} / 2.5;  // var1 equals {2, 3} point var2 <- {2,5} / 4;  // var2 equals {0.5,1.25}          if both operands are numbers (float or int), performs a normal arithmetic division and returns a float.       float var3 <- 3 / 5.0;  // var3 equals 0.6          if one operand is a color and the other an integer, returns a new color resulting from the division of each component of the color by the right operand       rgb var4 <- rgb([255, 128, 32]) / 2;  // var4 equals rgb([127,64,16])       See also: [](#), +, -,    ### .  Possible use:    matrix . matrix —>  matrix   . (matrix , matrix) —>  matrix   agent . any expression —>  unknown   . (agent , any expression) —>  unknown   Result: It has two different uses: it can be the dot product between 2 matrices or return an evaluation of the expression (right-hand operand) in the scope the given agent.  Special cases:    if the agent is nil or dead, throws an exception   if both operands are matrix, returns the dot product of them       matrix var0 <- matrix([[1,1],[1,2]]) . matrix([[1,1],[1,2]]);  // var0 equals matrix([[2,3],[3,5]])          if the left operand is an agent, it evaluates of the expression (right-hand operand) in the scope the given agent       unknown var1 <- agent1.location;  // var1 equals the location of the agent agent1 map(nil).keys         ### ^  Possible use:    int ^ float —>  float   ^ (int , float) —>  float   float ^ float —>  float   ^ (float , float) —>  float   int ^ int —>  float   ^ (int , int) —>  float   float ^ int —>  float   ^ (float , int) —>  float   Result: Returns the value (always a float) of the left operand raised to the power of the right operand.  Special cases:    if the right-hand operand is equal to 0, returns 1   if it is equal to 1, returns the left-hand operand.   Various examples of power       float var1 <- 2 ^ 3;  // var1 equals 8.0       Examples:  float var0 <- 4.84 ^ 0.5;  // var0 equals 2.2   See also: [](#), sqrt,    ### @ Same signification as at    ### *  Possible use:    int * int —>  int   * (int , int) —>  int   matrix * int —>  matrix   * (matrix , int) —>  matrix   point * point —>  float   * (point , point) —>  float   int * float —>  float   * (int , float) —>  float   float * float —>  float   * (float , float) —>  float   matrix * matrix —>  matrix   * (matrix , matrix) —>  matrix   point * int —>  point   * (point , int) —>  point   float * matrix —>  matrix   * (float , matrix) —>  matrix   geometry * point —>  geometry   * (geometry , point) —>  geometry   point * float —>  point   * (point , float) —>  point   int * matrix —>  matrix   * (int , matrix) —>  matrix   float * int —>  float   * (float , int) —>  float   rgb * int —>  rgb   * (rgb , int) —>  rgb   matrix * float —>  matrix   * (matrix , float) —>  matrix   geometry * float —>  geometry   * (geometry , float) —>  geometry   Result: Returns the product of the two operands.  Special cases:    if both operands are numbers (float or int), performs a normal arithmetic product and returns a float if one of them is a float.       int var1 <- 1 * 1;  // var1 equals 1          if both operands are points, returns their scalar product       float var2 <- {2,5} * {4.5, 5};  // var2 equals 34.0          if the left-hand operator is a point and the right-hand a number, returns a point with coordinates multiplied by the number       point var3 <- {2,5} * 4;  // var3 equals {8.0, 20.0} point var4 <- {2, 4} * 2.5;  // var4 equals {5.0, 10.0}          if the left-hand operand is a geometry and the right-hand operand a point, returns a geometry corresponding to the left-hand operand (geometry, agent, point) scaled by the right-hand operand coefficients in the 3 dimensions       geometry var5 <- shape * {0.5,0.5,2};  // var5 equals a geometry corresponding to the geometry of the agent applying the operator scaled by a coefficient of 0.5 in x, 0.5 in y and 2 in z          if one operand is a matrix and the other a number (float or int), performs a normal arithmetic product of the number with each element of the matrix (results are float if the number is a float.       matrix m <- (3.5 * matrix([[2,5],[3,4]])); //m equals matrix([[7.0,17.5],[10.5,14]])          if one operand is a color and the other an integer, returns a new color resulting from the product of each component of the color with the right operand (with a maximum value at 255)       rgb var7 <- rgb([255, 128, 32]) * 2;  // var7 equals rgb([255,255,64])          if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) scaled by the right-hand operand coefficient       geometry var8 <- circle(10) * 2;  // var8 equals circle(20)       Examples:  float var0 <- 2.5 * 2;  // var0 equals 5.0   See also: +, -, /,    ### +  Possible use:    string + string —>  string   + (string , string) —>  string   date + float —>  date   + (date , float) —>  date   map + pair —>  map   + (map , pair) —>  map   int + matrix —>  matrix   + (int , matrix) —>  matrix   point + int —>  point   + (point , int) —>  point   rgb + rgb —>  rgb   + (rgb , rgb) —>  rgb   geometry + float —>  geometry   + (geometry , float) —>  geometry   matrix + float —>  matrix   + (matrix , float) —>  matrix   geometry + geometry —>  geometry   + (geometry , geometry) —>  geometry   map + map —>  map   + (map , map) —>  map   float + float —>  float   + (float , float) —>  float   float + int —>  float   + (float , int) —>  float   matrix + matrix —>  matrix   + (matrix , matrix) —>  matrix   date + string —>  string   + (date , string) —>  string   matrix + int —>  matrix   + (matrix , int) —>  matrix   int + int —>  int   + (int , int) —>  int   string + unknown —>  string   + (string , unknown) —>  string   point + point —>  point   + (point , point) —>  point   float + matrix —>  matrix   + (float , matrix) —>  matrix   int + float —>  float   + (int , float) —>  float   point + float —>  point   + (point , float) —>  point   rgb + int —>  rgb   + (rgb , int) —>  rgb   date + int —>  date   + (date , int) —>  date   container + container —>  container   + (container , container) —>  container   container + unknown —>  container   + (container , unknown) —>  container   + (geometry, float, int) —>  geometry   + (geometry, float, int, int) —>  geometry   Result: Returns the sum, union or concatenation of the two operands.  Special cases:    if one of the operands is nil, + throws an error   if both operands are species, returns a special type of list called meta-population   if the left-hand operand is a geometry and the right-hand operands a float and an integer, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the first right-hand operand (distance), using a number of segments equal to the second right-hand operand       geometry var4 <- circle(5) + (5,32);  // var4 equals circle(10)          if one operand is a matrix and the other a number (float or int), performs a normal arithmetic sum of the number with each element of the matrix (results are float if the number is a float.       matrix var5 <- 3.5 + matrix([[2,5],[3,4]]);  // var5 equals matrix([[5.5,8.5],[6.5,7.5]])          if both operands are colors, returns a new color resulting from the sum of the two operands, component by component       rgb var6 <- rgb([255, 128, 32]) + rgb( red );  // var6 equals rgb([255,128,32])          if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the right-hand operand distance. The number of segments used by default is 8 and the end cap style is #round       geometry var7 <- circle(5) + 5;  // var7 equals circle(10)          if the right-operand is a point, a geometry or an agent, returns the geometry resulting from the union between both geometries       geometry var8 <- geom1 + geom2;  // var8 equals a geometry corresponding to union between geom1 and geom2          if both operands are numbers (float or int), performs a normal arithmetic sum and returns a float if one of them is a float.       int var9 <- 1 + 1;  // var9 equals 2 int var10 <- 1.0 + 1;  // var10 equals 2.0 int var11 <- 1.0 + 2.5;  // var11 equals 3.5          if the left-hand operand is a string, returns the concatenation of the two operands (the left-hand one beind casted into a string)       string var12 <-  hello   + 12;  // var12 equals  hello 12           if both operands are points, returns their sum.       point var13 <- {1, 2} + {4, 5};  // var13 equals {5.0, 7.0}          if the left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the sum of the operand coordinate with this number.       point var14 <- {1, 2} + 4;  // var14 equals {5.0, 6.0,4.0} point var15 <- {1, 2} + 4.5;  // var15 equals {5.5, 6.5,4.5}          if one operand is a color and the other an integer, returns a new color resulting from the sum of each component of the color with the right operand       rgb var16 <- rgb([255, 128, 32]) + 3;  // var16 equals rgb([255,131,35])          if the left-hand operand is a geometry and the right-hand operands a float, an integer and one of #round, #square or #flat, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the first right-hand operand (distance), using a number of segments equal to the second right-hand operand and a flat, square or round end cap style       geometry var17 <- circle(5) + (5,32,#round);  // var17 equals circle(10)          if one of the operands is a date and the other a number, returns a date corresponding to the date plus the given number as duration (in seconds)       date1 + 200          if both operands are list, +returns the concatenation of both lists.       list var19 <- [1,2,3,4,5,6] + [2,4,9];  // var19 equals [1,2,3,4,5,6,2,4,9] list var20 <- [1,2,3,4,5,6] + [0,8];  // var20 equals [1,2,3,4,5,6,0,8]          if the right operand is an object of any type (except a container), + returns a list of the elements of the left operand, to which this object has been added       list var21 <- [1,2,3,4,5,6] + 2;  // var21 equals [1,2,3,4,5,6,2] list var22 <- [1,2,3,4,5,6] + 0;  // var22 equals [1,2,3,4,5,6,0]       Examples:  map var0 <- [ a ::1, b ::2] + ( c ::3);  // var0 equals [ a ::1, b ::2, c ::3] map var1 <- [ a ::1, b ::2] + ( c ::3);  // var1 equals [ a ::1, b ::2, c ::3] map var2 <- [ a ::1, b ::2] + [ c ::3];  // var2 equals [ a ::1, b ::2, c ::3] map var3 <- [ a ::1, b ::2] + [5::3.0];  // var3 equals [ a ::1.0, b ::2.0,5::3.0]   See also: -, [](#), /,    ### <  Possible use:    float < int —>  bool   < (float , int) —>  bool   int < int —>  bool   < (int , int) —>  bool   point < point —>  bool   < (point , point) —>  bool   int < float —>  bool   < (int , float) —>  bool   date < date —>  bool   < (date , date) —>  bool   float < float —>  bool   < (float , float) —>  bool   string < string —>  bool   < (string , string) —>  bool   Result: true if the left-hand operand is less than the right-hand operand, false otherwise.  Special cases:    if one of the operands is nil, returns false   if both operands are points, returns true if and only if the left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.       bool var5 <- {5,7} < {4,6};  // var5 equals false bool var6 <- {5,7} < {4,8};  // var6 equals false          if both operands are String, uses a lexicographic comparison of two strings       bool var7 <-  abc  <  aeb ;  // var7 equals true       Examples:  bool var0 <- 3.5 < 7;  // var0 equals true bool var1 <- 3 < 7;  // var1 equals true bool var2 <- 3 < 2.5;  // var2 equals false #now < #now minus_hours 1 :- false bool var4 <- 3.5 < 7.6;  // var4 equals true   See also: >, >=, <=, =, !=,    ### <=  Possible use:    string <= string —>  bool   <= (string , string) —>  bool   date <= date —>  bool   <= (date , date) —>  bool   float <= float —>  bool   <= (float , float) —>  bool   int <= int —>  bool   <= (int , int) —>  bool   int <= float —>  bool   <= (int , float) —>  bool   float <= int —>  bool   <= (float , int) —>  bool   point <= point —>  bool   <= (point , point) —>  bool   Result: true if the left-hand operand is less or equal than the right-hand operand, false otherwise.  Special cases:    if one of the operands is nil, returns false   if both operands are String, uses a lexicographic comparison of two strings       bool var5 <-  abc  <=  aeb ;  // var5 equals true          if both operands are points, returns true if and only if the left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.       bool var6 <- {5,7} <= {4,6};  // var6 equals false bool var7 <- {5,7} <= {4,8};  // var7 equals false       Examples:  #now <= #now minus_hours 1 :- false bool var1 <- 3.5 <= 3.5;  // var1 equals true bool var2 <- 3 <= 7;  // var2 equals true bool var3 <- 3 <= 2.5;  // var3 equals false bool var4 <- 7.0 <= 7;  // var4 equals true   See also: >, <, >=, =, !=,    ### <> Same signification as !=    ### =  Possible use:    date = date —>  bool   = (date , date) —>  bool   int = float —>  bool   = (int , float) —>  bool   unknown = unknown —>  bool   = (unknown , unknown) —>  bool   float = float —>  bool   = (float , float) —>  bool   float = int —>  bool   = (float , int) —>  bool   int = int —>  bool   = (int , int) —>  bool   Result: returns true if both operands are equal, false otherwise returns true if both operands are equal, false otherwise  Special cases:    if both operands are any kind of objects, returns true if they are identical (i.e., the same object) or equal (comparisons between nil values are permitted)       bool var0 <- [2,3] = [2,3];  // var0 equals true       Examples:  #now = #now minus_hours 1 :- false bool var2 <- 3 = 3.0;  // var2 equals true bool var3 <- 4 = 4.7;  // var3 equals false bool var4 <- 4.5 = 4.7;  // var4 equals false bool var5 <- 4.7 = 4;  // var5 equals false bool var6 <- 4 = 5;  // var6 equals false   See also: !=, >, <, >=, <=,    ### >  Possible use:    int > float —>  bool   > (int , float) —>  bool   float > float —>  bool   > (float , float) —>  bool   string > string —>  bool   > (string , string) —>  bool   int > int —>  bool   > (int , int) —>  bool   date > date —>  bool   > (date , date) —>  bool   point > point —>  bool   > (point , point) —>  bool   float > int —>  bool   > (float , int) —>  bool   Result: true if the left-hand operand is greater than the right-hand operand, false otherwise.  Special cases:    if one of the operands is nil, returns false   if both operands are String, uses a lexicographic comparison of two strings       bool var0 <-  abc  >  aeb ;  // var0 equals false          if both operands are points, returns true if and only if the left component (x) of the left operand if greater than x of the right one and if the right component (y) of the left operand is greater than y of the right one.       bool var1 <- {5,7} > {4,6};  // var1 equals true bool var2 <- {5,7} > {4,8};  // var2 equals false       Examples:  bool var3 <- 3 > 2.5;  // var3 equals true bool var4 <- 3.5 > 7.6;  // var4 equals false bool var5 <- 3 > 7;  // var5 equals false #now > #now minus_hours 1 :- true bool var7 <- 3.5 > 7;  // var7 equals false   See also: <, >=, <=, =, !=,    ### >=  Possible use:    float >= int —>  bool   >= (float , int) —>  bool   int >= int —>  bool   >= (int , int) —>  bool   int >= float —>  bool   >= (int , float) —>  bool   string >= string —>  bool   >= (string , string) —>  bool   date >= date —>  bool   >= (date , date) —>  bool   float >= float —>  bool   >= (float , float) —>  bool   point >= point —>  bool   >= (point , point) —>  bool   Result: true if the left-hand operand is greater or equal than the right-hand operand, false otherwise.  Special cases:    if one of the operands is nil, returns false   if both operands are string, uses a lexicographic comparison of the two strings       bool var5 <-  abc  >=  aeb ;  // var5 equals false bool var6 <-  abc  >=  abc ;  // var6 equals true          if both operands are points, returns true if and only if the left component (x) of the left operand if greater or equal than x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.       bool var7 <- {5,7} >= {4,6};  // var7 equals true bool var8 <- {5,7} >= {4,8};  // var8 equals false       Examples:  bool var0 <- 3.5 >= 7;  // var0 equals false bool var1 <- 3 >= 7;  // var1 equals false bool var2 <- 3 >= 2.5;  // var2 equals true #now >= #now minus_hours 1 :- true bool var4 <- 3.5 >= 3.5;  // var4 equals true   See also: >, <, <=, =, !=,    ### abs  Possible use:    abs (int) —>  int   abs (float) —>  float   Result: Returns the absolute value of the operand (so a positive int or float depending on the type of the operand).  Examples:  int var0 <- abs (-10);  // var0 equals 10 int var1 <- abs (10);  // var1 equals 10 float var3 <- abs (200 * -1 + 0.5);  // var3 equals 199.5     ### accumulate  Possible use:    container accumulate any expression —>  container   accumulate (container , any expression) —>  container   Result: returns a new flat list, in which each element is the evaluation of the right-hand operand. If this evaluation returns a list, the elements of this result are added directly to the list returned  Comment: accumulate is dedicated to the application of a same computation on each element of a container (and returns a list). In the right-hand operand, the keyword each can be used to represent, in turn, each of the left-hand operand elements.  Examples:  container var0 <- [a1,a2,a3] accumulate (each neighbors_at 10);  // var0 equals a flat list of all the neighbors of these three agents list<int> var1 <- [1,2,4] accumulate ([2,4]);  // var1 equals [2,4,2,4,2,4] list<int> var2 <- [1,2,4] accumulate (each * 2);  // var2 equals [2,4,8]   See also: collect,    ### acos  Possible use:    acos (float) —>  float   acos (int) —>  float   Result: Returns the value (in the interval [0,180], in decimal degrees) of the arccos of the operand (which should be in [-1,1]).  Special cases:    if the right-hand operand is outside of the [-1,1] interval, returns NaN   Examples:  float var0 <- acos (0);  // var0 equals 90.0   See also: asin, atan, cos,    ### action  Possible use:    action (any) —>  action   Result: Casts the operand into the type action    ### add_days Same signification as plus_days    ### add_edge  Possible use:    graph add_edge pair —>  graph   add_edge (graph , pair) —>  graph   Result: add an edge between a source vertex and a target vertex (resp. the left and the right element of the pair operand)  Comment: if the edge already exists, the graph is unchanged  Examples:  graph <- graph add_edge (source::target);   See also: add_node, graph,    ### add_hours Same signification as plus_hours    ### add_minutes Same signification as plus_minutes    ### add_months Same signification as plus_months    ### add_ms Same signification as plus_ms    ### add_node  Possible use:    graph add_node geometry —>  graph   add_node (graph , geometry) —>  graph   Result: adds a node in a graph.  Examples:  graph var0 <- graph add_node node(0) ;  // var0 equals the graph with node(0)   See also: add_edge, graph,    ### add_point  Possible use:    geometry add_point point —>  geometry   add_point (geometry , point) —>  geometry   Result: A new geometry resulting from the addition of the right point (coordinate) to the left-hand geometry. Note that adding a point to a line or polyline will always return a closed contour. Also note that the position at which the added point will appear in the geometry is not necessarily the last one, as points are always ordered in a clockwise fashion in geometries  Examples:  geometry var0 <- polygon([{10,10},{10,20},{20,20}]) add_point {20,10};  // var0 equals polygon([{10,10},{10,20},{20,20},{20,10}])     ### add_seconds Same signification as +    ### add_weeks Same signification as plus_weeks    ### add_years Same signification as plus_years    ### adjacency  Possible use:    adjacency (graph) —>  matrix<float>   Result: adjacency matrix of the given graph.    ### after  Possible use:    after (date) —>  bool   any expression after date —>  bool   after (any expression , date) —>  bool   Result: Returns true if the current_date of the model is strictly after the date passed in argument. Synonym of  current_date > argument . Can be used in its composed form with 2 arguments to express the lower boundary for the computation of a frequency. Note that only dates strictly after this one will be tested against the frequency  Examples:  reflex when: after(starting_date) {} -: will always be run after the first step reflex when: false after(starting date + #10days) {} -: will not be run after this date. Better to use  until  or  before  in that case every(2#days) after (starting_date + 1#day) // the computation will return true every two days (using the starting_date of the model as the starting point) only for the dates strictly after this starting_date + 1#day     ### agent  Possible use:    agent (any) —>  agent   Result: Casts the operand into the type agent    ### agent_closest_to  Possible use:    agent_closest_to (unknown) —>  agent   Result: An agent, the closest to the operand (casted as a geometry).  Comment: the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.  Examples:  agent var0 <- agent_closest_to(self);  // var0 equals the closest agent to the agent applying the operator.   See also: neighbors_at, neighbors_of, agents_inside, agents_overlapping, closest_to, inside, overlapping,    ### agent_farthest_to  Possible use:    agent_farthest_to (unknown) —>  agent   Result: An agent, the farthest to the operand (casted as a geometry).  Comment: the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.  Examples:  agent var0 <- agent_farthest_to(self);  // var0 equals the farthest agent to the agent applying the operator.   See also: neighbors_at, neighbors_of, agents_inside, agents_overlapping, closest_to, inside, overlapping, agent_closest_to, farthest_to,    ### agent_from_geometry  Possible use:    path agent_from_geometry geometry —>  agent   agent_from_geometry (path , geometry) —>  agent   Result: returns the agent corresponding to given geometry (right-hand operand) in the given path (left-hand operand).  Special cases:    if the left-hand operand is nil, returns nil   Examples:  geometry line <- one_of(path_followed.segments); road ag <- road(path_followed agent_from_geometry line);   See also: path,    ### agents_at_distance  Possible use:    agents_at_distance (float) —>  container   Result: A list of agents situated at a distance lower than the right argument.  Examples:  container var0 <- agents_at_distance(20);  // var0 equals all the agents (excluding the caller) which distance to the caller is lower than 20   See also: neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, overlapping, at_distance,    ### agents_inside  Possible use:    agents_inside (unknown) —>  list<agent>   Result: A list of agents covered by the operand (casted as a geometry).  Examples:  list<agent> var0 <- agents_inside(self);  // var0 equals the agents that are covered by the shape of the agent applying the operator.   See also: agent_closest_to, agents_overlapping, closest_to, inside, overlapping,    ### agents_overlapping  Possible use:    agents_overlapping (unknown) —>  list<agent>   Result: A list of agents overlapping the operand (casted as a geometry).  Examples:  list<agent> var0 <- agents_overlapping(self);  // var0 equals the agents that overlap the shape of the agent applying the operator.   See also: neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, overlapping, at_distance,    ### all_pairs_shortest_path  Possible use:    all_pairs_shortest_path (graph) —>  matrix<int>   Result: returns the successor matrix of shortest paths between all node pairs (rows: source, columns: target): a cell (i,j) will thus contains the next node in the shortest path between i and j.  Examples:  matrix<int> var0 <- all_pairs_shortest_paths(my_graph);  // var0 equals shortest_paths_matrix will contain all pairs of shortest paths     ### alpha_index  Possible use:    alpha_index (graph) —>  float   Result: returns the alpha index of the graph (measure of connectivity which evaluates the number of cycles in a graph in comparison with the maximum number of cycles. The higher the alpha index, the more a network is connected: alpha = nb_cycles / (2*S-5) - planar graph)  Examples:  float var1 <- alpha_index(graphEpidemio);  // var1 equals the alpha index of the graph   See also: beta_index, gamma_index, nb_cycles, connectivity_index,    ### among  Possible use:    int among container —>  container   among (int , container) —>  container   Result: Returns a list of length the value of the left-hand operand, containing random elements from the right-hand operand. As of GAMA 1.6, the order in which the elements are returned can be different than the order in which they appear in the right-hand container  Special cases:    if the right-hand operand is empty, among returns a new empty list. If it is nil, it throws an error.   if the left-hand operand is greater than the length of the right-hand operand, among returns the right-hand operand (converted as a list). If it is smaller or equal to zero, it returns an empty list   Examples:  list<int> var0 <- 3 among [1,2,4,3,5,7,6,8];  // var0 equals [1,2,8] (for example) container var1 <- 3 among g2;  // var1 equals [node6,node11,node7] container var2 <- 3 among list(node);  // var2 equals [node1,node11,node4] list<int> var3 <- 1 among [1::2,3::4];  // var3 equals 2 or 4     ### and  Possible use:    bool and any expression —>  bool   and (bool , any expression) —>  bool   Result: a bool value, equal to the logical and between the left-hand operand and the right-hand operand.  Comment: both operands are always casted to bool before applying the operator. Thus, an expression like (1 and 0) is accepted and returns false.  See also: bool, or, !,    ### and  Possible use:    predicate and predicate —>  predicate   and (predicate , predicate) —>  predicate   Result: create a new predicate from two others by including them as subintentions  Examples:  predicate1 and predicate2     ### angle_between  Possible use:    angle_between (point, point, point) —>  int   Result: the angle between vectors P0P1 and P0P2 (P0, P1, P2 being the three point operands)  Examples:  int var0 <- angle_between({5,5},{10,5},{5,10});  // var0 equals 90     ### any Same signification as one_of    ### any_location_in  Possible use:    any_location_in (geometry) —>  point   Result: A point inside (or touching) the operand-geometry.  Examples:  point var0 <- any_location_in(square(5));  // var0 equals a point in the square, for example : {3,4.6}.   See also: closest_points_with, farthest_point_to, points_at,    ### any_point_in Same signification as any_location_in    ### append_horizontally  Possible use:    matrix append_horizontally matrix —>  matrix   append_horizontally (matrix , matrix) —>  matrix   matrix append_horizontally matrix —>  matrix   append_horizontally (matrix , matrix) —>  matrix   Result: A matrix resulting from the concatenation of the rows of the two given matrices. If not both numerical or both object matrices, returns the first matrix.  Examples:  matrix var0 <- matrix([[1.0,2.0],[3.0,4.0]]) append_horizontally matrix([[1,2],[3,4]]);  // var0 equals matrix([[1.0,2.0],[3.0,4.0],[1.0,2.0],[3.0,4.0]])     ### append_vertically  Possible use:    matrix append_vertically matrix —>  matrix   append_vertically (matrix , matrix) —>  matrix   matrix append_vertically matrix —>  matrix   append_vertically (matrix , matrix) —>  matrix   Result: A matrix resulting from the concatenation of the columns  of the two given matrices. If not both numerical or both object matrices, returns the first matrix.  Examples:  matrix var0 <- matrix([[1,2],[3,4]]) append_vertically matrix([[1,2],[3,4]]);  // var0 equals matrix([[1,2,1,2],[3,4,3,4]])     ### arc  Possible use:    arc (float, float, float) —>  geometry   arc (float, float, float, bool) —>  geometry   Result: An arc, which radius is equal to the first operand, heading to the second and amplitude the third An arc, which radius is equal to the first operand, heading to the second, amplitude to the third and a boolean indicating whether to return a linestring or a polygon to the fourth  Comment: the center of the arc is by default the location of the current agent in which has been called this operator. This operator returns a polygon by default.the center of the arc is by default the location of the current agent in which has been called this operator.  Special cases:    returns a point if the radius operand is lower or equal to 0.   returns a point if the radius operand is lower or equal to 0.   Examples:  geometry var0 <- arc(4,45,90);  // var0 equals a geometry as an arc of radius 4, in a direction of 45Â° and an amplitude of 90Â° geometry var1 <- arc(4,45,90, false);  // var1 equals a geometry as an arc of radius 4, in a direction of 45Â° and an amplitude of 90Â°, which only contains the points on the arc   See also: around, cone, line, link, norm, point, polygon, polyline, super_ellipse, rectangle, square, circle, ellipse, triangle,    ### around  Possible use:    float around unknown —>  geometry   around (float , unknown) —>  geometry   Result: A geometry resulting from the difference between a buffer around the right-operand casted in geometry at a distance left-operand (right-operand buffer left-operand) and the right-operand casted as geometry.  Special cases:    returns a circle geometry of radius right-operand if the left-operand is nil   Examples:  geometry var0 <- 10 around circle(5);  // var0 equals the ring geometry between 5 and 10.   See also: circle, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,    ### as  Possible use:    unknown as any expression —>  unknown   as (unknown , any expression) —>  unknown   Result: casting of the first argument into a given type  Comment: It is equivalent to the application of the type operator on the left operand.  Examples:  int var0 <- 3.5 as int;  // var0 equals int(3.5)     ### as_4_grid  Possible use:    geometry as_4_grid point —>  matrix   as_4_grid (geometry , point) —>  matrix   Result: A matrix of square geometries (grid with 4-neighborhood) with dimension given by the right-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)  Examples:  matrix var0 <- self as_4_grid {10, 5};  // var0 equals the matrix of square geometries (grid with 4-neighborhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.   See also: as_grid, as_hexagonal_grid,    ### as_distance_graph  Possible use:    container as_distance_graph map —>  graph   as_distance_graph (container , map) —>  graph   container as_distance_graph float —>  graph   as_distance_graph (container , float) —>  graph   as_distance_graph (container, float, species) —>  graph   Result: creates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices close enough (less than a distance, right-hand operand).  Comment: as_distance_graph is more efficient for a list of points than as_intersection_graph.  Examples:  list(ant) as_distance_graph 3.0   See also: as_intersection_graph, as_edge_graph,    ### as_driving_graph  Possible use:    container as_driving_graph container —>  graph   as_driving_graph (container , container) —>  graph   Result: creates a graph from the list/map of edges given as operand and connect the node to the edge  Examples:  as_driving_graph(road,node)  --:  build a graph while using the road agents as edges and the node agents as nodes   See also: as_intersection_graph, as_distance_graph, as_edge_graph,    ### as_edge_graph  Possible use:    as_edge_graph (map) —>  graph   as_edge_graph (container) —>  graph   container as_edge_graph float —>  graph   as_edge_graph (container , float) —>  graph   Result: creates a graph from the list/map of edges given as operand  Special cases:    if the operand is a map, the graph will be built by creating edges from pairs of the map       graph var0 <- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);  // var0 equals a graph with these three vertices and two edges          if the operand is a list and a tolerance (max distance in meters to consider that 2 points are the same node) is given, the graph will be built with elements of the list as edges and two edges will be connected by a node if the distance between their extremity (first or last points) are at distance lower or equal to the tolerance       graph var1 <- as_edge_graph([line([{1,5},{12,45}]),line([{13,45},{34,56}])],1);;  // var1 equals a graph with two edges and three vertices          if the operand is a list, the graph will be built with elements of the list as edges       graph var2 <- as_edge_graph([line([{1,5},{12,45}]),line([{12,45},{34,56}])]);  // var2 equals a graph with two edges and three vertices       See also: as_intersection_graph, as_distance_graph,    ### as_grid  Possible use:    geometry as_grid point —>  matrix   as_grid (geometry , point) —>  matrix   Result: A matrix of square geometries (grid with 8-neighborhood) with dimension given by the right-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)  Examples:  matrix var0 <- self as_grid {10, 5};  // var0 equals a matrix of square geometries (grid with 8-neighborhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.   See also: as_4_grid, as_hexagonal_grid,    ### as_hexagonal_grid  Possible use:    geometry as_hexagonal_grid point —>  list<geometry>   as_hexagonal_grid (geometry , point) —>  list<geometry>   Result: A list of geometries (hexagonal) corresponding to the hexagonal tesselation of the first operand geometry  Examples:  list<geometry> var0 <- self as_hexagonal_grid {10, 5};  // var0 equals list of geometries (hexagonal) corresponding to the hexagonal tesselation of the first operand geometry   See also: as_4_grid, as_grid,    ### as_int  Possible use:    string as_int int —>  int   as_int (string , int) —>  int   Result: parses the string argument as a signed integer in the radix specified by the second argument.  Special cases:    if the left operand is nil or empty, as_int returns 0   if the left operand does not represent an integer in the specified radix, as_int throws an exception   Examples:  int var0 <-  20  as_int 10;  // var0 equals 20 int var1 <-  20  as_int 8;  // var1 equals 16 int var2 <-  20  as_int 16;  // var2 equals 32 int var3 <-  1F  as_int 16;  // var3 equals 31 int var4 <-  hello  as_int 32;  // var4 equals 18306744   See also: int,    ### as_intersection_graph  Possible use:    container as_intersection_graph float —>  graph   as_intersection_graph (container , float) —>  graph   Result: creates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices with an intersection (with a given tolerance).  Comment: as_intersection_graph is more efficient for a list of geometries (but less accurate) than as_distance_graph.  Examples:  list(ant) as_intersection_graph 0.5   See also: as_distance_graph, as_edge_graph,    ### as_map  Possible use:    container as_map any expression —>  map   as_map (container , any expression) —>  map   Result: produces a new map from the evaluation of the right-hand operand for each element of the left-hand operand  Comment: the right-hand operand should be a pair  Special cases:    if the left-hand operand is nil, as_map throws an error.   Examples:  map<int,int> var0 <- [1,2,3,4,5,6,7,8] as_map (each::(each * 2));  // var0 equals [1::2, 2::4, 3::6, 4::8, 5::10, 6::12, 7::14, 8::16] map<int,int> var1 <- [1::2,3::4,5::6] as_map (each::(each * 2));  // var1 equals [2::4, 4::8, 6::12]      ### as_matrix  Possible use:    unknown as_matrix point —>  matrix   as_matrix (unknown , point) —>  matrix   Result: casts the left operand into a matrix with right operand as preferred size  Comment: This operator is very useful to cast a file containing raster data into a matrix.Note that both components of the right operand point should be positive, otherwise an exception is raised.The operator as_matrix creates a matrix of preferred size. It fills in it with elements of the left operand until the matrix is full If the size is to short, some elements will be omitted. Matrix remaining elements will be filled in by nil.  Special cases:    if the right operand is nil, as_matrix is equivalent to the matrix operator   See also: matrix,    ### as_path  Possible use:    list<geometry> as_path graph —>  path   as_path (list<geometry> , graph) —>  path   Result: create a graph path from the list of shape  Examples:  path var0 <- [road1,road2,road3] as_path my_graph;  // var0 equals a path road1->road2->road3 of my_graph     ### asin  Possible use:    asin (float) —>  float   asin (int) —>  float   Result: the arcsin of the operand  Special cases:    if the right-hand operand is outside of the [-1,1] interval, returns NaN   Examples:  float var0 <- asin (0);  // var0 equals 0.0 float var1 <- asin (90);  // var1 equals #nan   See also: acos, atan, sin,    ### at  Possible use:    string at int —>  string   at (string , int) —>  string   container<KeyType,ValueType> at KeyType —>  ValueType   at (container<KeyType,ValueType> , KeyType) —>  ValueType   Result: the element at the right operand index of the container  Comment: The first element of the container is located at the index 0. In addition, if the user tries to get the element at an index higher or equals than the length of the container, he will get an IndexOutOfBoundException.The at operator behavior depends on the nature of the operand  Special cases:    if it is a file, at returns the element of the file content at the index specified by the right operand   if it is a population, at returns the agent at the index specified by the right operand   if it is a graph and if the right operand is a node, at returns the in and out edges corresponding to that node   if it is a graph and if the right operand is an edge, at returns the pair node_out::node_in of the edge   if it is a graph and if the right operand is a pair node1::node2, at returns the edge from node1 to node2 in the graph   if it is a list or a matrix, at returns the element at the index specified by the right operand       int var1 <- [1, 2, 3] at 2;  // var1 equals 3 point var2 <- [{1,2}, {3,4}, {5,6}] at 0;  // var2 equals {1.0,2.0}       Examples:  string var0 <-  abcdef  at 0;  // var0 equals  a    See also: contains_all, contains_any,    ### at_distance  Possible use:    container<agent> at_distance float —>  list<geometry>   at_distance (container<agent> , float) —>  list<geometry>   Result: A list of agents or geometries among the left-operand list that are located at a distance <= the right operand from the caller agent (in its topology)  Examples:  list<geometry> var0 <- [ag1, ag2, ag3] at_distance 20;  // var0 equals the agents of the list located at a distance <= 20 from the caller agent (in the same order).   See also: neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, overlapping,    ### at_location  Possible use:    geometry at_location point —>  geometry   at_location (geometry , point) —>  geometry   Result: A geometry resulting from the tran of a translation to the right-hand operand point of the left-hand operand (geometry, agent, point)  Examples:  geometry var0 <- self at_location {10, 20};  // var0 equals the geometry resulting from a translation to the location {10, 20} of the left-hand geometry (or agent).     ### atan  Possible use:    atan (float) —>  float   atan (int) —>  float   Result: Returns the value (in the interval [-90,90], in decimal degrees) of the arctan of the operand (which can be any real number).  Examples:  float var0 <- atan (1);  // var0 equals 45.0   See also: acos, asin, tan,    ### atan2  Possible use:    float atan2 float —>  float   atan2 (float , float) —>  float   Result: the atan2 value of the two operands.  Comment: The function atan2 is the arctangent function with two arguments. The purpose of using two arguments instead of one is to gather information on the signs of the inputs in order to return the appropriate quadrant of the computed angle, which is not possible for the single-argument arctangent function.  Examples:  float var0 <- atan2 (0,0);  // var0 equals 0.0   See also: atan, acos, asin,    ### attributes  Possible use:    attributes (any) —>  attributes   Result: Casts the operand into the type attributes    ### BDIPlan  Possible use:    BDIPlan (any) —>  BDIPlan   Result: Casts the operand into the type BDIPlan    ### before  Possible use:    before (date) —>  bool   any expression before date —>  bool   before (any expression , date) —>  bool   Result: Returns true if the current_date of the model is strictly before the date passed in argument. Synonym of  current_date < argument   Examples:  reflex when: before(starting_date) {} -: will never be run     ### beta_index  Possible use:    beta_index (graph) —>  float   Result: returns the beta index of the graph (Measures the level of connectivity in a graph and is expressed by the relationship between the number of links (e) over the number of nodes (v) : beta = e/v.  Examples:  graph graphEpidemio <- graph([]); float var1 <- beta_index(graphEpidemio);  // var1 equals the beta index of the graph   See also: alpha_index, gamma_index, nb_cycles, connectivity_index,    ### between  Possible use:    date between date —>  bool   between (date , date) —>  bool   between (int, int, int) —>  bool   between (any expression, date, date) —>  bool   between (float, float, float) —>  bool   between (date, date, date) —>  bool   Result: returns true the first integer operand is bigger than the second integer operand and smaller than the third integer operand returns true if the first float operand is bigger than the second float operand and smaller than the third float operand  Special cases:    returns true if the first operand is between the two dates passed in arguments (both exclusive). Can be combined with  every  to express a frequency between two dates       (date( 2016-01-01 ) between(date( 2000-01-01 ), date( 2020-02-02 ) -: true every #day between(date( 2000-01-01 ), date( 2020-02-02 ) // will return true every new day between these two dates, taking the first one as the starting point          returns true if the first operand is between the two dates passed in arguments (both exclusive). The version with 2 arguments compares the current_date with the 2 others       (date( 2016-01-01 ) between(date( 2000-01-01 ), date( 2020-02-02 ) -: true between(date( 2000-01-01 ), date( 2020-02-02 ) // will return true if the current_date of the model is in_between the 2       Examples:  bool var0 <- between(5, 1, 10);  // var0 equals true bool var1 <- between(5.0, 1.0, 10.0);  // var1 equals true     ### betweenness_centrality  Possible use:    betweenness_centrality (graph) —>  map   Result: returns a map containing for each vertex (key), its betweenness centrality (value): number of shortest paths passing through each vertex  Examples:  graph graphEpidemio <- graph([]); map var1 <- betweenness_centrality(graphEpidemio);  // var1 equals the betweenness centrality index of the graph     ### biggest_cliques_of  Possible use:    biggest_cliques_of (graph) —>  list<list>   Result: returns the biggest cliques of a graph using the Bron-Kerbosch clique detection algorithm  Examples:  graph my_graph <- graph([]); list<list> var1 <- biggest_cliques_of (my_graph);  // var1 equals the list of the biggest cliques as list   See also: maximal_cliques_of,    ### binomial  Possible use:    int binomial float —>  int   binomial (int , float) —>  int   Result: A value from a random variable following a binomial distribution. The operands represent the number of experiments n and the success probability p.  Comment: The binomial distribution is the discrete probability distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields success with probability p, cf. Binomial distribution on Wikipedia.  Examples:  int var0 <- binomial(15,0.6);  // var0 equals a random positive integer   See also: poisson, gauss,    ### blend  Possible use:    rgb blend rgb —>  rgb   blend (rgb , rgb) —>  rgb   blend (rgb, rgb, float) —>  rgb   Result: Blend two colors with an optional ratio (c1 * r + c2 * (1 - r)) between 0 and 1  Special cases:    If the ratio is omitted, an even blend is done       rgb var3 <- blend(#red, #blue);  // var3 equals to a color very close to the purple       Examples:  rgb var1 <- blend(#red, #blue, 0.3);  // var1 equals to a color between the purple and the blue   See also: rgb, hsb,    ### bool  Possible use:    bool (any) —>  bool   Result: Casts the operand into the type bool    ### box  Possible use:    box (point) —>  geometry   box (float, float, float) —>  geometry   Result: A box geometry which side sizes are given by the operands.  Comment: the center of the box is by default the location of the current agent in which has been called this operator.the center of the box is by default the location of the current agent in which has been called this operator.  Special cases:    returns nil if the operand is nil.   returns nil if the operand is nil.   Examples:  geometry var0 <- box(10, 5 , 5);  // var0 equals a geometry as a rectangle with width = 10, height = 5 depth= 5. geometry var1 <- box({10, 5 , 5});  // var1 equals a geometry as a rectangle with width = 10, height = 5 depth= 5.   See also: around, circle, sphere, cone, line, link, norm, point, polygon, polyline, square, cube, triangle,    ### brewer_colors  Possible use:    brewer_colors (string) —>  list<rgb>   string brewer_colors int —>  list<rgb>   brewer_colors (string , int) —>  list<rgb>   Result: Build a list of colors of a given type (see website http://colorbrewer2.org/) Build a list of colors of a given type (see website http://colorbrewer2.org/) with a given number of classes  Examples:  list<rgb> var0 <- list<rgb> colors <- brewer_colors(OrRd);;  // var0 equals a list of 6 blue colors list<rgb> var1 <- list<rgb> colors <- brewer_colors(Pastel1, 10);;  // var1 equals a list of 10 sequential colors   See also: brewer_palettes,    ### brewer_palettes  Possible use:    brewer_palettes (int) —>  list<string>   int brewer_palettes int —>  list<string>   brewer_palettes (int , int) —>  list<string>   Result: returns the list a palette with a given min number of classes and max number of classes) returns the list a palette with a given min number of classes and max number of classes)  Examples:  list<string> var0 <- list<rgb> colors <- brewer_palettes(5,10);;  // var0 equals a list of palettes that are composed of a min of 5 colors and a max of 10 colors list<string> var1 <- list<rgb> colors <- brewer_palettes();;  // var1 equals a list of palettes that are composed of a min of 5 colors   See also: brewer_colors,    ### buffer Same signification as +    ### build  Possible use:    build (matrix<float>) —>  regression   matrix<float> build string —>  regression   build (matrix<float> , string) —>  regression   Result: returns the regression build from the matrix data (a row = an instance, the last value of each line is the y value) while using the given ordinary least squares method. Usage: build(data) returns the regression build from the matrix data (a row = an instance, the last value of each line is the y value) while using the given method ( GLS  or  OLS ). Usage: build(data,method)  Examples:  matrix([[1,2,3,4],[2,3,4,2]]) build(matrix([[1,2,3,4],[2,3,4,2]]),GLS)     ### ceil  Possible use:    ceil (float) —>  float   Result: Maps the operand to the smallest following integer, i.e. the smallest integer not less than x.  Examples:  float var0 <- ceil(3);  // var0 equals 3.0 float var1 <- ceil(3.5);  // var1 equals 4.0 float var2 <- ceil(-4.7);  // var2 equals -4.0   See also: floor, round,    ### centroid  Possible use:    centroid (geometry) —>  point   Result: Centroid (weighted sum of the centroids of a decomposition of the area into triangles) of the operand-geometry. Can be different to the location of the geometry  Examples:  point var0 <- centroid(world);  // var0 equals the centroid of the square, for example : {50.0,50.0}.   See also: any_location_in, closest_points_with, farthest_point_to, points_at,    ### char  Possible use:    char (int) —>  string   Special cases:    converts ACSII integer value to character       string var0 <- char (34);  // var0 equals             ### circle  Possible use:    circle (float) —>  geometry   float circle point —>  geometry   circle (float , point) —>  geometry   Result: A circle geometry which radius is equal to the first operand, and the center has the location equal to the second operand. A circle geometry which radius is equal to the operand.  Comment: the center of the circle is by default the location of the current agent in which has been called this operator.  Special cases:    returns a point if the operand is lower or equal to 0.   returns a point if the operand is lower or equal to 0.   Examples:  geometry var0 <- circle(10,{80,30});  // var0 equals a geometry as a circle of radius 10, the center will be in the location {80,30}. geometry var1 <- circle(10);  // var1 equals a geometry as a circle of radius 10.   See also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,    ### clean  Possible use:    clean (geometry) —>  geometry   Result: A geometry corresponding to the cleaning of the operand (geometry, agent, point)  Comment: The cleaning corresponds to a buffer with a distance of 0.0  Examples:  geometry var0 <- clean(self);  // var0 equals returns the geometry resulting from the cleaning of the geometry of the agent applying the operator.     ### closest_points_with  Possible use:    geometry closest_points_with geometry —>  list<point>   closest_points_with (geometry , geometry) —>  list<point>   Result: A list of two closest points between the two geometries.  Examples:  list<point> var0 <- geom1 closest_points_with(geom2);  // var0 equals [pt1, pt2] with pt1 the closest point of geom1 to geom2 and pt1 the closest point of geom2 to geom1   See also: any_location_in, any_point_in, farthest_point_to, points_at,    ### closest_to  Possible use:    container<agent> closest_to geometry —>  geometry   closest_to (container<agent> , geometry) —>  geometry   Result: An agent or a geometry among the left-operand list of agents, species or meta-population (addition of species), the closest to the operand (casted as a geometry).  Comment: the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.  Examples:  geometry var0 <- [ag1, ag2, ag3] closest_to(self);  // var0 equals return the closest agent among ag1, ag2 and ag3 to the agent applying the operator. (species1 + species2) closest_to self   See also: neighbors_at, neighbors_of, inside, overlapping, agents_overlapping, agents_inside, agent_closest_to,    ### collect  Possible use:    container collect any expression —>  container   collect (container , any expression) —>  container   Result: returns a new list, in which each element is the evaluation of the right-hand operand.  Comment: collect is similar to accumulate except that accumulate always produces flat lists if the right-hand operand returns a list.In addition, collect can be applied to any container.  Special cases:    if the left-hand operand is nil, collect throws an error   Examples:  container var0 <- [1,2,4] collect (each *2);  // var0 equals [2,4,8] container var1 <- [1,2,4] collect ([2,4]);  // var1 equals [[2,4],[2,4],[2,4]] container var2 <- [1::2, 3::4, 5::6] collect (each + 2);  // var2 equals [4,6,8] container var3 <- (list(node) collect (node(each).location.x * 2);  // var3 equals the list of nodes with their x multiplied by 2   See also: accumulate,    ### column_at  Possible use:    matrix column_at int —>  list   column_at (matrix , int) —>  list   Result: returns the column at a num_col (right-hand operand)  Examples:  list var0 <- matrix([[el11,el12,el13],[el21,el22,el23],[el31,el32,el33]]) column_at 2;  // var0 equals [el31,el32,el33]   See also: row_at, rows_list,    ### columns_list  Possible use:    columns_list (matrix) —>  list<list>   Result: returns a list of the columns of the matrix, with each column as a list of elements  Examples:  list<list> var0 <- columns_list(matrix([[el11,el12,el13],[el21,el22,el23],[el31,el32,el33]]));  // var0 equals [[el11,el12,el13],[el21,el22,el23],[el31,el32,el33]]   See also: rows_list,    ### command  Possible use:    command (string) —>  string   Result: command allows GAMA to issue a system command using the system terminal or shell and to receive a string containing the outcome of the command or script executed. By default, commands are blocking the agent calling them, unless the sequence   &  is used at the end. In this case, the result of the operator is an empty string    ### cone  Possible use:    cone (point) —>  geometry   int cone int —>  geometry   cone (int , int) —>  geometry   Result: A cone geometry which min and max angles are given by the operands. A cone geometry which min and max angles are given by the operands.  Comment: the center of the cone is by default the location of the current agent in which has been called this operator.the center of the cone is by default the location of the current agent in which has been called this operator.  Special cases:    returns nil if the operand is nil.   returns nil if the operand is nil.   Examples:  geometry var0 <- cone({0, 45});  // var0 equals a geometry as a cone with min angle is 0 and max angle is 45. geometry var1 <- cone(0, 45);  // var1 equals a geometry as a cone with min angle is 0 and max angle is 45.   See also: around, circle, line, link, norm, point, polygon, polyline, rectangle, square, triangle,    ### cone3D  Possible use:    float cone3D float —>  geometry   cone3D (float , float) —>  geometry   Result: A cone geometry which base radius size is equal to the first operand, and which the height is equal to the second operand.  Comment: the center of the cone is by default the location of the current agent in which has been called this operator.  Special cases:    returns a point if the operand is lower or equal to 0.   Examples:  geometry var0 <- cone3D(10.0,5.0);  // var0 equals a geometry as a cone with a base circle of radius 10 and a height of 5.   See also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,    ### connected_components_of  Possible use:    connected_components_of (graph) —>  list<list>   Result: returns the connected components of of a graph, i.e. the list of all vertices that are in the maximally connected component together with the specified vertex.  Examples:  graph my_graph <- graph([]); list<list> var1 <- connected_components_of (my_graph);  // var1 equals the list of all the components as list   See also: alpha_index, connectivity_index, nb_cycles,    ### connectivity_index  Possible use:    connectivity_index (graph) —>  float   Result: returns a simple connectivity index. This number is estimated through the number of nodes (v) and of sub-graphs (p) : IC = (v - p) /(v - 1).  Examples:  graph graphEpidemio <- graph([]); float var1 <- connectivity_index(graphEpidemio);  // var1 equals the connectivity index of the graph   See also: alpha_index, beta_index, gamma_index, nb_cycles,    ### container  Possible use:    container (any) —>  container   Result: Casts the operand into the type container    ### contains  Possible use:    container<KeyType,ValueType> contains unknown —>  bool   contains (container<KeyType,ValueType> , unknown) —>  bool   string contains string —>  bool   contains (string , string) —>  bool   Result: true, if the container contains the right operand, false otherwise  Comment: the contains operator behavior depends on the nature of the operand  Special cases:    if it is a map, contains returns true if the operand is a key of the map   if it is a file, contains returns true it the operand is contained in the file content   if it is a population, contains returns true if the operand is an agent of the population, false otherwise   if it is a graph, contains returns true if the operand is a node or an edge of the graph, false otherwise   if both operands are strings, returns true if the right-hand operand contains the right-hand pattern;   if it is a list or a matrix, contains returns true if the list or matrix contains the right operand       bool var0 <- [1, 2, 3] contains 2;  // var0 equals true bool var1 <- [{1,2}, {3,4}, {5,6}] contains {3,4};  // var1 equals true       Examples:  bool var2 <-  abcded  contains  bc ;  // var2 equals true   See also: contains_all, contains_any,    ### contains_all  Possible use:    container contains_all container —>  bool   contains_all (container , container) —>  bool   string contains_all list —>  bool   contains_all (string , list) —>  bool   Result: true if the left operand contains all the elements of the right operand, false otherwise  Comment: the definition of contains depends on the container  Special cases:    if the right operand is nil or empty, contains_all returns true   if the left-operand is a string, test whether the string contains all the element of the list;       bool var4 <-  abcabcabc  contains_all [ ca , xy ];  // var4 equals false       Examples:  bool var0 <- [1,2,3,4,5,6] contains_all [2,4];  // var0 equals true  bool var1 <- [1,2,3,4,5,6] contains_all [2,8];  // var1 equals false bool var2 <- [1::2, 3::4, 5::6] contains_all [1,3];  // var2 equals false  bool var3 <- [1::2, 3::4, 5::6] contains_all [2,4];  // var3 equals true   See also: contains, contains_any,    ### contains_any  Possible use:    container contains_any container —>  bool   contains_any (container , container) —>  bool   string contains_any list —>  bool   contains_any (string , list) —>  bool   Result: true if the left operand contains one of the elements of the right operand, false otherwise  Comment: the definition of contains depends on the container  Special cases:    if the right operand is nil or empty, contains_any returns false   Examples:  bool var0 <- [1,2,3,4,5,6] contains_any [2,4];  // var0 equals true  bool var1 <- [1,2,3,4,5,6] contains_any [2,8];  // var1 equals true bool var2 <- [1::2, 3::4, 5::6] contains_any [1,3];  // var2 equals false bool var3 <- [1::2, 3::4, 5::6] contains_any [2,4];  // var3 equals true bool var4 <- abcabcabc contains_any [ca,xy];  // var4 equals true   See also: contains, contains_all,    ### contains_edge  Possible use:    graph contains_edge unknown —>  bool   contains_edge (graph , unknown) —>  bool   graph contains_edge pair —>  bool   contains_edge (graph , pair) —>  bool   Result: returns true if the graph(left-hand operand) contains the given edge (righ-hand operand), false otherwise  Special cases:    if the left-hand operand is nil, returns false   if the right-hand operand is a pair, returns true if it exists an edge between the two elements of the pair in the graph       bool var2 <- graphEpidemio contains_edge (node(0)::node(3));  // var2 equals true       Examples:  graph graphFromMap <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); bool var1 <- graphFromMap contains_edge link({1,5}::{12,45});  // var1 equals true   See also: contains_vertex,    ### contains_vertex  Possible use:    graph contains_vertex unknown —>  bool   contains_vertex (graph , unknown) —>  bool   Result: returns true if the graph(left-hand operand) contains the given vertex (righ-hand operand), false otherwise  Special cases:    if the left-hand operand is nil, returns false   Examples:  graph graphFromMap<-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); bool var1 <- graphFromMap contains_vertex {1,5};  // var1 equals true   See also: contains_edge,    ### conversation  Possible use:    conversation (unknown) —>  conversation     ### convex_hull  Possible use:    convex_hull (geometry) —>  geometry   Result: A geometry corresponding to the convex hull of the operand.  Examples:  geometry var0 <- convex_hull(self);  // var0 equals the convex hull of the geometry of the agent applying the operator     ### copy  Possible use:    copy (unknown) —>  unknown   Result: returns a copy of the operand.    ### copy_between  Possible use:    copy_between (string, int, int) —>  string   copy_between (container, int, int) —>  container   Result: Returns a copy of the first operand between the indexes determined by the second (inclusive) and third operands (exclusive)  Special cases:    If the first operand is empty, returns an empty object of the same type   If the second operand is greater than or equal to the third operand, return an empty object of the same type   If the first operand is nil, raises an error   Examples:  string var0 <- copy_between(abcabcabc, 2,6);  // var0 equals cabc container var1 <-  copy_between ([4, 1, 6, 9 ,7], 1, 3);  // var1 equals [1, 6]     ### corR  Possible use:    container corR container —>  unknown   corR (container , container) —>  unknown   Result: returns the Pearson correlation coefficient of two given vectors (right-hand operands) in given variable  (left-hand operand).  Special cases:    if the lengths of two vectors in the right-hand aren t equal, returns 0   Examples:  list X <- [1, 2, 3]; list Y <- [1, 2, 4]; unknown var2 <- corR(X, Y);  // var2 equals 0.981980506061966     ### cos  Possible use:    cos (int) —>  float   cos (float) —>  float   Result: Returns the value (in [-1,1]) of the cosinus of the operand (in decimal degrees).  The argument is casted to an int before being evaluated.  Special cases:    Operand values out of the range [0-359] are normalized.   Examples:  float var0 <- cos (0);  // var0 equals 1.0 float var1 <- cos(360);  // var1 equals 1.0 float var2 <- cos(-720);  // var2 equals 1.0   See also: sin, tan,    ### cos_rad  Possible use:    cos_rad (float) —>  float   Result: Returns the value (in [-1,1]) of the cosinus of the operand (in decimal degrees).  The argument is casted to an int before being evaluated.  Special cases:    Operand values out of the range [0-359] are normalized.   See also: sin, tan,    ### count  Possible use:    container count any expression —>  int   count (container , any expression) —>  int   Result: returns an int, equal to the number of elements of the left-hand operand that make the right-hand operand evaluate to true.  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.  Special cases:    if the left-hand operand is nil, count throws an error   Examples:  int var0 <- [1,2,3,4,5,6,7,8] count (each > 3);  // var0 equals 5 // Number of nodes of graph g2 without any out edge graph g2 <- graph([]); int var3 <- g2 count (length(g2 out_edges_of each) = 0  ) ;  // var3 equals the total number of out edges // Number of agents node with x > 32 int n <- (list(node) count (round(node(each).location.x) > 32); int var6 <- [1::2, 3::4, 5::6] count (each > 4);  // var6 equals 1   See also: group_by,    ### covers  Possible use:    geometry covers geometry —>  bool   covers (geometry , geometry) —>  bool   Result: A boolean, equal to true if the left-geometry (or agent/point) covers the right-geometry (or agent/point).  Special cases:    if one of the operand is null, returns false.   Examples:  bool var0 <- square(5) covers square(2);  // var0 equals true   See also: disjoint_from, crosses, overlaps, partially_overlaps, touches,    ### cross  Possible use:    cross (float) —>  geometry   float cross float —>  geometry   cross (float , float) —>  geometry   Result: A cross, which radius is equal to the first operand A cross, which radius is equal to the first operand and the width of the lines for the second  Examples:  geometry var0 <- cross(10);  // var0 equals a geometry as a cross of radius 10 geometry var1 <- cross(10,2);  // var1 equals a geometry as a cross of radius 10, and with a width of 2 for the lines    See also: around, cone, line, link, norm, point, polygon, polyline, super_ellipse, rectangle, square, circle, ellipse, triangle,    ### crosses  Possible use:    geometry crosses geometry —>  bool   crosses (geometry , geometry) —>  bool   Result: A boolean, equal to true if the left-geometry (or agent/point) crosses the right-geometry (or agent/point).  Special cases:    if one of the operand is null, returns false.   if one operand is a point, returns false.   Examples:  bool var0 <- polyline([{10,10},{20,20}]) crosses polyline([{10,20},{20,10}]);  // var0 equals true bool var1 <- polyline([{10,10},{20,20}]) crosses {15,15};  // var1 equals true bool var2 <- polyline([{0,0},{25,25}]) crosses polygon([{10,10},{10,20},{20,20},{20,10}]);  // var2 equals true   See also: disjoint_from, intersects, overlaps, partially_overlaps, touches,    ### crs  Possible use:    crs (file) —>  string   Result: the Coordinate Reference System (CRS) of the GIS file  Examples:  string var0 <- crs(my_shapefile);  // var0 equals the crs of the shapefile     ### CRS_transform  Possible use:    CRS_transform (geometry) —>  geometry   geometry CRS_transform string —>  geometry   CRS_transform (geometry , string) —>  geometry   Special cases:    returns the geometry corresponding to the transformation of the given geometry by the left operand CRS (Coordinate Reference System)       geometry var0 <- shape CRS_transform( EPSG:4326 );  // var0 equals a geometry corresponding to the agent geometry transformed into the EPSG:4326 CRS          returns the geometry corresponding to the transformation of the given geometry by the current CRS (Coordinate Reference System), the one corresponding to the world s agent one       geometry var1 <- CRS_transform(shape);  // var1 equals a geometry corresponding to the agent geometry transformed into the current CRS         ### csv_file  Possible use:    csv_file (string) —>  file   Result: Constructs a file of type csv. Allowed extensions are limited to csv, tsv    ### cube  Possible use:    cube (float) —>  geometry   Result: A cube geometry which side size is equal to the operand.  Comment: the center of the cube is by default the location of the current agent in which has been called this operator.  Special cases:    returns nil if the operand is nil.   Examples:  geometry var0 <- cube(10);  // var0 equals a geometry as a square of side size 10.   See also: around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, triangle,    ### curve  Possible use:    curve (point, point, point) —>  geometry   curve (point, point, point, int) —>  geometry   curve (point, point, point, point) —>  geometry   curve (point, point, point, point, int) —>  geometry   Result: A quadratic Bezier curve geometry built from the three given points composed of a given numnber of points. A quadratic Bezier curve geometry built from the three given points composed of 10 points. A cubic Bezier curve geometry built from the four given points composed of a given number of points. A cubic Bezier curve geometry built from the four given points composed of 10 points.  Special cases:    if the operand is nil, returns nil   if the last operand (number of points) is inferior to 2, returns nil   if the operand is nil, returns nil   if the operand is nil, returns nil   if the last operand (number of points) is inferior to 2, returns nil   if the operand is nil, returns nil   Examples:  geometry var0 <- curve({0,0}, {0,10}, {10,10}, 20);  // var0 equals a quadratic Bezier curve geometry composed of 20 points from p0 to p2. geometry var1 <- curve({0,0}, {0,10}, {10,10});  // var1 equals a quadratic Bezier curve geometry composed of 10 points from p0 to p2. geometry var2 <- curve({0,0}, {0,10}, {10,10});  // var2 equals a cubic Bezier curve geometry composed of 10 points from p0 to p3. geometry var3 <- curve({0,0}, {0,10}, {10,10});  // var3 equals a cubic Bezier curve geometry composed of 10 points from p0 to p3.   See also: around, circle, cone, link, norm, point, polygone, rectangle, square, triangle, line,    ### cylinder  Possible use:    float cylinder float —>  geometry   cylinder (float , float) —>  geometry   Result: A cylinder geometry which radius is equal to the operand.  Comment: the center of the cylinder is by default the location of the current agent in which has been called this operator.  Special cases:    returns a point if the operand is lower or equal to 0.   Examples:  geometry var0 <- cylinder(10,10);  // var0 equals a geometry as a circle of radius 10.   See also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,    ### date  Possible use:    string date string —>  date   date (string , string) —>  date   Result: converts a string to a date following a custom pattern. The pattern can use  %Y %M %N %D %E %h %m %s %z  for outputting years, months, name of month, days, name of days, hours, minutes, seconds and the time-zone. A null or empty pattern will parse the date using one of the ISO date & time formats (similar to date( … ) in that case). The pattern can also follow the pattern definition found here, which gives much more control over what will be parsed: https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns. Different patterns are available by default as constant: #iso_local, #iso_simple, #iso_offset, #iso_zoned and #custom, which can be changed in the preferences  Examples:  date(1999-12-30,  yyyy-MM-dd )     ### dbscan  Possible use:    dbscan (list, float, int) —>  list<list>   Result: returns the list of clusters (list of instance indices) computed with the dbscan (density-based spatial clustering of applications with noise) algorithm from the first operand data according to the maximum radius of the neighborhood to be considered (eps) and the minimum number of points needed for a cluster (minPts). Usage: dbscan(data,eps,minPoints)  Special cases:    if the lengths of two vectors in the right-hand aren t equal, returns 0   Examples:  dbscan ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],10,2)     ### dead  Possible use:    dead (agent) —>  bool   Result: true if the agent is dead (or null), false otherwise.  Examples:  bool var0 <- dead(agent_A);  // var0 equals true or false     ### degree_of  Possible use:    graph degree_of unknown —>  int   degree_of (graph , unknown) —>  int   Result: returns the degree (in+out) of a vertex (right-hand operand) in the graph given as left-hand operand.  Examples:  int var1 <- graphFromMap degree_of (node(3));  // var1 equals 3   See also: in_degree_of, out_degree_of,    ### dem  Possible use:    dem (file) —>  geometry   file dem file —>  geometry   dem (file , file) —>  geometry   file dem float —>  geometry   dem (file , float) —>  geometry   dem (file, file, float) —>  geometry   Result: A polygon that is equivalent to the surface of the texture  Examples:  geometry var0 <- dem(dem,texture,z_factor);  // var0 equals a geometry as a rectangle of width and height equal to the texture. geometry var1 <- dem(dem,texture);  // var1 equals a geometry as a rectangle of weight and height equal to the texture. geometry var2 <- dem(dem,z_factor);  // var2 equals a geometry as a rectangle of weight and height equal to the texture. geometry var3 <- dem(dem);  // var3 equals returns a geometry as a rectangle of width and height equal to the texture.     ### det Same signification as determinant    ### determinant  Possible use:    determinant (matrix) —>  float   Result: The determinant of the given matrix  Examples:  float var0 <- determinant(matrix([[1,2],[3,4]]));  // var0 equals -2     ### diff  Possible use:    float diff float —>  float   diff (float , float) —>  float     ### diff2  Possible use:    float diff2 float —>  float   diff2 (float , float) —>  float     ### directed  Possible use:    directed (graph) —>  graph   Result: the operand graph becomes a directed graph.  Comment: the operator alters the operand graph, it does not create a new one.  See also: undirected,    ### direction_between  Possible use:    topology direction_between container<geometry> —>  int   direction_between (topology , container<geometry>) —>  int   Result: A direction (in degree) between a list of two geometries (geometries, agents, points) considering a topology.  Examples:  int var0 <- my_topology direction_between [ag1, ag2];  // var0 equals the direction between ag1 and ag2 considering the topology my_topology   See also: towards, direction_to, distance_to, distance_between, path_between, path_to,    ### direction_to Same signification as towards    ### disjoint_from  Possible use:    geometry disjoint_from geometry —>  bool   disjoint_from (geometry , geometry) —>  bool   Result: A boolean, equal to true if the left-geometry (or agent/point) is disjoints from the right-geometry (or agent/point).  Special cases:    if one of the operand is null, returns true.   if one operand is a point, returns false if the point is included in the geometry.   Examples:  bool var0 <- polyline([{10,10},{20,20}]) disjoint_from polyline([{15,15},{25,25}]);  // var0 equals false bool var1 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{15,15},{15,25},{25,25},{25,15}]);  // var1 equals false bool var2 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from {15,15};  // var2 equals false bool var3 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from {25,25};  // var3 equals true bool var4 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{35,35},{35,45},{45,45},{45,35}]);  // var4 equals true   See also: intersects, crosses, overlaps, partially_overlaps, touches,    ### distance_between  Possible use:    topology distance_between container<geometry> —>  float   distance_between (topology , container<geometry>) —>  float   Result: A distance between a list of geometries (geometries, agents, points) considering a topology.  Examples:  float var0 <- my_topology distance_between [ag1, ag2, ag3];  // var0 equals the distance between ag1, ag2 and ag3 considering the topology my_topology   See also: towards, direction_to, distance_to, direction_between, path_between, path_to,    ### distance_to  Possible use:    geometry distance_to geometry —>  float   distance_to (geometry , geometry) —>  float   point distance_to point —>  float   distance_to (point , point) —>  float   Result: A distance between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.  Examples:  float var0 <- ag1 distance_to ag2;  // var0 equals the distance between ag1 and ag2 considering the topology of the agent applying the operator   See also: towards, direction_to, distance_between, direction_between, path_between, path_to,    ### distinct  Possible use:    distinct (container) —>  container   Result: produces a set from the elements of the operand (i.e. a list without duplicated elements)  Special cases:    if the operand is nil, remove_duplicates returns nil   if the operand is a graph, remove_duplicates returns the set of nodes   if the operand is a matrix, remove_duplicates returns a matrix without duplicated row   if the operand is a map, remove_duplicates returns the set of values without duplicate       container var1 <- remove_duplicates([1::3,2::4,3::3,5::7]);  // var1 equals [3,4,7]       Examples:  container var0 <- remove_duplicates([3,2,5,1,2,3,5,5,5]);  // var0 equals [3,2,5,1]     ### distribution_of  Possible use:    distribution_of (container) —>  map   container distribution_of int —>  map   distribution_of (container , int) —>  map   distribution_of (container, int, float, float) —>  map   Result: Discretize a list of values into n bins (computes the bins from a numerical variable into n (default 10) bins. Returns a distribution map with the values (values key), the interval legends (legend key), the distribution parameters (params keys, for cumulative charts). Parameters can be (list), (list, nbbins) or (list,nbbins,valmin,valmax)  Examples:  map var0 <- distribution_of([1,1,2,12.5]);  // var0 equals map([ values ::[2,1,0,0,0,0,1,0,0,0], legend ::[ [0.0:2.0] , [2.0:4.0] , [4.0:6.0] , [6.0:8.0] , [8.0:10.0] , [10.0:12.0] , [12.0:14.0] , [14.0:16.0] , [16.0:18.0] , [18.0:20.0] ], parlist ::[1,0]]) map var1 <- distribution_of([1,1,2,12.5],10);  // var1 equals map([ values ::[2,1,0,0,0,0,1,0,0,0], legend ::[ [0.0:2.0] , [2.0:4.0] , [4.0:6.0] , [6.0:8.0] , [8.0:10.0] , [10.0:12.0] , [12.0:14.0] , [14.0:16.0] , [16.0:18.0] , [18.0:20.0] ], parlist ::[1,0]]) map var2 <- distribution_of([1,1,2,12.5]);  // var2 equals map([ values ::[2,1,0,0,0,0,1,0,0,0], legend ::[ [0.0:2.0] , [2.0:4.0] , [4.0:6.0] , [6.0:8.0] , [8.0:10.0] , [10.0:12.0] , [12.0:14.0] , [14.0:16.0] , [16.0:18.0] , [18.0:20.0] ], parlist ::[1,0]])   See also: as_map,    ### distribution2d_of  Possible use:    container distribution2d_of container —>  map   distribution2d_of (container , container) —>  map   distribution2d_of (container, container, int, int) —>  map   distribution2d_of (container, container, int, float, float, int, float, float) —>  map   Result: Discretize two lists of values into n bins (computes the bins from a numerical variable into n (default 10) bins. Returns a distribution map with the values (values key), the interval legends (legend key), the distribution parameters (params keys, for cumulative charts). Parameters can be (list), (list, nbbins) or (list,nbbins,valmin,valmax)  Examples:  map var0 <- distribution_of([1,1,2,12.5],10);  // var0 equals map([ values ::[2,1,0,0,0,0,1,0,0,0], legend ::[ [0.0:2.0] , [2.0:4.0] , [4.0:6.0] , [6.0:8.0] , [8.0:10.0] , [10.0:12.0] , [12.0:14.0] , [14.0:16.0] , [16.0:18.0] , [18.0:20.0] ], parlist ::[1,0]]) map var1 <- distribution2d_of([1,1,2,12.5]);  // var1 equals map([ values ::[2,1,0,0,0,0,1,0,0,0], legend ::[ [0.0:2.0] , [2.0:4.0] , [4.0:6.0] , [6.0:8.0] , [8.0:10.0] , [10.0:12.0] , [12.0:14.0] , [14.0:16.0] , [16.0:18.0] , [18.0:20.0] ], parlist ::[1,0]]) map var2 <- distribution_of([1,1,2,12.5],10);  // var2 equals map([ values ::[2,1,0,0,0,0,1,0,0,0], legend ::[ [0.0:2.0] , [2.0:4.0] , [4.0:6.0] , [6.0:8.0] , [8.0:10.0] , [10.0:12.0] , [12.0:14.0] , [14.0:16.0] , [16.0:18.0] , [18.0:20.0] ], parlist ::[1,0]])   See also: as_map,    ### div  Possible use:    float div float —>  int   div (float , float) —>  int   int div int —>  int   div (int , int) —>  int   float div int —>  int   div (float , int) —>  int   int div float —>  int   div (int , float) —>  int   Result: Returns the truncation of the division of the left-hand operand by the right-hand operand.  Special cases:    if the right-hand operand is equal to zero, raises an exception.   if the right-hand operand is equal to zero, raises an exception.   if the right-hand operand is equal to zero, raises an exception.   Examples:  int var0 <- 40.1 div 4.5;  // var0 equals 8 int var1 <- 40 div 3;  // var1 equals 13 int var2 <- 40.5 div 3;  // var2 equals 13 int var3 <- 40 div 4.1;  // var3 equals 9   See also: mod,    ### dxf_file  Possible use:    dxf_file (string) —>  file   Result: Constructs a file of type dxf. Allowed extensions are limited to dxf    ### edge  Possible use:    edge (pair) —>  unknown   edge (unknown) —>  unknown   unknown edge unknown —>  unknown   edge (unknown , unknown) —>  unknown   pair edge float —>  unknown   edge (pair , float) —>  unknown   unknown edge float —>  unknown   edge (unknown , float) —>  unknown   edge (unknown, unknown, unknown) —>  unknown   edge (unknown, unknown, float) —>  unknown   edge (pair, unknown, float) —>  unknown   edge (unknown, unknown, unknown, float) —>  unknown     ### edge_between  Possible use:    graph edge_between pair —>  unknown   edge_between (graph , pair) —>  unknown   Result: returns the edge linking two nodes  Examples:  unknown var0 <- graphFromMap edge_between node1::node2;  // var0 equals edge1   See also: out_edges_of, in_edges_of,    ### edge_betweenness  Possible use:    edge_betweenness (graph) —>  map   Result: returns a map containing for each edge (key), its betweenness centrality (value): number of shortest paths passing through each edge  Examples:  graph graphEpidemio <- graph([]); map var1 <- edge_betweenness(graphEpidemio);  // var1 equals the edge betweenness index of the graph     ### edges  Possible use:    edges (container) —>  container     ### eigenvalues  Possible use:    eigenvalues (matrix) —>  list<float>   Result: The eigen values (matrix) of the given matrix  Examples:  list<float> var0 <- eigenvalues(matrix([[5,-3],[6,-4]]));  // var0 equals [2.0000000000000004,-0.9999999999999998]     ### electre_DM  Possible use:    electre_DM (list<list>, list<map<string,object>>, float) —>  int   Result: The index of the best candidate according to a method based on the ELECTRE methods. The principle of the ELECTRE methods is to compare the possible candidates by pair. These methods analyses the possible outranking relation existing between two candidates. An candidate outranks another if this one is at least as good as the other one. The ELECTRE methods are based on two concepts: the concordance and the discordance. The concordance characterizes the fact that, for an outranking relation to be validated, a sufficient majority of criteria should be in favor of this assertion. The discordance characterizes the fact that, for an outranking relation to be validated, none of the criteria in the minority should oppose too strongly this assertion. These two conditions must be true for validating the outranking assertion. More information about the ELECTRE methods can be found in [http://www.springerlink.com/content/g367r44322876223/ Figueira,  J., Mousseau, V., Roy, B.: ELECTRE Methods. In: Figueira, J., Greco, S., and Ehrgott, M., (Eds.), Multiple Criteria Decision Analysis: State of the Art Surveys, Springer, New York, 133–162 (2005)]. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains fives elements: a name, a weight, a preference value (p), an indifference value (q) and a veto value (v). The preference value represents the threshold from which the difference between two criterion values allows to prefer one vector of values over another. The indifference value represents the threshold from which the difference between two criterion values is considered significant. The veto value represents the threshold from which the difference between two criterion values disqualifies the candidate that obtained the smaller value; the last operand is the fuzzy cut.  Special cases:    returns -1 is the list of candidates is nil or empty   Examples:  int var0 <- electre_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[name::utility, weight :: 2.0,p::0.5, q::0.0, s::1.0, maximize :: true],[name::price, weight :: 1.0,p::0.5, q::0.0, s::1.0, maximize :: false]]);  // var0 equals 0   See also: weighted_means_DM, promethee_DM, evidence_theory_DM,    ### ellipse  Possible use:    float ellipse float —>  geometry   ellipse (float , float) —>  geometry   Result: An ellipse geometry which x-radius is equal to the first operand and y-radius is equal to the second operand  Comment: the center of the ellipse is by default the location of the current agent in which has been called this operator.  Special cases:    returns a point if both operands are lower or equal to 0, a line if only one is.   Examples:  geometry var0 <- ellipse(10, 10);  // var0 equals a geometry as an ellipse of width 10 and height 10.   See also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, circle, squircle, triangle,    ### emotion  Possible use:    emotion (any) —>  emotion   Result: Casts the operand into the type emotion    ### empty  Possible use:    empty (container<KeyType,ValueType>) —>  bool   empty (string) —>  bool   Result: true if the operand is empty, false otherwise.  Comment: the empty operator behavior depends on the nature of the operand  Special cases:    if it is a map, empty returns true if the map contains no key-value mappings, and false otherwise   if it is a file, empty returns true if the content of the file (that is also a container) is empty, and false otherwise   if it is a population, empty returns true if there is no agent in the population, and false otherwise   if it is a graph, empty returns true if it contains no vertex and no edge, and false otherwise   if it is a matrix of int, float or object, it will return true if all elements are respectively 0, 0.0 or null, and false otherwise   if it is a matrix of geometry, it will return true if the matrix contains no cell, and false otherwise   if it is a list, empty returns true if there is no element in the list, and false otherwise       bool var0 <- empty([]);  // var0 equals true          if it is a string, empty returns true if the string does not contain any character, and false otherwise       bool var1 <- empty ( abced );  // var1 equals false         ### enlarged_by Same signification as +    ### envelope  Possible use:    envelope (unknown) —>  geometry   Result: A 3D geometry that represents the box that surrounds the geometries or the surface described by the arguments. More general than geometry(arguments).envelope, as it allows to pass int, double, point, image files, shape files, asc files, or any list combining these arguments, in which case the envelope will be correctly expanded. If an envelope cannot be determined from the arguments, a default one of dimensions (0,100, 0, 100, 0, 100) is returned    ### eval_gaml  Possible use:    eval_gaml (string) —>  unknown   Result: evaluates the given GAML string.  Examples:  unknown var0 <- eval_gaml(2+3);  // var0 equals 5     ### eval_when  Possible use:    eval_when (BDIPlan) —>  bool   Result: evaluate the facet when of a given plan  Examples:  eval_when(plan1)     ### even  Possible use:    even (int) —>  bool   Result: Returns true if the operand is even and false if it is odd.  Special cases:    if the operand is equal to 0, it returns true.   if the operand is a float, it is truncated before   Examples:  bool var0 <- even (3);  // var0 equals false bool var1 <- even(-12);  // var1 equals true     ### every  Possible use:    every (int) —>  bool   every (any expression) —>  bool   msi.gama.util.GamaDateInterval every any expression —>  msi.gama.util.IList<msi.gama.util.GamaDate>   every (msi.gama.util.GamaDateInterval , any expression) —>  msi.gama.util.IList<msi.gama.util.GamaDate>   container every int —>  container   every (container , int) —>  container   Result: true every operand * cycle, false otherwise applies a step to an interval of dates defined by  date1 to date2  expects a frequency (expressed in seconds of simulated time) as argument. Will return true every time the current_date matches with this frequency Retrieves elements from the first argument every step (second argument) elements. Raises an error if the step is negative or equal to zero  Comment: the value of the every operator depends on the cycle. It can be used to do something every x cycle.Used to do something at regular intervals of time. Can be used in conjunction with  since ,  after ,  before ,  until  or  between , so that this computation only takes place in the temporal segment defined by these operators. In all cases, the starting_date of the model is used as a reference starting point  Examples:  if every(2) {write the cycle number is even;}       else {write the cycle number is odd;} (date( 2000-01-01 ) to date( 2010-01-01 )) every (#month) // builds an interval between these two dates which contains all the monthly dates starting from the beginning of the interval reflex when: every(2#days) since date( 2000-01-01 ) { .. } state a { transition to: b when: every(2#mn);} state b { transition to: a when: every(30#s);} // This oscillatory behavior will use the starting_date of the model as its starting point in time   See also: to, since, after,    ### every_cycle Same signification as every    ### evidence_theory_DM  Possible use:    list<list> evidence_theory_DM list<map<string,object>> —>  int   evidence_theory_DM (list<list> , list<map<string,object>>) —>  int   evidence_theory_DM (list<list>, list<map<string,object>>, bool) —>  int   Result: The index of the best candidate according to a method based on the Evidence theory. This theory, which was proposed by Shafer ([http://www.glennshafer.com/books/amte.html Shafer G (1976) A mathematical theory of evidence, Princeton University Press]), is based on the work of Dempster ([http://projecteuclid.org/DPubS?service=UI&version=1.0&verb=Display&handle=euclid.aoms/1177698950 Dempster A (1967) Upper and lower probabilities induced by multivalued mapping. Annals of Mathematical Statistics, vol.  38, pp. 325–339]) on lower and upper probability distributions. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains seven elements: a name, a first threshold s1, a second threshold s2, a value for the assertion  this candidate is the best  at threshold s1 (v1p), a value for the assertion  this candidate is the best  at threshold s2 (v2p), a value for the assertion  this candidate is not the best  at threshold s1 (v1c), a value for the assertion  this candidate is not the best  at threshold s2 (v2c). v1p, v2p, v1c and v2c have to been defined in order that: v1p + v1c <= 1.0; v2p + v2c <= 1.0.; the last operand allows to use a simple version of this multi-criteria decision making method (simple if true)  Special cases:    if the operator is used with only 2 operands (the candidates and the criteria), the last parameter (use simple method) is set to true   returns -1 is the list of candidates is nil or empty   Examples:  int var0 <- evidence_theory_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[name::utility, s1 :: 0.0,s2::1.0, v1p::0.0, v2p::1.0, v1c::0.0, v2c::0.0, maximize :: true],[name::price,  s1 :: 0.0,s2::1.0, v1p::0.0, v2p::1.0, v1c::0.0, v2c::0.0, maximize :: true]], true);  // var0 equals 0   See also: weighted_means_DM, electre_DM,    ### exp  Possible use:    exp (float) —>  float   exp (int) —>  float   Result: Returns Euler s number e raised to the power of the operand.  Special cases:    the operand is casted to a float before being evaluated.   the operand is casted to a float before being evaluated.   Examples:  float var0 <- exp (0);  // var0 equals 1.0   See also: ln,    ### fact  Possible use:    fact (int) —>  float   Result: Returns the factorial of the operand.  Special cases:    if the operand is less than 0, fact returns 0.   Examples:  float var0 <- fact(4);  // var0 equals 24     ### farthest_point_to  Possible use:    geometry farthest_point_to point —>  point   farthest_point_to (geometry , point) —>  point   Result: the farthest point of the left-operand to the left-point.  Examples:  point var0 <- geom farthest_point_to(pt);  // var0 equals the farthest point of geom to pt   See also: any_location_in, any_point_in, closest_points_with, points_at,    ### farthest_to  Possible use:    container<agent> farthest_to geometry —>  geometry   farthest_to (container<agent> , geometry) —>  geometry   Result: An agent or a geometry among the left-operand list of agents, species or meta-population (addition of species), the farthest to the operand (casted as a geometry).  Comment: the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.  Examples:  geometry var0 <- [ag1, ag2, ag3] closest_to(self);  // var0 equals return the farthest agent among ag1, ag2 and ag3 to the agent applying the operator. (species1 + species2) closest_to self   See also: neighbors_at, neighbors_of, inside, overlapping, agents_overlapping, agents_inside, agent_closest_to, closest_to, agent_farthest_to,    ### file  Possible use:    file (string) —>  file   string file container —>  file   file (string , container) —>  file   Result: opens a file in read only mode, creates a GAML file object, and tries to determine and store the file content in the contents attribute. Creates a file in read/write mode, setting its contents to the container passed in parameter  Comment: The file should have a supported extension, see file type definition for supported file extensions.The type of container to pass will depend on the type of file (see the management of files in the documentation). Can be used to copy files since files are considered as containers. For example: save file( image_copy.png , file( image.png )); will copy image.png to image_copy.png  Special cases:    If the specified string does not refer to an existing file, an exception is risen when the variable is used.   Examples:  let fileT type: file value: file(../includes/Stupid_Cell.Data);     // fileT represents the file ../includes/Stupid_Cell.Data    // fileT.contents here contains a matrix storing all the data of the text file   See also: folder, new_folder,    ### file_exists  Possible use:    file_exists (string) —>  bool   Result: Test whether the parameter is the path to an existing file.    ### first  Possible use:    first (string) —>  string   first (container<KeyType,ValueType>) —>  ValueType   int first container —>  container   first (int , container) —>  container   Result: the first value of the operand  Comment: the first operator behavior depends on the nature of the operand  Special cases:    if it is a map, first returns the first value of the first pair (in insertion order)   if it is a file, first returns the first element of the content of the file (that is also a container)   if it is a population, first returns the first agent of the population   if it is a graph, first returns the first edge (in creation order)   if it is a matrix, first returns the element at {0,0} in the matrix   for a matrix of int or float, it will return 0 if the matrix is empty   for a matrix of object or geometry, it will return nil if the matrix is empty   if it is a string, first returns a string composed of its first character       string var0 <- first ( abce );  // var0 equals  a           if it is a list, first returns the first element of the list, or nil if the list is empty       int var1 <- first ([1, 2, 3]);  // var1 equals 1       See also: last,    ### first_of Same signification as first    ### first_with  Possible use:    container first_with any expression —>  unknown   first_with (container , any expression) —>  unknown   Result: the first element of the left-hand operand that makes the right-hand operand evaluate to true.  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    if the left-hand operand is nil, first_with throws an error. If there is no element that satisfies the condition, it returns nil   if the left-operand is a map, the keyword each will contain each value       unknown var4 <- [1::2, 3::4, 5::6] first_with (each >= 4);  // var4 equals 4 unknown var5 <- [1::2, 3::4, 5::6].pairs first_with (each.value >= 4);  // var5 equals 3::4       Examples:  unknown var0 <- [1,2,3,4,5,6,7,8] first_with (each > 3);  // var0 equals 4 unknown var2 <- g2 first_with (length(g2 out_edges_of each) = 0);  // var2 equals node9 unknown var3 <- (list(node) first_with (round(node(each).location.x) > 32);  // var3 equals node2   See also: group_by, last_with, where,    ### flip  Possible use:    flip (float) —>  bool   Result: true or false given the probability represented by the operand  Special cases:    flip 0 always returns false, flip 1 true   Examples:  bool var0 <- flip (0.66666);  // var0 equals 2/3 chances to return true.   See also: rnd,    ### float  Possible use:    float (any) —>  float   Result: Casts the operand into the type float    ### floor  Possible use:    floor (float) —>  float   Result: Maps the operand to the largest previous following integer, i.e. the largest integer not greater than x.  Examples:  float var0 <- floor(3);  // var0 equals 3.0 float var1 <- floor(3.5);  // var1 equals 3.0 float var2 <- floor(-4.7);  // var2 equals -5.0   See also: ceil, round,    ### folder  Possible use:    folder (string) —>  file   Result: opens an existing repository  Special cases:    If the specified string does not refer to an existing repository, an exception is risen.   Examples:  folder(../includes/) file dirT <- folder(../includes/);     // dirT represents the repository ../includes/     // dirT.contents here contains the list of the names of included files   See also: file, new_folder,    ### font  Possible use:    font (string, int, int) —>  font   Result: Creates a new font, by specifying its name (either a font face name like  Lucida Grande Bold  or  Helvetica , or a logical name like  Dialog ,  SansSerif ,  Serif , etc.), a size in points and a style, either #bold, #italic or #plain or a combination (addition) of them.  Examples:  font var0 <- font ( Helvetica Neue ,12, #bold + #italic);  // var0 equals a bold and italic face of the Helvetica Neue family     ### frequency_of  Possible use:    container frequency_of any expression —>  map   frequency_of (container , any expression) —>  map   Result: Returns a map with keys equal to the application of the right-hand argument (like collect) and values equal to the frequency of this key (i.e. how many times it has been obtained)  Examples:  map var0 <- [ag1, ag2, ag3, ag4] frequency_of each.size;  // var0 equals the different sizes as keys and the number of agents of this size as values   See also: as_map,    ### from Same signification as since    ### fuzzy_kappa  Possible use:    fuzzy_kappa (list<agent>, list, list, list<float>, list, matrix<float>, float) —>  float   fuzzy_kappa (list<agent>, list, list, list<float>, list, matrix<float>, float, list) —>  float   Result: fuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance, weights). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling & Software, 21 fuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling & Software, 21  Examples:  fuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2, [1.0,3.0,2.0,2.0,4.0]) fuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2)     ### fuzzy_kappa_sim  Possible use:    fuzzy_kappa_sim (list<agent>, list, list, list, list<float>, list, matrix<float>, float) —>  float   fuzzy_kappa_sim (list<agent>, list, list, list, list<float>, list, matrix<float>, float, list) —>  float   Result: fuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800,  fuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance, weights). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800,  Examples:  fuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2) fuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2,[1.0,3.0,2.0,2.0,4.0])     ### gaml_file  Possible use:    gaml_file (string) —>  file   Result: Constructs a file of type gaml. Allowed extensions are limited to gaml, experiment    ### gamma_index  Possible use:    gamma_index (graph) —>  float   Result: returns the gamma index of the graph (A measure of connectivity that considers the relationship between the number of observed links and the number of possible links: gamma = e/(3 * (v - 2)) - for planar graph.  Examples:  graph graphEpidemio <- graph([]); float var1 <- gamma_index(graphEpidemio);  // var1 equals the gamma index of the graph   See also: alpha_index, beta_index, nb_cycles, connectivity_index,    ### gamma_rnd  Possible use:    float gamma_rnd float —>  float   gamma_rnd (float , float) —>  float   Result: returns a random value from a gamma distribution with specified values of the shape and scale parameters  Examples:  gamma_rnd(10.0,5.0)     ### gauss  Possible use:    gauss (point) —>  float   float gauss float —>  float   gauss (float , float) —>  float   Result: A value from a normally distributed random variable with expected value (mean) and variance (standardDeviation). The probability density function of such a variable is a Gaussian. A value from a normally distributed random variable with expected value (mean) and variance (standardDeviation). The probability density function of such a variable is a Gaussian.  Special cases:    when the operand is a point, it is read as {mean, standardDeviation}   when standardDeviation value is 0.0, it always returns the mean value   when the operand is a point, it is read as {mean, standardDeviation}   when standardDeviation value is 0.0, it always returns the mean value   Examples:  float var0 <- gauss(0,0.3);  // var0 equals 0.22354 float var1 <- gauss(0,0.3);  // var1 equals -0.1357 float var2 <- gauss({0,0.3});  // var2 equals 0.22354 float var3 <- gauss({0,0.3});  // var3 equals -0.1357   See also: skew_gauss, truncated_gauss, poisson,    ### generate_barabasi_albert  Possible use:    generate_barabasi_albert (container<agent>, species, int, bool) —>  graph   generate_barabasi_albert (species, species, int, int, bool) —>  graph   Result: returns a random scale-free network (following Barabasi-Albert (BA) model). returns a random scale-free network (following Barabasi-Albert (BA) model).  Comment: The Barabasi-Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:The Barabasi-Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:  Special cases:     vertices_specy : the species of vertices    edges_species : the species of edges    size : the graph will contain (size + 1) nodes    m : the number of edges added per novel node    synchronized : is the graph and the species of vertices and edges synchronized?    agents : list of existing node agents    edges_species : the species of edges    size : the graph will contain (size + 1) nodes    m : the number of edges added per novel node    synchronized : is the graph and the species of vertices and edges synchronized?   Examples:  graph<yourNodeSpecy,yourEdgeSpecy> graphEpidemio <- generate_barabasi_albert(   yourNodeSpecy,   yourEdgeSpecy,   3,   5,   true); graph<yourNodeSpecy,yourEdgeSpecy> graphEpidemio <- generate_barabasi_albert(   yourListOfNodes,   yourEdgeSpecy,   3,   5,   true);   See also: generate_watts_strogatz,    ### generate_complete_graph  Possible use:    generate_complete_graph (container<agent>, species, bool) —>  graph   generate_complete_graph (container<agent>, species, float, bool) —>  graph   generate_complete_graph (species, species, int, bool) —>  graph   generate_complete_graph (species, species, int, float, bool) —>  graph   Result: returns a fully connected graph. returns a fully connected graph. returns a fully connected graph. returns a fully connected graph.  Comment: Arguments should include following elements:Arguments should include following elements:Arguments should include following elements:Arguments should include following elements:  Special cases:     agents : list of existing node agents    edges_species : the species of edges    layoutRadius : nodes of the graph will be located on a circle with radius layoutRadius and centered in the environment.    synchronized : is the graph and the species of vertices and edges synchronized?    vertices_specy : the species of vertices    edges_species : the species of edges    size : the graph will contain size nodes.    layoutRadius : nodes of the graph will be located on a circle with radius layoutRadius and centered in the environment.    synchronized : is the graph and the species of vertices and edges synchronized?    vertices_specy : the species of vertices    edges_species : the species of edges    size : the graph will contain size nodes.    synchronized : is the graph and the species of vertices and edges synchronized?    agents : list of existing node agents    edges_species : the species of edges    synchronized : is the graph and the species of vertices and edges synchronized?   Examples:  graph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_complete_graph(    myListOfNodes,    myEdgeSpecy,    25,   true); graph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_complete_graph(    myVertexSpecy,    myEdgeSpecy,    10, 25,   true); graph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_complete_graph(    myVertexSpecy,    myEdgeSpecy,    10,   true); graph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_complete_graph(    myListOfNodes,    myEdgeSpecy,   true);   See also: generate_barabasi_albert, generate_watts_strogatz,    ### generate_watts_strogatz  Possible use:    generate_watts_strogatz (container<agent>, species, float, int, bool) —>  graph   generate_watts_strogatz (species, species, int, float, int, bool) —>  graph   Result: returns a random small-world network (following Watts-Strogatz model). returns a random small-world network (following Watts-Strogatz model).  Comment: The Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:The Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:  Special cases:     vertices_specy : the species of vertices    edges_species : the species of edges    size : the graph will contain (size + 1) nodes. Size must be greater than k.    p : probability to  rewire  an edge. So it must be between 0 and 1. The parameter is often called beta in the literature.    k : the base degree of each node. k must be greater than 2 and even.    synchronized : is the graph and the species of vertices and edges synchronized?    agents : list of existing node agents    edges_species : the species of edges    p : probability to  rewire  an edge. So it must be between 0 and 1. The parameter is often called beta in the literature.    k : the base degree of each node. k must be greater than 2 and even.    synchronized : is the graph and the species of vertices and edges synchronized?   Examples:  graph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_watts_strogatz(    myVertexSpecy,    myEdgeSpecy,    2,    0.3,    2,   true); graph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_watts_strogatz(    myListOfNodes,    myEdgeSpecy,    0.3,    2,   true);   See also: generate_barabasi_albert,    ### geojson_file  Possible use:    geojson_file (string) —>  file   Result: Constructs a file of type geojson. Allowed extensions are limited to json, geojson, geo.json    ### geometric_mean  Possible use:    geometric_mean (container) —>  float   Result: the geometric mean of the elements of the operand. See Geometric_mean for more details.  Comment: The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.  Examples:  float var0 <- geometric_mean ([4.5, 3.5, 5.5, 7.0]);  // var0 equals 4.962326343467649   See also: mean, median, harmonic_mean,    ### geometry  Possible use:    geometry (any) —>  geometry   Result: Casts the operand into the type geometry    ### geometry_collection  Possible use:    geometry_collection (container<geometry>) —>  geometry   Result: A geometry collection (multi-geometry) composed of the given list of geometries.  Special cases:    if the operand is nil, returns the point geometry {0,0}   if the operand is composed of a single geometry, returns a copy of the geometry.   Examples:  geometry var0 <- geometry_collection([{0,0}, {0,10}, {10,10}, {10,0}]);  // var0 equals a geometry composed of the 4 points (multi-point).   See also: around, circle, cone, link, norm, point, polygone, rectangle, square, triangle, line,    ### get  Possible use:    geometry get string —>  unknown   get (geometry , string) —>  unknown   agent get string —>  unknown   get (agent , string) —>  unknown   Result: Reads an attribute of the specified geometry (left operand). The attribute name is specified by the right operand. Reads an attribute of the specified agent (left operand). The attribute name is specified by the right operand.  Special cases:    Reading the attribute of a geometry       string geom_area <- a_geometry get( area );     // reads then  area  attribute of  a_geometry  variable then assigns the returned value to the geom_area variable          Reading the attribute of another agent       string agent_name <- an_agent get( name );     // reads then  name  attribute of an_agent then assigns the returned value to the agent_name variable         ### get_about  Possible use:    get_about (emotion) —>  predicate   Result: get the about value of the given emotion  Examples:  get_about(emotion)     ### get_agent  Possible use:    get_agent (msi.gaml.architecture.simplebdi.SocialLink) —>  agent   Result: get the agent value of the given social link  Examples:  get_agent(social_link1)     ### get_agent_cause  Possible use:    get_agent_cause (emotion) —>  agent   get_agent_cause (predicate) —>  agent   Result: get the agent cause value of the given emotion  Examples:  get_agent_cause(emotion)     ### get_decay  Possible use:    get_decay (emotion) —>  float   Result: get the decay value of the given emotion  Examples:  get_decay(emotion)     ### get_dominance  Possible use:    get_dominance (msi.gaml.architecture.simplebdi.SocialLink) —>  float   Result: get the dominance value of the given social link  Examples:  get_dominance(social_link1)     ### get_familiarity  Possible use:    get_familiarity (msi.gaml.architecture.simplebdi.SocialLink) —>  float   Result: get the familiarity value of the given social link  Examples:  get_familiarity(social_link1)     ### get_intensity  Possible use:    get_intensity (emotion) —>  float   Result: get the intensity value of the given emotion  Examples:  emotion set_intensity 12     ### get_lifetime  Possible use:    get_lifetime (predicate) —>  int     ### get_liking  Possible use:    get_liking (msi.gaml.architecture.simplebdi.SocialLink) —>  float   Result: get the liking value of the given social link  Examples:  get_liking(social_link1)     ### get_praiseworthiness  Possible use:    get_praiseworthiness (predicate) —>  float     ### get_priority  Possible use:    get_priority (predicate) —>  float     ### get_solidarity  Possible use:    get_solidarity (msi.gaml.architecture.simplebdi.SocialLink) —>  float   Result: get the solidarity value of the given social link  Examples:  get_solidarity(social_link1)     ### get_super_intention  Possible use:    get_super_intention (predicate) —>  predicate     ### gif_file  Possible use:    gif_file (string) —>  file   Result: Constructs a file of type gif. Allowed extensions are limited to gif    ### gini  Possible use:    gini (list<float>) —>  float   Special cases:    return the Gini Index of the given list of values (list of floats)       float var0 <- gini([1.0, 0.5, 2.0]);  // var0 equals the gini index computed         ### graph  Possible use:    graph (any) —>  graph   Result: Casts the operand into the type graph    ### grayscale  Possible use:    grayscale (rgb) —>  rgb   Result: Converts rgb color to grayscale value  Comment: r=red, g=green, b=blue. Between 0 and 255 and gray = 0.299 * red + 0.587 * green + 0.114 * blue (Photoshop value)  Examples:  rgb var0 <- grayscale (rgb(255,0,0));  // var0 equals to a dark grey   See also: rgb, hsb,    ### grid_at  Possible use:    species grid_at point —>  agent   grid_at (species , point) —>  agent   Result: returns the cell of the grid (right-hand operand) at the position given by the right-hand operand  Comment: If the left-hand operand is a point of floats, it is used as a point of ints.  Special cases:    if the left-hand operand is not a grid cell species, returns nil   Examples:  agent var0 <- grid_cell grid_at {1,2};  // var0 equals the agent grid_cell with grid_x=1 and grid_y = 2     ### grid_cells_to_graph  Possible use:    grid_cells_to_graph (container) —>  graph   Result: creates a graph from a list of cells (operand). An edge is created between neighbors.  Examples:  my_cell_graph<-grid_cells_to_graph(cells_list)     ### grid_file  Possible use:    grid_file (string) —>  file   Result: Constructs a file of type grid. Allowed extensions are limited to asc, tif    ### group_by  Possible use:    container group_by any expression —>  map   group_by (container , any expression) —>  map   Result: Returns a map, where the keys take the possible values of the right-hand operand and the map values are the list of elements of the left-hand operand associated to the key value  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    if the left-hand operand is nil, group_by throws an error   Examples:  map var0 <- [1,2,3,4,5,6,7,8] group_by (each > 3);  // var0 equals [false::[1, 2, 3], true::[4, 5, 6, 7, 8]] map var1 <- g2 group_by (length(g2 out_edges_of each) );  // var1 equals [ 0::[node9, node7, node10, node8, node11], 1::[node6], 2::[node5], 3::[node4]] map var2 <- (list(node) group_by (round(node(each).location.x));  // var2 equals [32::[node5], 21::[node1], 4::[node0], 66::[node2], 96::[node3]] map var3 <- [1::2, 3::4, 5::6] group_by (each > 4);  // var3 equals [false::[2, 4], true::[6]]   See also: first_with, last_with, where,    ### harmonic_mean  Possible use:    harmonic_mean (container) —>  float   Result: the harmonic mean of the elements of the operand. See Harmonic_mean for more details.  Comment: The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.  Examples:  float var0 <- harmonic_mean ([4.5, 3.5, 5.5, 7.0]);  // var0 equals 4.804159445407279   See also: mean, median, geometric_mean,    ### hexagon  Possible use:    hexagon (point) —>  geometry   hexagon (float) —>  geometry   Result: A hexagon geometry which the given with and height  Comment: the center of the hexagon is by default the location of the current agent in which has been called this operator.the center of the hexagon is by default the location of the current agent in which has been called this operator.  Special cases:    returns nil if the operand is nil.   returns nil if the operand is nil.   Examples:  geometry var0 <- hexagon({10,5});  // var0 equals a geometry as a hexagon of width of 10 and height of 5. geometry var1 <- hexagon(10);  // var1 equals a geometry as a hexagon of width of 10 and height of 10.   See also: around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, triangle,    ### hierarchical_clustering  Possible use:    container<agent> hierarchical_clustering float —>  container   hierarchical_clustering (container<agent> , float) —>  container   Result: A tree (list of list) contained groups of agents clustered by distance considering a distance min between two groups.  Comment: use of hierarchical clustering with Minimum for linkage criterion between two groups of agents.  Examples:  container var0 <- [ag1, ag2, ag3, ag4, ag5] hierarchical_clustering 20.0;  // var0 equals for example, can return [[[ag1],[ag3]], [ag2], [[[ag4],[ag5]],[ag6]]   See also: simple_clustering_by_distance,    ### hsb  Possible use:    hsb (float, float, float) —>  rgb   hsb (float, float, float, int) —>  rgb   hsb (float, float, float, float) —>  rgb   Result: Converts hsb (h=hue, s=saturation, b=brightness) value to Gama color  Comment: h,s and b components should be floating-point values between 0.0 and 1.0 and when used alpha should be an integer (between 0 and 255) or a float (between 0 and 1) . Examples: Red=(0.0,1.0,1.0), Yellow=(0.16,1.0,1.0), Green=(0.33,1.0,1.0), Cyan=(0.5,1.0,1.0), Blue=(0.66,1.0,1.0), Magenta=(0.83,1.0,1.0)  Examples:  rgb var0 <- hsb (0.5,1.0,1.0,0.0);  // var0 equals rgb(cyan,0) rgb var1 <- hsb (0.0,1.0,1.0);  // var1 equals rgb(red)   See also: rgb,    ### hypot  Possible use:    hypot (float, float, float, float) —>  float   Result: Returns sqrt(x2 +y2) without intermediate overflow or underflow.  Special cases:    If either argument is infinite, then the result is positive infinity. If either argument is NaN and neither argument is infinite, then the result is NaN.   Examples:  float var0 <- hypot(0,1,0,1);  // var0 equals sqrt(2)     ### IDW  Possible use:    IDW (container<agent>, map<point,float>, int) —>  map<agent,float>   Result: Inverse Distance Weighting (IDW) is a type of deterministic method for multivariate interpolation with a known scattered set of points. The assigned values to each geometry are calculated with a weighted average of the values available at the known points. See: http://en.wikipedia.org/wiki/Inverse_distance_weighting Usage: IDW (list of geometries, map of points (key: point, value: value), power parameter)  Examples:  map<agent,float> var0 <- IDW([ag1, ag2, ag3, ag4, ag5],[{10,10}::25.0, {10,80}::10.0, {100,10}::15.0], 2);  // var0 equals for example, can return [ag1::12.0, ag2::23.0,ag3::12.0,ag4::14.0,ag5::17.0]     ### image_file  Possible use:    image_file (string) —>  file   Result: Constructs a file of type image. Allowed extensions are limited to tiff, jpg, jpeg, png, pict, bmp    ### in  Possible use:    unknown in container —>  bool   in (unknown , container) —>  bool   string in string —>  bool   in (string , string) —>  bool   Result: true if the right operand contains the left operand, false otherwise  Comment: the definition of in depends on the container  Special cases:    if the right operand is nil or empty, in returns false   if both operands are strings, returns true if the left-hand operand patterns is included in to the right-hand string;   Examples:  bool var0 <- 2 in [1,2,3,4,5,6];  // var0 equals true bool var1 <- 7 in [1,2,3,4,5,6];  // var1 equals false bool var2 <- 3 in [1::2, 3::4, 5::6];  // var2 equals false bool var3 <- 6 in [1::2, 3::4, 5::6];  // var3 equals true bool var4 <-   bc  in  abcded ;  // var4 equals true   See also: contains,    ### in_degree_of  Possible use:    graph in_degree_of unknown —>  int   in_degree_of (graph , unknown) —>  int   Result: returns the in degree of a vertex (right-hand operand) in the graph given as left-hand operand.  Examples:  int var1 <- graphFromMap in_degree_of (node(3));  // var1 equals 2   See also: out_degree_of, degree_of,    ### in_edges_of  Possible use:    graph in_edges_of unknown —>  container   in_edges_of (graph , unknown) —>  container   Result: returns the list of the in-edges of a vertex (right-hand operand) in the graph given as left-hand operand.  Examples:  container var1 <- graphFromMap in_edges_of node({12,45});  // var1 equals [LineString]   See also: out_edges_of,    ### indented_by  Possible use:    string indented_by int —>  string   indented_by (string , int) —>  string   Result: Converts a (possibly multiline) string by indenting it by a number – specified by the second operand – of tabulations to the right    ### index_by  Possible use:    container index_by any expression —>  map   index_by (container , any expression) —>  map   Result: produces a new map from the evaluation of the right-hand operand for each element of the left-hand operand  Special cases:    if the left-hand operand is nil, index_by throws an error. If the operation results in duplicate keys, only the first value corresponding to the key is kept   Examples:  map var0 <- [1,2,3,4,5,6,7,8] index_by (each - 1);  // var0 equals [0::1, 1::2, 2::3, 3::4, 4::5, 5::6, 6::7, 7::8]     ### index_of  Possible use:    container index_of unknown —>  int   index_of (container , unknown) —>  int   map index_of unknown —>  unknown   index_of (map , unknown) —>  unknown   matrix index_of unknown —>  point   index_of (matrix , unknown) —>  point   string index_of string —>  int   index_of (string , string) —>  int   species index_of unknown —>  int   index_of (species , unknown) —>  int   Result: the index of the first occurence of the right operand in the left operand container the index of the first occurence of the right operand in the left operand container  Comment: The definition of index_of and the type of the index depend on the container  Special cases:    if the left operand is a map, index_of returns the index of a value or nil if the value is not mapped   if the left operator is a species, returns the index of an agent in a species. If the argument is not an agent of this species, returns -1. Use int(agent) instead   if the left operand is a list, index_of returns the index as an integer       int var1 <- [1,2,3,4,5,6] index_of 4;  // var1 equals 3 int var2 <- [4,2,3,4,5,4] index_of 4;  // var2 equals 0          if the left operand is a matrix, index_of returns the index as a point       point var3 <- matrix([[1,2,3],[4,5,6]]) index_of 4;  // var3 equals {1.0,0.0}          if both operands are strings, returns the index within the left-hand string of the first occurrence of the given right-hand string       int var4 <-   abcabcabc  index_of  ca ;  // var4 equals 2       Examples:  unknown var0 <- [1::2, 3::4, 5::6] index_of 4;  // var0 equals 3   See also: at, last_index_of,    ### inside  Possible use:    container<agent> inside geometry —>  list<geometry>   inside (container<agent> , geometry) —>  list<geometry>   Result: A list of agents or geometries among the left-operand list, species or meta-population (addition of species), covered by the operand (casted as a geometry).  Examples:  list<geometry> var0 <- [ag1, ag2, ag3] inside(self);  // var0 equals the agents among ag1, ag2 and ag3 that are covered by the shape of the right-hand argument. list<geometry> var1 <- (species1 + species2) inside (self);  // var1 equals the agents among species species1 and species2 that are covered by the shape of the right-hand argument.   See also: neighbors_at, neighbors_of, closest_to, overlapping, agents_overlapping, agents_inside, agent_closest_to,    ### int  Possible use:    int (any) —>  int   Result: Casts the operand into the type int    ### inter  Possible use:    container inter container —>  container   inter (container , container) —>  container   geometry inter geometry —>  geometry   inter (geometry , geometry) —>  geometry   Result: the intersection of the two operands A geometry resulting from the intersection between the two geometries  Comment: both containers are transformed into sets (so without duplicated element, cf. remove_deplicates operator) before the set intersection is computed.  Special cases:    if an operand is a graph, it will be transformed into the set of its nodes   returns nil if one of the operands is nil   if an operand is a map, it will be transformed into the set of its values       container var0 <- [1::2, 3::4, 5::6] inter [2,4];  // var0 equals [2,4] container var1 <- [1::2, 3::4, 5::6] inter [1,3];  // var1 equals []          if an operand is a matrix, it will be transformed into the set of the lines       container var2 <- matrix([[1,2,3],[4,5,4]]) inter [3,4];  // var2 equals [3,4]       Examples:  container var3 <- [1,2,3,4,5,6] inter [2,4];  // var3 equals [2,4] container var4 <- [1,2,3,4,5,6] inter [0,8];  // var4 equals [] geometry var5 <- square(10) inter circle(5);  // var5 equals circle(5)   See also: remove_duplicates, union, +, -,    ### interleave  Possible use:    interleave (container) —>  container   Result: a new list containing the interleaved elements of the containers contained in the operand  Comment: the operand should be a list of lists of elements. The result is a list of elements.  Examples:  container var0 <- interleave([1,2,4,3,5,7,6,8]);  // var0 equals [1,2,4,3,5,7,6,8] container var1 <- interleave([[ e11 , e12 , e13 ],[ e21 , e22 , e23 ],[ e31 , e32 , e33 ]]);  // var1 equals [ e11 , e21 , e31 , e12 , e22 , e32 , e13 , e23 , e33 ]     ### internal_at  Possible use:    agent internal_at container —>  unknown   internal_at (agent , container) —>  unknown   geometry internal_at container —>  unknown   internal_at (geometry , container) —>  unknown   container<KeyType,ValueType> internal_at list<KeyType> —>  ValueType   internal_at (container<KeyType,ValueType> , list<KeyType>) —>  ValueType   Result: For internal use only. Corresponds to the implementation, for agents, of the access to containers with [index] For internal use only. Corresponds to the implementation, for geometries, of the access to containers with [index] For internal use only. Corresponds to the implementation of the access to containers with [index]  See also: at,    ### internal_integrated_value  Possible use:    any expression internal_integrated_value any expression —>  container   internal_integrated_value (any expression , any expression) —>  container   Result: For internal use only. Corresponds to the implementation, for agents, of the access to containers with [index]    ### internal_zero_order_equation  Possible use:    internal_zero_order_equation (any expression) —>  float     ### intersection Same signification as inter    ### intersects  Possible use:    geometry intersects geometry —>  bool   intersects (geometry , geometry) —>  bool   Result: A boolean, equal to true if the left-geometry (or agent/point) intersects the right-geometry (or agent/point).  Special cases:    if one of the operand is null, returns false.   Examples:  bool var0 <- square(5) intersects {10,10};  // var0 equals false   See also: disjoint_from, crosses, overlaps, partially_overlaps, touches,    ### inverse  Possible use:    inverse (matrix) —>  matrix<float>   Result: The inverse matrix of the given matrix. If no inverse exists, returns a matrix that has properties that resemble that of an inverse.  Examples:  matrix<float> var0 <- inverse(matrix([[5,-3],[6,-4]]));  // var0 equals [2.0000000000000004,-0.9999999999999998]     ### inverse_distance_weighting Same signification as IDW    ### is  Possible use:    unknown is any expression —>  bool   is (unknown , any expression) —>  bool   Result: returns true if the left operand is of the right operand type, false otherwise  Examples:  bool var0 <- 0 is int;  // var0 equals true bool var1 <- an_agent is node;  // var1 equals true bool var2 <- 1 is float;  // var2 equals false     ### is_csv  Possible use:    is_csv (any) —>  bool   Result: Tests whether the operand is a csv file.    ### is_dxf  Possible use:    is_dxf (any) —>  bool   Result: Tests whether the operand is a dxf file.    ### is_finite  Possible use:    is_finite (float) —>  bool   Result: Returns whether the argument is a finite number or not  Examples:  bool var0 <- is_finite(4.66);  // var0 equals true bool var1 <- is_finite(#infinity);  // var1 equals false     ### is_gaml  Possible use:    is_gaml (any) —>  bool   Result: Tests whether the operand is a gaml file.    ### is_geojson  Possible use:    is_geojson (any) —>  bool   Result: Tests whether the operand is a geojson file.    ### is_gif  Possible use:    is_gif (any) —>  bool   Result: Tests whether the operand is a gif file.    ### is_grid  Possible use:    is_grid (any) —>  bool   Result: Tests whether the operand is a grid file.    ### is_image  Possible use:    is_image (any) —>  bool   Result: Tests whether the operand is a image file.    ### is_json  Possible use:    is_json (any) —>  bool   Result: Tests whether the operand is a json file.    ### is_number  Possible use:    is_number (string) —>  bool   is_number (float) —>  bool   Result: tests whether the operand represents a numerical value Returns whether the argument is a real number or not  Comment: Note that the symbol . should be used for a float value (a string with , will not be considered as a numeric value). Symbols e and E are also accepted. A hexadecimal value should begin with #.  Examples:  bool var0 <- is_number(test);  // var0 equals false bool var1 <- is_number(123.56);  // var1 equals true bool var2 <- is_number(-1.2e5);  // var2 equals true bool var3 <- is_number(1,2);  // var3 equals false bool var4 <- is_number(#12FA);  // var4 equals true bool var5 <- is_number(4.66);  // var5 equals true bool var6 <- is_number(#infinity);  // var6 equals true bool var7 <- is_number(#nan);  // var7 equals false     ### is_obj  Possible use:    is_obj (any) —>  bool   Result: Tests whether the operand is a obj file.    ### is_osm  Possible use:    is_osm (any) —>  bool   Result: Tests whether the operand is a osm file.    ### is_pgm  Possible use:    is_pgm (any) —>  bool   Result: Tests whether the operand is a pgm file.    ### is_property  Possible use:    is_property (any) —>  bool   Result: Tests whether the operand is a property file.    ### is_R  Possible use:    is_R (any) —>  bool   Result: Tests whether the operand is a R file.    ### is_shape  Possible use:    is_shape (any) —>  bool   Result: Tests whether the operand is a shape file.    ### is_skill  Possible use:    unknown is_skill string —>  bool   is_skill (unknown , string) —>  bool   Result: returns true if the left operand is an agent whose species implements the right-hand skill name  Examples:  bool var0 <- agentA is_skill  moving ;  // var0 equals true     ### is_svg  Possible use:    is_svg (any) —>  bool   Result: Tests whether the operand is a svg file.    ### is_text  Possible use:    is_text (any) —>  bool   Result: Tests whether the operand is a text file.    ### is_threeds  Possible use:    is_threeds (any) —>  bool   Result: Tests whether the operand is a threeds file.    ### is_URL  Possible use:    is_URL (any) —>  bool   Result: Tests whether the operand is a URL file.    ### is_xml  Possible use:    is_xml (any) —>  bool   Result: Tests whether the operand is a xml file.    ### json_file  Possible use:    json_file (string) —>  file   Result: Constructs a file of type json. Allowed extensions are limited to json    ### kappa  Possible use:    kappa (list, list, list) —>  float   kappa (list, list, list, list) —>  float   Result: kappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20. kappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories, weights). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20.  Examples:  kappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3]) float var1 <- kappa([1,3,5,1,5],[1,1,1,1,5],[1,3,5]);  // var1 equals the similarity between 0 and 1 float var2 <- kappa([1,1,1,1,5],[1,1,1,1,5],[1,3,5]);  // var2 equals 1.0 kappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3], [1.0, 2.0, 3.0, 1.0, 5.0])     ### kappa_sim  Possible use:    kappa_sim (list, list, list, list) —>  float   kappa_sim (list, list, list, list, list) —>  float   Result: kappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories). Reference: van Vliet, J., Bregt, A.K. & Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8). kappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories, weights). Reference: van Vliet, J., Bregt, A.K. & Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8)  Examples:  kappa([cat1,cat1,cat2,cat2,cat2],[cat2,cat1,cat2,cat1,cat3],[cat2,cat1,cat2,cat3,cat3], [cat1,cat2,cat3]) kappa([cat1,cat1,cat2,cat2,cat2],[cat2,cat1,cat2,cat1,cat3],[cat2,cat1,cat2,cat3,cat3], [cat1,cat2,cat3],[1.0, 2.0, 3.0, 1.0, 5.0])     ### kmeans  Possible use:    list kmeans int —>  list<list>   kmeans (list , int) —>  list<list>   kmeans (list, int, int) —>  list<list>   Result: returns the list of clusters (list of instance indices) computed with the kmeans++ algorithm from the first operand data according to the number of clusters to split the data into (k) and the maximum number of iterations to run the algorithm for (If negative, no maximum will be used) (maxIt). Usage: kmeans(data,k,maxit) returns the list of clusters (list of instance indices) computed with the kmeans++ algorithm from the first operand data according to the number of clusters to split the data into (k). Usage: kmeans(data,k)  Special cases:    if the lengths of two vectors in the right-hand aren t equal, returns 0   if the lengths of two vectors in the right-hand aren t equal, returns 0   Examples:  kmeans ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],2,10) kmeans ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],2)     ### kurtosis  Possible use:    kurtosis (list) —>  float   Result: returns kurtosis value computed from the operand list of values  Special cases:    if the length of the list is lower than 3, returns NaN   Examples:  kurtosis ([1,2,3,4,5])     ### last  Possible use:    last (string) —>  string   last (container<KeyType,ValueType>) —>  ValueType   int last container —>  container   last (int , container) —>  container   Result: the last element of the operand  Comment: the last operator behavior depends on the nature of the operand  Special cases:    if it is a map, last returns the value of the last pair (in insertion order)   if it is a file, last returns the last element of the content of the file (that is also a container)   if it is a population, last returns the last agent of the population   if it is a graph, last returns a list containing the last edge created   if it is a matrix, last returns the element at {length-1,length-1} in the matrix   for a matrix of int or float, it will return 0 if the matrix is empty   for a matrix of object or geometry, it will return nil if the matrix is empty   if it is a string, last returns a string composed of its last character, or an empty string if the operand is empty       string var0 <- last ( abce );  // var0 equals  e           if it is a list, last returns the last element of the list, or nil if the list is empty       int var1 <- last ([1, 2, 3]);  // var1 equals 3       See also: first,    ### last_index_of  Possible use:    map last_index_of unknown —>  unknown   last_index_of (map , unknown) —>  unknown   string last_index_of string —>  int   last_index_of (string , string) —>  int   species last_index_of unknown —>  int   last_index_of (species , unknown) —>  int   container last_index_of unknown —>  int   last_index_of (container , unknown) —>  int   matrix last_index_of unknown —>  point   last_index_of (matrix , unknown) —>  point   Result: the index of the last occurence of the right operand in the left operand container  Comment: The definition of last_index_of and the type of the index depend on the container  Special cases:    if the left operand is a species, the last index of an agent is the same as its index   if the left operand is a map, last_index_of returns the index as an int (the key of the pair)       unknown var0 <- [1::2, 3::4, 5::4] last_index_of 4;  // var0 equals 5          if both operands are strings, returns the index within the left-hand string of the rightmost occurrence of the given right-hand string       int var1 <-  abcabcabc  last_index_of  ca ;  // var1 equals 5          if the left operand is a list, last_index_of returns the index as an integer       int var2 <- [1,2,3,4,5,6] last_index_of 4;  // var2 equals 3 int var3 <- [4,2,3,4,5,4] last_index_of 4;  // var3 equals 5          if the left operand is a matrix, last_index_of returns the index as a point       point var4 <- matrix([[1,2,3],[4,5,4]]) last_index_of 4;  // var4 equals {1.0,2.0}       See also: at, index_of, last_index_of,    ### last_of Same signification as last    ### last_with  Possible use:    container last_with any expression —>  unknown   last_with (container , any expression) —>  unknown   Result: the last element of the left-hand operand that makes the right-hand operand evaluate to true.  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    if the left-hand operand is nil, last_with throws an error.   If there is no element that satisfies the condition, it returns nil   if the left-operand is a map, the keyword each will contain each value       unknown var4 <- [1::2, 3::4, 5::6] last_with (each >= 4);  // var4 equals 6 unknown var5 <- [1::2, 3::4, 5::6].pairs last_with (each.value >= 4);  // var5 equals 5::6       Examples:  unknown var0 <- [1,2,3,4,5,6,7,8] last_with (each > 3);  // var0 equals 8 unknown var2 <- g2 last_with (length(g2 out_edges_of each) = 0 );  // var2 equals node11 unknown var3 <- (list(node) last_with (round(node(each).location.x) > 32);  // var3 equals node3   See also: group_by, first_with, where,    ### layout  Possible use:    graph layout string —>  graph   layout (graph , string) —>  graph   layout (graph, string, int) —>  graph   layout (graph, string, int, map<string,unknown>) —>  graph   Result: layouts a GAMA graph.    ### length  Possible use:    length (string) —>  int   length (container<KeyType,ValueType>) —>  int   Result: the number of elements contained in the operand  Comment: the length operator behavior depends on the nature of the operand  Special cases:    if it is a population, length returns number of agents of the population   if it is a graph, length returns the number of vertexes or of edges (depending on the way it was created)   if it is a string, length returns the number of characters       int var0 <- length ( I am an agent );  // var0 equals 13          if it is a list or a map, length returns the number of elements in the list or map       int var1 <- length([12,13]);  // var1 equals 2 int var2 <- length([]);  // var2 equals 0          if it is a matrix, length returns the number of cells       int var3 <- length(matrix([[ c11 , c12 , c13 ],[ c21 , c22 , c23 ]]));  // var3 equals 6         ### line  Possible use:    line (container<geometry>) —>  geometry   container<geometry> line float —>  geometry   line (container<geometry> , float) —>  geometry   Result: A polyline geometry from the given list of points represented as a cylinder of radius r. A polyline geometry from the given list of points.  Special cases:    if the operand is nil, returns the point geometry {0,0}   if the operand is composed of a single point, returns a point geometry.   if the operand is nil, returns the point geometry {0,0}   if the operand is composed of a single point, returns a point geometry.   if a radius is added, the given list of points represented as a cylinder of radius r       geometry var0 <- polyline([{0,0}, {0,10}, {10,10}, {10,0}],0.2);  // var0 equals a polyline geometry composed of the 4 points.       Examples:  geometry var1 <- polyline([{0,0}, {0,10}, {10,10}, {10,0}]);  // var1 equals a polyline geometry composed of the 4 points.   See also: around, circle, cone, link, norm, point, polygone, rectangle, square, triangle,    ### link  Possible use:    geometry link geometry —>  geometry   link (geometry , geometry) —>  geometry   Result: A dynamic line geometry between the location of the two operands  Comment: The geometry of the link is a line between the locations of the two operands, which is built and maintained dynamically  Special cases:    if one of the operands is nil, link returns a point geometry at the location of the other. If both are null, it returns a point geometry at {0,0}   Examples:  geometry var0 <- link (geom1,geom2);  // var0 equals a link geometry between geom1 and geom2.   See also: around, circle, cone, line, norm, point, polygon, polyline, rectangle, square, triangle,    ### list  Possible use:    list (any) —>  list   Result: Casts the operand into the type list    ### list_with  Possible use:    int list_with any expression —>  container   list_with (int , any expression) —>  container   Result: creates a list with a size provided by the first operand, and filled with the second operand  Comment: Note that the right operand  should be positive, and that the second one is evaluated for each position  in the list.  See also: list,    ### ln  Possible use:    ln (int) —>  float   ln (float) —>  float   Result: Returns the natural logarithm (base e) of the operand.  Special cases:    an exception is raised if the operand is less than zero.   Examples:  float var0 <- ln(1);  // var0 equals 0.0 float var1 <- ln(exp(1));  // var1 equals 1.0   See also: exp,    ### load_graph_from_file  Possible use:    load_graph_from_file (string) —>  graph   string load_graph_from_file file —>  graph   load_graph_from_file (string , file) —>  graph   string load_graph_from_file string —>  graph   load_graph_from_file (string , string) —>  graph   load_graph_from_file (string, species, species) —>  graph   load_graph_from_file (string, file, species, species) —>  graph   load_graph_from_file (string, string, species, species) —>  graph   load_graph_from_file (string, string, species, species, bool) —>  graph   Result: loads a graph from a file returns a graph loaded from a given file encoded into a given format. The last boolean parameter indicates whether the resulting graph will be considered as spatial or not by GAMA  Comment: Available formats:  pajek : Pajek (Slovene word for Spider) is a program, for Windows, for analysis and visualization of large networks. See: http://pajek.imfm.si/doku.php?id=pajek for more details. lgl : LGL is a compendium of applications for making the visualization of large networks and trees tractable. See: http://lgl.sourceforge.net/ for more details. dot : DOT is a plain text graph description language. It is a simple way of describing graphs that both humans and computer programs can use. See: http://en.wikipedia.org/wiki/DOT_language for more details. edge : This format is a simple text file with numeric vertex ids defining the edges. gexf : GEXF (Graph Exchange XML Format) is a language for describing complex networks structures, their associated data and dynamics. Started in 2007 at Gephi project by different actors, deeply involved in graph exchange issues, the gexf specifications are mature enough to claim being both extensible and open, and suitable for real specific applications. See: http://gexf.net/format/ for more details. graphml : GraphML is a comprehensive and easy-to-use file format for graphs based on XML. See: http://graphml.graphdrawing.org/ for more details. tlp  or  tulip : TLP is the Tulip software graph format. See: http://tulip.labri.fr/TulipDrupal/?q=tlp-file-format for more details.  ncol : This format is used by the Large Graph Layout progra. It is simply a symbolic weighted edge list. It is a simple text file with one edge per line. An edge is defined by two symbolic vertex names separated by whitespace. (The symbolic vertex names themselves cannot contain whitespace.) They might followed by an optional number, this will be the weight of the edge. See: http://bioinformatics.icmb.utexas.edu/lgl for more details.The map operand should includes following elements:Available formats:  pajek : Pajek (Slovene word for Spider) is a program, for Windows, for analysis and visualization of large networks. See: http://pajek.imfm.si/doku.php?id=pajek for more details. lgl : LGL is a compendium of applications for making the visualization of large networks and trees tractable. See: http://lgl.sourceforge.net/ for more details. dot : DOT is a plain text graph description language. It is a simple way of describing graphs that both humans and computer programs can use. See: http://en.wikipedia.org/wiki/DOT_language for more details. edge : This format is a simple text file with numeric vertex ids defining the edges. gexf : GEXF (Graph Exchange XML Format) is a language for describing complex networks structures, their associated data and dynamics. Started in 2007 at Gephi project by different actors, deeply involved in graph exchange issues, the gexf specifications are mature enough to claim being both extensible and open, and suitable for real specific applications. See: http://gexf.net/format/ for more details. graphml : GraphML is a comprehensive and easy-to-use file format for graphs based on XML. See: http://graphml.graphdrawing.org/ for more details. tlp  or  tulip : TLP is the Tulip software graph format. See: http://tulip.labri.fr/TulipDrupal/?q=tlp-file-format for more details.  ncol : This format is used by the Large Graph Layout progra. It is simply a symbolic weighted edge list. It is a simple text file with one edge per line. An edge is defined by two symbolic vertex names separated by whitespace. (The symbolic vertex names themselves cannot contain whitespace.) They might followed by an optional number, this will be the weight of the edge. See: http://bioinformatics.icmb.utexas.edu/lgl for more details.The map operand should includes following elements:  Special cases:     format : the format of the file    filename : the filename of the file containing the network    edges_species : the species of edges    vertices_specy : the species of vertices    format : the format of the file    filename : the filename of the file containing the network    edges_species : the species of edges    vertices_specy : the species of vertices    format : the format of the file,  file : the file containing the network,  edges_species : the species of edges,  vertices_specy : the species of vertices       graph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(     pajek ,     example_of_Pajek_file ,    myVertexSpecy,    myEdgeSpecy );           filename : the filename of the file containing the network,  edges_species : the species of edges,  vertices_specy : the species of vertices       graph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(     pajek ,     ./example_of_Pajek_file ,    myVertexSpecy,    myEdgeSpecy );           file : the file containing the network       graph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(     pajek ,     example_of_Pajek_file );           format : the format of the file,  file : the file containing the network       graph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(     pajek ,     example_of_Pajek_file );           format : the format of the file,  filename : the filename of the file containing the network       graph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(     pajek ,     example_of_Pajek_file );       Examples:  graph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(    pajek,    ./example_of_Pajek_file,    myVertexSpecy,    myEdgeSpecy); graph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(    pajek,    ./example_of_Pajek_file,    myVertexSpecy,    myEdgeSpecy , true);     ### load_shortest_paths  Possible use:    graph load_shortest_paths matrix —>  graph   load_shortest_paths (graph , matrix) —>  graph   Result: put in the graph cache the computed shortest paths contained in the matrix (rows: source, columns: target)  Examples:  graph var0 <- load_shortest_paths(shortest_paths_matrix);  // var0 equals return my_graph with all the shortest paths computed     ### log  Possible use:    log (float) —>  float   log (int) —>  float   Result: Returns the logarithm (base 10) of the operand.  Special cases:    an exception is raised if the operand is equals or less than zero.   Examples:  float var0 <- log(10);  // var0 equals 1.0 float var1 <- log(1);  // var1 equals 0.0   See also: ln,    ### lower_case  Possible use:    lower_case (string) —>  string   Result: Converts all of the characters in the string operand to lower case  Examples:  string var0 <- lower_case(Abc);  // var0 equals  abc    See also: upper_case,    ### map  Possible use:    map (any) —>  map   Result: Casts the operand into the type map    ### masked_by  Possible use:    geometry masked_by container<geometry> —>  geometry   masked_by (geometry , container<geometry>) —>  geometry   masked_by (geometry, container<geometry>, int) —>  geometry   Examples:  geometry var0 <- perception_geom masked_by obstacle_list;  // var0 equals the geometry representing the part of perception_geom visible from the agent position considering the list of obstacles obstacle_list. geometry var1 <- perception_geom masked_by obstacle_list;  // var1 equals the geometry representing the part of perception_geom visible from the agent position considering the list of obstacles obstacle_list.     ### material  Possible use:    float material float —>  msi.gama.util.GamaMaterial   material (float , float) —>  msi.gama.util.GamaMaterial   Result: Returns  Examples:           See also: ,    ### matrix  Possible use:    matrix (any) —>  matrix   Result: Casts the operand into the type matrix    ### matrix_with  Possible use:    point matrix_with any expression —>  matrix   matrix_with (point , any expression) —>  matrix   Result: creates a matrix with a size provided by the first operand, and filled with the second operand  Comment: Note that both components of the right operand point should be positive, otherwise an exception is raised.  See also: matrix, as_matrix,    ### max  Possible use:    max (container) —>  unknown   Result: the maximum element found in the operand  Comment: the max operator behavior depends on the nature of the operand  Special cases:    if it is a population of a list of other type: max transforms all elements into integer and returns the maximum of them   if it is a map, max returns the maximum among the list of all elements value   if it is a file, max returns the maximum of the content of the file (that is also a container)   if it is a graph, max returns the maximum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)   if it is a matrix of int, float or object, max returns the maximum of all the numerical elements (thus all elements for integer and float matrices)   if it is a matrix of geometry, max returns the maximum of the list of the geometries   if it is a matrix of another type, max returns the maximum of the elements transformed into float   if it is a list of int of float, max returns the maximum of all the elements       unknown var0 <- max ([100, 23.2, 34.5]);  // var0 equals 100.0          if it is a list of points: max returns the maximum of all points as a point (i.e. the point with the greatest coordinate on the x-axis, in case of equality the point with the greatest coordinate on the y-axis is chosen. If all the points are equal, the first one is returned. )       unknown var1 <- max([{1.0,3.0},{3.0,5.0},{9.0,1.0},{7.0,8.0}]);  // var1 equals {9.0,1.0}       See also: min,    ### max_of  Possible use:    container max_of any expression —>  unknown   max_of (container , any expression) —>  unknown   Result: the maximum value of the right-hand expression evaluated on each of the elements of the left-hand operand  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    As of GAMA 1.6, if the left-hand operand is nil or empty, max_of throws an error   if the left-operand is a map, the keyword each will contain each value       unknown var5 <- [1::2, 3::4, 5::6] max_of (each + 3);  // var5 equals 6       Examples:  unknown var1 <- [1,2,4,3,5,7,6,8] max_of (each * 100 );  // var1 equals 800 graph g2 <- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); unknown var3 <- g2.vertices max_of (g2 degree_of( each ));  // var3 equals 2 unknown var4 <- (list(node) max_of (round(node(each).location.x));  // var4 equals 96   See also: min_of,    ### maximal_cliques_of  Possible use:    maximal_cliques_of (graph) —>  list<list>   Result: returns the maximal cliques of a graph using the Bron-Kerbosch clique detection algorithm: A clique is maximal if it is impossible to enlarge it by adding another vertex from the graph. Note that a maximal clique is not necessarily the biggest clique in the graph.  Examples:  graph my_graph <- graph([]); list<list> var1 <- maximal_cliques_of (my_graph);  // var1 equals the list of all the maximal cliques as list   See also: biggest_cliques_of,    ### mean  Possible use:    mean (container) —>  unknown   Result: the mean of all the elements of the operand  Comment: the elements of the operand are summed (see sum for more details about the sum of container elements ) and then the sum value is divided by the number of elements.  Special cases:    if the container contains points, the result will be a point. If the container contains rgb values, the result will be a rgb color   Examples:  unknown var0 <- mean ([4.5, 3.5, 5.5, 7.0]);  // var0 equals 5.125    See also: sum,    ### mean_deviation  Possible use:    mean_deviation (container) —>  float   Result: the deviation from the mean of all the elements of the operand. See Mean_deviation for more details.  Comment: The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.  Examples:  float var0 <- mean_deviation ([4.5, 3.5, 5.5, 7.0]);  // var0 equals 1.125   See also: mean, standard_deviation,    ### mean_of  Possible use:    container mean_of any expression —>  unknown   mean_of (container , any expression) —>  unknown   Result: the mean of the right-hand expression evaluated on each of the elements of the left-hand operand  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    if the left-operand is a map, the keyword each will contain each value       unknown var2 <- [1::2, 3::4, 5::6] mean_of (each);  // var2 equals 4       Examples:  unknown var1 <- [1,2] mean_of (each * 10 );  // var1 equals 15   See also: min_of, max_of, sum_of, product_of,    ### meanR  Possible use:    meanR (container) —>  unknown   Result: returns the mean value of given vector (right-hand operand) in given variable  (left-hand operand).  Examples:  list<int> X <- [2, 3, 1]; int var1 <- meanR(X);  // var1 equals 2     ### median  Possible use:    median (container) —>  unknown   Result: the median of all the elements of the operand.  Special cases:    if the container contains points, the result will be a point. If the container contains rgb values, the result will be a rgb color   Examples:  unknown var0 <- median ([4.5, 3.5, 5.5, 3.4, 7.0]);  // var0 equals 5.0   See also: mean,    ### message  Possible use:    message (unknown) —>  msi.gama.extensions.messaging.GamaMessage   Result: to be added    ### milliseconds_between  Possible use:    date milliseconds_between date —>  float   milliseconds_between (date , date) —>  float   Result: Provide the exact number of milliseconds between two dates. This number can be positive or negative (if the second operand is smaller than the first one)  Examples:  milliseconds_between(d1, d2) -: 10      ### min  Possible use:    min (container) —>  unknown   Result: the minimum element found in the operand.  Comment: the min operator behavior depends on the nature of the operand  Special cases:    if it is a list of points: min returns the minimum of all points as a point (i.e. the point with the smallest coordinate on the x-axis, in case of equality the point with the smallest coordinate on the y-axis is chosen. If all the points are equal, the first one is returned. )   if it is a population of a list of other types: min transforms all elements into integer and returns the minimum of them   if it is a map, min returns the minimum among the list of all elements value   if it is a file, min returns the minimum of the content of the file (that is also a container)   if it is a graph, min returns the minimum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)   if it is a matrix of int, float or object, min returns the minimum of all the numerical elements (thus all elements for integer and float matrices)   if it is a matrix of geometry, min returns the minimum of the list of the geometries   if it is a matrix of another type, min returns the minimum of the elements transformed into float   if it is a list of int or float: min returns the minimum of all the elements       unknown var0 <- min ([100, 23.2, 34.5]);  // var0 equals 23.2       See also: max,    ### min_of  Possible use:    container min_of any expression —>  unknown   min_of (container , any expression) —>  unknown   Result: the minimum value of the right-hand expression evaluated on each of the elements of the left-hand operand  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    if the left-hand operand is nil or empty, min_of throws an error   if the left-operand is a map, the keyword each will contain each value       unknown var5 <- [1::2, 3::4, 5::6] min_of (each + 3);  // var5 equals 5       Examples:  unknown var1 <- [1,2,4,3,5,7,6,8] min_of (each * 100 );  // var1 equals 100 graph g2 <- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); unknown var3 <- g2 min_of (length(g2 out_edges_of each) );  // var3 equals 0 unknown var4 <- (list(node) min_of (round(node(each).location.x));  // var4 equals 4   See also: max_of,    ### minus_days  Possible use:    date minus_days int —>  date   minus_days (date , int) —>  date   Result: Subtract a given number of days from a date  Examples:  date1 minus_days 20     ### minus_hours  Possible use:    date minus_hours int —>  date   minus_hours (date , int) —>  date   Result: Remove a given number of hours from a date  Examples:  date1 minus_hours 15 // equivalent to date1 - 15 #h     ### minus_minutes  Possible use:    date minus_minutes int —>  date   minus_minutes (date , int) —>  date   Result: Subtract a given number of minutes from a date  Examples:  date1 minus_minutes 5 // equivalent to date1 - 5#mn     ### minus_months  Possible use:    date minus_months int —>  date   minus_months (date , int) —>  date   Result: Subtract a given number of months from a date  Examples:  date1 minus_months 5     ### minus_ms  Possible use:    date minus_ms int —>  date   minus_ms (date , int) —>  date   Result: Remove a given number of milliseconds from a date  Examples:  date1 minus_ms 15 // equivalent to date1 - 15 #ms     ### minus_seconds Same signification as -    ### minus_weeks  Possible use:    date minus_weeks int —>  date   minus_weeks (date , int) —>  date   Result: Subtract a given number of weeks from a date  Examples:  date1 minus_weeks 15     ### minus_years  Possible use:    date minus_years int —>  date   minus_years (date , int) —>  date   Result: Subtract a given number of year from a date  Examples:  date1 minus_years 3     ### mod  Possible use:    int mod int —>  int   mod (int , int) —>  int   Result: Returns the remainder of the integer division of the left-hand operand by the right-hand operand.  Special cases:    if operands are float, they are truncated   if the right-hand operand is equal to zero, raises an exception.   Examples:  int var0 <- 40 mod 3;  // var0 equals 1   See also: div,    ### months_between  Possible use:    date months_between date —>  int   months_between (date , date) —>  int   Result: Provide the exact number of months between two dates. This number can be positive or negative (if the second operand is smaller than the first one)  Examples:  months_between(d1, d2) -: 10      ### moran  Possible use:    list<float> moran matrix<float> —>  float   moran (list<float> , matrix<float>) —>  float   Special cases:    return the Moran Index of the given list of interest points (list of floats) and the weight matrix (matrix of float)       float var0 <- moran([1.0, 0.5, 2.0], weight_matrix);  // var0 equals the Moran index computed         ### mul  Possible use:    mul (container) —>  unknown   Result: the product of all the elements of the operand  Comment: the mul operator behavior depends on the nature of the operand  Special cases:    if it is a list of points: mul returns the product of all points as a point (each coordinate is the product of the corresponding coordinate of each element)   if it is a list of other types: mul transforms all elements into integer and multiplies them   if it is a map, mul returns the product of the value of all elements   if it is a file, mul returns the product of the content of the file (that is also a container)   if it is a graph, mul returns the product of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)   if it is a matrix of int, float or object, mul returns the product of all the numerical elements (thus all elements for integer and float matrices)   if it is a matrix of geometry, mul returns the product of the list of the geometries   if it is a matrix of other types: mul transforms all elements into float and multiplies them   if it is a list of int or float: mul returns the product of all the elements       unknown var0 <- mul ([100, 23.2, 34.5]);  // var0 equals 80040.0       See also: sum,    ### nb_cycles  Possible use:    nb_cycles (graph) —>  int   Result: returns the maximum number of independent cycles in a graph. This number (u) is estimated through the number of nodes (v), links (e) and of sub-graphs (p): u = e - v + p.  Examples:  graph graphEpidemio <- graph([]); int var1 <- nb_cycles(graphEpidemio);  // var1 equals the number of cycles in the graph   See also: alpha_index, beta_index, gamma_index, connectivity_index,    ### neighbors_at  Possible use:    geometry neighbors_at float —>  container   neighbors_at (geometry , float) —>  container   Result: a list, containing all the agents of the same species than the left argument (if it is an agent) located at a distance inferior or equal to the right-hand operand to the left-hand operand (geometry, agent, point).  Comment: The topology used to compute the neighborhood  is the one of the left-operand if this one is an agent; otherwise the one of the agent applying the operator.  Examples:  container var0 <- (self neighbors_at (10));  // var0 equals all the agents located at a distance lower or equal to 10 to the agent applying the operator.   See also: neighbors_of, closest_to, overlapping, agents_overlapping, agents_inside, agent_closest_to, at_distance,    ### neighbors_of  Possible use:    graph neighbors_of unknown —>  container   neighbors_of (graph , unknown) —>  container   topology neighbors_of agent —>  container   neighbors_of (topology , agent) —>  container   neighbors_of (topology, geometry, float) —>  container   Result: a list, containing all the agents of the same species than the argument (if it is an agent) located at a distance inferior or equal to 1 to the right-hand operand agent considering the left-hand operand topology.  Special cases:    a list, containing all the agents of the same species than the left argument (if it is an agent) located at a distance inferior or equal to the third argument to the second argument (agent, geometry or point) considering the first operand topology.       container var3 <- neighbors_of (topology(self), self,10);  // var3 equals all the agents located at a distance lower or equal to 10 to the agent applying the operator considering its topology.       Examples:  container var0 <- graphEpidemio neighbors_of (node(3));  // var0 equals [node0,node2] container var1 <- graphFromMap neighbors_of node({12,45});  // var1 equals [{1.0,5.0},{34.0,56.0}] container var2 <- topology(self) neighbors_of self;  // var2 equals returns all the agents located at a distance lower or equal to 1 to the agent applying the operator considering its topology.   See also: predecessors_of, successors_of, neighbors_at, closest_to, overlapping, agents_overlapping, agents_inside, agent_closest_to,    ### new_emotion  Possible use:    new_emotion (string) —>  emotion   string new_emotion agent —>  emotion   new_emotion (string , agent) —>  emotion   string new_emotion float —>  emotion   new_emotion (string , float) —>  emotion   string new_emotion predicate —>  emotion   new_emotion (string , predicate) —>  emotion   new_emotion (string, float, predicate) —>  emotion   new_emotion (string, float, float) —>  emotion   new_emotion (string, predicate, agent) —>  emotion   new_emotion (string, float, agent) —>  emotion   new_emotion (string, float, float, agent) —>  emotion   new_emotion (string, float, predicate, float) —>  emotion   new_emotion (string, float, predicate, agent) —>  emotion   new_emotion (string, float, predicate, float, agent) —>  emotion   Result: a new emotion with the given properties (name) a new emotion with the given properties (name) a new emotion with the given properties (name,intensity,about) a new emotion with the given properties (name,intensity,decay) a new emotion with the given properties (name) a new emotion with the given properties (name, intensity) a new emotion with the given properties (name,about) a new emotion with the given properties (name) a new emotion with the given properties (name) a new emotion with the given properties (name) a new emotion with the given properties (name) a new emotion with the given properties (name)  Examples:  emotion(joy,12.3,eatFood,4) emotion(joy,12.3,eatFood,4) emotion(joy,12.3,eatFood) emotion(joy,12.3,4) emotion(joy,12.3,eatFood,4) emotion(joy,12.3) emotion(joy,eatFood) emotion(joy) emotion(joy,12.3,eatFood,4) emotion(joy,12.3,eatFood,4) emotion(joy,12.3,eatFood,4) emotion(joy,12.3,eatFood,4)     ### new_folder  Possible use:    new_folder (string) —>  file   Result: opens an existing repository or create a new folder if it does not exist.  Special cases:    If the specified string does not refer to an existing repository, the repository is created.   If the string refers to an existing file, an exception is risen.   Examples:  file dirNewT <- new_folder(incl/);    // dirNewT represents the repository ../incl/                // eventually creates the directory ../incl   See also: folder, file,    ### new_predicate  Possible use:    new_predicate (string) —>  predicate   string new_predicate agent —>  predicate   new_predicate (string , agent) —>  predicate   string new_predicate float —>  predicate   new_predicate (string , float) —>  predicate   string new_predicate int —>  predicate   new_predicate (string , int) —>  predicate   string new_predicate map —>  predicate   new_predicate (string , map) —>  predicate   string new_predicate bool —>  predicate   new_predicate (string , bool) —>  predicate   new_predicate (string, map, float) —>  predicate   new_predicate (string, map, int) —>  predicate   new_predicate (string, map, agent) —>  predicate   new_predicate (string, map, bool) —>  predicate   new_predicate (string, map, int, bool) —>  predicate   new_predicate (string, map, bool, agent) —>  predicate   new_predicate (string, map, float, int) —>  predicate   new_predicate (string, map, int, agent) —>  predicate   new_predicate (string, map, float, agent) —>  predicate   new_predicate (string, map, float, bool) —>  predicate   new_predicate (string, map, float, int, bool) —>  predicate   new_predicate (string, map, int, bool, agent) —>  predicate   new_predicate (string, map, float, bool, agent) —>  predicate   new_predicate (string, map, float, int, agent) —>  predicate   new_predicate (string, map, float, int, bool, agent) —>  predicate   Result: a new predicate with the given properties (name, values, lifetime, is_true) a new predicate with the given properties (name, values, priority) a new predicate with the given properties (name, values, priority, lifetime, is_true, agentCause) a new predicate with the given properties (name, values, is_true, agentCause) a new predicate with the given properties (name, values, lifetime) a new predicate with the given properties (name, values, priority, lifetime, is_true) a new predicate with the given properties (name, values, lifetime, is_true, agentCause) a new predicate with the given is_true (name, priority) a new predicate with the given is_true (name, lifetime) a new predicate with the given properties (name, values) a new predicate with the given properties (name, values, lifetime) a new predicate with the given is_true (name, is_true) a new predicate with the given properties (name, values, priority,lifetime) a new predicate with the given properties (name, values, priority, is_true, agentCause) a new predicate with the given properties (name, values,  agentCause) a new predicate with the given properties (name, values, lifetime, agentCause) a new predicate with the given properties (name) a new predicate with the given properties (name, values, priority, agentCause) a new predicate with the given properties (name, values, priority, is_true) a new predicate with the given properties (name, values, priority, lifetime, agentCause) a new predicate with the given properties (name, values, is_true)  Examples:  predicate(people to meet, [time::10], 10,true) predicate(people to meet, people1, [time::10]) predicate(people to meet, [time::10],2.0,10, true, agentA) predicate(people to meet, [time::10], true, agentA) predicate(people to meet, [time::10], true) predicate(people to meet, [time::10],2.0,10, true) predicate(people to meet, [time::10], 10, true, agentA) predicate(hasWater, 2.0 ) predicate(hasWater, 10  predicate(people to meet, people1 ) predicate(people to meet, [time::10], true) predicate(hasWater, true) predicate(people to meet, [time::10], 2.0,10) predicate(people to meet, [time::10], 2.0, true, agentA) predicate(people to meet, [time::10], agentA) predicate(people to meet, [time::10], 10, agentA) predicate(people to meet) predicate(people to meet, [time::10], 2.0,agentA) predicate(people to meet, [time::10],2.0, true) predicate(people to meet, [time::10], 2.0,10,agentA) predicate(people to meet, [time::10], true)     ### new_social_link  Possible use:    new_social_link (agent) —>  msi.gaml.architecture.simplebdi.SocialLink   new_social_link (agent, float, float, float, float) —>  msi.gaml.architecture.simplebdi.SocialLink   Result: a new social link a new social link  Examples:  new_social_link(agentA) new_social_link(agentA,0.0,-0.1,0.2,0.1)     ### node  Possible use:    node (unknown) —>  unknown   unknown node float —>  unknown   node (unknown , float) —>  unknown     ### nodes  Possible use:    nodes (container) —>  container     ### norm  Possible use:    norm (point) —>  float   Result: the norm of the vector with the coordinates of the point operand.  Examples:  float var0 <- norm({3,4});  // var0 equals 5.0     ### not Same signification as !    ### obj_file  Possible use:    obj_file (string) —>  file   Result: Constructs a file of type obj. Allowed extensions are limited to obj, OBJ    ### of Same signification as .    ### of_generic_species  Possible use:    container of_generic_species species —>  container   of_generic_species (container , species) —>  container   Result: a list, containing the agents of the left-hand operand whose species is that denoted by the right-hand operand and whose species extends the right-hand operand species  Examples:  // species test {} // species sous_test parent: test {} container var2 <- [sous_test(0),sous_test(1),test(2),test(3)] of_generic_species test;  // var2 equals [sous_test0,sous_test1,test2,test3] container var3 <- [sous_test(0),sous_test(1),test(2),test(3)] of_generic_species sous_test;  // var3 equals [sous_test0,sous_test1] container var4 <- [sous_test(0),sous_test(1),test(2),test(3)] of_species test;  // var4 equals [test2,test3] container var5 <- [sous_test(0),sous_test(1),test(2),test(3)] of_species sous_test;  // var5 equals [sous_test0,sous_test1]   See also: of_species,    ### of_species  Possible use:    container of_species species —>  container   of_species (container , species) —>  container   Result: a list, containing the agents of the left-hand operand whose species is the one denoted by the right-hand operand.The expression agents of_species (species self) is equivalent to agents where (species each = species self); however, the advantage of using the first syntax is that the resulting list is correctly typed with the right species, whereas, in the second syntax, the parser cannot determine the species of the agents within the list (resulting in the need to cast it explicitly if it is to be used in an ask statement, for instance).  Special cases:    if the right operand is nil, of_species returns the right operand   Examples:  container var0 <- (self neighbors_at 10) of_species (species (self));  // var0 equals all the neighboring agents of the same species. container var1 <- [test(0),test(1),node(1),node(2)] of_species test;  // var1 equals [test0,test1]   See also: of_generic_species,    ### one_of  Possible use:    one_of (container<KeyType,ValueType>) —>  ValueType   Result: one of the values stored in this container  at a random key  Comment: the one_of operator behavior depends on the nature of the operand  Special cases:    if it is a graph, one_of returns one of the lists of edges   if it is a file, one_of returns one of the elements of the content of the file (that is also a container)   if the operand is empty, one_of returns nil                if it is a list or a matrix, one_of returns one of the values of the list or of the matrix       int i <- any ([1,2,3]);  // i equals 1, 2 or 3 string sMat <- one_of(matrix([[ c11 , c12 , c13 ],[ c21 , c22 , c23 ]]));  // sMat equals  c11 , c12 , c13 ,  c21 , c22  or  c23           if it is a map, one_of returns one the value of a random pair of the map       int im <- one_of ([2::3, 4::5, 6::7]); // im equals 3, 5 or 7 bool var6 <- [2::3, 4::5, 6::7].values contains im;  // var6 equals true          if it is a population, one_of returns one of the agents of the population       bug b <- one_of(bug);   // Given a previously defined species bug, b is one of the created bugs, e.g. bug3       See also: contains,    ### or  Possible use:    bool or any expression —>  bool   or (bool , any expression) —>  bool   Result: a bool value, equal to the logical or between the left-hand operand and the right-hand operand.  Comment: both operands are always casted to bool before applying the operator. Thus, an expression like 1 or 0 is accepted and returns true.  See also: bool, and, !,    ### or  Possible use:    predicate or predicate —>  predicate   or (predicate , predicate) —>  predicate   Result: create a new predicate from two others by including them as subintentions. It s an exclusive  or   Examples:  predicate1 or predicate2     ### osm_file  Possible use:    string osm_file map<string,list> —>  file   osm_file (string , map<string,list>) —>  file   osm_file (string, map<string,list>, int) —>  file   Result: opens a file that a is a kind of OSM file with some filtering. opens a file that a is a kind of OSM file with some filtering, forcing the initial CRS to be the one indicated by the second int parameter (see http://spatialreference.org/ref/epsg/). If this int parameter is equal to 0, the data is considered as already projected.  Comment: The file should have a OSM file extension, cf. file type definition for supported file extensions.The file should have a OSM file extension, cf. file type definition for supported file extensions.  Special cases:    If the specified string does not refer to an existing OSM file, an exception is risen.   If the specified string does not refer to an existing OSM file, an exception is risen.   Examples:  file myOSMfile <- osm_file(../includes/rouen.osm, [highway::[primary,motorway]]); file myOSMfile2 <- osm_file(../includes/rouen.osm,[highway::[primary,motorway]], 0);   See also: file,    ### out_degree_of  Possible use:    graph out_degree_of unknown —>  int   out_degree_of (graph , unknown) —>  int   Result: returns the out degree of a vertex (right-hand operand) in the graph given as left-hand operand.  Examples:  int var1 <- graphFromMap out_degree_of (node(3));  // var1 equals 4   See also: in_degree_of, degree_of,    ### out_edges_of  Possible use:    graph out_edges_of unknown —>  container   out_edges_of (graph , unknown) —>  container   Result: returns the list of the out-edges of a vertex (right-hand operand) in the graph given as left-hand operand.  Examples:  container var1 <- graphFromMap out_edges_of (node(3));  // var1 equals 3   See also: in_edges_of,    ### overlapping  Possible use:    container<agent> overlapping geometry —>  list<geometry>   overlapping (container<agent> , geometry) —>  list<geometry>   Result: A list of agents or geometries among the left-operand list, species or meta-population (addition of species), overlapping the operand (casted as a geometry).  Examples:  list<geometry> var0 <- [ag1, ag2, ag3] overlapping(self);  // var0 equals return the agents among ag1, ag2 and ag3 that overlap the shape of the agent applying the operator. (species1 + species2) overlapping self   See also: neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, agents_overlapping,    ### overlaps  Possible use:    geometry overlaps geometry —>  bool   overlaps (geometry , geometry) —>  bool   Result: A boolean, equal to true if the left-geometry (or agent/point) overlaps the right-geometry (or agent/point).  Special cases:    if one of the operand is null, returns false.   if one operand is a point, returns true if the point is included in the geometry   Examples:  bool var0 <- polyline([{10,10},{20,20}]) overlaps polyline([{15,15},{25,25}]);  // var0 equals true bool var1 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{15,15},{15,25},{25,25},{25,15}]);  // var1 equals true bool var2 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps {25,25};  // var2 equals false bool var3 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{35,35},{35,45},{45,45},{45,35}]);  // var3 equals false bool var4 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polyline([{10,10},{20,20}]);  // var4 equals true bool var5 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps {15,15};  // var5 equals true bool var6 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{0,0},{0,30},{30,30}, {30,0}]);  // var6 equals true bool var7 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{15,15},{15,25},{25,25},{25,15}]);  // var7 equals true bool var8 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{10,20},{20,20},{20,30},{10,30}]);  // var8 equals true   See also: disjoint_from, crosses, intersects, partially_overlaps, touches,    ### pair  Possible use:    pair (any) —>  pair   Result: Casts the operand into the type pair    ### partially_overlaps  Possible use:    geometry partially_overlaps geometry —>  bool   partially_overlaps (geometry , geometry) —>  bool   Result: A boolean, equal to true if the left-geometry (or agent/point) partially overlaps the right-geometry (or agent/point).  Comment: if one geometry operand fully covers the other geometry operand, returns false (contrarily to the overlaps operator).  Special cases:    if one of the operand is null, returns false.   Examples:  bool var0 <- polyline([{10,10},{20,20}]) partially_overlaps polyline([{15,15},{25,25}]);  // var0 equals true bool var1 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{15,15},{15,25},{25,25},{25,15}]);  // var1 equals true bool var2 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps {25,25};  // var2 equals false bool var3 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{35,35},{35,45},{45,45},{45,35}]);  // var3 equals false bool var4 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polyline([{10,10},{20,20}]);  // var4 equals false bool var5 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps {15,15};  // var5 equals false bool var6 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{0,0},{0,30},{30,30}, {30,0}]);  // var6 equals false bool var7 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{15,15},{15,25},{25,25},{25,15}]);  // var7 equals true bool var8 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{10,20},{20,20},{20,30},{10,30}]);  // var8 equals false   See also: disjoint_from, crosses, overlaps, intersects, touches,    ### path  Possible use:    path (any) —>  path   Result: Casts the operand into the type path    ### path_between  Possible use:    topology path_between container<geometry> —>  path   path_between (topology , container<geometry>) —>  path   list<agent> path_between container<geometry> —>  path   path_between (list<agent> , container<geometry>) —>  path   path_between (graph, geometry, geometry) —>  path   path_between (list<agent>, geometry, geometry) —>  path   path_between (topology, geometry, geometry) —>  path   Result: The shortest path between a list of two objects in a graph The shortest path between two objects according to set of cells The shortest path between several objects according to set of cells  Examples:  path var0 <- path_between (my_graph, ag1, ag2);  // var0 equals A path between ag1 and ag2 path var1 <- my_topology path_between [ag1, ag2];  // var1 equals A path between ag1 and ag2 path var2 <- path_between (cell_grid where each.is_free, ag1, ag2);  // var2 equals A path between ag1 and ag2 passing through the given cell_grid agents path var3 <- my_topology path_between (ag1, ag2);  // var3 equals A path between ag1 and ag2 path var4 <- path_between (cell_grid where each.is_free, [ag1, ag2, ag3]);  // var4 equals A path between ag1 and ag2 and ag3 passing through the given cell_grid agents   See also: towards, direction_to, distance_between, direction_between, path_to, distance_to,    ### path_to  Possible use:    geometry path_to geometry —>  path   path_to (geometry , geometry) —>  path   point path_to point —>  path   path_to (point , point) —>  path   Result: A path between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.  Examples:  path var0 <- ag1 path_to ag2;  // var0 equals the path between ag1 and ag2 considering the topology of the agent applying the operator   See also: towards, direction_to, distance_between, direction_between, path_between, distance_to,    ### paths_between  Possible use:    paths_between (graph, pair, int) —>  list<path>   Result: The K shortest paths between a list of two objects in a graph  Examples:  list<path> var0 <- paths_between(my_graph, ag1:: ag2, 2);  // var0 equals the 2 shortest paths (ordered by length) between ag1 and ag2     ### percent_absolute_deviation  Possible use:    list<float> percent_absolute_deviation list<float> —>  float   percent_absolute_deviation (list<float> , list<float>) —>  float   Result: percent absolute deviation indicator for 2 series of values: percent_absolute_deviation(list_vals_observe,list_vals_sim)  Examples:  percent_absolute_deviation([200,300,150,150,200],[250,250,100,200,200])     ### pgm_file  Possible use:    pgm_file (string) —>  file   Result: Constructs a file of type pgm. Allowed extensions are limited to pgm    ### plan  Possible use:    container<geometry> plan float —>  geometry   plan (container<geometry> , float) —>  geometry   Result: A polyline geometry from the given list of points.  Special cases:    if the operand is nil, returns the point geometry {0,0}   if the operand is composed of a single point, returns a point geometry.   Examples:  geometry var0 <- polyplan([{0,0}, {0,10}, {10,10}, {10,0}],10);  // var0 equals a polyline geometry composed of the 4 points with a depth of 10.   See also: around, circle, cone, link, norm, point, polygone, rectangle, square, triangle,    ### plus_days  Possible use:    date plus_days int —>  date   plus_days (date , int) —>  date   Result: Add a given number of days to a date  Examples:  date1 plus_days 20     ### plus_hours  Possible use:    date plus_hours int —>  date   plus_hours (date , int) —>  date   Result: Add a given number of hours to a date  Examples:  date1 plus_hours 15 // equivalent to date1 + 15 #h     ### plus_minutes  Possible use:    date plus_minutes int —>  date   plus_minutes (date , int) —>  date   Result: Add a given number of minutes to a date  Examples:  date1 plus_minutes 5 // equivalent to date1 + 5 #mn     ### plus_months  Possible use:    date plus_months int —>  date   plus_months (date , int) —>  date   Result: Add a given number of months to a date  Examples:  date1 plus_months 5     ### plus_ms  Possible use:    date plus_ms int —>  date   plus_ms (date , int) —>  date   Result: Add a given number of milliseconds to a date  Examples:  date1 plus_ms 15 // equivalent to date1 + 15 #ms     ### plus_seconds Same signification as +    ### plus_weeks  Possible use:    date plus_weeks int —>  date   plus_weeks (date , int) —>  date   Result: Add a given number of weeks to a date  Examples:  date1 plus_weeks 15     ### plus_years  Possible use:    date plus_years int —>  date   plus_years (date , int) —>  date   Result: Add a given number of years to a date  Examples:  date1 plus_years 3     ### point  Possible use:    float point int —>  point   point (float , int) —>  point   int point float —>  point   point (int , float) —>  point   int point int —>  point   point (int , int) —>  point   float point float —>  point   point (float , float) —>  point   point (float, int, int) —>  point   point (int, int, int) —>  point   point (float, int, float) —>  point   point (int, int, float) —>  point   point (int, float, float) —>  point   point (float, float, float) —>  point   point (float, float, int) —>  point   Result: internal use only. Use the standard construction {x,y} instead. internal use only. Use the standard construction {x,y} instead. internal use only. Use the standard construction {x,y, z} instead. internal use only. Use the standard construction {x,y, z} instead. internal use only. Use the standard construction {x,y, z} instead. internal use only. Use the standard construction {x,y, z} instead. internal use only. Use the standard construction {x,y, z} instead. internal use only. Use the standard construction {x,y} instead. internal use only. Use the standard construction {x,y} instead. internal use only. Use the standard construction {x,y, z} instead. internal use only. Use the standard construction {x,y, z} instead.    ### points_along  Possible use:    geometry points_along list<float> —>  container   points_along (geometry , list<float>) —>  container   Result: A list of points along the operand-geometry given its location in terms of rate of distance from the starting points of the geometry.  Examples:  container var0 <-  line([{10,10},{80,80}]) points_along ([0.3, 0.5, 0.9]);  // var0 equals the list of following points: [{31.0,31.0,0.0},{45.0,45.0,0.0},{73.0,73.0,0.0}]   See also: closest_points_with, farthest_point_to, points_at, points_on,    ### points_at  Possible use:    int points_at float —>  list<point>   points_at (int , float) —>  list<point>   Result: A list of left-operand number of points located at a the right-operand distance to the agent location.  Examples:  list<point> var0 <- 3 points_at(20.0);  // var0 equals returns [pt1, pt2, pt3] with pt1, pt2 and pt3 located at a distance of 20.0 to the agent location   See also: any_location_in, any_point_in, closest_points_with, farthest_point_to,    ### points_on  Possible use:    geometry points_on float —>  container   points_on (geometry , float) —>  container   Result: A list of points of the operand-geometry distant from each other to the float right-operand .  Examples:  container var0 <-  square(5) points_on(2);  // var0 equals a list of points belonging to the exterior ring of the square distant from each other of 2.   See also: closest_points_with, farthest_point_to, points_at,    ### poisson  Possible use:    poisson (float) —>  int   Result: A value from a random variable following a Poisson distribution (with the positive expected number of occurence lambda as operand).  Comment: The Poisson distribution is a discrete probability distribution that expresses the probability of a given number of events occurring in a fixed interval of time and/or space if these events occur with a known average rate and independently of the time since the last event, cf. Poisson distribution on Wikipedia.  Examples:  int var0 <- poisson(3.5);  // var0 equals a random positive integer   See also: binomial, gauss,    ### polygon  Possible use:    polygon (container<agent>) —>  geometry   Result: A polygon geometry from the given list of points.  Special cases:    if the operand is nil, returns the point geometry {0,0}   if the operand is composed of a single point, returns a point geometry   if the operand is composed of 2 points, returns a polyline geometry.   Examples:  geometry var0 <- polygon([{0,0}, {0,10}, {10,10}, {10,0}]);  // var0 equals a polygon geometry composed of the 4 points.   See also: around, circle, cone, line, link, norm, point, polyline, rectangle, square, triangle,    ### polyhedron  Possible use:    container<geometry> polyhedron float —>  geometry   polyhedron (container<geometry> , float) —>  geometry   Result: A polyhedron geometry from the given list of points.  Special cases:    if the operand is nil, returns the point geometry {0,0}   if the operand is composed of a single point, returns a point geometry   if the operand is composed of 2 points, returns a polyline geometry.   Examples:  geometry var0 <- polyhedron([{0,0}, {0,10}, {10,10}, {10,0}],10);  // var0 equals a polygon geometry composed of the 4 points and of depth 10.   See also: around, circle, cone, line, link, norm, point, polyline, rectangle, square, triangle,    ### polyline Same signification as line    ### polyplan Same signification as plan    ### predecessors_of  Possible use:    graph predecessors_of unknown —>  container   predecessors_of (graph , unknown) —>  container   Result: returns the list of predecessors (i.e. sources of in edges) of the given vertex (right-hand operand) in the given graph (left-hand operand)  Examples:  container var1 <- graphEpidemio predecessors_of ({1,5});  // var1 equals [] container var2 <- graphEpidemio predecessors_of node({34,56});  // var2 equals [{12;45}]   See also: neighbors_of, successors_of,    ### predicate  Possible use:    predicate (any) —>  predicate   Result: Casts the operand into the type predicate    ### predict  Possible use:    regression predict list<float> —>  float   predict (regression , list<float>) —>  float   Result: returns the value predict by the regression parameters for a given instance. Usage: predict(regression, instance)  Examples:  predict(my_regression, [1,2,3]     ### product Same signification as mul    ### product_of  Possible use:    container product_of any expression —>  unknown   product_of (container , any expression) —>  unknown   Result: the product of the right-hand expression evaluated on each of the elements of the left-hand operand  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    if the left-operand is a map, the keyword each will contain each value       unknown var2 <- [1::2, 3::4, 5::6] product_of (each);  // var2 equals 48       Examples:  unknown var1 <- [1,2] product_of (each * 10 );  // var1 equals 200   See also: min_of, max_of, sum_of, mean_of,    ### promethee_DM  Possible use:    list<list> promethee_DM list<map<string,object>> —>  int   promethee_DM (list<list> , list<map<string,object>>) —>  int   Result: The index of the best candidate according to the Promethee II method. This method is based on a comparison per pair of possible candidates along each criterion: all candidates are compared to each other by pair and ranked. More information about this method can be found in [http://www.sciencedirect.com/science?_ob=ArticleURL&_udi=B6VCT-4VF56TV-1&_user=10&_coverDate=01%2F01%2F2010&_rdoc=1&_fmt=high&_orig=search&_sort=d&_docanchor=&view=c&_searchStrId=1389284642&_rerunOrigin=google&_acct=C000050221&_version=1&_urlVersion=0&_userid=10&md5=d334de2a4e0d6281199a39857648cd36 Behzadian, M., Kazemzadeh, R., Albadvi, A., M., A.: PROMETHEE: A comprehensive literature review on methodologies and applications. European Journal of Operational Research(2009)]. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains fours elements: a name, a weight, a preference value (p) and an indifference value (q). The preference value represents the threshold from which the difference between two criterion values allows to prefer one vector of values over another. The indifference value represents the threshold from which the difference between two criterion values is considered significant.  Special cases:    returns -1 is the list of candidates is nil or empty   Examples:  int var0 <- promethee_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[name::utility, weight :: 2.0,p::0.5, q::0.0, s::1.0, maximize :: true],[name::price, weight :: 1.0,p::0.5, q::0.0, s::1.0, maximize :: false]]);  // var0 equals 1   See also: weighted_means_DM, electre_DM, evidence_theory_DM,    ### property_file  Possible use:    property_file (string) —>  file   Result: Constructs a file of type property. Allowed extensions are limited to properties    ### pyramid  Possible use:    pyramid (float) —>  geometry   Result: A square geometry which side size is given by the operand.  Comment: the center of the pyramid is by default the location of the current agent in which has been called this operator.  Special cases:    returns nil if the operand is nil.   Examples:  geometry var0 <- pyramid(5);  // var0 equals a geometry as a square with side_size = 5.   See also: around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, square,    ### R_correlation Same signification as corR    ### R_file  Possible use:    R_file (string) —>  file   Result: Constructs a file of type R. Allowed extensions are limited to r    ### R_mean Same signification as meanR    ### range  Possible use:    range (int) —>  container   int range int —>  container   range (int , int) —>  container   range (int, int, int) —>  container   Result: Allows to build a list of int representing all contiguous values from zero to the argument. The range can be increasing or decreasing. Passing 0 will return a singleton list with 0 Allows to build a list of int representing all contiguous values from the first to the second argument, using the step represented by the third argument. The range can be increasing or decreasing. Passing the same value for both will return a singleton list with this value. Passing a step of 0 will result in an exception. Attempting to build infinite ranges (e.g. end > start with a negative step) will similarly not be accepted and yield an exception Allows to build a list of int representing all contiguous values from the first to the second argument. The range can be increasing or decreasing. Passing the same value for both will return a singleton list with this value    ### read  Possible use:    read (string) —>  unknown   Result: Reads an attribute of the agent. The attribute s name is specified by the operand.  Examples:  unknown agent_name <- read ( name );  // agent_name equals reads the  name  variable of agent then assigns the returned value to the  agent_name  variable.      ### rectangle  Possible use:    rectangle (point) —>  geometry   float rectangle float —>  geometry   rectangle (float , float) —>  geometry   point rectangle point —>  geometry   rectangle (point , point) —>  geometry   Result: A rectangle geometry which side sizes are given by the operands.  Comment: the center of the rectangle is by default the location of the current agent in which has been called this operator.the center of the rectangle is by default the location of the current agent in which has been called this operator.  Special cases:    returns nil if the operand is nil.   returns nil if the operand is nil.   returns nil if the operand is nil.   Examples:  geometry var0 <- rectangle(10, 5);  // var0 equals a geometry as a rectangle with width = 10 and height = 5. geometry var1 <- rectangle({2.0,6.0}, {6.0,20.0});  // var1 equals a geometry as a rectangle with {2.0,6.0} as the upper-left corner, {6.0,20.0} as the lower-right corner. geometry var2 <- rectangle({10, 5});  // var2 equals a geometry as a rectangle with width = 10 and height = 5.   See also: around, circle, cone, line, link, norm, point, polygon, polyline, square, triangle,    ### reduced_by Same signification as -    ### regression  Possible use:    regression (any) —>  regression   Result: Casts the operand into the type regression    ### remove_duplicates Same signification as distinct    ### remove_node_from  Possible use:    geometry remove_node_from graph —>  graph   remove_node_from (geometry , graph) —>  graph   Result: removes a node from a graph.  Comment: all the edges containing this node are also removed.  Examples:  graph var0 <- node(0) remove_node_from graphEpidemio;  // var0 equals the graph without node(0)     ### replace  Possible use:    replace (string, string, string) —>  string   Result: Returns the String resulting by replacing for the first operand all the sub-strings corresponding the second operand by the third operand  Examples:  string var0 <- replace( to be or not to be,that is the question , to ,  do );  // var0 equals  do be or not do be,that is the question    See also: replace_regex,    ### replace_regex  Possible use:    replace_regex (string, string, string) —>  string   Result: Returns the String resulting by replacing for the first operand all the sub-strings corresponding to the regular expression given in the second operand by the third operand  Examples:  string var0 <- replace_regex(colour, color, colou?r, col);  // var0 equals  col, col    See also: replace,    ### reverse  Possible use:    reverse (string) —>  string   reverse (container<KeyType,ValueType>) —>  msi.gama.util.IContainer<?,?>   Result: the operand elements in the reversed order in a copy of the operand.  Comment: the reverse operator behavior depends on the nature of the operand  Special cases:    if it is a file, reverse returns a copy of the file with a reversed content   if it is a population, reverse returns a copy of the population with elements in the reversed order   if it is a graph, reverse returns a copy of the graph (with all edges and vertexes), with all of the edges reversed   if it is a string, reverse returns a new string with characters in the reversed order       string var0 <- reverse ( abcd );  // var0 equals  dcba           if it is a list, reverse returns a copy of the operand list with elements in the reversed order       msi.gama.util.IContainer,?> var1 <- reverse ([10,12,14]);  // var1 equals [14, 12, 10]          if it is a map, reverse returns a copy of the operand map with each pair in the reversed order (i.e. all keys become values and values become keys)       msi.gama.util.IContainer,?> var2 <- reverse ([ k1 ::44,  k2 ::32,  k3 ::12]);  // var2 equals [12:: k3 ,  32:: k2 , 44:: k1 ]          if it is a matrix, reverse returns a new matrix containing the transpose of the operand.       msi.gama.util.IContainer,?> var3 <- reverse(matrix([[ c11 , c12 , c13 ],[ c21 , c22 , c23 ]]));  // var3 equals matrix([[ c11 , c21 ],[ c12 , c22 ],[ c13 , c23 ]])         ### rewire_n  Possible use:    graph rewire_n int —>  graph   rewire_n (graph , int) —>  graph   Result: rewires the given count of edges.  Comment: If there are too many edges, all the edges will be rewired.  Examples:  graph var1 <- graphEpidemio rewire_n 10;  // var1 equals the graph with 3 edges rewired     ### rgb  Possible use:    rgb rgb float —>  rgb   rgb (rgb , float) —>  rgb   rgb rgb int —>  rgb   rgb (rgb , int) —>  rgb   string rgb int —>  rgb   rgb (string , int) —>  rgb   rgb (int, int, int) —>  rgb   rgb (int, int, int, float) —>  rgb   rgb (int, int, int, int) —>  rgb   Result: Returns a color defined by red, green, blue components and an alpha blending value.  Special cases:    It can be used with r=red, g=green, b=blue (each between 0 and 255), a=alpha (between 0.0 and 1.0)   It can be used with a color and an alpha between 0 and 1   It can be used with a color and an alpha between 0 and 255   It can be used with r=red, g=green, b=blue, each between 0 and 255   It can be used with a name of color and alpha (between 0 and 255)   It can be used with r=red, g=green, b=blue (each between 0 and 255), a=alpha (between 0 and 255)   Examples:  rgb var0 <- rgb (255,0,0,0.5);  // var0 equals a light red color rgb var1 <- rgb(rgb(255,0,0),0.5);  // var1 equals a light red color rgb var2 <- rgb(rgb(255,0,0),125);  // var2 equals a light red color rgb var3 <- rgb (255,0,0);  // var3 equals #red rgb var4 <- rgb (red);  // var4 equals rgb(255,0,0) rgb var5 <- rgb (255,0,0,125);  // var5 equals a light red color   See also: hsb,    ### rgb_to_xyz  Possible use:    rgb_to_xyz (file) —>  list<point>   Result: A list of point corresponding to RGB value of an image (r:x , g:y, b:z)  Examples:  list<point> var0 <- rgb_to_xyz(texture);  // var0 equals a list of points     ### rnd  Possible use:    rnd (float) —>  float   rnd (int) —>  int   rnd (point) —>  point   point rnd point —>  point   rnd (point , point) —>  point   int rnd int —>  int   rnd (int , int) —>  int   float rnd float —>  float   rnd (float , float) —>  float   rnd (point, point, float) —>  point   rnd (float, float, float) —>  float   rnd (int, int, int) —>  int   Result: a random integer in the interval [0, operand]  Comment: to obtain a probability between 0 and 1, use the expression (rnd n) / n, where n is used to indicate the precision  Special cases:    if the operand is a float, returns an uniformly distributed float random number in [0.0, to]   if the operand is a point, returns a point with three random float ordinates, each in the interval [0, ordinate of argument]   Examples:  float var0 <- rnd(3.4);  // var0 equals a random float between 0.0 and 3.4 point var1 <- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}, 1);  // var1 equals a point with x = 2.0, y equal to 2.0, 3.0 or 4.0 and z between 0.0 and 10.0 every 1.0 point var2 <- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0});  // var2 equals a point with x = 2.0, y between 2.0 and 4.0 and z between 0.0 and 10.0 int var3 <- rnd (2, 4);  // var3 equals 2, 3 or 4 float var4 <- rnd (2.0, 4.0);  // var4 equals a float number between 2.0 and 4.0 float var5 <- rnd (2.0, 4.0, 0.5);  // var5 equals a float number between 2.0 and 4.0 every 0.5 int var6 <- rnd (2);  // var6 equals 0, 1 or 2 float var7 <- rnd (1000) / 1000;  // var7 equals a float between 0 and 1 with a precision of 0.001 point var8 <- rnd ({2.5,3, 0.0});  // var8 equals {x,y} with x in [0.0,2.0], y in [0.0,3.0], z = 0.0 int var9 <- rnd (2, 12, 4);  // var9 equals 2, 6 or 10   See also: flip,    ### rnd_choice  Possible use:    rnd_choice (container) —>  int   Result: returns an index of the given list with a probability following the (normalized) distribution described in the list (a form of lottery)  Examples:  int var0 <- rnd_choice([0.2,0.5,0.3]);  // var0 equals 2/10 chances to return 0, 5/10 chances to return 1, 3/10 chances to return 2   See also: rnd,    ### rnd_color  Possible use:    rnd_color (int) —>  rgb   Result: rgb color  Comment: Return a random color equivalent to rgb(rnd(operand),rnd(operand),rnd(operand))  Examples:  rgb var0 <- rnd_color(255);  // var0 equals a random color, equivalent to rgb(rnd(255),rnd(255),rnd(255))   See also: rgb, hsb,    ### rotated_by  Possible use:    geometry rotated_by float —>  geometry   rotated_by (geometry , float) —>  geometry   geometry rotated_by int —>  geometry   rotated_by (geometry , int) —>  geometry   rotated_by (geometry, float, point) —>  geometry   Result: A geometry resulting from the application of a rotation by the right-hand operand angle (degree) to the left-hand operand (geometry, agent, point) A geometry resulting from the application of a rotation by the right-hand operand angles (degree) along the three axis (x,y,z) to the left-hand operand (geometry, agent, point)  Comment: the right-hand operand can be a float or a int  Examples:  geometry var0 <- self rotated_by 45;  // var0 equals the geometry resulting from a 45 degrees rotation to the geometry of the agent applying the operator. geometry var1 <- rotated_by(pyramid(10),45, {1,0,0});  // var1 equals the geometry resulting from a 45 degrees rotation along the {1,0,0} vector to the geometry of the agent applying the operator.   See also: transformed_by, translated_by,    ### round  Possible use:    round (int) —>  int   round (point) —>  point   round (float) —>  int   Result: Returns the rounded value of the operand.  Special cases:    if the operand is an int, round returns it   Examples:  point var0 <- {12345.78943,  12345.78943, 12345.78943} with_precision 2;  // var0 equals {12345.79,12345.79,12345.79} int var1 <- round (0.51);  // var1 equals 1 int var2 <- round (100.2);  // var2 equals 100 int var3 <- round(-0.51);  // var3 equals -1   See also: round, int, with_precision,    ### row_at  Possible use:    matrix row_at int —>  list   row_at (matrix , int) —>  list   Result: returns the row at a num_line (right-hand operand)  Examples:  list var0 <- matrix([[el11,el12,el13],[el21,el22,el23],[el31,el32,el33]]) row_at 2;  // var0 equals [el13,el23,el33]   See also: column_at, columns_list,    ### rows_list  Possible use:    rows_list (matrix) —>  list<list>   Result: returns a list of the rows of the matrix, with each row as a list of elements  Examples:  list<list> var0 <- rows_list(matrix([[el11,el12,el13],[el21,el22,el23],[el31,el32,el33]]));  // var0 equals [[el11,el21,el31],[el12,el22,el32],[el13,el23,el33]]   See also: columns_list,    ### sample  Possible use:    sample (any expression) —>  string   string sample any expression —>  string   sample (string , any expression) —>  string   sample (container, int, bool) —>  container   sample (container, int, bool, container) —>  container   Result: takes a sample of the specified size from the elements of x using either with or without replacement takes a sample of the specified size from the elements of x using either with or without replacement with given weights  Examples:  container var0 <- sample([2,10,1],2,false);  // var0 equals [1,2] container var1 <- sample([2,10,1],2,false,[0.1,0.7,0.2]);  // var1 equals [10,2]     ### scaled_by Same signification as [](#)    ### scaled_to  Possible use:    geometry scaled_to point —>  geometry   scaled_to (geometry , point) —>  geometry   Result: allows to restrict the size of a geometry so that it fits in the envelope {width, height, depth} defined by the second operand  Examples:  geometry var0 <- shape scaled_to {10,10};  // var0 equals a geometry corresponding to the geometry of the agent applying the operator scaled so that it fits a square of 10x10     ### select Same signification as where    ### set_about  Possible use:    emotion set_about predicate —>  emotion   set_about (emotion , predicate) —>  emotion   Result: change the about value of the given emotion  Examples:  emotion set_about predicate1     ### set_agent  Possible use:    msi.gaml.architecture.simplebdi.SocialLink set_agent agent —>  msi.gaml.architecture.simplebdi.SocialLink   set_agent (msi.gaml.architecture.simplebdi.SocialLink , agent) —>  msi.gaml.architecture.simplebdi.SocialLink   Result: change the agent value of the given social link  Examples:  social_link set_agent agentA     ### set_agent_cause  Possible use:    emotion set_agent_cause agent —>  emotion   set_agent_cause (emotion , agent) —>  emotion   predicate set_agent_cause agent —>  predicate   set_agent_cause (predicate , agent) —>  predicate   Result: change the agentCause value of the given emotion change the agentCause value of the given predicate  Examples:  emotion set_agent_cause agentA predicate set_agent_cause agentA     ### set_decay  Possible use:    emotion set_decay float —>  emotion   set_decay (emotion , float) —>  emotion   Result: change the decay value of the given emotion  Examples:  emotion set_decay 12     ### set_dominance  Possible use:    msi.gaml.architecture.simplebdi.SocialLink set_dominance float —>  msi.gaml.architecture.simplebdi.SocialLink   set_dominance (msi.gaml.architecture.simplebdi.SocialLink , float) —>  msi.gaml.architecture.simplebdi.SocialLink   Result: change the dominance value of the given social link  Examples:  social_link set_dominance 0.4     ### set_familiarity  Possible use:    msi.gaml.architecture.simplebdi.SocialLink set_familiarity float —>  msi.gaml.architecture.simplebdi.SocialLink   set_familiarity (msi.gaml.architecture.simplebdi.SocialLink , float) —>  msi.gaml.architecture.simplebdi.SocialLink   Result: change the familiarity value of the given social link  Examples:  social_link set_familiarity 0.4     ### set_intensity  Possible use:    emotion set_intensity float —>  emotion   set_intensity (emotion , float) —>  emotion   Result: change the intensity value of the given emotion  Examples:  emotion set_intensity 12     ### set_liking  Possible use:    msi.gaml.architecture.simplebdi.SocialLink set_liking float —>  msi.gaml.architecture.simplebdi.SocialLink   set_liking (msi.gaml.architecture.simplebdi.SocialLink , float) —>  msi.gaml.architecture.simplebdi.SocialLink   Result: change the liking value of the given social link  Examples:  social_link set_liking 0.4     ### set_solidarity  Possible use:    msi.gaml.architecture.simplebdi.SocialLink set_solidarity float —>  msi.gaml.architecture.simplebdi.SocialLink   set_solidarity (msi.gaml.architecture.simplebdi.SocialLink , float) —>  msi.gaml.architecture.simplebdi.SocialLink   Result: change the solidarity value of the given social link  Examples:  social_link set_solidarity 0.4     ### set_truth  Possible use:    predicate set_truth bool —>  predicate   set_truth (predicate , bool) —>  predicate   Result: change the is_true value of the given predicate  Examples:  predicate set_truth false     ### set_z  Possible use:    geometry set_z container<float> —>  geometry   set_z (geometry , container<float>) —>  geometry   set_z (geometry, int, float) —>  geometry   Result: Sets the z ordinate of the n-th point of a geometry to the value provided by the third argument  Examples:  loop i from: 0 to: length(shape.points) - 1{set shape <-  set_z (shape, i, 3.0);} shape <- triangle(3) set_z [5,10,14];     ### shape_file  Possible use:    shape_file (string) —>  file   Result: Constructs a file of type shape. Allowed extensions are limited to shp    ### shuffle  Possible use:    shuffle (matrix) —>  matrix   shuffle (string) —>  string   shuffle (container) —>  container   Result: The elements of the operand in random order.  Special cases:    if the operand is empty, returns an empty list (or string, matrix)   Examples:  matrix var0 <- shuffle (matrix([[c11,c12,c13],[c21,c22,c23]]));  // var0 equals matrix([[c12,c21,c11],[c13,c22,c23]]) (for example) string var1 <- shuffle ( abc );  // var1 equals  bac  (for example) container var2 <- shuffle ([12, 13, 14]);  // var2 equals [14,12,13] (for example)   See also: reverse,    ### signum  Possible use:    signum (float) —>  int   Result: Returns -1 if the argument is negative, +1 if it is positive, 0 if it is equal to zero or not a number  Examples:  int var0 <- signum(-12);  // var0 equals -1 int var1 <- signum(14);  // var1 equals 1 int var2 <- signum(0);  // var2 equals 0     ### simple_clustering_by_distance  Possible use:    container<agent> simple_clustering_by_distance float —>  list<list<agent>>   simple_clustering_by_distance (container<agent> , float) —>  list<list<agent>>   Result: A list of agent groups clustered by distance considering a distance min between two groups.  Examples:  list<list<agent>> var0 <- [ag1, ag2, ag3, ag4, ag5] simpleClusteringByDistance 20.0;  // var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]   See also: hierarchical_clustering,    ### simple_clustering_by_envelope_distance Same signification as simple_clustering_by_distance    ### simplification  Possible use:    geometry simplification float —>  geometry   simplification (geometry , float) —>  geometry   Result: A geometry corresponding to the simplification of the operand (geometry, agent, point) considering a tolerance distance.  Comment: The algorithm used for the simplification is Douglas-Peucker  Examples:  geometry var0 <- self simplification 0.1;  // var0 equals the geometry resulting from the application of the Douglas-Peuker algorithm on the geometry of the agent applying the operator with a tolerance distance of 0.1.     ### sin  Possible use:    sin (float) —>  float   sin (int) —>  float   Result: Returns the value (in [-1,1]) of the sinus of the operand (in decimal degrees). The argument is casted to an int before being evaluated.  Special cases:    Operand values out of the range [0-359] are normalized.   Examples:  float var0 <- sin(360);  // var0 equals 0.0 float var1 <- sin (0);  // var1 equals 0.0   See also: cos, tan,    ### sin_rad  Possible use:    sin_rad (float) —>  float   Result: Returns the value (in [-1,1]) of the sinus of the operand (in decimal degrees). The argument is casted to an int before being evaluated.  Special cases:    Operand values out of the range [0-359] are normalized.   Examples:  float var0 <- sin(360);  // var0 equals 0.0   See also: cos, tan,    ### since  Possible use:    since (date) —>  bool   any expression since date —>  bool   since (any expression , date) —>  bool   Result: Returns true if the current_date of the model is after (or equal to) the date passed in argument. Synonym of  current_date >= argument . Can be used, like  after , in its composed form with 2 arguments to express the lowest boundary of the computation of a frequency. However, contrary to  after , there is a subtle difference: the lowest boundary will be tested against the frequency as well  Examples:  reflex when: since(starting_date) {} -: will always be run every(2#days) since (starting_date + 1#day) // the computation will return true 1 day after the starting date and every two days after this reference date     ### skeletonize  Possible use:    skeletonize (geometry) —>  list<geometry>   Result: A list of geometries (polylines) corresponding to the skeleton of the operand geometry (geometry, agent)  Examples:  list<geometry> var0 <- skeletonize(self);  // var0 equals the list of geometries corresponding to the skeleton of the geometry of the agent applying the operator.     ### skew_gauss  Possible use:    skew_gauss (float, float, float, float) —>  float   Result: A value from a skew normally distributed random variable with min value (the minimum skewed value possible), max value (the maximum skewed value possible), skew (the degree to which the values cluster around the mode of the distribution; higher values mean tighter clustering) and bias (the tendency of the mode to approach the min, max or midpoint value; positive values bias toward max, negative values toward min).The algorithm was taken from http://stackoverflow.com/questions/5853187/skewing-java-random-number-generation-toward-a-certain-number  Examples:  float var0 <- skew_gauss(0.0, 1.0, 0.7,0.1);  // var0 equals 0.1729218460343077   See also: gauss, truncated_gauss, poisson,    ### skewness  Possible use:    skewness (list) —>  float   Result: returns skewness value computed from the operand list of values  Special cases:    if the length of the list is lower than 3, returns NaN   Examples:  skewness ([1,2,3,4,5])     ### skill  Possible use:    skill (any) —>  skill   Result: Casts the operand into the type skill    ### smooth  Possible use:    geometry smooth float —>  geometry   smooth (geometry , float) —>  geometry   Result: Returns a  smoothed  geometry, where straight lines are replaces by polynomial (bicubic) curves. The first parameter is the original geometry, the second is the  fit  parameter which can be in the range 0 (loose fit) to 1 (tightest fit).  Examples:  geometry var0 <- smooth(square(10), 0.0);  // var0 equals a  rounded  square     ### social_link  Possible use:    social_link (any) —>  social_link   Result: Casts the operand into the type social_link    ### solid Same signification as without_holes    ### sort Same signification as sort_by    ### sort_by  Possible use:    container sort_by any expression —>  container   sort_by (container , any expression) —>  container   Result: Returns a list, containing the elements of the left-hand operand sorted in ascending order by the value of the right-hand operand when it is evaluated on them.  Comment: the left-hand operand is casted to a list before applying the operator. In the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.  Special cases:    if the left-hand operand is nil, sort_by throws an error   Examples:  container var0 <- [1,2,4,3,5,7,6,8] sort_by (each);  // var0 equals [1,2,3,4,5,6,7,8] container var2 <- g2 sort_by (length(g2 out_edges_of each) );  // var2 equals [node9, node7, node10, node8, node11, node6, node5, node4] container var3 <- (list(node) sort_by (round(node(each).location.x));  // var3 equals [node5, node1, node0, node2, node3] container var4 <- [1::2, 5::6, 3::4] sort_by (each);  // var4 equals [2, 4, 6]   See also: group_by,    ### source_of  Possible use:    graph source_of unknown —>  unknown   source_of (graph , unknown) —>  unknown   Result: returns the source of the edge (right-hand operand) contained in the graph given in left-hand operand.  Special cases:    if the lef-hand operand (the graph) is nil, throws an Exception   Examples:  graph graphEpidemio <- generate_barabasi_albert( [edges_species::edge,vertices_specy::node,size::3,m::5] ); unknown var1 <- graphEpidemio source_of(edge(3));  // var1 equals node1 graph graphFromMap <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); point var3 <- graphFromMap source_of(link({1,5}::{12,45}));  // var3 equals {1,5}   See also: target_of,    ### spatial_graph  Possible use:    spatial_graph (container) —>  graph   Result: allows to create a spatial graph from a container of vertices, without trying to wire them. The container can be empty. Emits an error if the contents of the container are not geometries, points or agents  See also: graph,    ### species  Possible use:    species (unknown) —>  species   Result: casting of the operand to a species.  Special cases:    if the operand is nil, returns nil;   if the operand is an agent, returns its species;   if the operand is a string, returns the species with this name (nil if not found);   otherwise, returns nil   Examples:  species var0 <- species(self);  // var0 equals the species of the current agent species var1 <- species( node );  // var1 equals node species var2 <- species([1,5,9,3]);  // var2 equals nil species var3 <- species(node1);  // var3 equals node     ### species_of Same signification as species    ### sphere  Possible use:    sphere (float) —>  geometry   Result: A sphere geometry which radius is equal to the operand.  Comment: the centre of the sphere is by default the location of the current agent in which has been called this operator.  Special cases:    returns a point if the operand is lower or equal to 0.   Examples:  geometry var0 <- sphere(10);  // var0 equals a geometry as a circle of radius 10 but displays a sphere.   See also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,    ### split_at  Possible use:    geometry split_at point —>  list<geometry>   split_at (geometry , point) —>  list<geometry>   Result: The two part of the left-operand lines split at the given right-operand point  Special cases:    if the left-operand is a point or a polygon, returns an empty list   Examples:  list<geometry> var0 <- polyline([{1,2},{4,6}]) split_at {7,6};  // var0 equals [polyline([{1.0,2.0},{7.0,6.0}]), polyline([{7.0,6.0},{4.0,6.0}])]     ### split_geometry  Possible use:    geometry split_geometry float —>  list<geometry>   split_geometry (geometry , float) —>  list<geometry>   geometry split_geometry point —>  list<geometry>   split_geometry (geometry , point) —>  list<geometry>   split_geometry (geometry, int, int) —>  list<geometry>   Result: A list of geometries that result from the decomposition of the geometry by square cells of the given side size (geometry, size) A list of geometries that result from the decomposition of the geometry by rectangle cells of the given dimension (geometry, {size_x, size_y}) A list of geometries that result from the decomposition of the geometry according to a grid with the given number of rows and columns (geometry, nb_cols, nb_rows)  Examples:  list<geometry> var0 <- to_squares(self, 10.0);  // var0 equals the list of the geometries corresponding to the decomposition of the geometry by squares of side size 10.0 list<geometry> var1 <- to_rectangles(self, {10.0, 15.0});  // var1 equals the list of the geometries corresponding to the decomposition of the geometry by rectangles of size 10.0, 15.0 list<geometry> var2 <- to_rectangles(self, 10,20);  // var2 equals the list of the geometries corresponding to the decomposition of the geometry of the agent applying the operator     ### split_lines  Possible use:    split_lines (container<geometry>) —>  list<geometry>   Result: A list of geometries resulting after cutting the lines at their intersections.  Examples:  list<geometry> var0 <- split_lines([line([{0,10}, {20,10}]), line([{0,10}, {20,10}])]);  // var0 equals a list of four polylines: line([{0,10}, {10,10}]), line([{10,10}, {20,10}]), line([{10,0}, {10,10}]) and line([{10,10}, {10,20}])     ### split_with  Possible use:    string split_with string —>  container   split_with (string , string) —>  container   Result: Returns a list containing the sub-strings (tokens) of the left-hand operand delimited by each of the characters of the right-hand operand.  Comment: Delimiters themselves are excluded from the resulting list.  Examples:  container var0 <-  to be or not to be,that is the question  split_with   , ;  // var0 equals [ to , be , or , not , to , be , that , is , the , question ]     ### sqrt  Possible use:    sqrt (int) —>  float   sqrt (float) —>  float   Result: Returns the square root of the operand.  Special cases:    if the operand is negative, an exception is raised   Examples:  float var0 <- sqrt(4);  // var0 equals 2.0 float var1 <- sqrt(4);  // var1 equals 2.0     ### square  Possible use:    square (float) —>  geometry   Result: A square geometry which side size is equal to the operand.  Comment: the centre of the square is by default the location of the current agent in which has been called this operator.  Special cases:    returns nil if the operand is nil.   Examples:  geometry var0 <- square(10);  // var0 equals a geometry as a square of side size 10.   See also: around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, triangle,    ### squircle  Possible use:    float squircle float —>  geometry   squircle (float , float) —>  geometry   Result: A mix of square and circle geometry (see : http://en.wikipedia.org/wiki/Squircle), which side size is equal to the first operand and power is equal to the second operand  Comment: the center of the ellipse is by default the location of the current agent in which has been called this operator.  Special cases:    returns a point if the side operand is lower or equal to 0.   Examples:  geometry var0 <- squircle(4,4);  // var0 equals a geometry as a squircle of side 4 with a power of 4.   See also: around, cone, line, link, norm, point, polygon, polyline, super_ellipse, rectangle, square, circle, ellipse, triangle,    ### standard_deviation  Possible use:    standard_deviation (container) —>  float   Result: the standard deviation on the elements of the operand. See Standard_deviation for more details.  Comment: The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.  Examples:  float var0 <- standard_deviation ([4.5, 3.5, 5.5, 7.0]);  // var0 equals 1.2930100540985752   See also: mean, mean_deviation,    ### string  Possible use:    date string string —>  string   string (date , string) —>  string   Result: converts a date to astring following a custom pattern. The pattern can use  %Y %M %N %D %E %h %m %s %z  for outputting years, months, name of month, days, name of days, hours, minutes, seconds and the time-zone. A null or empty pattern will return the complete date as defined by the ISO date & time format. The pattern can also follow the pattern definition found here, which gives much more control over the format of the date: https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns. Different patterns are available by default as constants: #iso_local, #iso_simple, #iso_offset, #iso_zoned and #custom, which can be changed in the preferences  Examples:  format(#now,  yyyy-MM-dd )     ### subtract_days Same signification as minus_days    ### subtract_hours Same signification as minus_hours    ### subtract_minutes Same signification as minus_minutes    ### subtract_months Same signification as minus_months    ### subtract_ms Same signification as minus_ms    ### subtract_seconds Same signification as -    ### subtract_weeks Same signification as minus_weeks    ### subtract_years Same signification as minus_years    ### successors_of  Possible use:    graph successors_of unknown —>  container   successors_of (graph , unknown) —>  container   Result: returns the list of successors (i.e. targets of out edges) of the given vertex (right-hand operand) in the given graph (left-hand operand)  Examples:  container var1 <- graphEpidemio successors_of ({1,5});  // var1 equals [{12,45}] container var2 <- graphEpidemio successors_of node({34,56});  // var2 equals []   See also: predecessors_of, neighbors_of,    ### sum  Possible use:    sum (graph) —>  float   sum (container) —>  unknown   Result: the sum of all the elements of the operand  Comment: the behavior depends on the nature of the operand  Special cases:    if it is a population or a list of other types: sum transforms all elements into float and sums them   if it is a map, sum returns the sum of the value of all elements   if it is a file, sum returns the sum of the content of the file (that is also a container)   if it is a graph, sum returns the total weight of the graph   if it is a matrix of int, float or object, sum returns the sum of all the numerical elements (i.e. all elements for integer and float matrices)   if it is a matrix of other types: sum transforms all elements into float and sums them   if it is a list of colors: sum will sum them and return the blended resulting color   if it is a list of int or float: sum returns the sum of all the elements       int var0 <- sum ([12,10,3]);  // var0 equals 25          if it is a list of points: sum returns the sum of all points as a point (each coordinate is the sum of the corresponding coordinate of each element)       unknown var1 <- sum([{1.0,3.0},{3.0,5.0},{9.0,1.0},{7.0,8.0}]);  // var1 equals {20.0,17.0}       See also: mul,    ### sum_of  Possible use:    container sum_of any expression —>  unknown   sum_of (container , any expression) —>  unknown   Result: the sum of the right-hand expression evaluated on each of the elements of the left-hand operand  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    if the left-operand is a map, the keyword each will contain each value       unknown var2 <- [1::2, 3::4, 5::6] sum_of (each + 3);  // var2 equals 21       Examples:  unknown var1 <- [1,2] sum_of (each * 100 );  // var1 equals 300   See also: min_of, max_of, product_of, mean_of,    ### svg_file  Possible use:    svg_file (string) —>  file   Result: Constructs a file of type svg. Allowed extensions are limited to svg    ### tan  Possible use:    tan (int) —>  float   tan (float) —>  float   Result: Returns the value (in [-1,1]) of the trigonometric tangent of the operand (in decimal degrees). The argument is casted to an int before being evaluated.  Special cases:    Operand values out of the range [0-359] are normalized. Notice that tan(360) does not return 0.0 but -2.4492935982947064E-16   The tangent is only defined for any real number except 90 + k * 180 (k an positive or negative integer). Nevertheless notice that tan(90) returns 1.633123935319537E16 (whereas we could except infinity).   Examples:  float var0 <- tan (0);  // var0 equals 0.0 float var1 <- tan(90);  // var1 equals 1.633123935319537E16   See also: cos, sin,    ### tan_rad  Possible use:    tan_rad (float) —>  float   Result: Returns the value (in [-1,1]) of the trigonometric tangent of the operand (in decimal degrees). The argument is casted to an int before being evaluated.  Special cases:    Operand values out of the range [0-359] are normalized. Notice that tan(360) does not return 0.0 but -2.4492935982947064E-16   The tangent is only defined for any real number except 90 + k * 180 (k an positive or negative integer). Nevertheless notice that tan(90) returns 1.633123935319537E16 (whereas we could except infinity).   See also: cos, sin,    ### tanh  Possible use:    tanh (float) —>  float   tanh (int) —>  float   Result: Returns the value (in the interval [-1,1]) of the hyperbolic tangent of the operand (which can be any real number, expressed in decimal degrees).  Examples:  float var0 <- tanh(0);  // var0 equals 0.0 float var1 <- tanh(100);  // var1 equals 1.0     ### target_of  Possible use:    graph target_of unknown —>  unknown   target_of (graph , unknown) —>  unknown   Result: returns the target of the edge (right-hand operand) contained in the graph given in left-hand operand.  Special cases:    if the lef-hand operand (the graph) is nil, returns nil   Examples:  graph graphEpidemio <- generate_barabasi_albert( [edges_species::edge,vertices_specy::node,size::3,m::5] ); unknown var1 <- graphEpidemio source_of(edge(3));  // var1 equals node1 graph graphFromMap <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); unknown var3 <- graphFromMap target_of(link({1,5}::{12,45}));  // var3 equals {12,45}   See also: source_of,    ### teapot  Possible use:    teapot (float) —>  geometry   Result: A teapot geometry which radius is equal to the operand.  Comment: the centre of the teapot is by default the location of the current agent in which has been called this operator.  Special cases:    returns a point if the operand is lower or equal to 0.   Examples:  geometry var0 <- teapot(10);  // var0 equals a geometry as a circle of radius 10 but displays a teapot.   See also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,    ### text_file  Possible use:    text_file (string) —>  file   Result: Constructs a file of type text. Allowed extensions are limited to txt, data, text    ### TGauss Same signification as truncated_gauss    ### threeds_file  Possible use:    threeds_file (string) —>  file   Result: Constructs a file of type threeds. Allowed extensions are limited to 3ds, max    ### to  Possible use:    date to date —>  msi.gama.util.IList<msi.gama.util.GamaDate>   to (date , date) —>  msi.gama.util.IList<msi.gama.util.GamaDate>   Result: builds an interval between two dates (the first inclusive and the second exclusive, which behaves like a read-only list of dates. The default step between two dates is the step of the model  Comment: The default step can be overruled by using the every operator applied to this interval  Examples:  date( 2000-01-01 ) to date( 2010-01-01 ) // builds an interval between these two dates (date( 2000-01-01 ) to date( 2010-01-01 )) every (#month) // builds an interval between these two dates which contains all the monthly dates starting from the beginning of the interval   See also: every,    ### to_GAMA_CRS  Possible use:    to_GAMA_CRS (geometry) —>  geometry   geometry to_GAMA_CRS string —>  geometry   to_GAMA_CRS (geometry , string) —>  geometry   Special cases:    returns the geometry corresponding to the transformation of the given geometry to the GAMA CRS (Coordinate Reference System) assuming the given geometry is referenced by given CRS       geometry var0 <- to_GAMA_CRS({121,14},  EPSG:4326 );  // var0 equals a geometry corresponding to the agent geometry transformed into the GAMA CRS          returns the geometry corresponding to the transformation of the given geometry to the GAMA CRS (Coordinate Reference System) assuming the given geometry is referenced by the current CRS, the one corresponding to the world s agent one       geometry var1 <- to_GAMA_CRS({121,14});  // var1 equals a geometry corresponding to the agent geometry transformed into the GAMA CRS         ### to_gaml  Possible use:    to_gaml (unknown) —>  string   Result: returns the literal description of an expression or description – action, behavior, species, aspect, even model – in gaml  Examples:  string var0 <- to_gaml(0);  // var0 equals  0  string var1 <- to_gaml(3.78);  // var1 equals  3.78  string var2 <- to_gaml(true);  // var2 equals  true  string var3 <- to_gaml({23, 4.0});  // var3 equals  {23.0,4.0,0.0}  string var4 <- to_gaml(5::34);  // var4 equals  5::34  string var5 <- to_gaml(rgb(255,0,125));  // var5 equals  rgb (255, 0, 125,255)  string var6 <- to_gaml( hello );  // var6 equals  hello  string var7 <- to_gaml([1,5,9,3]);  // var7 equals  [1,5,9,3]  string var8 <- to_gaml([ a ::345,  b ::13,  c ::12]);  // var8 equals ([ a ::345, b ::13, c ::12] as map ) string var9 <- to_gaml([[3,5,7,9],[2,4,6,8]]);  // var9 equals  [[3,5,7,9],[2,4,6,8]]  string var10 <- to_gaml(a_graph);  // var10 equals ([((1 as node)::(3 as node))::(5 as edge),((0 as node)::(3 as node))::(3 as edge),((1 as node)::(2 as node))::(1 as edge),((0 as node)::(2 as node))::(2 as edge),((0 as node)::(1 as node))::(0 as edge),((2 as node)::(3 as node))::(4 as edge)] as map ) as graph string var11 <- to_gaml(node1);  // var11 equals  1 as node     ### to_rectangles  Possible use:    to_rectangles (geometry, point, bool) —>  list<geometry>   to_rectangles (geometry, int, int, bool) —>  list<geometry>   Result: A list of rectangles of the size corresponding to the given dimension that result from the decomposition of the geometry into rectangles (geometry, dimension, overlaps), if overlaps = true, add the rectangles that overlap the border of the geometry A list of rectangles corresponding to the given dimension that result from the decomposition of the geometry into rectangles (geometry, nb_cols, nb_rows, overlaps) by a grid composed of the given number of columns and rows, if overlaps = true, add the rectangles that overlap the border of the geometry  Examples:  list<geometry> var0 <- to_rectangles(self, {10.0, 15.0}, true);  // var0 equals the list of rectangles of size {10.0, 15.0} corresponding to the discretization into rectangles of the geometry of the agent applying the operator. The rectangles overlapping the border of the geometry are kept list<geometry> var1 <- to_rectangles(self, 5, 20, true);  // var1 equals the list of rectangles corresponding to the discretization by a grid of 5 columns and 20 rows into rectangles of the geometry of the agent applying the operator. The rectangles overlapping the border of the geometry are kept     ### to_squares Same signification as split_geometry  Possible use:    to_squares (geometry, int, bool) —>  list<geometry>   to_squares (geometry, float, bool) —>  list<geometry>   to_squares (geometry, int, bool, float) —>  list<geometry>   Result: A list of a given number of squares from the decomposition of the geometry into squares (geometry, nb_square, overlaps), if overlaps = true, add the squares that overlap the border of the geometry A list of squares of the size corresponding to the given size that result from the decomposition of the geometry into squares (geometry, size, overlaps), if overlaps = true, add the squares that overlap the border of the geometry A list of a given number of squares from the decomposition of the geometry into squares (geometry, nb_square, overlaps, precision_coefficient), if overlaps = true, add the squares that overlap the border of the geometry, coefficient_precision should be close to 1.0  Examples:  list<geometry> var0 <- to_squares(self, 10, true);  // var0 equals the list of 10 squares corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept list<geometry> var1 <- to_squares(self, 10.0, true);  // var1 equals the list of squares of side size 10.0 corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept list<geometry> var2 <- to_squares(self, 10, true, 0.99);  // var2 equals the list of 10 squares corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept     ### to_triangles Same signification as triangulate    ### tokenize Same signification as split_with    ### topology  Possible use:    topology (unknown) —>  topology   Result: casting of the operand to a topology.  Special cases:    if the operand is a topology, returns the topology itself;   if the operand is a spatial graph, returns the graph topology associated;   if the operand is a population, returns the topology of the population;   if the operand is a shape or a geometry, returns the continuous topology bounded by the geometry;   if the operand is a matrix, returns the grid topology associated   if the operand is another kind of container, returns the multiple topology associated to the container   otherwise, casts the operand to a geometry and build a topology from it.   Examples:  topology var0 <- topology(0);  // var0 equals nil topology(a_graph) --: Multiple topology in POLYGON ((24.712119771887785 7.867357373616512, 24.712119771887785 61.283226839310565, 82.4013676510046  7.867357373616512)) at location[53.556743711446195;34.57529210646354]   See also: geometry,    ### touches  Possible use:    geometry touches geometry —>  bool   touches (geometry , geometry) —>  bool   Result: A boolean, equal to true if the left-geometry (or agent/point) touches the right-geometry (or agent/point).  Comment: returns true when the left-operand only touches the right-operand. When one geometry covers partially (or fully) the other one, it returns false.  Special cases:    if one of the operand is null, returns false.   Examples:  bool var0 <- polyline([{10,10},{20,20}]) touches {15,15};  // var0 equals false bool var1 <- polyline([{10,10},{20,20}]) touches {10,10};  // var1 equals true bool var2 <- {15,15} touches {15,15};  // var2 equals false bool var3 <- polyline([{10,10},{20,20}]) touches polyline([{10,10},{5,5}]);  // var3 equals true bool var4 <- polyline([{10,10},{20,20}]) touches polyline([{5,5},{15,15}]);  // var4 equals false bool var5 <- polyline([{10,10},{20,20}]) touches polyline([{15,15},{25,25}]);  // var5 equals false bool var6 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{15,15},{15,25},{25,25},{25,15}]);  // var6 equals false bool var7 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{10,20},{20,20},{20,30},{10,30}]);  // var7 equals true bool var8 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{10,10},{0,10},{0,0},{10,0}]);  // var8 equals true bool var9 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches {15,15};  // var9 equals false bool var10 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches {10,15};  // var10 equals true   See also: disjoint_from, crosses, overlaps, partially_overlaps, intersects,    ### towards  Possible use:    geometry towards geometry —>  int   towards (geometry , geometry) —>  int   Result: The direction (in degree) between the two geometries (geometries, agents, points) considering the topology of the agent applying the operator.  Examples:  int var0 <- ag1 towards ag2;  // var0 equals the direction between ag1 and ag2 and ag3 considering the topology of the agent applying the operator   See also: distance_between, distance_to, direction_between, path_between, path_to,    ### trace  Possible use:    trace (matrix) —>  float   Result: The trace of the given matrix (the sum of the elements on the main diagonal).  Examples:  float var0 <- trace(matrix([[1,2],[3,4]]));  // var0 equals 5     ### transformed_by  Possible use:    geometry transformed_by point —>  geometry   transformed_by (geometry , point) —>  geometry   Result: A geometry resulting from the application of a rotation and a scaling (right-operand : point {angle(degree), scale factor} of the left-hand operand (geometry, agent, point)  Examples:  geometry var0 <- self transformed_by {45, 0.5};  // var0 equals the geometry resulting from 45 degrees rotation and 50% scaling of the geometry of the agent applying the operator.   See also: rotated_by, translated_by,    ### translated_by  Possible use:    geometry translated_by point —>  geometry   translated_by (geometry , point) —>  geometry   Result: A geometry resulting from the application of a translation by the right-hand operand distance to the left-hand operand (geometry, agent, point)  Examples:  geometry var0 <- self translated_by {10,10,10};  // var0 equals the geometry resulting from applying the translation to the left-hand geometry (or agent).   See also: rotated_by, transformed_by,    ### translated_to Same signification as at_location    ### transpose  Possible use:    transpose (matrix) —>  matrix   Result: The transposition of the given matrix  Examples:  matrix var0 <- transpose(matrix([[5,-3],[6,-4]]));  // var0 equals [[5,6],[-3,-4]]     ### triangle  Possible use:    triangle (float) —>  geometry   Result: A triangle geometry which side size is given by the operand.  Comment: the center of the triangle is by default the location of the current agent in which has been called this operator.  Special cases:    returns nil if the operand is nil.   Examples:  geometry var0 <- triangle(5);  // var0 equals a geometry as a triangle with side_size = 5.   See also: around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, square,    ### triangulate  Possible use:    triangulate (list<geometry>) —>  list<geometry>   triangulate (geometry) —>  list<geometry>   Result: A list of geometries (triangles) corresponding to the Delaunay triangulation of the operand geometry (geometry, agent, point)  Examples:  list<geometry> var0 <- triangulate(self);  // var0 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator. list<geometry> var1 <- triangulate(self);  // var1 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator.     ### truncated_gauss  Possible use:    truncated_gauss (container) —>  float   truncated_gauss (point) —>  float   Result: A random value from a normally distributed random variable in the interval ]mean - standardDeviation; mean + standardDeviation[.  Special cases:    if the operand is a list, only the two first elements are taken into account as [mean, standardDeviation]   when truncated_gauss is called with a list of only one element mean, it will always return 0.0   when the operand is a point, it is read as {mean, standardDeviation}   Examples:  float var0 <- truncated_gauss ([0.5, 0.0]);  // var0 equals 0.5 float var1 <- truncated_gauss ({0, 0.3});  // var1 equals a float between -0.3 and 0.3   See also: gauss,    ### undirected  Possible use:    undirected (graph) —>  graph   Result: the operand graph becomes an undirected graph.  Comment: the operator alters the operand graph, it does not create a new one.  See also: directed,    ### union  Possible use:    union (container<geometry>) —>  geometry   container union container —>  container   union (container , container) —>  container   Result: returns a new list containing all the elements of both containers without duplicated elements.  Special cases:    if the left or right operand is nil, union throws an error   if the right-operand is a container of points, geometries or agents, returns the geometry resulting from the union all the geometries   Examples:  container var0 <- [1,2,3,4,5,6] union [2,4,9];  // var0 equals [1,2,3,4,5,6,9] container var1 <- [1,2,3,4,5,6] union [0,8];  // var1 equals [1,2,3,4,5,6,0,8] container var2 <- [1,3,2,4,5,6,8,5,6] union [0,8];  // var2 equals [1,3,2,4,5,6,8,0] geometry var3 <- union([geom1, geom2, geom3]);  // var3 equals a geometry corresponding to union between geom1, geom2 and geom3   See also: inter, +,    ### unknown  Possible use:    unknown (any) —>  unknown   Result: Casts the operand into the type unknown    ### until  Possible use:    until (date) —>  bool   any expression until date —>  bool   until (any expression , date) —>  bool   Result: Returns true if the current_date of the model is before (or equel to) the date passed in argument. Synonym of  current_date <= argument   Examples:  reflex when: until(starting_date) {} -: will be run only once at the beginning of the simulation     ### upper_case  Possible use:    upper_case (string) —>  string   Result: Converts all of the characters in the string operand to upper case  Examples:  string var0 <- upper_case(Abc);  // var0 equals  ABC    See also: lower_case,    ### URL_file  Possible use:    URL_file (string) —>  file   Result: Constructs a file of type URL. Allowed extensions are limited to url    ### use_cache  Possible use:    graph use_cache bool —>  graph   use_cache (graph , bool) —>  graph   Result: if the second operand is true, the operand graph will store in a cache all the previously computed shortest path (the cache be cleared if the graph is modified).  Comment: the operator alters the operand graph, it does not create a new one.  See also: path_between,    ### user_input  Possible use:    user_input (any expression) —>  map<string,unknown>   string user_input any expression —>  map<string,unknown>   user_input (string , any expression) —>  map<string,unknown>   Result: asks the user for some values (not defined as parameters). Takes a string (optional) and a map as arguments. The string is used to specify the message of the dialog box. The map is to specify the parameters you want the user to change before the simulation starts, with the name of the parameter in string key, and the default value as value.  Comment: This operator takes a map [string::value] as argument, displays a dialog asking the user for these values, and returns the same map with the modified values (if any). The dialog is modal and will interrupt the execution of the simulation until the user has either dismissed or accepted it. It can be used, for instance, in an init section to force the user to input new values instead of relying on the initial values of parameters :  Examples:  map<string,unknown> values2 <- user_input(Enter numer of agents and locations,[Number :: 100, Location :: {10, 10}]); create bug number: int(values2 at Number) with: [location:: (point(values2 at Location))]; map<string,unknown> values <- user_input([Number :: 100, Location :: {10, 10}]); create bug number: int(values at Number) with: [location:: (point(values at Location))];     ### using  Possible use:    any expression using topology —>  unknown   using (any expression , topology) —>  unknown   Result: Allows to specify in which topology a spatial computation should take place.  Special cases:    has no effect if the topology passed as a parameter is nil   Examples:  unknown var0 <- (agents closest_to self) using topology(world);  // var0 equals the closest agent to self (the caller) in the continuous topology of the world     ### variance  Possible use:    variance (container) —>  float   Result: the variance of the elements of the operand. See Variance for more details.  Comment: The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.  Examples:  float var0 <- variance ([4.5, 3.5, 5.5, 7.0]);  // var0 equals 1.671875   See also: mean, median,    ### variance_of  Possible use:    container variance_of any expression —>  unknown   variance_of (container , any expression) —>  unknown   Result: the variance of the right-hand expression evaluated on each of the elements of the left-hand operand  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  See also: min_of, max_of, sum_of, product_of,    ### voronoi  Possible use:    voronoi (list<point>) —>  list<geometry>   list<point> voronoi geometry —>  list<geometry>   voronoi (list<point> , geometry) —>  list<geometry>   Result: A list of geometries corresponding to the Voronoi diagram built from the list of points according to the given clip A list of geometries corresponding to the Voronoi diagram built from the list of points  Examples:  list<geometry> var0 <- voronoi([{10,10},{50,50},{90,90},{10,90},{90,10}], square(300));  // var0 equals the list of geometries corresponding to the Voronoi Diagram built from the list of points with a square of 300m side size as clip. list<geometry> var1 <- voronoi([{10,10},{50,50},{90,90},{10,90},{90,10}]);  // var1 equals the list of geometries corresponding to the Voronoi Diagram built from the list of points.     ### weight_of  Possible use:    graph weight_of unknown —>  float   weight_of (graph , unknown) —>  float   Result: returns the weight of the given edge (right-hand operand) contained in the graph given in right-hand operand.  Comment: In a localized graph, an edge has a weight by default (the distance between both vertices).  Special cases:    if the left-operand (the graph) is nil, returns nil   if the right-hand operand is not an edge of the given graph, weight_of checks whether it is a node of the graph and tries to return its weight   if the right-hand operand is neither a node, nor an edge, returns 1.   Examples:  graph graphFromMap <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); float var1 <- graphFromMap weight_of(link({1,5}::{12,45}));  // var1 equals 1.0     ### weighted_means_DM  Possible use:    list<list> weighted_means_DM list<map<string,object>> —>  int   weighted_means_DM (list<list> , list<map<string,object>>) —>  int   Result: The index of the candidate that maximizes the weighted mean of its criterion values. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion (list of map)  Special cases:    returns -1 is the list of candidates is nil or empty   Examples:  int var0 <- weighted_means_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[name::utility, weight :: 2.0],[name::price, weight :: 1.0]]);  // var0 equals 1   See also: promethee_DM, electre_DM, evidence_theory_DM,    ### where  Possible use:    container where any expression —>  container   where (container , any expression) —>  container   Result: a list containing all the elements of the left-hand operand that make the right-hand operand evaluate to true.  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    if the left-hand operand is a list nil, where returns a new empty list   if the left-operand is a map, the keyword each will contain each value       container var4 <- [1::2, 3::4, 5::6] where (each >= 4);  // var4 equals [4, 6]       Examples:  container var0 <- [1,2,3,4,5,6,7,8] where (each > 3);  // var0 equals [4, 5, 6, 7, 8]  container var2 <- g2 where (length(g2 out_edges_of each) = 0 );  // var2 equals [node9, node7, node10, node8, node11] container var3 <- (list(node) where (round(node(each).location.x) > 32);  // var3 equals [node2, node3]   See also: first_with, last_with, where,    ### with_lifetime  Possible use:    predicate with_lifetime int —>  predicate   with_lifetime (predicate , int) —>  predicate   Result: change the parameters of the given predicate  Examples:  predicate with_lifetime 10     ### with_max_of  Possible use:    container with_max_of any expression —>  unknown   with_max_of (container , any expression) —>  unknown   Result: one of elements of the left-hand operand that maximizes the value of the right-hand operand  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    if the left-hand operand is nil, with_max_of returns the default value of the right-hand operand   Examples:  unknown var0 <- [1,2,3,4,5,6,7,8] with_max_of (each );  // var0 equals 8 unknown var2 <- g2 with_max_of (length(g2 out_edges_of each)  ) ;  // var2 equals node4 unknown var3 <- (list(node) with_max_of (round(node(each).location.x));  // var3 equals node3 unknown var4 <- [1::2, 3::4, 5::6] with_max_of (each);  // var4 equals 6   See also: where, with_min_of,    ### with_min_of  Possible use:    container with_min_of any expression —>  unknown   with_min_of (container , any expression) —>  unknown   Result: one of elements of the left-hand operand that minimizes the value of the right-hand operand  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    if the left-hand operand is nil, with_max_of returns the default value of the right-hand operand   Examples:  unknown var0 <- [1,2,3,4,5,6,7,8] with_min_of (each );  // var0 equals 1 unknown var2 <- g2 with_min_of (length(g2 out_edges_of each)  );  // var2 equals node11 unknown var3 <- (list(node) with_min_of (round(node(each).location.x));  // var3 equals node0 unknown var4 <- [1::2, 3::4, 5::6] with_min_of (each);  // var4 equals 2   See also: where, with_max_of,    ### with_optimizer_type  Possible use:    graph with_optimizer_type string —>  graph   with_optimizer_type (graph , string) —>  graph   Result: changes the shortest path computation method of the given graph  Comment: the right-hand operand can be  Djikstra ,  Bellmann ,  Astar  to use the associated algorithm. Note that these methods are dynamic: the path is computed when needed. In contrarily, if the operand is another string, a static method will be used, i.e. all the shortest are previously computed.  Examples:  graphEpidemio <- graphEpidemio with_optimizer_type static;   See also: set_verbose,    ### with_praiseworthiness  Possible use:    predicate with_praiseworthiness float —>  predicate   with_praiseworthiness (predicate , float) —>  predicate   Result: change the praiseworthiness value of the given predicate  Examples:  predicate set_truth false     ### with_precision  Possible use:    float with_precision int —>  float   with_precision (float , int) —>  float   point with_precision int —>  point   with_precision (point , int) —>  point   Result: Rounds off the value of left-hand operand to the precision given by the value of right-hand operand Rounds off the ordinates of the left-hand point to the precision given by the value of right-hand operand  Examples:  float var0 <- 12345.78943 with_precision 2;  // var0 equals 12345.79 float var1 <- 123 with_precision 2;  // var1 equals 123.00 point var2 <- {12345.78943, 12345.78943, 12345.78943} with_precision 2 ;  // var2 equals {12345.79, 12345.79, 12345.79}   See also: round,    ### with_priority  Possible use:    predicate with_priority float —>  predicate   with_priority (predicate , float) —>  predicate   Result: change the priority of the given predicate  Examples:  predicate with_priority 2     ### with_values  Possible use:    predicate with_values map —>  predicate   with_values (predicate , map) —>  predicate   Result: change the parameters of the given predicate  Examples:  predicate with_values [time::10]     ### with_weights  Possible use:    graph with_weights map —>  graph   with_weights (graph , map) —>  graph   graph with_weights container —>  graph   with_weights (graph , container) —>  graph   Result: returns the graph (left-hand operand) with weight given in the map (right-hand operand).  Comment: this operand re-initializes the path finder  Special cases:    if the right-hand operand is a list, affects the n elements of the list to the n first edges. Note that the ordering of edges may change overtime, which can create some problems…   if the left-hand operand is a map, the map should contains pairs such as: vertex/edge::double       graph_from_edges (list(ant) as_map each::one_of (list(ant))) with_weights (list(ant) as_map each::each.food)         ### without_holes  Possible use:    without_holes (geometry) —>  geometry   Result: A geometry corresponding to the operand geometry (geometry, agent, point) without its holes  Examples:  geometry var0 <- solid(self);  // var0 equals the geometry corresponding to the geometry of the agent applying the operator without its holes.     ### writable  Possible use:    file writable bool —>  file   writable (file , bool) —>  file   Result: Marks the file as read-only or not, depending on the second boolean argument, and returns the first argument  Comment: A file is created using its native flags. This operator can change them. Beware that this change is system-wide (and not only restrained to GAMA): changing a file to read-only mode (e.g.  writable(f, false) )  Examples:  file var0 <- shape_file(../images/point_eau.shp) writable false;  // var0 equals returns a file in read-only mode   See also: file,    ### xml_file  Possible use:    xml_file (string) —>  file   Result: Constructs a file of type xml. Allowed extensions are limited to xml    ### years_between  Possible use:    date years_between date —>  int   years_between (date , date) —>  int   Result: Provide the exact number of years between two dates. This number can be positive or negative (if the second operand is smaller than the first one)  Examples:  years_between(d1, d2) -: 10    ","url":"wiki/Operators.md"},{"id":"wiki/OtherBuiltInSpecies.md","title":" Other Built-in Species (Under Construction)","content":"Other Built-in Species (Under Construction)  TODO ","url":"wiki/OtherBuiltInSpecies.md"},{"id":"wiki/PseudoVariables.md","title":" Pseudo-variables","content":"# Pseudo-variables  The expressions known as pseudo-variables are special read-only variables that are not declared anywhere (at least not in a species), and which represent a value that changes depending on the context of execution.  Table of contents     Pseudo-variables  self       myself       each self The pseudo-variable self always holds a reference to the agent executing the current statement.     Example (sets the friend attribute of another random agent of the same species to self and conversely):    friend potential_friend <- one_of (species(self) - self); if potential_friend != nil {     potential_friend.friend <- self;     friend <- potential_friend; }   myself myself plays the same role as self but in remotely-executed code (ask, create, capture and release statements), where it represents the calling agent when the code is executed by the remote agent.     Example (asks the first agent of my species to set its color to my color):    ask first (species (self)){     color <- myself.color; }      Example (create 10 new agents of the species of my species, share the energy between them, turn them towards me, and make them move 4 times to get closer to me):    create species (self) number: 10 {    energy <- myself.energy / 10.0;    loop times: 4 { heading <- towards (myself); do move;    } }   each each is available only in the right-hand argument of iterators.  It is a pseudo-variable that represents, in turn, each of the elements of the left-hand container. It can then take any type depending on the context.     Example: list<string> names <- my_species collect each.name;  // each is of type my_species     int max <- max([ aa ,  bbb ,  cccc ] collect length(each)); // each is of type string  ","url":"wiki/PseudoVariables.md"},{"id":"wiki/SpeciesBuiltIn.md","title":" Built-in Species","content":"Built-in Species   This file is automatically generated from java files. Do Not Edit It.   It is possible to use in the models a set of built-in agents. These agents allow to directly use some advance features like clustering, multi-criteria analysis, etc. The creation of these agents are similar as for other kinds of agents:   create species: my_built_in_agent returns: the_agent;   So, for instance, to be able to use clustering techniques in the model:  create cluster_builder returns: clusterer;   The list of available built-in agents in GAMA is:     cluster_builder: allows to use clustering techniques on a set of agents.   multicriteria_analyzer: allows to use multi-criteria analysis methods.   Top of the page  Table of Contents  agent  Actions  init     returns: unknown   step     returns: unknown   Top of the page  AgentDB  Actions  close     returns: unknown   connect     returns: unknown   → params (map): Connection parameters   executeUpdate     returns: int   → updateComm (string): SQL commands such as Create, Update, Delete, Drop with question mark   → values (list): List of values that are used to replace question mark   getParameter     returns: unknown   helloWorld     returns: unknown   insert     returns: int   → into (string): Table name   → columns (list): List of column name of table   → values (list): List of values that are used to insert into table. Columns and values must have same size   isConnected     returns: bool   select     returns: list   → select (string): select string   → values (list): List of values that are used to replace question marks   setParameter     returns: unknown   → params (map): Connection parameters   testConnection     returns: bool   → params (map): Connection parameters   timeStamp     returns: float   Top of the page  base_edge  Actions  Top of the page  experiment  Actions  Top of the page  graph_edge  Actions  Top of the page  graph_node  Actions  related_to     returns: bool   → other (agent):   Top of the page  model  Actions  halt Allows to stop the current simulation so that cannot be continued after. All the behaviors and updates are stopped.   * returns: unknown  pause Allows to pause the current simulation ACTUALLY EXPERIMENT FOR THE MOMENT. It can be set to continue with the manual intervention of the user.   * returns: unknown  Top of the page  multicriteria_analyzer  Actions  electre_DM     returns: int   evidence_theory_DM     returns: int   promethee_DM     returns: int   weighted_means_DM     returns: int   Top of the page  Physical3DWorld  Actions  computeForces     returns: unknown   Top of the page ","url":"wiki/SpeciesBuiltIn.md"},{"id":"wiki/Statements.md","title":" Statements","content":"Statements    This file is automatically generated from java files. Do Not Edit It.    Table of Contents   =, action, add, agents, annealing, ask, aspect, assert, benchmark, break, camera, capture, chart, conscious_contagion, create, data, datalist, default, diffuse, display, display_grid, display_population, do, draw, else, emotional_contagion, enter, equation, error, event, exhaustive, exit, experiment, export, focus, focus_on, genetic, graphics, highlight, hill_climbing, if, image, inspect, let, light, loop, match, migrate, monitor, output, output_file, overlay, parameter, perceive, permanent, plan, put, reactive_tabu, reflex, release, remove, return, rule, run, save, save_batch, set, setup, simulate, socialize, solve, species, state, status, switch, tabu, task, test, trace, transition, unconscious_contagion, user_command, user_init, user_input, user_panel, using, Variable_container, Variable_number, Variable_regular, warn, write,  Statements by kinds     Batch method  annealing,  exhaustive,  genetic,  hill_climbing,  reactive_tabu,  save_batch,  tabu, Behavior  aspect,  plan,  reflex,  state,  task,  test,  user_init,  user_panel, Experiment  experiment, Layer  agents,  camera,  chart,  display_grid,  display_population,  event,  graphics,  image,  light,  overlay, Output  display,  inspect,  monitor,  output,  output_file,  permanent, Parameter  parameter, Sequence of statements or action  action,  ask,  benchmark,  capture,  create,  default,  else,  enter,  equation,  exit,  if,  loop,  match,  migrate,  perceive,  release,  run,  setup,  switch,  trace,  transition,  user_command,  using, Single statement  =,  add,  assert,  break,  conscious_contagion,  data,  datalist,  diffuse,  do,  draw,  emotional_contagion,  error,  export,  focus,  focus_on,  highlight,  let,  put,  remove,  return,  rule,  save,  set,  simulate,  socialize,  solve,  status,  unconscious_contagion,  user_input,  warn,  write, Species  species, Variable (container)  Variable_container, Variable (number)  Variable_number, Variable (regular)  Variable_regular, Statements by embedment     Behavior  add, ask, benchmark, capture, conscious_contagion, create, diffuse, do, emotional_contagion, error, focus, focus_on, highlight, if, inspect, let, loop, migrate, put, release, remove, return, run, save, set, simulate, socialize, solve, status, switch, trace, transition, unconscious_contagion, using, warn, write, Environment  species, Experiment  action, annealing, exhaustive, export, genetic, hill_climbing, output, parameter, permanent, reactive_tabu, reflex, save_batch, setup, simulate, state, tabu, task, test, user_command, user_init, user_panel, Variable_container, Variable_number, Variable_regular, Layer  add, benchmark, draw, error, focus_on, highlight, if, let, loop, put, remove, set, status, switch, trace, using, warn, write, Model  action, aspect, equation, experiment, output, perceive, plan, reflex, rule, run, setup, species, state, task, test, user_command, user_init, user_panel, Variable_container, Variable_number, Variable_regular, Sequence of statements or action  add, ask, benchmark, break, capture, conscious_contagion, create, data, datalist, diffuse, do, draw, emotional_contagion, error, focus, focus_on, highlight, if, inspect, let, loop, migrate, put, release, remove, return, save, set, simulate, socialize, solve, status, switch, trace, transition, unconscious_contagion, using, warn, write, Single statement  run, Species  action, aspect, equation, perceive, plan, reflex, rule, run, setup, simulate, species, state, task, test, user_command, user_init, user_panel, Variable_container, Variable_number, Variable_regular, action  return, aspect  draw, chart  add, ask, data, datalist, do, put, remove, set, simulate, using, display  agents, camera, chart, display_grid, display_population, event, graphics, image, light, overlay, display_population  display_population, equation  =, fsm  state, user_panel, if  else, output  display, inspect, monitor, output_file, permanent  display, inspect, monitor, output_file, probabilistic_tasks  task, sorted_tasks  task, state  enter, exit, switch  default, match, test  assert, user_command  user_input, user_first  user_panel, user_init  user_panel, user_last  user_panel, user_only  user_panel, user_panel  user_command, weighted_tasks  task, General syntax  A statement represents either a declaration or an imperative command. It consists in a keyword, followed by specific facets, some of them mandatory (in bold), some of them optional. One of the facet names can be omitted (the one denoted as omissible). It has to be the first one.   statement_keyword expression1 facet2: expression2 ... ; or statement_keyword facet1: expression1 facet2: expression2 ...;   If the statement encloses other statements, it is called a sequence statement, and its sub-statements (either sequence statements or single statements) are declared between curly brackets, as in:   statement_keyword1 expression1 facet2: expression2... { // a sequence statement      statement_keyword2 expression1 facet2: expression2...;  // a single statement      statement_keyword3 expression1 facet2: expression2...; }     ### =  #### Facets     right (float), (omissible) : the right part of the equation (it is mandatory that it can be evaluated as a float   left (any type): the left part of the equation (it should be a variable or a call to the diff() or diff2() operators)   Definition  Allows to implement an equation in the form function(n, t) = expression. The left function is only here as a placeholder for enabling a simpler syntax and grabbing the variable as its left member.  Usages     The syntax of the = statement is a bit different from the other statements. It has to be used as follows (in an equation):    float t; float S; float I; equation SI {     diff(S,t) = (- 0.3 * S * I / 100);    diff(I,t) = (0.3 * S * I / 100); }       See also: equation, solve,   Embedments    The = statement is of type: Single statement   The = statement can be embedded into: equation,   The = statement embeds statements:     ### action  #### Facets     name (an identifier), (omissible) : identifier of the action   index (a datatype identifier): if the action returns a map, the type of its keys   of (a datatype identifier): if the action returns a container, the type of its elements   type (a datatype identifier): the action returned type   virtual (boolean): whether the action is virtual (defined without a set of instructions) (false by default)   Definition  Allows to define in a species, model or experiment a new action that can be called elsewhere.  Usages     The simplest syntax to define an action that does not take any parameter and does not return anything is:    action simple_action {    // [set of statements] }      If the action needs some parameters, they can be specified betwee, braquets after the identifier of the action:    action action_parameters(int i, string s){    // [set of statements using i and s] }      If the action returns any value, the returned type should be used instead of the  action  keyword. A return statement inside the body of the action statement is mandatory.    int action_return_val(int i, string s){    // [set of statements using i and s]    return i + i; }      If virtual: is true, then the action is abstract, which means that the action is defined without body. A species containing at least one abstract action is abstract. Agents of this species cannot be created. The common use of an abstract action is to define an action that can be used by all its sub-species, which should redefine all abstract actions and implements its body.       species parent_species {    int virtual_action(int i, string s); }  species children parent: parent_species {    int virtual_action(int i, string s) {       return i + i;    } }         See also: do,   Embedments    The action statement is of type: Sequence of statements or action   The action statement can be embedded into: Species, Experiment, Model,   The action statement embeds statements: return,     ### add  #### Facets     to (any type in [container, species, agent, geometry]): an expression that evaluates to a container   item (any type), (omissible) : any expression to add in the container   all (any type): Allows to either pass a container so as to add all its element, or  true , if the item to add is already a container.   at (any type): position in the container of added element   edge (any type): a pair that will be added to a graph as an edge (if nodes do not exist, they are also added)   node (any type): an expression that will be added to a graph as a node.   vertex (any type):   weight (float):   Definition  Allows to add, i.e. to insert, a new element in a container (a list, matrix, map, …).Incorrect use: The addition of a new element at a position out of the bounds of the container will produce a warning and let the container unmodified. If all: is specified, it has no effect if its argument is not a container, or if its argument is  true  and the item to add is not a container. In that latter case  Usages     The new element can be added either at the end of the container or at a particular position.    add expr to: expr_container;    // Add at the end add expr at: expr to: expr_container;   // Add at position expr      Case of a list, the expression in the facet at: should be an integer.    list<int> workingList <- []; add 0 at: 0 to: workingList ;  // workingList equals [0] add 10 at: 0 to: workingList ;  // workingList equals [10,0] add 20 at: 2 to: workingList ;  // workingList equals [10,0,20] add 50 to: workingList;  // workingList equals [10,0,20,50] add [60,70] all: true to: workingList;  // workingList equals [10,0,20,50,60,70]      Case of a map: As a map is basically a list of pairs key::value, we can also use the add statement on it. It is important to note that the behavior of the statement is slightly different, in particular in the use of the at facet, which denotes the key of the pair.    map<string,string> workingMap <- []; add val1 at: x to: workingMap;  // workingMap equals [x::val1]      If the at facet is omitted, a pair expr_item::expr_item will be added to the map. An important exception is the case where the expr_item is a pair: in this case the pair is added.    add val2 to: workingMap;  // workingMap equals [x::val1, val2::val2] add 5::val4 to: workingMap;   // workingMap equals [x::val1, val2::val2, 5::val4]      Notice that, as the key should be unique, the addition of an item at an existing position (i.e. existing key) will only modify the value associated with the given key.    add val3 at: x to: workingMap;  // workingMap equals [x::val3, val2::val2, 5::val4]      On a map, the all facet will add all value of a container  in the map (so as pair val_cont::val_cont)    add [val4,val5] all: true at: x to: workingMap;  // workingMap equals [x::val3, val2::val2, 5::val4,val4::val4,val5::val5]      In case of a graph, we can use the facets node, edge and weight to add a node, an edge or weights to the graph. However, these facets are now considered as deprecated, and it is advised to use the various edge(), node(), edges(), nodes() operators, which can build the correct objects to add to the graph    graph g <- as_edge_graph([{1,5}::{12,45}]); add edge: {1,5}::{2,3} to: g; list var <- g.vertices;  // var equals [{1,5},{12,45},{2,3}] list var <- g.edges;  // var equals [polyline({1.0,5.0}::{12.0,45.0}),polyline({1.0,5.0}::{2.0,3.0})] add node: {5,5} to: g; list var <- g.vertices;  // var equals [{1.0,5.0},{12.0,45.0},{2.0,3.0},{5.0,5.0}] list var <- g.edges;  // var equals [polyline({1.0,5.0}::{12.0,45.0}),polyline({1.0,5.0}::{2.0,3.0})]      Case of a matrix: this statement can not be used on matrix. Please refer to the statement put.   See also: put, remove,   Embedments    The add statement is of type: Single statement   The add statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer,   The add statement embeds statements:     ### agents  #### Facets     value (container): the set of agents to display   name (a label), (omissible) : Human readable title of the layer   aspect (an identifier): the name of the aspect that should be used to display the species   fading (boolean): Used in conjunction with  trace: , allows to apply a fading effect to the previous traces. Default is false   focus (agent): the agent on which the camera will be focused (it is dynamically computed)   position (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.   refresh (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, useful in case of agents that do not move)   selectable (boolean): Indicates whether the agents present on this layer are selectable by the user. Default is true   size (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in  position , an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions   trace (any type in [boolean, int]): Allows to aggregate the visualization of agents at each timestep on the display. Default is false. If set to an int value, only the last n-th steps will be visualized. If set to true, no limit of timesteps is applied.   transparency (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency)   Definition  agents allows the modeler to display only the agents that fulfill a given condition.  Usages     The general syntax is:    display my_display {    agents layer_name value: expression [additional options]; }      For instance, in a segregation model, agents will only display unhappy agents:    display Segregation {    agents agentDisappear value: people as list where (each.is_happy = false) aspect: with_group_color; }      See also: display, chart, event, graphics, display_grid, image, overlay, display_population,   Embedments    The agents statement is of type: Layer   The agents statement can be embedded into: display,   The agents statement embeds statements:     ### annealing  #### Facets     name (an identifier), (omissible) :   aggregation (a label), takes values in: {min, max}: the agregation method   maximize (float): the value the algorithm tries to maximize   minimize (float): the value the algorithm tries to minimize   nb_iter_cst_temp (int): number of iterations per level of temperature   temp_decrease (float): temperature decrease coefficient   temp_end (float): final temperature   temp_init (float): initial temperature   Definition  This algorithm is an implementation of the Simulated Annealing algorithm. See the wikipedia article and [batch161 the batch dedicated page].  Usages     As other batch methods, the basic syntax of the annealing statement uses method annealing instead of the expected annealing name: id :    method annealing [facet: value];      For example:    method annealing temp_init: 100  temp_end: 1 temp_decrease: 0.5 nb_iter_cst_temp: 5 maximize: food_gathered;   Embedments    The annealing statement is of type: Batch method   The annealing statement can be embedded into: Experiment,   The annealing statement embeds statements:     ### ask  #### Facets     target (any type in [container, agent]), (omissible) : an expression that evaluates to an agent or a list of agents   as (species): an expression that evaluates to a species   parallel (any type in [boolean, int]): (experimental) setting this facet to  true  will allow  ask  to use concurrency when traversing the targets; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet is false by default.   Definition  Allows an agent, the sender agent (that can be the [Sections161#global world agent]), to ask another (or other) agent(s) to perform a set of statements. If the value of the target facet is nil or empty, the statement is ignored.  Usages     Ask  a set of receiver agents, stored in a container, to perform a block of statements. The block is evaluated in the context of the agents  species    ask ${receiver_agents} {      ${cursor} }      Ask  one agent to perform a block of statements. The block is evaluated in the context of the agent s species    ask ${one_agent} {      ${cursor} }      If the species of the receiver agent(s) cannot be determined, it is possible to force it using the as facet. An error is thrown if an agent is not a direct or undirect instance of this species    ask${receiver_agent(s)} as: ${a_species_expression} {      ${cursor} }      To ask a set of agents to do something only if they belong to a given species, the of_species operator can be used. If none of the agents belong to the species, nothing happens    ask ${receiver_agents} of_species ${species_name} {      ${cursor} }      Any statement can be declared in the block statements. All the statements will be evaluated in the context of the receiver agent(s), as if they were defined in their species, which means that an expression like self will represent the receiver agent and not the sender. If the sender needs to refer to itself, some of its own attributes (or temporary variables) within the block statements, it has to use the keyword myself.    species animal {     float energy <- rnd (1000) min: 0.0 {     reflex when: energy > 500 { // executed when the energy is above the given threshold   list<animal> others <- (animal at_distance 5); // find all the neighboring animals in a radius of 5 meters   float shared_energy  <- (energy - 500) / length (others); // compute the amount of energy to share with each of them   ask others { // no need to cast, since others has already been filtered to only include animals     if (energy < 500) { // refers to the energy of each animal in others   energy <- energy + myself.shared_energy; // increases the energy of each animal   myself.energy <- myself.energy - myself.shared_energy; // decreases the energy of the sender     }   }     } }      If the species of the receiver agent cannot be determined, it is possible to force it by casting the agent. Nothing happens if the agent cannot be casted to this species   Embedments    The ask statement is of type: Sequence of statements or action   The ask statement can be embedded into: chart, Behavior, Sequence of statements or action,   The ask statement embeds statements:     ### aspect  #### Facets     name (an identifier), (omissible) : identifier of the aspect (it can be used in a display to identify which aspect should be used for the given species). Two special names can also be used:  default  will allow this aspect to be used as a replacement for the default aspect defined in preferences;  highlighted  will allow the aspect to be used when the agent is highlighted as a replacement for the default (application of a color)   Definition  Aspect statement is used to define a way to draw the current agent. Several aspects can be defined in one species. It can use attributes to customize each agent s aspect. The aspect is evaluate for each agent each time it has to be displayed.  Usages     An example of use of the aspect statement:    species one_species {  int a <- rnd(10);  aspect aspect1 {   if(a mod 2 = 0) { draw circle(a);}   else {draw square(a);}   draw text: a=  + a color: #black size: 5;  } }   Embedments    The aspect statement is of type: Behavior   The aspect statement can be embedded into: Species, Model,   The aspect statement embeds statements: draw,     ### assert  #### Facets     value (any type), (omissible) : the value that is evaluated and compared to other facets   equals (any type): an expression, assert tests whether the value is equals to this expression   is_not (any type): an expression, assert tests whether the value is not equals to this expression   raises (an identifier):  error  or  warning , used in testing what raises the evaluation of the value: expression   Definition  Allows to check whether the evaluation of a given expression fulfills a given condition. If it is not fulfilled, an exception is raised.  Usages     if the equals: facet is used, the equality between the evaluation of expressions in the value: and in the equals: facets is tested    assert (2+2) equals: 4;      if the is_not: facet is used, the inequality between the evaluation of expressions in the value: and in the equals: facets is tested    assert self is_not: nil;      if the raises: facet is used with either  warning  or  error , the statement tests whether the evaluation of the value: expression raises an error (resp. a warning)    int z <- 0; assert (3/z) raises: error;      See also: test, setup,   Embedments    The assert statement is of type: Single statement   The assert statement can be embedded into: test,   The assert statement embeds statements:     ### benchmark  #### Facets     message (any type), (omissible) : A message to display alongside the results. Should concisely describe the contents of the benchmark   repeat (int): An int expression describing how many executions of the block must be handled. The output in this case will return the min, max and average durations   Definition  Displays in the console the duration in ms of the execution of the statements included in the block. It is possible to indicate, with the  repeat  facet, how many times the sequence should be run  Usages  Embedments    The benchmark statement is of type: Sequence of statements or action   The benchmark statement can be embedded into: Behavior, Sequence of statements or action, Layer,   The benchmark statement embeds statements:     ### break  #### Facets  Definition  break allows to interrupt the current sequence of statements.  Usages  Embedments    The break statement is of type: Single statement   The break statement can be embedded into: Sequence of statements or action,   The break statement embeds statements:     ### camera  #### Facets     name (string), (omissible) : The name of the camera   location (point): The location of the camera in the world   look_at (point): The location that the camera is looking   up_vector (point): The up-vector of the camera.   Definition  camera allows the modeler to define a camera. The display will then be able to choose among the camera defined (either within this statement or globally in GAMA) in a dynamic way.  Usages     See also: display, agents, chart, event, graphics, display_grid, image, display_population,   Embedments    The camera statement is of type: Layer   The camera statement can be embedded into: display,   The camera statement embeds statements:     ### capture  #### Facets     target (any type in [agent, container]), (omissible) : an expression that is evaluated as an agent or a list of the agent to be captured   as (species): the species that the captured agent(s) will become, this is a micro-species of the calling agent s species   returns (a new identifier): a list of the newly captured agent(s)   Definition  Allows an agent to capture other agent(s) as its micro-agent(s).  Usages     The preliminary for an agent A to capture an agent B as its micro-agent is that the A s species must defined a micro-species which is a sub-species of B s species (cf. [Species161#Nesting_species Nesting species]).    species A { ... } species B { ...    species C parent: A {    ...    } ... }      To capture all  A  agents as  C  agents, we can ask an  B  agent to execute the following statement:    capture list(B) as: C;      Deprecated writing:    capture target: list (B) as: C;      See also: release,   Embedments    The capture statement is of type: Sequence of statements or action   The capture statement can be embedded into: Behavior, Sequence of statements or action,   The capture statement embeds statements:     ### chart  #### Facets     name (a label), (omissible) : the identifier of the chart layer   axes (rgb): the axis color   background (rgb): the background color   color (rgb): Text color   gap (float): minimum gap between bars (in proportion)   label_font (string): Label font face   label_font_size (int): Label font size   label_font_style (an identifier), takes values in: {plain, bold, italic}: the style used to display labels   legend_font (string): Legend font face   legend_font_size (int): Legend font size   legend_font_style (an identifier), takes values in: {plain, bold, italic}: the style used to display legend   memorize (boolean): Whether or not to keep the values in memory (in order to produce a csv file, for instance). The default value, true, can also be changed in the preferences   position (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.   reverse_axes (boolean): reverse X and Y axis (for example to get horizental bar charts   series_label_position (an identifier), takes values in: {default, none, legend, onchart, yaxis, xaxis}: Position of the Series names: default (best guess), none, legend, onchart, xaxis (for category plots) or yaxis (uses the first serie name).   size (point): the layer resize factor: {1,1} refers to the original size whereas {0.5,0.5} divides by 2 the height and the width of the layer. In case of a 3D layer, a 3D point can be used (note that {1,1} is equivalent to {1,1,0}, so a resize of a layer containing 3D objects with a 2D points will remove the elevation)   style (an identifier), takes values in: {line, whisker, area, bar, dot, step, spline, stack, 3d, ring, exploded, default}: The sub-style style, also default style for the series.   tick_font (string): Tick font face   tick_font_size (int): Tick font size   tick_font_style (an identifier), takes values in: {plain, bold, italic}: the style used to display ticks   title_font (string): Title font face   title_font_size (int): Title font size   title_font_style (an identifier), takes values in: {plain, bold, italic}: the style used to display titles   type (an identifier), takes values in: {xy, scatter, histogram, series, pie, radar, heatmap, box_whisker}: the type of chart. It could be histogram, series, xy, pie, radar, heatmap or box whisker. The difference between series and xy is that the former adds an implicit x-axis that refers to the numbers of cycles, while the latter considers the first declaration of data to be its x-axis.   x_label (string): the title for the X axis   x_range (any type in [float, int, point, list]): range of the x-axis. Can be a number (which will set the axis total range) or a point (which will set the min and max of the axis).   x_serie (any type in [list, float, int]): for series charts, change the default common x serie (simulation cycle) for an other value (list or numerical).   x_serie_labels (any type in [list, float, int, a label]): change the default common x series labels (replace x value or categories) for an other value (string or numerical).   x_tick_unit (float): the tick unit for the y-axis (distance between horyzontal lines and values on the left of the axis).   y_label (string): the title for the Y axis   y_range (any type in [float, int, point, list]): range of the y-axis. Can be a number (which will set the axis total range) or a point (which will set the min and max of the axis).   y_serie_labels (any type in [list, float, int, a label]): for heatmaps/3d charts, change the default y serie for an other value (string or numerical in a list or cumulative).   y_tick_unit (float): the tick unit for the x-axis (distance between vertical lines and values bellow the axis).   Definition  chart allows modeler to display a chart: this enables to display specific values of the model at each iteration. GAMA can display various chart types: time series (series), pie charts (pie) and histograms (histogram).  Usages     The general syntax is:    display chart_display {    chart chart name type: series [additional options] {       [Set of data, datalists statements]    } }      See also: display, agents, event, graphics, display_grid, image, overlay, quadtree, display_population, text,   Embedments    The chart statement is of type: Layer   The chart statement can be embedded into: display,   The chart statement embeds statements: add,  ask,  data,  datalist,  do,  put,  remove,  set,  simulate,  using,     ### conscious_contagion  #### Facets     emotion_created (546706): the emotion that will be created with the contagion   emotion_detected (546706): the emotion that will start the contagion   name (an identifier), (omissible) : the identifier of the unconscious contagion   charisma (float): The charisma value of the perceived agent (between 0 and 1)   receptivity (float): The receptivity value of the current agent (between 0 and 1)   threshold (float): The threshold value to make the contagion   when (boolean): A boolean value to get the emotion only with a certain condition   Definition  enables to directly add an emotion of a perceived specie if the perceived agent ges a patricular emotion.  Usages     Other examples of use:   conscious_contagion emotion_detected:fear emotion_created:fearConfirmed; conscious_contagion emotion_detected:fear emotion_created:fearConfirmed charisma: 0.5 receptivity: 0.5;    Embedments    The conscious_contagion statement is of type: Single statement   The conscious_contagion statement can be embedded into: Behavior, Sequence of statements or action,   The conscious_contagion statement embeds statements:     ### create  #### Facets     species (any type in [species, agent]), (omissible) : an expression that evaluates to a species, the species of the agents to be created. In the case of simulations, the name  simulation , which represents the current instance of simulation, can also be used as a proxy to their species   as (species):   from (any type): an expression that evaluates to a localized entity, a list of localized entities, a string (the path of a file), a file (shapefile, a .csv, a .asc or a OSM file) or a container returned by a request to a database   header (boolean): an expression that evaluates to a boolean, when creating agents from csv file, specify whether the file header is loaded   number (int): an expression that evaluates to an int, the number of created agents   returns (a new identifier): a new temporary variable name containing the list of created agents (a list, even if only one agent has been created)   with (map): an expression that evaluates to a map, for each pair the key is a species attribute and the value the assigned value   Definition  Allows an agent to create number agents of species species, to create agents of species species from a shapefile or to create agents of species species from one or several localized entities (discretization of the localized entity geometries).  Usages     Its simple syntax to create an_int agents of species a_species is:    create a_species number: an_int; create species_of(self) number: 5 returns: list5Agents; 5      In GAML modelers can create agents of species a_species  (with two attributes type and nature with types corresponding to the types of the shapefile attributes) from a shapefile the_shapefile  while reading attributes  TYPE_OCC  and  NATURE  of the shapefile. One agent will be created by object contained in the shapefile:    create a_species from: the_shapefile with: [type:: read( TYPE_OCC ), nature::read( NATURE )];      In order to create agents from a .csv file, facet header can be used to specified whether we can use columns header:    create toto from: toto.csv header: true with:[att1::read(NAME), att2::read(TYPE)]; or create toto from: toto.csv with:[att1::read(0), att2::read(1)]; //with read(int), the index of the column      Similarly to the creation from shapefile, modelers can create agents from a set of geometries. In this case, one agent per geometry will be created (with the geometry as shape)    create species_of(self) from: [square(4),circle(4)];  // 2 agents have been created, with shapes respectively square(4) and circle(4)      Created agents are initialized following the rules of their species. If one wants to refer to them after the statement is executed, the returns keyword has to be defined: the agents created will then be referred to by the temporary variable it declares. For instance, the following statement creates 0 to 4 agents of the same species as the sender, and puts them in the temporary variable children for later use.    create species (self) number: rnd (4) returns: children; ask children {  // ... }      If one wants to specify a special initialization sequence for the agents created, create provides the same possibilities as ask. This extended syntax is:    create a_species number: an_int {      [statements] }      The same rules as in ask apply. The only difference is that, for the agents created, the assignments of variables will bypass the initialization defined in species. For instance:    create species(self) number: rnd (4) returns: children {      set location <- myself.location + {rnd (2), rnd (2)}; // tells the children to be initially located close to me      set parent <- myself; // tells the children that their parent is me (provided the variable parent is declared in this species)  }      Desprecated uses:       // Simple syntax create species: a_species number: an_int;          If number equals 0 or species is not a species, the statement is ignored.   Embedments    The create statement is of type: Sequence of statements or action   The create statement can be embedded into: Behavior, Sequence of statements or action,   The create statement embeds statements:     ### data  #### Facets     legend (string), (omissible) :   value (any type in [float, point, list]):   accumulate_values (boolean): Force to replace values at each step (false) or accumulate with previous steps (true)   color (any type in [rgb, list]): color of the serie, for heatmap can be a list to specify [minColor,maxColor] or [minColor,medColor,maxColor]   fill (boolean): Marker filled (true) or not (false)   line_visible (boolean): Line visible or not   marker (boolean): marker visible or not   marker_shape (an identifier), takes values in: {marker_empty, marker_square, marker_circle, marker_up_triangle, marker_diamond, marker_hor_rectangle, marker_down_triangle, marker_hor_ellipse, marker_right_triangle, marker_vert_rectangle, marker_left_triangle}: Shape of the marker   marker_size (float): Size in pixels of the marker   style (an identifier), takes values in: {line, whisker, area, bar, dot, step, spline, stack, 3d, ring, exploded}: Style for the serie (if not the default one sepecified on chart statement)   thickness (float): The thickness of the lines to draw   x_err_values (any type in [float, list]): the X Error bar values to display. Has to be a List. Each element can be a number or a list with two values (low and high value)   y_err_values (any type in [float, list]): the Y Error bar values to display. Has to be a List. Each element can be a number or a list with two values (low and high value)   y_minmax_values (list): the Y MinMax bar values to display (BW charts). Has to be a List. Each element can be a number or a list with two values (low and high value)   Embedments    The data statement is of type: Single statement   The data statement can be embedded into: chart, Sequence of statements or action,   The data statement embeds statements:     ### datalist  #### Facets     value (list): the values to display. Has to be a matrix, a list or a List of List. Each element can be a number (series/histogram) or a list with two values (XY chart)   legend (list), (omissible) : the name of the series: a list of strings (can be a variable with dynamic names)   accumulate_values (boolean): Force to replace values at each step (false) or accumulate with previous steps (true)   color (list): list of colors, for heatmaps can be a list of [minColor,maxColor] or [minColor,medColor,maxColor]   fill (boolean): Marker filled (true) or not (false), same for all series.   line_visible (boolean): Line visible or not (same for all series)   marker (boolean): marker visible or not   marker_shape (an identifier), takes values in: {marker_empty, marker_square, marker_circle, marker_up_triangle, marker_diamond, marker_hor_rectangle, marker_down_triangle, marker_hor_ellipse, marker_right_triangle, marker_vert_rectangle, marker_left_triangle}: Shape of the marker. Same one for all series.   marker_size (list): the marker sizes to display. Can be a list of numbers (same size for each marker of the series) or a list of list (different sizes by point)   style (an identifier), takes values in: {line, whisker, area, bar, dot, step, spline, stack, 3d, ring, exploded}: Style for the serie (if not the default one sepecified on chart statement)   x_err_values (list): the X Error bar values to display. Has to be a List. Each element can be a number or a list with two values (low and high value)   y_err_values (list): the Y Error bar values to display. Has to be a List. Each element can be a number or a list with two values (low and high value)   y_minmax_values (list): the Y MinMax bar values to display (BW charts). Has to be a List. Each element can be a number or a list with two values (low and high value)   Embedments    The datalist statement is of type: Single statement   The datalist statement can be embedded into: chart, Sequence of statements or action,   The datalist statement embeds statements:     ### default  #### Facets     value (any type), (omissible) :   Definition  Used in a switch match structure, the block prefixed by default is executed only if no other block has matched (otherwise it is not).  Usages     See also: switch, match,   Embedments    The default statement is of type: Sequence of statements or action   The default statement can be embedded into: switch,   The default statement embeds statements:     ### diffuse  #### Facets     var (an identifier), (omissible) : the variable to be diffused   on (any type in [container, species]): the list of agents (in general cells of a grid), on which the diffusion will occur   avoid_mask (boolean): if true, the value will not be diffused in the masked cells, but will be restitute to the neighboring cells, multiplied by the proportion value (no signal lost). If false, the value will be diffused in the masked cells, but masked cells won t diffuse the value afterward (lost of signal). (default value : false)   cycle_length (int): the number of diffusion operation applied in one simulation step   mask (matrix): a matrix masking the diffusion (matrix created from a image for example). The cells corresponding to the values smaller than  -1  in the mask matrix will not diffuse, and the other will diffuse.   mat_diffu (matrix): the diffusion matrix (can have any size)   matrix (matrix): the diffusion matrix ( kernel  or  filter  in image processing). Can have any size, as long as dimensions are odd values.   method (an identifier), takes values in: {convolution, dot_product}: the diffusion method   min_value (float): if a value is smaller than this value, it will not be diffused. By default, this value is equal to 0.0. This value cannot be smaller than 0.   propagation (a label), takes values in: {diffusion, gradient}: represents both the way the signal is propagated and the way to treat multiple propagation of the same signal occurring at once from different places. If propagation equals  diffusion , the intensity of a signal is shared between its neighbors with respect to  proportion ,  variation  and the number of neighbors of the environment places (4, 6 or 8). I.e., for a given signal S propagated from place P, the value transmitted to its N neighbors is : S  = (S / N / proportion) - variation. The intensity of S is then diminished by S * proportion on P. In a diffusion, the different signals of the same name see their intensities added to each other on each place. If propagation equals  gradient , the original intensity is not modified, and each neighbors receives the intensity : S / proportion - variation. If multiple propagation occur at once, only the maximum intensity is kept on each place. If  propagation  is not defined, it is assumed that it is equal to  diffusion .   proportion (float): a diffusion rate   radius (int): a diffusion radius (in number of cells from the center)   variation (float): an absolute value to decrease at each neighbors   Definition  This statements allows a value to diffuse among a species on agents (generally on a grid) depending on a given diffusion matrix.  Usages     A basic example of diffusion of the variable phero defined in the species cells, given a diffusion matrix math_diff is:    matrix<float> math_diff <- matrix([[1/9,1/9,1/9],[1/9,1/9,1/9],[1/9,1/9,1/9]]); diffuse var: phero on: cells mat_diffu: math_diff;      The diffusion can be masked by obstacles, created from a bitmap image:    diffuse var: phero on: cells mat_diffu: math_diff mask: mymask;      A convenient way to have an uniform diffusion in a given radius is (which is equivalent to the above diffusion):    diffuse var: phero on: cells proportion: 1/9 radius: 1;   Embedments    The diffuse statement is of type: Single statement   The diffuse statement can be embedded into: Behavior, Sequence of statements or action,   The diffuse statement embeds statements:     ### display  #### Facets     name (a label), (omissible) : the identifier of the display   ambient_light (any type in [int, rgb]): Allows to define the value of the ambient light either using an int (ambient_light:(125)) or a rgb color ((ambient_light:rgb(255,255,255)). default is rgb(127,127,127,255)   autosave (any type in [boolean, point]): Allows to save this display on disk. A value of true/false will save it at a resolution of 500x500. A point can be passed to personalize these dimensions   background (rgb): Allows to fill the background of the display with a specific color   camera_interaction (boolean): If false, the user will not be able to modify the position and the orientation of the camera, and neither using the ROI. Default is true.   camera_lens (int): Allows to define the lens of the camera   camera_look_pos (point): Allows to define the direction of the camera   camera_pos (any type in [point, agent]): Allows to define the position of the camera   camera_up_vector (point): Allows to define the orientation of the camera   diffuse_light (any type in [int, rgb]): Allows to define the value of the diffuse light either using an int (diffuse_light:(125)) or a rgb color ((diffuse_light:rgb(255,255,255)). default is (127,127,127,255)   diffuse_light_pos (point): Allows to define the position of the diffuse light either using an point (diffuse_light_pos:{x,y,z}). default is {world.shape.width/2,world.shape.height/2,world.shape.width*2}   draw_diffuse_light (boolean): Allows to show/hide a representation of the lights. Default is false.   draw_env (boolean): Allows to enable/disable the drawing of the world shape and the ordinate axes. Default can be configured in Preferences   focus (geometry): the geometry (or agent) on which the display will (dynamically) focus   fullscreen (any type in [boolean, int]): Indicates, when using a boolean value, whether or not the display should cover the whole screen (default is false). If an integer is passed, specifies also the screen to use: 0 for the primary monitor, 1 for the secondary one, and so on and so forth. If the monitor is not available, the first one is used   keystone (container): Set the position of the 4 corners of your screen ([topLeft,topRight,botLeft,botRight]), in (x,y) coordinate ( the (0,0) position is the top left corner, while the (1,1) position is the bottom right corner). The default value is : [{0,0},{1,0},{0,1},{1,1}]   light (boolean): Allows to enable/disable the light. Default is true   orthographic_projection (boolean): Allows to enable/disable the orthographic projection. Default can be configured in Preferences   refresh (boolean): Indicates the condition under which this output should be refreshed (default is true)   refresh_every (int): Allows to refresh the display every n time steps (default is 1)   rotate (float): Set the angle for the rotation around the Z axis   scale (any type in [boolean, float]): Allows to display a scale bar in the overlay. Accepts true/false or an unit name   show_fps (boolean): Allows to enable/disable the drawing of the number of frames per second   synchronized (boolean): Indicates whether the display should be directly synchronized with the simulation   type (a label): Allows to use either Java2D (for planar models) or OpenGL (for 3D models) as the rendering subsystem   use_shader (boolean): Under construction…   z_fighting (boolean): Allows to alleviate a problem where agents at the same z would overlap each other in random ways   Definition  A display refers to a independent and mobile part of the interface that can display species, images, texts or charts.  Usages     The general syntax is:    display my_display [additional options] { ... }      Each display can include different layers (like in a GIS).    display gridWithElevationTriangulated type: opengl ambient_light: 100 {  grid cell elevation: true triangulation: true;  species people aspect: base; }   Embedments    The display statement is of type: Output   The display statement can be embedded into: output, permanent,   The display statement embeds statements: agents,  camera,  chart,  display_grid,  display_population,  event,  graphics,  image,  light,  overlay,     ### display_grid  #### Facets     species (species), (omissible) : the species of the agents in the grid   dem (matrix):   draw_as_dem (boolean):   elevation (any type in [matrix, float, int, boolean]): Allows to specify the elevation of each cell, if any. Can be a matrix of float (provided it has the same size than the grid), an int or float variable of the grid species, or simply true (in which case, the variable called  grid_value  is used to compute the elevation of each cell)   grayscale (boolean): if true, givse a grey value to each polygon depending on its elevation (false by default)   lines (rgb): the color to draw lines (borders of cells)   position (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.   refresh (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, usefull in case of agents that do not move)   selectable (boolean): Indicates whether the agents present on this layer are selectable by the user. Default is true   size (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in  position , an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions   text (boolean): specify whether the attribute used to compute the elevation is displayed on each cells (false by default)   texture (any type in [boolean, file]): Either file  containing the texture image to be applied on the grid or, if true, the use of the image composed by the colors of the cells. If false, no texture is applied   transparency (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency)   triangulation (boolean): specifies whther the cells will be triangulated: if it is false, they will be displayed as horizontal squares at a given elevation, whereas if it is true, cells will be triangulated and linked to neighbors in order to have a continuous surface (false by default)   Definition  display_grid is used using the grid keyword. It allows the modeler to display in an optimized way all cell agents of a grid (i.e. all agents of a species having a grid topology).  Usages     The general syntax is:    display my_display {    grid ant_grid lines: #black position: { 0.5, 0 } size: {0.5,0.5}; }      To display a grid as a DEM:    display my_display {     grid cell texture: texture_file text: false triangulation: true elevation: true; }      See also: display, agents, chart, event, graphics, image, overlay, display_population,   Embedments    The display_grid statement is of type: Layer   The display_grid statement can be embedded into: display,   The display_grid statement embeds statements:     ### display_population  #### Facets     species (species), (omissible) : the species to be displayed   aspect (an identifier): the name of the aspect that should be used to display the species   fading (boolean): Used in conjunction with  trace: , allows to apply a fading effect to the previous traces. Default is false   position (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.   refresh (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, usefull in case of agents that do not move)   selectable (boolean): Indicates whether the agents present on this layer are selectable by the user. Default is true   size (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in  position , an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions   trace (any type in [boolean, int]): Allows to aggregate the visualization of agents at each timestep on the display. Default is false. If set to an int value, only the last n-th steps will be visualized. If set to true, no limit of timesteps is applied.   transparency (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency)   Definition  The display_population statement is used using the species keyword. It allows modeler to display all the agent of a given species in the current display. In particular, modeler can choose the aspect used to display them.  Usages     The general syntax is:    display my_display {    species species_name [additional options]; }      Species can be superposed on the same plan (be careful with the order, the last one will be above all the others):    display my_display {    species agent1 aspect: base;    species agent2 aspect: base;    species agent3 aspect: base; }      Each species layer can be placed at a different z value using the opengl display. position:{0,0,0} means the layer will be placed on the ground and position:{0,0,1} means it will be placed at an height equal to the maximum size of the environment.    display my_display type: opengl{    species agent1 aspect: base ;    species agent2 aspect: base position:{0,0,0.5};    species agent3 aspect: base position:{0,0,1}; }      See also: display, agents, chart, event, graphics, display_grid, image, overlay,   Embedments    The display_population statement is of type: Layer   The display_population statement can be embedded into: display, display_population,   The display_population statement embeds statements: display_population,     ### do  #### Facets     action (an identifier), (omissible) : the name of an action or a primitive   internal_function (any type):   returns (a new identifier): create a new variable and assign to it the result of the action   with (map): a map expression containing the parameters of the action   Definition  Allows the agent to execute an action or a primitive.  For a list of primitives available in every species, see this [BuiltIn161 page]; for the list of primitives defined by the different skills, see this [Skills161 page]. Finally, see this [Species161 page] to know how to declare custom actions.  Usages     The simple syntax (when the action does not expect any argument and the result is not to be kept) is:    do name_of_action_or_primitive;      In case the action expects one or more arguments to be passed, they are defined by using facets (enclosed tags or a map are now deprecated):    do name_of_action_or_primitive arg1: expression1 arg2: expression2;      In case the result of the action needs to be made available to the agent, the action can be called with the agent calling the action (self when the agent itself calls the action) instead of do; the result should be assigned to a temporary variable:    type_returned_by_action result <- self name_of_action_or_primitive [];      In case of an action expecting arguments and returning a value, the following syntax is used:    type_returned_by_action result <- self name_of_action_or_primitive [arg1::expression1, arg2::expression2];      Deprecated uses: following uses of the do statement (still accepted) are now deprecated:       // Simple syntax:  do action: name_of_action_or_primitive;  // In case the result of the action needs to be made available to the agent, the returns keyword can be defined; the result will then be referred to by the temporary variable declared in this attribute: do name_of_action_or_primitive returns: result; do name_of_action_or_primitive arg1: expression1 arg2: expression2 returns: result; type_returned_by_action result <- name_of_action_or_primitive(self, [arg1::expression1, arg2::expression2]);  // In case the result of the action needs to be made available to the agent let result <- name_of_action_or_primitive(self, []);  // In case the action expects one or more arguments to be passed, they can also be defined by using enclosed arg statements, or the with facet with a map of parameters: do name_of_action_or_primitive with: [arg1::expression1, arg2::expression2];  or  do name_of_action_or_primitive {      arg arg1 value: expression1;      arg arg2 value: expression2;      … }      Embedments    The do statement is of type: Single statement   The do statement can be embedded into: chart, Behavior, Sequence of statements or action,   The do statement embeds statements:     ### draw  #### Facets     geometry (any type), (omissible) : any type of data (it can be geometry, image, text)   at (point): location where the shape/text/icon is drawn   begin_arrow (any type in [int, float]): the size of the arrow, located at the beginning of the drawn geometry   bitmap (boolean): Whether to render the text in 3D or not   border (any type in [rgb, boolean]): if used with a color, represents the color of the geometry border. If set to false, expresses that no border should be drawn. If not set, the borders will be drawn using the color of the geometry.   color (any type in [rgb, container]): the color to use to display the object. In case of images, will try to colorize it. You can also pass a list of colors : in that case, each color will be matched to its corresponding vertex.   depth (float): (only if the display type is opengl) Add an artificial depth to the geometry previously defined (a line becomes a plan, a circle becomes a cylinder, a square becomes a cube, a polygon becomes a polyhedron with height equal to the depth value). Note: This only works if the geometry is not a point   empty (boolean): a condition specifying whether the geometry is empty or full   end_arrow (any type in [int, float]): the size of the arrow, located at the end of the drawn geometry   font (any type in [19, string]): the font used to draw the text, if any. Applying this facet to geometries or images has no effect. You can construct here your font with the operator  font . ex : font:font( Helvetica , 20 , #plain)   material (25): Set a particular material to the object (only if you are in the  use_shader  mode).   perspective (boolean): Whether to render the text in perspective or facing the user. Default is true.   rotate (any type in [float, int, pair]): orientation of the shape/text/icon; can be either an int/float (angle) or a pair float::point (angle::rotation axis). The rotation axis, when expressed as an angle, is by defaut {0,0,1}   rounded (boolean): specify whether the geometry have to be rounded (e.g. for squares)   size (any type in [float, point]): size of the object to draw, expressed as a bounding box (width, height, depth). If expressed as a float, represents the size in the three directions.   texture (any type in [string, list, file]): the texture(s) that should be applied to the geometry. Either a path to a file or a list of paths   width (float): The line width to use for drawing this object   Definition  draw is used in an aspect block to express how agents of the species will be drawn. It is evaluated each time the agent has to be drawn. It can also be used in the graphics block.  Usages     Any kind of geometry as any location can be drawn when displaying an agent (independently of his shape)    aspect geometryAspect {  draw circle(1.0) empty: !hasFood color: #orange ; }      Image or text can also be drawn    aspect arrowAspect {  draw Current state= +state at: location + {-3,1.5} color: #white font: font( Default , 12, #bold) ;  draw file(ant_shape_full) rotate: heading at: location size: 5 }      Arrows can be drawn with any kind of geometry, using begin_arrow and end_arrow facets, combined with the empty: facet to specify whether it is plain or empty    aspect arrowAspect {  draw line([{20, 20}, {40, 40}]) color: #black begin_arrow:5;  draw line([{10, 10},{20, 50}, {40, 70}]) color: #green end_arrow: 2 begin_arrow: 2 empty: true;  draw square(10) at: {80,20} color: #purple begin_arrow: 2 empty: true; }   Embedments    The draw statement is of type: Single statement   The draw statement can be embedded into: aspect, Sequence of statements or action, Layer,   The draw statement embeds statements:     ### else  #### Facets  Definition  This statement cannot be used alone  Usages     See also: if,   Embedments    The else statement is of type: Sequence of statements or action   The else statement can be embedded into: if,   The else statement embeds statements:     ### emotional_contagion  #### Facets     emotion_detected (546706): the emotion that will start the contagion   name (an identifier), (omissible) : the identifier of the emotional contagion   charisma (float): The charisma value of the perceived agent (between 0 and 1)   emotion_created (546706): the emotion that will be created with the contagion   receptivity (float): The receptivity value of the current agent (between 0 and 1)   threshold (float): The threshold value to make the contagion   when (boolean): A boolean value to get the emotion only with a certain condition   Definition  enables to make conscious or unconscious emotional contagion  Usages     Other examples of use:   emotional_contagion emotion_detected:fearConfirmed; emotional_contagion emotion_detected:fear emotion_created:fearConfirmed; emotional_contagion emotion_detected:fear emotion_created:fearConfirmed charisma: 0.5 receptivity: 0.5;    Embedments    The emotional_contagion statement is of type: Single statement   The emotional_contagion statement can be embedded into: Behavior, Sequence of statements or action,   The emotional_contagion statement embeds statements:     ### enter  #### Facets  Definition  In an FSM architecture, enter introduces a sequence of statements to execute upon entering a state.  Usages     In the following example, at the step it enters into the state s_init, the message  Enter in s_init  is displayed followed by the display of the state name:     state s_init {   enter { write Enter in + state; }    write Enter in + state;   }   write state;  }      See also: state, exit, transition,   Embedments    The enter statement is of type: Sequence of statements or action   The enter statement can be embedded into: state,   The enter statement embeds statements:     ### equation  #### Facets     name (an identifier), (omissible) : the equation identifier   params (list): the list of parameters used in predefined equation systems   simultaneously (list): a list of species containing a system of equations (all systems will be solved simultaneously)   type (an identifier), takes values in: {SI, SIS, SIR, SIRS, SEIR, LV}: the choice of one among classical models (SI, SIS, SIR, SIRS, SEIR, LV)   vars (list): the list of variables used in predefined equation systems   Definition  The equation statement is used to create an equation system from several single equations.  Usages     The basic syntax to define an equation system is:    float t; float S; float I; equation SI {     diff(S,t) = (- 0.3 * S * I / 100);    diff(I,t) = (0.3 * S * I / 100); }       If the type: facet is used, a predefined equation system is defined using variables vars: and parameters params: in the right order. All possible predefined equation systems are the following ones (see [EquationPresentation161 EquationPresentation161] for precise definition of each classical equation system):    equation eqSI type: SI vars: [S,I,t] params: [N,beta]; equation eqSIS type: SIS vars: [S,I,t] params: [N,beta,gamma]; equation eqSIR type:SIR vars:[S,I,R,t] params:[N,beta,gamma]; equation eqSIRS type: SIRS vars: [S,I,R,t] params: [N,beta,gamma,omega,mu]; equation eqSEIR type: SEIR vars: [S,E,I,R,t] params: [N,beta,gamma,sigma,mu]; equation eqLV type: LV vars: [x,y,t] params: [alpha,beta,delta,gamma] ;      If the simultaneously: facet is used, system of all the agents will be solved simultaneously.   See also: =, solve,   Embedments    The equation statement is of type: Sequence of statements or action   The equation statement can be embedded into: Species, Model,   The equation statement embeds statements: =,     ### error  #### Facets     message (string), (omissible) : the message to display in the error.   Definition  The statement makes the agent output an error dialog (if the simulation contains a user interface). Otherwise displays the error in the console.  Usages     Throwing an error    error  This is an error raised by   + self;   Embedments    The error statement is of type: Single statement   The error statement can be embedded into: Behavior, Sequence of statements or action, Layer,   The error statement embeds statements:     ### event  #### Facets     name (an identifier), (omissible) : the type of event captured: can be   mouse_up ,  mouse_down ,  mouse_move ,  mouse_exit ,  mouse_enter  or a character   action (26): Either a block of statements to execute in the context of the simulation or the identifier of the action to be executed. This action needs to be defined in  global  or in the current experiment, without any arguments. The location of the mouse in the world can be retrieved in this action with the pseudo-constant #user_location   unused (an identifier), takes values in: {mouse_up, mouse_down, mouse_move, mouse_enter, mouse_exit}: an unused facet that serves only for the purpose of declaring the string values   Definition  event allows to interact with the simulation by capturing mouse or key events and doing an action. This action needs to be defined in  global  or in the current experiment, without any arguments. The location of the mouse in the world can be retrieved in this action with the pseudo-constant #user_location  Usages     The general syntax is:    event [event_type] action: myAction;      For instance:       global {    // …     action myAction () {       point loc <- #user_location; // contains the location of the mouse in the world       list selected_agents <- agents inside (10#m around loc); // contains agents clicked by the event    // code written by modelers    } }   experiment Simple type:gui {    display my_display {       event mouse_up action: myAction;    } }         See also: display, agents, chart, graphics, display_grid, image, overlay, display_population,   Embedments    The event statement is of type: Layer   The event statement can be embedded into: display,   The event statement embeds statements:     ### exhaustive  #### Facets     name (an identifier), (omissible) :   aggregation (a label), takes values in: {min, max}: the agregation method   maximize (float): the value the algorithm tries to maximize   minimize (float): the value the algorithm tries to minimize   Definition  This is the standard batch method. The exhaustive mode is defined by default when there is no method element present in the batch section. It explores all the combination of parameter values in a sequential way. See [batch161 the batch dedicated page].  Usages     As other batch methods, the basic syntax of the exhaustive statement uses method exhaustive instead of the expected exhaustive name: id :    method exhaustive [facet: value];      For example:    method exhaustive maximize: food_gathered;   Embedments    The exhaustive statement is of type: Batch method   The exhaustive statement can be embedded into: Experiment,   The exhaustive statement embeds statements:     ### exit  #### Facets  Definition  In an FSM architecture, exit introduces a sequence of statements to execute right before exiting the state.  Usages     In the following example, at the state it leaves the state s_init, he will display the message  EXIT from s_init :     state s_init initial: true {   write state;   transition to: s1 when: (cycle > 2) {    write transition s_init -> s1;   }   exit {    write EXIT from +state;   }  }      See also: enter, state, transition,   Embedments    The exit statement is of type: Sequence of statements or action   The exit statement can be embedded into: state,   The exit statement embeds statements:     ### experiment  #### Facets     name (a label), (omissible) : identifier of the experiment   title (a label):   type (a label), takes values in: {batch, memorize, gui, headless}: the type of the experiment (either  gui  or  batch    control (an identifier):   frequency (int): the execution frequence of the experiment (default value: 1). If frequency: 10, the experiment is executed only each 10 steps.   keep_seed (boolean):   keep_simulations (boolean): In the case of a batch experiment, specifies whether or not the simulations should be kept in memory for further analysis or immediately discarded with only their fitness kept in memory   parallel (any type in [boolean, int]): When set to true, use multiple threads to run its simulations. Setting it to n will set the numbers of threads to use   parent (an identifier): the parent experiment (in case of inheritance between experiments)   repeat (int): In the case of a batch experiment, expresses hom many times the simulations must be repeated   schedules (container): A container of agents (a species, a dynamic list, or a combination of species and containers) , which represents which agents will be actually scheduled when the population is scheduled for execution. For instance,  species a schedules: (10 among a)  will result in a population that schedules only 10 of its own agents every cycle.  species b schedules: []  will prevent the agents of  b  to be scheduled. Note that the scope of agents covered here can be larger than the population, which allows to build complex scheduling controls; for instance, defining  global schedules: [] {…} species b schedules: []; species c schedules: b + world;   allows to simulate a model where the agents of b are scheduled first, followed by the world, without even having to create an instance of c.   skills (list):   until (boolean): In the case of a batch experiment, an expression that will be evaluated to know when a simulation should be terminated   Embedments    The experiment statement is of type: Experiment   The experiment statement can be embedded into: Model,   The experiment statement embeds statements:     ### export  #### Facets     var (an identifier), (omissible) :   framerate (int):   name (string):   Embedments    The export statement is of type: Single statement   The export statement can be embedded into: Experiment,   The export statement embeds statements:     ### focus  #### Facets     name (an identifier), (omissible) : the identifier of the focus   agent_cause (agent): the agentCause value of the created belief (can be nil   expression (any type): an expression that will be the value kept in the belief   lifetime (int): the lifetime value of the created belief   priority (any type in [float, int]): The priority of the created predicate   truth (boolean): the truth value of the created belief   var (any type in [any type, list, container]): the variable of the perceived agent you want to add to your beliefs   when (boolean): A boolean value to focus only with a certain condition   Definition  enables to directly add a belief from the variable of a perceived specie.  Usages     Other examples of use:   focus var:speed /*where speed is a variable from a species that is being perceived*/    Embedments    The focus statement is of type: Single statement   The focus statement can be embedded into: Behavior, Sequence of statements or action,   The focus statement embeds statements:     ### focus_on  #### Facets     value (any type), (omissible) : The agent, list of agents, geometry to focus on   Definition  Allows to focus on the passed parameter in all available displays. Passing  nil  for the parameter will make all screens return to their normal zoom  Usages     Focuses on an agent, a geometry, a set of agents, etc…)    focus_on my_species(0);   Embedments    The focus_on statement is of type: Single statement   The focus_on statement can be embedded into: Behavior, Sequence of statements or action, Layer,   The focus_on statement embeds statements:     ### genetic  #### Facets     name (an identifier), (omissible) :   aggregation (a label), takes values in: {min, max}: the agregation method   crossover_prob (float): crossover probability between two individual solutions   max_gen (int): number of generations   maximize (float): the value the algorithm tries to maximize   minimize (float): the value the algorithm tries to minimize   mutation_prob (float): mutation probability for an individual solution   nb_prelim_gen (int): number of random populations used to build the initial population   pop_dim (int): size of the population (number of individual solutions)   Definition  This is a simple implementation of Genetic Algorithms (GA). See the wikipedia article and [batch161 the batch dedicated page]. The principle of the GA is to search an optimal solution by applying evolution operators on an initial population of solutions. There are three types of evolution operators: crossover, mutation and selection. Different techniques can be applied for this selection. Most of them are based on the solution quality (fitness).  Usages     As other batch methods, the basic syntax of the genetic statement uses method genetic instead of the expected genetic name: id :    method genetic [facet: value];      For example:    method genetic maximize: food_gathered pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 20;    Embedments    The genetic statement is of type: Batch method   The genetic statement can be embedded into: Experiment,   The genetic statement embeds statements:     ### graphics  #### Facets     name (a label), (omissible) : the human readable title of the graphics   fading (boolean): Used in conjunction with  trace: , allows to apply a fading effect to the previous traces. Default is false   position (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.   refresh (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, usefull in case of agents that do not move)   size (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in  position , an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions   trace (any type in [boolean, int]): Allows to aggregate the visualization at each timestep on the display. Default is false. If set to an int value, only the last n-th steps will be visualized. If set to true, no limit of timesteps is applied.   transparency (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency)   Definition  graphics allows the modeler to freely draw shapes/geometries/texts without having to define a species. It works exactly like a species [Aspect161 aspect]: the draw statement can be used in the same way.  Usages     The general syntax is:    display my_display {    graphics my new layer {       draw circle(5) at: {10,10} color: #red;       draw test at: {10,10} size: 20 color: #black;    } }      See also: display, agents, chart, event, graphics, display_grid, image, overlay, display_population,   Embedments    The graphics statement is of type: Layer   The graphics statement can be embedded into: display,   The graphics statement embeds statements:     ### highlight  #### Facets     value (agent), (omissible) : The agent to hightlight   color (rgb): An optional color to highlight the agent. Note that this color will become the default color for further higlight operations   Definition  Allows to highlight the agent passed in parameter in all available displays, optionaly setting a color. Passing  nil  for the agent will remove the current highlight  Usages     Highlighting an agent    highlight my_species(0) color: #blue;   Embedments    The highlight statement is of type: Single statement   The highlight statement can be embedded into: Behavior, Sequence of statements or action, Layer,   The highlight statement embeds statements:     ### hill_climbing  #### Facets     name (an identifier), (omissible) :   aggregation (a label), takes values in: {min, max}: the agregation method   iter_max (int): number of iterations   maximize (float): the value the algorithm tries to maximize   minimize (float): the value the algorithm tries to minimize   Definition  This algorithm is an implementation of the Hill Climbing algorithm. See the wikipedia article and [batch161 the batch dedicated page].  Usages     As other batch methods, the basic syntax of the hill_climbing statement uses method hill_climbing instead of the expected hill_climbing name: id :    method hill_climbing [facet: value];      For example:    method hill_climbing iter_max: 50 maximize : food_gathered;    Embedments    The hill_climbing statement is of type: Batch method   The hill_climbing statement can be embedded into: Experiment,   The hill_climbing statement embeds statements:     ### if  #### Facets     condition (boolean), (omissible) : A boolean expression: the condition that is evaluated.   Definition  Allows the agent to execute a sequence of statements if and only if the condition evaluates to true.  Usages     The generic syntax is:    if bool_expr {     [statements] }      Optionally, the statements to execute when the condition evaluates to false can be defined in a following statement else. The syntax then becomes:    if bool_expr {     [statements] } else {     [statements] } string valTrue <- ; if true {  valTrue <- true; } else {  valTrue <- false; }   // valTrue equals true string valFalse <- ; if false {  valFalse <- true; } else {  valFalse <- false; }   // valFalse equals false      ifs and elses can be imbricated as needed. For instance:    if bool_expr {     [statements] } else if bool_expr2 {     [statements] } else {     [statements] }   Embedments    The if statement is of type: Sequence of statements or action   The if statement can be embedded into: Behavior, Sequence of statements or action, Layer,   The if statement embeds statements: else,     ### image  #### Facets     name (any type in [string, file]), (omissible) : Human readable title of the image layer   color (rgb): in the case of a shapefile, this the color used to fill in geometries of the shapefile   file (any type in [string, file]): the name/path of the image (in the case of a raster image)   gis (any type in [file, string]): the name/path of the shape file (to display a shapefile as background, without creating agents from it)   position (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.   refresh (boolean): (openGL only) specify whether the image display is refreshed. (true by default, usefull in case of images that is not modified over the simulation)   size (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in  position , an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions   transparency (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency)   Definition  image allows modeler to display an image (e.g. as background of a simulation).  Usages     The general syntax is:    display my_display {    image layer_name file: image_file [additional options]; }      For instance, in the case of a bitmap image    display my_display {    image background file:../images/my_backgound.jpg; }      Or in the case of a shapefile:    display my_display {    image testGIS gis: ../includes/building.shp color: rgb( blue ); }      It is also possible to superpose images on different layers in the same way as for species using opengl display:    display my_display {   image image1 file:../images/image1.jpg;   image image2 file:../images/image2.jpg;   image image3 file:../images/image3.jpg position: {0,0,0.5}; }      See also: display, agents, chart, event, graphics, display_grid, overlay, display_population,   Embedments    The image statement is of type: Layer   The image statement can be embedded into: display,   The image statement embeds statements:     ### inspect  #### Facets     name (any type), (omissible) : the identifier of the inspector   attributes (list): the list of attributes to inspect   refresh (boolean): Indicates the condition under which this output should be refreshed (default is true)   refresh_every (int): Allows to refresh the inspector every n time steps (default is 1)   type (an identifier), takes values in: {agent, table}: the way to inspect agents: in a table, or a set of inspectors   value (any type): the set of agents to inspect, could be a species, a list of agents or an agent   Definition  inspect (and browse) statements allows modeler to inspect a set of agents, in a table with agents and all their attributes or an agent inspector per agent, depending on the type: chosen. Modeler can choose which attributes to display. When browse is used, type: default value is table, whereas wheninspect is used, type: default value is agent.  Usages     An example of syntax is:    inspect my_inspector value: ant attributes: [name, location];   Embedments    The inspect statement is of type: Output   The inspect statement can be embedded into: output, permanent, Behavior, Sequence of statements or action,   The inspect statement embeds statements:     ### let  #### Facets     name (a new identifier), (omissible) :   index (a datatype identifier):   of (a datatype identifier):   type (a datatype identifier):   value (any type):   Embedments    The let statement is of type: Single statement   The let statement can be embedded into: Behavior, Sequence of statements or action, Layer,   The let statement embeds statements:     ### light  #### Facets     id (int), (omissible) : a number from 1 to 7 to specify which light we are using   active (boolean): a boolean expression telling if you want this light to be switch on or not. (default value : true)   color (any type in [int, rgb]): an int / rgb / rgba value to specify the color and the intensity of the light. (default value : (127,127,127,255) ).   direction (point): the direction of the light (only for direction and spot light). (default value : {0.5,0.5,-1})   draw_light (boolean): draw or not the light. (default value : false).   linear_attenuation (float): the linear attenuation of the positionnal light. (default value : 0)   position (point): the position of the light (only for point and spot light). (default value : {0,0,1})   quadratic_attenuation (float): the linear attenuation of the positionnal light. (default value : 0)   spot_angle (float): the angle of the spot light in degree (only for spot light). (default value : 45)   type (a label): the type of light to create. A value among {point, direction, spot}. (default value : direction)   update (boolean): specify if the light has to be updated. (default value : true).   Definition  light allows to define diffusion lights in your 3D display.  Usages     The general syntax is:    light 1 type:point position:{20,20,20} color:255, linear_attenuation:0.01 quadratic_attenuation:0.0001 draw_light:true update:false light 2 type:spot position:{20,20,20} direction:{0,0,-1} color:255 spot_angle:25 linear_attenuation:0.01 quadratic_attenuation:0.0001 draw_light:true update:false light 3 type:point direction:{1,1,-1} color:255 draw_light:true update:false      See also: display,   Embedments    The light statement is of type: Layer   The light statement can be embedded into: display,   The light statement embeds statements:     ### loop  #### Facets     name (a new identifier), (omissible) : a temporary variable name   from (int): an int expression   over (any type in [container, point]): a list, point, matrix or map expression   step (int): an int expression   times (int): an int expression   to (int): an int expression   while (boolean): a boolean expression   Definition  Allows the agent to perform the same set of statements either a fixed number of times, or while a condition is true, or by progressing in a collection of elements or along an interval of integers. Be aware that there are no prevention of infinite loops. As a consequence, open loops should be used with caution, as one agent may block the execution of the whole model.  Usages     The basic syntax for repeating a fixed number of times a set of statements is:    loop times: an_int_expression {      // [statements] }      The basic syntax for repeating a set of statements while a condition holds is:    loop while: a_bool_expression {      // [statements] }      The basic syntax for repeating a set of statements by progressing over a container of a point is:    loop a_temp_var over: a_collection_expression {      // [statements] }      The basic syntax for repeating a set of statements while an index iterates over a range of values with a fixed step of 1 is:    loop a_temp_var from: int_expression_1 to: int_expression_2 {      // [statements] }      The incrementation step of the index can also be chosen:    loop a_temp_var from: int_expression_1 to: int_expression_2 step: int_expression3 {      // [statements] }      In these latter three cases, the name facet designates the name of a temporary variable, whose scope is the loop, and that takes, in turn, the value of each of the element of the list (or each value in the interval). For example, in the first instance of the  loop over  syntax :    int a <- 0; loop i over: [10, 20, 30] {      a <- a + i; } // a now equals 60      The second (quite common) case of the loop syntax allows one to use an interval of integers. The from and to facets take an integer expression as arguments, with the first (resp. the last) specifying the beginning (resp. end) of the inclusive interval (i.e. [to, from]). If the step is not defined, it is assumed to be equal to 1 or -1, depending on the direction of the range. If it is defined, its sign will be respected, so that a positive step will never allow the loop to enter a loop from i to j where i is greater than j    list the_list <-list (species_of (self)); loop i from: 0 to: length (the_list) - 1 {      ask the_list at i {  // ...      } } // every  agent of the list is asked to do something   Embedments    The loop statement is of type: Sequence of statements or action   The loop statement can be embedded into: Behavior, Sequence of statements or action, Layer,   The loop statement embeds statements:     ### match  #### Facets     value (any type), (omissible) :   Definition  In a switch…match structure, the value of each match block is compared to the value in the switch. If they match, the embedded statement set is executed. Three kinds of match can be used  Usages     match block is executed if the switch value is equals to the value of the match:    switch 3 {    match 1 {write Match 1; }    match 3 {write Match 2; } }      match_between block is executed if the switch value is in the interval given in value of the match_between:    switch 3 {    match_between [1,2] {write Match OK between [1,2]; }    match_between [2,5] {write Match OK between [2,5]; } }      match_one block is executed if the switch value is equals to one of the values of the match_one:    switch 3 {    match_one [0,1,2] {write Match OK with one of [0,1,2]; }    match_between [2,3,4,5] {write Match OK with one of [2,3,4,5]; } }      See also: switch, default,   Embedments    The match statement is of type: Sequence of statements or action   The match statement can be embedded into: switch,   The match statement embeds statements:     ### migrate  #### Facets     source (any type in [agent, species, container, an identifier]), (omissible) : can be an agent, a list of agents, a agent s population to be migrated   target (species): target species/population that source agent(s) migrate to.   returns (a new identifier): the list of returned agents in a new local variable   Definition  This command permits agents to migrate from one population/species to another population/species and stay in the same host after the migration. Species of source agents and target species respect the following constraints: (i) they are  peer  species (sharing the same direct macro-species), (ii) they have sub-species vs. parent-species relationship.  Usages     It can be used in a 3-levels model, in case where individual agents can be captured into group meso agents and groups into clouds macro agents. migrate is used to allows agents captured by groups to migrate into clouds. See the model  Balls, Groups and Clouds.gaml  in the library.    migrate ball_in_group target: ball_in_cloud;      See also: capture, release,   Embedments    The migrate statement is of type: Sequence of statements or action   The migrate statement can be embedded into: Behavior, Sequence of statements or action,   The migrate statement embeds statements:     ### monitor  #### Facets     name (a label), (omissible) : identifier of the monitor   value (any type): expression that will be evaluated to be displayed in the monitor   color (rgb): Indicates the (possibly dynamic) color of this output (default is a light gray)   refresh (boolean): Indicates the condition under which this output should be refreshed (default is true)   refresh_every (int): Allows to refresh the monitor every n time steps (default is 1)   Definition  A monitor allows to follow the value of an arbitrary expression in GAML.  Usages     An example of use is:    monitor nb preys value: length(prey as list) refresh_every: 5;     Embedments    The monitor statement is of type: Output   The monitor statement can be embedded into: output, permanent,   The monitor statement embeds statements:     ### output  #### Facets  Definition  output blocks define how to visualize a simulation (with one or more display blocks that define separate windows). It will include a set of displays, monitors and files statements. It will be taken into account only if the experiment type is gui.  Usages     Its basic syntax is:    experiment exp_name type: gui {    // [inputs]    output {       // [display, file, inspect, layout or monitor statements]    } }      See also: display, monitor, inspect, output_file, layout,   Embedments    The output statement is of type: Output   The output statement can be embedded into: Model, Experiment,   The output statement embeds statements: display,  inspect,  monitor,  output_file,     ### output_file  #### Facets     name (an identifier), (omissible) : The name of the file where you want to export the data   data (string): The data you want to export   footer (string): Define a footer for your export file   header (string): Define a header for your export file   refresh (boolean): Indicates the condition under which this file should be saved (default is true)   refresh_every (int): Allows to save the file every n time steps (default is 1)   rewrite (boolean): Rewrite or not the existing file   type (an identifier), takes values in: {csv, text, xml}: The type of your output data   Embedments    The output_file statement is of type: Output   The output_file statement can be embedded into: output, permanent,   The output_file statement embeds statements:     ### overlay  #### Facets     background (rgb): the background color of the overlay displayed inside the view (the bottom overlay remains black)   border (rgb): Color to apply to the border of the rectangular shape of the overlay. Nil by default   center (any type): an expression that will be evaluated and displayed in the center section of the bottom overlay   color (any type in [list, rgb]): the color(s) used to display the expressions given in the  left ,  center  and  right  facets   left (any type): an expression that will be evaluated and displayed in the left section of the bottom overlay   position (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.   right (any type): an expression that will be evaluated and displayed in the right section of the bottom overlay   rounded (boolean): Whether or not the rectangular shape of the overlay should be rounded. True by default   size (point): extent of the layer in the view from its position. Coordinates in [0,1[ are treated as percentages of the total surface of the view, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Unlike   position , no elevation can be provided with the z coordinate   transparency (float): the transparency rate of the overlay (between 0 and 1, 1 means no transparency) when it is displayed inside the view. The bottom overlay will remain at 0.75   Definition  overlay allows the modeler to display a line to the already existing bottom overlay, where the results of  left ,  center  and  right  facets, when they are defined, are displayed with the corresponding color if defined.  Usages     To display information in the bottom overlay, the syntax is:    overlay Cycle:  + (cycle) center: Duration:  + total_duration + ms right: Model time:  + as_date(time,) color: [#yellow, #orange, #yellow];      See also: display, agents, chart, event, graphics, display_grid, image, display_population,   Embedments    The overlay statement is of type: Layer   The overlay statement can be embedded into: display,   The overlay statement embeds statements:     ### parameter  #### Facets     var (an identifier): the name of the variable (that should be declared in the global)   name (a label), (omissible) : The message displayed in the interface   among (list): the list of possible values   category (a label): a category label, used to group parameters in the interface   init (any type): the init value   max (any type): the maximum value   min (any type): the minimum value   on_change (any type): Provides a block of statements that will be executed whenever the value of the parameter changes   slider (boolean): Whether or not to display a slider for entering an int or float value. Default is true when max and min values are defined, false otherwise. If no max or min value is defined, setting this facet to true will have no effect   step (float): the increment step (mainly used in batch mode to express the variation step between simulation)   type (a datatype identifier): the variable type   unit (a label): the variable unit   Definition  The parameter statement specifies which global attributes (i) will change through the successive simulations (in batch experiments), (ii) can be modified by user via the interface (in gui experiments). In GUI experiments, parameters are displayed depending on their type.  Usages     In gui experiment, the general syntax is the following:    parameter title var: global_var category: cat;      In batch experiment, the two following syntaxes can be used to describe the possible values of a parameter:    parameter  Value of toto:  var: toto among: [1, 3, 7, 15, 100];  parameter  Value of titi:  var: titi min: 1 max: 100 step: 2;    Embedments    The parameter statement is of type: Parameter   The parameter statement can be embedded into: Experiment,   The parameter statement embeds statements:     ### perceive  #### Facets     target (any type in [container, point, agent]): the list of the agent you want to perceive   name (an identifier), (omissible) : the name of the perception   as (species): an expression that evaluates to a species   emotion (546706): The emotion needed to do the perception   in (any type in [float, geometry]): a float or a geometry. If it is a float, it s a radius of a detection area. If it is a geometry, it is the area of detection of others species.   parallel (any type in [boolean, int]): setting this facet to  true  will allow  perceive  to use concurrency with a parallel_bdi architecture; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet is true by default.   threshold (float): Threshold linked to the emotion.   when (boolean): a boolean to tell when does the perceive is active   Definition  Allow the agent, with a bdi architecture, to perceive others agents  Usages     the basic syntax to perceive agents inside a circle of perception    perceive name_of-perception target: the_agents_you_want_to_perceive in: a_distance when: a_certain_condition { Here you are in the context of the perceived agents. To refer to the agent who does the perception, use myself. If you want to make an action (such as adding a belief for example), use ask myself{ do the_action} }   Embedments    The perceive statement is of type: Sequence of statements or action   The perceive statement can be embedded into: Species, Model,   The perceive statement embeds statements:     ### permanent  #### Facets     layout (int), (omissible) : Either #none, to indicate that no layout will be imposed, or one of the four possible predefined layouts: #stack, #split, #horizontal or #vertical. This layout will be applied to both experiment and simulation display views   Definition  Represents the outputs of the experiment itself. In a batch experiment, the permanent section allows to define an output block that will NOT be re-initialized at the beginning of each simulation but will be filled at the end of each simulation.  Usages     For instance, this permanent section will allow to display for each simulation the end value of the food_gathered variable:    permanent {  display Ants background: rgb( white ) refresh_every: 1 {   chart Food Gathered type: series {    data Food value: food_gathered;   }  } }   Embedments    The permanent statement is of type: Output   The permanent statement can be embedded into: Experiment,   The permanent statement embeds statements: display,  inspect,  monitor,  output_file,     ### plan  #### Facets     name (an identifier), (omissible) :   emotion (546706):   finished_when (boolean):   instantaneous (boolean):   intention (546704):   priority (float):   threshold (float):   when (boolean):   Embedments    The plan statement is of type: Behavior   The plan statement can be embedded into: Species, Model,   The plan statement embeds statements:     ### put  #### Facets     in (any type in [container, species, agent, geometry]): an expression that evaluates to a container   item (any type), (omissible) : any expression   all (any type): any expression   at (any type): any expression   edge (any type): Indicates that the item to put should be considered as an edge of the receiving graph. Soon to be deprecated, use  put edge(item)…  instead   key (any type): any expression   weight (float): an expression that evaluates to a float   Definition  Allows the agent to replace a value in a container at a given position (in a list or a map) or for a given key (in a map). Note that the behavior and the type of the attributes depends on the specific kind of container.  Usages     The allowed parameters configurations are the following ones:    put expr at: expr in: expr_container; put all: expr in: expr_container;      In the case of a list, the position should an integer in the bound of the list. The facet all: is used to replace all the elements of the list by the given value.    list<int> putList <- [1,2,3,4,5];  // putList equals [1,2,3,4,5] put -10 at: 1 in: putList;  // putList equals [1,-10,3,4,5] put 10 all: true in: putList;  // putList equals [10,10,10,10,10]      In the case of a matrix, the position should be a point in the bound of the matrix. The facet all: is used to replace all the elements of the matrix by the given value.    matrix<int> putMatrix <- matrix([[0,1],[2,3]]);  // putMatrix equals matrix([[0,1],[2,3]]) put -10 at: {1,1} in: putMatrix;  // putMatrix equals matrix([[0,1],[2,-10]]) put 10 all: true in: putMatrix;  // putMatrix equals matrix([[10,10],[10,10]])      In the case of a map, the position should be one of the key values of the map. Notice that if the given key value does not exist in the map, the given pair key::value will be added to the map. The facet all is used to replace the value of all the pairs of the map.    map<string,int> putMap <- [x::4,y::7];  // putMap equals [x::4,y::7] put -10 key: y in: putMap;  // putMap equals [x::4,y::-10] put -20 key: z in: putMap;  // putMap equals [x::4,y::-10, z::-20] put -30 all: true in: putMap;  // putMap equals [x::-30,y::-30, z::-30]   Embedments    The put statement is of type: Single statement   The put statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer,   The put statement embeds statements:     ### reactive_tabu  #### Facets     name (an identifier), (omissible) :   aggregation (a label), takes values in: {min, max}: the agregation method   cycle_size_max (int): minimal size of the considered cycles   cycle_size_min (int): maximal size of the considered cycles   iter_max (int): number of iterations   maximize (float): the value the algorithm tries to maximize   minimize (float): the value the algorithm tries to minimize   nb_tests_wthout_col_max (int): number of movements without collision before shortening the tabu list   tabu_list_size_init (int): initial size of the tabu list   tabu_list_size_max (int): maximal size of the tabu list   tabu_list_size_min (int): minimal size of the tabu list   Definition  This algorithm is a simple implementation of the Reactive Tabu Search algorithm ((Battiti et al., 1993)). This Reactive Tabu Search is an enhance version of the Tabu search. It adds two new elements to the classic Tabu Search. The first one concerns the size of the tabu list: in the Reactive Tabu Search, this one is not constant anymore but it dynamically evolves according to the context. Thus, when the exploration process visits too often the same solutions, the tabu list is extended in order to favor the diversification of the search process. On the other hand, when the process has not visited an already known solution for a high number of iterations, the tabu list is shortened in order to favor the intensification of the search process. The second new element concerns the adding of cycle detection capacities. Thus, when a cycle is detected, the process applies random movements in order to break the cycle. See [batch161 the batch dedicated page].  Usages     As other batch methods, the basic syntax of the reactive_tabu statement uses method reactive_tabu instead of the expected reactive_tabu name: id :    method reactive_tabu [facet: value];      For example:    method reactive_tabu iter_max: 50 tabu_list_size_init: 5 tabu_list_size_min: 2 tabu_list_size_max: 10 nb_tests_wthout_col_max: 20 cycle_size_min: 2 cycle_size_max: 20 maximize: food_gathered;   Embedments    The reactive_tabu statement is of type: Batch method   The reactive_tabu statement can be embedded into: Experiment,   The reactive_tabu statement embeds statements:     ### reflex  #### Facets     name (an identifier), (omissible) : the identifier of the reflex   when (boolean): an expression that evaluates a boolean, the condition to fulfill in order to execute the statements embedded in the reflex.   Definition  Reflexes are sequences of statements that can be executed by the agent. Reflexes prefixed by the  reflex  keyword are executed continuously. Reflexes prefixed by  init  are executed only immediately after the agent has been created. Reflexes prefixed by  abort  just before the agent is killed. If a facet when: is defined, a reflex is executed only if the boolean expression evaluates to true.  Usages     Example:    reflex my_reflex when: flip (0.5){   //Only executed when flip returns true     write Executing the unconditional reflex; }   Embedments    The reflex statement is of type: Behavior   The reflex statement can be embedded into: Species, Experiment, Model,   The reflex statement embeds statements:     ### release  #### Facets     target (any type in [agent, list, 27]), (omissible) : an expression that is evaluated as an agent/a list of the agents to be released or an agent saved as a map   as (species): an expression that is evaluated as a species in which the micro-agent will be released   in (agent): an expression that is evaluated as an agent that will be the macro-agent in which micro-agent will be released, i.e. their new host   returns (a new identifier): a new variable containing a list of the newly released agent(s)   Definition  Allows an agent to release its micro-agent(s). The preliminary for an agent to release its micro-agents is that species of these micro-agents are sub-species of other species (cf. [Species161#Nesting_species Nesting species]). The released agents won t be micro-agents of the calling agent anymore. Being released from a macro-agent, the micro-agents will change their species and host (macro-agent).  Usages     We consider the following species. Agents of  C  species can be released from a  B  agent to become agents of  A  species. Agents of  D  species cannot be released from the  A  agent because species  D  has no parent species.    species A { ... } species B { ...    species C parent: A {    ...    }    species D {    ...    } ... }      To release all  C  agents from a  B  agent, agent  C  has to execute the following statement. The  C  agent will change to  A  agent. The won t consider  B  agent as their macro-agent (host) anymore. Their host (macro-agent) will the be the host (macro-agent) of the  B  agent.    release list(C);      The modeler can specify the new host and the new species of the released agents:    release list (C) as: new_species in: new host;      See also: capture,   Embedments    The release statement is of type: Sequence of statements or action   The release statement can be embedded into: Behavior, Sequence of statements or action,   The release statement embeds statements:     ### remove  #### Facets     from (any type in [container, species, agent, geometry]): an expression that evaluates to a container   item (any type), (omissible) : any expression to remove from the container   all (any type): an expression that evaluates to a container. If it is true and if the value a list, it removes the first instance of each element of the list. If it is true and the value is not a container, it will remove all instances of this value.   edge (any type): Indicates that the item to remove should be considered as an edge of the receiving graph   index (any type): any expression, the key at which to remove the element from the container   key (any type): any expression, the key at which to remove the element from the container   node (any type): Indicates that the item to remove should be considered as a node of the receiving graph   vertex (any type):   Definition  Allows the agent to remove an element from a container (a list, matrix, map…).  Usages     This statement should be used in the following ways, depending on the kind of container used and the expected action on it:    remove expr from: expr_container; remove index: expr from: expr_container; remove key: expr from: expr_container; remove all: expr from: expr_container;      In the case of list, the facet item: is used to remove the first occurence of a given expression, whereas all is used to remove all the occurrences of the given expression.    list<int> removeList <- [3,2,1,2,3]; remove 2 from: removeList;  // removeList equals [3,1,2,3] remove 3 all: true from: removeList;  // removeList equals [1,2] remove index: 1 from: removeList;  // removeList equals [1]      In the case of map, the facet key: is used to remove the pair identified by the given key.    map<string,int> removeMap <- [x::5, y::7, z::7]; remove key: x from: removeMap;  // removeMap equals [y::7, z::7] remove 7 all: true from: removeMap;  // removeMap equals map([])      In addition, a map a be managed as a list with pair key as index. Given that, facets item:, all: and index: can be used in the same way:    map<string,int> removeMapList <- [x::5, y::7, z::7, t::5]; remove 7 from: removeMapList;  // removeMapList equals [x::5, z::7, t::5] remove [5,7] all: true from: removeMapList;  // removeMapList equals [t::5] remove index: t from: removeMapList;  // removeMapList equals map([])      In the case of a graph, both edges and nodes can be removes using node: and edge facets. If a node is removed, all edges to and from this node are also removed.    graph removeGraph <- as_edge_graph([{1,2}::{3,4},{3,4}::{5,6}]); remove node: {1,2} from: removeGraph; remove node(1,2) from: removeGraph; list var <- removeGraph.vertices;  // var equals [{3,4},{5,6}] list var <- removeGraph.edges;  // var equals [polyline({3,4}::{5,6})] remove edge: {3,4}::{5,6} from: removeGraph; remove edge({3,4},{5,6}) from: removeGraph; list var <- removeGraph.vertices;  // var equals [{3,4},{5,6}] list var <- removeGraph.edges;  // var equals []      In the case of an agent or a shape, remove allows to remove an attribute from the attributes map of the receiver. However, for agents, it will only remove attributes that have been added dynamically, not the ones defined in the species or in its built-in parent.       global {    init {       create speciesRemove;       speciesRemove sR <- speciesRemove(0);  // sR.a now equals 100       remove key: a  from: sR;  // sR.a now equals nil    } }  species speciesRemove {    int a <- 100;  }         This statement can not be used on matrix.   See also: add, put,   Embedments    The remove statement is of type: Single statement   The remove statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer,   The remove statement embeds statements:     ### return  #### Facets     value (any type), (omissible) : an expression that is returned   Definition  Allows to immediately stop and tell which value to return from the evaluation of the surrounding action or top-level statement (reflex, init, etc.). Usually used within the declaration of an action. For more details about actions, see the following [Section161 section].  Usages     Example:       string foo {      return  foo ; }  reflex {     string foo_result <- foo();  // foos_result is now equals to  foo  }         In the specific case one wants an agent to ask another agent to execute a statement with a return, it can be done similarly to:    // In Species A: string foo_different {      return foo_not_same; } /// .... // In Species B: reflex writing {     string temp <- some_agent_A.foo_different [];  // temp is now equals to foo_not_same  }   Embedments    The return statement is of type: Single statement   The return statement can be embedded into: action, Behavior, Sequence of statements or action,   The return statement embeds statements:     ### rule  #### Facets     name (an identifier), (omissible) : The name of the rule   belief (546704): The mandatory belief   desire (546704): The mandatory desire   emotion (546706): The mandatory emotion   new_belief (546704): The belief that will be added   new_beliefs (list): The belief that will be added   new_desire (546704): The desire that will be added   new_desires (list): The desire that will be added   new_emotion (546706): The emotion that will be added   new_emotions (list): The emotion that will be added   new_uncertainties (list): The uncertainty that will be added   new_uncertainty (546704): The uncertainty that will be added   parallel (any type in [boolean, int]): setting this facet to  true  will allow  perceive  to use concurrency with a parallel_bdi architecture; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet is true by default.   priority (any type in [float, int]): The priority of the predicate added as a desire   remove_belief (546704): The belief that will be removed   remove_beliefs (list): The belief that will be removed   remove_desire (546704): The desire that will be removed   remove_desires (list): The desire that will be removed   remove_emotion (546706): The emotion that will be removed   remove_emotions (list): The emotion that will be removed   remove_intention (546704): The intention that will be removed   remove_uncertainties (list): The uncertainty that will be removed   remove_uncertainty (546704): The uncertainty that will be removed   threshold (float): Threshold linked to the emotion.   uncertainty (546704): The mandatory uncertainty   when (boolean):   Definition  enables to add a desire or a belief or to remove a belief, a desire or an intention if the agent gets the belief or/and desire or/and condition mentioned.  Usages     Other examples of use:   rule belief: new_predicate(test) when: flip(0.5) new_desire: new_predicate(test)    Embedments    The rule statement is of type: Single statement   The rule statement can be embedded into: Species, Model,   The rule statement embeds statements:     ### run  #### Facets     name (string), (omissible) :   of (string):   core (int):   end_cycle (int):   seed (int):   with_output (map):   with_param (map):   Embedments    The run statement is of type: Sequence of statements or action   The run statement can be embedded into: Behavior, Single statement, Species, Model,   The run statement embeds statements:     ### save  #### Facets     data (any type), (omissible) : any expression, that will be saved in the file   attributes (map): Allows to specify the attributes of a shape file (or other files that accept attributes). The keys of the map are the names of the attributes that will be present in the file, the values are whatever expression neeeded to define their value   crs (any type): the name of the projection, e.g. crs: EPSG:4326  or its EPSG id, e.g. crs:4326. Here a list of the CRS codes (and EPSG id): http://spatialreference.org   header (boolean): an expression that evaluates to a boolean, specifying whether the save will write a header if the file does not exist   rewrite (boolean): an expression that evaluates to a boolean, specifying whether the save will ecrase the file or append data at the end of it. Default is true   to (string): an expression that evaluates to an string, the path to the file   type (an identifier), takes values in: {shp, text, csv, asc, geotiff, image}: an expression that evaluates to an string, the type of the output file (it can be only  shp ,  asc ,  geotiff ,  image ,  text  or  csv )   with (map): Allows to define the attributes of a shape file. Keys of the map are the attributes of agents to save, values are the names of attributes in the shape file   Definition  Allows to save data in a file. The type of file can be  shp ,  asc ,  geotiff ,  text  or  csv .  Usages     Its simple syntax is:    save data to: output_file type: a_type_file;      To save data in a text file:    save (string(cycle) + ->  + name + : + location) to: save_data.txt type: text;      To save the values of some attributes of the current agent in csv file:    save [name, location, host] to: save_data.csv type: csv;      To save the values of all attributes of all the agents of a species into a csv (with optional attributes):    save species_of(self) to: save_csvfile.csv type: csv header: false;      To save the geometries of all the agents of a species into a shapefile (with optional attributes):    save species_of(self) to: save_shapefile.shp type: shp with: [name::nameAgent, location::locationAgent] crs: EPSG:4326;      To save the grid_value attributes of all the cells of a grid into an ESRI ASCII Raster file:    save grid to: save_grid.asc type: asc;      To save the grid_value attributes of all the cells of a grid into geotiff:    save grid to: save_grid.tif type: geotiff;      To save the grid_value attributes of all the cells of a grid into png (with a worldfile):    save grid to: save_grid.png type: image;      The save statement can be use in an init block, a reflex, an action or in a user command. Do not use it in experiments.   Embedments    The save statement is of type: Single statement   The save statement can be embedded into: Behavior, Sequence of statements or action,   The save statement embeds statements:     ### save_batch  #### Facets     to (a label):   data (any type), (omissible) :   rewrite (boolean):   Embedments    The save_batch statement is of type: Batch method   The save_batch statement can be embedded into: Experiment,   The save_batch statement embeds statements:     ### set  #### Facets     name (any type), (omissible) : the name of an existing variable or attribute to be modified   value (any type): the value to affect to the variable or attribute   Definition  Allows to assign a value to the variable or attribute specified  Usages  Embedments    The set statement is of type: Single statement   The set statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer,   The set statement embeds statements:     ### setup  #### Facets  Definition  The setup statement is used to define the set of instructions that will be executed before every [#test test].  Usages     As every test should be independent from the others, the setup will mainly contain initialization of variables that will be used in each test.       species Tester {     int val_to_test;  setup {     val_to_test <- 0; }  test t1 {    // [set of instructions, including asserts] } }          See also: test, assert,   Embedments    The setup statement is of type: Sequence of statements or action   The setup statement can be embedded into: Species, Experiment, Model,   The setup statement embeds statements:     ### simulate  #### Facets     comodel (file), (omissible) :   repeat (int):   reset (boolean):   share (list):   until (boolean):   with_experiment (string):   with_input (map):   with_output (map):   Definition  Allows an agent, the sender agent (that can be the [Sections161#global world agent]), to ask another (or other) agent(s) to perform a set of statements. It obeys the following syntax, where the target attribute denotes the receiver agent(s):  Usages     Other examples of use:   ask receiver_agent(s) {    // [statements] }    Embedments    The simulate statement is of type: Single statement   The simulate statement can be embedded into: chart, Experiment, Species, Behavior, Sequence of statements or action,   The simulate statement embeds statements:     ### socialize  #### Facets     name (an identifier), (omissible) : the identifier of the socialize statement   agent (agent): the agent value of the created social link   dominance (float): the dominance value of the created social link   familiarity (float): the familiarity value of the created social link   liking (float): the appreciation value of the created social link   solidarity (float): the solidarity value of the created social link   when (boolean): A boolean value to socialize only with a certain condition   Definition  enables to directly add a social link from a perceived agent.  Usages     Other examples of use:   socialize;    Embedments    The socialize statement is of type: Single statement   The socialize statement can be embedded into: Behavior, Sequence of statements or action,   The socialize statement embeds statements:     ### solve  #### Facets     equation (an identifier), (omissible) : the equation system identifier to be numerically solved   cycle_length (int): length of simulation cycle which will be synchronize with step of integrator (default value: 1)   discretizing_step (int): number of discrete between 2 steps of simulation (default value: 0)   integrated_times (list): time interval inside integration process   integrated_values (list): list of variables s value inside integration process   max_step (float): maximal step, (used with dp853 method only), (sign is irrelevant, regardless of integration direction, forward or backward), the last step can be smaller than this value   method (an identifier), takes values in: {Euler, ThreeEighthes, Midpoint, Gill, Luther, rk4, dp853, AdamsBashforth, AdamsMoulton, DormandPrince54, GraggBulirschStoer, HighamHall54}: integrate method (can be only  Euler ,  ThreeEighthes ,  Midpoint ,  Gill ,  Luther ,  rk4  or  dp853 ,  AdamsBashforth ,  AdamsMoulton ,  DormandPrince54 ,  GraggBulirschStoer ,   HighamHall54 ) (default value:  rk4 )   min_step (float): minimal step, (used with dp853 method only), (sign is irrelevant, regardless of integration direction, forward or backward), the last step can be smaller than this value   scalAbsoluteTolerance (float): allowed absolute error (used with dp853 method only)   scalRelativeTolerance (float): allowed relative error (used with dp853 method only)   step (float): integration step, use with most integrator methods (default value: 1)   time_final (float): target time for the integration (can be set to a value smaller than t0 for backward integration)   time_initial (float): initial time   Definition  Solves all equations which matched the given name, with all systems of agents that should solved simultaneously.  Usages     Other examples of use:   solve SIR method: rk4 step:0.001;    Embedments    The solve statement is of type: Single statement   The solve statement can be embedded into: Behavior, Sequence of statements or action,   The solve statement embeds statements:     ### species  #### Facets     name (an identifier), (omissible) : the identifier of the species   cell_height (float): (grid only), the height of the cells of the grid   cell_width (float): (grid only), the width of the cells of the grid   compile (boolean):   control (22): defines the architecture of the species (e.g. fsm…)   edge_species (species): In the case of a species defining a graph topology for its instances (nodes of the graph), specifies the species to use for representing the edges   file (file): (grid only), a bitmap file that will be loaded at runtime so that the value of each pixel  can be assigned to the attribute  grid_value    frequency (int): The execution frequency of the species (default value: 1). For instance, if frequency is set to 10, the population of agents will be executed only every 10 cycles.   height (int): (grid only),  the height of the grid (in terms of agent number)   mirrors (any type in [list, species]): The species this species is mirroring. The population of this current species will be dependent of that of the species mirrored (i.e. agents creation and death are entirely taken in charge by GAMA with respect to the demographics of the species mirrored). In addition, this species is provided with an attribute called  target , which allows each agent to know which agent of the mirrored species it is representing.   neighbors (int): (grid only), the chosen neighborhood (4, 6 or 8)   neighbours (int): (grid only), the chosen neighborhood (4, 6 or 8)   parallel (any type in [boolean, int]): (experimental) setting this facet to  true  will allow this species to use concurrency when scheduling its agents; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet has a default set in the preferences (Under Performances > Concurrency)   parent (species): the parent class (inheritance)   schedules (container): A container of agents (a species, a dynamic list, or a combination of species and containers) , which represents which agents will be actually scheduled when the population is scheduled for execution. For instance,  species a schedules: (10 among a)  will result in a population that schedules only 10 of its own agents every cycle.  species b schedules: []  will prevent the agents of  b  to be scheduled. Note that the scope of agents covered here can be larger than the population, which allows to build complex scheduling controls; for instance, defining  global schedules: [] {…} species b schedules: []; species c schedules: b + world;   allows to simulate a model where the agents of b are scheduled first, followed by the world, without even having to create an instance of c.   skills (list): The list of skills that will be made available to the instances of this species. Each new skill provides attributes and actions that will be added to the ones defined in this species   topology (topology): The topology of the population of agents defined by this species. In case of nested species, it can for example be the shape of the macro-agent. In case of grid or graph species, the topology is automatically computed and cannot be redefined   torus (boolean): is the topology toric (defaut: false). Needs to be defined on the global species.   use_individual_shapes (boolean): (grid only),(true by default). Allows to specify whether or not the agents of the grid will have distinct geometries. If set to false, they will all have simpler proxy geometries   use_neighbors_cache (boolean): (grid only),(true by default). Allows to turn on or off the use of the neighbors cache used for grids. Note that if a diffusion of variable occurs, GAMA will emit a warning and automatically switch to a caching version   use_regular_agents (boolean): (grid only),(true by default). Allows to specify if the agents of the grid are regular agents (like those of any other species) or minimal ones (which can t have sub-populations, can t inherit from a regular species, etc.)   width (int): (grid only), the width of the grid (in terms of agent number)   Definition  The species statement allows modelers to define new species in the model. global and grid are speciel cases of species: global being the definition of the global agent (which has automatically one instance, world) and grid being a species with a grid topology.  Usages     Here is an example of a species definition with a FSM architecture and the additional skill moving:    species ant skills: [moving] control: fsm {      In the case of a species aiming at mirroring another one:    species node_agent mirrors: list(bug) parent: graph_node edge_species: edge_agent {      The definition of the single grid of a model will automatically create gridwidth x gridheight agents:    grid ant_grid width: gridwidth height: gridheight file: grid_file neighbors: 8 use_regular_agents: false {       Using a file to initialize the grid can replace width/height facets:    grid ant_grid file: grid_file neighbors: 8 use_regular_agents: false {    Embedments    The species statement is of type: Species   The species statement can be embedded into: Model, Environment, Species,   The species statement embeds statements:     ### state  #### Facets     name (an identifier), (omissible) : the identifier of the state   final (boolean): specifies whether the state is a final one (i.e. there is no transition from this state to another state) (default value= false)   initial (boolean): specifies whether the state is the initial one (default value = false)   Definition  A state, like a reflex, can contains several statements that can be executed at each time step by the agent.  Usages     Here is an exemple integrating 2 states and the statements in the FSM architecture:        state s_init initial: true {   enter { write  Enter in  + state; }    write  Enter in  + state;   }   write state;   transition to: s1 when: (cycle > 2) {   write transition s_init -> s1;  }   exit {   write EXIT from +state;  } } state s1 {  enter {write  Enter in  +state;}  write state;  exit {write  EXIT from  +state;} }          See also: enter, exit, transition,   Embedments    The state statement is of type: Behavior   The state statement can be embedded into: fsm, Species, Experiment, Model,   The state statement embeds statements: enter,  exit,     ### status  #### Facets     message (any type), (omissible) : Allows to display a necessarily short message in the status box in the upper left corner. No formatting characters (carriage returns, tabs, or Unicode characters) should be used, but a background color can be specified. The message will remain in place until it is replaced by another one or by nil, in which case the standard status (number of cycles) will be displayed again   color (rgb):   Definition  The statement makes the agent output an arbitrary message in the status box.  Usages     Outputting a message    status ( This is my status   + self) color: #yellow;   Embedments    The status statement is of type: Single statement   The status statement can be embedded into: Behavior, Sequence of statements or action, Layer,   The status statement embeds statements:     ### switch  #### Facets     value (any type), (omissible) : an expression   Definition  The  switch… match  statement is a powerful replacement for imbricated  if … else …  constructs. All the blocks that match are executed in the order they are defined. The block prefixed by default is executed only if none have matched (otherwise it is not).  Usages     The prototypical syntax is as follows:    switch an_expression {  match value1 {...}  match_one [value1, value2, value3] {...}  match_between [value1, value2] {...}  default {...} }      Example:    switch 3 {    match 1 {write Match 1; }    match 2 {write Match 2; }    match 3 {write Match 3; }    match_one [4,4,6,3,7]  {write Match one_of; }    match_between [2, 4] {write Match between; }    default {write Match Default; } }      See also: match, default, if,   Embedments    The switch statement is of type: Sequence of statements or action   The switch statement can be embedded into: Behavior, Sequence of statements or action, Layer,   The switch statement embeds statements: default,  match,     ### tabu  #### Facets     name (an identifier), (omissible) :   aggregation (a label), takes values in: {min, max}: the agregation method   iter_max (int): number of iterations   maximize (float): the value the algorithm tries to maximize   minimize (float): the value the algorithm tries to minimize   tabu_list_size (int): size of the tabu list   Definition  This algorithm is an implementation of the Tabu Search algorithm. See the wikipedia article and [batch161 the batch dedicated page].  Usages     As other batch methods, the basic syntax of the tabu statement uses method tabu instead of the expected tabu name: id :    method tabu [facet: value];      For example:    method tabu iter_max: 50 tabu_list_size: 5 maximize: food_gathered;   Embedments    The tabu statement is of type: Batch method   The tabu statement can be embedded into: Experiment,   The tabu statement embeds statements:     ### task  #### Facets     name (an identifier), (omissible) : the identifier of the task   weight (float): the priority level of the task   Definition  As reflex, a task is a sequence of statements that can be executed, at each time step, by the agent. If an agent owns several tasks, the scheduler chooses a task to execute based on its current priority weight value.  Usages  Embedments    The task statement is of type: Behavior   The task statement can be embedded into: weighted_tasks, sorted_tasks, probabilistic_tasks, Species, Experiment, Model,   The task statement embeds statements:     ### test  #### Facets     name (an identifier), (omissible) : identifier of the test   Definition  The test statement allows modeler to define a set of assertions that will be tested. Before the execution of the embedded set of instructions, if a setup is defined in the species, model or experiment, it is executed. In a test, if one assertion fails, the evaluation of other assertions continue (if GAMA is configured in the preferences that the program does not stop at the first exception).  Usages     An example of use:       species Tester {     // set of attributes that will be used in test  setup {     // [set of instructions... in particular initializations] }  test t1 {    // [set of instructions, including asserts] } }          See also: setup, assert,   Embedments    The test statement is of type: Behavior   The test statement can be embedded into: Species, Experiment, Model,   The test statement embeds statements: assert,     ### trace  #### Facets  Definition  All the statements executed in the trace statement are displayed in the console.  Usages  Embedments    The trace statement is of type: Sequence of statements or action   The trace statement can be embedded into: Behavior, Sequence of statements or action, Layer,   The trace statement embeds statements:     ### transition  #### Facets     to (an identifier): the identifier of the next state   when (boolean), (omissible) : a condition to be fulfilled to have a transition to another given state   Definition  In an FSM architecture, transition specifies the next state of the life cycle. The transition occurs when the condition is fulfilled. The embedded statements are executed when the transition is triggered.  Usages     In the following example, the transition is executed when after 2 steps:     state s_init initial: true {   write state;   transition to: s1 when: (cycle > 2) {    write transition s_init -> s1;   }  }      See also: enter, state, exit,   Embedments    The transition statement is of type: Sequence of statements or action   The transition statement can be embedded into: Sequence of statements or action, Behavior,   The transition statement embeds statements:     ### unconscious_contagion  #### Facets     emotion (546706): the emotion that will be copied with the contagion   name (an identifier), (omissible) : the identifier of the unconscious contagion   charisma (float): The charisma value of the perceived agent (between 0 and 1)   receptivity (float): The receptivity value of the current agent (between 0 and 1)   threshold (float): The threshold value to make the contagion   when (boolean): A boolean value to get the emotion only with a certain condition   Definition  enables to directly copy an emotion presents in the perceived specie.  Usages     Other examples of use:   unconscious_contagion emotion:fearConfirmed;  unconscious_contagion emotion:fearConfirmed charisma: 0.5 receptivity: 0.5;    Embedments    The unconscious_contagion statement is of type: Single statement   The unconscious_contagion statement can be embedded into: Behavior, Sequence of statements or action,   The unconscious_contagion statement embeds statements:     ### user_command  #### Facets     name (a label), (omissible) : the identifier of the user_command   action (26): the identifier of the action to be executed. This action should be accessible in the context in which the user_command is defined (an experiment, the global section or a species). A special case is allowed to maintain the compatibility with older versions of GAMA, when the user_command is declared in an experiment and the action is declared in  global . In that case, all the simulations managed by the experiment will run the action in response to the user executing the command   color (rgb): The color of the button to display   continue (boolean): Whether or not the button, when clicked, should dismiss the user panel it is defined in. Has no effect in other contexts (menu, parameters, inspectors)   when (boolean): the condition that should be fulfilled (in addition to the user clicking it) in order to execute this action   with (map): the map of the parameters::values required by the action   Definition  Anywhere in the global block, in a species or in an (GUI) experiment, user_command statements allows to either call directly an existing action (with or without arguments) or to be followed by a block that describes what to do when this command is run.  Usages     The general syntax is for example:    user_command kill_myself action: some_action with: [arg1::val1, arg2::val2, ...];      See also: user_init, user_panel, user_input,   Embedments    The user_command statement is of type: Sequence of statements or action   The user_command statement can be embedded into: user_panel, Species, Experiment, Model,   The user_command statement embeds statements: user_input,     ### user_init  #### Facets     name (an identifier), (omissible) : The name of the panel   initial (boolean): Whether or not this panel will be the initial one   Definition  Used in the user control architecture, user_init is executed only once when the agent is created. It opens a special panel (if it contains user_commands statements). It is the equivalent to the init block in the basic agent architecture.  Usages     See also: user_command, user_init, user_input,   Embedments    The user_init statement is of type: Behavior   The user_init statement can be embedded into: Species, Experiment, Model,   The user_init statement embeds statements: user_panel,     ### user_input  #### Facets     returns (a new identifier): a new local variable containing the value given by the user   name (a label), (omissible) : the displayed name   among (list): the set of acceptable values for the variable   init (any type): the init value   max (float): the maximum value   min (float): the minimum value   slider (boolean): Whether to display a slider or not when applicable   type (a datatype identifier): the variable type   Definition  It allows to let the user define the value of a variable.  Usages   Other examples of use:   user_panel Advanced Control {   user_input Location returns: loc type: point <- {0,0};   create cells number: 10 with: [location::loc]; }  See also: user_command, user_init, user_panel,      Embedments    The user_input statement is of type: Single statement   The user_input statement can be embedded into: user_command,   The user_input statement embeds statements:     ### user_panel  #### Facets     name (an identifier), (omissible) : The name of the panel   initial (boolean): Whether or not this panel will be the initial one   Definition  It is the basic behavior of the user control architecture (it is similar to state for the FSM architecture). This user_panel translates, in the interface, in a semi-modal view that awaits the user to choose action buttons, change attributes of the controlled agent, etc. Each user_panel, like a state in FSM, can have a enter and exit sections, but it is only defined in terms of a set of user_commands which describe the different action buttons present in the panel.  Usages     The general syntax is for example:       user_panel default initial: true {  user_input  Number  returns: number type: int <- 10;  ask (number among list(cells)){ do die; }  transition to:  Advanced Control  when: every (10); }  user_panel  Advanced Control  {  user_input  Location  returns: loc type: point <- {0,0};  create cells number: 10 with: [location::loc]; }         See also: user_command, user_init, user_input,   Embedments    The user_panel statement is of type: Behavior   The user_panel statement can be embedded into: fsm, user_first, user_last, user_init, user_only, Species, Experiment, Model,   The user_panel statement embeds statements: user_command,     ### using  #### Facets     topology (topology), (omissible) : the topology   Definition  using is a statement that allows to set the topology to use by its sub-statements. They can gather it by asking the scope to provide it.  Usages     All the spatial operations are topology-dependent (e.g. neighbors are not the same in a continuous and in a grid topology). So using statement allows modelers to specify the topology in which the spatial operation will be computed.    float dist <- 0.0; using topology(grid_ant) {  d (self.location distance_to target.location); }   Embedments    The using statement is of type: Sequence of statements or action   The using statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer,   The using statement embeds statements:     ### Variable_container  #### Facets     name (a new identifier), (omissible) : The name of the attribute   category (a label): Soon to be deprecated. Declare the parameter in an experiment instead   const (boolean): Indicates whether this attribute can be subsequently modified or not   fill_with (any type):   function (any type): Used to specify an expression that will be evaluated each time the attribute is accessed. This facet is incompatible with both  init:  and  update:    index (a datatype identifier):   init (any type): The initial value of the attribute   of (a datatype identifier):   on_change (any type): Provides a block of statements that will be executed whenever the value of the attribute changes   parameter (a label): Soon to be deprecated. Declare the parameter in an experiment instead   size (any type in [int, point]):   type (a datatype identifier):   update (any type): An expression that will be evaluated each cycle to compute a new value for the attribute   value (any type):   Definition  Allows to declare an attribute of a species or an experiment  Usages  Embedments    The Variable_container statement is of type: Variable (container)   The Variable_container statement can be embedded into: Species, Experiment, Model,   The Variable_container statement embeds statements:     ### Variable_number  #### Facets     name (a new identifier), (omissible) : The name of the attribute   among (list): A list of constant values among which the attribute can take its value   category (a label): Soon to be deprecated. Declare the parameter in an experiment instead   const (boolean): Indicates whether this attribute can be subsequently modified or not   function (any type in [int, float]): Used to specify an expression that will be evaluated each time the attribute is accessed. This facet is incompatible with both  init:  and  update:    init (any type in [int, float]): The initial value of the attribute   max (any type in [int, float]): The maximum value this attribute can take.   min (any type in [int, float]): The minimum value this attribute can take   on_change (any type): Provides a block of statements that will be executed whenever the value of the attribute changes   parameter (a label): Soon to be deprecated. Declare the parameter in an experiment instead   step (int):   type (a datatype identifier): The type of the attribute, either  int  or  float    update (any type in [int, float]): An expression that will be evaluated each cycle to compute a new value for the attribute   value (any type in [int, float]):   Definition  Allows to declare an attribute of a species or experiment  Usages  Embedments    The Variable_number statement is of type: Variable (number)   The Variable_number statement can be embedded into: Species, Experiment, Model,   The Variable_number statement embeds statements:     ### Variable_regular  #### Facets     name (a new identifier), (omissible) : The name of the attribute   among (list): A list of constant values among which the attribute can take its value   category (a label): Soon to be deprecated. Declare the parameter in an experiment instead   const (boolean): Indicates whether this attribute can be subsequently modified or not   function (any type): Used to specify an expression that will be evaluated each time the attribute is accessed. This facet is incompatible with both  init:  and  update:    index (a datatype identifier): The type of the index used to retrieve elements if the type of the attribute is a container type   init (any type): The initial value of the attribute   of (a datatype identifier): The type of the elements contained in the type of this attribute if it is a container type   on_change (any type): Provides a block of statements that will be executed whenever the value of the attribute changes   parameter (a label): Soon to be deprecated. Declare the parameter in an experiment instead   type (a datatype identifier): The type of this attribute. Can be combined with facets  of  and  index  to describe container types   update (any type): An expression that will be evaluated each cycle to compute a new value for the attribute   value (any type):   Definition  Allows to declare an attribute of a species or an experiment  Usages  Embedments    The Variable_regular statement is of type: Variable (regular)   The Variable_regular statement can be embedded into: Species, Experiment, Model,   The Variable_regular statement embeds statements:     ### warn  #### Facets     message (string), (omissible) : the message to display as a warning.   Definition  The statement makes the agent output an arbitrary message in the error view as a warning.  Usages     Emmitting a warning    warn  This is a warning from   + self;   Embedments    The warn statement is of type: Single statement   The warn statement can be embedded into: Behavior, Sequence of statements or action, Layer,   The warn statement embeds statements:     ### write  #### Facets     message (any type), (omissible) : the message to display. Modelers can add some formatting characters to the message (carriage returns, tabs, or Unicode characters), which will be used accordingly in the console.   color (rgb): The color with wich the message will be displayed. Note that different simulations will have different (default) colors to use for this purpose if this facet is not specified   Definition  The statement makes the agent output an arbitrary message in the console.  Usages     Outputting a message    write  This is a message from   + self;   Embedments    The write statement is of type: Single statement   The write statement can be embedded into: Behavior, Sequence of statements or action, Layer,   The write statement embeds statements:  ","url":"wiki/Statements.md"},{"id":"wiki/UnitsAndConstants.md","title":" Units and constants","content":"Units and constants    This file is automatically generated from java files. Do Not Edit It.    Introduction Units can be used to qualify the values of numeric variables. By default, unqualified values are considered as: * meters for distances, lengths… * seconds for durations * cubic meters for volumes * kilograms for masses  So, an expression like:  float foo <- 1;   will be considered as 1 meter if foo is a distance, or 1 second if it is a duration, or 1 meter/second if it is a speed. If one wants to specify the unit, it can be done very simply by adding the unit symbol (° or #) followed by an unit name after the numeric value, like:   float foo <- 1 °centimeter;   or   float foo <- 1 #centimeter;   In that case, the numeric value of foo will be automatically translated to 0.01 (meter). It is recommended to always use float as the type of the variables that might be qualified by units (otherwise, for example in the previous case, they might be truncated to 0).  Several units names are allowed as qualifiers of numeric variables.  These units represent the basic metric and US units. Composed and derived units (like velocity, acceleration, special volumes or surfaces) can be obtained by combining these units using the * and / operators. For instance:  float one_kmh <- 1 °km / °h const: true; float one_millisecond <-1 °sec / 1000; float one_cubic_inch <- 1 °sqin * 1 °inch; ... etc ...   Table of Contents     Constants     #e, value= 2.718281828459045, Comment: The e constant      #infinity, value= Infinity, Comment: A constant holding the positive infinity of type (Java Double.POSITIVE_INFINITY)      #max_float, value= 1.7976931348623157E308, Comment: A constant holding the largest positive finite value of type float (Java Double.MAX_VALUE)      #max_int, value= 2.147483647E9, Comment: A constant holding the maximum value an int can have (Java Integer.MAX_VALUE)      #min_float, value= 4.9E-324, Comment: A constant holding the smallest positive nonzero value of type float (Java Double.MIN_VALUE)      #min_int, value= -2.147483648E9, Comment: A constant holding the minimum value an int can have (Java Integer.MIN_VALUE)      #nan, value= NaN, Comment: A constant holding a Not-a-Number (NaN) value of type float (Java Double.POSITIVE_INFINITY)      #pi, value= 3.141592653589793, Comment: The PI constant      #to_deg, value= 57.29577951308232, Comment: A constant holding the value to convert radians into degrees      #to_rad, value= 0.017453292519943295, Comment: A constant holding the value to convert degrees into radians     Graphics units     #bold, value= 1, Comment: This constant allows to build a font with a bold face. Can be combined with #italic      #camera_location, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current position of the camera as a point      #camera_orientation, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current orientation of the camera as a point      #camera_target, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current target of the camera as a point      #display_height, value= 1.0, Comment: This constant is only accessible in a graphical context: display, graphics…      #display_width, value= 1.0, Comment: This constant is only accessible in a graphical context: display, graphics…      #flat, value= 2, Comment: This constant represents a flat line buffer end cap style      #horizontal, value= 3, Comment: This constant represents a layout where all display views are aligned horizontally      #italic, value= 2, Comment: This constant allows to build a font with an italic face. Can be combined with #bold      #none, value= 0, Comment: This constant represents the absence of a predefined layout      #pixels (#px), value= 1.0, Comment: This unit, only available when running aspects or declaring displays,  returns a dynamic value instead of a fixed one. px (or pixels), returns the value of one pixel on the current view in terms of model units.      #plain, value= 0, Comment: This constant allows to build a font with a plain face      #round, value= 1, Comment: This constant represents a round line buffer end cap style      #split, value= 2, Comment: This constant represents a layout where all display views are split in a grid-like structure      #square, value= 3, Comment: This constant represents a square line buffer end cap style      #stack, value= 1, Comment: This constant represents a layout where all display views are stacked      #user_location, value= No Default Value, Comment: This unit contains in permanence the location of the mouse on the display in which it is situated. The latest location is provided when it is out of a display      #vertical, value= 4, Comment: This constant represents a layout where all display views are aligned vertically      #zoom, value= 1.0, Comment: This unit, only available when running aspects or declaring displays, returns the current zoom level of the display as a positive float, where 1.0 represent the neutral zoom (100%)     Length units     #cm (#centimeter,#centimeters), value= 0.009999999776482582, Comment: centimeter unit      #dm (#decimeter,#decimeters), value= 0.10000000149011612, Comment: decimeter unit      #foot (#feet,#ft), value= 0.3047999931871891, Comment: foot unit      #inch (#inches), value= 0.025399999432265757, Comment: inch unit      #km (#kilometer,#kilometers), value= 1000.0, Comment: kilometer unit      #m (#meter,#meters), value= 1.0, Comment: meter: the length basic unit      #mile (#miles), value= 1609.344, Comment: mile unit      #mm (#milimeter,#milimeters), value= 9.999999776482583E-4, Comment: millimeter unit      #yard (#yards), value= 0.9144, Comment: yard unit     Surface units     #m2, value= 1.0, Comment: square meter: the basic unit for surfaces      #sqft (#square_foot,#square_feet), value= 0.09290303584691051, Comment: square foot unit      #sqin (#square_inch,#square_inches), value= 6.451599711591008E-4, Comment: square inch unit      #sqmi (#square_mile,#square_miles), value= 2589988.110336, Comment: square mile unit     Time units     #custom, value= CUSTOM, Comment: custom: a custom date/time pattern that can be defined in the preferences of GAMA and reused in models      #cycle (#cycles), value= 1, Comment: cycle: the discrete measure of time in the simulation. Used to force a temporal expression to be expressed in terms of cycles rather than seconds      #day (#days), value= 86400.0, Comment: day time unit: defines an exact duration of 24 hours      #epoch, value= No Default Value, Comment: The epoch default starting date as defined by the ISO format (1970-01-01T00:00Z)      #h (#hour,#hours), value= 3600.0, Comment: hour time unit: defines an exact duration of 60 minutes      #iso_local, value= ISO_LOCAL_DATE_TIME, Comment: iso_local: the standard ISO 8601 output / parsing format for local dates (i.e. with no time-zone information)      #iso_offset, value= ISO_OFFSET_DATE_TIME, Comment: iso_offset: the standard ISO 8601 output / parsing format for dates with a time offset      #iso_zoned, value= ISO_ZONED_DATE_TIME, Comment: iso_zoned: the standard ISO 8601 output / parsing format for dates with a time zone      #minute (#minutes,#mn), value= 60.0, Comment: minute time unit: defined an exact duration of 60 seconds      #month (#months), value= 2592000.0, Comment: month time unit: does not define an exact duration. The duration will depend on the step/date at which this unit is computed.      #msec (#millisecond,#milliseconds,#ms), value= 0.001, Comment: millisecond time unit: defines an exact duration of 0.001 second      #now, value= 1.0, Comment: This value represents the current date      #sec (#second,#seconds,#s), value= 1.0, Comment: second: the time basic unit, with a fixed value of 1. All other durations are expressed with respect to it      #week (#weeks), value= 604800.0, Comment: week time unit: defines an exact duration of  7 days      #year (#years,#y), value= 3.1104E7, Comment: year time unit: does not define an exact duration. The duration will depend on the step/date at which this unit is computed.     Volume units     #cl (#centiliter,#centiliters), value= 1.0E-5, Comment: centiliter unit      #dl (#deciliter,#deciliters), value= 1.0E-4, Comment: deciliter unit      #hl (#hectoliter,#hectoliters), value= 0.1, Comment: hectoliter unit      #l (#liter,#liters,#dm3), value= 0.001, Comment: liter unit      #m3, value= 1.0, Comment: cube meter: the basic unit for volumes     Weight units     #gram (#grams), value= 0.001, Comment: gram unit      #kg (#kilo,#kilogram,#kilos), value= 1.0, Comment: second: the basic unit for weights      #longton (#lton), value= 1016.0469088000001, Comment: short ton unit      #ounce (#oz,#ounces), value= 0.028349523125, Comment: ounce unit      #pound (#lb,#pounds,#lbm), value= 0.45359237, Comment: pound unit      #shortton (#ston), value= 907.18474, Comment: short ton unit      #stone (#st), value= 6.35029318, Comment: stone unit      #ton (#tons), value= 1000.0, Comment: ton unit     Colors  In addition to the previous units, GAML provides a direct access to the 147 named colors defined in CSS (see http://www.cssportal.com/css3-color-names/). E.g,  rgb my_color <- °teal;      #aliceblue, value= r=240, g=248, b=255, alpha=1      #antiquewhite, value= r=250, g=235, b=215, alpha=1      #aqua, value= r=0, g=255, b=255, alpha=1      #aquamarine, value= r=127, g=255, b=212, alpha=1      #azure, value= r=240, g=255, b=255, alpha=1      #beige, value= r=245, g=245, b=220, alpha=1      #bisque, value= r=255, g=228, b=196, alpha=1      #black, value= r=0, g=0, b=0, alpha=1      #blanchedalmond, value= r=255, g=235, b=205, alpha=1      #blue, value= r=0, g=0, b=255, alpha=1      #blueviolet, value= r=138, g=43, b=226, alpha=1      #brown, value= r=165, g=42, b=42, alpha=1      #burlywood, value= r=222, g=184, b=135, alpha=1      #cadetblue, value= r=95, g=158, b=160, alpha=1      #chartreuse, value= r=127, g=255, b=0, alpha=1      #chocolate, value= r=210, g=105, b=30, alpha=1      #coral, value= r=255, g=127, b=80, alpha=1      #cornflowerblue, value= r=100, g=149, b=237, alpha=1      #cornsilk, value= r=255, g=248, b=220, alpha=1      #crimson, value= r=220, g=20, b=60, alpha=1      #cyan, value= r=0, g=255, b=255, alpha=1      #darkblue, value= r=0, g=0, b=139, alpha=1      #darkcyan, value= r=0, g=139, b=139, alpha=1      #darkgoldenrod, value= r=184, g=134, b=11, alpha=1      #darkgray, value= r=169, g=169, b=169, alpha=1      #darkgreen, value= r=0, g=100, b=0, alpha=1      #darkgrey, value= r=169, g=169, b=169, alpha=1      #darkkhaki, value= r=189, g=183, b=107, alpha=1      #darkmagenta, value= r=139, g=0, b=139, alpha=1      #darkolivegreen, value= r=85, g=107, b=47, alpha=1      #darkorange, value= r=255, g=140, b=0, alpha=1      #darkorchid, value= r=153, g=50, b=204, alpha=1      #darkred, value= r=139, g=0, b=0, alpha=1      #darksalmon, value= r=233, g=150, b=122, alpha=1      #darkseagreen, value= r=143, g=188, b=143, alpha=1      #darkslateblue, value= r=72, g=61, b=139, alpha=1      #darkslategray, value= r=47, g=79, b=79, alpha=1      #darkslategrey, value= r=47, g=79, b=79, alpha=1      #darkturquoise, value= r=0, g=206, b=209, alpha=1      #darkviolet, value= r=148, g=0, b=211, alpha=1      #deeppink, value= r=255, g=20, b=147, alpha=1      #deepskyblue, value= r=0, g=191, b=255, alpha=1      #dimgray, value= r=105, g=105, b=105, alpha=1      #dimgrey, value= r=105, g=105, b=105, alpha=1      #dodgerblue, value= r=30, g=144, b=255, alpha=1      #firebrick, value= r=178, g=34, b=34, alpha=1      #floralwhite, value= r=255, g=250, b=240, alpha=1      #forestgreen, value= r=34, g=139, b=34, alpha=1      #fuchsia, value= r=255, g=0, b=255, alpha=1      #gainsboro, value= r=220, g=220, b=220, alpha=1      #ghostwhite, value= r=248, g=248, b=255, alpha=1      #gold, value= r=255, g=215, b=0, alpha=1      #goldenrod, value= r=218, g=165, b=32, alpha=1      #gray, value= r=128, g=128, b=128, alpha=1      #green, value= r=0, g=128, b=0, alpha=1      #greenyellow, value= r=173, g=255, b=47, alpha=1      #grey, value= r=128, g=128, b=128, alpha=1      #honeydew, value= r=240, g=255, b=240, alpha=1      #hotpink, value= r=255, g=105, b=180, alpha=1      #indianred, value= r=205, g=92, b=92, alpha=1      #indigo, value= r=75, g=0, b=130, alpha=1      #ivory, value= r=255, g=255, b=240, alpha=1      #khaki, value= r=240, g=230, b=140, alpha=1      #lavender, value= r=230, g=230, b=250, alpha=1      #lavenderblush, value= r=255, g=240, b=245, alpha=1      #lawngreen, value= r=124, g=252, b=0, alpha=1      #lemonchiffon, value= r=255, g=250, b=205, alpha=1      #lightblue, value= r=173, g=216, b=230, alpha=1      #lightcoral, value= r=240, g=128, b=128, alpha=1      #lightcyan, value= r=224, g=255, b=255, alpha=1      #lightgoldenrodyellow, value= r=250, g=250, b=210, alpha=1      #lightgray, value= r=211, g=211, b=211, alpha=1      #lightgreen, value= r=144, g=238, b=144, alpha=1      #lightgrey, value= r=211, g=211, b=211, alpha=1      #lightpink, value= r=255, g=182, b=193, alpha=1      #lightsalmon, value= r=255, g=160, b=122, alpha=1      #lightseagreen, value= r=32, g=178, b=170, alpha=1      #lightskyblue, value= r=135, g=206, b=250, alpha=1      #lightslategray, value= r=119, g=136, b=153, alpha=1      #lightslategrey, value= r=119, g=136, b=153, alpha=1      #lightsteelblue, value= r=176, g=196, b=222, alpha=1      #lightyellow, value= r=255, g=255, b=224, alpha=1      #lime, value= r=0, g=255, b=0, alpha=1      #limegreen, value= r=50, g=205, b=50, alpha=1      #linen, value= r=250, g=240, b=230, alpha=1      #magenta, value= r=255, g=0, b=255, alpha=1      #maroon, value= r=128, g=0, b=0, alpha=1      #mediumaquamarine, value= r=102, g=205, b=170, alpha=1      #mediumblue, value= r=0, g=0, b=205, alpha=1      #mediumorchid, value= r=186, g=85, b=211, alpha=1      #mediumpurple, value= r=147, g=112, b=219, alpha=1      #mediumseagreen, value= r=60, g=179, b=113, alpha=1      #mediumslateblue, value= r=123, g=104, b=238, alpha=1      #mediumspringgreen, value= r=0, g=250, b=154, alpha=1      #mediumturquoise, value= r=72, g=209, b=204, alpha=1      #mediumvioletred, value= r=199, g=21, b=133, alpha=1      #midnightblue, value= r=25, g=25, b=112, alpha=1      #mintcream, value= r=245, g=255, b=250, alpha=1      #mistyrose, value= r=255, g=228, b=225, alpha=1      #moccasin, value= r=255, g=228, b=181, alpha=1      #navajowhite, value= r=255, g=222, b=173, alpha=1      #navy, value= r=0, g=0, b=128, alpha=1      #oldlace, value= r=253, g=245, b=230, alpha=1      #olive, value= r=128, g=128, b=0, alpha=1      #olivedrab, value= r=107, g=142, b=35, alpha=1      #orange, value= r=255, g=165, b=0, alpha=1      #orangered, value= r=255, g=69, b=0, alpha=1      #orchid, value= r=218, g=112, b=214, alpha=1      #palegoldenrod, value= r=238, g=232, b=170, alpha=1      #palegreen, value= r=152, g=251, b=152, alpha=1      #paleturquoise, value= r=175, g=238, b=238, alpha=1      #palevioletred, value= r=219, g=112, b=147, alpha=1      #papayawhip, value= r=255, g=239, b=213, alpha=1      #peachpuff, value= r=255, g=218, b=185, alpha=1      #peru, value= r=205, g=133, b=63, alpha=1      #pink, value= r=255, g=192, b=203, alpha=1      #plum, value= r=221, g=160, b=221, alpha=1      #powderblue, value= r=176, g=224, b=230, alpha=1      #purple, value= r=128, g=0, b=128, alpha=1      #red, value= r=255, g=0, b=0, alpha=1      #rosybrown, value= r=188, g=143, b=143, alpha=1      #royalblue, value= r=65, g=105, b=225, alpha=1      #saddlebrown, value= r=139, g=69, b=19, alpha=1      #salmon, value= r=250, g=128, b=114, alpha=1      #sandybrown, value= r=244, g=164, b=96, alpha=1      #seagreen, value= r=46, g=139, b=87, alpha=1      #seashell, value= r=255, g=245, b=238, alpha=1      #sienna, value= r=160, g=82, b=45, alpha=1      #silver, value= r=192, g=192, b=192, alpha=1      #skyblue, value= r=135, g=206, b=235, alpha=1      #slateblue, value= r=106, g=90, b=205, alpha=1      #slategray, value= r=112, g=128, b=144, alpha=1      #slategrey, value= r=112, g=128, b=144, alpha=1      #snow, value= r=255, g=250, b=250, alpha=1      #springgreen, value= r=0, g=255, b=127, alpha=1      #steelblue, value= r=70, g=130, b=180, alpha=1      #tan, value= r=210, g=180, b=140, alpha=1      #teal, value= r=0, g=128, b=128, alpha=1      #thistle, value= r=216, g=191, b=216, alpha=1      #tomato, value= r=255, g=99, b=71, alpha=1      #transparent, value= r=0, g=0, b=0, alpha=0      #turquoise, value= r=64, g=224, b=208, alpha=1      #violet, value= r=238, g=130, b=238, alpha=1      #wheat, value= r=245, g=222, b=179, alpha=1      #white, value= r=255, g=255, b=255, alpha=1      #whitesmoke, value= r=245, g=245, b=245, alpha=1      #yellow, value= r=255, g=255, b=0, alpha=1      #yellowgreen, value= r=154, g=205, b=50, alpha=1  ","url":"wiki/UnitsAndConstants.md"},{"id":"wiki/UnitsAndConstantsPDF.md","title":" Units and constants","content":"Units and constants    This file is automatically generated from java files. Do Not Edit It.    Introduction Units can be used to qualify the values of numeric variables. By default, unqualified values are considered as: * meters for distances, lengths… * seconds for durations * cubic meters for volumes * kilograms for masses  So, an expression like:  float foo <- 1;   will be considered as 1 meter if foo is a distance, or 1 second if it is a duration, or 1 meter/second if it is a speed. If one wants to specify the unit, it can be done very simply by adding the unit symbol (° or #) followed by an unit name after the numeric value, like:   float foo <- 1 °centimeter;   or   float foo <- 1 #centimeter;   In that case, the numeric value of foo will be automatically translated to 0.01 (meter). It is recommended to always use float as the type of the variables that might be qualified by units (otherwise, for example in the previous case, they might be truncated to 0).  Several units names are allowed as qualifiers of numeric variables.  These units represent the basic metric and US units. Composed and derived units (like velocity, acceleration, special volumes or surfaces) can be obtained by combining these units using the * and / operators. For instance:  float one_kmh <- 1 °km / °h const: true; float one_millisecond <-1 °sec / 1000; float one_cubic_inch <- 1 °sqin * 1 °inch; ... etc ...   Table of Contents     Constants     \\#e, value= 2.718281828459045, Comment: The e constant      \\#infinity, value= Infinity, Comment: A constant holding the positive infinity of type (Java Double.POSITIVE_INFINITY)      \\#max_float, value= 1.7976931348623157E308, Comment: A constant holding the largest positive finite value of type float (Java Double.MAX_VALUE)      \\#max_int, value= 2.147483647E9, Comment: A constant holding the maximum value an int can have (Java Integer.MAX_VALUE)      \\#min_float, value= 4.9E-324, Comment: A constant holding the smallest positive nonzero value of type float (Java Double.MIN_VALUE)      \\#min_int, value= -2.147483648E9, Comment: A constant holding the minimum value an int can have (Java Integer.MIN_VALUE)      \\#nan, value= NaN, Comment: A constant holding a Not-a-Number (NaN) value of type float (Java Double.POSITIVE_INFINITY)      \\#pi, value= 3.141592653589793, Comment: The PI constant      \\#to_deg, value= 57.29577951308232, Comment: A constant holding the value to convert radians into degrees      \\#to_rad, value= 0.017453292519943295, Comment: A constant holding the value to convert degrees into radians     Graphics units     \\#bold, value= 1, Comment: This constant allows to build a font with a bold face. Can be combined with #italic      \\#camera_location, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current position of the camera as a point      \\#camera_orientation, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current orientation of the camera as a point      \\#camera_target, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current target of the camera as a point      \\#display_height, value= 1.0, Comment: This constant is only accessible in a graphical context: display, graphics…      \\#display_width, value= 1.0, Comment: This constant is only accessible in a graphical context: display, graphics…      \\#flat, value= 2, Comment: This constant represents a flat line buffer end cap style      \\#horizontal, value= 3, Comment: This constant represents a layout where all display views are aligned horizontally      \\#italic, value= 2, Comment: This constant allows to build a font with an italic face. Can be combined with #bold      \\#none, value= 0, Comment: This constant represents the absence of a predefined layout      \\#pixels (#px), value= 1.0, Comment: This unit, only available when running aspects or declaring displays,  returns a dynamic value instead of a fixed one. px (or pixels), returns the value of one pixel on the current view in terms of model units.      \\#plain, value= 0, Comment: This constant allows to build a font with a plain face      \\#round, value= 1, Comment: This constant represents a round line buffer end cap style      \\#split, value= 2, Comment: This constant represents a layout where all display views are split in a grid-like structure      \\#square, value= 3, Comment: This constant represents a square line buffer end cap style      \\#stack, value= 1, Comment: This constant represents a layout where all display views are stacked      \\#user_location, value= No Default Value, Comment: This unit contains in permanence the location of the mouse on the display in which it is situated. The latest location is provided when it is out of a display      \\#vertical, value= 4, Comment: This constant represents a layout where all display views are aligned vertically      \\#zoom, value= 1.0, Comment: This unit, only available when running aspects or declaring displays, returns the current zoom level of the display as a positive float, where 1.0 represent the neutral zoom (100%)     Length units     \\#cm (#centimeter,#centimeters), value= 0.009999999776482582, Comment: centimeter unit      \\#dm (#decimeter,#decimeters), value= 0.10000000149011612, Comment: decimeter unit      \\#foot (#feet,#ft), value= 0.3047999931871891, Comment: foot unit      \\#inch (#inches), value= 0.025399999432265757, Comment: inch unit      \\#km (#kilometer,#kilometers), value= 1000.0, Comment: kilometer unit      \\#m (#meter,#meters), value= 1.0, Comment: meter: the length basic unit      \\#mile (#miles), value= 1609.344, Comment: mile unit      \\#mm (#milimeter,#milimeters), value= 9.999999776482583E-4, Comment: millimeter unit      \\#yard (#yards), value= 0.9144, Comment: yard unit     Surface units     \\#m2, value= 1.0, Comment: square meter: the basic unit for surfaces      \\#sqft (#square_foot,#square_feet), value= 0.09290303584691051, Comment: square foot unit      \\#sqin (#square_inch,#square_inches), value= 6.451599711591008E-4, Comment: square inch unit      \\#sqmi (#square_mile,#square_miles), value= 2589988.110336, Comment: square mile unit     Time units     \\#custom, value= CUSTOM, Comment: custom: a custom date/time pattern that can be defined in the preferences of GAMA and reused in models      \\#cycle (#cycles), value= 1, Comment: cycle: the discrete measure of time in the simulation. Used to force a temporal expression to be expressed in terms of cycles rather than seconds      \\#day (#days), value= 86400.0, Comment: day time unit: defines an exact duration of 24 hours      \\#epoch, value= No Default Value, Comment: The epoch default starting date as defined by the ISO format (1970-01-01T00:00Z)      \\#h (#hour,#hours), value= 3600.0, Comment: hour time unit: defines an exact duration of 60 minutes      \\#iso_local, value= ISO_LOCAL_DATE_TIME, Comment: iso_local: the standard ISO 8601 output / parsing format for local dates (i.e. with no time-zone information)      \\#iso_offset, value= ISO_OFFSET_DATE_TIME, Comment: iso_offset: the standard ISO 8601 output / parsing format for dates with a time offset      \\#iso_zoned, value= ISO_ZONED_DATE_TIME, Comment: iso_zoned: the standard ISO 8601 output / parsing format for dates with a time zone      \\#minute (#minutes,#mn), value= 60.0, Comment: minute time unit: defined an exact duration of 60 seconds      \\#month (#months), value= 2592000.0, Comment: month time unit: does not define an exact duration. The duration will depend on the step/date at which this unit is computed.      \\#msec (#millisecond,#milliseconds,#ms), value= 0.001, Comment: millisecond time unit: defines an exact duration of 0.001 second      \\#now, value= 1.0, Comment: This value represents the current date      \\#sec (#second,#seconds,#s), value= 1.0, Comment: second: the time basic unit, with a fixed value of 1. All other durations are expressed with respect to it      \\#week (#weeks), value= 604800.0, Comment: week time unit: defines an exact duration of  7 days      \\#year (#years,#y), value= 3.1104E7, Comment: year time unit: does not define an exact duration. The duration will depend on the step/date at which this unit is computed.     Volume units     \\#cl (#centiliter,#centiliters), value= 1.0E-5, Comment: centiliter unit      \\#dl (#deciliter,#deciliters), value= 1.0E-4, Comment: deciliter unit      \\#hl (#hectoliter,#hectoliters), value= 0.1, Comment: hectoliter unit      \\#l (#liter,#liters,#dm3), value= 0.001, Comment: liter unit      \\#m3, value= 1.0, Comment: cube meter: the basic unit for volumes     Weight units     \\#gram (#grams), value= 0.001, Comment: gram unit      \\#kg (#kilo,#kilogram,#kilos), value= 1.0, Comment: second: the basic unit for weights      \\#longton (#lton), value= 1016.0469088000001, Comment: short ton unit      \\#ounce (#oz,#ounces), value= 0.028349523125, Comment: ounce unit      \\#pound (#lb,#pounds,#lbm), value= 0.45359237, Comment: pound unit      \\#shortton (#ston), value= 907.18474, Comment: short ton unit      \\#stone (#st), value= 6.35029318, Comment: stone unit      \\#ton (#tons), value= 1000.0, Comment: ton unit     Colors  In addition to the previous units, GAML provides a direct access to the 147 named colors defined in CSS (see http://www.cssportal.com/css3-color-names/). E.g,  rgb my_color <- °teal;      \\#aliceblue, value= r=240, g=248, b=255, alpha=1      \\#antiquewhite, value= r=250, g=235, b=215, alpha=1      \\#aqua, value= r=0, g=255, b=255, alpha=1      \\#aquamarine, value= r=127, g=255, b=212, alpha=1      \\#azure, value= r=240, g=255, b=255, alpha=1      \\#beige, value= r=245, g=245, b=220, alpha=1      \\#bisque, value= r=255, g=228, b=196, alpha=1      \\#black, value= r=0, g=0, b=0, alpha=1      \\#blanchedalmond, value= r=255, g=235, b=205, alpha=1      \\#blue, value= r=0, g=0, b=255, alpha=1      \\#blueviolet, value= r=138, g=43, b=226, alpha=1      \\#brown, value= r=165, g=42, b=42, alpha=1      \\#burlywood, value= r=222, g=184, b=135, alpha=1      \\#cadetblue, value= r=95, g=158, b=160, alpha=1      \\#chartreuse, value= r=127, g=255, b=0, alpha=1      \\#chocolate, value= r=210, g=105, b=30, alpha=1      \\#coral, value= r=255, g=127, b=80, alpha=1      \\#cornflowerblue, value= r=100, g=149, b=237, alpha=1      \\#cornsilk, value= r=255, g=248, b=220, alpha=1      \\#crimson, value= r=220, g=20, b=60, alpha=1      \\#cyan, value= r=0, g=255, b=255, alpha=1      \\#darkblue, value= r=0, g=0, b=139, alpha=1      \\#darkcyan, value= r=0, g=139, b=139, alpha=1      \\#darkgoldenrod, value= r=184, g=134, b=11, alpha=1      \\#darkgray, value= r=169, g=169, b=169, alpha=1      \\#darkgreen, value= r=0, g=100, b=0, alpha=1      \\#darkgrey, value= r=169, g=169, b=169, alpha=1      \\#darkkhaki, value= r=189, g=183, b=107, alpha=1      \\#darkmagenta, value= r=139, g=0, b=139, alpha=1      \\#darkolivegreen, value= r=85, g=107, b=47, alpha=1      \\#darkorange, value= r=255, g=140, b=0, alpha=1      \\#darkorchid, value= r=153, g=50, b=204, alpha=1      \\#darkred, value= r=139, g=0, b=0, alpha=1      \\#darksalmon, value= r=233, g=150, b=122, alpha=1      \\#darkseagreen, value= r=143, g=188, b=143, alpha=1      \\#darkslateblue, value= r=72, g=61, b=139, alpha=1      \\#darkslategray, value= r=47, g=79, b=79, alpha=1      \\#darkslategrey, value= r=47, g=79, b=79, alpha=1      \\#darkturquoise, value= r=0, g=206, b=209, alpha=1      \\#darkviolet, value= r=148, g=0, b=211, alpha=1      \\#deeppink, value= r=255, g=20, b=147, alpha=1      \\#deepskyblue, value= r=0, g=191, b=255, alpha=1      \\#dimgray, value= r=105, g=105, b=105, alpha=1      \\#dimgrey, value= r=105, g=105, b=105, alpha=1      \\#dodgerblue, value= r=30, g=144, b=255, alpha=1      \\#firebrick, value= r=178, g=34, b=34, alpha=1      \\#floralwhite, value= r=255, g=250, b=240, alpha=1      \\#forestgreen, value= r=34, g=139, b=34, alpha=1      \\#fuchsia, value= r=255, g=0, b=255, alpha=1      \\#gainsboro, value= r=220, g=220, b=220, alpha=1      \\#ghostwhite, value= r=248, g=248, b=255, alpha=1      \\#gold, value= r=255, g=215, b=0, alpha=1      \\#goldenrod, value= r=218, g=165, b=32, alpha=1      \\#gray, value= r=128, g=128, b=128, alpha=1      \\#green, value= r=0, g=128, b=0, alpha=1      \\#greenyellow, value= r=173, g=255, b=47, alpha=1      \\#grey, value= r=128, g=128, b=128, alpha=1      \\#honeydew, value= r=240, g=255, b=240, alpha=1      \\#hotpink, value= r=255, g=105, b=180, alpha=1      \\#indianred, value= r=205, g=92, b=92, alpha=1      \\#indigo, value= r=75, g=0, b=130, alpha=1      \\#ivory, value= r=255, g=255, b=240, alpha=1      \\#khaki, value= r=240, g=230, b=140, alpha=1      \\#lavender, value= r=230, g=230, b=250, alpha=1      \\#lavenderblush, value= r=255, g=240, b=245, alpha=1      \\#lawngreen, value= r=124, g=252, b=0, alpha=1      \\#lemonchiffon, value= r=255, g=250, b=205, alpha=1      \\#lightblue, value= r=173, g=216, b=230, alpha=1      \\#lightcoral, value= r=240, g=128, b=128, alpha=1      \\#lightcyan, value= r=224, g=255, b=255, alpha=1      \\#lightgoldenrodyellow, value= r=250, g=250, b=210, alpha=1      \\#lightgray, value= r=211, g=211, b=211, alpha=1      \\#lightgreen, value= r=144, g=238, b=144, alpha=1      \\#lightgrey, value= r=211, g=211, b=211, alpha=1      \\#lightpink, value= r=255, g=182, b=193, alpha=1      \\#lightsalmon, value= r=255, g=160, b=122, alpha=1      \\#lightseagreen, value= r=32, g=178, b=170, alpha=1      \\#lightskyblue, value= r=135, g=206, b=250, alpha=1      \\#lightslategray, value= r=119, g=136, b=153, alpha=1      \\#lightslategrey, value= r=119, g=136, b=153, alpha=1      \\#lightsteelblue, value= r=176, g=196, b=222, alpha=1      \\#lightyellow, value= r=255, g=255, b=224, alpha=1      \\#lime, value= r=0, g=255, b=0, alpha=1      \\#limegreen, value= r=50, g=205, b=50, alpha=1      \\#linen, value= r=250, g=240, b=230, alpha=1      \\#magenta, value= r=255, g=0, b=255, alpha=1      \\#maroon, value= r=128, g=0, b=0, alpha=1      \\#mediumaquamarine, value= r=102, g=205, b=170, alpha=1      \\#mediumblue, value= r=0, g=0, b=205, alpha=1      \\#mediumorchid, value= r=186, g=85, b=211, alpha=1      \\#mediumpurple, value= r=147, g=112, b=219, alpha=1      \\#mediumseagreen, value= r=60, g=179, b=113, alpha=1      \\#mediumslateblue, value= r=123, g=104, b=238, alpha=1      \\#mediumspringgreen, value= r=0, g=250, b=154, alpha=1      \\#mediumturquoise, value= r=72, g=209, b=204, alpha=1      \\#mediumvioletred, value= r=199, g=21, b=133, alpha=1      \\#midnightblue, value= r=25, g=25, b=112, alpha=1      \\#mintcream, value= r=245, g=255, b=250, alpha=1      \\#mistyrose, value= r=255, g=228, b=225, alpha=1      \\#moccasin, value= r=255, g=228, b=181, alpha=1      \\#navajowhite, value= r=255, g=222, b=173, alpha=1      \\#navy, value= r=0, g=0, b=128, alpha=1      \\#oldlace, value= r=253, g=245, b=230, alpha=1      \\#olive, value= r=128, g=128, b=0, alpha=1      \\#olivedrab, value= r=107, g=142, b=35, alpha=1      \\#orange, value= r=255, g=165, b=0, alpha=1      \\#orangered, value= r=255, g=69, b=0, alpha=1      \\#orchid, value= r=218, g=112, b=214, alpha=1      \\#palegoldenrod, value= r=238, g=232, b=170, alpha=1      \\#palegreen, value= r=152, g=251, b=152, alpha=1      \\#paleturquoise, value= r=175, g=238, b=238, alpha=1      \\#palevioletred, value= r=219, g=112, b=147, alpha=1      \\#papayawhip, value= r=255, g=239, b=213, alpha=1      \\#peachpuff, value= r=255, g=218, b=185, alpha=1      \\#peru, value= r=205, g=133, b=63, alpha=1      \\#pink, value= r=255, g=192, b=203, alpha=1      \\#plum, value= r=221, g=160, b=221, alpha=1      \\#powderblue, value= r=176, g=224, b=230, alpha=1      \\#purple, value= r=128, g=0, b=128, alpha=1      \\#red, value= r=255, g=0, b=0, alpha=1      \\#rosybrown, value= r=188, g=143, b=143, alpha=1      \\#royalblue, value= r=65, g=105, b=225, alpha=1      \\#saddlebrown, value= r=139, g=69, b=19, alpha=1      \\#salmon, value= r=250, g=128, b=114, alpha=1      \\#sandybrown, value= r=244, g=164, b=96, alpha=1      \\#seagreen, value= r=46, g=139, b=87, alpha=1      \\#seashell, value= r=255, g=245, b=238, alpha=1      \\#sienna, value= r=160, g=82, b=45, alpha=1      \\#silver, value= r=192, g=192, b=192, alpha=1      \\#skyblue, value= r=135, g=206, b=235, alpha=1      \\#slateblue, value= r=106, g=90, b=205, alpha=1      \\#slategray, value= r=112, g=128, b=144, alpha=1      \\#slategrey, value= r=112, g=128, b=144, alpha=1      \\#snow, value= r=255, g=250, b=250, alpha=1      \\#springgreen, value= r=0, g=255, b=127, alpha=1      \\#steelblue, value= r=70, g=130, b=180, alpha=1      \\#tan, value= r=210, g=180, b=140, alpha=1      \\#teal, value= r=0, g=128, b=128, alpha=1      \\#thistle, value= r=216, g=191, b=216, alpha=1      \\#tomato, value= r=255, g=99, b=71, alpha=1      \\#transparent, value= r=0, g=0, b=0, alpha=0      \\#turquoise, value= r=64, g=224, b=208, alpha=1      \\#violet, value= r=238, g=130, b=238, alpha=1      \\#wheat, value= r=245, g=222, b=179, alpha=1      \\#white, value= r=255, g=255, b=255, alpha=1      \\#whitesmoke, value= r=245, g=245, b=245, alpha=1      \\#yellow, value= r=255, g=255, b=0, alpha=1      \\#yellowgreen, value= r=154, g=205, b=50, alpha=1  ","url":"wiki/UnitsAndConstantsPDF.md"},{"id":"wiki/VariablesAndAttributes.md","title":" Variables and Attributes","content":"Variables and Attributes  Variables and attributes represent named data that can be used in an expression. They can be accessed depending on their scope:   * the scope of attributes declared in a species is itself, its child species and its micro-species.   * the scope of temporary variables is the one in which they have been declared, and all its sub-scopes. Outside its scope of validity, an expression cannot use a variable or an attribute directly. However, attributes can be used in a remote fashion by using a dotted notation on a given agent (see here).  Table of contents     Variables and Attributes  Direct Access       Remote Access Direct Access When an agent wants to use either one of the variables declared locally, one of the attributes declared in its species (or parent species), one of the attributes declared in the macro-species of its species, it can directly invoke its name and the compiler will do the rest (i.e. finding the variable or attribute in the right scope). For instance, we can have a look at the following example:      species animal {    float energy <- 1000 min: 0 max: 2000 update: energy - 0.001;    int age_in_years <- 1 update: age_in_years + int (time / 365);  action eat (float amount <- 0) { float gain <- amount / age_in_years; energy <- energy + gain;    }  reflex feed {       int food_found <- rnd(100);       do eat (amount: food_found);     }  }         Species declaration > Everywhere in the species declaration, we are able to directly name and use:  time, a global built-in variable,       energy and age_in_years, the two species attributes. > Nevertheless, in the species declaration, but outside of the action eat and the reflex feed, we cannot name the variables:       amount, the argument of eat action,       gain, a local variable defined into the eat action,       food_found, the local variable defined into the feed reflex. Eat action declaration > In the eat action declaration, we can directly name and use:  time, a global built-in variable,       energy and age_in_years, the two species attributes,       amount, which is an argument to the action eat,       gain, a temporary variable within the action. > We cannot name and use the variables:       food_found, the local variable defined into the feed reflex. feed reflex declaration > Similarly, in the feed reflex declaration, we can directly name and use:  time, a global built-in variable,       energy and age_in_years, the two species variables,       food_found, the local variable defined into the reflex. > But we cannot access to variables:       amount, the argument of eat action,       gain, a local variable defined into the eat action. Remote Access When an expression needs to get access to the attribute of an agent which does not belong to its scope of execution, a special notation (similar to that used in Java) has to be used:   remote_agent.variable   where remote_agent can be the name of an agent, an expression returning an agent, self, myself or each. For instance, if we modify the previous species by giving its agents the possibility to feed another agent found in its neighbourhood, the result would be:   species animal {    float energy <- 1000 min: 0 max: 2000 update: energy - 0.001;    int age_in_years <- 1 update: age_in_years + int (time / 365);    action eat (float amount <- 0.0) { float gain <- amount / age_in_years; energy <- energy + gain;    }    action feed (animal target){ if (agent_to_feed != nil) and (agent_to_feed.energy < energy { // verifies that the agent exists and that it need to be fed   ask agent_to_feed {       do eat amount: myself.energy / 10; // asks the agent to eat 10% of our own energy   }   energy <- energy - (energy / 10); // reduces the energy by 10% }    }    reflex { animal candidates <- agents_overlapping (10 around agent.shape); gathers all the neighbours agent_to_feed value: candidates with_min_of (each.energy); //grabs one agent with the lowest energy  do feed target: agent_to_feed; // tries to feed it    } }   In this example, agent_to_feed.energy, myself.energy and each.energy show different remote accesses to the attribute energy. The dotted notation used here can be employed in assignments as well. For instance, an action allowing two agents to exchange their energy could be defined as:   action random_exchange {//exchanges our energy with that of the closest agent      animal one_agent <- agent_closest_to (self)/>      float temp  <-one_agent.energy; // temporary storage of the agent s energy      one_agent.energy <- energy; // assignment of the agent s energy with our energy      energy <- temp; }  ","url":"wiki/VariablesAndAttributes.md"},{"id":"wiki/Diffusion-Statement-Anisotropic-Diffusion-(Simple).md","title":" Anisotropic diffusion (Simple)","content":"# Anisotropic diffusion (Simple)  Author : Benoit Gaudou  This model is used to show how to construct an anisotropic diffusion through a grid. The cell at the center of the grid emit a pheromon at each step, which is spread through the grid thanks to the diffusion mechanism, using a particular matrix of diffusion.   == $0 Code of the model :       model anisotropic_diffusion  global {  int size <- 64; // better to have a pow of 2 for the size of the grid    geometry shape <- envelope(square(size) * 10);    cells selected_cells;     // Declare the anisotropic matrix (diffuse to the left-upper direction) matrix<float> mat_diff <- matrix([         [4/9,2/9,0/9],         [2/9,1/9,0.0],         [0/9,0.0,0.0]]);  reflex diff {   diffuse var: phero on: cells matrix:mat_diff; }  // Initialize the emiter cell as the cell at the center of the word init {  selected_cells <- location as cells; } reflex new_Value {  ask selected_cells {   phero <- 1.0;  } } }   grid cells height: size width: size {  //  phero  is the variable storing the value of the diffusion  float phero  <- 0.0;  // the color of the cell is linked to the value of  phero .  rgb color <- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);  // Update the  grid_value , which will be used for the elevation of the cell  float grid_value update: phero * 100; }  experiment diffusion type: gui {  output {   display a type: opengl {    // Display the grid with elevation    grid cells elevation: true triangulation: true;   }  } }     ","url":"wiki/Diffusion-Statement-Anisotropic-Diffusion-(Simple).md"},{"id":"wiki/Diffusion-Statement-Anisotropic-Diffusion-(Toroidal).md","title":" Anisotropic diffusion (Toroidal)","content":"# Anisotropic diffusion (Toroidal)  Author : Benoit Gaudou  This model is used to show how to construct an anisotropic diffusion through a grid. The cell at the center of the grid emit a pheromon at each step, which is spread through the grid thanks to the diffusion mechanism, using a particular matrix of diffusion, in a toroidal world.   == $0 Code of the model :       model anisotropic_diffusion_torus  global torus: true {  int size <- 64; // better to have a pow of 2 for the size of the grid    geometry shape <- envelope(square(size) * 10);    cells selected_cells;    matrix mat_diff <- matrix([          [4/9,2/9,0/9],          [2/9,1/9,0.0],          [0/9,0.0,0.0]]);  init {   selected_cells <- location as cells;  }  reflex new_Value {   ask selected_cells{    phero <- 1.0;   }    }  reflex diff {  diffuse var: phero on: cells matrix: mat_diff method:dot_product;  } }   grid cells height: size width: size  {  float phero  <- 0.0;  rgb color <- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);  float grid_value update: phero * 100; }  experiment diffusion type: gui {  output {   display a type: opengl {    grid cells elevation: true triangulation: true;   }  } }     ","url":"wiki/Diffusion-Statement-Anisotropic-Diffusion-(Toroidal).md"},{"id":"wiki/Diffusion-Statement-Anisotropic-Diffusion-(Various-Methods).md","title":" Anisotropic diffusion with several computation method","content":"# Anisotropic diffusion with several computation method  Author : Benoit Gaudou  This model is used to show two different computation methods to use diffusion : with the dot product method and with the convolution method. The cell at the center of the grid emit a pheromon at each step, which is spread through the grid thanks to the diffusion mechanism, using a particular matrix of diffusion.   == $0  == $0 Code of the model :       model diffusion_computation_method  global{  int size <- 64; // better to have a pow of 2 for the size of the grid    geometry shape <- envelope(square(size) * 10);    cells_dot selected_cells_dot;    cells_convol selected_cells_convol;    // Declare the anisotropic matrix (diffuse to the left-upper direction)    matrix mat_diff <- matrix([          [2/9,2/9,1/9],          [2/9,1/9,0.0],          [1/9,0.0,0.0]]);  // Initialize the emiter cell as the cell at the center of the word init {  selected_cells_dot <- location as cells_dot;     selected_cells_convol <- location as cells_convol; } reflex new_Value {  ask(selected_cells_dot){   phero <- 1.0;  }  ask(selected_cells_convol){   phero <- 1.0;  }   }  reflex diff {  // Declare a diffusion on the grid cells_dot (with a dot product computation) and on cells_convol (with a convol computation).   // The value of the diffusion will be store in the new variable phero of the cell.  diffuse var: phero on: cells_dot matrix: mat_diff method: dot_product;   diffuse var: phero on: cells_convol matrix: mat_diff method: convolution;    } }   grid cells_dot height: size width: size {  //  phero  is the variable storing the value of the diffusion  float phero  <- 0.0;  // The color of the cell is linked to the value of  phero .  rgb color <- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);  // Update the  grid_value , which will be used for the elevation of the cell  float grid_value update: phero * 100; }  grid cells_convol height: size width: size {  //  phero  is the variable storing the value of the diffusion  float phero  <- 0.0;  // The color of the cell is linked to the value of  phero .  rgb color <- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);  // Update the  grid_value , which will be used for the elevation of the cell  float grid_value update: phero * 100; }  experiment diffusion type: gui {  output {   display dot type: opengl {    // Display the grid with elevation    grid cells_dot elevation: true triangulation: true;   }   display convol type: opengl {    // Display the grid with elevation    grid cells_convol elevation: true triangulation: true;   }  } }     ","url":"wiki/Diffusion-Statement-Anisotropic-Diffusion-(Various-Methods).md"},{"id":"wiki/Diffusion-Statement-Blend-color-in-a-cuve-(Multiple-Signals).md","title":" Blend color in a cuve","content":"# Blend color in a cuve  Author : Julien Mazars  This model is used to show how we can diffuse several variables in the same grid. At the cycle 0, 3 different pheromons are emited in 3 of the 4 corners of the cuve (each one associated to a color). Thanks to the diffusion mechanism, all the 3 colors will blend each other. The process is accelerated by using the facet  cycle_length . The  avoid_mask  facet is used in order to have a constant sum of pheromon.   == $0 Code of the model :       model cycle_length  global {  int size <- 64; // better to have a pow of 2 for the size of the grid  int cycle_length <- 5;    geometry shape <- envelope(square(size));    list top_left_cells;    list top_right_cells;    list bot_left_cells;    // Declare the uniform matrix    matrix mat_diff <- matrix([          [1/9,1/9,1/9],          [1/9,1/9,1/9],          [1/9,1/9,1/9]]);  // Initialize the emiter cells init {  top_left_cells <- list<cells>(cells where (each.grid_x < location.x   and each.grid_x > cycle_length   and each.grid_y < location.y   and each.grid_y > cycle_length  ));  top_right_cells <- list<cells>(cells where (each.grid_x < size-cycle_length   and each.grid_x > location.x   and each.grid_y < location.y   and each.grid_y > cycle_length  ));  bot_left_cells <- list<cells>(cells where (each.grid_x < location.x   and each.grid_x > cycle_length   and each.grid_y < size-cycle_length   and each.grid_y > location.y  )); } reflex init_value when:cycle=0 {  ask(top_left_cells){   phero1 <- 1.0;  }  ask(top_right_cells){   phero2 <- 1.0;  }  ask(bot_left_cells){   phero3 <- 1.0;  }  }  reflex diff {  // Declare a diffusion on the grid cells for each one of the pheromons.   // In order to not loosing phero value, we apply a hand made mask (with the operator where) and we turn the avoid_mask facet to true.  list cells_where_diffuse <- cells where (each.grid_x < size-cycle_length and each.grid_x > cycle_length and each.grid_y < size-cycle_length and each.grid_y > cycle_length);  diffuse var: phero1 on: cells_where_diffuse matrix: mat_diff avoid_mask: true method:dot_product cycle_length:cycle_length;  diffuse var: phero2 on: cells_where_diffuse matrix: mat_diff avoid_mask: true method:dot_product cycle_length:cycle_length;  diffuse var: phero3 on: cells_where_diffuse matrix: mat_diff avoid_mask: true method:dot_product cycle_length:cycle_length; } }   grid cells height: size width: size {  //  phero1 ,  phero2 ,  phero3  are the variables storing the value of the diffusion  float phero1  <- 0.0;  float phero2  <- 0.0;  float phero3  <- 0.0;  // The color of the cell is construct using the 3 pheromons.  rgb color <- rgb(phero1256,phero2256,phero3256) update: rgb(phero1256,phero2256,phero3256); }  experiment diffusion type: gui {  output {   display a type: opengl {    // Display the grid with elevation    grid cells elevation: (phero1+phero2+phero3)*10 triangulation: true;   }  } }     ","url":"wiki/Diffusion-Statement-Blend-color-in-a-cuve-(Multiple-Signals).md"},{"id":"wiki/Diffusion-Statement-Diffusion-in-a-cuve-(Cycle-length).md","title":" Diffusion in a cuve (Cycle length)","content":"# Diffusion in a cuve (Cycle length)  Author : Julien Mazars  This model is used to show how to use diffusion on a grid, and how to accelerate the process by computing several times the diffusion at each step. The cells at the center of the grid emit a pheromon at the cycle 0, which is spread through the grid thanks to the diffusion mechanism, using a particular matrix of diffusion. The  avoid_mask  facet is used in order to have a constant sum of pheromon.   == $0  == $0 Code of the model :       model cycle_length  global {  int size <- 64; // better to have a pow of 2 for the size of the grid  int cycle_length <- 5;    geometry shape <- envelope(square(size));    list selected_cells;    list selected_quick_cells;    // Declare an uniform diffusion matrix    matrix mat_diff <- matrix([          [1/9,1/9,1/9],          [1/9,1/9,1/9],          [1/9,1/9,1/9]]);  int impulse_area_size <- 6;  // Initialize the emiter cells as the cells at the center of the word init {  selected_cells <- list<cells>(cells where (each.grid_x < location.x+impulse_area_size   and each.grid_x > location.x-impulse_area_size   and each.grid_y < location.y+impulse_area_size   and each.grid_y > location.y-impulse_area_size  ));  selected_quick_cells <- list<quick_cells>(quick_cells where (each.grid_x < location.x+impulse_area_size   and each.grid_x > location.x-impulse_area_size   and each.grid_y < location.y+impulse_area_size   and each.grid_y > location.y-impulse_area_size  )); } reflex init_value when:cycle=0 {  ask(selected_cells){   phero <- 1.0;  }  ask(selected_quick_cells){   phero <- 1.0;  }   }  reflex diff {  // Declare a diffusion on the grid cells and on quick_cells. The diffusion declared on quick_cells will make 5 computations at each step to accelerate the process.   // The value of the diffusion will be store in the new variable phero of the cell.  // In order to not loosing phero value, we apply a hand made mask (with the operator where) and we turn the avoid_mask facet to true.  list cells_where_diffuse <- cells where (each.grid_x < size-cycle_length and each.grid_x > cycle_length and each.grid_y < size-cycle_length and each.grid_y > cycle_length);  diffuse var: phero on: cells_where_diffuse matrix: mat_diff avoid_mask: true method:dot_product;   list quick_cells_where_diffuse <- quick_cells where (each.grid_x < size-cycle_length and each.grid_x > cycle_length and each.grid_y < size-cycle_length and each.grid_y > cycle_length);  diffuse var: phero on: quick_cells_where_diffuse matrix: mat_diff avoid_mask: true cycle_length: 10 method:dot_product; } }   grid cells height: size width: size {  //  phero  is the variable storing the value of the diffusion  float phero  <- 0.0;  // The color of the cell is linked to the value of  phero .  rgb color <- (phero = 0) ? #black : hsb(phero,1.0,1.0) update: (phero = 0) ? #black : hsb(phero,1.0,1.0); }  grid quick_cells height: size width: size {  //  phero  is the variable storing the value of the diffusion  float phero  <- 0.0;  // The color of the cell is linked to the value of  phero .  rgb color <- (phero = 0) ? #black : hsb(phero,1.0,1.0) update: (phero = 0) ? #black : hsb(phero,1.0,1.0); }  experiment diffusion type: gui {  output {   display a type: opengl {    // Display the grid with elevation    grid cells elevation: phero10 triangulation: true;   }   display quick type: opengl {    // Display the grid with elevation    grid quick_cells elevation: phero10 triangulation: true;   }  } }     ","url":"wiki/Diffusion-Statement-Diffusion-in-a-cuve-(Cycle-length).md"},{"id":"wiki/Diffusion-Statement-Kernel-matrix-generation.md","title":" Generate diffusion matrix with parameters","content":"# Generate diffusion matrix with parameters  Author : Julien Mazars  This model shows how to create a diffusion matrix by using the 4 parameters variation, proportion, radius and min-value. Manipulate the parameters to see in real time the result. The number displayed in each cells are the ratio of the initial signal diffused at the end of a step.   == $0 Code of the model :       model kernelmatrixgeneration  global {  // parameters  float variation <- 0.0;  float proportion <- 1.0;  int radius <- 1;  float min_value <- 0.0;  int cycle_length <- 1;  // global variables int cell_max_size <- 51; int x_min <- cell_max_size; int x_max <- 0; int y_min <- cell_max_size; int y_max <- 0;  float world_size <- 100.0; geometry shape <- cube(world_size);  buffer_cells selected_cells;  // init the emiter cell as the one in the center of the world. init {  selected_cells <- location as buffer_cells;  // no need to have a faster display. Let s cool down your computer a bit ;)  minimum_cycle_duration <- 200#ms; }  reflex update {  x_min <- cell_max_size;  x_max <- 0;  y_min <- cell_max_size;  y_max <- 0;  // copy the values of the buffer_cells (of the previous step) to the grid which will be displayed.  ask cells {   value <- (location as buffer_cells).value;  }  ask buffer_cells {   // find the boundaries of the diffusion   if (value != 0.0) {    if (grid_x > x_max) {     x_max <- grid_x;    }    if (grid_x < x_min) {     x_min <- grid_x;    }    if (grid_y > y_max) {     y_max <- grid_y;    }    if (grid_y < y_min) {     y_min <- grid_y;    }   }  }  // re-initialize the value of the buffer grid to 0, and the value of the central cell to 1.  ask buffer_cells {   value <- 0.0;   if (self = selected_cells) {    value <- 1.0;   }  }  // diffuse the value over the buffer grid, according to the parameters choosen.  diffuse var:value on:buffer_cells variation:variation proportion:proportion radius:radius cycle_length:cycle_length min_value:min_value; } }   // the buffer grid will be used to compute the diffusion at each step. grid buffer_cells height:cell_max_size width:cell_max_size {  // the diffused variable  float value <- 0.0; }  // this grid is the copy of the buffer grid at the end of each step. Indeed, we have to display the grid once the diffusion has been done. grid cells height:cell_max_size width:cell_max_size {  // the diffused variable  float value <- 0.0;  aspect base {  // we only display the cells wich contains a non null value  if (grid_x <= x_max and grid_x >= x_min and grid_y <= y_max and grid_y >= y_min)  {   // compute dynamically the size of the current cell.   float size_cell <- world_size/(x_max-x_min+1);   // compute dynamically the position of the current cell.   point pos <- {(grid_x-x_min+1)*size_cell-0.5*size_cell,(grid_y-y_min+1)*size_cell-0.5*size_cell};   // display each cell as a square. The color is linked to the value of the diffused variable.   draw square(size_cell) color:hsb(value,1.0,1.0) border:#black at:pos;   // display the ratio in each square.   draw string(value) at: pos + {-size_cell/3,0} color: °black font: font(Helvetica, size_cell * #zoom * 2/3, #bold) perspective:true;  } } }   experiment my_experiment type:gui {  parameter  proportion  var:proportion;  parameter  variation  var:variation;  parameter  min_value  var:min_value;  parameter  radius  var:radius;  parameter  cycle_length  var:cycle_length;  output {   display my_display {    species cells aspect:base;   }  } }     ","url":"wiki/Diffusion-Statement-Kernel-matrix-generation.md"},{"id":"wiki/Diffusion-Statement-Uniform-Diffusion.md","title":" Uniform diffusion","content":"# Uniform diffusion  Author : Benoit Gaudou  This model is used to show how a diffusion works with a uniform matrix of diffusion in a grid. The cell at the center of the grid emit a pheromon at each step, which is spread through the grid thanks to the diffusion mechanism. Without passing a diffusion matrix, the default diffusion matrix is a uniform matrix 3x3, with value 1/nb_neighbors.   == $0  == $0 Code of the model :       model uniform_diffusion  global {  int size <- 64; // better to have a pow of 2 for the size of the grid    geometry shape <- envelope(square(size) * 10);    cells_eight_nb selected_cells_8;    cells_four_nb selected_cells_4;  // Initialize the emiter cell as the cell at the center of the word init {  selected_cells_8 <- location as cells_eight_nb;  selected_cells_4 <- location as cells_four_nb; } reflex new_Value {  ask selected_cells_4 {   phero <- 1.0;  }  ask selected_cells_8 {   phero <- 1.0;  } } reflex diff {  // Declare a diffusion on the grid cells, with a uniform matrix of diffusion. The value of the diffusion  // will be store in the new variable phero of the cell.  diffuse var: phero on: cells_eight_nb ;  diffuse var: phero on: cells_four_nb ; } }   grid cells_eight_nb height: size width: size neighbors: 8 {  //  phero  is the variable storing the value of the diffusion  float phero  <- 0.0;  // the color of the cell is linked to the value of  phero .  rgb color <- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);  // Update the  grid_value , which will be used for the elevation of the cell  float grid_value update: phero * 100; }  grid cells_four_nb height: size width: size neighbors: 4 {  //  phero  is the variable storing the value of the diffusion  float phero  <- 0.0;  // the color of the cell is linked to the value of  phero .  rgb color <- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);  // Update the  grid_value , which will be used for the elevation of the cell  float grid_value update: phero * 100; }  experiment diffusion type: gui {  output {   display uniform_diffusion_in_8_neighbors_grid type: opengl {    // Display the grid with elevation    grid cells_eight_nb elevation: true triangulation: true;   }   display uniform_diffusion_in_4_neighbors_grid type: opengl {    // Display the grid with elevation    grid cells_four_nb elevation: true triangulation: true;   }  } }     ","url":"wiki/Diffusion-Statement-Uniform-Diffusion.md"},{"id":"wiki/Diffusion-Statement-Uniform-diffusion-with-mask-(Avoid-mask).md","title":" Uniform diffusion with mask (Avoid mask)","content":"# Uniform diffusion with mask (Avoid mask)  Author : Julien Mazars  This model is used to show how a uniform diffusion can be used with a mask. The cell at the center of the grid emit a pheromon at each step, which is spread through the grid thanks to the diffusion mechanism. A mask is used to restrict the diffusion to a  corridor  (the white part of the bmp image). The first display shows a diffusion avoiding the masked cells (the value is redistributed to the neighboring cells, to have a constant number of pheromon), the second display shows a diffusion without avoiding the masked cells (the value is diffused in the masked cell, and never rediffused again).   == $0  == $0 Code of the model :       model diffusion_with_mask  global {  int grid_size <- 64; // better to have a pow of 2 for the size of the grid    geometry shape <- envelope(square(grid_size) * 10);    cells_avoid_mask selected_cells1;    cells_diffuse_on_mask selected_cells2;    // Load the image mask as a matrix. The white part of the image is the part where diffusion will work, and the black part is where diffusion will be blocked.    matrix mymask <- file( ../includes/complex_mask.bmp ) as_matrix({grid_size,grid_size});    // Declare a uniform diffusion matrix    matrix mat_diff <- matrix([          [1/9,1/9,1/9],          [1/9,1/9,1/9],          [1/9,1/9,1/9]]);  // Initialize the emiter cell as the cell at the center of the word  init {   selected_cells1 <- location as cells_avoid_mask;   selected_cells2 <- location as cells_diffuse_on_mask;  }  reflex new_Value {   ask selected_cells1 {    phero <- 1.0;   }   ask selected_cells2 {    phero <- 1.0;   }  }  reflex diff {  // Declare a diffusion on the grid cells. The value of the diffusion will be store in the new variable phero of the cell.  diffuse var: phero on: cells_avoid_mask matrix: mat_diff mask: mymask avoid_mask: true;  diffuse var: phero on: cells_diffuse_on_mask matrix: mat_diff mask: mymask;  } }   grid cells_avoid_mask height: grid_size width: grid_size {  //  phero  is the variable storing the value of the diffusion  float phero <- 0.0;  // the color of the cell is linked to the value of  phero .  rgb color <- (((mymask row_at grid_y) at grid_x) < -1) ? #black : hsb(phero,1.0,1.0) update: (((mymask row_at grid_y) at grid_x) < -1) ? #black : hsb(phero,1.0,1.0);  // Update the  grid_value , which will be used for the elevation of the cell  float grid_value update: phero * 100; }  grid cells_diffuse_on_mask height: grid_size width: grid_size {  //  phero  is the variable storing the value of the diffusion  float phero <- 0.0;  // the color of the cell is linked to the value of  phero .  rgb color <- (((mymask row_at grid_y) at grid_x) < -1) ? #black : hsb(phero,1.0,1.0) update: (((mymask row_at grid_y) at grid_x) < -1) ? #black : hsb(phero,1.0,1.0);  // Update the  grid_value , which will be used for the elevation of the cell  float grid_value update: phero * 100; }  experiment diffusion type: gui {  output {   display a type: opengl {    // Display the grid with elevation    grid cells_avoid_mask elevation: true triangulation: true;   }   display b type: opengl {    // Display the grid with elevation    grid cells_diffuse_on_mask elevation: true triangulation: true;   }  } }     ","url":"wiki/Diffusion-Statement-Uniform-diffusion-with-mask-(Avoid-mask).md"},{"id":"wiki/FIPA-Skill-FIPA-CFP-(1).md","title":" FIPA Contract Net","content":"# FIPA Contract Net  This model demonstrates a use-case of the FIPA Contract Net interaction protocol. One initiator sends a  cfp  message to other participants. All participants reply with a  refuse  messages which end the interaction protocol.  Code of the model :       model cfp_cfp_1  global {  int nbOfParticipants <- 5;  init {  create initiator;  create participant number: nbOfParticipants;   write  Please step the simulation to observe the outcome in the console ; } }   species initiator skills: [fipa] {  reflex send_cfp_to_participants when: (time = 1) {  //list<participant> participants <- list(participant);    write  (Time   + time +  ):   + name +   sends a cfp message to all participants ;  do start_conversation (to: list(participant), protocol:  fipa-contract-net , performative:  cfp , contents: [ Go swimming ]); }  reflex receive_refuse_messages when: !empty(refuses) {  write  (Time   + time +  ):   + name +   receives refuse messages ;    loop r over: refuses {   write     + name +   receives a refuse message from   + r.sender +   with content   + r.contents ;  } } }   species participant skills: [fipa] {  reflex receive_cfp_from_initiator when: !empty(cfps) {    message proposalFromInitiator <- cfps[0];  write  (Time   + time +  ):   + name +   receives a cfp message from   + agent(proposalFromInitiator.sender).name +   and replies with a refuse message ;  do refuse (message: proposalFromInitiator, contents: [ I am busy today ] );   } }   experiment test type: gui {   output {  } }      ","url":"wiki/FIPA-Skill-FIPA-CFP-(1).md"},{"id":"wiki/FIPA-Skill-FIPA-CFP-(2).md","title":" FIPA Contract Net (2)","content":"# FIPA Contract Net (2)  This model demonstrates a use-case of the FIPA Contract Net interaction protocol.  One initiator sends a  cfp  message to 5 participants. The first participants (participant0) replies with a refuse message. Four participants (participant1, participant2, participant3, participant4) reply with four propose messages.  When the initiator receives the propose messages, it proceeds as follows: The initiator replies the participant1 with a reject_proposal message. The initiator replies participant2, participant3, participant4 with three accept_proposal messages respectively.  When participant2, participant3 and participant4 receive the accept_proposal messages from the initiator, they proceed as follows: Participant2 replies with a failure message. Participant3 replies with an inform_done message. Participant4 replies with an inform_result message.  Code of the model :       model cfp_cfp_2  global {  int nbOfParticipants <- 5;  participant refuser;  list proposers;  participant reject_proposal_participant;  list accept_proposal_participants ;  participant failure_participant;  participant inform_done_participant;  participant inform_result_participant;  init {  create initiator;  create participant number: nbOfParticipants returns: ps;    refuser <- ps[0];    add ps all: true to: proposers;  remove refuser from: proposers;    reject_proposal_participant <- proposers[0];    add proposers all: true to: accept_proposal_participants;  remove reject_proposal_participant from: accept_proposal_participants;    failure_participant <- accept_proposal_participants[0];  inform_done_participant <- accept_proposal_participants[1];  inform_result_participant <- accept_proposal_participants[2];    write  Please step the simulation to observe the outcome in the console ; } }   species initiator skills: [fipa] {  reflex send_cfp_to_participants when: (time = 1) {    write  (Time   + time +  ):   + name +   sends a cfp message to all participants ;  do start_conversation with: [ to :: list(participant), protocol ::  fipa-contract-net , performative ::  cfp , contents :: [ Go swimming ] ]; }  reflex receive_refuse_messages when: !empty(refuses) {  write  (Time   + time +  ):   + name +   receives refuse messages ;    loop r over: refuses {   write     + name +   receives a refuse message from   + agent(r.sender).name +   with content   + r.contents ;  } }  reflex receive_propose_messages when: !empty(proposes) {  write  (Time   + time +  ):   + name +   receives propose messages ;    loop p over: proposes {   write     + name +   receives a propose message from   + agent(p.sender).name +   with content   + p.contents ;      if (p.sender = reject_proposal_participant) {    write     + name +   sends a reject_proposal message to   + p.sender;    do reject_proposal with: [ message :: p, contents :: [ Not interested in your proposal ] ];   } else {    write     + name +   sends a accept_proposal message to   + p.sender;    do accept_proposal with: [ message :: p, contents :: [ Interesting proposal. Go do it ] ];   }  } }  reflex receive_failure_messages when: !empty(failures) {  message f <- failures[0];  write     + name +   receives a failure message from   + agent(f.sender).name +   with content   + f.contents ; }  reflex receive_inform_messages when: !empty(informs) {  write  (Time   + time +  ):   + name +   receives inform messages ;    loop i over: informs {   write     + name +   receives a inform message from   + agent(i.sender).name +   with content   + i.contents ;  } } }   species participant skills: [fipa] {  reflex receive_cfp_from_initiator when: !empty(cfps) {    message proposalFromInitiator <- cfps[0];  write  (Time   + time +  ):   + name +   receives a cfp message from   + agent(proposalFromInitiator.sender).name +   with content   + proposalFromInitiator.contents;    if (self = refuser) {   write     + name +   sends a refuse message to   + agent(proposalFromInitiator.sender).name;   do refuse with: [ message :: proposalFromInitiator, contents :: [ I am busy today ] ];  }    if (self in proposers) {   write     + name +   sends a propose message to   + agent(proposalFromInitiator.sender).name;   do propose with: [ message :: proposalFromInitiator, contents :: [ Ok. That sound interesting ] ];  } }  reflex receive_reject_proposals when: !empty(reject_proposals) {  message r <- reject_proposals[0];  write  (Time   + time +  ):   + name +   receives a reject_proposal message from   + agent(r.sender).name +   with content   + r.contents; }  reflex receive_accept_proposals when: !empty(accept_proposals) {  message a <- accept_proposals[0];  write  (Time   + time +  ):   + name +   receives a accept_proposal message from   + agent(a.sender).name +   with content   + a.contents;    if (self = failure_participant) {   write     + name +   sends a failure message to   + agent(a.sender).name;   do failure with: [ message :: a, contents :: [ Failure ] ];  }    if (self = inform_done_participant) {   write     + name +   sends an inform_done message to   + agent(a.sender).name;   do inform with: [ message :: a, contents :: [ Inform done ] ];  }    if (self = inform_result_participant) {   write     + name +   sends an inform_result message to   + agent(a.sender).name;   do inform with: [ message :: a, contents :: [ Inform result ] ];  } } }   experiment test type: gui {  output {  } }      ","url":"wiki/FIPA-Skill-FIPA-CFP-(2).md"},{"id":"wiki/FIPA-Skill-FIPA-No-Protocol.md","title":" FIPA no protocol","content":"# FIPA no protocol  This model demonstrates a usecase of  no-protocol  interaction protocol.  no-protocol  is a freestyle intecraction protocol in which the modeller (1) can send whatever type of message (i.e., message performative) in the corresponding conversation (2) is responsible for marking the end of the conversation by sending a message with  end_conversation  performative.  Code of the model :      model no_protocol_1  global {  Participant p;  init {  create Initiator;  create Participant returns: ps;    p <- ps at 0;    write  Step the simulation to observe the outcome in the console ; } }   species Initiator skills: [fipa] {  reflex print_debug_infor {   write name +   with conversations:   + (string(conversations)) +  ; mailbox:   + (string(mailbox));  }  reflex say_hello when: (time = 1) {  do start_conversation with: [ to :: [p], protocol ::  no-protocol , performative ::  inform , contents :: [ ( Hello from   + name)] ]; }  reflex read_hello_from_participant when: (time = 3) {  loop i over: informs {   write name +   receives message with content:   + (string(i.contents));   do inform with: [ message :: i, contents :: [ ( Goodbye from   + name)] ];  } }  reflex read_rebound_goodbye when: (time = 5) {  loop i over: mailbox {   write name +   receives message with content:   + (string(i.contents));  } } }   species Participant skills: [fipa] {  reflex print_debug_infor {   write name +   with conversations:   + (string(conversations)) +  ; mailbox:   + (string(mailbox));  }  reflex reply_hello when: (time = 2) {  loop m over: informs {   write name +   receives message with content:   + (string(m.contents));   do inform with: [ message :: m, contents :: [ ( Rebound hello from   + name) ] ];  } }  reflex read_goodbye when: (time = 4) {  loop i over: informs {   write name +   receives message with content:   + (string(i.contents));   do end_conversation with: [ message :: i, contents :: [ ( Rebound goodbye from  + name) ] ];  } } }   experiment test_no_protocol type: gui {}     ","url":"wiki/FIPA-Skill-FIPA-No-Protocol.md"},{"id":"wiki/FIPA-Skill-FIPA-Propose-(1).md","title":" FIPA Propose","content":"# FIPA Propose  This model demontrates a usecase of the FIPA Propose interaction protocol. (Please see http://www.fipa.org/specs/fipa00036/SC00036H.html for the detail description of this protocol).  The Initiator agent begins the conversation/interaction protocol by sending a  propose  message to the Participant agent with  Go swimming?  as content. On receiving the  propose  message, the participant agent replies with an  accept_proposal  message indicating that it agrees to go swimming. After the Initiator agent reads the  accept_proposal  message, the conversation ends.  Code of the model :      model fipa_propose_1  global {  Participant p;  init {  create Initiator;  create Participant returns: ps;    p <- ps at 0;    write  Step the simulation to observe the outcome in the console ; } }   species Initiator skills: [fipa] {  reflex send_propose_message when: (time = 1) {   write name +   sends a propose message ;   do start_conversation ( to : [p], protocol :  fipa-propose , performative :  propose , contents : [ Go swimming? ] );  }  reflex read_accept_proposals when: !(empty(accept_proposals)) {  write name +   receives accept_proposal messages ;  loop i over: accept_proposals {   write  accept_proposal message with content:   + (string(i.contents));  } }   }  species Participant skills: [fipa] {  reflex accept_proposal when: !(empty(proposes)) {   message proposalFromInitiator <- proposes at 0;   do accept_proposal ( message : proposalFromInitiator, contents : [ OK! It \\ s hot today! ] ); } }   experiment test_propose_interaction_protocol type: gui {}     ","url":"wiki/FIPA-Skill-FIPA-Propose-(1).md"},{"id":"wiki/FIPA-Skill-FIPA-Propose-(2).md","title":" FIPA Propose (2)","content":"# FIPA Propose (2)  This model demontrates a usecase of the FIPA Propose interaction protocol. (Please see http://www.fipa.org/specs/fipa00036/SC00036H.html for the detail description of this protocol).  The Initiator agent begins the conversation/interaction protocol by sending a  propose  message to the Participant agent with  Go swimming?  as content. On receiving the  propose  message, the participant agent replies with an  reject_proposal  message indicating that it refuses to go swimming. After the Initiator agent reads the  reject_proposal  message, the conversation ends.  Code of the model :      model fipa_propose_2  global {  Participant p;  init {  create Initiator;  create Participant returns: ps;     p <- ps at 0;    write  Step the simulation to observe the outcome in the console ; } }   species Initiator skills: [fipa] {  reflex send_propose_message when: (time = 1) {   write name +   sends a propose message ;   do start_conversation with: [ to :: [p], protocol ::  fipa-propose , performative ::  propose , contents :: [ Go swimming? ] ];  }  reflex read_accept_proposals when: !(empty(reject_proposals)) {  write name +   receives reject_proposal messages ;  loop i over: reject_proposals {   write  reject_proposal message with content:   + (string(i.contents));  } } }   species Participant skills: [fipa] {  reflex accept_proposal when: !(empty(proposes)) {   message proposalFromInitiator <- proposes at 0;   do reject_proposal with: [ message :: proposalFromInitiator, contents :: [ No! It \\ s too cold today! ] ]; } }   experiment test_propose_interaction_protocol type: gui {}     ","url":"wiki/FIPA-Skill-FIPA-Propose-(2).md"},{"id":"wiki/FIPA-Skill-FIPA-Query-(1).md","title":" FIPA Query","content":"# FIPA Query  This model demontrates a usecase of the FIPA Query interaction protocol. (Please see http://www.fipa.org/specs/fipa00027/SC00027H.html for the detail description of this protocol).  The Initiator agent begins the  fipa-query  conversation/interaction protocol by sending a  query  message to the Participant agent with  your name?  as content. On receiving the  query  message, the Participant agent replies with two consecutive messages : (1) an  agree  message indicating that the Participant agent accepts to execute the query of the Initiator agent, (2) an  inform  message informing the Initiation agent of Participant agent s name.  After the Initiator agent read the  inform  message from the Participant agent, the conversation ends.  Code of the model :      model fipa_query_1  global {  Participant p;  init {  create Initiator;  create Participant returns: ps;     p <- ps at 0;    write  Step the simulation to observe the outcome in the console ; } }   species Initiator skills: [fipa] {  reflex send_query_message when: (time = 1) {   write name +   sends query message ;   do start_conversation with: [ to :: [p], protocol ::  fipa-query , performative ::  query , contents :: [ your name? ] ];  }  reflex read_inform_message when: !(empty(informs)) {  write name +   reads inform messages ;  loop i over: informs {   write  inform message with content:   + (string(i.contents));  } } }   species Participant skills: [fipa] {  reflex reply_query_messages when: !(empty(queries)) {  message queryFromInitiator <- queries at 0;    write name +   reads a query message with content :   + (string(queryFromInitiator.contents));    do agree with: [ message :: queryFromInitiator, contents :: [ OK, I will answer you ] ];    do inform with: [ message :: queryFromInitiator, contents :: [  My name is   + name ] ]; } }   experiment test_query_interaction_protocol type: gui {}     ","url":"wiki/FIPA-Skill-FIPA-Query-(1).md"},{"id":"wiki/FIPA-Skill-FIPA-Query-(2).md","title":" FIPA Query (2)","content":"# FIPA Query (2)  This model demontrates a usecase of the FIPA Query interaction protocol. (Please see http://www.fipa.org/specs/fipa00027/SC00027H.html for the detail description of this protocol).  The Intiator agent begins the  fipa-query  conversation/interaction protocol by sending a  query  message to the Participant agent with  your name?  as content. On receiving the  query  message, the Participant agent replies with a  refuse  message indicating that its name is a secret! After the Initiator agent reads the  refuse  message, the conversation ends.  Code of the model :      model fipa_query_2  global {  Participant p;  init {  create Initiator;  create Participant returns: ps;     p <- ps at 0;    write  Step the simulation to observe the outcome in the console ; } }   species Initiator skills: [fipa] {  reflex send_query_message when: (time = 1) {   write name +   sends a query message ;   do start_conversation (to :: [p], protocol ::  fipa-query , performative ::  query , contents :: [ your name? ]);  }  reflex read_refuse_messages when: !(empty(refuses)) {  write name +   receives refuse messages ;  loop i over: refuses {   write  refuse message with content:   + (string(i.contents));  } } }   species Participant skills: [fipa] {  reflex reply_query_messages when: !(empty(queries)) {   message queryFromInitiator  <- queries at 0;   write name +   reads a query message with content :   + (string(queryFromInitiator.contents));    do refuse with: [ message :: queryFromInitiator, contents :: [ No! That is a secret! ] ];   } }   experiment test_query_interaction_protocol type: gui {}     ","url":"wiki/FIPA-Skill-FIPA-Query-(2).md"},{"id":"wiki/FIPA-Skill-FIPA-Request-(1).md","title":" FIPA Request","content":"# FIPA Request  This model demontrates a usecase of the FIPA Request interaction protocol. (Please see http://www.fipa.org/specs/fipa00026/index.html for the detail description of this protocol).  The Initiator agent begins the  fipa-request  conversation/interaction protocol by sending a  request  message to the Participant agent with  go sleeping  as content. On receiving the  request  message, the Participant agent replies with a  refuse  message. After the Initiator reads the  refuse  message, the  fipa-request  conversation ends.  Code of the model :      model fipa_request_1  global {  Participant p;  init {  create Initiator;  create Participant returns: ps;     p <- ps at 0;    write  Step the simulation to observe the outcome in the console ; } }   species Initiator skills: [fipa] {  reflex print_debug_infor {   write name +   with conversations:   + (string(conversations)) +  ; messages:   + (string(mailbox));  }  reflex send_request when: (time = 1) {  write  send message ;  do start_conversation with: [ to :: [p], protocol ::  fipa-request , performative ::  request , contents :: [ go sleeping ] ]; }  reflex read_refuse_message when: !(empty(refuses)) {  write  read refuse messages ;  loop r over: refuses {   write  refuse message with content:   + string(r.contents);  } } }   species Participant skills: [fipa] {  reflex print_debug_infor {   write name +   with conversations:   + (string(conversations)) +  ; messages:   + (string(mailbox));  }  reflex reply_messages when: (!empty(mailbox)) {  write name +   sends a refuse message ;  do refuse with: [ message :: (mailbox at 0), contents :: [ I don\\ t want ] ]; } }   experiment test_request_interaction_protocol type: gui {}     ","url":"wiki/FIPA-Skill-FIPA-Request-(1).md"},{"id":"wiki/FIPA-Skill-FIPA-Request-(2).md","title":" FIPA Request (2)","content":"# FIPA Request (2)  This model demontrates a usecase of the FIPA Request interaction protocol. (Please see http://www.fipa.org/specs/fipa00026/index.html for the detail description of this protocol).  The Initiator agent begins the  fipa-request  conversation/interaction protocol by sending a  request  message to the Participant agent with  go sleeping  as content. On receiving the  request  message, the Participant agent replies with two consecutive messages :  (1) an  agree  message indicating that the Participant agent accepts to execute the request of the Initiator agent,  (2) a  failure  message indicating that the Participant agent fails to (can not) execute the requestion of the Initiator agent (in this case, the Participant agent says that it can not go sleeping because the bed is broken!). After the Initiator reads the  failure  message from the Participant, the corresponding conversation ends.  Code of the model :      model fipa_request_2  global {  Participant p;  init {  create Initiator;  create Participant returns: ps;     p <- ps at 0;    write  Step the simulation to observe the outcome in the console ; } }   species Initiator skills: [fipa] {  reflex print_debug_infor {   write name +   with conversations:   + (string(conversations)) +  ; messages:   + (string(mailbox));  }  reflex send_request when: (time = 1) {  write  send message ;  do start_conversation (to :: [p], protocol ::  fipa-request , performative ::  request , contents :: [ go sleeping ] ); }  reflex read_agree_message when: !(empty(agrees)) {  write  read agree messages ;  loop a over: agrees {   write  agree message with content:   + string(a.contents);  } }  reflex read_failure_message when: !(empty(failures)) {  write  read failure messages ;  loop f over: failures {   write  failure message with content:   + (string(f.contents));  } } }   species Participant skills: [fipa] {  reflex print_debug_infor {   write name +   with conversations:   + (string(conversations)) +  ; messages:   + (string(mailbox));  }  reflex reply_messages when: (!empty(mailbox)) {  message requestFromInitiator <- (mailbox at 0);  write  agree message ;  do agree with: (message: requestFromInitiator, contents: [ I will ]);    write  inform the initiator of the failure ;  do failure (message: requestFromInitiator, contents: [ The bed is broken ]); } }   experiment test_request_interaction_protocol type: gui {}     ","url":"wiki/FIPA-Skill-FIPA-Request-(2).md"},{"id":"wiki/FIPA-Skill-FIPA-Request-(3).md","title":" FIPA Request (3)","content":"# FIPA Request (3)  This model demontrates a usecase of the FIPA Request interaction protocol. (Please see http://www.fipa.org/specs/fipa00026/index.html for the detail description of this protocol).  The Initiator agent begins the  fipa-request  conversation/interaction protocol by sending a  request   message to the Participant agent with  go sleeping  as content. On receiving the  request  message, the Participant replies with two consecutive messages : (1) an  agree  message indicating that the Participant agent accepts to execute the request of the Initiator agent, (2) an  inform  message indicating that the Participant agent has already executed the request of the Initiator agent (in this case, the  inform  message informs the Initiator that the Participant agent has already gone to bed!). After the Initiator agent reads the  inform  message, the conversation ends.  Code of the model :      model fipa_request_3  global {  Participant p;  init {  create Initiator;  create Participant returns: ps;    p <- ps at 0;    write  Step the simulation to observe the outcome in the console ; } }   species Initiator skills: [fipa] {  reflex print_debug_infor {   write name +   with conversations:   + (string(conversations)) +  ; messages:   + (string(mailbox));  }  reflex send_request when: (time = 1) {  write  send message ;  do start_conversation (to :: [p], protocol ::  fipa-request , performative ::  request , contents :: [ go sleeping ] ); }  reflex read_agree_message when: !(empty(agrees)) {  write  read agree messages ;  loop a over: agrees {   write  agree message with content:   + string(a.contents);  } }  reflex read_inform_message when: !(empty(informs)) {  write  read inform messages ;  loop i over: informs {   write  inform message with content:   + (string(i.contents));  } } }   species Participant skills: [fipa] {  reflex print_debug_infor {   write name +   with conversations:   + (string(conversations)) +  ; messages:   + (string(mailbox));  }  reflex reply_messages when: (!empty(mailbox)) {  message requestFromInitiator <- (mailbox at 0);  write  agree message ;  do agree with: [ message :: requestFromInitiator, contents :: [ I will ] ];    write  inform the initiator ;  do inform with: [ message :: requestFromInitiator, contents :: [ I\\ m in bed already ] ]; } }   experiment test_request_interaction_protocol type: gui {}     ","url":"wiki/FIPA-Skill-FIPA-Request-(3).md"},{"id":"wiki/FIPA-Skill-FIPA-Request-(4).md","title":" FIPA Request (4)","content":"# FIPA Request (4)  This model demontrates a usecase of the FIPA Request interaction protocol.   * (Please see http://www.fipa.org/specs/fipa00026/index.html for the detail description of this protocol).     The Initiator agent begins the  fipa-request  conversation/intaction protocol by sending a  request  message to the Participant agent with  go sleeping  as content.      On receiving a  request  message, the Participant agent replies with an  inform  message.   According to the specification of the FIPA Requestion interaction protocol, the next possible messages   after receiving a  request  message are either  refuse  message or  agree  message.   Hence replying with an  inform  message upon receiving a  request  message violates the protocol specification.   GAMA will hence raise a GamaRuntimeException.   A conversation is automatically ended in case of GamaRuntimeException raised. Hence this conversation ends.   Code of the model :      model fipa_request_4  global {  Participant p;  init {  create Initiator;  create Participant returns: ps;    p <- ps at 0;    write  Step the simulation to observe the outcome in the console ; } }   species Initiator skills: [fipa] {  reflex print_debug_infor {   write name +   with conversations:   + (string(conversations)) +  ; messages:   + (string(mailbox));  }  reflex send_request when: (time = 1) {  write  send message ;  do start_conversation with: [ to :: [p], protocol ::  fipa-request , performative ::  request , contents :: [ go sleeping ] ]; }  reflex read_refuse_message when: !(empty(refuses)) {  write  read refuse messages ;  loop r over: refuses {   write  refuse message with content:   + string(r.contents);  } } }   species Participant skills: [fipa] {  reflex print_debug_infor {   write name +   with conversations:   + (string(conversations)) +  ; messages:   + (string(mailbox));  }  reflex reply_messages when: (!empty(mailbox)) {  write name +   sends an inform message ;      write  A GamaRuntimeException is raised to inform that the message\\ s performative doesn\\ t respect the \\ request\\  interaction protocol\\  specification ;  do inform with: [ message :: (mailbox at 0), contents :: [ I don\\ t want ] ]; // Attention: note that GAMA will raise an exception because an  inform  message is not appropriate here. } }   experiment test_request_interaction_protocol type: gui {}     ","url":"wiki/FIPA-Skill-FIPA-Request-(4).md"},{"id":"wiki/Ordinary-Differential-Equations-Built-In-Equations.md","title":" Predefined equestions","content":"# Predefined equestions  Author : Benoit Gaudou  Presentation of all the predefined equation systems.Comparaison with hand-written systems to test them.   == $0  == $0  == $0  == $0  == $0  == $0  == $0 Code of the model :      model all_predefined_equations  global {  float mu <- 0.02;  float alpha <- 35.842;  float gamma <- 100.0;  float beta0 <- 1884.95;  float beta1 <- 0.255;  float hKR4 <- 0.01;  init {  create preSI  with: [h::0.1,N::500,I::1.0];  create userSI with: [h::0.1,N::500,I::1.0];   create preSIS  with: [h::0.1,N::500,I::1.0];  create userSIS with: [h::0.1,N::500,I::1.0];      create preSIR  with: [h::0.1,N::500,I::1.0];  create userSIR with: [h::0.1,N::500,I::1.0];    create preSIRS  with: [h::0.1,N::500,I::1.0];  create userSIRS with: [h::0.1,N::500,I::1.0];     create preSEIR  with: [h::0.1,N::500,I::1.0];  create userSEIR with: [h::0.1,N::500,I::1.0];      create preLV  with: [h::0.1,x::2.0,y::2.0];  create userLV with: [h::0.1,x::2.0,y::2.0];    } }   species preSI {  float t;  int N;  float I ;   float S <- N - I;   float h;  float beta<-0.4;  // must be followed with exact order S, I, t  and N,beta equation eqSI type: SI vars: [S,I,t] params: [N,beta] ; /*reflex solving {  list i_list;  //solve eqSI method: dp853 step: 0.01 cycle_length: 100 min_step: 1 max_step: 1 scalAbsoluteTolerance: 1 scalRelativeTolerance: 1 integrated_times: i_list ;  //solve eqSI method:rk4 step:h; }*/  reflex solving {  list i_list;  list v_list ;  solve eqSI method: rk4 step: h ;//cycle_length: 1/h integrated_times: i_list integrated_values: v_list;  write i_list:  + i_list;  write v_list: + v_list; } }   species userSI {  float t;  int N;  float I ;   float S <- N - I;   float h;  float beta<-0.4;  equation eqSI {  diff(S,t) = -beta * S * I / N ;  diff(I,t) = beta * S * I / N ; }   reflex solving{solve eqSI method:rk4 step:h;}   }  species preSIS {  float t;  int N;  float I ;   float S <- N - I;   float h;  float beta<-0.4;  float gamma<-0.01;  // must be followed with exact order S, I, t  and N,beta equation eqSIS type: SIS vars: [S,I,t] params: [N,beta,gamma] ; reflex solving {  solve eqSIS method:rk4 step:h; } }   species userSIS {  float t;  int N;  float I ;   float S <- N - I;   float h;  float beta<-0.4;  float gamma<-0.01;  equation eqSIS {  diff(S,t) = -beta * S * I / N + gamma * I;  diff(I,t) = beta * S * I / N - gamma * I; }   reflex solving {   solve eqSIS method:rk4 step:h; } }   species preSIR {  float t;  int N;  float I ;   float S <- N - I;   float R <- 0.0;   float h;  float beta<-0.4;  float gamma<-0.01;  // must be followed with exact order S, I, R, t  and N,beta,delta equation eqSIR type:SIR vars:[S,I,R,t] params:[N,beta,gamma] ; reflex solving {   solve eqSIR method:rk4 step:h; } }   species userSIR{  float t;  int N;  float I ;   float S <- N - I;   float R <- 0.0;   float h;  float beta<-0.4;  float gamma<-0.01;  equation eqSIR {  diff(S,t) = (- beta * S * I / N);  diff(I,t) = (beta * S * I / N) - (gamma * I);  diff(R,t) = (gamma * I); }   reflex solving {  solve eqSIR method:rk4 step:h; } }   species preSIRS {  float t;  int N;  float I ;   float S <- N - I;   float R <- 0.0;   float h;  float beta<-0.4;  float gamma<-0.01;   float omega <- 0.05;  float mu <- 0.01;  // must be followed with exact order S, I, R, t  and N,beta,delta equation eqSIRS type: SIRS vars: [S,I,R,t] params: [N,beta,gamma,omega,mu] ; reflex solving {  solve eqSIRS method:rk4 step:h; } }   species userSIRS {  float t;  int N;  float I ;   float S <- N - I;   float R <- 0.0;   float h;  float beta<-0.4;  float gamma<-0.01;    float omega <- 0.05;  float mu <- 0.01;  equation eqSIRS {   diff(S,t) = mu * N + omega * R + - beta * S * I / N - mu * S ;   diff(I,t) = beta * S * I / N - gamma * I - mu * I ;   diff(R,t) = gamma * I - omega * R - mu * R ; }   reflex solving {  solve eqSIRS method:rk4 step:h; } }   species preSEIR {  float t;  int N;  float S <- N - I;        float E <- 0.0;  float I ;   float R <- 0.0;   float h;  float beta<-0.4;  float gamma<-0.01;   float sigma <- 0.05;  float mu <- 0.01;  // must be followed with exact order S, E, I, R, t  and N,beta,gamma,sigma,mu equation eqSEIR type: SEIR vars: [S,E,I,R,t] params: [N,beta,gamma,sigma,mu] ; reflex solving {  solve eqSEIR method:rk4 step:h; } }   species userSEIR {  float t;  int N;  float S <- N - I;        float E <- 0.0;  float I ;   float R <- 0.0;   float h;  float beta<-0.4;  float gamma<-0.01;    float sigma <- 0.05;  float mu <- 0.01;  equation eqSEIR {  diff(S,t) = mu * N - beta * S * I / N - mu * S ;  diff(E,t) = beta * S * I / N - mu * E - sigma * E ;  diff(I,t) = sigma * E - mu * I - gamma * I;  diff(R,t) = gamma * I - mu * R ; }   reflex solving { solve eqSEIR method:rk4 step:h; } }   species preLV {  float t;  float x ;   float y ;   float h;  float alpha <- 0.8 ;  float beta  <- 0.3 ;  float gamma <- 0.2 ;  float delta <- 0.85;  // must be followed with exact order x, y, t  and  alpha,beta,delta,gamma equation eqLV type: LV vars: [x,y,t] params: [alpha,beta,delta,gamma] ; reflex solving {  solve eqLV method:rk4 step:h; } }   species userLV {  float t;  float x ;   float y ;   float h;  float alpha <- 0.8 ;  float beta  <- 0.3 ;  float gamma <- 0.2 ;  float delta <- 0.85;  equation eqLV {   diff(x,t) =   x * (alpha - beta * y);  diff(y,t) = - y * (delta - gamma * x); }   reflex solving {  solve eqLV method:rk4 step:h; } }   experiment examples type: gui {  output {     display SI  {    chart  examplePreSI  type: series background: #lightgray position: {0,0} size:{1,0.5} {     data  S  value: first(preSI).S color: #green;     data  I  value: first(preSI).I color: #red;    }    chart  examplesUserSI  type: series background: #lightgray position: {0,0.5} size:{1,0.5} {     data  S  value: first(userSI).S color: #green;     data  I  value: first(userSI).I color: #red;    }   }   display SISs  {   chart  examplePreSIS  type: series background: #lightgray position: {0,0} size:{1,0.5} {    data S value: first(preSIS).S color: #green;    data I value: first(preSIS).I color: #red;   }   chart  examplesUserSIS  type: series background: #lightgray position: {0,0.5} size:{1,0.5} {    data S value: first(userSIS).S color: #green;    data I value: first(userSIS).I color: #red;   }     }    display SIR  {   chart  examplePreSIR  type: series background: #lightgray position: {0,0} size:{1,0.5} {    data S value: first(preSIR).S color: #green;    data I value: first(preSIR).I color: #red;    data R value: first(preSIR).R color: #blue;   }   chart  examplesUserSIR  type: series background: #lightgray position: {0,0.5} size:{1,0.5} {    data S value: first(userSIR).S color: #green;    data I value: first(userSIR).I color: #red;    data R value: first(userSIR).R color: #blue;   }     }   display SIRS  {   chart  examplePreSIRS  type: series background: #lightgray position: {0,0} size:{1,0.5} {    data S value: first(preSIRS).S color: #green;    data I value: first(preSIRS).I color: #red;    data R value: first(preSIRS).R color: #blue;   }   chart  examplesUserSIRS  type: series background: #lightgray position: {0,0.5} size:{1,0.5} {    data S value: first(userSIRS).S color: #green;    data I value: first(userSIRS).I color: #red;    data R value: first(userSIRS).R color: #blue;   }     }   display SEIR  {   chart  examplePreSEIR  type: series background: #lightgray position: {0,0} size:{1,0.5} {    data S value: first(preSEIR).S color: #green;    data E value: first(preSEIR).E color: #yellow;    data I value: first(preSEIR).I color: #red;    data R value: first(preSEIR).R color: #blue;   }   chart  examplesUserSEIR  type: series background: #lightgray position: {0,0.5} size:{1,0.5} {    data S value: first(userSEIR).S color: #green;    data E value: first(userSEIR).E color: #yellow;        data I value: first(userSEIR).I color: #red;    data R value: first(userSEIR).R color: #blue;   }  }   display LV  {   chart  examplePreLV  type: series background: #lightgray position: {0,0} size:{1,0.5} {    data x value: first(preLV).x color: #yellow;    data y value: first(preLV).y color: #blue;   }   chart  examplesUserLV  type: series background: #lightgray position: {0,0.5} size:{1,0.5} {    data x value: first(userLV).x color: #yellow;    data y value: first(userLV).y color: #blue;   }     }       } }   experiment diff_predefined_defined_by_user type: gui {  output {   display diff  {    chart  diffSI  type: series background: #lightgray  position: {0,0} size:{0.5, 0.33} {     data  dS  value: (first(userSI).S - first(preSI).S) color: #yellow;     data  dI  value: (first(userSI).I - first(preSI).I) color: #blue;    }    chart  diffSIS  type: series background: #lightgray position: {0.5,0} size:{0.5, 0.33} {     data  dS  value: (first(userSIS).S - first(preSIS).S) color: #yellow;     data  dI  value: (first(userSIS).I - first(preSIS).I) color: #blue;    }    chart  diffSIR  type: series background: #lightgray position: {0,0.33} size:{0.5, 0.33} {     data  dS  value: (first(userSIR).S - first(preSIR).S) color: #yellow;     data  dI  value: (first(userSIR).I - first(preSIR).I) color: #blue;     data  dR  value: (first(userSIR).R - first(preSIR).R) color: #red;    }      chart  diffSIRS  type: series background: #lightgray position: {0.5,0.33} size:{0.5, 0.33} {     data  dS  value: (first(userSIRS).S - first(preSIRS).S) color: #yellow;     data  dI  value: (first(userSIRS).I - first(preSIRS).I) color: #blue;     data  dR  value: (first(userSIRS).R - first(preSIRS).R) color: #red;    }     chart  diffSEIR  type: series background: #lightgray position: {0,0.66} size:{0.5, 0.33} {     data  dS  value: (first(userSEIR).S - first(preSEIR).S) color: #yellow;     data  dE  value: (first(userSEIR).E - first(preSEIR).E) color: #yellow;         data  dI  value: (first(userSEIR).I - first(preSEIR).I) color: #blue;     data  dR  value: (first(userSEIR).R - first(preSEIR).R) color: #red;    }     chart  diffLV  type: series background: #lightgray position: {0.5,0.66} size:{0.5, 0.33} {     data  dx  value: (first(userLV).x - first(preLV).x) color: #yellow;     data  dy  value: (first(userLV).y - first(preLV).y) color: #red;        }        }   } }      ","url":"wiki/Ordinary-Differential-Equations-Built-In-Equations.md"},{"id":"wiki/Ordinary-Differential-Equations-SIR-(Influence-of-Integration-Step).md","title":" SIR (Influence of Integration Step).gaml","content":"# SIR (Influence of Integration Step).gaml  Author : hqnghi  A SIR model to illustrate the impact of the change of the integration parameters.   == $0  == $0  == $0 Code of the model :       model SIR_influence_of_integration_step  global {   float step<-1#s;  float beta <- 0.8 ;    float delta <- 0.01 ;  float s1 <- 1#s; float s2 <- 1.5#s; float s3 <- 2#s;  init {  create SIR_agt with: [h::1,myUnit::s1];  create SIR_agt with: [h::0.1,myUnit::s2];  create SIR_agt with: [h::0.01,myUnit::s3];     }   }   species SIR_agt {  int N <- 500;     float t;  float I <- 1.0;  float S <- N - I;  float R <- 0.0;        float h;      float myUnit<-1#s; equation SIR{   diff(S,t) =myUnit* (- beta  * S * I / N);  diff(I,t) =myUnit* (beta * S * I / N) - (delta * I);  diff(R,t) =myUnit* (delta * I); }   reflex solving {  solve SIR method: rk4 step: h;// cycle_length:mycycle ; //  S<-S*myUnit; //  I<-I*myUnit; //  R<-R*myUnit; }       }   experiment mysimulation1 type: gui {    output {    display SIR_1  {    chart  SI - h=1  type: series background: #white {     data  S  value: first(SIR_agt where (each.myUnit = s1)).S color: #green;         data  I  value: first(SIR_agt where (each.myUnit = s1)).I color: #red ;     data  R  value: first(SIR_agt where (each.myUnit = s1)).R color: #blue ;        }   }   display SIR_10 {   chart SI - h=0.1 type: series background: #white{    data  S  value: first(SIR_agt where (each.myUnit = s2)).S color: #green;        data  I  value: first(SIR_agt where (each.myUnit = s2)).I color: #red ;    data  R  value: first(SIR_agt where (each.myUnit = s2)).R color: #blue ;       }  }    display SIR_100  {   chart SI - h=0.01 type: series background: #white {    data  S  value: first(SIR_agt where (each.myUnit = s3)).S color: #green;        data  I  value: first(SIR_agt where (each.myUnit = s3)).I color: #red ;    data  R  value: first(SIR_agt where (each.myUnit = s3)).R color: #blue ;       }  }  } }      ","url":"wiki/Ordinary-Differential-Equations-SIR-(Influence-of-Integration-Step).md"},{"id":"wiki/Ordinary-Differential-Equations-SIR-(Simple-with-charts).md","title":" SIR (Simple)","content":"# SIR (Simple)  Author : hqnghi  A simple example of ODE use into agents with the example of the SIR equation system.   == $0  == $0  == $0 Code of the model :       model simple_ODE_SIR  global {  init{   create aSIR number:10{    S<-S-(int(self)*10000);   }  }  list S_3d->{aSIR collect each.S};  list I_3d->{aSIR collect each.I};  list R_3d->{aSIR collect each.R};  reflex ss when: cycle>=40{      do pause;  } }   species aSIR {  int N <- 150000 ;  int iInit <- 1000;  float t;   float S <- N - float(iInit);         float I <- float(iInit);  float R <- 0.0;   float alpha <- 0.2 min: 0.0 max: 1.0; float beta <- 0.8  min: 0.0 max: 1.0;  float h <- 0.1;     equation SIR{   diff(S,t) = (- beta * S * I / N);  diff(I,t) = (beta * S * I / N) - (alpha * I);  diff(R,t) = (alpha * I); }    reflex solving {  solve SIR method: rk4 step: h ;//cycle_length: 1/h ; }     }   experiment maths type: gui {   float minimum_cycle_duration<-0.2;  output {   display display_charts {   chart SIR_agent type: series background: #white {    data  S0  value: (aSIR[0]).S color: #green ;        data  S1  value: (aSIR[1]).S color: #green ;        data  S2  value: (aSIR[2]).S color: #green ;        data  S3  value: (aSIR[3]).S color: #green ;        data  S4  value: (aSIR[4]).S color: #green ;        data  S5  value: (aSIR[5]).S color: #green ;        data  S6  value: (aSIR[6]).S color: #green ;        data  S7  value: (aSIR[7]).S color: #green ;        data  S8  value: (aSIR[8]).S color: #green ;      data  S9  value: (aSIR[9]).S color: #green ;              data  I0  value: (aSIR[0]).I color: #red ;        data  I1  value: (aSIR[1]).I color: #red ;        data  I2  value: (aSIR[2]).I color: #red ;        data  I3  value: (aSIR[3]).I color: #red ;        data  I4  value: (aSIR[4]).I color: #red ;        data  I5  value: (aSIR[5]).I color: #red ;        data  I6  value: (aSIR[6]).I color: #red ;        data  I7  value: (aSIR[7]).I color: #red ;        data  I8  value: (aSIR[8]).I color: #red ;      data  I9  value: (aSIR[9]).I color: #red ;              data  R0  value: (aSIR[0]).R color: #blue ;        data  R1  value: (aSIR[1]).R color: #blue ;        data  R2  value: (aSIR[2]).R color: #blue ;        data  R3  value: (aSIR[3]).R color: #blue ;        data  R4  value: (aSIR[4]).R color: #blue ;        data  R5  value: (aSIR[5]).R color: #blue ;        data  R6  value: (aSIR[6]).R color: #blue ;        data  R7  value: (aSIR[7]).R color: #blue ;        data  R8  value: (aSIR[8]).R color: #blue ;      data  R9  value: (aSIR[9]).R color: #blue ;      }  }    display display_charts_radar {   chart SIR_agent type: radar background: #white axes:#white {    data  S0  value: (aSIR[0]).S[] color: #green ;       data  I0  value: (aSIR[0]).I[] color: #red ;     data  R0  value: (aSIR[0]).R[] color: #blue ;     }  }        display display_chartsH {   chart SIR_agent type: heatmap background: #white   reverse_axes: true    {    data  S0  value: S_3d color: #green ;     data  I0  value: I_3d color: #red ;     data  R0  value: R_3d color: #blue ;    }  } } }      ","url":"wiki/Ordinary-Differential-Equations-SIR-(Simple-with-charts).md"},{"id":"wiki/Ordinary-Differential-Equations-SIR-(Simple).md","title":" SIR (Simple)","content":"# SIR (Simple)  Author : hqnghi  A simple example of ODE use into agents with the example of the SIR equation system.   == $0 Code of the model :       model simple_ODE_SIR  global {  init{   create agent_with_SIR_dynamic number:1;  } }  species agent_with_SIR_dynamic {  int N <- 1500 ;  int iInit <- 1;  float t;   float S <- N - float(iInit);         float I <- float(iInit);  float R <- 0.0;   float alpha <- 0.2 min: 0.0 max: 1.0; float beta <- 0.8 min: 0.0 max: 1.0;  float h <- 0.01;     equation SIR{   diff(S,t) = (- beta * S * I / N);  diff(I,t) = (beta * S * I / N) - (alpha * I);  diff(R,t) = (alpha * I); }    reflex solving {  solve SIR method: rk4 step: h ;//cycle_length: 1/h ; }     }   experiment maths type: gui {  output {    display display_charts {    chart  SIR_agent  type: series background: #white {     data  S  value: first(list(agent_with_SIR_dynamic)).S color: #green ;         data  I  value: first(list(agent_with_SIR_dynamic)).I color: #red ;     data  R  value: first(list(agent_with_SIR_dynamic)).R color: #blue ;    }   }  } }     ","url":"wiki/Ordinary-Differential-Equations-SIR-(Simple).md"},{"id":"wiki/Ordinary-Differential-Equations-SIR-(Split-in-Agents,-Multiple-Strains).md","title":" SIR (Split in Agents, Multiple Strains)","content":"# SIR (Split in Agents, Multiple Strains)  Author : tri and nghi  This model is an extension of the model SIR_split_in_agents.gaml. It creates several agents of one compartment type (here typically several I_agt).   == $0  == $0 Code of the model :      model SIR_split_in_agents_multiple_strains  global {  // Parameters  int number_S <- 495 ; // The number of susceptible  int number_I <- 5 ; // The number of infected  int number_R <- 0 ; // The number of removed  float _beta <- 1.0 ; // The parameter Beta float _delta <- 0.01 ; // The parameter Delta  // Global variables int strain_number <- 2; int N <- number_S + number_I * strain_number + number_R;  float hKR4 <- 0.01;  init {  create S_agt {   Ssize <- float(number_S);  }   create I_agt number: strain_number {   Isize <- float(number_I);   self.beta <- _beta;    self.delta <- _delta;   }   create R_agt {   Rsize <- float(number_R);  }   create my_SIR_maths {   self.Sm <- float(number_S);   self.Im <- float(number_I) * strain_number;   self.Rm <- float(number_R);  }   write  Basic Reproduction Number (R0):   + string(_beta * number_S / (_delta)); }   }  species S_agt {  float t;    float Ssize;  equation evol simultaneously: [I_agt, R_agt] {  diff(self.Ssize, t) = (- sum(I_agt accumulate [each.beta * each.Isize]) * self.Ssize / N); }  reflex solving {solve evol method: rk4 step: hKR4 ;} }   species I_agt {  float t;    float Isize;  float beta; float delta;  equation evol simultaneously: [S_agt, R_agt] {  diff(self.Isize, t) = (beta * first(S_agt).Ssize * self.Isize / N) - (delta * self.Isize); } }   species R_agt {  float t;    float Rsize;  equation evol simultaneously: [I_agt] {  diff(self.Rsize, t) = (sum(I_agt collect (each.delta * each.Isize))); } }   species my_SIR_maths {  float t;  float Im;  float Sm;  float Rm;  equation SIR {  diff(self.Sm, t) = (-_beta * Sm * Im / N);  diff(self.Im, t) = (_beta * Sm * Im / N) - (_delta * Im);  diff(self.Rm, t) = (_delta * Im); }  reflex solving {solve SIR method: rk4 step: hKR4;} }   experiment Simulation type: gui {  parameter  Number of Susceptible  type: int var: number_S <- 495 category:  Initial population ;   parameter  Number of Infected     type: int var: number_I <- 5   category:  Initial population ;  parameter  Number of Removed      type: int var: number_R <- 0   category:  Initial population ;  parameter  Beta (S->I)   type: float var: _beta <- 1.0   category: Parameters; parameter  Delta (I->R)  type: float var: _delta <- 0.01 category: Parameters;   output {  display chart_3system_eq {   chart  Split system  type: series background: #lightgray {    data  susceptible  value: first(S_agt).Ssize color: #green;    data  infected0  value: first(I_agt).beta * first(I_agt).Isize color: #white;    data  infected1  value: last(I_agt).beta * last(I_agt).Isize color: #yellow;    data  i1+i2  value: sum(I_agt accumulate (each.beta * each. Isize)) color: rgb (  red  ) ;        data  recovered  value: first(R_agt).Rsize color: #blue;   }   }   display chart_1system_eq  {   chart  unified system  type: series background: #lightgray {    data  susceptible_maths  value: first(my_SIR_maths).Sm color: #green;    data  infected_maths  value: first(my_SIR_maths).Im color: #red;    data  recovered_maths  value: first(my_SIR_maths).Rm color: #blue;   }  } } }       ","url":"wiki/Ordinary-Differential-Equations-SIR-(Split-in-Agents,-Multiple-Strains).md"},{"id":"wiki/Physics-Engine-Hello-World.md","title":" Falling Balls","content":"# Falling Balls  Author : Arnaud Grignard  This is a model that shows how the physics engine work by displaying two species (a floor and balls). Ball agents use the skill physical3D. The ball agents fall on a floor and fall from the floor to the void.  Code of the model :       model FallingHelloWorld  global {  int environment_size <- 500;  int number_of_ball parameter:  Number of ball  min:1 <- 100  category:  Model ;  int ball_radius parameter:  Ball radius  min:1 <- 25  category:  Model ;   file imageRaster <- file( ./../images/wood-floor.jpg ) ; geometry shape <- square(environment_size);   //Physic World used to simulate gravity and compute forces physic_world world2;   init {  create ball number: number_of_ball{   location <-  {rnd(environment_size),rnd(environment_size),rnd(environment_size)};  radius <-float(rnd(ball_radius)+1);  //Bounds to compute the collision for the ball agents   collisionBound <-  [shape::sphere,radius::radius];   mass <-1.0;  }    create ground {   location <- {environment_size/2,environment_size/2,0};  //Bounds to compute the collision for the floor agent   collisionBound <-  [shape::floor,x::environment_size/2, y:: environment_size/2, z::0];   mass <-0.0;  }   create physic_world{    world2 <- self;    //Add to the agents that will be used to compute the forces.    ask world2 {agents <-  (ball as list) + (ground as list);}    //Boolean to set gravity      world2.gravity <- true;  } }  //Reflex to compute the forces at each step reflex computeForces  {   ask world2 {do compute_forces step: 1;} }     }    species physic_world parent: physical_world ;  species ground skills: [physics]{       aspect image{   draw imageRaster size: environment_size;  } }  species ball skills: [physics] {  rgb color <- rgb (217,229,143);   float radius;  aspect sphere{  draw sphere(radius) color: color ; }  } experiment Falling_Hello_world type: gui { init{  minimum_cycle_duration <-0.001; }  output {    display Rain  type: opengl background:rgb(0,58,64) draw_env:false{   species ground aspect:image;      species ball aspect:sphere;     } } }       ","url":"wiki/Physics-Engine-Hello-World.md"},{"id":"wiki/Physics-Engine-Perfect-Gas.md","title":" Balls without gravity","content":"# Balls without gravity  Author : Arnaud Grignard  This is a model that shows how the physics engine work without gravity. Balls can collide each other and can t go further than the wall and the ground agents.  Code of the model :      model Perfect_Gas  global {  //Bounds of the environment  int width_of_environment parameter:  Dimensions  init:200 ;   int height_of_environment parameter:  Dimensions  init:200  ;  //Range, Speed ans Size of the agents int range_of_agents parameter:  Range of Agents  min: 1 <- 25 ; float speed_of_agents parameter:  Speed of Agents  min: 0.1  <- 2.0 ;  int size_of_agents <- 10;   float size_of_the_wall <- 10.0; int offset<-10; geometry shape <- rectangle(width_of_environment, height_of_environment);  //Physic engines that will compute the forces physic_world world2; init {  create ball number: 1000{   radius <-2;   location <-  {offset+ rnd(width_of_environment-offset*2), offset+ rnd(height_of_environment- offset*2),offset+ rnd(width_of_environment-offset*2)};   mass <-0.001;   collisionBound <-  [shape::sphere,radius::radius];  }    create ground   {      location <- {width_of_environment/2,height_of_environment/2,0};   collisionBound <-  [shape::floor,x::width_of_environment/2 , y:: height_of_environment/2, z::size_of_the_wall];   shape <- rectangle(width_of_environment,height_of_environment);   mass <-0.0;  }    //Sky  create ground{   location <- {width_of_environment/2,height_of_environment/2,width_of_environment};   collisionBound <-  [shape::floor,x::width_of_environment/2 , y:: height_of_environment/2, z::size_of_the_wall];   shape <- rectangle(width_of_environment,height_of_environment);   mass <-0.0;  }   //down wall  create wall{   location <- {width_of_environment/2,height_of_environment,0};   height <- float(width_of_environment);   shape <- rectangle(width_of_environment,2);   collisionBound <-  [shape::floor,x::width_of_environment/2, y:: size_of_the_wall, z::height];   mass <-0.0;  }  //upper wall  create wall{   location <- {width_of_environment/2,0,0};   height <- float(width_of_environment);   shape <- rectangle(width_of_environment,2);   collisionBound <-  [shape::floor,x::width_of_environment/2, y:: size_of_the_wall, z::height];   mass <-0.0;  }  //left wall  create wall{   location <- {0.0,height_of_environment/2,0.0};   height <- float(width_of_environment);   shape <- rectangle(2,height_of_environment);   collisionBound <-  [shape::floor,x::size_of_the_wall, y:: height_of_environment/2, z::height];   mass <-0.0;     }  //right wall  create wall{   location <- {width_of_environment,height_of_environment/2,0};   height <- float(width_of_environment);   shape <- rectangle(2,height_of_environment);   collisionBound <-  [shape::floor,x::size_of_the_wall, y:: height_of_environment/2, z::height];   mass <-0.0;     }    //Create the physic engine without gravity computed  create physic_world {   gravity <- false;   world2 <- self;  }    //Add the agents to compute their forces  ask world2 {agents <-  (ball as list) + (ground as list) + (wall as list);}   }  //Reflex to compute the forces at each step reflex computeForces  {  ask world2 {do compute_forces step: 1;} }    }  //Species to represent the physic engine, derivated from the Physical3DWorld built-in species species physic_world parent: physical_world ;  //Species to represent the ground using the physical3D skill species ground skills: [physics]{  aspect default {   draw shape color: #black empty:true;  } }  //Species to represent the wall using the physical3D skill species wall skills: [physics]{  rgb color;  float height;     aspect default {   draw shape color: #black depth:height empty:true;  } }  //Species to represent the ball using the physical3D skill species ball skills: [physics] {  rgb color;  int radius;  int size  <- size_of_agents;  int range  <- range_of_agents;   float speed  <- speed_of_agents;  int heading <- rnd(359);  aspect sphere{  draw sphere(radius) color: rgb(135,201,255) ; }  }   experiment perfect_gas type: gui {  init{   minimum_cycle_duration <-0.001;  }  output {   display Cube type:opengl background:rgb(20,79,127) draw_env:false{    species ground transparency:0.5;    species wall transparency:0.5;       species ball aspect:sphere;      }  } }      ","url":"wiki/Physics-Engine-Perfect-Gas.md"},{"id":"wiki/Physics-Engine-Pool.md","title":" Pool using Physic Engine","content":"# Pool using Physic Engine  Author : Arnaud Grignard  This is a model that shows how the physics engine works using a pool with balls, collided by a white ball. The balls use the skill Physical3D.  Code of the model :      model pool3D  global {  //Parameters for the environment  int width_of_environment <- 200;  int height_of_environment <- 300;  //Parameters for the balls float speed_of_agents <- 2.0; int size_of_agents <- 10;  rgb colorwood <- rgb([178, 112, 62]);  //Physical Engine physic_world world2; geometry shape <- rectangle(width_of_environment, height_of_environment); init {    //Creation of the white ball  create ball {   location <- { width_of_environment / 2, 4 * height_of_environment / 5, 5.0 };   mass <- 3.0;   //a random velocity between 500 and 1000   velocity <- [0.0, -float(500 + rnd(500)), 0.0];   collisionBound <- [shape::sphere, radius::5];  }   int i <- 0;  int deltaI <- 0;  int initX <- 75;  int initY <- int(height_of_environment / 8);    //Create the other balls for the pool  create ball number: 15 {   location <- { initX + (i - deltaI) * 10, initY, 5.0 };   heading <- 90;   speed <- 0.0;   mass <- 3.0;   collisionBound <- [shape::sphere, radius::5];   i <- i + 1;      if ((i mod 2) = 0) {     color <- #red;   } else {    color <- #yellow;   }    if (i = 5) {    initX <- initX + 5;    initY <- initY + 9;    deltaI <- 5;   }    if (i = 9) {    initX <- initX + 5;    initY <- initY + 9;    deltaI <- 9;   }    if (i = 12) {    initX <- initX + 5;    initY <- initY + 9;    deltaI <- 12;   }    if (i = 14) {    initX <- initX + 5;    initY <- initY + 9;    deltaI <- 14;   }   }   create ground {   location <- { width_of_environment / 2, height_of_environment / 2, 0 };   shape <- rectangle({ width_of_environment - 24, height_of_environment - 24 });   collisionBound <- [shape::floor, x::width_of_environment / 2 - 12, y::height_of_environment / 2 - 12, z::0];   mass <- 0.0;  }   create ground {   location <- { width_of_environment / 2, 6, 0 };   shape <- rectangle({ width_of_environment - 24, 12 });   collisionBound <- [shape::floor, x::width_of_environment / 2 - 12, y::6, z::0];   mass <- 0.0;  }   create ground {   location <- { width_of_environment / 2, height_of_environment - 6, 0 };   shape <- rectangle({ width_of_environment - 24, 12 });   collisionBound <- [shape::floor, x::width_of_environment / 2 - 12, y::6, z::0];   mass <- 0.0;  }   create ground {   location <- { 6, height_of_environment / 4 + 3, 0 };   shape <- rectangle({ 12, height_of_environment / 2 - 18 });   collisionBound <- [shape::floor, x::6, y::height_of_environment / 4 - 9, z::0];   mass <- 0.0;  }   create ground {   location <- { 6, 3 * height_of_environment / 4 - 3, 0 };   shape <- rectangle({ 12, height_of_environment / 2 - 18 });   collisionBound <- [shape::floor, x::6, y::height_of_environment / 4 - 9, z::0];   mass <- 0.0;  }   create ground {   location <- { width_of_environment - 6, height_of_environment / 4 + 3, 0 };   shape <- rectangle({ 12, height_of_environment / 2 - 18 });   collisionBound <- [shape::floor, x::6, y::height_of_environment / 4 - 9, z::0];   mass <- 0.0;  }   create ground {   location <- { width_of_environment - 6, 3 * height_of_environment / 4 - 3, 0 };   shape <- rectangle({ 12, height_of_environment / 2 - 18 });   collisionBound <- [shape::floor, x::6, y::height_of_environment / 4 - 9, z::0];   mass <- 0.0;  }   //down wall  create wall {   location <- { width_of_environment / 2, height_of_environment, 0 };   shape <- rectangle({ width_of_environment, 2 });   collisionBound <- [shape::floor, x::width_of_environment / 2, y::1, z::10];   mass <- 0.0;   color <- colorwood;  }  //upper wall  create wall {   location <- { width_of_environment / 2, 0, 0 };   shape <- rectangle({ width_of_environment, 2 });   collisionBound <- [shape::floor, x::width_of_environment / 2, y::1, z::10];   mass <- 0.0;   color <- colorwood;  }  //left wall  create wall {   location <- { 0, height_of_environment / 2, 0 };   shape <- rectangle({ 2, height_of_environment });   collisionBound <- [shape::floor, x::1, y::height_of_environment / 2, z::10];   mass <- 0.0;   color <- colorwood;  }  //right wall  create wall {   location <- { width_of_environment, height_of_environment / 2, 0 };   shape <- rectangle({ 2, height_of_environment });   collisionBound <- [shape::floor, x::1, y::height_of_environment / 2, z::10];   mass <- 0.0;   color <- colorwood;  }    //Create the physic engine with gravity  create physic_world {   gravity <- true;   world2 <- self;  }   //Add the agents inside the registered agents in the physic engine  ask world2 {   agents <- (ball as list) + (ground as list) + (wall as list);  }  }  //Reflex to compute the forces at each step reflex computeForces {  ask world2 {   do compute_forces step: 1;  }  }   }  //Species corresponding to the physics engine, derivated from the built-in species Physical3DWorld species physic_world parent: physical_world ;  //Species representing the ground agents used for the computation of the forces, using the skill physical3D species ground skills: [physics] {  aspect default {   draw shape color: rgb([10, 114, 63]) border: rgb([10, 114, 63]);  }  }  //Species representing the wall agents of the pool using the skill physical3D species wall skills: [physics] {  rgb color;  aspect default {   draw shape color: color depth: 10;  }  }  //Species representing the ball agents of the pool using the skill physical3D species ball skills: [physics] {  rgb color<-#white;  int size <- size_of_agents;  float speed <- speed_of_agents;  int heading <- rnd(359);  aspect sphere {  draw sphere(5) color:color; }   }  experiment pool type: gui {  output {   display Circle type: opengl tesselation: true background: #white draw_env: false { species ground aspect: default;   species wall aspect: default;   species ball aspect: sphere;   }  }  }      ","url":"wiki/Physics-Engine-Pool.md"},{"id":"wiki/Physics-Engine-Water-Tank.md","title":" Water Tank","content":"# Water Tank  Author : Arnaud Grignard  This is a model that shows how the physics engine works using a tank, with a floor and 4 walls, and balls falling into it. The floor doesn t have any mass,  Code of the model :      model Tank  global {  //Dimensions of the environment int width_of_environment parameter:  Dimensions  init: 100; int height_of_environment parameter:  Dimensions  init: 100;  //Parameters for the ball species int nb_balls parameter:  Number of Agents  min: 1 <- 500; int size_of_agents parameter:  Size of Agents  min: 1 <- 1;   int wall_height parameter:  Wall height  min: 1 <- 25; geometry shape <- rectangle(width_of_environment, height_of_environment);  //Physics engine physic_world world2;   init {    //Creation of the ball agents  create ball number: nb_balls {   location <- { rnd(width_of_environment - size_of_agents), rnd(height_of_environment - size_of_agents), rnd(height_of_environment - size_of_agents) };   radius <- float(size_of_agents);      //Attributes to know the collision bounds of the agent   collisionBound <- [shape::sphere, radius::radius];  }   //Create the ground of the tank  create ground {   location <- { width_of_environment / 2, height_of_environment / 2, 0 };   collisionBound <- [shape::floor, x::width_of_environment / 2, y::height_of_environment / 2, z::0];   shape <- rectangle({ width_of_environment, height_of_environment });   mass <- 0.0;  }  //down wall  create wall {   location <- { width_of_environment / 2, height_of_environment, 0 };   shape <- rectangle({ width_of_environment, 2 });   collisionBound <- [shape::floor, x::width_of_environment / 2, y::1, z::wall_height];   mass <- 0.0;  }  //upper wall  create wall {   location <- { width_of_environment / 2, 0, 0 };   shape <- rectangle({ width_of_environment, 2 });   collisionBound <- [shape::floor, x::width_of_environment / 2, y::1, z::wall_height];   mass <- 0.0;  }  //left wall  create wall {   location <- { 0, height_of_environment / 2, 0 };   shape <- rectangle({ 2, height_of_environment });   collisionBound <- [shape::floor, x::1, y::height_of_environment / 2, z::wall_height];   mass <- 0.0;  }  //right wall  create wall {   location <- { width_of_environment, height_of_environment / 2, 0 };   shape <- rectangle({ 2, height_of_environment });   collisionBound <- [shape::floor, x::1, y::height_of_environment / 2, z::wall_height];   mass <- 0.0;  }  //Initialisation of the physic engine  create physic_world {   world2 <- self;  }    //The physic engine agent gets all the other agents of the world to compute their forces  ask world2 {   agents <- (ball as list) + (ground as list) + (wall as list);  }   world2.gravity <- true; }  //Reflex to compute the forces at each step reflex computeForces {  ask world2 {   do compute_forces step: 1;  }  }   }  //Species that will represent the physic engine, derivated from builti-in species Physical3DWorld species physic_world parent: physical_world ;  //Species that will represent the ground of the tank, using the skill physical 3D species ground skills: [physics] {  aspect default {   draw shape color: rgb(60, 60, 60);  }  }  //Species that will represent the walls of the tank, using the skill physical 3D species wall skills: [physics] {  rgb color;  aspect default {   draw shape color: rgb(40, 40, 40) depth: wall_height;  }  }  //Species that will represent the balls falling in the tank, using the skill physical 3D species ball skills: [physics] {  float radius;  aspect default {   draw sphere(radius) color: rgb(4, 158, 189);  }  }  experiment tank type: gui {  init{   minimum_cycle_duration <-0.001;  }  output {   display Circle type: opengl background: rgb(230, 230, 230) {     species ground;    species wall;    species ball;   }  }  }      ","url":"wiki/Physics-Engine-Water-Tank.md"},{"id":"wiki/Diffusion-Statement.md","title":" Diffusion Statement","content":"Diffusion Statement  This sub-section is composed of the following models :     Anisotropic diffusion (Simple)    == $0    Anisotropic diffusion (Toroidal)    == $0    Anisotropic diffusion with several computation method    == $0  == $0    Blend color in a cuve    == $0    Diffusion in a cuve (Cycle length)    == $0  == $0    Generate diffusion matrix with parameters    == $0    Uniform diffusion with mask (Avoid mask)    == $0  == $0    Uniform diffusion    == $0  == $0 ","url":"wiki/Diffusion-Statement.md"},{"id":"wiki/FIPA-Skill.md","title":" FIPA Skill","content":"FIPA Skill  This sub-section is composed of the following models :   FIPA Contract Net FIPA Contract Net (2) FIPA no protocol FIPA Propose FIPA Propose (2) FIPA Query FIPA Query (2) FIPA Request FIPA Request (2) FIPA Request (3) FIPA Request (4)      ","url":"wiki/FIPA-Skill.md"},{"id":"wiki/Ordinary-Differential-Equations.md","title":" Ordinary Differential Equations","content":"Ordinary Differential Equations  This sub-section is composed of the following models :     Predefined equestions    == $0  == $0  == $0  == $0  == $0  == $0  == $0    SIR (Influence of Integration Step).gaml    == $0  == $0  == $0    SIR (Simple)    == $0  == $0  == $0    SIR (Simple)    == $0    SIR (Split in Agents, Multiple Strains)    == $0  == $0 ","url":"wiki/Ordinary-Differential-Equations.md"},{"id":"wiki/Physics-Engine.md","title":" Physics Engine","content":"Physics Engine  This sub-section is composed of the following models :   Falling Balls Balls without gravity Pool using Physic Engine Water Tank      ","url":"wiki/Physics-Engine.md"},{"id":"wiki/Agent-movement-Follow-Path.md","title":"  Movement of an agent on different paths","content":"#  Movement of an agent on different paths  _Author : _  Model showing the movement of an agent following three different paths : one defined by its vertices, an other defined thanks to all the roads species, and finally a path defined by a graph with weights (graph created thanks to an other species)  Code of the model :      model path_and_follow  global{  graph the_graph;     init{       //It is possible to define a road by defining its shape, being a line. The line need to be created by passing the location of the vertices create road {   shape <- line([{0,50},{40,60}]); } create road {   shape <- line([{40,60},{50,50},{55,60}]); } create road {   shape <- line([{55,60},{65,40}]); }     create road_of_graph {      shape <- line([{65,40},{75,35}]);    }    create road_of_graph {      shape <- line([{75,35},{85,40},{80,60}]);    }    //It is possible to define a weights map by linking the road and their weights (the road will be the key of the weight)    map<road_of_graph,float> weight_map <- road_of_graph as_map (each::each.shape.perimeter * 10); //A graph can be defined by using a list or all the agents of a species and it is possible to use a map of weights with each key     // of the map being a road to link the road and its weight    //The as_edge_graph operator is an operator creating a graph using the list of agents passed as edges of the graph    the_graph <- as_edge_graph(road_of_graph) with_weights weight_map;       create myCircle {      location <- {0,0};    }    }   }   species myCircle skills:[moving]{  //The different ways to declare a path : declaring all the lines of the path using their vertices  //         using a list of agents representing the lines of the path  //         using the graph as a path    path path_to_follow1 <- path([{0,0},{10,10},{0,20},{20,30},{20,40},{0,50}]);    path path_to_follow2 <- path(list(road));    path path_to_follow3 <- list(road_of_graph) as_path the_graph;     //These two variables will change when the cycle will be higher than 100 and 200   path path_following<- path_to_follow1;   rgb color <- #green;  reflex myfollow{   //The operator follow make the agent move from the starting vertice of the starting edge of a path to the last vertice of the last edge of the path  // but following the edges of the concerned path   do follow path: path_following;    if(cycle>200)   {    path_following<- path_to_follow3;     color<-#pink;   }   else   {    if(cycle>100)    {     path_following<- path_to_follow2;      color<-#blue;    }   } }  aspect base {   draw circle(1) color:#red ;    //We loop on all the edges of the path the agent follow to display them    loop seg over: path_following.edges {     draw seg color: color;    }    }  }   species road {  aspect base {    draw shape color:#blue ;  }  }   species road_of_graph {  aspect base {    draw shape color:#red ;  }  }   experiment main type: gui {  float minimum_cycle_duration <- 0.10;  output {   display myView {     species myCircle aspect:base;    }  } }      ","url":"wiki/Agent-movement-Follow-Path.md"},{"id":"wiki/Agent-movement-Follow-Weighted-Network-(Agents).md","title":"  Follow Weighted Network","content":"#  Follow Weighted Network  Author :  Martine Taillandier  Model representing how to make a weighted graph and the impacts of the weights on the time to follow the path for the agents. Two agents are represented to show this difference : one knowing the weights and following a fast path, an other following a path longer without knowing it s a longer path.  Code of the model :       model weightperagents  global {  map<road, float> roads_weight;  graph road_network;  float slow_coeff <- 3.0;  init {   //This road will be slow   create road {    shape <- line ([{10,50},{90,50}]);    slow <- true;   }   //The others will be faster   create road {    shape <- line ([{10,50},{10,10}]);    slow <- false;   }   create road {    shape <- line ([{10,10},{90,10}]);    slow <- false;   }   create road {    shape <- line ([{90,10},{90,50}]);    slow <- false;   }   //Weights map of the graph for those who will know the shortest road by taking into account the weight of the edges  roads_weight <- road as_map (each:: each.shape.perimeter * (each.slow ? slow_coeff : 1.0));  road_network <- as_edge_graph(road);    //people with information about the traffic  create people {   color <- #blue;   size <- 2.0;   roads_knowledge <- roads_weight;  }    //people without information about the traffic  create people {   color <- #yellow;   size <- 1.0;   roads_knowledge <- road as_map (each:: each.shape.perimeter);  } }   }  species road {  bool slow;  aspect geom {   draw shape color: slow ? #red : #green;  } }  species people skills: [moving] {  map<road, float> roads_knowledge;  point the_target;  rgb color;  float size;  path path_to_follow;  init {  the_target <- {90,50};  location <- {10,50}; }   reflex movement when: location != the_target{  if (path_to_follow = nil) {      //Find the shortest path using the agent s own weights to compute the shortest path   path_to_follow <- path_between(road_network with_weights roads_knowledge, location,the_target);  }  //the agent follows the path it computed but with the real weights of the graph  do follow path:path_to_follow speed: 5 move_weights: roads_weight; }   aspect base {  draw circle(size) color: color; } }   experiment weightperagents type: gui {  float minimum_cycle_duration <- 0.1;  output {   display map {    species road aspect: geom;    species people aspect: base;   }  } }     ","url":"wiki/Agent-movement-Follow-Weighted-Network-(Agents).md"},{"id":"wiki/Agent-movement-Goto-Directed-Graph.md","title":"  Directed Graph Model","content":"#  Directed Graph Model  Author :  Patrick Taillandier  Model representing how to directed graph using GIS Data for the road networks : the GIS contains a column defining the direction of the roads and people moving from one random point to another on this graph  Code of the model :       model simplemodel  global {  file road_file <- file( ../includes/gis/roads.shp );  geometry shape <- envelope(road_file);  graph the_graph;  init {  create road from: road_file with:[direction::int(read(DIRECTION))] {   switch direction {    match 0 {color <- #green;}    match 1 {color <- #red;     //inversion of the road geometry     shape <- polyline(reverse(shape.points));    }    match 2 {color <- #blue;     //bidirectional: creation of the inverse road     create road {      shape <- polyline(reverse(myself.shape.points));      direction <- 2;      color <- #blue;     }    }    }  }  //The operator directed modify the graph created by as_edge_graph(road) to a directed graph  the_graph <- directed(as_edge_graph(road)) ;      create people number: 1000 {   //The operator any_location_in returns a random point located in one of the road agents   target <- any_location_in(one_of (road)) ;   location <- any_location_in (one_of(road));   source <- location;  }  } }   species road {  int direction;  rgb color;  aspect geom {   draw shape color: color;  } } //The people agents use the skill moving which have built-in variables such as speed, target, location, heading and built-in operators species people skills: [moving] {  point target;  path my_path;   point source;  string r_s;  string r_t;   aspect circle {   draw circle(10) color: #green;  }  reflex movement {    //The operator goto is a built-in operator derivated from the moving skill, moving the agent from its location to its target,   //   restricted by the on variable, with the speed and returning the path followed  my_path <- self goto (on:the_graph, target:target, speed:10, return_path: true);    //If the agent arrived to its target location, then it choose randomly an other target on the road  if (target = location) {      target <- any_location_in(one_of (road)) ;   source <- location;  } } }   experiment simplemodel type: gui {  output {   display map {    species road aspect: geom;    species people aspect: circle;   }  } }     ","url":"wiki/Agent-movement-Goto-Directed-Graph.md"},{"id":"wiki/Agent-movement-Goto-Grid.md","title":"  Movement on a Grid of Cells","content":"#  Movement on a Grid of Cells  Author :  Patrick Taillandier  Model to represent how the agents move from one point to a target agent on a grid of cells with obstacles, following the shortest path and coloring in magenta the cells intersecting the path of an agent  Code of the model :       model Grid  global {  init {     create goal{    location <- (one_of (cell where not each.is_obstacle)).location;   }   create people number: 10 {    target <- one_of (goal);    location <-  (one_of (cell where not each.is_obstacle)).location;   }  }  }  grid cell width: 50 height: 50 neighbors: 4 {  bool is_obstacle <- flip(0.2);  rgb color <- is_obstacle ? #black : #white; }  species goal {  aspect default {    draw circle(0.5) color: #red;  } }  species people skills: [moving] {  goal target;  float speed <- float(3);  aspect default {  draw circle(0.5) color: #green; }  reflex move when: location != target{  //Neighs contains all the neighbours cells that are reachable by the agent plus the cell where it s located  list<cell> neighs <- (cell(location) neighbors_at speed) + cell(location);     //We restrain the movements of the agents only at the grid of cells that are not obstacle using the on facet of the goto operator and we return the path  //followed by the agent  //the recompute_path is used to precise that we do not need to recompute the shortest path at each movement (gain of computation time): the obtsacles on the grid never change.  path followed_path <- self goto (on:(cell where not each.is_obstacle), target:target, speed:speed, return_path:true, recompute_path: false);    //As a side note, it is also possible to use the path_between operator and follow action with a grid  //Add a my_path attribute of type path to the people species  //if my_path = nil {my_path <- path_between((cell where not each.is_obstacle), location, target);}  //path followed_path <- self follow (path: my_path,  return_path:true);    if (followed_path != nil) and not empty(followed_path.segments) {   geometry path_geom <- geometry(followed_path.segments);      //The cells intersecting the path followed by the agent are colored in magenta   ask (neighs where (each.shape intersects path_geom)) { color <- #magenta;}  }  } }   experiment goto_grid type: gui {  output {   display objects_display {    grid cell lines: #black;    species goal aspect: default ;    species people aspect: default ;   }  } }     ","url":"wiki/Agent-movement-Goto-Grid.md"},{"id":"wiki/Agent-movement-Goto-Network.md","title":"  Shortest Path Computation on a Graph","content":"#  Shortest Path Computation on a Graph  Author :  Patrick Taillandier  Model to show how to use the optimizer methods to compute the shortest path for the agents placed on a network with all of them having the same goal location. It also shows how to save these paths computed into a text file.  Code of the model :       model Network  global {  file shape_file_in <- file( ../includes/gis/roads.shp ) ;  graph the_graph;   geometry shape <- envelope(shape_file_in);  bool save_shortest_paths <- false;  bool load_shortest_paths <- false;  string shortest_paths_file <-  ../includes/shortest_paths.csv ;  bool memorize_shortest_paths <- true;  /*4 type of optimizer can be used for the shortest path computation:  *    - Djikstra: the default one - ensure to find the best shortest path - compute one shortest path at a time (by default, memorise the shortest path found)  *    - Bellmann: ensure to find the best shortest path - compute one shortest path at a time (by default, memorise the shortest path found)  *    - AStar: do not ensure to find the best shortest path - compute one shortest path at a time (by default, memorise the shortest path found)  *    - Floyd Warshall: ensure to find the best shortest path - compute all the shortest pathes at the same time (and keep them in memory)  */ string optimizer_type <- Djikstra; int nb_people <- 100; init {      create road from: shape_file_in ;  the_graph <- as_edge_graph(list(road));    //allows to choose the type of algorithm to use compute the shortest paths  the_graph <- the_graph with_optimizer_type optimizer_type;    //allows to define if the shortest paths computed should be memorized (in a cache) or not  the_graph <- the_graph use_cache memorize_shortest_paths;    //computes all the shortest paths, puts them in a matrix, then saves the matrix in a file  if save_shortest_paths {   matrix ssp <- all_pairs_shortest_path(the_graph);   save ssp type:text to:shortest_paths_file;     //loads the file of the shortest paths as a matrix and uses it to initialize all the shortest paths of the graph  } else if load_shortest_paths {   the_graph <- the_graph load_shortest_paths matrix(file(shortest_paths_file));  }    create goal number: 1 {   location <- any_location_in (one_of(road));  }  create people number: nb_people {   target <- one_of (goal) ;   location <- any_location_in (one_of(road));  }  } }   species road  {  float speed_coef ;  aspect default {   draw shape color: #black ;  } }  species goal {  aspect default {   draw circle(50) color: #red;  } }  species people skills: [moving] {  goal target;  path my_path;  aspect default {  draw circle(50) color: #green; } reflex movement {  do goto on:the_graph target:target speed:1; } }   experiment goto_network type: gui {  parameter  Type of optimizer  var: optimizer_type among: [ Djikstra ,  AStar ,  Bellmann ,  Floyd Warshall ];  parameter  Number of people  var: nb_people min: 1 max: 1000000;  parameter  Computed all the shortest paths and save the results  var: save_shortest_paths;  parameter  Load the shortest paths from the file  var: load_shortest_paths;  output {  display objects_display {   species road aspect: default ;   species people aspect: default ;   species goal aspect: default ;  } } }      ","url":"wiki/Agent-movement-Goto-Network.md"},{"id":"wiki/Agent-movement-Goto-Polygon.md","title":"  Movement on a Graph created by Polygons","content":"#  Movement on a Graph created by Polygons  Author :  Patrick Taillandier  Model to show how to create a graph using a polygon shapefile by skeletonizing it, and creating roads using the skeleton. All of the agents will use this graph to go to the same targeted location.  Code of the model :       model polygon global {  //Import of the shapefile containing the different polygons  file shape_file_in <- file( ../includes/gis/squareHole.shp ) ;  graph the_graph;  geometry shape <- envelope(shape_file_in);  init {      create object from: shape_file_in ;  object the_object <- first(object);    //triangulation of the object to get the different triangles of the polygons  list<geometry> triangles <- list(triangulate(the_object));    loop trig over: triangles {   create triangle_obj {    shape <- trig;   }  }    //creation of a list of skeleton from the object   list<geometry> skeletons <- list(skeletonize(the_object));    //Split of the skeletons list according to their intersection points  list<geometry> skeletons_split  <- split_lines(skeletons);  loop sk over: skeletons_split {   create skeleton {    shape <- sk;   }  }    //Creation of the graph using the edges resulting of the splitted skeleton   the_graph <- as_edge_graph(skeleton);        create goal  {    location <- any_location_in (one_of(skeleton));   }  create people number: 100 {    target <- one_of (goal) ;     location <- any_location_in (one_of(skeleton));  }  } }   species object  {  aspect default {   draw shape color: #gray ;  } }  species triangle_obj  {  rgb color <- rgb(150 +rnd(100),150 + rnd(100),150 + rnd(100));  aspect default {   draw shape color: color ;   } }  species skeleton  {  aspect default {   draw shape + 0.2 color: #red ;  } }  species goal {  aspect default {   draw circle(3) color:#red;  } }  species people skills: [moving] {  goal target;  path my_path;  reflex goto {  do goto on:the_graph target:target speed:1; } aspect default {  draw circle(3) color: #green; } }   experiment goto_polygon type: gui {  output {   display objects_display {    species object aspect: default ;    species triangle_obj aspect: default ;    species skeleton aspect: default ;    species people aspect: default ;    species goal aspect: default ;   }  } }      ","url":"wiki/Agent-movement-Goto-Polygon.md"},{"id":"wiki/Agent-movement-Moving3D.md","title":"  Movement in 3D","content":"#  Movement in 3D  Author :  Arnaud Grignard - Tri Nguyen Huu  This model illustrates the different action and effect offered by the movingSkill3D (move,wander,goto and follow)  Code of the model :       model Moving3DModel  global {  int number_of_agents parameter:  Number of Agents  min: 1 <- 250 step:10 category:  Initialization ;   int envSize <-100; //max:100;  int mazeSize <-10;  int radius parameter:  Radius  min: 1 <- 1 ;  int directionSize parameter:  direction size  min: 1 <- 10 ;  string effectType <-  ;// among:[  , firework ,  blob , direction ];  string movingType <- move ;  graph mazeGraph;  geometry shape <- cube(envSize);  bool trace <-false;  string agentAspect <-  sphere  among:[ circle ,  sphere , direction ];  init {     if(movingType = move or movingType = complete){    create movingAgent number: number_of_agents{     if(effectType = firework){       location <- {envSize/2, envSize/2, envSize/2};      }     else{      location <- {rnd(envSize), rnd(envSize), rnd(envSize)};     }      color<-°red;     }   }    if(movingType = wander or movingType = complete){   create wanderAgent number: number_of_agents{     location <- {rnd(envSize), rnd(envSize), rnd(envSize)};     color<-°green;    }  }    if(movingType = goto or movingType = complete){   create gotoAgent number: number_of_agents{     location <- {rnd(envSize), rnd(envSize), rnd(envSize)};     myTarget <-{rnd(envSize),rnd(envSize),rnd(envSize)};     color<-°yellow;   }  }    if(movingType = gotoOnNetwork or movingType = complete){      loop i from:0 to:mazeSize{        loop j from:0 to: mazeSize{       loop k from:0 to:mazeSize{         create cell{        location <-{(i)*envSize/mazeSize,(j)*envSize/mazeSize, (k)*envSize/mazeSize};         }        }  }      }      create gotoAgentOnNetwork number: number_of_agents{     location <- {floor(rnd(envSize)/mazeSize)*10, floor(rnd(envSize)/mazeSize)*10, floor(rnd(envSize)/mazeSize)*10};     myTarget <-{0,0,0};     speed <-0.1;     color<-°orange;     }      mazeGraph <- as_distance_graph(cell, [distance::10.0,species::edge_agent]);  }  } }   species abstractAgent skills: [moving3D]{  rgb color;  aspect default {   if(agentAspect =  sphere ){    draw sphere(radius) color:color;   }   if(agentAspect =  circle ){    draw circle(radius) color:color;   }   if(agentAspect =  direction ){     draw sphere(radius) color:color; draw line([{location.x,location.y,location.z},{location.x+directionSizecos(pitch)cos(heading),location.y+directionSizecos(pitch)sin(heading),location.z+directionSize*sin(pitch)}]) end_arrow:1.0 color:color;    }          } }  species movingAgent  parent:abstractAgent{   reflex move{    do move;  }   }  species wanderAgent parent:abstractAgent{   reflex wander{    do wander amplitude:90;  } }  species gotoAgent parent:abstractAgent{   point myTarget;  string gotoType;  reflex goto{   if(effectType =  blob ){    myTarget<-{rnd(envSize),rnd(envSize),rnd(envSize)};   }     do goto target:myTarget;   } }  species gotoAgentOnNetwork parent:abstractAgent{   point myTarget;  string gotoType;  reflex goto{     do goto target:myTarget on: mazeGraph;  }   }  species followAgent parent:abstractAgent{   point myTarget;  string gotoType;  reflex goto{    if(gotoType =  goto ){     do goto target:myTarget;    }    if(gotoType =  gotoOnNetwork ){     do goto target:myTarget on: mazeGraph;    }  }  }   species cell schedules:[]{  aspect myPoint{  draw sphere(0.01 * envSize/mazeSize) color:rgb(255,255,255,0.5) at:location ; }   }  species edge_agent schedules:[]{  aspect base2 {   draw shape color: rgb(255,255,255);  } }  experiment Moving  type: gui {  parameter  Trace  var:trace <- false;  parameter  Movement  var:movingType <-  move ;  parameter  Agent Aspect  var:agentAspect <-  direction ;  parameter  Effect type  var:effectType <-    among:[  , firework ];  output {    display MovingAgent type:opengl  background:rgb(10,40,55) {    species movingAgent trace:trace;   }  } }  experiment Wandering  type: gui {  parameter  Trace  var:trace <- false;  parameter  Movement  var:movingType <-  wander ;  parameter  Agent Aspect  var:agentAspect <-  direction ;  output {    display WanderingAgent type:opengl  background:rgb(10,40,55) {    species wanderAgent trace:trace;   }  } }  experiment Goto  type: gui {  parameter  Trace  var:trace <- false;  parameter  Movement  var:movingType <-  goto ;  parameter  Agent Aspect  var:agentAspect <-  direction ;  parameter  Effect Type  var:effectType <-    among:[  , blob ];  output {    display GotoAgent type:opengl  background:rgb(10,40,55) {    species gotoAgent trace:trace;   }  } }  experiment GotoOnNetwork  type: gui {  parameter  Trace  var:trace <- false;  parameter  Movement  var:movingType <-  gotoOnNetwork ;  parameter  Agent Aspect  var:agentAspect <-  direction ;  output {   display GotoOnNetworkAgent type:opengl background:rgb(10,40,55) {   species gotoAgentOnNetwork trace:trace;   species cell aspect:myPoint;   species edge_agent aspect: base2 ;  } } }   experiment Complete  type: gui {  parameter  Trace  var:trace <- false;  parameter  Movement  var:movingType <-  complete ;  parameter  Agent Aspect  var:agentAspect <-  direction ;  output {   display GotoOnNetworkAgent type:opengl background:rgb(10,40,55) {   species movingAgent position:{0,0,0} trace:trace;   species wanderAgent position:{envSize,0,0} trace:trace;   species gotoAgent position:{envSize*2,0,0} trace:trace;   species gotoAgentOnNetwork position:{envSize*3,0,0} trace:trace;   species cell aspect:myPoint position:{envSize*3,0,0};   species edge_agent aspect: base2 position:{envSize*3,0,0};  } } }       ","url":"wiki/Agent-movement-Moving3D.md"},{"id":"wiki/Batch-Batch.md","title":"  Model using Batch mode","content":"#  Model using Batch mode  Author :  Patrick Taillandier  A model showing how to use batch experiments to find the best combination of parameters to minimize the numbers of infected people in a SIR infection model where agents infect others and become immune for a certain time. The batch mode uses three different methods : Exhaustive, GA and Tabu Search. The model proposes five experiments : one simple with a User Interface, one running 5 experiments and saving the data, and one for each strategy.  Code of the model :       model batch_example  global {     int number_people <- 300;  // The init number of people     int number_I <- 1 ; // The init number of infected     float infection_rate <- 0.1 ; // The infection rate  float infection_distance <- 5.0 ; // infection distance (in meters)  int immune_step <- 30 ; // number of steps before becoming immune after infection  int end_immunity_step <-50; // number of steps before not being immune anymore  float speed_people <- 5.0 ; // speed of the Host  int nb_infected <- 0; init {  create people number: number_people ;     ask (number_I among people) {      is_infected <- true;      color <- #red;     } } }   species people skills:[moving] {  bool is_infected <- false;  bool is_immune <- false;  rgb color <- #green;  int cpt <- 0;  reflex basic_move {   do wander speed: speed_people;  }  reflex end_of_immunity when: is_immune {  if (cpt > end_immunity_step) {   cpt <- 0;   is_immune <- false;   color <-  #green;  } else {   cpt <- cpt + 1;  } } reflex become_immune when: is_infected {  if (cpt > immune_step) {   cpt <- 0;   is_immune <- true;   is_infected <- false;   color <-  #blue;  } else {   cpt <- cpt + 1;  } } reflex become_infected when: not is_infected and not is_immune{  if (flip(infection_rate) and not empty(people at_distance infection_distance where each.is_infected)) {   is_infected <- true;   color <-  #red;   nb_infected <- nb_infected + 1;  } }  aspect default {   draw circle(1) color: color; } }   experiment Simple type:gui {  parameter  Infection Rate:  var: infection_rate;  parameter  Infection Distance:  var: infection_distance;  output {   monitor  nb of infected people  value: nb_infected;   display map {    species people aspect: default;   }  } }  // This experiment runs the simulation 5 times. // At the end of each simulation, the people agents are saved in a shapefile experiment  Run 5 simulations  type: batch repeat: 5 keep_seed: true until: ( time > 1000 ) {  // the reflex will be activated at the end of each run; in this experiment a run consists of the execution of 5 simulations (repeat: 5) reflex end_of_runs {  int cpt <- 0;  // each simulation of the run is an agent; it is possible to access to the list of these agents by using the variable simulations of the experiment.   // Another way of accessing to the simulations consists in using the name of model + _model: here batch_example_model  //in this example, we ask all the simulation agents of the run to save (at the end of the simulation) the people population in a shapefile with their is_infected and is_immune attributes   ask simulations  {   save people type: shp to: people_shape + cpt + .shp with: [is_infected::INFECTED, is_immune::IMMUNE];   cpt <- cpt + 1;  } } }   // This experiment explores two parameters with an exhaustive strategy, // repeating each simulation three times (the aggregated fitness correspond to the mean fitness),  // in order to find the best combination of parameters to minimize the number of infected people experiment  Exhaustive optimization  type: batch repeat: 5 keep_seed: true until: ( time > 1000 ) {  parameter  Infection rate  var: infection_rate among: [ 0.1 , 0.5 , 1.0 ];  parameter  Speed of people:  var: speed_people min: 1.0 max: 3.0 step:1.0;  method exhaustive minimize: nb_infected;  //the permanent section allows to define a output section that will be kept during all the batch experiment permanent {  display Comparison {   chart Number of people infected type: series {    //we can access to all the simulations of a run (here composed of 5 simulation -> repeat: 5) by the variable simulations of the experiment.    //here we display for the 5 simulations, the mean, min and max values of the nb_infected variable.    data Mean value: mean(simulations collect each.nb_infected ) style: spline color: #blue ;    data Min value:  min(simulations collect each.nb_infected ) style: spline color: #darkgreen ;    data Max value:  max(simulations collect each.nb_infected ) style: spline color: #red ;   }  }  } }   // This experiment explores two parameters with a GA strategy, // repeating each simulation three times (the aggregated fitness correspond to the min fitness),  // in order to find the best combination of parameters to minimize the number of infected people experiment Genetic type: batch keep_seed: true repeat: 3 until: ( time > 1000 ) {  parameter  Infection rate  var: infection_rate among: [ 0.1 ,0.2, 0.5 , 0.6,0.8, 1.0 ];  parameter  Speed of people:  var: speed_people min: 1.0 max: 10.0 step:1.0;  method genetic pop_dim: 3 crossover_prob: 0.7 mutation_prob: 0.1  nb_prelim_gen: 1 max_gen: 5  minimize: nb_infected  aggregation:  min ; }  // This experiment explores two parameters with a Tabu Search strategy, // repeating each simulation three times (the aggregated fitness correspond to the max fitness),  // in order to find the best combination of parameters to minimize the number of infected people experiment Tabu_Search type: batch keep_seed: true repeat: 3 until: ( time > 1000 ) {  parameter  Infection rate  var: infection_rate among: [ 0.1 ,0.2, 0.5 , 0.6,0.8, 1.0 ];  parameter  Speed of people:  var: speed_people min: 1.0 max: 10.0 step:1.0;  method tabu iter_max: 10 tabu_list_size: 5 minimize: nb_infected aggregation:  max ; }     ","url":"wiki/Batch-Batch.md"},{"id":"wiki/Charts-Ant-Foraging-(Charts-examples).md","title":" Ant Foraging (Charts examples)","content":"# Ant Foraging (Charts examples)  _Author : _  Toy Model ant using the question of how ants search food and use pheromons to return to their nest once they did find food. In this model, the charts are particularly used.  Code of the model :      model ants  global {  //Number of ants  int ants_number <- 100 min: 1 max: 2000 ;  //Evaporation value per cycle for the pheromons  float evaporation_per_cycle <- 5.0 min: 0.0 max: 240.0 ;  //Diffusion rate for the pheromons  float diffusion_rate <- 1.0 min: 0.0 max: 1.0 ;  bool use_icons <- true ;  bool display_state <- true;  //Size of the grid  int gridsize <- 75 ;  //Center of the grid to put the location of the nest  point center const: true <- { (gridsize / 2),  (gridsize / 2)} ;  file types const: true <- (pgm_file( ../images/environment75x75.pgm )) ;  string ant_shape_empty const: true <-  ../icons/ant.png  ;  string ant_shape_full const: true <-  ../icons/full_ant.png   ;  rgb C00CC00 const: true <- rgb( #00CC00 ) ;    rgb C009900 const: true <- rgb( #009900 ) ;   rgb C005500 const: true <- rgb( #005500 ) ;   int food_gathered <- 0 ;   geometry shape <- square(gridsize);  init{   //Ant are placed randomly in the nest   create ant number: ants_number with: [location::any_location_in (ant_grid(center))] ;  }  //Reflex to diffuse the road of pheromon on the grid reflex diffuse {   diffuse var:road on:ant_grid proportion: diffusion_rate radius:2 propagation: gradient;    }   }  //Grid to discretize space for the food and the nest grid ant_grid width: gridsize height: gridsize neighbors: 8 use_regular_agents: false {  bool multiagent <- true ;  float road <- 0.0 max:240.0 update: (road<=evaporation_per_cycle) ? 0.0 : road-evaporation_per_cycle;  int type <- int(types at {grid_x,grid_y}) ;  bool isNestLocation <- (self distance_to center) < 4 ;   bool isFoodLocation <- type = 2 ;   rgb color <- isNestLocation ? °violet:((food > 0)? °blue : ((road < 0.001)? rgb ([100,100,100]) : ((road > 2)? °white : ((road > 0.5)? (C00CC00) : ((road > 0.2)? (C009900) : (C005500)))))) update: isNestLocation ? °violet:((food > 0)? °blue : ((road < 0.001)? rgb ([100,100,100]) : ((road > 2)? °white : ((road > 0.5)? (C00CC00) : ((road > 0.2)? (C009900) : (C005500)))))) ;  int food <- isFoodLocation ? 5 : 0 ;  int nest const: true <- 300 - int(self distance_to center) ;  } //Species ant that will move and follow a final state machine species ant skills: [moving] control: fsm {  float speed <- 2.0 ;  ant_grid place update: ant_grid (location );   string im <-  ant_shape_empty  ;  bool hasFood <- false ;  reflex diffuse_road when:hasFood=true{   ant_grid(location).road <- ant_grid(location).road + 100.0;    }    //Action to pick food action pick {  im <- ant_shape_full ;  hasFood <- true ;  place.food <- place.food - 1 ; } //Action to drop food action drop {  food_gathered <- food_gathered + 1 ;  hasFood <- false ;  heading <- heading - 180 ; } //Action to chose the best place according to the possible food in the neighbour cells action choose_best_place type: ant_grid {  list<ant_grid> list_places <- place.neighbors ;  if (list_places count (each.food > 0)) > 0  {   return (list_places first_with (each.food > 0)) ;  } else {    int min_nest  <-  (list_places min_of (each.nest)) ;    list_places <- list_places sort ((each.nest = min_nest) ? each.road :  0.0) ;    return last(list_places) ;   } }  //Initial state of the ant : wander until it finds food or find a road to follow state wandering initial: true {  do wander amplitude:120 ;  transition to: carryingFood when: place.food > 0 {   do pick ;  }  transition to: followingRoad when: place.road > 0.05 ; } //State to carry food to the nest once the food is found state carryingFood {  do goto target: center ;  transition to: wandering when: place.isNestLocation {    do drop ;  } } //State to follow a road  state followingRoad {  location <- (self choose_best_place []) as point ;  transition to: carryingFood when: place.food > 0 {   do pick ;  }  transition to: wandering when: (place.road < 0.05) ; } aspect text {  if use_icons {   draw  hasFood ? file(ant_shape_full) : file(ant_shape_empty) rotate: heading at: location size: {7,5} ;  } else {   draw circle(1.0) empty: !hasFood color: rgb ( orange ) ;  }  if display_state {   draw state at: location + {-3,1.5} color: °white size: 0.8 ;  } } aspect default {  draw circle(1.0) empty: !hasFood color: #orange ;  } } experiment Ant type: gui { //Parameters to play with  in the gui parameter  Number of ants:  var: ants_number category:  Model  ; parameter  Evaporation of the signal (unit/cycle):  var: evaporation_per_cycle category:  Model  ; parameter  Rate of diffusion of the signal (%/cycle):  var: diffusion_rate category:  Model  ; parameter  Use icons for the agents:  var: use_icons category:  Display  ; parameter  Display state of agents:  var: display_state category:  Display  ;  list<list<int>> nbants<-[[0]]; list<string> statesnames<-[wandering]; list<string> categnames<-[empty,carry]; list<list<int>> nbantsbydist<-[[0]]; list xytestvallist<-[[[1,1],[2,2],[3,3]],[[1,2],[2,1],[3,4]],[[1,3],[2,3],[0,1]],[[1,4],[2,5],[0,0]]]; list<list<int>> xyval<-[[1,1],[2,1],[3,2]];  //Reflex to update the charts, belonging to the experiment bloc as it will not be used by other experiment which don t have the charts reflex update_charts {  nbants<-list<list<int>>([]);  statesnames<-list<string>([]);  categnames<-[empty,carry];  nbantsbydist<-list<list<int>>([]);  ant x<-one_of(world.ant);  loop x over:list(world.ant)  {   if !(statesnames contains (x.state))   {       add [(list(ant) count (each.state=x.state and !each.hasFood)),(list(ant) count (each.state=x.state and each.hasFood))] to: nbants;   add (x.state) to:statesnames;       int d<-0;   list<int> nl<-list<int>([]);   loop d from:0 to:9    {   add (list(ant) count (each.state=x.state and (((each distance_to center)>gridsize/20*d) and ((each distance_to center)<gridsize/20*(d+1))))) to: nl;    }   add nl to:nbantsbydist;   } //   add length((list(world.ant) collect (each.next_place distance_to each.location)) where (each=x)) to:nbants;  }  //write(nbants+nbants);  //write(nbantsbydist+nbantsbydist);  //write(states+statesnames);   }  //The different displays output {  display Ants type: opengl {   grid ant_grid ;   species ant aspect: text ;  }  display ProportionCarryFood {   chart Proportions carrying: Pie  size: {0.5,0.5} position: {0, 0} type:pie   {    data empty_ants value:(list(ant) count (!each.hasFood)) color:°red;    data carry_food_ants value:(list(ant) count (each.hasFood)) color:°green;       }      chart Proportions carrying: Radar  size: {0.5,0.5} position: {0.5, 0} type:radar   axes:#white    {    data empty value:(list(ant) count (!each.hasFood))     accumulate_values:true    color:°red;        data carry value:(list(ant) count (each.hasFood))     accumulate_values:true    color:°blue;       }      chart Proportion: serie   size: {1.0,0.5} position: {0, 0.5} type:series    series_label_position: legend   style:stack   {    datalist [empty,carry] accumulate_values:true     value:[(list(ant) count (!each.hasFood)),(list(ant) count (each.hasFood))]     color:[°red,°green];       }  } // idem with stacked bar: /*   display ProportionByState {   chart DataListListBar type:histogram    x_serie_labels: categnames    series_label_position: legend   {    datalist value:nbants legend:statesnames style:stack;   }     } */   // Idem with datalist: //  display PositionByState { //   chart Position by state (datalist) type:scatter //   { //    datalist [empty,carry] value:[((list(ant) where (!each.hasFood))  collect each.location),((list(ant) where (each.hasFood))  collect each.location)] color:[°red,°green] line_visible:false;     //   } //  }  display CentroidPosition {   chart Positions and History of Centroide and size by Carry state type:scatter   {    datalist [avg-carry,avg-empty] value:[mean((list(ant) where (each.hasFood)) collect each.location),     mean((list(ant) where (!each.hasFood)) collect each.location)    ]    marker_size: [length(list(ant) where (each.hasFood))/20,length(list(ant) where (!each.hasFood))/20]      color:[°red,°green]       fill:false      line_visible:true;        data empty_ants value:((list(ant) where (!each.hasFood)) collect each.location) color:°red     accumulate_values:false    line_visible:false;    data carry_food_ants value:((list(ant) where (each.hasFood)) collect each.location)     accumulate_values:false    color:°green line_visible:false;    }  }   display Distribution2dPosition {   chart Distribution of the X positions   size: {0.65,0.3} position: {0.05, 0} type:histogram      {    datalist (distribution_of(list(ant) collect each.location.x,10,0,100) at legend)      value:(distribution_of(list(ant) collect each.location.x,10,0,100) at values);   }   chart Distribution of the Y positions   size: {0.3,0.7} position: {0.7, 0.28} type:histogram   reverse_axes:true      {    datalist reverse(distribution_of(list(ant) collect each.location.x,10,0,100) at legend)      value:reverse(distribution_of(list(ant) collect each.location.x,10,0,100) at values);   }    chart Distribution2d of the XvsY positions- heatmap   size: {0.7,0.7} position: {0, 0.3} type:heatmap   x_serie_labels: (distribution2d_of(list(ant) collect each.location.x,list(ant) collect each.location.y,10,0,100,10,0,100) at legendx)   y_serie_labels: (distribution2d_of(list(ant) collect each.location.x,list(ant) collect each.location.y,10,0,100,10,0,100) at legendy)   series_label_position:none   {    data  XYdistrib     value:(distribution2d_of(list(ant) collect each.location.x,list(ant) collect each.location.y,10,0,100,10,0,100) at values)     color:[#red];   }  }    display DistributionPosition {   chart Distribution of the X positions   size: {0.92,0.3} position: {0, 0} type:histogram      {    datalist (distribution_of(list(ant) collect each.location.x,10,0,100) at legend)      value:(distribution_of(list(ant) collect each.location.x,10,0,100) at values);   }   chart Distribution of the X positions- heatmap   size: {1.0,0.7} position: {0, 0.3} type:heatmap   x_serie_labels: (distribution_of(list(ant) collect each.location.x,10,0,100) at legend)   y_range:50   {    data  Xdistrib     value:(distribution_of(list(ant) collect each.location.x,10,0,100) at values)     color:[#red];   }  }   }  }   //Experiment with only two display : the grid and the ants, and a chart experiment AntOneDisp type: gui {  parameter  Number of ants:  var: ants_number category:  Model  ;  parameter  Evaporation of the signal unit/cycle):  var: evaporation_per_cycle category:  Model  ;  parameter  Rate of diffusion of the signal (%/cycle):  var: diffusion_rate category:  Model  ;  parameter  Use icons for the agents:  var: use_icons category:  Display  ;  parameter  Display state of agents:  var: display_state category:  Display  ;  list<list<int>> nbants<-[[0]]; list<string> statesnames<-[]; list<string> categnames<-[empty,carry]; list<list<int>> nbantsbydist<-[[0]]; list xytestvallist<-[[[1,1],[2,2],[3,3]],[[1,2],[2,1],[3,4]],[[1,3],[2,3],[0,1]],[[1,4],[2,5],[0,0]]]; list<list<int>> xyval<-[[1,1],[2,1],[3,2]];  reflex update_charts {  ant x<-one_of(world.ant);  nbants<-list<list<int>>([]);  statesnames<-list<string>([]);  loop x over:list(world.ant)  {   if !(statesnames contains (x.state))   {       add [(list(ant) count (each.state=x.state and !each.hasFood)),(list(ant) count (each.state=x.state and each.hasFood))] to: nbants;   add (x.state) to:statesnames;       int d<-0;   list<int> nl<-list<int>([]);   loop d from:0 to:9    {   add (list(ant) count (each.state=x.state and (((each distance_to center)>gridsize/20*d) and ((each distance_to center)<gridsize/20*(d+1))))) to: nl;    }   add nl to:nbantsbydist;   }  }  write(nbants+nbants);  write(nbantsbydist+nbantsbydist);  write(states+statesnames);   } output {  display Ants type: opengl {   grid ant_grid ;   species ant aspect: text ;  }   display ChartScatter {   chart Distribution2d of the XvsY positions- heatmap   size: {0.7,0.7} position: {0, 0.3} type:heatmap   x_serie_labels: (distribution2d_of(list(ant) collect each.location.x,list(ant) collect each.location.y,10,0,100,10,0,100) at legendx)   y_serie_labels: (distribution2d_of(list(ant) collect each.location.x,list(ant) collect each.location.y,10,0,100,10,0,100) at legendy)   series_label_position:none   {    data  XYdistrib     value:(distribution2d_of(list(ant) collect each.location.x,list(ant) collect each.location.y,10,0,100,10,0,100) at values)     color:[#red];   }      } } }       ","url":"wiki/Charts-Ant-Foraging-(Charts-examples).md"},{"id":"wiki/Clustering-Clustering.md","title":"  Clustering of agents by K Means and DBScan","content":"#  Clustering of agents by K Means and DBScan  Author :  Patrick Taillandier  A model to show how to use clustering operators and two methods of clustering (K Means and DBScan) with the goal of regrouping agents in clusters  Code of the model :       model clustering  global {  //the number of groups to create (kmeans)  int k <- 4;  //the maximum radius of the neighborhood (DBscan) float eps <- 10.0;   //the minimum number of elements needed for a cluster (DBscan) int minPoints <- 3;  init {  //create dummy agents  create dummy number: 100; }  reflex cluster_building {  //create a list of list containing for each dummy agent a list composed of its x and y values  list<list> instances <- dummy collect ([each.location.x, each.location.y]);    //from the previous list, create groups with the eps and minPoints parameters and the DBSCAN algorithm (https://en.wikipedia.org/wiki/DBSCAN)  list<list<int>> clusters_dbscan <- list<list<int>>(dbscan(instances, eps,minPoints));    //We give a random color to each group (i.e. to each dummy agents of the group)    loop cluster over: clusters_dbscan {   rgb col <- rnd_color(255);   loop i over: cluster {    ask dummy[i] {color_dbscan <- col;}   }  }    //from the previous list, create k groups  with the Kmeans algorithm (https://en.wikipedia.org/wiki/K-means_clustering)  list<list<int>> clusters_kmeans <- list<list<int>>(kmeans(instances, k));    //We give a random color to each group (i.e. to each dummy agents of the group)  loop cluster over: clusters_kmeans {   rgb col <- rnd_color(255);   loop i over: cluster {    ask dummy[i] {color_kmeans <- col;}   }  } }   }  species dummy {  rgb color_dbscan <- #grey;  rgb color_kmeans <- #grey;  aspect dbscan_aspect {   draw circle(2) color: color_dbscan;  }  aspect kmeans_aspect {   draw circle(2) color: color_kmeans;  } }  experiment clustering type: gui {  parameter  Number of clusters to split the data into  var: k category:  KMEANS ;  parameter  Maximum radius of the neighborhood to be considered  var: eps category:  DBSCAN ;  parameter  Minimum number of points needed for a cluster   var: minPoints category:  DBSCAN ;  output {   display map_dbscan{    species dummy aspect: dbscan_aspect;   }   display map_kmeans{    species dummy aspect: kmeans_aspect;   }  } }     ","url":"wiki/Clustering-Clustering.md"},{"id":"wiki/Clustering-Spatial-Clustering.md","title":"  Clustering of agents by their distance ","content":"#  Clustering of agents by their distance  Author :  Patrick Taillandier  A model to show how to use clustering operators with simple_clustering_by_distance to take into account the distances between agents or between cells to create the clusters,  and showing the relations between the people from the same cluster.  Code of the model :       model clustering  global {  //define the maximal distance between people in the continuous environement (in meters): if the distance between 2 people is lower than this value, they will be in the same group  float max_dist_people <- 20.0;  //define the maximal distance between cells (in number of cells): if the distance between 2 cells is lower than this value, they will be in the same group int max_dist_cell <- 1;  //probability for a cell to have vegetation float proba_vegetation <- 0.2;  //create the people agents init {  create people number:20;  }  //reflex that builds the people clusters reflex people_clustering {  //clustering by using the simple clustering operator: two people agents are in the same groups if their distance is lower than max_dist_people (in meters)  //returns a list of lists (i.e. a list of groups, a group is a list of people agents)  list<list<people>> clusters <- list<list<people>>(simple_clustering_by_distance(people, max_dist_people));   //We give a random color to each group (i.e. to each people agents of the group)     loop cluster over: clusters {      rgb rnd_color <- rnd_color(255);      ask cluster {       color_cluster <- rnd_color;      }     }   //build the hierchical clustering (https://en.wikipedia.org/wiki/Hierarchical_clustering)     list clustering_tree <- hierarchical_clustering (people, max_dist_people);   //create groups from the results of the hierarchical clustering     do create_groups(clustering_tree, nil); }  //recursive action that create group_people agents from the list of group. action create_groups (list group, group_people parent_gp) {  bool compute_shape <- false;  loop el over: group {   if (el is people) {    parent_gp.shape <- people(el).shape;   }   else {    create group_people returns: created_g{     if (parent_gp != nil) {      add self to: parent_gp.sub_groups;     }     parent <- parent_gp;    }    do create_groups(el, first(created_g));    compute_shape <- true;   }  }  if (compute_shape and parent_gp != nil) {   ask parent_gp {    shape <- polyline (sub_groups collect each.location);   }     } } //reflex that builds the cell clusters reflex forest_clustering {  list<list<vegetation_cell>> clusters <- list<list<vegetation_cell>>(simple_clustering_by_distance(vegetation_cell where (each.color = #green), max_dist_cell));     loop cluster over: clusters {      create forest {       cells <- cluster;       shape <- union (cells);      }     }     list clustering_tree <- hierarchical_clustering (people, max_dist_people); }   } grid vegetation_cell width: 25 height: 25 neighbors: 4{  rgb color <- flip (proba_vegetation) ? #green : #white; }  species forest {  list cells;  aspect default {   draw shape.contour + 0.5 color: #red;  } }  species people {  rgb color_cluster <- #black;  rgb color_tree <- #black;  aspect cluster {   draw circle(2) color: color_cluster;  }  aspect tree {   draw circle(2) color: color_tree;  } }  species group_people {  list sub_groups;  group_people parent;  aspect default {   draw shape + 0.2 color: #red;   if (parent != nil) {    draw line ([location, parent.location]) end_arrow: 2 color: #red;   }  } }  experiment clustering type: gui {  parameter  Maximal distance for people clustering  var: max_dist_people min: 0.0 max: 100.0 category:  People ;  parameter  Maximal distance for vegetation cell clustering  var: max_dist_cell min: 0 max: 5 category:  Forest ;  parameter  Probability for vegetation cells  var: proba_vegetation min: 0.1 max: 1.0 category:  Forest ;  output {   display map_people_clusters {    species people aspect: cluster;   }   display map_people_tree {    species people aspect: tree;    species group_people;   }   display map_forest_clusters {    grid vegetation_cell lines: #black;    species forest;   }  } }     ","url":"wiki/Clustering-Spatial-Clustering.md"},{"id":"wiki/Co-model-Usage-comodel_mix_behaviors.md","title":" comodel with mixed behaviors ","content":"# comodel with mixed behaviors  Author : HUYNH Quang Nghi  This is a simple comodel serve to demonstrate the mixing behaviors of preyPredator with the Ants. Ants are the prey, fleeing from Predators, when they are not chasing, they try to do job of the ants.  Imported models :      model ants  global {  //Evaporation value per cycle  float evaporation_per_cycle <- 5.0 min: 0.0 max: 240.0 parameter:  Evaporation of the signal (unit/cycle):  category:  Signals ;  //Diffusion rate of the pheromon among the grid  float diffusion_rate <- 1.0 min: 0.0 max: 1.0 parameter:  Rate of diffusion of the signal (%/cycle):  category:  Signals ;  //Size of the grid  int gridsize <- 100 min: 30 parameter:  Width and Height of the grid:  category:  Environment and Population ;  //Number of ants  int ants_number <- 200 min: 1 parameter:  Number of ants:  category:  Environment and Population ;  //Frequency of update of the grid  int grid_frequency <- 1 min: 1 max: 100 parameter:  Grid updates itself every:  category:  Environment and Population ;  //Number of food places among the grid  int number_of_food_places <- 5 min: 1 parameter:  Number of food depots:  category:  Environment and Population ;  float grid_transparency <- 1.0;  file ant_shape_empty const: true <- file( ../icons/ant.png );  image_file ant_shape_full const: true <- file( ../icons/full_ant.png );  //The center of the grid that will be considered as the nest location  point center const: true <- { round(gridsize / 2), round(gridsize / 2) };  int food_gathered <- 1;  int food_placed <- 1;  rgb background const: true <- rgb(#99CC66);  rgb food_color const: true <- rgb(#312200);  rgb nest_color const: true <- rgb(#000000);  geometry shape <- square(gridsize); init {  //Creation of the food places placed randomly with a certain distance between each  loop times: number_of_food_places {   point loc <- { rnd(gridsize - 10) + 5, rnd(gridsize - 10) + 5 };   list<ant_grid> food_places <- (ant_grid where ((each distance_to loc) < 5));   ask food_places {    if food = 0 {     food <- 5;     food_placed <- food_placed + 5;     color <- food_color;      }      }  }  //Creation of the ants that will be placed in the nest  create ant number: ants_number with: (location: center); } //Reflex to diffuse the pheromon among the grid reflex diffuse {   diffuse var:road on:ant_grid proportion: diffusion_rate radius:3 propagation: gradient method:convolution;    }   }  //Grid used to discretize the space to place food grid ant_grid width: gridsize height: gridsize neighbors: 8 frequency: grid_frequency use_regular_agents: false use_individual_shapes: false{  bool is_nest const: true <- (topology(ant_grid) distance_between [self, center]) < 4;  float road <- 0.0 max: 240.0 update: (road <= evaporation_per_cycle) ? 0.0 : road - evaporation_per_cycle;  rgb color <- is_nest ? nest_color : ((food > 0) ? food_color : ((road < 0.001) ? background : rgb(#009900) + int(road * 5))) update: is_nest ? nest_color : ((food > 0) ?  food_color : ((road < 0.001) ? background : rgb(#009900) + int(road * 5)));  int food <- 0; } //Species ant that will move and follow a final state machine species ant skills: [moving] control: fsm {  float speed <- 1.0;  bool has_food <- false;  //Reflex to place a pheromon stock in the cell reflex diffuse_road when:has_food=true{   ant_grid(location).road <- ant_grid(location).road + 100.0;    } //Action to pick food action pick (int amount) {  has_food <- true;  ant_grid place <- ant_grid(location);  place.food <- place.food - amount; } //Action to drop food action drop {  food_gathered <- food_gathered + 1;  has_food <- false;  heading <- heading - 180; } //Action to find the best place in the neighborhood cells point choose_best_place {  container list_places <- ant_grid(location).neighbors;  if (list_places count (each.food > 0)) > 0 {   return point(list_places first_with (each.food > 0));  } else {   list_places <- (list_places where ((each.road > 0) and ((each distance_to center) > (self distance_to center)))) sort_by (each.road);   return point(last(list_places));  }  } //Reflex to drop food once the ant is in the nest reflex drop when: has_food and (ant_grid(location)).is_nest {  do drop(); } //Reflex to pick food when there is one at the same location reflex pick when: !has_food and (ant_grid(location)).food > 0 {  do pick(1); } //Initial state to make the ant wander  state wandering initial: true {  do wander(amplitude: 90);  float pr <- (ant_grid(location)).road;  transition to: carryingFood when: has_food;  transition to: followingRoad when: (pr > 0.05) and (pr < 4); } //State to carry food once it has been found state carryingFood {  do goto(target: center);  transition to: wandering when: !has_food; } //State to follow a pheromon road if once has been found state followingRoad {  point next_place <- choose_best_place();  float pr <- (ant_grid(location)).road;  location <- next_place;  transition to: carryingFood when: has_food;  transition to: wandering when: (pr < 0.05) or (next_place = nil); }  aspect info {  draw circle(1) empty: !has_food color: #red;  if (destination != nil) {   draw line([location + {0,0,0.5}, destination + {0,0,0.5}]) + 0.1 color: #white border: false;  }   draw circle(4) empty: true color: #white;  draw string(self as int) color: #white font: font(Helvetica, 12 * #zoom, #bold) at: my location - {1, 1, -0.5};  draw state color: #yellow  font: font(Helvetica, 10 * #zoom, #plain) at: my location + { 1, 1, 0.5 } perspective: false; }  aspect icon {  draw ant_shape_empty size: {7,5} rotate: my heading + 1; }  aspect default {  draw square(1) empty: !has_food color: #blue rotate: my heading; } }  //Simple experiment to display the ants experiment Displays type: gui { point quadrant_size <- { 0.5, 0.5 }; float inc <- 0.001; float pos <- 0.0; reflex moving_quadrant { //pos <- pos + inc;  if (pos > 0.5 or pos <= 0) {   inc <- -inc;  }   }  output {  display Ants background: #white type: opengl {   image  ../images/soil.jpg  position: { pos, pos } size: quadrant_size;   agents agents transparency: 0.5 position: { pos, pos } size: quadrant_size value: (ant_grid as list) where ((each.food > 0) or (each.road > 0) or (each.is_nest));   species ant position: { pos, pos } size: quadrant_size aspect: icon;   grid ant_grid lines: #darkgray position: { 0.5, 0 } size: quadrant_size;   species ant position: { 0.5, 0 } size: quadrant_size aspect: info;  } } } //Complete experiment that will inspect all ants in a table experiment Complete type: gui { parameter  Number:  var: ants_number init: 100 unit:  ants  category:  Environment and Population ; parameter  Grid dimension:  var: gridsize init: 100 unit:  (number of rows and columns)  category:  Environment and Population ; parameter  Number of food depots:  var: number_of_food_places init: 5 min: 1 category:  Environment and Population ;  // Experimentator  init {  write Experimentator agent running  + self;    ants_number <- 200; }   output {  display Ants2D type: java2D {   image  ../images/soil.jpg  position: { 0.05, 0.05 } size: { 0.9, 0.9 };   agents agents transparency: 0.7 position: { 0.05, 0.05 } size: { 0.9, 0.9 } value: (ant_grid as list) where ((each.food > 0) or (each.road > 0) or (each.is_nest)) ;   species ant position: { 0.05, 0.05 } size: { 0.9, 0.9 } aspect: icon;   overlay Texts transparency: 0.3 background: rgb (99, 85, 66,255)  position: {10°px, 10°px} size: {250°px, 150°px} border: rgb (99, 85, 66,255) rounded: true{    draw ant_shape_full at: {60°px, 70°px} size: {140°px, 100°px} rotate: -60;    draw ( Food foraged:   + (((food_placed = 0 ? 0 : food_gathered / food_placed) * 100) with_precision 2) +  % ) at: {40°px,70°px} font:font(Arial, 18, #bold) color: #white;    draw ( Carrying ants:   + (((100 * ant count (each.has_food or each.state = followingRoad)) / length(ant)) with_precision 2) +  % ) at: {40°px, 100°px} font:font(Arial, 18 , #bold) color: #white;   }       }  inspect All ants type: table value: ant attributes: [ name ,  location ,  heading , state ]; } } //Batch experiment to find the best way to maximize the food gathered using exhaustive method experiment Batch type: batch repeat: 4 keep_seed: true until: (food_gathered = food_placed) or (time > 1000) { parameter  Size of the grid:  var: gridsize init: 75 unit:  width and height ; parameter  Number:  var: ants_number among:[10,20,50] unit:  ants ; parameter   Evaporation:  var: evaporation_per_cycle among: [0.1, 0.5, 2.0, 10.0] unit:  units every cycle ; parameter   Diffusion:  var: diffusion_rate min: 0.1 max: 1.0 unit:  rate every cycle (1.0 means 100%)  step: 0.2; method exhaustive maximize: food_gathered;   permanent {  display Comparison background: #white {   chart Food Gathered type: series {     data Min value:  min(ants_model collect each.food_gathered ) style: spline color: #darkgreen ;     data Max value:  max(ants_model collect each.food_gathered ) style: spline color: #red ;   }  } } }   //Batch experiment to find the best way to maximize the food gathered using genetic method experiment Genetic type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed) or (time > 1000) {  parameter  Size of the grid:  var: gridsize init: 75 unit:  (width and height) ;  parameter  Number:  var: ants_number among:[10,20,50] unit:  ants ;  parameter   Evaporation:  var: evaporation_per_cycle among: [0.1, 0.5, 2.0, 10.0] unit:  units every cycle ;  parameter  Diffusion:  var: diffusion_rate min: 0.1 max: 1.0 unit:  rate every cycle (1.0 means 100%)  step: 0.2;  method genetic maximize: food_gathered pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 20;   permanent {  display Comparison background: #white {   chart Food Gathered type: series {     data Min value:  min(ants_model collect each.food_gathered ) style: spline color: #darkgreen ;     data Max value:  max(ants_model collect each.food_gathered ) style: spline color: #red ;   }  } } }            model Ants_coupling  import  ../../../Toy Models/Ants (Foraging and Sorting)/models/Ant Foraging (Complex).gaml   experiment Ants_coupling_exp type:gui  parent:Complete{  list<ant> getAnts{  return list(ant); }  list<ant_grid> getAnt_grid{  return list(ant_grid); }  output{  } }           model PreyPredator  global {  geometry shape <- square(100);  float perceipt_radius <- 20.0;  int preyinit <- 500;  int predatorinit <- 3;  list lstPredator <- list(predator);  list lstPrey <- list(prey);  init  {   create prey number: preyinit;   create predator number: predatorinit;   lstPredator <- list(predator);   lstPrey <- list(prey);  }  }  species generic_species skills: [moving] {  float speed <- 1.0;  point goal <- nil;  bool is_chased <- false;  reflex live_with_my_goal  {   if (goal != nil)   {    do wander speed: speed;    do goto target: goal speed: speed;   } else   {    do wander speed: speed;   }  }   }  species prey parent: generic_species {  geometry shape <- circle(0.5);  float speed <- 0.2;  rgb color <- # green;  reflex fleeing  {   if (length((lstPredator where (each != nil and !dead(each) and each distance_to self < perceipt_radius))) > 0)   {    speed <- 1.0;    is_chased <- true;    color <- # lime;    if (goal = nil)    {     agent a <- any(((lstPrey where (each != nil and !dead(each) and !generic_species(each).is_chased))));     if (a != nil and !dead(a))     {      if (flip(0.5))      {       goal <- a.location;      } else      {       goal <- any_location_in(world.shape);      }     } else    {     goal <- any_location_in(world.shape);    }    }   }   if (goal != nil and self.location distance_to goal < 0.5)  {   goal <- nil;  }   if (length((lstPredator where (each != nil and !dead(each))) where (each distance_to self <= perceipt_radius)) = 0)  {   is_chased <- false;   color <- # green;   speed <- 0.2;  }  }  aspect default {  draw shape color: color; }   }  species predator parent: generic_species {  geometry shape <- triangle(2);  rgb color <- # red;  reflex hunting  {   if (goal = nil)   {    list tmp <- (lstPrey where (!dead(each) and each.shape distance_to self.shape < perceipt_radius));    if (length(tmp) > 0)    {     agent a <- first(tmp sort (each.shape distance_to self.shape));     if (a = nil)     {      a <- any((lstPrey where (!dead(each))));     }     if (a != nil)    {     speed <- 2.0;     goal <- a.location;    }    }   } else if ((self.location distance_to goal < 0.5))  {   ask lstPrey where (!dead(each) and each.location distance_to goal < 0.5)   {    do die;   }    goal <- nil;   speed <- 1.0;  }  }  aspect default {  draw circle(perceipt_radius) color: # pink empty: true;  draw shape color: color rotate: 90 + my heading; }   }  experiment prey_predator_exp type: gui {  output  {   display main_display   {   species prey;   species predator;  }  }   }          model PreyPredator_coupling import  PreyPredator.gaml   global {  }  experiment PreyPredator_coupling_exp parent:prey_predator_exp type: gui { geometry shape<- square(100);  list getPrey{   return list(prey);  }   list getPredator{   return list(predator);  }  //if we redefine the output, i.e, a blank output, the displays in parent experiement dont show. output { }   }       Code of the model :      model comodel_mix_behaviors  import  PreyPredator_coupling.gaml  as myPreyPredator import  Ants_coupling.gaml  as myAnt  global {  //set the shape of environment: square 100   geometry shape <- square(100);  // the variable that refer to the ants population in micro-model   list theAnts;  // the variable that refer to the prey population in micro-model  list thePreys;  init {  //create the Ants micro-model with the size of grid is 100 and the population have 500 ants.  create myAnt.Ants_coupling_exp with: [gridsize::100,ants_number::500];  //create the PreyPredator micro-model with the parameters and the number of the prey is equal with the size of ants population  create myPreyPredator.PreyPredator_coupling_exp with: [shape::square(100), preyinit::myAnt.Ants_coupling_exp[0].simulation.ants_number, predatorinit::3]    {   // set the size of micro-model PreyPredator equal with the size of the grid of myAnt   shape <- square(100);  }   // save the original population of the Ants and the Preys  theAnts <- myAnt.Ants_coupling_exp accumulate each.getAnts();  thePreys <- list<prey>(myPreyPredator.PreyPredator_coupling_exp accumulate each.getPrey());   }  reflex simulate_micro_models {  // ask myAnt do a step  ask (myAnt.Ants_coupling_exp collect each.simulation)  {   do _step_;  }  // ask myPreyPredator do a step, too  ask (myPreyPredator.PreyPredator_coupling_exp collect each.simulation)  {   do _step_;  }   //check if a Prey is chased, set the position of that agent to the location of prey   //if not, set ant s location to agent location.  // if the agent (prey) died, then tell the ant do die  loop i from: 0 to: length(theAnts) - 1  {   if (!dead(thePreys at i) and !dead(theAnts at i))   {    if (!(thePreys at i).is_chased)    {     (thePreys at i).location <- (theAnts at i).location;    } else    {     (theAnts at i).location <- (thePreys at i).location;    }    } else   {    ask (theAnts at i)    {     do die;    }    }   }  }   }  experiment comodel_mix_behaviors_exp type: gui {  output  {   display  comodel    {    agents  ant_grid  value: myAnt.Ants_coupling_exp accumulate each.getAnt_grid() transparency: 0.7;    agents  agentprey  value: (myPreyPredator.PreyPredator_coupling_exp accumulate each.getPrey());    agents  agentpredator  value: (myPreyPredator.PreyPredator_coupling_exp accumulate each.getPredator());   }  }   }     ","url":"wiki/Co-model-Usage-comodel_mix_behaviors.md"},{"id":"wiki/Co-model-Usage-comodel_mutate_population.md","title":" comodel_with_the_coupling","content":"# comodel_with_the_coupling  Author : HUYNH Quang Nghi  This is a simple comodel serve to demonstrate the importation and instatiation of micro-model  using the couplings  with the mutation the population of micro-model. A population can be a collection from itself and from other mircro-model  Imported models :      model PreyPredator  global {  geometry shape <- square(100);  float perceipt_radius <- 20.0;  int preyinit <- 500;  int predatorinit <- 3;  list lstPredator <- list(predator);  list lstPrey <- list(prey);  init  {   create prey number: preyinit;   create predator number: predatorinit;   lstPredator <- list(predator);   lstPrey <- list(prey);  }  }  species generic_species skills: [moving] {  float speed <- 1.0;  point goal <- nil;  bool is_chased <- false;  reflex live_with_my_goal  {   if (goal != nil)   {    do wander speed: speed;    do goto target: goal speed: speed;   } else   {    do wander speed: speed;   }  }   }  species prey parent: generic_species {  geometry shape <- circle(0.5);  float speed <- 0.2;  rgb color <- # green;  reflex fleeing  {   if (length((lstPredator where (each != nil and !dead(each) and each distance_to self < perceipt_radius))) > 0)   {    speed <- 1.0;    is_chased <- true;    color <- # lime;    if (goal = nil)    {     agent a <- any(((lstPrey where (each != nil and !dead(each) and !generic_species(each).is_chased))));     if (a != nil and !dead(a))     {      if (flip(0.5))      {       goal <- a.location;      } else      {       goal <- any_location_in(world.shape);      }     } else    {     goal <- any_location_in(world.shape);    }    }   }   if (goal != nil and self.location distance_to goal < 0.5)  {   goal <- nil;  }   if (length((lstPredator where (each != nil and !dead(each))) where (each distance_to self <= perceipt_radius)) = 0)  {   is_chased <- false;   color <- # green;   speed <- 0.2;  }  }  aspect default {  draw shape color: color; }   }  species predator parent: generic_species {  geometry shape <- triangle(2);  rgb color <- # red;  reflex hunting  {   if (goal = nil)   {    list tmp <- (lstPrey where (!dead(each) and each.shape distance_to self.shape < perceipt_radius));    if (length(tmp) > 0)    {     agent a <- first(tmp sort (each.shape distance_to self.shape));     if (a = nil)     {      a <- any((lstPrey where (!dead(each))));     }     if (a != nil)    {     speed <- 2.0;     goal <- a.location;    }    }   } else if ((self.location distance_to goal < 0.5))  {   ask lstPrey where (!dead(each) and each.location distance_to goal < 0.5)   {    do die;   }    goal <- nil;   speed <- 1.0;  }  }  aspect default {  draw circle(perceipt_radius) color: # pink empty: true;  draw shape color: color rotate: 90 + my heading; }   }  experiment prey_predator_exp type: gui {  output  {   display main_display   {   species prey;   species predator;  }  }   }          model PreyPredator_coupling import  PreyPredator.gaml   global {  }  experiment PreyPredator_coupling_exp parent:prey_predator_exp type: gui { geometry shape<- square(100);  list getPrey{   return list(prey);  }   list getPredator{   return list(predator);  }  //if we redefine the output, i.e, a blank output, the displays in parent experiement dont show. output { }   }       Code of the model :      model comodel_with_the_coupling  import  PreyPredator_coupling.gaml  as myP  global {  // set the shape of world as a rectangle 200 x 100  geometry shape <- rectangle(200, 100);  init  {   //instantiate three instant of micro-model PreyPredator   create myP.PreyPredator_coupling_exp with: [shape::square(100), preyinit::rnd(20), predatorinit::1] number: 3;   //explicitly save the orginal population of predator and original population of prey of each micro-model  list<agent> lstpredator0 <- myP.PreyPredator_coupling_exp[0].getPredator();  list<agent> lstprey0 <- myP.PreyPredator_coupling_exp[0].getPrey();    list<agent> lstpredator1 <- myP.PreyPredator_coupling_exp[1].getPredator();  list<agent> lstprey1 <- myP.PreyPredator_coupling_exp[1].getPrey();    list<agent> lstpredator2 <- myP.PreyPredator_coupling_exp[2].getPredator();  list<agent> lstprey2 <- myP.PreyPredator_coupling_exp[2].getPrey();    //mutate the popuplation of micro-model by assigning the list above to  the population of micro-models  (myP.PreyPredator_coupling_exp[0].simulation).lstPredator <- lstpredator2;  (myP.PreyPredator_coupling_exp[1].simulation).lstPredator <- lstprey2;  (myP.PreyPredator_coupling_exp[2].simulation).lstPredator <- lstprey1;      (myP.PreyPredator_coupling_exp[0].simulation).lstPrey <- lstprey0 + lstprey1;  (myP.PreyPredator_coupling_exp[1].simulation).lstPrey <- lstpredator1;  (myP.PreyPredator_coupling_exp[2].simulation).lstPrey <- lstpredator0 + lstprey2;    //change the shape correspond with the new role of agent in the new populations  ask (myP.PreyPredator_coupling_exp accumulate each.simulation.lstPredator)  {   shape <- triangle(2);  }   ask (myP.PreyPredator_coupling_exp accumulate each.simulation.lstPrey)  {   shape <- circle(0.5);  }  }  reflex simulate_micro_models {  // ask all simulation do their job  ask (myP.PreyPredator_coupling_exp collect each.simulation)  {   do _step_;  }  }   }  experiment comodel_with_the_coupling_exp type: gui {  output  {   //a mixing display of all agents from all populations   display  comodel    {    agents  agentprey  value: (myP.PreyPredator_coupling_exp accumulate each.getPrey());    agents  agentpredator  value: (myP.PreyPredator_coupling_exp accumulate each.getPredator());   }  }   }     ","url":"wiki/Co-model-Usage-comodel_mutate_population.md"},{"id":"wiki/Co-model-Usage-comodel_simple.md","title":" Simple syntax demonstration of Comodeling ","content":"# Simple syntax demonstration of Comodeling  Author : HUYNH Quang Nghi  This is a simple comodel serve to demonstrate the importation and instatiation of micro-model without using the couplings  Imported models :      model M2  global {  int n <- 4;  init  {   create B number: n;  }  }  species B skills: [moving] {  int IQ <- rnd(100);  reflex dolive  {   write    +  i m alive !! ;   do wander;  }  aspect default {  draw square(1) color: # red; }   }  experiment M2_exp type: gui {  output  {   display  m2_disp    {    species B aspect: default;   }  }   }           model M1  global {  int n <- 8;  init  {   create A number: n;  }  }  species A skills: [moving] {  int IQ <- rnd(100);  reflex dolive  {   write    +  i m alive !! ;   do wander;  }  aspect default {  draw square(1) color: # green; }   }  experiment M1_exp type: gui {  output  {   display  m1_disp    {    species A aspect: default;   }  }   }       Code of the model :      model Comodel_simple  import  m1.gaml  as micro_model_1 import  m2.gaml  as micro_model_2  global {  init  {  //micro_model must be instantiated by create statement. We create an experiment inside the micro-model and the simulation will be created implicitly (1 experiment have only 1 simulation).   create micro_model_1.M1_exp number: 5;   create micro_model_2.M2_exp;  }  reflex simulate_micro_models {  //tell the first experiment of micro_model_1 do 1 step;  ask first(micro_model_1.M1_exp).simulation  {   do _step_;  }   //tell the  experiment at 3 of micro_model_1 do 1 step;  ask (micro_model_1.M1_exp at 3).simulation  {   do _step_;  }   //tell all experiments of micro_model_1 do 1 step;  ask (micro_model_1.M1_exp collect each.simulation)  {   do _step_;  }   //tell all experiments of micro_model_2 do 1 step;  ask (micro_model_2.M2_exp collect each.simulation)  {   do _step_;  }    //kill simulation  of micro_model and recreate then  ask  (micro_model_2.M2_exp collect each.simulation){   do die;  }  ask (micro_model_2.M2_exp){   create simulation{do _init_;}  } } }   experiment Comodel_simple_exp type: gui { }     ","url":"wiki/Co-model-Usage-comodel_simple.md"},{"id":"wiki/Co-model-Usage-comodel_with_the_coupling.md","title":" comodel_with_the_coupling","content":"# comodel_with_the_coupling  Author : HUYNH Quang Nghi  This is a simple comodel serve to demonstrate the importation and instatiation of micro-model using the couplings  Imported models :      model M2  global {  int n <- 4;  init  {   create B number: n;  }  }  species B skills: [moving] {  int IQ <- rnd(100);  reflex dolive  {   write    +  i m alive !! ;   do wander;  }  aspect default {  draw square(1) color: # red; }   }  experiment M2_exp type: gui {  output  {   display  m2_disp    {    species B aspect: default;   }  }   }           model M2_coupling import  m2.gaml   global { }  experiment M2_coupling_exp parent:M2_exp type: gui {  list getB{   return list(B);  }  //if we redefine the output, i.e, a blank output, the displays in parent experiement dont show. output { }   }           model M1  global {  int n <- 8;  init  {   create A number: n;  }  }  species A skills: [moving] {  int IQ <- rnd(100);  reflex dolive  {   write    +  i m alive !! ;   do wander;  }  aspect default {  draw square(1) color: # green; }   }  experiment M1_exp type: gui {  output  {   display  m1_disp    {    species A aspect: default;   }  }   }           model M1_coupling import  m1.gaml   global { }  experiment M1_coupling_exp parent:M1_exp type: gui {  list getA{   return list(A);  }  //if we redefine the output, i.e, a blank output, the displays in parent experiement dont show. output { }   }       Code of the model :      model comodel_with_the_coupling  import  m1_coupling.gaml  as micro_model_1 import  m2_coupling.gaml  as micro_model_2  global {  geometry shape<-envelope(square(100));  init{   //micro_model must be instantiated by create statement. We create an experiment inside the micro-model and the simulation will be created implicitly (1 experiment have only 1 simulation).   create micro_model_1.M1_coupling_exp;   create micro_model_2.M2_coupling_exp number:5;  }  reflex simulate_micro_models{   //tell all experiments of micro_model_1 do 1 step;  ask (micro_model_1.M1_coupling_exp collect each.simulation){   do _step_;  }    //tell the first experiment of micro_model_2 do 1 step;  ask (micro_model_2.M2_coupling_exp collect each.simulation){   do _step_;  } } }   experiment comodel_with_the_coupling type: gui{  output{   display  comodel  {    //to display the agents of micro-models, we use the agent layer with the values come from the coupling.    agents  agentA  value:first(micro_model_1.M1_coupling_exp).getA();    agents  agentB  value:first(micro_model_2.M2_coupling_exp).getB();   }  } }     ","url":"wiki/Co-model-Usage-comodel_with_the_coupling.md"},{"id":"wiki/Color-Bubble-Sort-3D.md","title":" Creating color and sort cubes by color","content":"# Creating color and sort cubes by color  Author :  Arnaud Grignard  A model to show how to create color by using the rgb operator, the color depending on the position of cube in the xyz space. The cubes are randomly mixed to finally be sorted according to the color of each vertix of the whole big cube, using the bubble sort algorithm (https://en.wikipedia.org/wiki/Bubble_sort).  Code of the model :       model bubblesort3D  global {  //Number of cubes by faces of the whole big cube int nb_cells<-15;  geometry shape <- cube(nb_cells) ;  bool change <- true;  init {  //We create nb_cells^3 cubes and we define their color depending on their position in XYZ  loop i from:0 to:nb_cells-1{   loop j from:0 to: nb_cells-1{    loop k from:0 to:nb_cells-1{      create cells{     location <-{i mod nb_cells,j mod nb_cells, k mod nb_cells};     //The canal RGB limit color to 255 by canal    red <- float((i mod nb_cells)* int(255 / nb_cells));    green <- float((j mod nb_cells) * int(255 / nb_cells));    blue <- float((k mod nb_cells) * int(255 / nb_cells));        //We create the color according to the value of the red, green and blue canals    color <- rgb(red,green,blue);     }    }      } }  //We mix all the cubes randomly by permuting two randomly chosen cubes loop times: 10000 {   ask one_of(cells) {    cells one_cells <- one_of(cells);    if (self != one_cells) {     point loc <- copy(location);     location <- one_cells.location;     one_cells.location <- loc;    }   }  }   }  //Reflex to finish the execution of the model when nothing has changed during the cycle reflex end {  if (not change) {   do pause;   }   change <- false;  } }  species cells{  rgb color; float red; float green; float blue; list<cells> neigbhours update: cells at_distance (1.1);  //Update of the neighbours cubes at each cycle of the simulation according to their location cells upper_cell_y update: neigbhours first_with (shape.location.y > each.shape.location.y); cells upper_cell_x update: neigbhours first_with (shape.location.x > each.shape.location.x); cells upper_cell_z update: neigbhours first_with (shape.location.z > each.shape.location.z);  //We permute the cube agent with its neighbour if its intensity is greater according to the canal related to its axis (z for canal blue, y for green and x for red) reflex swap_z when: upper_cell_z != nil and blue < upper_cell_z.blue{   point tmp1Loc <-location;  location <- upper_cell_z.location;    upper_cell_z.location<-tmp1Loc;       change <- true;  }  reflex swap_y when: upper_cell_y != nil and green < upper_cell_y.green{   point tmp1Loc <-location;  location <- upper_cell_y.location;    upper_cell_y.location<-tmp1Loc;       change <- true;  }  reflex swap_x when: upper_cell_x != nil and red < upper_cell_x.red{   point tmp1Loc <-location;  location <- upper_cell_x.location;    upper_cell_x.location<-tmp1Loc;       change <- true;  }  aspect default {  draw cube(1) color:color border:color at:location; }  }   experiment Display type: gui {  output {   display View1 type:opengl draw_env:false{    species cells transparency:0.1;    graphics  di {     draw  black(0,0,0)  at:{0,0,0} color:°black perspective:false;     draw  red(1,0,0)  at:{world.shape.width,0,0} color:°red perspective:false;     draw  green(0,1,0)  at:{0,world.shape.height,0} color:°green perspective:false;     draw  blue(0,0,1)  at:{0,0,world.shape.width} color:°blue perspective:false;     draw  yellow(1,1,0)  at:{world.shape.width,world.shape.height,0} color:°yellow perspective:false;     draw  magenta(1,0,1)  at:{world.shape.width,0,world.shape.depth} color:°magenta perspective:false;     draw  cyan(0,1,1)  at:{0,world.shape.height,world.shape.depth} color:°cyan perspective:false;     draw  white(1,1,1)  at:{world.shape.width,world.shape.height,world.shape.depth} color:°white perspective:false;     }   }  } }     ","url":"wiki/Color-Bubble-Sort-3D.md"},{"id":"wiki/Color-Color-Brewer.md","title":" Color defined by choosing a Color Brewer","content":"# Color defined by choosing a Color Brewer  Author :  Arnaud Grignard & Patrick Taillandier  A model to show how to use color brewer. In this model, two experiments are presents : one just to show the different colors present in some selected brewer, and a second one to show in a grid the different colors of brewler having at least a minimal number of colors passed in parameter.  Code of the model :       model ColorBrewer  global {  //number of colors int nb_classes<-14 min:5 max: 15;  int square_size <- 10;  //list of palettes that have at least nb_classes list palettes <- brewer_palettes(nb_classes);  //the current sequential palette from the list of all available sequential Palettes string sequentialPalette <-  YlOrRd  among:[ YlOrRd , Grays , PuBu , BuPu , YlOrBr , Greens , BuGn , GnBu , PuRd , Purples , Blues , Oranges , OrRd , Reds , YlGn , YlGnBu ];  //the current diverging palette from the list of all available diverging Palettes string divergingPalette <-  BrBG  among:[ PRGn , PuOr , RdGy , Spectral , RdYlGn , RdBu , RdYlBu , PiYG , BrBG ];  //the current qualitative palette from the list of all available qualitative Palettes string qualitativePalette <-  Pastel1  among:[ Accents , Paired , Set3 , Set2 , Set1 , Dark2 , Pastel2 , Pastel1 ];  //build the lists of colors from the palettes list SequentialColors<-list(brewer_colors(sequentialPalette)); list DivergingColors<-list(brewer_colors(divergingPalette)); list QualitativeColors<-list(brewer_colors(qualitativePalette));  init {  //if the palettes is not empty  if (not empty(palettes)) {   //for each palette   loop i from: 0 to: length(palettes) - 1 {    //define a  list of nb_classes colors from the current palette    list<rgb> colors<-list<rgb>(brewer_colors(palettes[i],nb_classes));        //define the colors of the corresponding cells    ask cell where (each.grid_y = i){     color <- colors[grid_x,i];     }   }  } } }   grid cell width:nb_classes height: max([1,length(palettes)]) ;  //in this experiment, we do not use the cell agents, but we directlty draw the different palettes of colors experiment BrewerPalette type: gui {  parameter  Sequential Palettes  var:sequentialPalette category: Brewer ;  parameter  Diverging Palettes  var:divergingPalette category: Brewer ;  parameter  Qualitatives Palettes  var:qualitativePalette category: Brewer ;  output {   display View1 type:opengl draw_env:false{    graphics  brewer {     //Sequential     draw  Sequential  at:{-world.shape.width0.2,0} color:°black perspective:true;     loop i from:0 to:length(SequentialColors)-1{      draw square(square_size) color:SequentialColors[i] at: {square_size(0.5 + i), 0, 0};     }     //Diverging     loop i from:0 to:length(DivergingColors)-1{      draw  Diverging  at:{-world.shape.width0.2,1square_size} color:°black perspective:false;      draw square(square_size) color:DivergingColors[i] at: {square_size(0.5 + i), 1square_size, 0};     }     //Qualitative       loop i from:0 to:length(QualitativeColors)-1{      draw  Qualitative  at:{-world.shape.width0.2,2square_size} color:°black perspective:false;      draw square(square_size) color:QualitativeColors[i] at: {square_size(0.5 + i), 2square_size, 0};     }       }   }   } }  //in this experiment, we display the cell agents with the  different aspects experiment BrewerColoredAgent type: gui {  parameter  Number of data classes  var:nb_classes category: Brewer ;  output {   display View1 {    grid cell lines: #black ;   }   } }     ","url":"wiki/Color-Color-Brewer.md"},{"id":"wiki/Color-RGB-to-XYZ.md","title":" RGB color to XYZ position","content":"# RGB color to XYZ position  Author :  Arnaud Grignard  A model to show how to convert rgb values in xyz position using the operator rgb_to_xyz. Each pixel of a given image is used to create a point with its coordinates depending on its color : red value for x coordinate, green value for y coordinate and blue value for the z coordinate.  Code of the model :       model rgbCube  global {  //import an image  file imageRaster <- file( images/RGB.jpg );  //list of points  create from the image  list<point> p;  //geometry of the world (environment) geometry shape <- square(255);  //create the list of points from the image: a point is defined per pixel, its coordinate correspond to the value of the red,green,blue color init {  p <- list<point> (rgb_to_xyz(imageRaster)); } }   experiment Display type: gui {  output {   display RGB_to_XYZ type: opengl {     image imageRaster.path refresh: false;    graphics  pts  refresh: false{     loop pt over: p {      draw cube(1) at: pt color: rgb(pt.x, pt.y, pt.z);     }    }   }  }  }     ","url":"wiki/Color-RGB-to-XYZ.md"},{"id":"wiki/Data-Importation-3D-shapefile-Loading.md","title":" 3D shapefile loading","content":"# 3D shapefile loading  _Author :  _  Model which shows how to create a shape using a 3D Shapefile after this one has been loaded.  Code of the model :      model shapefile_loading  global {  //file variable that will store the shape file file shape_file_gis_3d_objects <- shape_file( ../includes/Mobilier.shp , 0); geometry shape <- envelope(shape_file_gis_3d_objects); init {  create gis_3d_object from: shape_file_gis_3d_objects; } }   species gis_3d_object {  aspect base {   draw shape at:{world.shape.width/2,world.shape.height/2,0};  } }  experiment display_shape type: gui {  output {  display city_display type: opengl draw_env:false{   species gis_3d_object aspect: base;  }  } }       ","url":"wiki/Data-Importation-3D-shapefile-Loading.md"},{"id":"wiki/Data-Importation-ASC-file-Import.md","title":" ESRI ASCII to grid model","content":"# ESRI ASCII to grid model  Author :  Patrick Taillandier  Model which shows how to initialize a grid using a ESRI ASCII file  Code of the model :       model ascimport  global {  //definiton of the file to import  file grid_data <- file( ../includes/hab10.asc ) ;  //computation of the environment size from the geotiff file geometry shape <- envelope(grid_data);  }   //definition of the grid from the asc file: the width and height of the grid are directly read from the asc file. The values of the asc file are stored in the grid_value attribute of the cells. grid cell file: grid_data{  init {   color<- grid_value = 0.0 ? #black  : (grid_value = 1.0  ? #green :   #yellow);  } }  experiment gridloading type: gui {  output {   display  As DEM  type: opengl{    grid cell lines: #gray elevation: grid_value * 300 ;   }   display As 2D grid  type: java2D {   grid cell lines: #black;  } }  }       ","url":"wiki/Data-Importation-ASC-file-Import.md"},{"id":"wiki/Data-Importation-CSV-Agents.md","title":" CSV to Agents Model","content":"# CSV to Agents Model  Author :  Patrick Taillandier  Model which shows how to create agents by importing data of a CSV file. The model read the CSV File and create an agent Iris for each line of the CSV, linking its attributes to columns of the CSV File.  Code of the model :       model CSVfileloading  global {  init {  //create iris agents from the CSV file (use of the header of the CSV file), the attributes of the agents are initialized from the CSV files:   //we set the header facet to true to directly read the values corresponding to the right column. If the header was set to false, we could use the index of the columns to initialize the agent attributes  create iris from:csv_file( ../includes/iris.csv,true) with:   [sepal_length::float(get(sepallength)),     sepal_width::float(get(sepalwidth)),     petal_length::float(get(petallength)),    petal_width::float(get(petalwidth)),     type::string(get(type))   ];  } }   species iris {  float sepal_length;  float sepal_width;  float petal_length;  float petal_width;  string type;  rgb color ;  init {  color <- type =Iris-setosa ? #blue : ((type =Iris-virginica) ? #red: #yellow); }  aspect default {  draw circle(petal_width) color: color;  } }   experiment main type: gui{  output {   display map {    species iris;   }  }  }     ","url":"wiki/Data-Importation-CSV-Agents.md"},{"id":"wiki/Data-Importation-CSV-File-Loading.md","title":" Convertion of CSV data to Matrix","content":"# Convertion of CSV data to Matrix  Author :  Patrick Taillandier  Model which shows how to initialize a matrix by using the content of a CSV File. The model load a CSV File, and write its content in the console.  Code of the model :       model CSVfileloading  global {  file my_csv_file <- csv_file( ../includes/iris.csv , , );  init {  //convert the file into a matrix  matrix data <- matrix(my_csv_file);  //loop on the matrix rows (skip the first header line)  loop i from: 1 to: data.rows -1{   //loop on the matrix columns   loop j from: 0 to: data.columns -1{    write data rows:+ i + colums: + j +  =  + data[j,i];   }   }   } }   experiment main type: gui;     ","url":"wiki/Data-Importation-CSV-File-Loading.md"},{"id":"wiki/Data-Importation-Contour-Lines.md","title":" Contour Lines Import","content":"# Contour Lines Import  Author : Patrick Taillandier  Model which imports a shapefile of contour lines, build triangles from these contour lines, compute their elevation by using the elevation attribute of the contour lines which had been linked to the elevation column of the shapefile.  Code of the model :       model contour_lines_import  global {  //the contour lines shapefile  file shape_file_cl <- file( ../includes/contourLines.shp ) ;  //define the size of the world from the countour line shapefile geometry shape <- envelope(shape_file_cl);  init {  //create the contour line agents from the shapefile, and init the elevation for each agent  create contour_line from: shape_file_cl with: [elevation:: float(read(ELEVATION))];    //triangulate the contour lines  list<geometry> triangles  <- triangulate (list(contour_line));    //for each triangle geometry, create a triangle_ag agent and compute the elevation of each of its points (and modified their z value)  loop tr over: triangles {   create triangle_ag {    shape <- tr;    loop i from: 0 to: length(shape.points) - 1{      float val <- (contour_line closest_to (shape.points at i)).elevation;     shape <- shape set_z (i,val);    }   }  }  } }   species contour_line {  float elevation;  aspect default {   draw shape + 5.0 color: #red depth: 10 at: {location.x,location.y, elevation};   } } species triangle_ag {  aspect default {   draw shape color: #grey ;   } }  experiment contour_lines_import type: gui {  output {   display map type: opengl {    species triangle_ag refresh: false;    species contour_line refresh: false;   }  } }     ","url":"wiki/Data-Importation-Contour-Lines.md"},{"id":"wiki/Data-Importation-DXF-Agents.md","title":" DXF to Agents Model","content":"# DXF to Agents Model  Author :  Patrick Taillandier  Model which shows how to create agents by importing data of a DXF file  Code of the model :       model DXFAgents  global {  file house_file <- file( ../includes/house.dxf );  //compute the environment size from the dxf file envelope geometry shape <- envelope(house_file);  init {  //create house_element agents from the dxf file and initialized the layer attribute of the agents from the the file  create house_element from: house_file with: [layer::string(get(layer))];    create house_element from: house_file with: [layer::string(get(layer))];      create house_element from: house_file with: [layer::string(get(layer))];  //define a random color for each layer  map layers <- list(house_element) group_by each.layer;  loop la over: layers.keys {   rgb col <- rnd_color(255);   ask layers[la] {color <- col;}  } } }   species house_element {  string layer;  rgb color;  aspect default {   draw shape color: color;  } }  experiment DXFAgents type: gui {  output {   display map {    species house_element;   }   display As_Image {   graphics House {    draw house_file color: #brown ;   }  } }   }     ","url":"wiki/Data-Importation-DXF-Agents.md"},{"id":"wiki/Data-Importation-GEOTIFF-file-Import.md","title":" GeoTIFF file to Grid of Cells ","content":"# GeoTIFF file to Grid of Cells  Author :  Patrick Taillandier  Model which shows how to create a grid of cells by using a GeoTIFF File.  Code of the model :       model geotiffimport  global {  //definiton of the file to import  file grid_data <- file( ../includes/bogota_grid.tif ) ;  //computation of the environment size from the geotiff file geometry shape <- envelope(grid_data);   float max_value; float min_value; init {  max_value <- cell max_of (each.grid_value);  min_value <- cell min_of (each.grid_value);  ask cell {   int val <- int(255 * ( 1  - (grid_value - min_value) /(max_value - min_value)));   color <- rgb(val,val,val);  } } }   //definition of the grid from the geotiff file: the width and height of the grid are directly read from the asc file. The values of the asc file are stored in the grid_value attribute of the cells. grid cell file: grid_data;  experiment show_example type: gui {  output {   display test {    grid cell lines: #black;   }  }  }     ","url":"wiki/Data-Importation-GEOTIFF-file-Import.md"},{"id":"wiki/Data-Importation-GIS-Export.md","title":" Shapefiles Import and Save","content":"# Shapefiles Import and Save  Author : Patrick Taillandier  Model using shapefiles to create buildings, linking their height and type attributes to the height and nature columns of the shapefiles to finally save the data in an other shapefile.  Code of the model :       model saveGIS  global {  file shape_file_buildings <- file( ../includes/buildings_simple.shp );  string new_shape_file_buildings <-  ../results/buildings_final.shp ;  //definition of the geometry of the world agent (environment) as the envelope of the shapefile geometry shape <- envelope(shape_file_buildings);  init {  //creation of the building agents from the shapefile: the height and type attributes of the building agents are initialized according to the HEIGHT and NATURE attributes of the shapefile  create building from: shape_file_buildings with:[height::float(get(HEIGHT)), type::string(get(NATURE))]; }  //when cycle = 5, save of the building agents in a shapefile with the attributes height, type and price. reflex save_data when: cycle = 5 {  save building to: new_shape_file_buildings type:shp with:[height::HEIGHT, type::NATURE, price::PRICE]; } }   species building {  float height;  string type;  float price <- (shape.area * height) * (type =  Industrial  ? 0.5: 1) update: price * (90 +rnd(20)) / 100;   rgb color <- type =  Industrial  ? #pink : #gray;  aspect default {  draw shape depth: height color: color; }   }  experiment GIS_agentification type: gui {  output {   display city_display type: opengl {    species building;   }  } }     ","url":"wiki/Data-Importation-GIS-Export.md"},{"id":"wiki/Data-Importation-Grid-DEM.md","title":" ASCII File to DEM Representation","content":"# ASCII File to DEM Representation  Author : Arnaud Grignard  Model to show how to import a ASCII File to make a DEM Representation and apply a Texture on it. In this model, three experiments are presented : DEM to show the grid elevation using the ASCII File as data for the height of the cells, and showing different 3D displays. GridDEMComplete shows more displays with the three of the previous experiment, the grid of the cells in a 2D Display, with the Elevation but without triangulation, and the grid with text values to show the content of the ASCII used by the cells. GraphicDEMComplete shows the use of the z_factor to amplify or reduces the difference between the z values of a Dem geometry.  Code of the model :       model gridloading  global {  file grid_data <- file( ../includes/DEM-Vulcano/vulcano_50.asc );  file dem parameter:  DEM  <- file( ../includes/DEM-Vulcano/DEM.png );  file texture parameter:  Texture  <- file( ../includes/DEM-Vulcano/Texture.png );  geometry shape <- envelope(200);  init  {   ask cell   {    float r;    float g;    float b;    if(grid_value<20)    {     r<- 76+(26(grid_value-7)/13);     g<- 153-(51(grid_value-7)/13);     b<-0.0;    }    else    {     r<- 102+(122(grid_value-20)/19);     g<- 51+(173(grid_value-20)/19);     b<- 224*(grid_value-20)/19;    }    self.color<-rgb(r,g,b);   }  } }  grid cell file: grid_data {  rgb color;  reflex decreaseValue {   grid_value <- grid_value  + rnd (0.2) - 0.1;  } }  experiment DEM type: gui {  output {   //Display the grid triangulated in 3D with the cell altitude corresponding to its grid_value and the color cells (if defined otherwise in black)  display gridWithElevationTriangulated type: opengl autosave: true{    grid cell elevation: true triangulation: true ;  }   //Display the grid triangulated in 3D with the cell altitude corresponding to its grid_value and the color of cells as a gray value corresponding to grid_value / maxZ *255  display gridGrayScaledTriangulated type: opengl {    grid cell elevation: true grayscale: true triangulation: true;  }   //Display the textured grid in 3D with the cell altitude corresponding to its grid_value.      display gridTextured type: opengl {    grid cell texture: texture text: false triangulation: true elevation: true;  } }   }  experiment GridDEMComplete type: gui {  output {  //Display the grid on a plan with cell color (if defined otherwise in black)  display grid type: opengl { //Same as in java2D   grid cell;  }   //Display the grid in 3D with the cell altitude corresponding to its grid_value and the color cells (if defined otherwise in black)  display gridWithElevation type: opengl {    grid cell elevation: true;  }   //Display the grid triangulated in 3D with the cell altitude corresponding to its grid_value and the color cells (if defined otherwise in black)  display gridWithElevationTriangulated type: opengl {    grid cell elevation: true triangulation: true ;  }   //Display the grid in 3D with the cell altitude corresponding to its grid_value and the color of cells as a gray value corresponding to grid_value / maxZ *255  display gridGrayScaled type: opengl {    grid cell elevation: true grayscale: true;  }  //Display the grid triangulated in 3D with the cell altitude corresponding to its grid_value and the color of cells as a gray value corresponding to grid_value / maxZ *255  display gridGrayScaledTriangulated type: opengl {    grid cell elevation: true grayscale: true triangulation: true;  }   //Display the textured grid in 3D with the cell altitude corresponding to its grid_value.      display gridTextured type: opengl {    grid cell texture: texture text: false triangulation: false elevation: true;  }   //Display the textured triangulated grid in 3D with the cell altitude corresponding to its grid_value.  display gridTexturedTriangulated type: opengl {    grid cell texture: texture text: false triangulation: true elevation: true;  }  display gridWithText type: opengl {    grid cell text: true elevation: true grayscale: true;  } }   }  experiment GraphicDEMComplete type: gui {  output {   display VulcanoTexturedScaled type: opengl draw_env: false {     graphics  GraphicPrimitive  {     draw dem(dem, texture, 0.1);    }   }    display VulcanoDEMScaled type: opengl draw_env: false {     graphics  GraphicPrimitive  {     draw dem(dem, 0.1);    }   }    display VulcanoTextured type: opengl draw_env: false {     graphics  GraphicPrimitive  {     draw dem(dem, texture);    }   }    display VulcanoDEM type: opengl draw_env: false {     graphics  GraphicPrimitive  {     draw dem(dem);    }   }  } }     ","url":"wiki/Data-Importation-Grid-DEM.md"},{"id":"wiki/Data-Importation-OBJ-file-drawing.md","title":" OBJ File to Geometry","content":"# OBJ File to Geometry  Author :  Arnaud Grignard  Model which shows how to use a OBJ File to draw a complex geometry. The geometry is simply used, in this case, to draw the agents.  Code of the model :       model obj_drawing  global {  geometry shape <- square(40);  init {   create object number: 30; }   }    species object skills: [moving]{  rgb color <- rgb(rnd(255),rnd(255),rnd(255));  int size <- rnd(10) + 1;  int rot <- 1000 + rnd(1000);  reflex m when: every(100) {   do wander amplitude: 30 speed: 0.001;  }  aspect obj {   draw obj_file( ../includes/teapot.obj ) color: color size: size rotate: cycle/rot::{0,1,0};  } }  experiment Display  type: gui {  output {   display ComplexObject type: opengl background:°orange{    species object aspect:obj;       }  } }     ","url":"wiki/Data-Importation-OBJ-file-drawing.md"},{"id":"wiki/Data-Importation-OBJ-file-loading.md","title":" Complex Object Loading","content":"# Complex Object Loading  Author :  Arnaud Grignard  Provides a  complex geometry to agents (svg,obj or 3ds are accepted). The geometry becomes that of the agents.  Code of the model :       model obj_loading  global {  init {   create object; }   }    species object skills:[moving]{  geometry shape <- obj_file(../includes/teapot.obj) as geometry;  reflex move{  do wander; } aspect obj {  draw shape; }   }  experiment Display  type: gui {  output {   display complex  background:#gray type: opengl{     species object aspect:obj;       }  } }     ","url":"wiki/Data-Importation-OBJ-file-loading.md"},{"id":"wiki/Data-Importation-OSM-Loading.md","title":" OSM file to Agents","content":"# OSM file to Agents  Author :  Patrick Taillandier  Model which shows how to import a OSM File in GAMA and use it to create Agents. In this model, a filter is done to take only into account the roads and the buildings contained in the file.  Code of the model :       model simpleOSMLoading  global{  //map used to filter the object to build from the OSM file according to attributes. for an exhaustive list, see: http://wiki.openstreetmap.org/wiki/Map_Features map filtering <- map([highway::[primary, secondary, tertiary, motorway, living_street,residential, unclassified], building::[yes]]); //OSM file to load file<geometry> osmfile <-  file<geometry>(osm_file(../includes/rouen.gz, filtering))  ;  //compute the size of the environment from the envelope of the OSM file geometry shape <- envelope(osmfile);  init {  //possibility to load all of the attibutes of the OSM data: for an exhaustive list, see: http://wiki.openstreetmap.org/wiki/Map_Features  create osm_agent from:osmfile with: [highway_str::string(read(highway)), building_str::string(read(building))];    //from the created generic agents, creation of the selected agents  ask osm_agent {   if (length(shape.points) = 1 and highway_str != nil ) {    create node_agent with: [shape ::shape, type:: highway_str];    } else {    if (highway_str != nil ) {     create road with: [shape ::shape, type:: highway_str];    } else if (building_str != nil){     create building with: [shape ::shape];    }     }   //do the generic agent die   do die;  } }  }   species osm_agent {  string highway_str;  string building_str; }  species road {  rgb color <- rnd_color(255);  string type;  aspect default {   draw shape color: color;   } }  species node_agent {  string type;  aspect default {    draw square(3) color: #red ;  } }  species building {  aspect default {    draw shape color: rgb(200,200,200);  } }  experiment load_OSM type: gui {  output {   display map type: opengl {    species building refresh: false;    species road refresh: false  ;    species node_agent refresh: false ;   }  } }     ","url":"wiki/Data-Importation-OSM-Loading.md"},{"id":"wiki/Data-Importation-Raster-Image-Import.md","title":" Raster File in a Grid of cells","content":"# Raster File in a Grid of cells  Author : Maroussia Vavasseur and Benoit Gaudou  Model which shows how to import a Raster file in GAMA and use it to initialize the color attributes of a grid of cells. This model represents a grid with a cell, each cell has a color, and this color is used for animals (izards) to be placed on a cell that verifies some conditions. The izards do not move once they have been placed.  Code of the model :       model HowToImportRaster  global {   // Constants   int heightImg const: true <- 5587;  int widthImg const: true <- 6201;  // Global variables int factorDiscret <- 30 ; file mntImageRaster <- image_file( ../images/mnt/testAG.jpg ) ;  int nbIzard <- 250 ;  file izardShape <- file( ../images/icons/izard.gif );    // Initialization of grid and creation of the izard agents // - we use the as_matrix operator to transform a image file into a matrix of colors  // (Note that as_matrix takes a Point as right operand, this point specifies the number of lines and columns of the matrix) // - we then set the color built-in attribute of the cell with the value of the corresponding matrix cell      init {  // set mapColor value: mntImageRaster as_matrix {widthImg/factorDiscret,heightImg/factorDiscret} ;  ask cell {     color <-rgb( (mntImageRaster) at {grid_x,grid_y}) ;  }  create izard number: nbIzard;  } }   // We create izard agents and locate them on one cell  among the list of cellules in which there is no izard  // and with a color that is not white  each.color != #white  // the shuffle operator is used to randomized the list of cells  species izard {   init{   location <- (shuffle(cell) first_with ((each.color != #white) and (empty(izard inside each)))).location ;  }    aspect default{   draw square(1) color: #orange;  }  aspect image{   draw izardShape size: 3;  } }  // We create a grid as environment with the same dimensions as the matrix in which we want to store the image // Note that the height (resp. the width) of the grid corresponds to the number of rows (resp. of columns) of the matrix: // - in the creation of a matrix: ([…] as_matrix {widthImg/factorDiscret,heightImg/factorDiscret} ;) // - in the creation of the grid: grid cellule width: widthImg/factorDiscret height: heightImg/factorDiscret;  grid cell  width: widthImg/factorDiscret height: heightImg/factorDiscret;  experiment main type: gui {   // We display:  // - the grid  // - the original MNT image as background  // - izard agents  // We can thus compare the original MNT image and the discretized image in the grid.  // For cosmetic need, we can choose to not display the grid.   output {   display HowToImportRaster {         grid cell;         image  Background  file: mntImageRaster.path;         species izard aspect: image;       }   }  }     ","url":"wiki/Data-Importation-Raster-Image-Import.md"},{"id":"wiki/Data-Importation-Raster-Images-and-shapefile-Import.md","title":" Raster File and Shapefiles Import","content":"# Raster File and Shapefiles Import  Author : Maroussia Vavasseur and Benoit Gaudou  Model which imports data from a raster file and two shapefiles to initilalize a grid and two species. The roaster file initialize a grid attribute for the cells and the shapefiles a river species just with the same shape, and the managementUnit species with a link between the columns of the shapefile and the attributes of the species.  Code of the model :       model RasterAndShapefiles  global {  // Constants  int heightImg const: true <- 5587;  int widthImg const: true <- 6201;   file boundsMNT const: true <- file( ../images/mnt/boundsMNT.shp );  // The environment bounds are defined using the hand-made boundsMNT shapefile. // This shapefile has been created as a georeferenced bounding box of the MNT raster image, using information of the .pgw file  geometry shape <- envelope(boundsMNT);  // Global variables related to the MNT file mntImageRaster <- image_file( ../images/mnt/testAG.jpg ) ; int factorDiscret  <- 10;  // Global variables  related to the Management units  file ManagementUnitShape <- file( ../images/ug/UGSelect.shp );  // Global variables  related to the water network file waterShape <- file( ../images/reseauHydro/reseauEau.shp );  // Global variables  related to izard agents int nbIzard <- 25 ; file izardShape <-file( ../images/icons/izard.gif ) ;   // Initialization of grid and creation of the izard agents. // Creation of managmentUnit and rivers agents from the corresponding shapefile init {  create managementUnit from: ManagementUnitShape     with: [MUcode::int(read( Code_UG )), MULabel::string(read( Libelle_UG )), pgeSAGE::string(read( PGE_SAGE ))] ;      create river from: waterShape;      matrix<int> mapColor <- matrix<int>(mntImageRaster as_matrix {widthImg/factorDiscret,heightImg/factorDiscret}) ;  ask cell {     color <- rgb( mapColor at {grid_x,grid_y} );  }  create izard number: nbIzard;     } }   species river {  aspect default{   draw shape color: #blue;  }  }  species managementUnit{  int MUcode;  string MULabel;  string pgeSAGE;  aspect default{  draw shape; } }  species izard {  init{  location <- (shuffle(cell) first_with ((each.color != #white) and (empty(izard inside each)))).location ; }  aspect default{  draw square(5000) color: #orange; } aspect image{  draw izardShape size: 5000; } }    // We create a grid as environment with the same dimensions as the matrix in which we want to store the image  grid cell width: widthImg/factorDiscret height: heightImg/factorDiscret;  experiment main type: gui {  // We display: // - the original MNT image as background // - the grid representing the MNT // - izard agents // - the management unit shapefile // - the river shapefile // We can thus compare the original MNT image and the discretized image in the grid. // For cosmetic need, we can choose to not display the grid.  output {  display HowToImportVectorial {  image  Background  file: mntImageRaster.path;      grid cell;    species managementUnit transparency: 0.5;    species river ;    species izard aspect: image;    } } }       ","url":"wiki/Data-Importation-Raster-Images-and-shapefile-Import.md"},{"id":"wiki/Database-Usage-Agents-from-Database-in-MSSQL.md","title":"  Agents from Database in MSSQL","content":"#  Agents from Database in MSSQL  Author : Benoit Gaudou  This model does SQl query commands and create agents using the results  Code of the model :      model DB2agentMSSQL  global {  map<string,string> BOUNDS <- [ // srid :: 32648 , // optinal           host :: localhost ,           dbtype :: sqlserver ,           database :: spatial_DB ,           port :: 1433 ,           user :: sa ,           passwd :: tmt ,             select :: SELECT GEOM.STAsBinary() as GEOM FROM bounds;  ];  map<string,string> PARAMS <- [ // srid :: 32648 , // optinal           host :: localhost ,           dbtype :: sqlserver ,           database :: spatial_DB ,           port :: 1433 ,           user :: sa ,           passwd :: tmt ];  string QUERY <- SELECT name, type, GEOM.STAsBinary() as GEOM FROM buildings ;; geometry shape <- envelope(BOUNDS);      init {  create DB_accessor {   create buildings from: (self select [params:: PARAMS, select:: QUERY])         with:[ name::name,type::type, shape:: geometry(geom)];   } } }   species DB_accessor skills: [SQLSKILL];  species buildings {  string type;  aspect default {   draw shape color: #gray ;  }  }  experiment DB2agentMSSQL type: gui {  output {   display fullView {    species buildings aspect: default;   }  } }     ","url":"wiki/Database-Usage-Agents-from-Database-in-MSSQL.md"},{"id":"wiki/Database-Usage-Agents-from-Database-in-MySQL.md","title":"  Agents from Database in MySQL","content":"#  Agents from Database in MySQL  Author : Benoit Gaudou  This model does SQl query commands and create agents using the results  Code of the model :      model DB2agentMySQL  global {  map<string,string> BOUNDS <- [ // srid :: 32648 , // optinal           host :: localhost ,           dbtype :: MySQL ,           database :: spatial_DB ,           port :: 8889 ,           user :: root ,           passwd :: root ,             select :: SELECT geom FROM bounds;  ];  map<string,string> PARAMS <- [ // srid :: 32648 , // optinal           host :: localhost ,           dbtype :: MySQL ,           database :: spatial_DB ,           port :: 8889 ,           user :: root ,           passwd :: root ];  string QUERY <- SELECT name, type, geom FROM buildings ;; geometry shape <- envelope(BOUNDS);         init {  create DB_accessor {   create buildings from: list(self select [params:: PARAMS, select:: QUERY])         with:[  name ::name, type ::type,  shape :: geometry(geom)];   } } }   species DB_accessor skills: [SQLSKILL];  species buildings {  string type;  aspect default {   draw shape color: #gray ;  }  }  experiment DB2agentSQLite type: gui {  output {   display fullView {    species buildings aspect: default;   }  } }     ","url":"wiki/Database-Usage-Agents-from-Database-in-MySQL.md"},{"id":"wiki/Database-Usage-Agents-from-Database-in-PostGIS.md","title":"  Agents from Database in PostGIS","content":"#  Agents from Database in PostGIS  Author : Benoit Gaudou  This model does SQL query commands and create agents using the results  Code of the model :      model DB2agentMySQL  global {  map<string,string> BOUNDS <- [ // srid :: 32648 , // optinal            host :: localhost ,           dbtype :: postgres ,           database :: spatial_DB ,           port :: 5433 ,           user :: postgres ,           passwd :: tmt ,             select :: SELECT ST_AsBinary(geom) as geom FROM buildings;  ];  map<string,string> PARAMS <- [ // srid :: 32648 , // optinal           host :: localhost ,           dbtype :: postgres ,           database :: spatial_DB ,           port :: 5433 ,           user :: postgres ,           passwd :: tmt ];  string QUERY <- SELECT name, type, ST_AsBinary(geom) as geom FROM buildings ;; geometry shape <- envelope(BOUNDS);           init {  create DB_accessor {   create buildings from: (self select [params:: PARAMS, select:: QUERY])         with:[  name ::name, type ::type,  shape :: geometry(geom)];   } } }   species DB_accessor skills: [SQLSKILL];  species buildings {  string type;  aspect default {   draw shape color: #gray ;  }  }  experiment DB2agentSQLite type: gui {  output {   display fullView {    species buildings aspect: default;   }  } }     ","url":"wiki/Database-Usage-Agents-from-Database-in-PostGIS.md"},{"id":"wiki/Database-Usage-Agents-from-Database-in-SQLite.md","title":"  Agents from Database in SQLite ","content":"#  Agents from Database in SQLite  Author : Benoit Gaudou  This model creates buildings agents from the sqlite database using the result of a query  Code of the model :      model DB2agentSQLite  global { // file buildingsShp <- file( ../../includes/building.shp ); // file boundsShp <- file( ../../includes/bounds.shp ); // geometry shape <- envelope(boundsShp);  map<string,string> BOUNDS <- [dbtype::sqlite,           database :: ../../includes/spatialite.db ,         // srid :: 32648 ,          select::SELECT AsBinary(geom) as geom FROM bounds;               ]; map<string,string> PARAMS <- [dbtype::sqlite,          // srid :: 32648 ,           database :: ../../includes/spatialite.db           ];  string QUERY <- SELECT name, type, AsBinary(geom) as geom FROM buildings ;; geometry shape <- envelope(BOUNDS);          init {  create DB_accessor {   create buildings from: list(self select [params:: PARAMS, select:: QUERY])         with:[  name ::name, type ::type,  shape :: geometry(geom)];   } } }   species DB_accessor skills: [SQLSKILL];  species buildings {  string type;  aspect default {   draw shape color: #gray ;  }  }  experiment DB2agentSQLite type: gui {  output {   display fullView {    species buildings aspect: default;   }  } }     ","url":"wiki/Database-Usage-Agents-from-Database-in-SQLite.md"},{"id":"wiki/Database-Usage-Agents-from-Database-in-SQLite_QGis.md","title":"  Agents from Database in SQLite QGIS","content":"#  Agents from Database in SQLite QGIS  Author : Truong Minh Thai  This model loads data from vnm_adm2 that is created by QGis.   In this case we do not need using AsBinary() to convert blob data to WKB format.      In other case, if we load Geometry data that is created by using libspatialite library then we must use Asbinary()   to convert geometry to WKB format (see SQLite_libspatialite model)   Code of the model :      model Sqlite_QGis  global {   map BOUNDS <- [// srid :: 4326 , // optinal        dbtype :: sqlite ,        database :: ../../includes/spatialite.db        , select ::  select geom  from bounds;           ];  map PARAMS <- [// srid :: 4326 , // optinal     dbtype::sqlite,     database::../../includes/bph.db]; string QUERY <- SELECT name, type, geom as geom FROM buildings ;; geometry shape <- envelope(BOUNDS);           init {  create DB_accessor {   create buildings from: (self select [params:: PARAMS, select:: QUERY])         with:[  name ::name, type ::type,  shape :: geometry(geom)];   } } }   species DB_accessor skills: [SQLSKILL];  species buildings {  string type;  aspect default {   draw shape color: #gray ;  }  }  experiment DB2agentSQLite type: gui {  output {   display fullView {    species buildings aspect: default;   }  } }     ","url":"wiki/Database-Usage-Agents-from-Database-in-SQLite_QGis.md"},{"id":"wiki/Database-Usage-Agents-to-Database-in-MSSQL.md","title":"  Agents to Database in MSSQL","content":"#  Agents to Database in MSSQL  Author : Truong Minh Thai  This model shows how to Insert and Delete agents from a MSSQL DB  Code of the model :      model agent2DB_MSSQL  global {  file buildingsShp <- file( ../../includes/building.shp );  file boundsShp <- file( ../../includes/bounds.shp );  geometry shape <- envelope(boundsShp);  map<string,string> PARAMS <- [// srid :: 4326 , // optinal            host :: 127.0.0.1 , dbtype :: sqlserver , database :: spatial_DB ,            port :: 1433 , user :: sa , passwd :: tmt ];  init {  create buildings from: buildingsShp with: [type::string(read ( NATURE ))];  create bounds from: boundsShp;    create DB_Accessor   {       do executeUpdate params: PARAMS updateComm: DELETE FROM buildings;    do executeUpdate params: PARAMS updateComm: DELETE FROM bounds;  }  write Click on <<Step>> button to save data of agents to DB;    } }      species DB_Accessor skills: [SQLSKILL] ;  species bounds {  reflex printdata{    write   name :   + (name) ;  }  reflex savetosql{  // save data into MSSQL  write begin+ name;  ask DB_Accessor {   do insert params: PARAMS into: bounds       columns: [geom]       values: [myself.shape];  }     write finish + name; }   }   species buildings {  string type;  reflex printdata{   write   name :   + (name) +  ; type:   + (type) + shape: + shape; }  reflex savetosql{  // save data into MSSQL  write begin+ name;  ask DB_Accessor {   do insert params: PARAMS into: buildings       columns: [name, type,geom]       values: [myself.name,myself.type,myself.shape];  }     write finish + name; }   aspect default {  draw shape color: #gray ; } } experiment default_expr type: gui {  output {   display GlobalView {   species buildings aspect: default;  } } }       ","url":"wiki/Database-Usage-Agents-to-Database-in-MSSQL.md"},{"id":"wiki/Database-Usage-Agents-to-Database-in-MySQL.md","title":"  Agents to Database in MySQL","content":"#  Agents to Database in MySQL  Author : Truong Minh Thai  init: Select data from table vnm_adm2 (Created via QGis software)  and create  agents savetosql: Save data of agent into MySQL.  transform= true because you need to transform geometry data from Absolute(GAMA) to Gis NOTE: You should have imported the database (spatial_DB.sql) into the MySQL server in order that the model can run properly.  Code of the model :       model agent2DB_MySQL  global {   file buildingsShp <- file( ../../includes/building.shp );  file boundsShp <- file( ../../includes/bounds.shp );  geometry shape <- envelope(boundsShp);  map<string,string> PARAMS <- [ srid :: 4326 ,      host :: localhost , dbtype :: MySQL , database :: spatial_DB ,      port :: 8889 , user :: root , passwd :: root ];  init {  create buildings from: buildingsShp with: [type::string(read ( NATURE ))];  create bounds from: boundsShp;    create DB_Accessor number: 1    {       do executeUpdate params: PARAMS updateComm: DELETE FROM buildings;    do executeUpdate params: PARAMS updateComm: DELETE FROM bounds;  }  write Click on <<Step>> button to save data of agents to DB;    } }      species DB_Accessor skills: [SQLSKILL] ;  species bounds {  reflex printdata{    write   name :   + (name) ;  }  reflex savetosql{  // save data into MySQL  write begin+ name;  ask DB_Accessor {   do insert params: PARAMS into: bounds       columns: [geom]       values: [myself.shape];  }     write finish + name; }   }   species buildings {  string type;  reflex printdata{   write   name :   + (name) +  ; type:   + (type) + shape: + shape; }  reflex savetosql{  // save data into MySQL  write begin+ name;  ask DB_Accessor {   do insert params: PARAMS into: buildings       columns: [name, type,geom]       values: [myself.name,myself.type,myself.shape];  }     write finish + name; }   aspect default {  draw shape color: #gray ; } } experiment default_expr type: gui {  output {   display GlobalView {   species buildings aspect: default;  } } }       ","url":"wiki/Database-Usage-Agents-to-Database-in-MySQL.md"},{"id":"wiki/Database-Usage-Agents-to-Database-in-PostGIS.md","title":"  Agents to Database in PostGIS","content":"#  Agents to Database in PostGIS  Author : Truong Minh Thai  init: Select data from table vnm_adm2 (Created via QGis software)  and create  agents savetosql: Save data of agent into MySQL. transform= true because you need to transform geometry data from Absolute(GAMA) to Gis NOTE: You should have imported the database (spatial_DB.sql) into the MySQL server in order that the model can run properly.  Code of the model :       model agent2DB_MySQL  global {   file buildingsShp <- file( ../../includes/building.shp );  file boundsShp <- file( ../../includes/bounds.shp );  geometry shape <- envelope(boundsShp);  map<string,string> PARAMS <-  [// srid :: 4326 , // optinal            host :: localhost , dbtype :: Postgres , database :: spatial_DB ,            port :: 5433 , user :: postgres , passwd :: tmt ];  init {  create buildings from: buildingsShp with: [type::string(read ( NATURE ))];  create bounds from: boundsShp;    create DB_Accessor  {       do executeUpdate params: PARAMS updateComm: DELETE FROM buildings;    do executeUpdate params: PARAMS updateComm: DELETE FROM bounds;  }  write Click on <<Step>> button to save data of agents to DB;    } }      species DB_Accessor skills: [SQLSKILL] ;  species bounds {  reflex printdata{    write   name :   + (name) ;  }  reflex savetosql{  // save data into Postgres  write begin+ name;  ask DB_Accessor {   do insert params: PARAMS into: bounds       columns: [geom]       values: [myself.shape];  }     write finish + name; }   }   species buildings {  string type;  reflex printdata{  write  name :  + (name) + ; type:  + (type) + shape: + shape; }  reflex savetosql{  // save data into Postgres  write begin+ name;  ask DB_Accessor {   do insert params: PARAMS into: buildings       columns: [name, type,geom]       values: [myself.name,myself.type,myself.shape];  }     write finish + name; }   aspect default {  draw shape color: #gray ; } }      experiment default_expr type: gui {  output {   display GlobalView {   species buildings aspect: default;  } } }       ","url":"wiki/Database-Usage-Agents-to-Database-in-PostGIS.md"},{"id":"wiki/Database-Usage-Agents-to-Database-in-SQLite.md","title":"  Agents to Database in SQLite","content":"#  Agents to Database in SQLite  Author : Truong Minh Thai  init: Select data from table vnm_adm2 (Created via QGis software)  and create  agents   savetosql: Save data of agent into MySQL. transform= true because you need to transform geometry data from Absolute(GAMA) to Gis      Code of the model :       model agent2DB_SQLite  global {  file buildingsShp <- file( ../../includes/building.shp );  file boundsShp <- file( ../../includes/bounds.shp );  geometry shape <- envelope(boundsShp);  map<string,string> PARAMS <- [     dbtype :: sqlite ,     // srid :: 4326 , // optinal     database :: ../../includes/spatialite.db        ];   init {  create buildings from: buildingsShp with: [type::string(read ( NATURE ))];  create bounds from: boundsShp;    create DB_Accessor    {       do executeUpdate params: PARAMS updateComm: DELETE FROM buildings;    do executeUpdate params: PARAMS updateComm: DELETE FROM bounds;     }  write Click on <<Step>> button to save data of agents to DB;    } }      species DB_Accessor skills: [SQLSKILL] ;  species bounds {  reflex printdata{    write   name :   + (name) ;  }  reflex savetosql{  // save data into SQLite  write begin bound;  ask DB_Accessor {   do insert params: PARAMS into: bounds       columns: [geom]       values: [myself.shape];  }     write finish bound; }   }    species buildings {  string type;  reflex printdata{   write   name :   + (name) +  ; type:   + (type) + shape: + shape; }  reflex savetosql{  // save data into SQLite  write begin+ name;  ask DB_Accessor {   do insert params: PARAMS into: buildings       columns: [name, type,geom]       values: [myself.name,myself.type,myself.shape];  }     write finish + name; }   aspect default {  draw shape color: #gray ; } }       experiment default_expr type: gui {  output {   display GlobalView {   species buildings aspect: default;  } } }       ","url":"wiki/Database-Usage-Agents-to-Database-in-SQLite.md"},{"id":"wiki/Database-Usage-Connection-Test.md","title":" SQLConnection","content":"# SQLConnection  Author : thaitruongminh  How to create a connection to a database in GAMA  Code of the model :      model test_connection  global {  map<string, string> SQLSERVER <- [ host :: localhost ,  dbtype :: sqlserver ,  database ::  ,  port :: 1433 ,  user :: sa ,  passwd :: tmt ];  map<string, string> MySQL <- [ host :: localhost ,  dbtype :: MySQL ,  database ::  ,  port :: 8889 ,  user :: root ,  passwd :: root ];  map<string, string> ORACLE <- [ host :: localhost ,  dbtype :: Oracle ,  database ::  ,  port :: 1433 ,  user :: sa ,  passwd :: tmt ];  map<string, string> POSTGRES <- [ host :: localhost ,  dbtype :: Postgres ,  database :: bgaudou ,  port :: 5432 ,  user :: bgaudou ,  passwd ::  ];  map<string, string> SQLITE <- [ dbtype :: sqlite ,  database :: ../../includes/meteo.db ];  init {   create DB_connection_tester;  }  }  species DB_connection_tester skills: [SQLSKILL] {  init {   write  Current Time   + self timeStamp [];   write  Connection to SQLSERVER is   + self testConnection [params::SQLSERVER];   write  Connection to MySQL is   + self testConnection [params::MySQL];   write  Connection to SQLITE is   + self testConnection [params::SQLITE];   write  Connection to ORACLE is   + self testConnection [params::ORACLE];   write  Connection to POSTGRESQL is   + self testConnection [params::POSTGRES];  }  }  experiment default_expr type: gui { }     ","url":"wiki/Database-Usage-Connection-Test.md"},{"id":"wiki/Database-Usage-Create-Agents-and-Insert-in-MySQL.md","title":"  create_agents_Insert_result_MySQL","content":"#  create_agents_Insert_result_MySQL  Author : Benoit Gaudou  This model illustrates the use of the MySQL DBMS to:       create agents from a database   store every cycle some results into a database      Note: this model could be used with any DBMS just by changing the PARAMS variable.      NOTE: YOU SHOULD HAVE ALREADY CREATED YOUR DATABASE (meteo_DB here) AND IMPORTED THE FILE (../../includes/meteo_DB_dump.sql)   IN ORDER THAT THE MODEL CAN RUN PROPERLY.   Code of the model :      model create_agents_Insert_result_MySQL  global {  string res_DB <-  result_DB ;  map<string, string> PARAMS <- [ host :: localhost ,  dbtype :: MySQL ,  database :: meteo_DB ,  port :: 8889 ,  user :: root ,  passwd :: root ];  string SQLquery_idPoint <-  SELECT idPointgrille, AVG(RRmm) AS RR, AVG(Tmin) AS Tmin, AVG(Tmax) AS Tmax, AVG(Rglot) AS Rglot, AVG(ETPmm) AS ETPmm        FROM meteo_table GROUP BY idPointgrille ;  init {   create DB_accessor;   ask DB_accessor {    do executeUpdate params: PARAMS updateComm:  CREATE TABLE result_DB (             idPoint varchar(16) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,             valRnd float NOT NULL DEFAULT  0 ,             cycle int(16) NOT NULL DEFAULT  0            ) ENGINE=InnoDB DEFAULT CHARSET=utf8; ;   }   create idPoint from: list(first(DB_accessor) select [params::PARAMS, select::SQLquery_idPoint]) with:  [name:: idPointgrille, RRmm::float(RR), Tmin::float(Tmin), Tmax::float(Tmax), Rglot::float(Rglot), ETPmm::float(ETPmm)]; }  reflex endSimu when: (cycle = 10) {  ask DB_accessor {   write Data:  + (self select [params::PARAMS, select::select * FROM  + res_DB]);   do executeUpdate params: PARAMS updateComm: DROP TABLE  + res_DB;  }   write DROP the result table;  do halt;  }   }  species idPoint {  float RRmm;  float Tmin;  float Tmax;  float Rglot;  float ETPmm;  float valRnd;  reflex compute_new_random_value {   valRnd <- float(rnd(RRmm + Tmin + Tmax + Rglot + ETPmm));  }  reflex store_valRnd {  write   + self +  inserts value  + valRnd;  ask (first(DB_accessor)) {   do executeUpdate params: PARAMS updateComm: INSERT INTO  + res_DB +  VALUES(?, ?, ?); values: [myself.name, myself.valRnd, cycle];  }   write   + self +  inserts value  + valRnd; }   }  species DB_accessor skills: [SQLSKILL] {  list listRes <- [];  init {  // Test of the connection to the database   if (not (self testConnection [params::PARAMS])) {    write  Connection impossible ;    ask (world) {     do halt;    }   } else {   write Connection Database OK.;  }   write  + list(self select [params::PARAMS, select::SELECT * FROM meteo_table]);  write  + list(self select [params::PARAMS, select::SQLquery_idPoint]); }   }  experiment createInsertMySQL type: gui { }      ","url":"wiki/Database-Usage-Create-Agents-and-Insert-in-MySQL.md"},{"id":"wiki/Database-Usage-Create-Spatial-Table-in-MSSQL.md","title":"  CreateBuildingTableMSSQL","content":"#  CreateBuildingTableMSSQL  Author : Truong Minh Thai  This model shows how to create a database and a table in MSSQL using GAMA  Code of the model :      model CreateBuildingTable_MSSQL  global {  map<string, string> PARAMS <- [ host :: 127.0.0.1 ,  dbtype :: sqlserver ,  database ::  ,  port :: 1433 ,  user :: sa ,  passwd :: tmt ];  init  {   create dummy;   ask dummy   {    if (self testConnection [params::PARAMS])    {     do executeUpdate params: PARAMS updateComm:  CREATE DATABASE spatial_DB ;     write  spatial_BD database was created  ;     remove   database  from: PARAMS;     put  spatial_DB  key:  database  in: PARAMS;     do executeUpdate params: PARAMS updateComm:  CREATE TABLE bounds  +  (   +   geom GEOMETRY   +  ) ;     write  bounds table was created  ;     do executeUpdate params: PARAMS updateComm:  CREATE TABLE buildings   +  (   +   name VARCHAR(255),   +   type VARCHAR(255),   +   geom GEOMETRY   +  ) ;     write  buildings table was created  ;    } else    {     write  Connection to MySQL can not be established  ;    }   }  }   }  species dummy skills: [SQLSKILL] { }  experiment default_expr type: gui { }     ","url":"wiki/Database-Usage-Create-Spatial-Table-in-MSSQL.md"},{"id":"wiki/Database-Usage-Create-Spatial-Table-in-MySQL.md","title":"  CreateBuildingTableMySQL","content":"#  CreateBuildingTableMySQL  Author : Truong Minh Thai  This model shows how to create a database and a table in MySQL using GAMA  Code of the model :      model CreateBuildingTableMySQL  global {  map<string, string> PARAMS <- [ host :: localhost ,  dbtype :: MySQL ,  database ::  ,  port :: 8889 ,  user :: root ,  passwd :: root ];  init  {   create test_species number: 1;   ask test_species   {    if (self testConnection [params::PARAMS])    {     do executeUpdate params: PARAMS updateComm:  CREATE DATABASE spatial_DB_GAMA ;     write  spatial_BD_GAMA database was created  ;     remove  database  from: PARAMS;     put  spatial_DB_GAMA  key:  database  in: PARAMS;     do executeUpdate params: PARAMS updateComm:  CREATE TABLE bounds  +  (   +   geom GEOMETRY   +  ) ;     write  bounds table was created  ;     do executeUpdate params: PARAMS updateComm:  CREATE TABLE buildings   +  (   +   name VARCHAR(255),   +   type VARCHAR(255),   +   geom GEOMETRY   +  ) ;     write  buildings table was created  ;    } else    {     write  Connection to MySQL can not be established  ;    }   }  }   }  species test_species skills: [SQLSKILL] { }  experiment default_expr type: gui { }     ","url":"wiki/Database-Usage-Create-Spatial-Table-in-MySQL.md"},{"id":"wiki/Database-Usage-Create-Spatial-Table-in-PostGIS.md","title":"  CreateBuildingTablePostGIS","content":"#  CreateBuildingTablePostGIS  Author : Truong Minh Thai  This model shows how to create a database and a table in PostGIS using GAMA  Code of the model :      model CreateBuildingTablePostGIS  global {  map<string, string> PARAMS <- [ host :: localhost ,  dbtype :: Postgres ,  database ::  ,  port :: 5433 ,  user :: postgres ,  passwd :: tmt ];  init  {   create dummy;   ask dummy   {    if (self testConnection [params::PARAMS])    {     do executeUpdate params: PARAMS updateComm:  CREATE DATABASE spatial_db with TEMPLATE = template_postgis; ;     write  spatial_BD database was created  ;     remove  database  from: PARAMS;     put  spatial_db  key:  database  in: PARAMS;     do executeUpdate params: PARAMS updateComm:  CREATE TABLE bounds  +  (   +   geom GEOMETRY   +  ) ;     write  bounds table was created  ;     do executeUpdate params: PARAMS updateComm:  CREATE TABLE buildings   +  (   +   name character varying(255),   +   type character varying(255),   +   geom GEOMETRY   +  ) ;     write  buildings table was created  ;    } else    {     write  Connection to MySQL can not be established  ;    }   }  }   }  species dummy skills: [SQLSKILL] { }  experiment default_expr type: gui { }     ","url":"wiki/Database-Usage-Create-Spatial-Table-in-PostGIS.md"},{"id":"wiki/Database-Usage-Create-Spatial-Table-in-SQLite.md","title":"  CreateBuildingTableSQLite","content":"#  CreateBuildingTableSQLite  Author : Truong Minh Thai  This model shows how to create a database and a table in SQLite using GAMA  Code of the model :       model SQLite_selectNUpdate  global {  map PARAMS <- [ dbtype :: sqlite , database :: ../../includes/spatialite.db ];  init {  create dummy ;  ask (dummy)   {    do  executeUpdate params: PARAMS      updateComm: DROP TABLE bounds;  ;     do  executeUpdate params: PARAMS        updateComm: DROP TABLE buildings;  ;       write  dropped tables! ;   do executeUpdate params: PARAMS updateComm: CREATE TABLE bounds  +      (id INTEGER PRIMARY KEY,  +        geom BLOB NOT NULL);   ;     do executeUpdate params: PARAMS updateComm: CREATE TABLE buildings  +      (id INTEGER PRIMARY KEY,  +       name TEXT NOT NULL, +       type TEXT NOT NULL, +       geom BLOB NOT NULL);   ;   } } }     species dummy skills: [SQLSKILL] { }  experiment default_expr type:gui {  }        ","url":"wiki/Database-Usage-Create-Spatial-Table-in-SQLite.md"},{"id":"wiki/Database-Usage-Simple-SQL-Command-in-SQLite.md","title":"  Simple SQL Command in SQLIte","content":"#  Simple SQL Command in SQLIte  Author : Truong Minh Thai  This model does SQl query commands:       Create table   Insert data   Select data   Delete data   Drop table Note: the file emptyFile.db is only … an empty file.   Code of the model :      model SQLite_selectNUpdate  global {  map<string, string> PARAMS <- [ dbtype :: sqlite ,  database :: ../../includes/emptyFile.db ];  init {   create DB_Accessor;   // Test of the connection to the database  if (first(DB_Accessor) testConnection [params::PARAMS] = false) {   write Connection impossible;   do halt;  }   ask (DB_Accessor) {   do executeUpdate params: PARAMS updateComm: CREATE TABLE registration + (id INTEGER PRIMARY KEY,  +  first TEXT NOT NULL,  +  last TEXT NOT NULL,  +  age INTEGER);;   write REGISTRATION table has been created.;   do executeUpdate params: PARAMS updateComm: INSERT INTO registration  + VALUES(100,  Zara ,  Ali , 18);;   do executeUpdate params: PARAMS updateComm: INSERT INTO registration  + VALUES(?, ?, ?, ?); values: [101,  Mr ,  Mme , 45];   do insert params: PARAMS into: registration values: [102,  Mahnaz ,  Fatma , 25];   do insert params: PARAMS into: registration columns: [id, first, last] values: [103,  Zaid tim ,  Kha ];   do insert params: PARAMS into: registration columns: [id, first, last] values: [104,  Bill ,  Clark ];   write Five records have been inserted.;   write Click on <<Step>> button to view selected data;  }  }   }  species DB_Accessor skills: [SQLSKILL] {  reflex select {   list t <- list (self select [params::PARAMS, select::SELECT * FROM registration]);   write Select before updated  + t;  }  reflex update {  do executeUpdate params: PARAMS updateComm: UPDATE registration SET age = 30 WHERE id IN (100, 101);  do executeUpdate params: PARAMS updateComm: DELETE FROM registration where id=103 ;  list<list> t <- list<list> (self select [params::PARAMS, select::SELECT * FROM registration]);  write Select after updated  + t; }  reflex drop {  do executeUpdate params: PARAMS updateComm: DROP TABLE registration;  write Registration table has been dropped.; }   }  experiment simple_SQL_exp type: gui { }        ","url":"wiki/Database-Usage-Simple-SQL-Command-in-SQLite.md"},{"id":"wiki/Database-Usage-Simple-Species-MySQL.md","title":"  Simple Species MySql","content":"#  Simple Species MySql  Author : Truong Minh Thai  This model illustrates the use of the AgentDB species (instead of the SQLSKILL), and in particular following actions:       testConection   isConnected   close   executeUpdate   insert   select   getParameter      This model does SQl query commands: Create table   Insert data   Select data   Delete data   Drop table NOTE: YOU SHOULD HAVE ALREADY CREATED YOUR DATABASE (meteo_DB here) AND IMPORTED THE FILE (../../includes/meteo_DB_dump.sql)   IN ORDER THAT THE MODEL CAN RUN PROPERLY.   Code of the model :      model simpleSQL_DBSpecies_MySQL  global {  map<string, string> PARAMS <- [ host :: localhost ,  dbtype :: MySQL ,  database :: meteo_DB ,  port :: 8889 ,  user :: root ,  passwd :: root ];  init {   create DB_Accessor number: 1 {    if (self testConnection (params::PARAMS) = false) {     write  Impossible connection ;    } else {     write  Connection of   + self;     do connect params: PARAMS;    }   }   if (first(DB_Accessor) isConnected [] = false) {   write No connection.;   ask (AgentDB) {    do close;   }    do halt;  } else {   write  + first(DB_Accessor) getParameter ();  }   ask (DB_Accessor) {   do executeUpdate updateComm: CREATE TABLE registration + (id INTEGER PRIMARY KEY,  +  first TEXT NOT NULL,  +  last TEXT NOT NULL,  +  age INTEGER);;   write REGISTRATION table has been created.;   do executeUpdate updateComm: INSERT INTO registration  + VALUES(100,  Zara ,  Ali , 18);;   do executeUpdate updateComm: INSERT INTO registration  + VALUES(?, ?, ?, ?); values: [101,  Mr ,  Mme , 45];   do insert into: registration values: [102,  Mahnaz ,  Fatma , 25];   do insert into: registration columns: [id, first, last] values: [103,  Zaid tim ,  Kha ];   do insert into: registration columns: [id, first, last] values: [104,  Bill ,  Clark ];   write Five records have been inserted.;   write Click on <<Step>> button to view selected data;  }  }   }  species DB_Accessor parent: AgentDB {  reflex select {   list t <- list (self select (select::SELECT * FROM registration));   write Select before updated  + t;  }  reflex update {  do executeUpdate updateComm: UPDATE registration SET age = 30 WHERE id IN (100, 101);  do executeUpdate updateComm: DELETE FROM registration where id=103 ;  list<list> t <- list<list> (self select (select::SELECT * FROM registration));  write Select after updated  + t; }  reflex drop {  do executeUpdate updateComm: DROP TABLE registration;  write Registration table has been dropped.; }   }  experiment simple_SQL_exp type: gui { }        ","url":"wiki/Database-Usage-Simple-Species-MySQL.md"},{"id":"wiki/Date-and-Time-Date-type-and-real-dates.md","title":" Use of the Date variables","content":"# Use of the Date variables  Author :  Patrick Taillandier  A model to show how to use date variables and more particularly the starting_date and current_date global variables.  Code of the model :      model date_model  global {  //definition of the date of begining of the simulation - defining this date will allows to change the normal date management of the simulation by a more realistic one (using calendar)  date starting_date <- date([2011,1,2,1,1,30]);  //be careful, when real dates are used, modelers should not use the #month and #year values that are not consistent with them float step <- 1#h;   init {  write starting_date:  + starting_date;    //there are several ways to define a date.  //The simplest consists in using a list of int values: [year,month of the year,day of the month, hour of the day, minute of the hour, second of the minute]  date my_date <- date([2010,3,23,17,30,10]); //correspond the 23th of March 2010, at 17:30:10    //It is also possible to define a date through a string:  date my_date2 <- date(2010-3-23T17:30:10+07:00);   write (my_date2);   //it is possible to get the current date by using the now string:  date today <- date(now);   write (today);    write \\n -----------------------------------------------  ;    //GAMA provides several operator to manipulate dates:      //for instance, it is possible to compute the duration in seconds between 2 dates:  float d <- starting_date - my_date;  write duration between  + my_date +  and  + starting_date +  :  + d + s;    write \\n -----------------------------------------------  ;    //to add or subtract a duration (in secondes) to a date:   write my_date2 + 10:  + (my_date2 + 10);   write my_date2 - 10:  + (my_date2 - 10);      write \\n -----------------------------------------------  ;         //to add or subtract a duration (in years, months, weeks, days, hours, minutes,  secondes) to a date:    write my_date2 add_years 1:  + (my_date2 add_years 1);    write my_date2 add_months 1:  + (my_date2 add_months 1);    write my_date2 add_weeks 1:  + (my_date2 add_weeks 1);    write my_date2 add_days 1:  + (my_date2 add_days 1);    write my_date2 add_hours 1:  + (my_date2 add_hours 1);    write my_date2 add_minutes 1:  + (my_date2 add_minutes 1);    write my_date2 add_seconds 1:  + (my_date2 add_seconds 1);        write my_date2 subtract_years 1:  + (my_date2 subtract_years 1);    write my_date2 subtract_months 1:  + (my_date2 subtract_months 1);    write my_date2 subtract_weeks 1:  + (my_date2 subtract_weeks 1);    write my_date2 subtract_days 1:  + (my_date2 subtract_days 1);    write my_date2 subtract_hours 1:  + (my_date2 subtract_hours 1);    write my_date2 subtract_minutes 1:  + (my_date2 subtract_minutes 1);    write my_date2 subtract_seconds 1:  + (my_date2 subtract_seconds 1); }  reflex info_date {  //at each simulation step, the current_date is updated - its value can be seen in the top-left green info panel.  write current_date at cycle  + cycle +  :  + current_date; } }   experiment main type: gui;     ","url":"wiki/Date-and-Time-Date-type-and-real-dates.md"},{"id":"wiki/Date-and-Time-Simple-Time-definition.md","title":" Simple definition of time property in a model","content":"# Simple definition of time property in a model  Author : Patrick Taillandier  Show how the time is managed is GAMA.  Code of the model :       model SimpleTimedefinition  global {  //redifitiion of the duration of one simulation step to 1 hour. By default the duration is one second.  float step <- 1 #hour;  init {  //GAMA provides different values for temporal unities - these values are given in seconds  write 1#s:  + 1#s;  write 1#mn:  + 1#mn;  write 1#hour:  + 1#hour;  write 1#day:  + 1#day;  write 1#month:  + 1#month;  write 1#year:  + 1#year;    //Note that these values are constant: the value #month is always equal to 30 #day.  } reflex info_time {  write \\n-------------------------------------------;  //the global variable cycle gives the current step of the simulation  write cycle:  + cycle;    //the global variable time gives the current duration (in seconds) since the beginning of the simulation: time = cycle * step  //The value of the time facet can be seen - in a date-time presentation - in the top-left green info panel (click on the number of cycle to see the time value).  //When presenting the time value, a month is considered as being composed of 30 days. For a more realistic calendar, use the starting_date global value (see the Date type and Real dates model)  write time:  + time; } }   experiment SimpleTimedefinition type: gui ;     ","url":"wiki/Date-and-Time-Simple-Time-definition.md"},{"id":"wiki/Driving-Skill-OSM-Loading-Driving.md","title":" OSM Loading Driving","content":"# OSM Loading Driving  Author : Patrick Taillandier  Model to show how to import OSM Files, using them to create agents for a road network, and saving the different agents in shapefiles. The first goal of this model is to prepare data for the driving skill models.  Code of the model :       model OSMdata_to_shapefile  global{  //map used to filter the object to build from the OSM file according to attributes. for an exhaustive list, see: http://wiki.openstreetmap.org/wiki/Map_Features  map filtering <- map([ highway ::[ primary ,  secondary ,  tertiary ,  motorway ,  living_street , residential ,  unclassified ]]);  //OSM file to load file<geometry> osmfile <-  file<geometry>(osm_file(../includes/rouen.gz, filtering))  ;  geometry shape <- envelope(osmfile); graph the_graph;  map<point, intersection> nodes_map;    init {  write OSM file loaded:  + length(osmfile) +  geometries;    //from the OSM file, creation of the selected agents  loop geom over: osmfile {   if (shape covers geom) {    string highway_str <- string(geom get (highway));    if (length(geom.points) = 1 ) {     if ( highway_str != nil ) {      string crossing <- string(geom get (crossing));      create intersection with: [shape ::geom, type:: highway_str, crossing::crossing] {       nodes_map[location] <- self;      }     }    } else {     string oneway <- string(geom get (oneway));     float maxspeed_val <- float(geom get (maxspeed));     string lanes_str <- string(geom get (lanes));     int lanes_val <- empty(lanes_str) ? 1 : ((length(lanes_str) > 1) ? int(first(lanes_str)) : int(lanes_str));     create road with: [shape ::geom, type:: highway_str, oneway::oneway, maxspeed::maxspeed_val, lanes::lanes_val] {      if lanes < 1 {lanes <- 1;} //default value for the lanes attribute      if maxspeed = 0 {maxspeed <- 50.0;} //default value for the maxspeed attribute     }    }    }  }  write Road and node agents created;    ask road {   point ptF <- first(shape.points);   if (not(ptF in nodes_map)) {    create intersection with:[location::ptF] {     nodes_map[location] <- self;    }    }   point ptL <- last(shape.points);   if (not(ptL in nodes_map)) {    create intersection with:[location::ptL] {     nodes_map[location] <- self;    }   }  }     write Supplementary node agents created;  ask intersection {   if (empty (road overlapping (self))) {    do die;   }  }    write node agents filtered;    //Save all the road agents inside the file with the path written, using the with: facet to make a link between attributes and columns of the resulting shapefiles.   save road type:shp to:../includes/roads.shp with:[lanes::lanes,maxspeed::maxspeed, oneway::oneway] ;  save intersection type:shp to:../includes/nodes.shp with:[type::type, crossing::crossing] ;  write road and node shapefile saved; } }   species road{  rgb color <- rgb(rnd(255),rnd(255),rnd(255));  string type;  string oneway;  float maxspeed;  int lanes;  aspect base_ligne {   draw shape color: color;   }  }  species intersection {  string type;  string crossing;  aspect base {    draw square(3) color: #red ;  } }  experiment fromOSMtoShapefiles type: gui {  output {   display map type: opengl {    graphics  world  {     draw world.shape.contour;    }    species road aspect: base_ligne  refresh: false  ;    species intersection aspect: base   refresh: false ;   }  } }     ","url":"wiki/Driving-Skill-OSM-Loading-Driving.md"},{"id":"wiki/Driving-Skill-Road-Traffic-advanced.md","title":" Complex Road Network ","content":"# Complex Road Network  Author : Patrick Taillandier  Model to show how to use the driving skill to represent the traffic on a road network generated thanks to shapefiles, with intersections and traffic lights going from red to green to let people move or stop. Two experiments are presented : experiment_2D to display the model in 2D and which better display the orientation of roads and experiment_3D to display the model in 3D.  Code of the model :       model RoadTrafficComplex  global {   bool simple_data <- false;  //Check if we use simple data or more complex roads file shape_file_roads  <- simple_data ? file(../includes/RoadCircleLanes.shp): file(../includes/ManhattanRoads.shp) ; file shape_file_nodes  <- simple_data ? file(../includes/NodeCircleLanes.shp) : file(../includes/ManhattanNodes.shp); file shape_file_bounds <- simple_data ? file(../includes/BoundsLaneRoad.shp) :file(../includes/ManhattanRoads.shp); geometry shape <- envelope(shape_file_bounds) + 50.0;  graph road_network;   int nb_people <- simple_data ? 20 : 500;   init {    //create the intersection and check if there are traffic lights or not by looking the values inside the type column of the shapefile and linking  // this column to the attribute is_traffic_signal.   create intersection from: shape_file_nodes with:[is_traffic_signal::(read(type) = traffic_signals)];    //create road agents using the shapefile and using the oneway column to check the orientation of the roads if there are directed  create road from: shape_file_roads with:[lanes::int(read(lanes)), oneway::string(read(oneway))] {   geom_display <- shape + (2.5 * lanes);   maxspeed <- (lanes = 1 ? 30.0 : (lanes = 2 ? 50.0 : 70.0)) °km/°h;   switch oneway {    match no {     create road {      lanes <- max([1, int (myself.lanes / 2.0)]);      shape <- polyline(reverse(myself.shape.points));      maxspeed <- myself.maxspeed;      geom_display  <- myself.geom_display;      linked_road <- myself;      myself.linked_road <- self;     }     lanes <- int(lanes /2.0 + 0.5);    }    match -1 {     shape <- polyline(reverse(shape.points));    }    }  }   map general_speed_map <- road as_map (each::(each.shape.perimeter / each.maxspeed));    //creation of the road network using the road and intersection agents  road_network <-  (as_driving_graph(road, intersection))  with_weights general_speed_map;    //initialize the traffic light  ask intersection {   do initialize;  }    create people number: nb_people {    max_speed <- 160 °km/°h;   vehicle_length <- 5.0 °m;   right_side_driving <- true;   proba_lane_change_up <- 0.1 + (rnd(500) / 500);   proba_lane_change_down <- 0.5+ (rnd(500) / 500);   location <- one_of(intersection where empty(each.stop)).location;   security_distance_coeff <- 5/9 * 3.6 * (1.5 - rnd(1000) / 1000);     proba_respect_priorities <- 1.0 - rnd(200/1000);   proba_respect_stops <- [1.0];   proba_block_node <- 0.0;   proba_use_linked_road <- 0.0;   max_acceleration <- 5/3.6;   speed_coeff <- 1.2 - (rnd(400) / 1000);   threshold_stucked <-int ( (1 + rnd(5))°mn);   proba_breakdown <- 0.00001;     }  }   }  //species that will represent the intersection node, it can be traffic lights or not, using the skill_road_node skill species intersection skills: [skill_road_node] {  bool is_traffic_signal;  list stop;  int time_to_change <- 100;  int counter <- rnd (time_to_change) ;  list ways1;  list ways2;  bool is_green;  rgb color_fire;  action initialize {  if (is_traffic_signal) {   do compute_crossing;   stop<< [];   if (flip(0.5)) {    do to_green;   } else {    do to_red;   }   } }  action compute_crossing{  if  (length(roads_in) >= 2) {   road rd0 <- road(roads_in[0]);   list<point> pts <- rd0.shape.points;         float ref_angle <-  float( last(pts) direction_to rd0.location);   loop rd over: roads_in {    list<point> pts2 <- road(rd).shape.points;          float angle_dest <-  float( last(pts2) direction_to rd.location);    float ang <- abs(angle_dest - ref_angle);    if (ang > 45 and ang < 135) or  (ang > 225 and ang < 315) {     ways2<< road(rd);    }   }  }  loop rd over: roads_in {   if not(rd in ways2) {    ways1 << road(rd);   }  } }  action to_green {  stop[0] <- ways2 ;  color_fire <- #green;  is_green <- true; }  action to_red {  stop[0] <- ways1;  color_fire <- #red;  is_green <- false; } reflex dynamic_node when: is_traffic_signal  {  counter <- counter + 1;  if (counter >= time_to_change) {    counter <- 0;   if is_green {do to_red;}   else {do to_green;}  }  }  aspect base {  if (is_traffic_signal) {    draw circle(5) color: color_fire;  } }  aspect base3D {  if (is_traffic_signal) {    draw box(1,1,10) color:#black;   draw sphere(5) at: {location.x,location.y,12} color: color_fire;  } } }   //species that will represent the roads, it can be directed or not and uses the skill skill_road species road skills: [skill_road] {   geometry geom_display;  string oneway;  aspect base {     draw shape color: #gray end_arrow: 10;  }   aspect base3D {     draw geom_display color: #gray ;  }  }  //People species that will move on the graph of roads to a target and using the skill advanced_driving species people skills: [advanced_driving] {   rgb color <- rgb(rnd(255), rnd(255), rnd(255)) ;  int counter_stucked <- 0;  int threshold_stucked;  bool breakdown <- false;  float proba_breakdown ;  intersection target;  reflex breakdown when: flip(proba_breakdown){  breakdown <- true;  max_speed <- 1 °km/°h; }  reflex time_to_go when: final_target = nil {  target <- one_of(intersection where not each.is_traffic_signal);  current_path <- compute_path(graph: road_network, target: target );  if (current_path = nil ) {   final_target <- nil;  } } reflex move when: current_path != nil and final_target != nil {  do drive;  if real_speed < 5°km/°h {   counter_stucked<- counter_stucked + 1;   if (counter_stucked mod threshold_stucked = 0) {    proba_use_linked_road <- min([1.0,proba_use_linked_road + 0.1]);   }  } else {   counter_stucked<- 0;   proba_use_linked_road <- 0.0;  } }  aspect base {   draw breakdown ? square(15) : triangle(15) color: color rotate:heading + 90; }  aspect base3D {  point loc <- calcul_loc();  draw box(vehicle_length, 1,1) at: loc rotate:  heading color: color;    draw triangle(0.5) depth: 1.5 at: loc rotate:  heading + 90 color: color;    if (breakdown) {   draw circle(2) at: loc color: #red;  } }   point calcul_loc {  if (current_road = nil) {   return location;  } else {   float val <- (road(current_road).lanes - current_lane) + 0.5;   val <- on_linked_road ? val * - 1 : val;   if (val = 0) {    return location;    } else {    return (location + {cos(heading + 90) * val, sin(heading + 90) * val});   }  } }   }  experiment experiment_2D type: gui {  parameter  if true, simple data (simple track), if false complex one (Manhattan):  var: simple_data category:  GIS  ;  output {   display city_display {    species road aspect: base ;    species intersection aspect: base;    species people aspect: base;   }  } }  experiment experiment_3D type: gui {  parameter  if true, simple data (simple track), if false complex one (Manhattan):  var: simple_data category:  GIS  ;  output {   display carte_principale type: opengl {    species road aspect: base3D refresh: true;    species intersection aspect: base3D;    species people aspect: base3D ;    }  } }      ","url":"wiki/Driving-Skill-Road-Traffic-advanced.md"},{"id":"wiki/Driving-Skill-Road-Traffic-simple-(City).md","title":" Simple Road Network ","content":"# Simple Road Network  Author : Patrick Taillandier  Model using shapefiles to create buildings and a road graph, with people going from their living place to their work place depending on the hour. The traffic jam is also taken into account to slow the people agents when they are too much on the same road. The experiment shows a display of the city, with people agents, buildings and roads, a display of the traffic jam occuring on the roads, and a chart display showing two charts : one for the traffic jam coefficients, and an other for the objectives of the people agents.  Code of the model :       model RoadTrafficCity  global {  //Shapefiles for the buildings, the roads and the bounds of the environment file shape_file_roads parameter: Shapefile for the roads: category: GIS <- file(../includes/ManhattanRoads.shp) ; file shape_file_bounds parameter: Shapefile for the bounds: category: GIS <- file(../includes/ManhattanBounds.shp) ; file shape_file_buildings parameter: Shapefile for the buildings: category: GIS <- file(../includes/ManhattanBuildings.shp) ; geometry shape <- envelope(shape_file_bounds);  //Stock the number of times agents reached their goal (their house or work place) int nbGoalsAchived <- 0;  //represent the day time for the agent to inform them to go work or home int day_time update: cycle mod 144 ;  //Variables to manage the minimal and maximal time to start working int min_work_start <- 36; int max_work_start <- 60;  //Number of people created int nb_people <- 500;  //Variables to manage the minimal and maximal time to go home int min_work_end <- 84;  int max_work_end <- 132;   //Manage the speed allowed in the model for the people agents float min_speed <- 50.0; float max_speed <- 100.0;   //Graph of the road network graph the_graph;    init {      //creation of the agents of road and building species using the shapefile and linking the   create road from: shape_file_roads with:[nbLanes::int(read(lanes))];  create building from: shape_file_buildings;    //Increase the shape of roads according to the number of lanes it has  ask road as list {   visu_geom <- shape + (2 * nbLanes);   }  //Initliazation of the graph with the road species  the_graph <-  (as_edge_graph(road));    //Initialization of nb_people agents of people species  // and definition of their living and working places  create people number: nb_people {    living_space <- 3.0;   tolerance <- 0.1;   lanes_attribute <- nbLanes;   obstacle_species <- [species(self)];    speed <- min_speed + rnd (max_speed - min_speed) ;   start_work <- min_work_start + rnd (max_work_start - min_work_start) ;   end_work <- min_work_end + rnd (max_work_end - min_work_end) ;   living_place <- one_of(building) ;   working_place <- one_of(building) ;   location <- living_place.location;   }    }  //Update of the graph every 10 Cycles to take into account the traffic jam of the road in the weights of the graph reflex update_graph when:every(10){  map<road,float> weights_map <- road as_map (each:: (each.shape.perimeter * each.coeff_traffic));  the_graph <- the_graph with_weights weights_map; }   }  species road  {   int nbLanes;  int indexDirection;   bool blocked <- false;  rgb color <- #black;  float coeff_traffic <- 1.0 update: 1 + (float(length(people at_distance 1.0)) / shape.perimeter * 200 / nbLanes);  geometry visu_geom;  aspect base {   draw shape color: #black ; }    //Command that the user can execute to remove or add a road  user_command Remove a road action: remove; user_command Add a road action: add;    action remove {  blocked <- true;  the_graph <-  (as_edge_graph(road where (!each.blocked))) ;  map<road,float> weights_map <- road as_map (each:: each.coeff_traffic);  the_graph <- the_graph  with_weights weights_map;  color <- #magenta; }   action add {  blocked <- false;  the_graph <-  (as_edge_graph(road where (!each.blocked)));  map<road,float> weights_map <- road as_map (each:: each.coeff_traffic);  the_graph <- the_graph  with_weights weights_map;  color <- #black; }   aspect road_width {    draw visu_geom color: color ; }  aspect traffic_jam {    if (coeff_traffic > 0.025) {   draw shape + (coeff_traffic / 4.0) color: #red ;  } }    }   species building  {   rgb color <- #gray;  aspect base {    draw shape color: color ;  } }  species people skills: [driving]{   float speed;   rgb color <- rgb([rnd(255),rnd(255),rnd(255)]) ;  point targetBis <- nil ;   point previousLoc <- nil;  bool normalMove <- true;  float evadeDist <- 500.0;  building living_place <- nil ;  building working_place <- nil ;  int start_work ;  int end_work  ;  string objective ;   point the_target <- nil ;  //Reflex to make the agent move while it had a target and normalMove equals true reflex move when: the_target != nil and normalMove{  previousLoc <- copy(location);  do goto_driving target: the_target on: the_graph speed: speed ;   switch location {    match the_target {    the_target <- nil;    nbGoalsAchived <- nbGoalsAchived +1;   }   match previousLoc {    targetBis <- last((one_of(road where (each distance_to self < evadeDist)).shape).points);    normalMove <- false;   }  } }   //Reflex to make the agent move when it is not normal moving  reflex EvadeMove when: !(normalMove){  previousLoc <- copy(location);  do goto_driving target: targetBis on: the_graph speed: speed ;   switch location {    match targetBis {    normalMove <- true;   }   match previousLoc {    targetBis <- last((one_of(road where (each distance_to self < evadeDist)).shape).points);   }  } }  //Reflex to make the agent go to its working place when it s time to go work reflex time_to_work when: day_time = start_work {  objective <- working ;  the_target <- any_location_in (working_place); }  //Reflex to make the agent go to its living place when it s time to go home reflex time_to_go_home when: day_time = end_work {  objective <- go home ;  the_target <- any_location_in (living_place);  }    aspect base {  draw circle(20) color: color; } }   experiment traffic type: gui {  parameter  Shapefile for the buildings:  var: shape_file_buildings category:  GIS  ;  parameter  Shapefile for the roads:  var: shape_file_roads category:  GIS  ;  parameter  Shapefile for the bounds:  var: shape_file_bounds category:  GIS  ;  parameter  Number of people agents  var: nb_people category:  People  ;  parameter  Earliest hour to start work  var: min_work_start category:  People  ;  parameter  Latest hour to start work  var: max_work_start category:  People  ;  parameter  Earliest hour to end work  var: min_work_end category:  People  ;  parameter  Latest hour to end work  var: max_work_end category:  People  ;  parameter  minimal speed  var: min_speed category:  People  ;  parameter  maximal speed  var: max_speed category:  People  ;  output {  display city_display {   species road aspect: road_width ;   species building aspect: base;   species people aspect: base;  }  display traffic_jam_display {   species road aspect: base ;   species road aspect: traffic_jam ;  }  display chart_display refresh: every(10) {   chart Traffic jam type: series size: {0.9, 0.4} position: {0.05, 0.05} {    data Mean road traffic coefficient value: mean (road collect each.coeff_traffic) style: line color: #green ;    data Max road traffic coefficient value: road max_of (each.coeff_traffic) style: line color: #red ;   }   chart People Objectif type: pie style: exploded size: {0.9, 0.4} position: {0.05, 0.55} {    data Working value: length ((people as list) where (each.objective=working)) color: #green ;    data Staying home value: length ((people as list) where (each.objective=go home)) color: #blue ;   }  }  monitor Number of goals achieved value: nbGoalsAchived ; } }       ","url":"wiki/Driving-Skill-Road-Traffic-simple-(City).md"},{"id":"wiki/Driving-Skill-Road-Traffic-simple-(Simple-track).md","title":" Easy Road Network ","content":"# Easy Road Network  Author : Patrick Taillandier  Model using shapefiles to create roads using shapefiles with people driving on these roads. The model take into account the number of lanes of the roads.  Code of the model :       model RoadTrafficSimple  global {  file shape_file_roads  <- file( ../includes/RoadCircleLanes.shp ) ;  file shape_file_bounds <- file( ../includes/BoundsLaneRoad.shp ) ;  geometry shape <- envelope(shape_file_bounds);  graph the_graph;   list roadsList of: road ;     init {    create road from: shape_file_roads with: [nbLanes::int(read(lanes))] {   geom_visu <- shape + nbLanes;  }  the_graph <- as_edge_graph(road); }     reflex createPeople when: cycle mod 20 = 0 and cycle < 400{  roadsList <- (road as list);    create people number: 1 {    speed <-  (2.0 + 2 * length(people as list)) ;   currentRoad <- first (roadsList);   source <- first((currentRoad.shape).points);   location <- source;    target <- last((currentRoad.shape).points);   living_space <- 10.0;   tolerance <- 0.1;   lanes_attribute <- nbLanes;   obstacle_species <- [species(self)];   }   }    }    species road  {   int nbLanes;   geometry geom_visu;  aspect base {     draw geom_visu color: #black ;  }  }  species people skills: [driving]{   float speed;   rgb color <- rgb(rnd(255),rnd(255),rnd(255)) ;   point target <- nil ;   point source <- nil;  road currentRoad <- nil;  reflex move when: target != nil {   do goto_driving target: target on: the_graph speed: speed ;    switch target {     match location {     currentRoad <- (roadsList select (each != currentRoad)) with_min_of (each distance_to self);     source <- location;     list rls <- (currentRoad.shape).points;     target <- first (rls) = source ? last(rls):first(rls);    }   }  }  aspect base {  draw circle(10) color: color; } }   experiment Simple type: gui {  parameter  Shapefile for the roads:  var: shape_file_roads category:  GIS  ;  parameter  Shapefile for the bounds:  var: shape_file_bounds category:  GIS  ;  output {  display city_display {   species road aspect: base ;   species people aspect: base;  } } }       ","url":"wiki/Driving-Skill-Road-Traffic-simple-(Simple-track).md"},{"id":"wiki/Graphs-3D-Graph.md","title":" 3D Graph","content":"# 3D Graph  Author : Arnaud Grignard  Model using a 3D Graph and updating it at each step according to the location and the degree of each sphere. An arc is created between two adjacent spheres. Two different experiments are proposed : one with a dynamic size for the spheres according to their degree, one simpler with no update of the size.  Code of the model :       model graph3D  global {  int number_of_agents parameter:  Number of Agents  min: 1 <- 200 category:  Initialization ;  int width_and_height_of_environment parameter:  Dimensions  min: 100 <- 500 category:  Initialization ;  //Distance to know if a sphere is adjacent or not with an other int distance parameter:  distance   min: 1 <- 100;   int degreeMax <- 1; geometry shape <- cube(width_and_height_of_environment);   graph my_graph; init {    //creation of the node agent ie the spheres with a random location in the environment  create node_agent number: number_of_agents {   location <- { rnd(width_and_height_of_environment), rnd(width_and_height_of_environment), rnd(width_and_height_of_environment) };  }    do degreeMax_computation;    ask node_agent {   do compute_degree;  } }  reflex updateDegreeMax {  do degreeMax_computation; }  action degreeMax_computation {  my_graph <- node_agent as_distance_graph(distance);  degreeMax <- 1;  ask node_agent {   if ((my_graph) degree_of (self) > degreeMax) {    degreeMax <- (my_graph) degree_of (self);   }  } } }   species node_agent skills: [moving3D] {  int degree;  float radius;  rgb color ;  float speed <- 5.0;  reflex move {   //make the agent move randomly   do wander;   //compute the degree of the agent   do compute_degree;  }  action compute_degree {  degree <- my_graph = nil ? 0 : (my_graph) degree_of (self);  radius <- ((((degree + 1) ^ 1.4) / (degreeMax))) * 5;  color <- hsb(0.66,degree / (degreeMax + 1), 0.5); }  aspect base {  draw sphere(10) color:°black; }  aspect dynamic {  draw sphere(radius) color: color; }   }  experiment Display type: gui {  output {   display WanderingSphere type: opengl {     species node_agent aspect: dynamic;    graphics  edges  {     //Creation of the edges of adjacence     if (my_graph != nil) {      loop eg over: my_graph.edges {       geometry edge_geom <- geometry(eg);       float val <- 255 * edge_geom.perimeter / distance;        draw line(edge_geom.points, 0.5)  color: rgb(val,val,val);      }     }    }  } } }   experiment SimpleDisplay type: gui {  output {   display WanderingSphere type: opengl {     species node_agent aspect: base;    graphics  edges  {     if (my_graph != nil) {      loop eg over: my_graph.edges {       geometry edge_geom <- geometry(eg);       float val <- 255 * edge_geom.perimeter / distance;        draw line(edge_geom.points) color:°black;      }     }    }  } } }      ","url":"wiki/Graphs-3D-Graph.md"},{"id":"wiki/Graphs-Classic-Graph-Generation.md","title":" Graph Generation","content":"# Graph Generation  Author : Patrick Taillandier  Model which shows how to create three kind of graphs : a scale-free graph, a small-world graph, a complete graph and a complete graph with a radius.  Code of the model :       model classicgraphgeneration  global {  graph the_graph ;  string graph_type <-  small-world ;  int nb_nodes <- 500;  float p <- 0.0;  int k <- 4;  int m <- 4;  int radius <- 20;  init {  switch graph_type {   match scale-free {    the_graph <- generate_barabasi_albert(node_agent, edge_agent, nb_nodes,m, true);    }   match small-world {    the_graph <- generate_watts_strogatz(node_agent, edge_agent, nb_nodes, p, k, true);    }   match complete {    the_graph <- generate_complete_graph(node_agent, edge_agent, nb_nodes,true);    }   match complete-with-radius {    the_graph <- generate_complete_graph(node_agent, edge_agent, nb_nodes, radius,true);    }    }  write the_graph;  write Edges : +length(the_graph.edges);  write Nodes : +length(the_graph.vertices); }   }  species edge_agent {  aspect default {    draw shape color: #black;  } }  species node_agent {  aspect default {    draw circle(1) color: #red;  } }  experiment loadgraph type: gui {  parameter  Graph type  var: graph_type among: [  scale-free ,  small-world ,  complete ];  parameter  Number of nodes  var: nb_nodes min: 5 ;  parameter  Probability to rewire an edge (beta)  var: p min: 0.0 max: 1.0 category:  small-world ;  parameter  Base degree of each node. k must be even  var: k min: 2 max: 10 category:  small-world ;  parameter  Number of edges added per novel node  var: m min: 1 max: 10 category:  scale-free ;  output {  display map type: opengl{   species edge_agent ;   species node_agent ;  } } }      ","url":"wiki/Graphs-Classic-Graph-Generation.md"},{"id":"wiki/Graphs-Graph-Building-From-Agents.md","title":" Graph Generation using Agents","content":"# Graph Generation using Agents  Author : Patrick Taillandier  Model which shows how to create a graph using agents of a species as vertices. Two kinds of generations are presented : one where the distance taken into account to link two vertices by an edge, an other where the intersections of two vertices joins these vertices by an edge.  Code of the model :       model graphbuilding  global {  graph<geometry, geometry> the_graph ;  string graph_builing_type <-  distance ;  float distance <- 20.0;  float tolerance <- 0.0;  init {   create dummy_agent number: 30;    switch graph_builing_type {    match  distance  {     the_graph <- as_distance_graph(dummy_agent, distance);     }    match  intersection  {     the_graph <- as_intersection_graph(dummy_agent, tolerance);     }    }   write  nb vertices:   + length(the_graph.vertices);   write  nb edges:   + length(the_graph.edges);  }  }  species dummy_agent {  geometry shape <- square (5);  aspect default {    draw shape color: #red;  } }  experiment loadgraph type: gui {  parameter  Method to build the graph  var: graph_builing_type among: [  distance ,  intersection ];  parameter  Tolerance  var: tolerance min: 0.0 max: 2.0 category:  Intersection ;  parameter  Distance  var: distance min: 1.0 max: 50.0 category:  Distance ;  output {   display map {    species dummy_agent ;    graphics  the graph  {     loop edge over: the_graph.edges {      draw edge color: #blue;     }    }   }  } }     ","url":"wiki/Graphs-Graph-Building-From-Agents.md"},{"id":"wiki/Graphs-Graph-Loading-Layout.md","title":" Graph from DGS File and Layout Changed","content":"# Graph from DGS File and Layout Changed  Author : Patrick Taillandier  Model which shows how to load a graph from a DGS File, and change is layout.  Code of the model :       model graphloadinglayout  global {  graph the_graph ;  string barabasi_file <-  ../includes/ProteinSimple.dgs ;  geometry shape <- rectangle(500,500);  string layout_type <-  forcedirected ;  int layout_time <- 1000;  //The operator load_graph_from_file generates the graph from the file, and chose the vertices as agents of node_agent  //species, and edges as edge_agent agents init {  the_graph <- load_graph_from_file(barabasi_file, node_agent, edge_agent); }  //In case the layout type is forcedirected or random, the reflex will change at each step the layout of the graph reflex layout_graph {  the_graph <- layout(the_graph, layout_type, layout_time); } }   species edge_agent {  aspect default {    draw shape color: #black;  } }  species node_agent {  aspect default {    draw circle(2) color: #red;  } }  experiment loadgraph type: gui {  parameter  Layout type  var: layout_type among: [  forcedirected ,  random ,  radialtree ,  circle ];  parameter  layout time  var: layout_time min: 1 max: 100000;  output {   display map type: opengl{    species edge_agent ;    species node_agent ;   }  } }     ","url":"wiki/Graphs-Graph-Loading-Layout.md"},{"id":"wiki/Graphs-Graph-Operators.md","title":" Graph Operators","content":"# Graph Operators  Author : Patrick Taillandier  Model to show how to use the different existing operators for the graph species  Code of the model :       model graphoperators  global {  graph<geometry,geometry> the_graph;  list cliques;  init {   create people number: 50;   //creation of the graph: all vertices that are at distance <= 20 are connected  the_graph <- as_distance_graph(people, 20);    //compute the betweenness_centrality of each vertice  map<people,float> bc <- map<people, float>(betweenness_centrality(the_graph));  float max_centrality <- max(bc.values);  float min_centrality <- min(bc.values);  ask people {   centrality <- (bc[self] - min_centrality) / (max_centrality - min_centrality);   centrality_color <- rgb(255, int(255 * (1 - centrality)), int(255 * (1 - centrality)));  }  write mean vertice degree:  + mean(the_graph.vertices collect (the_graph degree_of each));  write nb_cycles:  + nb_cycles(the_graph);  write alpha_index:  + alpha_index(the_graph);  write beta_index:  + beta_index(the_graph);  write gamma_index:  + gamma_index(the_graph);  write connectivity_index:  + connectivity_index(the_graph);  write connected_components_of:  + length(connected_components_of(the_graph));    write connected_components_of:  + length(connected_components_of(the_graph));    write maximal_cliques_of: + (maximal_cliques_of(the_graph) collect (length(each)));  write biggest_cliques_of: + (biggest_cliques_of(the_graph) collect (length(each))); } }   species people {  float centrality;  rgb centrality_color;  aspect centrality{   draw circle(1) color: centrality_color;  } }   experiment graphoperators type: gui {  output {    display map background:#lightgray{   graphics edges {    loop edge over: the_graph.edges {     draw edge color: #black;    }     }     species people aspect: centrality;  } } }      ","url":"wiki/Graphs-Graph-Operators.md"},{"id":"wiki/Graphs-Hand-Made-Graph.md","title":" Hand Made Graph","content":"# Hand Made Graph  Author : Patrick Taillandier  Model to show how to build a graph from scratch using three ways : by putting a list of edges as parameter of as_edge_graph, by adding a node or an edge manually using facet to or by changing the graph itself after adding a node or an edge. The experiment has two displays : one for the first graph created from the list of edges, an other for the graph creating by adding the nodes and edges manually using add operator.  Code of the model :       @no_warning model handMadeGraph  global {  graph<geometry, geometry> the_graph1 ;  graph<geometry, geometry> the_graph2;  init {  the_graph1 <- as_edge_graph([edge({10,5}, {20,3}), edge({10,5}, {30,30}),edge({30,30}, {80,35}),edge({80,35}, {40,60}),edge({80,35}, {10,5}), node ({50,50})]);     the_graph2 <- graph<geometry, geometry>([]);  //first way to add nodes and edges  the_graph2 << node({50,50}) ;  the_graph2 << edge({10,10},{90,50});    //second way to add nodes and edges  the_graph2 <- the_graph2 add_node {10,40} ;  the_graph2 <- the_graph2 add_edge ({35,50}:: {50,50}) ; }   }  species edge_agent {  aspect default {    draw shape color: #black;  } }  species node_agent {  aspect default {    draw circle(1) color: #red;  } }  experiment create_graph type: gui {  output {  display graph1 type: opengl{   graphics the graph 1 {    loop e over: the_graph1.edges {     draw e color: °blue;     }    loop n over: the_graph1.vertices {     draw circle(2) at: point(n) color: °blue;     }   }  }  display graph2 type: opengl{   graphics the graph 2 {    loop e over: the_graph2.edges {     draw e color: °red;     }    loop n over: the_graph2.vertices {     draw circle(2) at: point(n) color: °red;     }   }  } } }      ","url":"wiki/Graphs-Hand-Made-Graph.md"},{"id":"wiki/Graphs-Multigraph.md","title":" Multigraph","content":"# Multigraph  Author : Patrick Taillandier  This model shows how to build a graph on which people agents will move with GIS Shapefile, but also to generate an other graph representing the friendship between the people agents, people agents trying to be closer spatially to each other  Code of the model :       model multigraph  global {  file shape_file_in <- file( ../includes/road.shp ) ;  file shape_file_bounds <- file( ../includes/bounds.shp ) ;  geometry shape <- envelope(shape_file_bounds);  //spatial graph representing the road network graph road_graph;   //social graph (not spatial) representing the frienship links between people graph friendship_graph <- graph([]);  init {  create road from: shape_file_in;    //creation of th road graph from the road agents  road_graph <- as_edge_graph(road);    //creation of 50 people agent, and add each people agent as a node in the friendship graph  create people number: 50 {   add node(self) to: friendship_graph;  }    //creation of 50 friendship link between people agents  loop times: 50 {   people p1 <- one_of(people);   people p2 <- one_of(list(people) - p1);   create friendship_link  {    add edge (p1, p2, self) to: friendship_graph;    shape <- link(p1,p2);   }  } } }   species people skills: [moving]{  point location <- any_location_in(one_of(road));  people target_people <- one_of(people);  point target <- target_people.location;  float size <- 3.0;  //action that make recompute the size of the agents as the distance between it and its target people in the friendship graph (the farthest, the biggest) action updateSize {  path friendship_path <- path_between(friendship_graph,self,target_people);  if (friendship_path != nil) {   size <-max([2,length( friendship_path.edges)]) as float;  } }  //the agent moves toward its target, when reaching it, it chooses another target as the location of one of the people agent reflex movement {  if (location distance_to target < 5.0) {   target_people <- one_of(people);   target <- target_people.location;   do updateSize;  }  do goto on:road_graph target:target speed:1 + rnd(2); } aspect default {  draw circle(size) color: #red; }  }   species friendship_link {  aspect default {  draw shape color: #blue; } }   species road  {  aspect default {   draw shape color:#black ;  } }  experiment multigraph type: gui {  output {   display friendship type: opengl{    species road ;    species friendship_link ;    species people;   }  } }     ","url":"wiki/Graphs-Multigraph.md"},{"id":"wiki/Graphs-Shortest-paths.md","title":" ShortestPath","content":"# ShortestPath  Author : Patrick Taillandier  This model shows how get the shortest path from one point to another on a graph. The experiment proposes two displays : one to show the shortest path, an other to show the first k shortest paths.  Code of the model :       model ShortestPath  global {  file shape_file_in <- file( ../includes/road.shp ) ;  file shape_file_bounds <- file( ../includes/bounds.shp ) ;  geometry shape <- envelope(shape_file_bounds);  graph road_graph;   point source;  point target;  path shortest_path;  list k_shortest_paths;  int k <- 3;   list colors <- [#red,#green,#blue,#pink,#cyan,#magenta,#yellow];  bool save_shortest_paths <- false;  bool load_shortest_paths <- false;  string shortest_paths_file <- ../includes/shortest_paths.csv;  init {  create road from: shape_file_in;  road_graph <- as_edge_graph(road);    //computes all the shortest paths, puts them in a matrix, then saves the matrix in a file  if save_shortest_paths {   matrix ssp <- all_pairs_shortest_path(road_graph);   write Matrix of all shortest paths:  + ssp;   save ssp type:text to:shortest_paths_file;     //loads the file of the shortest paths as a matrix and uses it to initialize all the shortest paths of the graph  } else if load_shortest_paths {   road_graph <- road_graph load_shortest_paths matrix(file(shortest_paths_file));  } }  reflex compute_shortest_paths {  source <- point(one_of(road_graph.vertices));  target <- point(one_of(road_graph.vertices));  if (source != target) {   shortest_path <- path_between (road_graph, source,target);   k_shortest_paths <- list<path>(paths_between(road_graph,source::target,k));   } } }   species road  {  aspect base {   draw shape color: #black ;  }  }  experiment ShortestPath type: gui {  parameter  number of shortest paths (k)  var: k min: 1 max: 7;  parameter  Computed all the shortest paths and save the results  var: save_shortest_paths;  parameter  Load the shortest paths from the file  var: load_shortest_paths;  output {  display map_shortest_path {   species road aspect: base;   graphics shortest path {    if (shortest_path != nil) {     draw circle(5) at: source color: #green;     draw circle(5) at: target color: #cyan;     draw (shortest_path.shape + 2.0) color: #magenta;    }   }  }  display map_k_shortest_paths {   species road aspect: base;   graphics k shortest paths {    if (shortest_path != nil) {     draw circle(5) at: source color: #green;     draw circle(5) at: target color: #cyan;     loop i from: 0 to: length(k_shortest_paths) - 1{      draw ((k_shortest_paths[i]).shape + 2.0) color: colors[i];     }    }   }  } } }      ","url":"wiki/Graphs-Shortest-paths.md"},{"id":"wiki/Init-Action-Init-Action.md","title":" InitAction","content":"# InitAction  Author : Alexis Drogoul  This simple example shows how to use the init callback action to build a simulation with some parameters, without declaring them as parameters  Code of the model :       model InitAction  global {  int agent_number <- 100;  rgb agent_color <- #red;  init {  create my_agents number: agent_number; } }   species my_agents {  aspect default {   draw square(5) color: agent_color;  } }  experiment InitAction type: gui {  action _init_ {  map<string, int> params <- user_input([Number of agents::100, Color::#red, 2D::true]);  create InitAction_model with: [agent_number::params[Number of agents], agent_color::rgb(params[Color])]; }  output {  display Simple {   species my_agents;  } }   }      ","url":"wiki/Init-Action-Init-Action.md"},{"id":"wiki/Map-comparison-Raster-Map-Comparison.md","title":" Raster Map Comparison","content":"# Raster Map Comparison  Author : Patrick Taillandier  This model shows how to use different comparators to know the accuracy of a prediction model. Four comparators are used : - kappa, comparing the map observed and the map simulation ; kappa simulation comparing the initial map, the map observed and the map simulation; - fuzzy kappa, comparing the map observed and the map simulation but being more permissive by using fuzzy logic; - fuzzy kappa simulation, comparing the map observed, the map simulation and the map initial but being more permissive by using fuzzy logic  Code of the model :       model mapcomparison  global {  list categories <- [type 1, type 2, type 3, type 4];  map<string,rgb> color_cat <- [type 1::#blue, type 2::#green, type 3::#yellow, type 4::#red];  matrix fuzzy_categories;  matrix fuzzy_transitions;  list nb_per_cat_obs;  list nb_per_cat_sim;  init {  //Initialize randomly the category of each cell  ask shuffle(cell) {   string neigh_cat <-one_of(neighbours).cat_observed;   cat_init <- neigh_cat in categories ? neigh_cat : one_of(categories);   color_init <- color_cat[cat_init];  }    //Initialize the category observed and the cat attributes of the cells according to probability :   // 60% of cases, the category observed will be the same than the category initialized  //60% of cases, the category will be the same than the category observed  ask cell {   cat_observed <- flip(0.6) ?  cat_init : one_of(categories);   cat <- flip(0.6) ?  cat_observed : one_of(categories);   color <- color_cat[cat];   color_obs <- color_cat[cat_observed];  }  fuzzy_categories <- 0.0 as_matrix {length(categories),length(categories)};  loop i from: 0 to: length(categories) - 1 {   fuzzy_categories[i,i] <- 1.0;  }  fuzzy_transitions <- 0.0 as_matrix {length(categories)*length(categories),length(categories)*length(categories)};  loop i from: 0 to: (length(categories) * length(categories)) - 1 {   fuzzy_transitions[i,i] <- 1.0;   }  list<float> similarity_per_agents ;  write kappa(map observed, map simulation, categories):  + kappa( cell collect (each.cat_observed),cell collect (each.cat),categories);  write kappa simulation(map init, map observed, map simulation,categories):  + kappa_sim( cell collect (each.cat_init), cell collect (each.cat_observed),cell collect (each.cat),categories);  using topology(cell) {   write fuzzy kappa(map observed, map simulation,categories):  + fuzzy_kappa(list(cell), cell collect (each.cat_observed),cell collect (each.cat), similarity_per_agents,categories,fuzzy_categories, 10);   write fuzzy kappa sim(map init, map observed, map simulation,categories):  + fuzzy_kappa_sim(list(cell), cell collect (each.cat_init), cell collect (each.cat_observed),cell collect (each.cat), similarity_per_agents,categories,fuzzy_transitions, 10);  }  loop i from: 0 to: length(cell) - 1 {   int val <- int(255 * similarity_per_agents[i]);   ask cell[i] {color_fuzzy <- rgb(val, val, val);}     }  loop c over: categories {   nb_per_cat_obs << cell count (each.cat_observed = c);   nb_per_cat_sim << cell count (each.cat = c);   }  write percent_absolute_deviation :  + percent_absolute_deviation(nb_per_cat_obs,nb_per_cat_sim) + %;   }   }  grid cell width: 50 height: 50 {  string cat_init;  string cat_observed;  string cat ;  rgb color;  rgb color_init;  rgb color_obs;  rgb color_fuzzy <- #white;  list neighbours <- self neighbors_at 1;  aspect fuzzy_sim {  draw shape color:color_fuzzy border: color_fuzzy; } aspect init {  draw shape color:color_init border: color_init; } aspect observed {  draw shape color:color_obs border: color_obs; } }   experiment mapcomparison type: gui {  output {   display map_sim type: opengl{    grid cell;   }   display map_observed type: opengl{    species cell aspect: observed refresh: false;   }   display map_init type: opengl{    species cell aspect: init refresh: false;   }   display map_fuzzy type: opengl{    species cell aspect: fuzzy_sim ;   }  } }      ","url":"wiki/Map-comparison-Raster-Map-Comparison.md"},{"id":"wiki/Map-comparison-Vector-Map-Comparison.md","title":" Vector Map Comparison","content":"# Vector Map Comparison  Author : Patrick Taillandier  This model shows how to use different comparators to know the accuracy of a prediction model. Four comparators are used : - kappa, comparing the map observed and the map simulation ; kappa simulation comparing the initial map, the map observed and the map simulation; - fuzzy kappa, comparing the map observed and the map simulation but being more permissive by using fuzzy logic; - fuzzy kappa simulation, comparing the map observed, the map simulation and the map initial but being more permissive by using fuzzy logic For each comparator, two comparisons are made : one without taking into account the weights of an area, just computing with each area having the same importance, and an other using weights related to the area of the region  Code of the model :       model mapcomparison  global {  list categories ;  map<string,rgb> color_cat ;  matrix fuzzy_categories;  matrix fuzzy_transitions;  list nb_per_cat_obs;  list nb_per_cat_sim;  file data <- file(../includes/CLC00_06.shp);  geometry shape <- envelope(data);   init {  create areaclc from: data with: [init_cover::string(read(CODE_00)),obs_cover::string(read(CODE_06))] ;  ask areaclc {   if (not (init_cover in categories)) {categories << init_cover; }   if (not (obs_cover in categories)) {categories << obs_cover;}     }  loop cat over: categories {   color_cat[cat] <- rgb(rnd(255),rnd(255),rnd(255));  }  ask areaclc {   sim_cover <- flip(0.7) ? obs_cover : one_of (categories);  }    fuzzy_categories <- 0.0 as_matrix {length(categories),length(categories)};  loop i from: 0 to: length(categories) - 1 {   fuzzy_categories[i,i] <- 1.0;  }  fuzzy_transitions <- 0.0 as_matrix {length(categories)*length(categories),length(categories)*length(categories)};  loop i from: 0 to: (length(categories) * length(categories)) - 1 {   fuzzy_transitions[i,i] <- 1.0;   }  list<float> similarity_per_agents ;  write kappa(map observed, map simulation, categories):  + kappa( areaclc collect (each.obs_cover),areaclc collect (each.sim_cover),categories);  write kappa(map observed, map simulation,categories, weights):  + kappa( areaclc collect (each.obs_cover),areaclc collect (each.sim_cover),categories,areaclc collect (each.shape.area));    write kappa simulation(map init, map observed, map simulation, categories):  + kappa_sim( areaclc collect (each.init_cover), areaclc collect (each.obs_cover),areaclc collect (each.sim_cover),categories);  write kappa simulation(map init, map observed, map simulation, categories, weights):  + kappa_sim( areaclc collect (each.init_cover), areaclc collect (each.obs_cover),areaclc collect (each.sim_cover),categories,areaclc collect (each.shape.area));    write fuzzy kappa(map observed, map simulation,categories):  + fuzzy_kappa(areaclc, areaclc collect (each.obs_cover),areaclc collect (each.sim_cover), similarity_per_agents,categories,fuzzy_categories, 3000);  write fuzzy kappa(map observed, map simulation,categories,weights):  + fuzzy_kappa(areaclc, areaclc collect (each.obs_cover),areaclc collect (each.sim_cover), similarity_per_agents,categories,fuzzy_categories, 3000,areaclc collect (each.shape.area));    write fuzzy kappa sim(map init, map observed, map simulation,categories):  + fuzzy_kappa_sim(areaclc, areaclc collect (each.init_cover), areaclc collect (each.obs_cover),areaclc collect (each.sim_cover), similarity_per_agents,categories,fuzzy_transitions, 3000);  write fuzzy kappa sim(map init, map observed, map simulation,categories,weights):  + fuzzy_kappa_sim(areaclc, areaclc collect (each.init_cover), areaclc collect (each.obs_cover),areaclc collect (each.sim_cover), similarity_per_agents,categories,fuzzy_transitions, 3000,areaclc collect (each.shape.area));    loop i from: 0 to: length(areaclc) - 1 {   int val <- int(255 * similarity_per_agents[i]);   ask areaclc[i] {color_fuzzy <- rgb(val, val, val);}     }  loop c over: categories {   list<areaclc> area_c <- areaclc where (each.obs_cover = c);   list<float> area_shape_c <- area_c collect (each.shape.area);   nb_per_cat_obs << sum(area_shape_c );   nb_per_cat_sim << sum((areaclc where (each.sim_cover = c)) collect (each.shape.area));   }  write percent_absolute_deviation :  + percent_absolute_deviation(nb_per_cat_obs,nb_per_cat_sim) + %;   }   }  species areaclc {  string init_cover;  string obs_cover;  string sim_cover;  rgb color_fuzzy;  aspect init {  draw shape color: color_cat[init_cover]; } aspect simulation {  draw shape color: color_cat[sim_cover]; } aspect observed {  draw shape color: color_cat[obs_cover]; } aspect fuzzy_sim {  draw shape color: color_fuzzy; } }   experiment mapcomparison type: gui {  output {   display map_sim type: opengl{    species areaclc aspect: simulation;   }   display map_observed type: opengl{    species areaclc aspect: observed refresh: false;   }   display map_init type: opengl{    species areaclc aspect: init refresh: false;   }   display map_fuzzy type: opengl background: #pink{    species areaclc aspect: fuzzy_sim ;   }  } }      ","url":"wiki/Map-comparison-Vector-Map-Comparison.md"},{"id":"wiki/Multi-Level-Usage-Balls,-Groups-and-Clouds.md","title":" Balls, Groups and Clouds Multilevel Architecture","content":"# Balls, Groups and Clouds Multilevel Architecture  _Author : _  This model shows how to use multi-level architecture to group agents, and regroup groups. The operators capture is used to capture an agent by a group and change its species as a species contained by the group and defined in the group species section. The operator release is used to release contained agents and change them into an other species. The experiment shows ball moving randomly, and following other balls. When they are close to each other, they generate a group of balls with its own behavior. A group of group agents generate a cloud in the same way. When the number of balls contained inside the group is too high, the group disappears and releases all its balls repulsively.  Code of the model :       model balls_groups_clouds  global {   // Parameters  bool create_group <- true;   bool create_cloud <- false;  // Environment point environment_bounds <- {500, 500};  geometry shape <- rectangle(environment_bounds) ;    //Define a inner environment smaller inside the environment int inner_bounds_x <- (int((environment_bounds.x) / 20))  ; int inner_bounds_y <- (int((environment_bounds.y) / 20))  ; int xmin <- inner_bounds_x ; int ymin <- inner_bounds_y ; int xmax <- int((environment_bounds.x) - inner_bounds_x) ; int ymax <- int((environment_bounds.y) - inner_bounds_y) ;  float MAX_DISTANCE <- environment_bounds.x + environment_bounds.y  ;  //Global variables for ball agents rgb ball_color <- #green;  rgb chaos_ball_color <- #red; float ball_size <- float(3);   float ball_speed <- float(1); float chaos_ball_speed <- 8 * ball_speed;   int ball_number <- 200 min: 2 max: 1000;   geometry ball_shape <- circle (ball_size) ; float ball_separation <- 6 * ball_size;   //Global variables for group agents int group_creation_distance <- int(ball_separation + 1); int min_group_member <- 3; int group_base_speed <- (int(ball_speed * 1.5)); int base_perception_range <- int (environment_bounds.x / 100) min: 1 ;   int creation_frequency <- 3; int update_frequency <- 3; int merge_frequency <- 3; float merge_possibility <- 0.3;  //Global variables for Clouds Agents int cloud_creation_distance <- 30 const: true; int min_cloud_member <- 3 const: true; int cloud_speed <- 3 const: true; int cloud_perception_range <- base_perception_range const: true ;   init {  create ball number: ball_number ;  create group_agents_viewer;  create cloud_agents_viewer; }  //The simulation will try to create group at each frequence cycle reflex create_groups when: ( create_group and ((cycle mod creation_frequency) = 0) ) {  //create a list from all balls following the nearest ball  list<ball> free_balls <- ball where ((each.state) =  follow_nearest_ball ) ;   if (length (free_balls) > 1) {   //Clustering of the balls according to their distance with at least a minimal number of balls in a group   list<list<ball>> satisfying_ball_groups <- (free_balls simple_clustering_by_distance group_creation_distance) where ( (length (each)) > min_group_member ) ;         loop one_group over: satisfying_ball_groups {    create group returns: new_groups;        //Capture by the new groups created of the different balls present in the list one_group    ask (new_groups at 0) as: group {     capture one_group as: ball_in_group;     }   }  } }  //The simulation will try to create clouds at each frequence cycle reflex create_clouds when: (create_cloud and ((cycle mod creation_frequency) = 0) ) {  //A cloud can be created only using group with a number of balls inside greater than 5% of the total ball number  list<group> candidate_groups <- group where (length(each.members) > (0.05 * ball_number) );    //A cloud can be created also only using group which aren t too far away   list<list<group>> satisfying_groups <- (candidate_groups simple_clustering_by_distance cloud_creation_distance) where (length(each) >= min_cloud_member);    //Creation of the different clouds using the groups satisfying both conditions  loop one_group over: satisfying_groups {   create cloud returns: rets;      cloud newCloud <- rets at 0;    ask newCloud as: cloud {    capture one_group as: group_delegation;   }    loop gd over: (newCloud.members) {    ask gd as group_delegation {     migrate ball_in_group target: ball_in_cloud;    }   }       newCloud.color <- ((group_delegation(one_of(newCloud.members))).color).darker;  } } } //Base species with just the skills moving and all built-in variables and operators derivated from it species base skills: [moving] ;  //Species with a specified type of control architecture, here the final state machine FSM species ball parent: base control: fsm  {     float speed <- ball_speed;   rgb color <- ball_color;  int beginning_chaos_time;   int time_in_chaos_state;    //create the ball in a certain way to not make balls intersect each other  init {   bool continue_loop <- true ;    loop while: continue_loop {    point tmp_location <- {(rnd (xmax - xmin)) + xmin, (rnd (ymax - ymin)) + ymin} ;    geometry potential_geom <- ball_shape at_location tmp_location ;         if ( empty ( ball where  ( each intersects potential_geom ) ) )  {     location <- tmp_location ;     continue_loop <- false ;    }   }  }    //Action used to separate the balls and make them repulsive for the other balls of the group  action separation (list<ball> nearby_balls) {   float repulsive_dx <- 0.0 ;   float repulsive_dy <- 0.0 ;   loop nb over: nearby_balls {     float repulsive_distance <- ball_separation - ( location distance_to ( nb).location ) ;    int repulsive_direction <- ((nb).location) towards (location) ;    repulsive_dx <- repulsive_dx + (repulsive_distance * (cos (repulsive_direction))) ;    repulsive_dy <- repulsive_dy + (repulsive_distance * (sin (repulsive_direction))) ;   }   location <- location + {repulsive_dx, repulsive_dy} ;  }    bool in_bounds (point a_point) {   return ( !(a_point.x < xmin) and !(a_point.x > xmax) and !(a_point.y < ymin) and !(a_point.y > ymax) ) ;  }     //State that will make the agent follows the closest ball if it is not in the chaos state anymore  state follow_nearest_ball initial: true {   enter {       color <- ball_color ;    speed <- ball_speed ;   }   list<ball> free_balls <- (list (ball) - self) where ((each.state) =  follow_nearest_ball ) ;   ball nearest_free_ball <- free_balls closest_to self;   if nearest_free_ball != nil {    heading <- self towards (nearest_free_ball) ;     float step_distance <- speed * step ;    float step_x <- step_distance * (cos (heading)) ;    float step_y <- step_distance * (sin (heading)) ;     point tmp_location <- location + {step_x, step_y} ;    if (self in_bounds (tmp_location) ) {     location <- tmp_location ;     do separation (((ball overlapping (shape + ball_separation)) - self));    }   }  }    //Make the ball move randomly during a certain time  state chaos {   enter {    beginning_chaos_time <- int(time) ;    time_in_chaos_state <- 10 + (rnd(10)) ;    color <- chaos_ball_color ;    speed <- chaos_ball_speed ;    heading <- rnd(359) ;   }      float step_distance <- speed * step ;   float step_x <- step_distance * (cos (heading)) ;   float step_y <- step_distance * (sin (heading)) ;   point tmp_location <- location + {step_x, step_y} ;   if (self in_bounds (tmp_location)) {    location <- tmp_location ;    do separation (nearby_balls: (ball overlapping (shape + ball_separation)) - self);   }      transition to: follow_nearest_ball when: time > (beginning_chaos_time + time_in_chaos_state) ;  }    aspect default {   draw ball_shape color: color size: ball_size at:self.location;  } }  //Species representing the group of balls species group parent: base {     rgb color <- rgb ([ rnd(255), rnd(255), rnd(255) ]) ;  geometry shape <- polygon (ball_in_group) buffer  10 ;  float speed update: float(group_base_speed) ;    //Parameter to capture the balls contains in the perception range  float perception_range update: float(base_perception_range + (rnd(5))) ;    ball nearest_free_ball update: ( ball where ( (each.state =  follow_nearest_ball ) ) ) closest_to self ;  group nearest_smaller_group update: ( ( (group as list) - self ) where ( (length (each.members)) < (length (members)) ) ) closest_to self ;  base target update: (self get_nearer_target []) depends_on: [nearest_free_ball, nearest_smaller_group] ;     //Function to return the closest ball or small group of balls that the agent could capture  base get_nearer_target {   if  (nearest_free_ball = nil) and (nearest_smaller_group = nil) {    return nil ;   }      float distance_to_ball <- (nearest_free_ball != nil) ? (self distance_to nearest_free_ball) : MAX_DISTANCE ;   float distance_to_group <- (nearest_smaller_group != nil) ? (self distance_to nearest_smaller_group) : MAX_DISTANCE ;   if (distance_to_ball < distance_to_group) {    return nearest_free_ball ;   }       return nearest_smaller_group ;  }    //Action to use when the group of balls explode  action separate_components {   loop com over: (list (ball_in_group)) {    list<ball_in_group> nearby_balls <-  ((ball_in_group overlapping (com.shape + ball_separation)) - com) where (each in members) ;    float repulsive_dx <- 0.0 ;    float repulsive_dy <- 0.0 ;    loop nb over: nearby_balls {      float repulsive_distance <- ball_separation - ( (ball_in_group (com)).location distance_to nb.location ) ;     int repulsive_direction <- (nb.location) direction_to ((ball_in_group (com)).location) ;     repulsive_dx <- repulsive_dx + (repulsive_distance * (cos (repulsive_direction))) ;     repulsive_dy <- repulsive_dy + (repulsive_distance * (sin (repulsive_direction))) ;    }        (ball_in_group (com)).location <- (ball_in_group (com)).location + {repulsive_dx, repulsive_dy} ;   }  }    //Species that will represent the balls captured by the group agent  species ball_in_group parent: ball topology: topology((world).shape)  {      float my_age <- 1.0 update: my_age + 0.01;       state follow_nearest_ball initial: true { }      state chaos { }      aspect default {    draw circle(my_age) color: ((host as group).color).darker ;   }  }    //Reflex to capture all the balls close to the group agent  reflex capture_nearby_free_balls when: (cycle mod update_frequency) = 0 {   list<ball> nearby_free_balls <- (ball overlapping (shape + perception_range)) where (each.state =  follow_nearest_ball );   if !(empty (nearby_free_balls)) {    capture nearby_free_balls as: ball_in_group;   }  }    //Action to do when the group is disaggregated  action disaggregate {   release members as: ball in: world {     state <-  chaos  ;   }      do die ;  }    //Reflex to merge the group close to the agent when the cycle is in the frequency of merging  reflex merge_nearby_groups when: (cycle mod merge_frequency) = 0 {   if ( (target != nil) and ((species_of (target)) = group) ) {    list<group> nearby_groups <- (group overlapping (shape + perception_range)) - self ;        if target in nearby_groups {     if (rnd(10)) < (merge_possibility * 10) {      list<ball_in_group> target_coms <- list<ball_in_group>(target.members) ;      list<ball> released_balls ;      ask target {       release target_coms as: ball in: world returns: released_coms;       released_balls <- list(released_coms);       do die ;      }      capture released_balls as: ball_in_group;      }    else { ask target as group {do disaggregate ;} }    }   }  }    //Reflex to chase a target agent   reflex chase_target when: (target != nil) {   int direction_to_nearest_ball <- (self towards (target)) ;   float step_distance <- speed * step ;   float dx <- step_distance * (cos (direction_to_nearest_ball)) ;   float dy <- step_distance * (sin (direction_to_nearest_ball)) ;   geometry envelope <- shape.envelope ;   point topleft_point <- (envelope.points) at 0 ;   point bottomright_point <- (envelope.points) at 0 ;      loop p over: envelope.points {    if ( (p.x <= topleft_point.x) and (p.y <= topleft_point.y) ) {     topleft_point <- p ;    }        if ( (p.x >= bottomright_point.x) and (p.y >= bottomright_point.y) ) {     bottomright_point <- p ;    }   }      if ( (dx + topleft_point.x) < 0 ) {    float tmp_dx <- dx + topleft_point.x ;    dx <- dx - tmp_dx ;   } else {    if (dx + bottomright_point.x) > (environment_bounds.x) {     float tmp_dx <- (dx + bottomright_point.x) - environment_bounds.x ;     dx <- dx - tmp_dx ;    }   }      if (dy + topleft_point.y) < 0 {    float tmp_dy <- dy + topleft_point.y ;    dy <- dy - tmp_dy ;   } else {    if (dy + topleft_point.y) > (environment_bounds.y) {     float tmp_dy <- (dy + bottomright_point.y) - (environment_bounds.y) ;     dy <- dy - tmp_dy ;    }   }      loop com over: (list (ball_in_group)) {    (ball_in_group (com)).location <- (ball_in_group (com)).location + {dx, dy} ;   }      shape <- convex_hull((polygon ((list (ball_in_group)) collect (ball_in_group (each)).location)) + 2.0) ;  }  //Reflex to disaggregate the group if it is too important ie the number of balls is greater than 80% of the total ball number  reflex self_disaggregate {   if ( ( length (members) ) > ( 0.8 * (ball_number) ) ) {    do disaggregate ;   }  }    aspect default {   draw shape color: color;  } }  //Species cloud that will be created by an agglomeration of groups. species cloud parent: base {  geometry shape <- convex_hull(polygon(members collect (((group_delegation(each)).shape).location))) update: convex_hull(polygon(members collect (((group_delegation(each)).shape).location)));   rgb color;    //Species contained in the cloud to represent the groups captured by the cloud agent  species group_delegation parent: group topology: (topology(world.shape)) {   geometry shape <- convex_hull( (polygon ( (list (ball_in_cloud)) collect (each.location) )) ) buffer 10 update: convex_hull( (polygon ( (list (ball_in_cloud)) collect (each.location) )) ) buffer  10 ;    reflex capture_nearby_free_balls when: false {   }      reflex merge_nearby_groups when: false {   }      reflex chase_target when: false {   }      reflex self_disaggregate {   }      action move2 (float with_heading, float with_speed) {     loop m over: members {     ask m as ball_in_cloud {      do move2 (with_heading,with_speed);     }    }   }       species ball_in_cloud parent: ball_in_group topology: (world.shape) as topology control: fsm {        action move2 (float with_heading, float with_speed) {     float dx <- cos(with_heading) * with_speed;     float dy <- sin(with_heading) * with_speed;     location <- { ( (location.x) + dx ), ( (location.y) + dy )};    }        aspect default {}       }  }    group target_group;   //The cloud try to look for small groups to capture them  reflex chase_group {   if ( (target_group = nil) or (dead(target_group)) ) {    target_group <- one_of(group);   }      if (target_group != nil) {    int direction_target <- self towards(target_group);        loop m over: members {     ask m as group_delegation {      do move2 with: [ with_heading :: float(direction_target), with_speed :: float(cloud_speed) ];     }        }   }  }    //Operator to know if a cloud can capture a group overlapping the cloud agent.   bool can_capture (group a_group) {      if (shape overlaps a_group.shape) { return true; }      loop gd over: members {    if ( (a_group.shape) overlaps ( ( group_delegation(gd)).shape ) ) { return true; }   }      return false;  }    //Reflex to capture group  reflex capture_group {   if ( (target_group != nil) and !(dead(target_group)) ) {    if (self can_capture [ a_group :: target_group]) {      capture target_group as: group_delegation returns: gds;      ask (gds at 0) as: group_delegation {      migrate ball_in_group target: ball_in_cloud;     }    }   }  }    //Reflex to disaggregate the clouds when they are no more group to capture  reflex disaggregate when: (empty(list(group))) {   loop m over: members {    ask group_delegation(m) as: group_delegation {     migrate ball_in_cloud target: ball_in_group;    }   }      release members as: group in: world returns: r_groups;      loop rg over: r_groups {    ask rg as: group { do disaggregate; }   }      do die;   }      aspect default {   draw shape color: color empty: true;   draw (name +   with   + (string(length(members))) +   groups. ) size: 15 color: color  at: {location.x - 65, location.y};  } }  species group_agents_viewer  {   aspect default {   draw ( Number of groups:   + (string (length (world.agents of_generic_species group)))) at: {(environment_bounds.x)/2 - 210, (environment_bounds.y)/2} color: #blue size: 40  ;  } }  species cloud_agents_viewer  {   aspect default {   draw ( Number of clouds:   + (string (length (list(cloud))))) at: {(environment_bounds.x)/2 - 210, (environment_bounds.y)/2} color: #green size: 40 ;  } }    experiment group_experiment type: gui {  parameter  Create groups?  var: create_group <- true;  parameter  Create clouds?  var: create_cloud <- false;  output {  display  Standard display  {   species ball aspect: default transparency: 0.5 ;      species group aspect: default transparency: 0.5 {    species ball_in_group;   }  }    display  Ball display  {   species ball;  }    display  Group display  {   species group;   species group_agents_viewer;  } } }   experiment cloud_experiment type: gui {  parameter  Create groups?  var: create_group <- true; parameter  Create clouds?  var: create_cloud <- true;   output {  display  Standard display  {   species ball aspect: default transparency: 0.5 ;      species group aspect: default transparency: 0.5 {    species ball_in_group;   }      species cloud aspect: default {    species group_delegation transparency: 0.9 {     species ball_in_cloud;     species ball_in_group;    }   }  }    display  Ball display  {   species ball;  }    display  Group display  {   species group;   species group_agents_viewer;  }   display  Cloud display  {   species cloud;  }    monitor Balls value: length(ball);  monitor Groups value: length(group);  monitor Clouds value: length(cloud); } }       ","url":"wiki/Multi-Level-Usage-Balls,-Groups-and-Clouds.md"},{"id":"wiki/Multi-Level-Usage-Corridor-(Hybrid-vs-ABM).md","title":" Corridor Multi-Level Architecture with Mathematics Model and Agent Based Model","content":"# Corridor Multi-Level Architecture with Mathematics Model and Agent Based Model  _Author : _  This model shows how to use multi-level architecture. Two corridors are presented : one which can capture the pedestrians going through it and computing for them the time before releasing them at the end of the corridor, and an other doing nothing, letting the pedestrians moving by themselves in the corridor.  Code of the model :       model pedestrian_corridor_Hybrid_vs_ABM  global  {  //Parameters of the environment int environment_width <- 200 const: true; int environment_height <- 200 const: true; geometry shape <- rectangle(environment_width, environment_height);    //Parameters of the pedestrian agents rgb pedestrian_green <- #green;  float pedestrian_size <- 1.0; geometry pedestrian_shape <- circle (pedestrian_size) ; float pedestrian_speed <- 2.0;     //Parameters of the corridors rgb corridor_color <- rgb ( blue ); int corridor_width <- 160 depends_on: [environment_width]; int corridor_height <- (int(environment_height * 0.05));  point corridor_location_0 <- {environment_width / 2, environment_height / 4}; geometry corridor_shape_0 <- ( (rectangle ({corridor_width, corridor_height})) at_location corridor_location_0) ;  point corridor_location_1 <- {environment_width / 2, environment_height * 0.75}; geometry corridor_shape_1 <- ( (rectangle ({corridor_width, corridor_height})) at_location corridor_location_1) ;  //Parameters of pedestrian generation int new_pedestian_generate_frequency <- 8; point pedestrian_source_0 <- {0, corridor_location_0.y} ; point pedestrian_source_1 <- {0, corridor_location_1.y} ;       init  {  create corridor number: 2 returns: new_corridors;    ask (new_corridors at 0)   {   do init_corridor corridor_shape: corridor_shape_0 is_hybrid: false;  }   ask (new_corridors at 1)   {   do init_corridor corridor_shape: corridor_shape_1 is_hybrid: true;   } }  //Generation of pedestrians according to the frequency of generation : one for each corridor reflex generate_pedestrians when: ( (cycle mod new_pedestian_generate_frequency) = 0 )  {   create pedestrian number: 2 returns: new_pedestrians;    ask (new_pedestrians at 0)   {   do init_location loc: pedestrian_source_0;  }    ask (new_pedestrians at 1)   {   do init_location loc: pedestrian_source_1;  } }  }   //Species for the pedestrians which can move species pedestrian skills: [moving] {  geometry shape <- circle(pedestrian_size);  rgb color;  corridor last_corridor;  point target_location;  float speed <- pedestrian_speed;  //Initialisation of the target location according to its generation location action init_location (point loc) {  location <- loc;  target_location <- {environment_width, location.y};  heading <- self towards (target_location); }  //Reflex to move the agent to its target location and make it die once it reached its target reflex move_left  {  do move heading: (self) towards (target_location);     if ( (target_location.x - location.x) <= speed )   {   do die;  } }   aspect default  {  draw shape color: color; } }   //Species for the corridor which can capture pedestrians species corridor  {  bool capture_pedestrians;  action init_corridor (geometry corridor_shape, bool is_hybrid)  {  shape <- corridor_shape;  capture_pedestrians <- is_hybrid; }  float max_speed <- pedestrian_speed; float macro_length min: 0.0 <- float(corridor_width); // the length of macro_patch  //Species to model the pedestrian captured by the corridor species captured_pedestrian parent: pedestrian schedules: []  {  float released_time;      aspect default { } }  init  {   create corridor_info_drawer number: 1 with: [target :: self]; } //Reflex to capture the pedestrians overlapping the corridor ie entering the corridor  reflex aggregate when: capture_pedestrians  {  list<pedestrian> tobe_captured_pedestrians <- (pedestrian overlapping shape) where ( (each.last_corridor != self) and ((each.location).x < (self.location).x) ) ;     if !(empty (tobe_captured_pedestrians))   {   capture tobe_captured_pedestrians as: captured_pedestrian returns: cps {     last_corridor <- myself;   }   if !(empty (cps))    {     //Computation of the time when the pedestrians captured will be released according to the speed     // and the time they should make to pass the corridor if they move by themselves     float group_outgoing_time <- time + (corridor_width / (pedestrian_speed) );      loop cp over: cps      {       cp.released_time <- group_outgoing_time;      }   }    } }  //Reflex to release the pedestrians when we consider they were enough time inside the corridor  reflex disaggregate   {  list tobe_released_pedestrians <- members where (time >= (captured_pedestrian (each)).released_time);    if !(empty (tobe_released_pedestrians))   {      release tobe_released_pedestrians as: pedestrian in: world returns: released_pedestrians;      loop rp over: released_pedestrians    {    rp.speed <- pedestrian_speed;    rp.location <- {((environment_width / 2) + (corridor_width / 2)), ((corridor_shape_1).location).y};   }  } }   aspect default  {  draw shape color: corridor_color; } }   species corridor_info_drawer  {  corridor target;  aspect base  {  if target.capture_pedestrians   {   draw  Hybrid model (coupling: ABM and Mathematical Model)  color: #blue size: 7 at: {(target.location).x - 90, (target.location).y - 10};   draw   Aggregated agents:   + string(length(target.members)) color: #black size: 7 at: {(target.location).x - 30, (target.location).y + 2};  }   else   {   draw  Agent-Based Model (ABM)  color: #blue size: 7 at: {(target.location).x - 40, (target.location).y - 10};  } } }   experiment default_experiment type: gui  {  output   {   display default_display    {    species pedestrian;    species corridor transparency: 0.8;    species corridor_info_drawer aspect: base;   }  } }     ","url":"wiki/Multi-Level-Usage-Corridor-(Hybrid-vs-ABM).md"},{"id":"wiki/Multi-Level-Usage-Corridor.md","title":" Corridor Multi-Level Architecture","content":"# Corridor Multi-Level Architecture  _Author : _  This model shows how to use multi-level architecture. A corridor can capture pedestrians going from left to right side if they are inside the corridor. This will result in changing their species from pedestrian to captured_pedestrian which will not be displayed. Once they pass enought time to consider they reach the exit of the corridor, they will be released by the corridor agent as pedestrians, letting them been displayed and going to their target.  Code of the model :       model corridor  global {   //Capture pedestrians parameter to define if wall will capture pedestrians  bool capture_pedestrians <- false parameter:  Capture pedestrians? ;  int environment_size init: 2000; point environment_bounds init: {environment_size, environment_size} ; geometry shape <- rectangle(environment_bounds) ;    //Pedestrians parameters float pedestrian_size init: 1.0; geometry pedestrian_shape <- circle (pedestrian_size); rgb pedestrian_color <- #green;  float pedestrian_speed <- 2.0;   //Wall parameters rgb corridor_wall_color <- #black; int corridor_wall_width <- int(environment_size / 2); int corridor_wall_height <- 200; geometry corridor_wall_0_shape <- rectangle ( {corridor_wall_width, corridor_wall_height} ) at_location {environment_size / 2, corridor_wall_height / 2}; geometry corridor_wall_1_shape <- rectangle ( {corridor_wall_width, corridor_wall_height} ) at_location {environment_size / 2, environment_size - (corridor_wall_height / 2)};  //Corridor parameters rgb corridor_color <- #blue; int corridor_width <- int(environment_size / 2) ; int corridor_height <- environment_size ; point corridor_location <- {environment_size / 2, environment_size / 2} ; geometry corridor_shape <- ( (rectangle ({corridor_width, corridor_height})) at_location corridor_location) - (corridor_wall_0_shape + corridor_wall_1_shape); int corridor_left_bounds <- (int(corridor_location.x - (corridor_width / 2))) ; int corridor_right_bounds <- (int(corridor_location.x + (corridor_width / 2))) ;  //Generation of new pedestrians parameters int new_pedestrian_rate <- 10; int new_pedestian_generate_frequency <- 1; int new_pedestrian_y_distance <- int(environment_size / new_pedestrian_rate);  list<pedestrian> pedestrians  update: list(pedestrian);  float start_time <- machine_time;  init {  create corridor;     create corridor_wall number: 2 returns: corridor_walls;   (corridor_walls at 0).shape <- corridor_wall_0_shape;  (corridor_walls at 1).shape <- corridor_wall_1_shape;   }  //Reflex to generate new pedestrians according to the frequency generation parameter reflex generate_pedestrians when: ((cycle mod new_pedestian_generate_frequency) = 0) {  create pedestrian number: new_pedestrian_rate returns: new_pedestrians;     int loop_times <- 0;  loop p over: new_pedestrians {   int y_coor <- rnd (new_pedestrian_y_distance);   ask p as: pedestrian {    do init_location loc: { 0, (loop_times * new_pedestrian_y_distance) + y_coor };   }   loop_times <- loop_times + 1;  } }   }  //Species pedestrian which will move from one side of the experiments to another and destroy itself once the other side is reached species pedestrian skills: [moving] topology: ( topology (shape - (corridor_wall_0_shape + corridor_wall_1_shape)) ){  geometry shape <-  circle (pedestrian_size);  point initial_location;  point target_location;  int heading;  float speed <- 2.0;  action init_location (point loc) {  location <- loc;  initial_location <- loc;  target_location <- {environment_size, loc.y};  heading <- (self) towards (target_location); }  //Reflex to make the agent move to its target_location reflex move_left {  int update_heading <- (self) towards (target_location);    point current_location <- location;    do move heading: update_heading ;    //Conditions to know if the agent doesn t move, in this case we take care if it is bcause of the walls   if (current_location = location) {   if ( (location.y <= corridor_wall_height) or (location.y >= environment_size - corridor_wall_height) ) {    do move heading: self towards {(environment_size / 2) - (corridor_width / 2), environment_size / 2};    } else {    do move heading: self towards {environment_size / 2, environment_size / 2};    }  }    if( (target_location.x - location.x) <= speed ) {    do die;  } }   aspect my_aspect {  draw shape color: pedestrian_color; } }   //Species which represents the corridor species corridor  {  geometry shape <- corridor_shape;  //Subspecies for the multi-level architectures : captured pedestrians in this case species captured_pedestrian parent: pedestrian schedules: [] {  float released_time;    aspect my_aspect { } }  init {  create corridor_info_drawer number: 1 with: [target :: self]; }  //Reflex to capture pedestrians if the parameter is checked reflex aggregate when: capture_pedestrians {  //List to get all the pedestrians inside the corridor  list<pedestrian> tobe_captured_pedestrians <- (pedestrian overlapping shape);    //If we have pedestrians inside the corridor, we capture them  if !(empty (tobe_captured_pedestrians)) {   capture tobe_captured_pedestrians as: captured_pedestrian returns: cps;      //We update the time during which a pedestrian is captured according to the time the pedestrian   // should need to pass through the corridor if it wasn t captured   loop cp over: cps {    cp.released_time <- time + ( ( corridor_width - ( (((cp).location).x) - ((environment_size / 2) - (corridor_width / 2)) ) ) / pedestrian_speed) ;   }  } }  //Reflex to release pedestrians which have already passed enough time in the corridor // which means if they weren t captured by the corridor, they would have finish passing through it reflex disaggregate  {  list tobe_released_pedestrians <- members where (time >= (captured_pedestrian (each)).released_time);  if !(empty (tobe_released_pedestrians)) {   release tobe_released_pedestrians as: pedestrian in: world {    location <- {((environment_size / 2) + (corridor_width / 2)) + (2 * pedestrian_size), (location).y};   }  } }  aspect my_aspect {  draw shape color: corridor_color; } }   species corridor_wall {  init {   create corridor_wall_info_drawer number: 1 with: [target :: self];  }  aspect  my_aspect {  draw shape color: corridor_wall_color; } }   species corridor_info_drawer {  corridor target;  aspect my_aspect {  draw   Captured pedestrians:   + (string (length (target.members))) color: rgb ( blue ) size: 12°px at: {(target.location).x - 480, (target.location).y};  draw   Pedestrians:   + (string (length (list (pedestrian)))) color: rgb ( blue ) size: 12°px at: {(target.location).x - 135, (target.location).y + 100}; } }   species corridor_wall_info_drawer {  corridor_wall target;  init {  location <- target.location; }  aspect my_aspect {   draw  WALL  color: rgb ( green ) size: 15°px at: {(location).x - 40, (location).y}; } }   experiment corridor_expr type: gui{  output {   display defaut_display {    species pedestrian;    species corridor aspect: my_aspect transparency: 0.8 {    species captured_pedestrian;   }      species corridor_wall aspect: my_aspect transparency: 0.7;   species corridor_info_drawer aspect: my_aspect;   species corridor_wall_info_drawer aspect: my_aspect;  }   display Execution_Time refresh: every(25) {   chart  Simulation step length  type: series background: #white {    data  simulation_step_length_in_mili_second  value: machine_time - start_time color: (rgb ( green ));   }  }     display Captured_Pedestrians refresh: every(25){   chart  Captured Pedestrian  type: series background: #white {    data  captured_pedestrians  value: length ( ((list (corridor)) at 0).members ) color: rgb ( blue );    data  pedestrians  value: length (list (pedestrian)) color: rgb ( white );     }  } } }      ","url":"wiki/Multi-Level-Usage-Corridor.md"},{"id":"wiki/Multi-Level-Usage-Predators,-Preys-and-Shelters.md","title":" Multi-Level Architecture with Preys and Predators","content":"# Multi-Level Architecture with Preys and Predators  _Author : _  This model shows how to use multi-level architecture. In this model, prey and predators agents move randomly in the environment. When a prey agent perceive a predator, it flees trying to go to the closest shelters while the predator agent chases it. The shelters capture the prey agents fleeing, changing them into prey_in_shelter species, that predator can t chase during a certain time. They are released after that time in an invisible state so that they can wander in the  environment without being chase by the predator, but also, for a certain time.  Code of the model :       model preys_predators_shelters  global {   //Parameters for the prey species  rgb prey_color <- #green const: true;  float prey_perception <- 20.0;  float prey_size <- 2.0 const: true;  float prey_speed <- 1.0;  rgb prey_flee_color <- #orange;  float prey_invisible_speed <- 3 * prey_speed;  rgb prey_invisible_color <- #black;  int prey_in_shelter_max_time min: 1 init: 200;  int prey_invisible_max_time min: 1 max: 100 init: 70;   int number_of_preys min: 1 max: 1000 init: 100;  //Parameters for the predator species rgb predator_color <- #red const: true; float predator_perception <- 3.0; float predator_size <- 4.0; float predator_speed <- 1.0; int number_of_predators min: 1 max: 100 init: 30;  geometry shape <- square(400);  rgb predator_in_shelter_color <- #yellow const: true;   //Parameters for the shelter species rgb shelter_color <- #blue const: true;  float shelter_speed <- 1.5 const: true; geometry shelter_shape <- square (50.0); int number_of_shelter <- 2 const: true;   init {  create prey number: number_of_preys;  create predator number: number_of_predators;   create shelter number: number_of_shelter returns: shelters;  (shelters at 0).shape <- shelter_shape at_location {150, 250};  (shelters at 1).shape <- shelter_shape at_location {350, 250}; } } //Species prey which can move using the skill moving and its operators species prey skills: [moving] control: fsm { geometry shape <- square (prey_size); rgb color <- prey_color;  //List of all predators inside the perception of the prey list nearby_predators update: (agents_overlapping (shape + prey_perception)) of_species predator depends_on: shape; int invisible_time min: 1 <- int(time);  shelter nearest_shelter;    //State to make the prey move randomly when there isn t any predator, if so, change the state to flee state move_around initial: true {  enter {   speed <- prey_speed;   color <- prey_color;  }  do wander;     transition to: flee_predator when: !(empty (nearby_predators));  }  //State to make the prey move to the closest shelter to flee from the predator, if no predator are perceived, change the state to move aroung state flee_predator {  enter {   color <- prey_flee_color;   nearest_shelter <- first ( (list (shelter)) sort_by ( each distance_to (self)) );  }  if !(empty (nearby_predators)) { do move heading: (self) towards (nearest_shelter) speed: prey_speed;}    transition to: move_around when: (empty (nearby_predators)); } //State to make the prey invisible during a certain time when it is released by the shelters state invisible {  enter {   speed <- prey_invisible_speed;   color <- prey_invisible_color;   invisible_time <- int(time);   heading <- rnd (359) ;  }  do move;   transition to: move_around when: ( (time - invisible_time) > prey_invisible_max_time ); }  aspect default {  draw  shape color: color; } }   //Species predator which can move using the skill moving species predator skills: [moving] schedules: shuffle (list (predator)) {  geometry shape <- square (predator_size);  prey target_prey update: self choose_target_prey [];  //Change the target prey according to the prey who aren t fleeing if it doesn t have any yet action choose_target_prey type: prey {  if ( (target_prey = nil) or (dead (target_prey) ) ) {   return one_of ( (list (prey)) where (each.state =  move_around ) );  }    return target_prey; } //Reflex to move randomly when no prey are perceived reflex move_around when: (target_prey = nil) { do wander speed: predator_speed; }  //Reflex to make the predator chase a prey reflex chase_prey when: (target_prey != nil) { do move heading: self towards target_prey speed: predator_speed;}  aspect default {  draw shape color: predator_color; }  }    //Species shelter that will capture prey agents species shelter skills: [moving]  frequency: 2 {  geometry shape <- (square (50.0)) at_location {250, 250};  //List of all preys which are being chased and inside the shelter but not captured yet list<prey> chased_preys update: (prey) where ( (each.shape intersects shape) and (each.state =  flee_predator ) );  reflex move_around {  //do wander speed: shelter_speed;  }   //Capture all the chased preys inside the shelter and change their species to prey_in_shelter reflex capture_chased_preys when: !(empty (chased_preys)) {   capture chased_preys as: prey_in_shelter {   state <-  in_shelter ;    shape <- ( triangle (4.0) ) at_location location;  } }  //Release all the prey_in_shelter after a certain time and change their state to invisible after making their species returned to prey reflex release_member_preys {  list<prey_in_shelter> to_be_released <- (prey_in_shelter) where ( (time - each.in_shelter_time) > prey_in_shelter_max_time );     release to_be_released in: world as: prey {    state <-  invisible ;   shape <-  at_location (square (prey_size), self.location);     } }   //Subspecies prey_in_shelter that will represent the prey agents captured by the shelter species prey_in_shelter parent: prey frequency: 2 schedules: ( ( int ( (length (prey_in_shelter)) / 2 ) ) among (list (prey_in_shelter)) ) {  int in_shelter_time <- int(time);    state in_shelter {   do wander speed: shelter_speed;  }    aspect default {   draw  shape color: predator_in_shelter_color;  }  }  aspect default {  draw shape color: shelter_color;  draw  Members:   + (string (length ((members)))) color: rgb ( white ) size: 6 at: {(location).x - 20, (location).y}; } }   experiment default_experiment type: gui {  output {   display default_display type: opengl{    species prey aspect: default;    species predator transparency: 0.5 aspect: default;    species shelter transparency: 0.5 aspect: default {      species prey_in_shelter aspect: default;    }   }  } }     ","url":"wiki/Multi-Level-Usage-Predators,-Preys-and-Shelters.md"},{"id":"wiki/Multi-simulation-Multi-simulation.md","title":" Multi Simulation","content":"# Multi Simulation  Author : Patrick Taillandier  Model to show how to use multi-simulation, i.e. to run several times the same GUI experiment with potentially different parameter sets  Code of the model :       model multi_simulation  global {  //definition of three global variables of which the initial values will be used by the first simulation   int nb_agents <- 10;  float agent_speed <- 1.0;  rgb agent_color <- #green;  init {  create dummy number: nb_agents; } }   //definition a simple species that just move randomly at a given speed species dummy skills: [moving]{  rgb color <- #green;  reflex move {   do wander speed: agent_speed;  }  aspect default {   draw circle(2) color: agent_color border: #black;  } }  experiment main type: gui {  //definition of a minimal duration for each cycle. As the model is very simple, it can run too fast to observe the results, so we slow it down.  float minimum_cycle_duration <- 0.1;  //we define a init block to create new simulations init {  //we create a second simulation (the first simulation is always created by default) with the given parameters  create simulation with: [nb_agents:: 5, agent_speed:: 3.0, agent_color:: #red];   } output {  display map {   //we use an overlay to display the speed of the agents in the simulation   overlay Overlay position: { 5, 5 } size: { 180 #px, 30 #px } background: # black transparency: 0.5 border: #black rounded: true  {  draw agent_speed:  + agent_speed color: # white font: font(SansSerif, 20, #bold) at: { 10°px, 20°px };  }   species dummy;  } } }      ","url":"wiki/Multi-simulation-Multi-simulation.md"},{"id":"wiki/Multicriteria-decision-Multicriteria.md","title":" Multicriteria","content":"# Multicriteria  Author : Patrick Taillandier  This model show how to use different methods of multicriteria analysis to look for the best house. Four methods are used : the Weighted_Means method , the Electre method , the Promethee method  an the Evidence Theory method. Each method uses different criteria with different weights according to the methods used.  Code of the model :       model multicriteria  global {  float weight_standing <- 1.0;  float weight_price <- 1.0;  float weight_distance <- 1.0;  float weight_area <- 1.0;  float p_standing <- 0.5;  float p_price <- 0.5;  float p_distance <- 0.5;  float p_area <- 0.5;  float q_standing <- 0.0;  float q_price <- 0.0;  float q_distance <- 0.0;  float q_area <- 0.0;  float v_standing <- 1.0;  float v_price <- 1.0;  float v_distance <- 1.0;  float v_area <- 1.0;  float s_standing <- 1.0;  float s_price <- 1.0;  float s_distance <- 1.0;  float s_area <- 1.0;  float s1_standing <- 0.0;  float s1_price <- 0.0;  float s1_distance <- 0.0;  float s1_area <- 0.0;  float s2_standing <- 1.0;  float s2_price <- 1.0;  float s2_distance <- 1.0;  float s2_area <- 1.0;  float v1p_standing <- 0.0;  float v1p_price <- 0.0;  float v1p_distance <- 0.0;  float v1p_area <- 0.0;  float v2p_standing <- 1.0;  float v2p_price <- 1.0;  float v2p_distance <- 1.0;  float v2p_area <- 1.0;  float v1c_standing <- 0.0;  float v1c_price <- 0.0;  float v1c_distance <- 0.0;  float v1c_area <- 0.0;  float v2c_standing <- 0.0;  float v2c_price <- 0.0;  float v2c_distance <- 0.0;  float v2c_area <- 0.0;  //Lists that will store the different criteria to use for each method linked with their weights list criteria_WM <- [[name::standing, weight :: weight_standing],[name::price, weight :: weight_price],[name::distance, weight ::weight_distance],[name::area, weight :: weight_area]];  list criteria_Electre <- [[name::standing, weight :: weight_standing, p::p_standing, q::q_standing, v::v_standing, maximize :: true],[name::price, weight :: weight_price, p::p_price, q::q_price, v::v_price,  maximize :: true],[name::distance, weight ::weight_distance, p::p_distance, q::q_distance, v::v_distance,  maximize :: true],[name::area, weight :: weight_area,  p::p_area, q::q_area, v::v_area,  maximize :: true]];  list criteria_Promethee <- [[name::standing, weight :: weight_standing, p::p_standing, q::q_standing, s::s_standing, maximize :: true],[name::price, weight :: weight_price, p::p_price, q::q_price, s::s_price,  maximize :: true],[name::distance, weight ::weight_distance, p::p_distance, q::q_distance, s::s_distance,  maximize :: true],[name::area, weight :: weight_area,  p::p_area, q::q_area, s::s_area,  maximize :: true]];   list criteria_ET <- [[name::standing, s1::s1_standing, s2::s2_standing, v1p::v1p_standing, v2p::v2p_standing, v1c::v1c_standing, v2c::v2c_standing,maximize :: true],[name::price, s1::s1_price, s2::s2_price, v1p::v1p_price, v2p::v2p_price, v1c::v1c_price, v2c::v2c_price,  maximize :: true],[name::distance, s1::s1_distance, s2::s2_distance, v1p::v1p_distance, v2p::v2p_distance, v1c::v1c_distance, v2c::v2c_distance,  maximize :: true],[name::area, s1::s1_area, s2::s2_area, v1p::v1p_area, v2p::v2p_area, v1c::v1c_area, v2c::v2c_area, maximize :: true]];   init {  create people;  geometry free_space <- copy(shape);  free_space <- free_space - 10;  create house number: 15 {   location <- any_location_in (free_space);   free_space <- free_space - (shape + 10);  } }  reflex reset_selected {  ask house {   is_selected_WM <- false;   is_selected_electre <- false;   is_selected_promethee <- false;   is_selected_ET <- false;  }  criteria_WM <- [[name::standing, weight :: weight_standing],[name::price, weight :: weight_price],[name::distance, weight ::weight_distance],[name::area, weight :: weight_area]];   criteria_Electre <- [[name::standing, weight :: weight_standing, p::p_standing, q::q_standing, v::v_standing, maximize :: true],[name::price, weight :: weight_price, p::p_price, q::q_price, v::v_price,  maximize :: true],[name::distance, weight ::weight_distance, p::p_distance, q::q_distance, v::v_distance,  maximize :: true],[name::area, weight :: weight_area,  p::p_area, q::q_area, v::v_area,  maximize :: true]];   criteria_Promethee <- [[name::standing, weight :: weight_standing, p::p_standing, q::q_standing, s::s_standing, maximize :: true],[name::price, weight :: weight_price, p::p_price, q::q_price, s::s_price,  maximize :: true],[name::distance, weight ::weight_distance, p::p_distance, q::q_distance, s::s_distance,  maximize :: true],[name::area, weight :: weight_area,  p::p_area, q::q_area, s::s_area,  maximize :: true]];   criteria_ET <- [[name::standing, s1::s1_standing, s2::s2_standing, v1p::v1p_standing, v2p::v2p_standing, v1c::v1c_standing, v2c::v2c_standing,maximize :: true],[name::price, s1::s1_price, s2::s2_price, v1p::v1p_price, v2p::v2p_price, v1c::v1c_price, v2c::v2c_price,  maximize :: true],[name::distance, s1::s1_distance, s2::s2_distance, v1p::v1p_distance, v2p::v2p_distance, v1c::v1c_distance, v2c::v2c_distance,  maximize :: true],[name::area, s1::s1_area, s2::s2_area, v1p::v1p_area, v2p::v2p_area, v1c::v1c_area, v2c::v2c_area, maximize :: true]]; }   }  species people  {  aspect default {   draw sphere(2) color: °red;  }  reflex choose_house_weighted_means {  list<list> cands <- houses_eval();  int choice <- weighted_means_DM(cands, criteria_WM);  if (choice >= 0) {   ask (house at choice) {is_selected_WM <- true;}  } }  reflex choose_house_promethee {  list<list> cands <- houses_eval();  int choice <- promethee_DM(cands, criteria_Promethee);  if (choice >= 0) {   ask (house at choice) {is_selected_promethee <- true;}  } } reflex choose_house_electre {  list<list> cands <- houses_eval();  int choice <- electre_DM(cands, criteria_Electre, 0.7);  if (choice >= 0) {   ask (house at choice) {is_selected_electre <- true;}  } } reflex choose_house_evidence_theory {  list<list> cands <- houses_eval();  int choice <- evidence_theory_DM(cands, criteria_ET, true);  if (choice >= 0) {   ask (house at choice) {is_selected_ET <- true;}  } }  list<list> houses_eval {  list<list> candidates;  loop bat over: house {   list<float> cand;   add bat.standing / 5 to: cand;   add ((500000 - bat.price) / 500000) to: cand;   add ((100 - (self distance_to bat)) / 100) to: cand;   add (bat.shape.area / 15^2) to: cand;   add cand to: candidates;  }  return candidates; }   }  species house {  bool is_selected_WM <- false;  bool is_selected_electre <- false;  bool is_selected_promethee <- false;  bool is_selected_ET <- false;  geometry shape <- square(5 + rnd(10));  float price <- 100000.0 + rnd (400000);  int standing <- rnd(5);  rgb color <- rgb(255 * (1 - standing/5.0),255 * (1 - standing/5.0),255);  float height <- price / 50000;  aspect weighted_means {   if (is_selected_WM) {    draw shape + 2.0 color: °red;   }   draw shape color: color depth: height;  }  aspect electre_means {   if (is_selected_electre) {    draw shape + 2.0 color: °red;   }   draw shape color: color depth: height;  }  aspect promethee_means {   if (is_selected_promethee) {    draw shape + 2.0 color: °red;   }   draw shape color: color depth: height;  }  aspect evidence_theory_means {   if (is_selected_ET) {    draw shape + 2.0 color: °red;   }   draw shape color: color depth: height;  } }  experiment multicriteria type: gui {  parameter  weight of the standing criterion  var:weight_standing category:  Weight ;  parameter  weight of the price criterion  var:weight_price category:  Weight ;  parameter  weight of the distance criterion  var:weight_distance category:  Weight ;  parameter  weight of the area criterion  var:weight_area category:  Weight ;  parameter  preference threshold of the standing criterion  var:p_standing category:  Preference ;  parameter  preference threshold of the price criterion  var:p_price category:  Preference ;  parameter  preference threshold of the distance criterion  var:p_distance category:  Preference ;  parameter  preference threshold of the area criterion  var:p_area category:  Preference ;  parameter  indifference threshold of the standing criterion  var:q_standing category:  Indifference ;  parameter  indifference threshold of the price criterion  var:q_price category:  Indifference ;  parameter  indifference threshold of the distance criterion  var:q_distance category:  Indifference ;  parameter  indifference threshold of the area criterion  var:q_area category:  Indifference ;  parameter  veto threshold of the standing criterion  var:v_standing category:  Veto ;  parameter  veto threshold of the price criterion  var:v_price category:  Veto ;  parameter  veto threshold of the distance criterion  var:v_distance category:  Veto ;  parameter  veto threshold of the area criterion  var:v_area category:  Veto ;  parameter  max prefence value of the standing criterion  var:v_standing category:  Max preference value ;  parameter  max prefence value of the price criterion  var:v_price category:  Max preference value ;  parameter  max prefence value of the distance criterion  var:v_distance category:  Max preference value ;  parameter  max prefence value of the area criterion  var:v_area category:  Max preference value ;  parameter  min criterion threshold of the standing criterion  var:s1_standing category:  Evidence Theory ;  parameter  min criterion threshold of the price criterion  var:s1_price category:  Evidence Theory ;  parameter  min criterion threshold of the distance criterion  var:s1_distance category:  Evidence Theory ;  parameter  min criterion threshold of the area criterion  var:s1_area category:  Evidence Theory ;  parameter  max criterion threshold of the standing criterion  var:s2_standing category:  Evidence Theory ;  parameter  max criterion threshold of the price criterion  var:s2_price category:  Evidence Theory ;  parameter  max criterion threshold of the distance criterion  var:s2_distance category:  Evidence Theory ;  parameter  max criterion threshold of the area criterion  var:s2_area category: Evidence Theory ;  parameter  min preference of the standing criterion  var:v1p_standing category:  Evidence Theory ;  parameter  min preference of the price criterion  var:v1p_price category:  Evidence Theory ;  parameter  min preference of the distance criterion  var:v1p_distance category:  Evidence Theory ;  parameter  min preference of the area criterion  var:v1p_area category:  Evidence Theory ;  parameter  max preference of the standing criterion  var:v2p_standing category:  Evidence Theory ;  parameter  max preference of the price criterion  var:v2p_price category:  Evidence Theory ;  parameter  max preference of the distance criterion  var:v2p_distance category:  Evidence Theory ;  parameter  max preference of the area criterion  var:v2p_area category:  Evidence Theory ;  parameter  min rejection of the standing criterion  var:v1c_standing category:  Evidence Theory ;  parameter  min rejection of the price criterion  var:v1c_price category:  Evidence Theory ;  parameter  min rejection of the distance criterion  var:v1c_distance category:  Evidence Theory ;  parameter  min rejection of the area criterion  var:v1c_area category:  Evidence Theory ;  parameter  max rejection of the standing criterion  var:v2c_standing category:  Evidence Theory ;  parameter  max rejection of the price criterion  var:v2c_price category:  Evidence Theory ;  parameter  max rejection of the distance criterion  var:v2c_distance category:  Evidence Theory ;  parameter  max rejection of the area criterion  var:v2c_area category:  Evidence Theory ;  output {   display Map_Weighted_Means type: opengl{    species house aspect: weighted_means;    species people;   }   display Map_Electre type: opengl{    species house aspect: electre_means;    species people;   }   display Map_Promethee type: opengl{    species house aspect: promethee_means;    species people;   }   display Map_Evidence_theory type: opengl{    species house aspect: evidence_theory_means;    species people;   }  } }     ","url":"wiki/Multicriteria-decision-Multicriteria.md"},{"id":"wiki/Overlay-Overlay.md","title":" Overlay","content":"# Overlay  Author : Alexis Drogoul and Patrick Taillandier  Model to show how to use overlay layers in a display  Code of the model :       model Overlay  global {  //define the color for each possible type (among  water ,  vegetation  and  building )  map<string,rgb> color_per_type <- [ water ::#blue,  vegetation :: #green,  building :: #pink]; }  //define a simple grid with 10 rows and 10 columns grid cell width: 10 height: 10 {  //each cell has a random type  string type <- one_of(color_per_type.keys);  rgb color <- color_per_type[type]; } experiment overlay type: gui {     output      {  display map   {   //define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.   overlay  Overlay  position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true   {    //for each possible type, we draw a square with the corresponding color and we write the name of the type       float y <- 30#px;       loop type over: color_per_type.keys       {    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;    draw type at: { 40#px, y + 4#px } color: # white font: font( SansSerif , 18, #bold);    y <- y + 25#px;       }   }  //then we display the grid   grid cell lines: #black;     }  } }      ","url":"wiki/Overlay-Overlay.md"},{"id":"wiki/Save-statement-Save_to_CSV.md","title":" Save to CSV","content":"# Save to CSV  Author : Patrick Taillandier  This is a model that shows how to save agents inside a CSV File to reuse it later or to keep it.  Code of the model :      model SavetoCSV  global {  init {   //Create all the agents   create bug number: 50;  }  //Save the agents bug when the cycle is equals to 100  reflex save_bug_attribute when: cycle = 100{   ask bug {    // save the values of the variables name, speed and size to the csv file    save [name,speed, size] to:  ../results/bug.csv  type: csv ;   }   //Pause the model as the data are saved   do pause;  } }  //Species that will be saved species bug skills:[moving]{  float size <- 1.0 + rnd(4) min: 1.0 max: 5.0;  float speed <- 1.0 + rnd(4.0);  reflex update_size {  int nb_neigh <- length(bug at_distance 20.0);  if (nb_neigh > 5) {   size <- size + 1;  } else {   size <- size - 1;  } }   reflex move {  do wander; }  aspect default {  draw circle(size) color: #red; } }   experiment main type: gui {  output {   display map {    species bug;   }  } }     ","url":"wiki/Save-statement-Save_to_CSV.md"},{"id":"wiki/Save-statement-Save_to_asc.md","title":" Save to Ascii","content":"# Save to Ascii  Author : Patrick Taillandier  This is a model that shows how to save a grid inside a ASCII File to reuse it later or to keep it.  Code of the model :       model SavetoAsc  global {  init {    //save grid  grid_value  attribute into the asc file.   save cell to: ../results/grid.asc  type: asc ;  } }  //Grid that will be saved in the ASC File grid cell width: 50 height: 50 {  float grid_value <- self distance_to world.location;  rgb color <- rgb(255 * (1 - grid_value / 50), 0,0); }  experiment main type: gui {  output {   display map {    grid cell lines: #black;   }  } }     ","url":"wiki/Save-statement-Save_to_asc.md"},{"id":"wiki/Save-statement-Save_to_shapefile.md","title":" Save to Shapefile","content":"# Save to Shapefile  Author : Patrick Taillandier  This is a model that shows how to save agents inside a Shapefile to reuse it later or to keep it.  Code of the model :       model Savetoshapefile  global {  init {   geometry free_space <- copy(shape);   //creation of the building agents that will be saved  create building number: 50 {   shape <- square(5.0);   location <- any_location_in (free_space - 5.0);   free_space <- free_space - shape;  }  //save building geometry into the shapefile: add the attribute TYPE which value is set by the type variable of the building agent  save building to:../results/buildings.shp type:shp with:[type::TYPE]; } }   //species that represent the building agents that will be saved species building {  string type <- flip(0.8) ?  residential  :  industrial ;  aspect default {   draw shape color: type =  residential  ? #gray : #pink;  } } experiment main type: gui {  output {   display map {    species building;   }  } }     ","url":"wiki/Save-statement-Save_to_shapefile.md"},{"id":"wiki/Save-statement-Save_to_text.md","title":" Save to Text","content":"# Save to Text  Author : Patrick Taillandier  This is a model that shows how to save agents inside a text file to reuse it later or to keep it.  Code of the model :       model SavetoText  global {  init {   //Create the agents that will be saved in the text file.   create bug number: 50;  }  //Reflex saving the agents every 10 steps.  reflex save_data when: every(10){  //save the following text into the given text file. Note that each time the save statement is used, a new line is added at the end of the file.  save (cycle: + cycle + , mean size:  + mean(bug collect each.size)) to: ../results/data.txt; } //Reflex that will pause the simulation when the number of cycles reach 100. reflex end_simulation when: cycle = 100 {  do pause; } }   //Species bug that will be saved using the skill moving species bug skills:[moving]{  float size <- 1.0 + rnd(4) min: 1.0 max: 5.0;  float speed <- 1.0 + rnd(4.0);  //At each step, the size of the agent is update according to the number of bugs close to the agent reflex update_size {  int nb_neigh <- length(bug at_distance 20.0);  if (nb_neigh > 5) {   size <- size + 1;  } else {   size <- size - 1;  } }    //Make the agent move randomly reflex move {  do wander; }  aspect default {  draw circle(size) color: #red; } }   experiment main type: gui {  output {   display map {    species bug;   }  } }     ","url":"wiki/Save-statement-Save_to_text.md"},{"id":"wiki/Spatial-Operators-Geometry-discretization.md","title":" Discretization of Topology","content":"# Discretization of Topology  Author : Patrick Taillandier  A model which shows how to use the different convert topologies operators : to_square, to_rectangle, points_on, triangulate, voronoi.  Code of the model :       model discretization  global  {  //Geometry that will be used for each display : a circle  geometry init_geom <- circle (35); }  experiment main type: gui {  output {   //Display that will show a circle converted in squares   display decretization_squares {    graphics  init_geom  {draw init_geom color: °black;}    graphics  geoms  transparency: 0.5{     //Convert the initial circle into squares of 5.0      loop g over: to_squares(init_geom, 5.0) {      draw g color: °red;     }     }    }   //Display that will show a circle converted in squares overlapping the shape   display squares_overlapping {    graphics  init_geom  {draw init_geom color: °black;}    graphics  squares  transparency: 0.5{     //Convert the initial circle into rectangles of 5.0 and keep the squares going out of the borders of the circle but still overlapping it     loop g over: to_squares(init_geom,5.0, true) {      draw g color: °red;     }     }    }   //Display that will show a circle converted in squares inside the shape   display squares_inside {    graphics  init_geom  {draw init_geom color: °black;}    graphics  squares  transparency: 0.5{     //Convert the initial circle into squares of 5.0 and remove the squares going out of the borders of the circle     loop g over: to_squares(init_geom, 5.0, false) {      draw g color: °red;     }     }    }   //Display that will show a circle converted in rectangles with a size of 10.0 and 5.0   display decretization_rectangles {    graphics  init_geom  {draw init_geom color: °black;}    graphics  geoms  transparency: 0.5{     loop g over: to_rectangles(init_geom, {10.0,5.0}) {      draw g color: °red;     }     }    }   //Display that will show a circle converted in rectangles forming a grid of 15 cols and 20 rows   display decretization_rectangles_grid {    graphics  init_geom  {draw init_geom color: °black;}    graphics  geoms  transparency: 0.5{     loop g over: to_rectangles(init_geom, 15,20) {      draw g color: °red;     }     }    }   //Display that will show a circle converted in rectangles overlapping the shape   display rectangles_overlapping {    graphics  init_geom  {draw init_geom color: °black;}    graphics  rectangles  transparency: 0.5{     //Convert the initial circle into rectangles of 5.0 and keep the rectangles going out of the borders of the circle but still overlapping it     loop g over:  to_rectangles(init_geom, {10.0,5.0}, true){      draw g color: °red;     }     }    }   //Display that will show a circle converted in rectangles inside the shape   display rectangles_inside {    graphics  init_geom  {draw init_geom color: °black;}    graphics  rectangles  transparency: 0.5{     //Convert the initial circle into rectangles of 5.0 and remove the rectanges going out of the borders of the circle     loop g over: to_rectangles(init_geom, {10.0,5.0}, false) {      draw g color: °red;     }     }    }   //Display that will show a circle triangulated  display triangles {   graphics init_geom {draw init_geom color: °black;}   graphics triangles transparency: 0.5{    loop g over: triangulate(init_geom) {     draw g color: °red;    }   }   }    //Display that will show a circle with points on its perimeter every 10.0  display points_on_contours {   graphics init_geom {draw init_geom color: °black;}   graphics geoms transparency: 0.5{    loop g over: points_on(init_geom,10.0) {     draw circle(2) at: g color: °red;    }    }   }    display voronoi {   //Creates a voronoi diagram from the points given and display them   graphics geoms transparency: 0.5{    loop g over: voronoi([{10,10},{10,10},{80,80},{80,10},{10,80}, {40,40}]) {     draw g color: °red;    }   }   graphics points {    loop pt over: [{10,10},{10,10},{80,80},{80,10},{10,80}, {40,40}] {     draw circle(2) at: pt color: °black;    }   }   } } }      ","url":"wiki/Spatial-Operators-Geometry-discretization.md"},{"id":"wiki/Spatial-Operators-Spatial-Operators-(Examples).md","title":" Spatial Operators","content":"# Spatial Operators  Author : Patrick Taillandier  A model which shows how to use spatial operators like rotated_by, scaled_by and convex_hull  Code of the model :      model example_spatial_operators  global {  // Parameters for the shapefiles  file shape_file_name_init  <- file( ../gis/init.shp ) ;  file shape_file_name_background  <- file( ../gis/background.shp );  //Parameters for the agents   float dying_size min: 100.0  <-10000.0 ;  float crossover_size min: 100.0  <- 1000.0; float minimum_size min: 100.0 <- 500.0;  int time_wthout_co min: 1 <- 7; float speed min: 1.0  <- 10.0;  float crossover_rate min: 0.1  <- 0.95;  float scaling_factor min: 1.001 <- 1.05; float angle_rotation_max min: 0.0 <- 45.0; int nb_partners_max min: 1  <- 1; int max_side_size min: 1 <- 5;   int background_size_side min: 20 max: 100 <- 80 ;  // Environment geometry shape <- envelope(shape_file_name_background);   reflex stop when: empty ( object ) {  do halt;    }    }  species object topology: topology(shape_file_name_init) {  rgb color <- rgb ( [ rnd ( 255 ) , rnd ( 255 ) , rnd ( 255 ) ]);  point location_new_Ag <- nil;  rgb color_new_Ag <- nil;  int nb_last_rep <- 0;  //Reflex making the shape of the agent growing and rotate it randomly reflex evolve {  nb_last_rep <- nb_last_rep + 1;  shape <- shape scaled_by scaling_factor;  shape <- shape rotated_by ((rnd ( 100 * angle_rotation_max))/ 100.0);   }  //Make the agent move, kill it if is area is greater than the dying size or intersecting contours of the world reflex move {  location <- location + { speed * ( 1 - rnd ( 2 ) ) , speed * ( 1 - rnd ( 2 ) ) };  if ( (shape.area > dying_size) or (shape intersects world.shape.contour)) {   do die;   }    }   //Reflex to change the shape of the agent intersects an other agent and create a convex hull of the shape of the new agent resulting in the intersection of the shapes of the agent and an other one reflex crossover when: ( shape.area > crossover_size ) and ( nb_last_rep > time_wthout_co ) {   int nb_partners  <- 0;  list<object> list_people <- shuffle ( object );  loop p over: list_people {   if ( p != self ) and ( nb_partners <= nb_partners_max ) and (rnd ( 100 ) < ( crossover_rate * 100 ) ) and ( (p.shape).area > crossover_size ) and ( p . nb_last_rep > time_wthout_co ) and (shape intersects p.shape) {    nb_partners <- nb_partners + 1;    geometry new_ag <- (shape inter p.shape);    if ( new_ag != nil ) and ( new_ag.area > minimum_size ) {     nb_last_rep <- 0;     ask p {      nb_last_rep <- 0;     }     create object  {      color <- (myself.color + p.color) / 2;      shape <-  convex_hull(new_ag);     }    }   }  }  }  aspect geometry {  draw shape color: color; } }   experiment example_spatial_operators type: gui {  parameter  Path of shapefile to load for the initial agent:  var: shape_file_name_init  category:  GIS specific  ;  parameter  Path of shapefile to load for the background:  var: shape_file_name_background category:  GIS specific ;  parameter  Size (area) from which an agent dies:  var: dying_size min: 100.0  category:  Population ;   parameter  Min size (area) for crossover:  var:crossover_size category:  Population ;  parameter  Minimum size (area) of a agent produced by a crossover:  var:minimum_size category:  Population ;  parameter  Number of steps without crossing-over for an agent:  var:time_wthout_co category:  Population ;  parameter  Agent deplacement speed:  var:speed category:  Population  ;   parameter  Rate of crossover  var:crossover_rate category:  Population ;   parameter  Scaling factor for agent geometry (at each step):  var:scaling_factor category:  Population ;  parameter  Max rotation angle for agent geometry (at each step):  var:angle_rotation_max category: Population ;  parameter  Max number of possible partners for crossing-overs (per step)  var:nb_partners_max category:  Population  ;  parameter  Size max of the initiale side of an agent:  var:max_side_size category:  Population ;   parameter  Size background side:  var: background_size_side category:  Population  ;  output {  display space_display {   graphics background {    draw world.shape color: rgb ([ 255 , 240 , 240 ]);   }   species object aspect: geometry;  } } }      ","url":"wiki/Spatial-Operators-Spatial-Operators-(Examples).md"},{"id":"wiki/Spatial-Operators-Topologies.md","title":" Spatial Operators","content":"# Spatial Operators  Author : Patrick Taillandier  A model which shows how to use spatial operator, allowing the user to change the parameter operator in the experiment to test the different operators and see the results  Code of the model :       model gridfilter  global {  map<string,map<dummy,rgb» theDummies;  map<string,map<cell,rgb» theCells;   string parameter_operator <- closest_to  among:[ closest_to , at_distance , neighbors_at , distance_to , path_to , cluster_distance , cluster_hierarchical ];  init {   //Create the agents  do create_dummy_agents;     //Different actions to test the operators  do test_agents_at_distance;  do test_distance_to;  do test_neighbors_at;  do test_path_to;  do test_simple_clustering_by_distance;  do test_hierarchical_clustering;  do test_agent_closest_to;   }    action test_agent_closest_to {  //It is possible to use the topology of the world (default), the graph or the grid  add [dummy(8)::#yellow] at:closest_to to:theDummies;  add #red at:dummy closest_to (dummy(8)) to:theDummies[closest_to];      add [cell(40)::#yellow] at:closest_to to:theCells;  add #red at:cell closest_to (cell(40)) to:theCells[closest_to]; } action test_agents_at_distance {    //It is possible to use the topology of the world (default), the graph or the grid  ask dummy(8)  {   add [self::#yellow] at:at_distance to:theDummies;   loop a_dummy over: agents_at_distance(30) of_species dummy   {     add #red at:a_dummy to:theDummies[at_distance];   }  }  ask cell(40)  {   add [self::#yellow] at:at_distance to:theCells;   loop a_cell over: agents_at_distance(10) of_species cell   {     add #red at:a_cell to:theCells[at_distance];   }  } }  action test_neighbors_at {    //It is possible to use the topology of the world (default), the graph or the grid  //The operator neighbors_at gives the same results that neighbors_of( an_agent, a_distance )    add [dummy(8)::#yellow] at:neighbors_at to:theDummies;  loop a_dummy over: dummy(8) neighbors_at 30  {    add #red at:a_dummy to:theDummies[neighbors_at];  }  add [cell(40)::#yellow] at:neighbors_at to:theCells;  loop a_cell over: cell(40) neighbors_at 20  {    add #red at:a_cell to:theCells[neighbors_at];  } }  action test_distance_to {    //It is possible to use the topology of the world (default), the graph or the grid  //The operator distance_to gives the same results that the operator topology distance_between[an_agent_A,an_agent_B]  add [dummy(8)::#yellow] at:distance_to to:theDummies;  add #red at:dummy(5) to:theDummies[distance_to];    add [cell(40)::#yellow] at:distance_to to:theCells;  add #red at:cell(27) to:theCells[distance_to]; }  action test_path_to {    //It is possible to use the topology of the world (default), the graph or the grid  //The operator distance_to gives the same results that the operator topology path_between[an_agent_A,an_agent_B]  add [dummy(8)::#yellow] at:path_to to:theDummies;  add #red at:dummy(9) to:theDummies[path_to];    add [cell(40)::#yellow] at:path_to to:theCells;  add #red at:cell(28) to:theCells[path_to]; } action test_simple_clustering_by_distance  {  //Can be used for other topologies by adding using(topology(cell)) for example    list<list<dummy>> clusteredDummies <- list<list<dummy>>(dummy simple_clustering_by_distance 30);  loop a_list over: clusteredDummies  {   rgb colorList <- rgb(rnd(255),rnd(255),rnd(255));   loop a_dummy over: a_list   {    if(length(theDummies[cluster_distance])=0)    {     add map<dummy,rgb>([a_dummy::colorList]) at:cluster_distance to:theDummies;    }    else    {     add colorList at:a_dummy to:theDummies[cluster_distance];    }   }  } } action test_hierarchical_clustering {  //Can be used for other topologies by adding using(topology(cell)) for example  list<list<dummy>> clusteredDummies <- list<list<dummy>>(dummy hierarchical_clustering 10);    loop a_list over: clusteredDummies  {   rgb colorList <- rgb(rnd(255),rnd(255),rnd(255));   loop a_dummy over: a_list   {    if(length(theDummies[cluster_hierarchical])=0)    {     add map<dummy,rgb>([a_dummy::colorList]) at:cluster_hierarchical to:theDummies;    }    else    {     add colorList at:a_dummy to:theDummies[cluster_hierarchical];    }   }  } } action create_dummy_agents {  create dummy with: [location :: {5,5}];  create dummy with: [location :: {8,9}];  create dummy with: [location :: {14,6}];  create dummy with: [location :: {35,55}];  create dummy with: [location :: {25,75}];  create dummy with: [location :: {56,80}];  create dummy with: [location :: {10,70}];  create dummy with: [location :: {80,8}];  create dummy with: [location :: {34,78}];  create dummy with: [location :: {67,32}];  loop i from: 0 to: length(dummy) - 1 {   ask dummy[i] {id <- string(i);}  } }   }  grid cell width: 10 height: 10 neighbors: 4{  rgb color <- #green; }  species dummy {  string id;  aspect default {   draw circle(2) color: #yellow;   draw id size: 6 color: #black;  } } experiment topology_test type: gui {  /** Insert here the definition of the input and output of the model */  parameter  Operator  var: parameter_operator;  output {   display Continuous_Environment    {   graphics cell   {    loop a_key over: theCells[parameter_operator].pairs {     draw a_key.key at:a_key.key.location color: theCells[parameter_operator][a_key.key] ;    }    loop a_cell over: cell-theCells[parameter_operator].keys    {     draw a_cell at:a_cell.location color: #green ;    }        //Display a line between the two chosen cell for the distance_to operator    if(parameter_operator=distance_to)    {     geometry aLine <- line([theCells[parameter_operator].keys[0].location,theCells[parameter_operator].keys[1].location]) +1.2;     draw (aLine) color:#silver;     draw string(distance_to (theCells[parameter_operator].keys[0].location,theCells[parameter_operator].keys[1].location)) at:aLine.location size: 6 color: #silver;     }    else    {     //Display a path between the two chosen cell for the path_to operator     if(parameter_operator=path_to)     {       path aPath <- theCells[parameter_operator].keys[0] path_to theCells[parameter_operator].keys[1].location;       loop eg over: aPath.edges       {        draw (geometry(eg)+1.2) color:#silver;       }     }    }   }   graphics dummy   {    loop a_key over: theDummies[parameter_operator].pairs {     draw circle(2) at:a_key.key.location color: theDummies[parameter_operator][a_key.key] ;     draw a_key.key.id at:a_key.key.location size: 6 color: #black;     }    loop a_dummy over: dummy-theDummies[parameter_operator].keys    {     draw circle(2) at:a_dummy.location color: #grey ;     draw a_dummy.id at:a_dummy.location size: 6 color: #black;     }    //Display a line between the two chosen dummies for the distance_to operator    if(parameter_operator=distance_to)    {     geometry aLine <- line([theDummies[parameter_operator].keys[0].location,theDummies[parameter_operator].keys[1].location]) +1.2;     draw (aLine) color:#pink;     draw string(distance_to (theDummies[parameter_operator].keys[0].location,theDummies[parameter_operator].keys[1].location)) at:aLine.location size: 6 color: #pink;     }    else    {     //Display a path between the two chosen dummies for the path_to operator     if(parameter_operator=path_to)     {       path aPath <- theDummies[parameter_operator].keys[0] path_to theDummies[parameter_operator].keys[1].location;       loop eg over: aPath.edges       {        draw (geometry(eg)+1.2) color:#pink;       }     }    }   }  } } }      ","url":"wiki/Spatial-Operators-Topologies.md"},{"id":"wiki/Spatial-Operators-spatialinterpolation.md","title":" Spatial Interpolation","content":"# Spatial Interpolation  Author : Patrick Taillandier  A model which shows how to use spatial interpolation  Code of the model :       model spatialinterpolation  global {  map<point, float> pts;  float max_val;   float min_val ;  //power parameter int power <- 2;  //cell properties int nb_rows <- 50; int nb_columns <- 50;  init {  //creation of random point for demo puporse  loop times: 50 {   point pt <- any_location_in(world);   pts[pt] <-pt.x ^2 + pt.y ^2;  }    //computation of the min and max values of the points (just use to define the color of the cells).  max_val <- max(pts.values);    min_val <- min(pts.values);     //computation of the value for each cell  map<cell_shape, float> results_shape <- map<cell_shape, float>(IDW(cell_shape, pts, power));    //setting of the value and color of each cell  ask cell_shape {   val <- results_shape[self];   float val_col <- 255 * (val - min_val) / (max_val - min_val);   color <- rgb(val_col,0,0);  }    //same computation, but in this case, we consider only the centroid (location) of the cell for the computation of the distance  map<point, float> results_location <- map<point, float>(IDW(cell_location collect each.location, pts, power));     ask cell_location {   val <- results_location[self.location];   float val_col <- 255 * (val - min_val) / (max_val - min_val);   color <- rgb(val_col,0,0);  } } }   //cells where the distance is based on the shape of the cell (min distance between the rectangle and the points) grid cell_shape width: nb_columns height: nb_rows {  float val; }  //cells where the distance is based on the centroid of the cell (distance between the centroid and the points) grid cell_location width: nb_columns height: nb_rows {  float val; }  experiment spatialinterpolation type: gui {  parameter  nb of columns  var: nb_columns;  parameter  nb of rows  var: nb_rows;  parameter  power parameter  var: power;  output {   display map_shape {    grid cell_shape;    graphics  points  {     loop pt over: pts.keys {      float val <- pts[pt];      float val_col <- 255 * (val - min_val) / (max_val - min_val);      draw circle(1) at: pt color: rgb(val_col,0,0) border: #white;     }    }   }   display map_location {    grid cell_location;    graphics  points  {     loop pt over: pts.keys {      float val <- pts[pt];      float val_col <- 255 * (val - min_val) / (max_val - min_val);      draw circle(1) at: pt color: rgb(val_col,0,0) border: #white;     }    }   }  } }     ","url":"wiki/Spatial-Operators-spatialinterpolation.md"},{"id":"wiki/Statistics-Regression.md","title":" Regression","content":"# Regression  Author : Patrick Taillandier  A model which shows how to use the regression  Code of the model :       model example_regression  global {  //Regression variable that will store the function  regression location_fct;  float x_val <- 50.0;  float y_val <- 50.0;  float val <- -1.0; init {  loop i from: 0 to: 18{   if (i != 10) {    create dummy with:[location::{i * 5 + 2 - rnd(4), i*5 + 2 - rnd(4), i*5 + 2 - rnd(4)}];    }  } }  //Reflex to compute the regression reflex do_regression {  matrix<float> instances <- 0.0 as_matrix {3,length(dummy)};  loop i from: 0 to: length(dummy) -1 {   dummy ag <- dummy[i];   instances[1,i] <- ag.location.x;   instances[2,i] <- ag.location.y;   instances[0,i] <- ag.location.z;  }  //Compute the function of regression  location_fct  <- build(instances);  write learnt function:  + location_fct;    //Predict the value using the function resulting before  val <-  predict(location_fct, [x_val, y_val]);  write value :  + val; } }   species dummy {  aspect default {   draw sphere(2) color: #blue;  } }  experiment main type: gui {  parameter  Point to test, x value  var: x_val ;  parameter  Point to test, y value  var: y_val ;  output {   display map type: opengl {    species dummy;    graphics  new Point   {     if (location_fct != nil) {      draw sphere(2) color: #red at: {x_val,y_val,val};      //Draw the function as a line     draw line([{100,100,predict(location_fct, [100,100])},{-10,-10,predict(location_fct, [-10,-10])}]) color: #black;    }       }  } } }      ","url":"wiki/Statistics-Regression.md"},{"id":"wiki/Unit-Test-Basic-Example.md","title":" Example of Unit Test","content":"# Example of Unit Test  Author : Benoit Gaudou  A model which shows how to use the unit test to show the possible errors you have to go in the Views, Preferences, Simulation, in  Errors  Uncheck  stop at the first error , to show all the errors.  Code of the model :       model test_unitTest_framework  global {  init {   create test_species number: 1;  } }  //Species to do the different unit tests species test_species {  int a <- 0;  //Setup a to 10 launched before each test setup {  a <- 10;  write SetUp : a =  + a; }  //First test executing comparison between numbers test t1 {   assert 100 + 100 equals: 200;   assert 100 + 100 equals: 201; }  //Second test executing comparison between list and type test t2 {  assert any([1,2,3]) is_not: nil;  assert any([1,2,3]) is int;  assert any([1,2,3]) is_not: 5;  assert any([1,2,3]) is float;  assert any([1,2,3]) is string; }  //test the incrementation of a test incement_a {      a<- a + 10;   write a:  + a; }  //Third test for lists test t3 {    list<int> aa;   assert aa[0] raises: error;   assert aa[0] raises: ;   assert a raises: error; } }   experiment new type: gui {}     ","url":"wiki/Unit-Test-Basic-Example.md"},{"id":"wiki/Unit-Test-Two-Species-(Example).md","title":" Example of Unit Test","content":"# Example of Unit Test  Author : Benoit Gaudou  The model creates 10 agents at initialization, kills one agent at each step.   * With the assert we want to ensure that the test_species1 population always contains more than 5 agents.   * After four steps the population is below 6 so Errors are raisen. You have to go in the Views, Preferences, Simulation, in  Errors  Uncheck  stop at the first error , to show all the errors.  Code of the model :       model test_unitTest_framework  global {  init {   //Create agents : one to test the population of test_species1 and the test_species1 agents   create test_species2 number: 1;   create test_species1 number: 10;  }  //At each step, one of the agents of test_species1 dies  reflex one_should_die {   ask one_of(test_species1){    do die;   }  } }  species test_species2 {  //The step is computed each step to test if there is still at least 5 agents of test_species1  test t1 {       assert (length(test_species1) > 5) equals: true;  } }  species test_species1 { }  experiment new type: gui {}     ","url":"wiki/Unit-Test-Two-Species-(Example).md"},{"id":"wiki/User-Interaction-Event-Layer.md","title":" Event Feature","content":"# Event Feature  Author : Arnaud Grignard & Patrick Taillandier  Model which shows how to use the event layer to trigger an action according to an event occuring in the display. The experiment has two displays : one for the changing color event, one for the changing shape event.  Code of the model :      model event_layer_model  global {  //number of agents to create  int nbAgent <- 500;  init  {  //creation of the agents  create cell number: nbAgent  {   color <- °green;  }  }  //Action to change the color of the agents, according to the point to know which agents we re in intersection with the point action change_color (point loc, list<cell> selected_agents) {  //change the color of the agents  ask selected_agents  {   color <- color = °green ? °pink : °green;  }  }  //Action to change the shape of the agents, according to the point to know which agents we re in intersection with the point action change_shape (point loc, list<cell> selected_agents) {  ask selected_agents  {   //change the bool attribute is_square to change the shape in the display   is_square <- not (is_square);  }  }   }  //Species cells moving randomly species cell skills: [moving] {  rgb color;  bool is_square <- false;  reflex mm  {   do wander amplitude: 30;  }  aspect default {  draw is_square ? square(2) : circle(1) color: color; }   }  experiment Displays type: gui {  output  {   display View_change_color   {    species cell aspect: default;    //event, launches the action change_color if the event mouse_down (ie. the user clicks on the layer event) is triggered   event [mouse_down] action: change_color;  }   display View_change_shape type: opengl  {   species cell;    //event, launches the action change_shape if the event mouse_down (ie. the user clicks on the layer event) is triggered   event [mouse_down] action: change_shape;  }  }   }      ","url":"wiki/User-Interaction-Event-Layer.md"},{"id":"wiki/User-Interaction-Moving-Agents.md","title":" MovingAgents","content":"# MovingAgents  Author : drogoul  Shows how to move agents using two event layers :  Click to grab an group of agents, click again to drop them. Press the keys  k  to kill the agents in the selection, and  d  to duplicate them.  Code of the model :      model MovingAgents  global {  list moved_agents ;  geometry shape <- square(1000);  point target;  geometry zone <- circle(100);  bool can_drop;  init  {   create being number: 100;  }  action kill (list<agent> selectedAgent, point mousePosition) {  ask moved_agents  {   do die;  }   moved_agents <- list<being>([]); }  action duplicate (list<agent> selectedAgent, point mousePosition) {  geometry available_space <- (zone at_location target) - (union(moved_agents) + 10);  create being number: length(moved_agents) with: (location: any_location_in(available_space)); }  action click (list<agent> selectedAgent, point mousePosition) {  if (empty(moved_agents))  {   list<being> selected_agents <- being inside (zone at_location mousePosition);   moved_agents <- selected_agents;   ask selected_agents   {    difference <- mousePosition - location;    color <- # olive;   }   } else if (can_drop)  {   ask moved_agents   {    color <- # burlywood;   }    moved_agents <- list<being>([]);  }  }  action move (list<agent> selectedAgent, point mousePosition) {  can_drop <- true;  target <- mousePosition;  list<being> other_agents <- (being inside (zone at_location mousePosition)) - moved_agents;  geometry occupied <- geometry(other_agents);  ask moved_agents  {   location <- mousePosition - difference;   if (occupied intersects self)   {    color <- # red;    can_drop <- false;   } else   {    color <- # olive;   }   }  }   }  species being skills: [moving] {  geometry shape <- square(10);  point difference <- { 0, 0 };  rgb color <- # burlywood;  reflex r  {   if (!(moved_agents contains self))   {    do wander amplitude: 30;   }  }  aspect default {  draw shape color: color at: location; }   }  experiment  Click and Move  type: gui {  font regular <- font( Helvetica , 14, # bold);  output  {   display  Click and Move [OPENGL]  type: opengl   {    graphics  Empty target      {     if (empty(moved_agents))     {      draw zone at: target empty: false border: false color: #wheat;     }    }    species being;   event mouse_move action: move;   event mouse_up action: click;   event  k  action: kill;   event  c  action: duplicate;   graphics Full target    {    int size <- length(moved_agents);    if (size > 0)    {     rgb c1 <- rgb(#darkseagreen, 120);     rgb c2 <- rgb(#firebrick, 120);     draw zone at: target empty: false border: false color: (can_drop ? c1 : c2);     draw string(size) at: target + { -30, -30 } font: regular color: # white;     draw  k : kill at: target + { -30, 0 } font: regular color: # white;     draw  c : copy at: target + { -30, 30 } font: regular color: # white;    }    }   }    display Click and Move [JAVA2D] type: java2D  {   graphics Empty target    {    if (empty(moved_agents))    {     draw zone at: target empty: false border: false color: #wheat;    }    }    species being;   event mouse_move action: move;   event mouse_up action: click;   event  k  action: kill;   event  c  action: duplicate;   graphics Full target    {    int size <- length(moved_agents);    if (size > 0)    {     rgb c1 <- rgb(#darkseagreen, 120);     rgb c2 <- rgb(#firebrick, 120);     draw zone at: target empty: false border: false color: (can_drop ? c1 : c2);     draw string(size) at: target + { -30, -30 } font: regular color: # white;     draw  k : kill at: target + { -30, 0 } font: regular color: # white;     draw  c : copy at: target + { -30, 30 } font: regular color: # white;    }    }   }       }   }     ","url":"wiki/User-Interaction-Moving-Agents.md"},{"id":"wiki/User-Interaction-User-Command.md","title":" User Command","content":"# User Command  Author : Patrick Taillandier  Model which shows how to use the user commands in order to create agents in the display. The user has two possibilities : create one agent, or create a number of agents, with the possibility to change their shape and a pink color. The user also has the possibility to change the color and the shapes of the agents.  Code of the model :       model usercommand  global {  //Number of agent to initialise  int nbAgent <- 1;  init {  //Create the agent  create cell number: nbAgent {   color <-°green;  } }  //These commands are displayed in the world layer //User command to create an agent according to the location where the user right click user_command Create an agent {      create cell number: nbAgent with: [location::user_location]  {       color <-°green;      }  } //User command to create a given number of agents according user_command Create agents {   map input_values <- user_input([Number :: nbAgent, shape :: circle]);    create cell number: int(input_values at Number) with: [color:: °pink, is_square:: string(input_values at shape) = square]; }   }  //Species that will be used species cell {  rgb color;   bool is_square <- false;  //These commands will be displayed in the cells layer, after right clicking on a agent user_command change coloraction: change_color; user_command change shape action: change_shape;  //Action to change the color of the agent triggered by change color user command action change_color  {  color <- color = °green ? °pink : °green; }  //Action to change the shape of the agent triggered by change shape user command action change_shape {    is_square <- not (is_square); } aspect default {  draw is_square ? square(2): circle(1) color: color; } }   experiment Displays type: gui {  output {   display map {     species cell;   }  } }     ","url":"wiki/User-Interaction-User-Command.md"},{"id":"wiki/User-Interaction-User-Control-Architecture.md","title":" User Command","content":"# User Command  Author : Patrick Taillandier  Model which shows how to use the advanced user control, to create and kill agents.  Code of the model :       model user_control  global {  int nbAgent <- 10; bool advanced_user_control <- false; init {  create cell number: nbAgent {   color <-°green;  }  create user; } }   species cell {  rgb color;   aspect default {   draw circle(1) color: color;  } }  species user control:user_only {    user_panel  Default  initial: true {       transition to:  Basic Control  when: every (10) and !advanced_user_control;       transition to:  Advanced Control  when: every(10) and advanced_user_control;    }  user_panel  Basic Control  {       user_command  Kill one cell  {   ask (one_of(cell)){   do die;   }       }       user_command  Create one cell  {  create cell {     color <-°green;    }       } transition to:  Default  when: true;  }    user_panel  Advanced Control  {       user_command  Kill cells  color: #red continue: true{  user_input  Number  returns: number type: int <- 10;  ask (number among list(cell)){  do die;  }       }       user_command  Create cells  color: #green {  user_input  Number  returns: number type: int <- 10;  create cell number: number ;       } transition to:  Default  when: true;   } }  experiment Displays type: gui {  parameter  advanced user control  var: advanced_user_control <- false;  output {    display map {     species cell;   }  } }     ","url":"wiki/User-Interaction-User-Control-Architecture.md"},{"id":"wiki/Agent-movement.md","title":" Agent movement","content":"Agent movement  This sub-section is composed of the following models : Movement of an agent on different paths  Follow Weighted Network  Directed Graph Model  Movement on a Grid of Cells  Shortest Path Computation on a Graph  Movement on a Graph created by Polygons  Movement in 3D      ","url":"wiki/Agent-movement.md"},{"id":"wiki/Batch.md","title":" Batch","content":"Batch  This sub-section is composed of the following models :      Model using Batch mode   ","url":"wiki/Batch.md"},{"id":"wiki/Charts.md","title":" Charts","content":"Charts  This sub-section is composed of the following models :     Ant Foraging (Charts examples)   ","url":"wiki/Charts.md"},{"id":"wiki/Clustering.md","title":" Clustering","content":"Clustering  This sub-section is composed of the following models : Clustering of agents by K Means and DBScan  Clustering of agents by their distance       ","url":"wiki/Clustering.md"},{"id":"wiki/Co-model-Usage.md","title":" Co-model Usage","content":"Co-model Usage  This sub-section is composed of the following models :   comodel with mixed behaviors  comodel_with_the_coupling Simple syntax demonstration of Comodeling  comodel_with_the_coupling      ","url":"wiki/Co-model-Usage.md"},{"id":"wiki/Color.md","title":" Color","content":"Color  This sub-section is composed of the following models :   Creating color and sort cubes by color Color defined by choosing a Color Brewer RGB color to XYZ position      ","url":"wiki/Color.md"},{"id":"wiki/Data-Importation.md","title":" Data Importation","content":"Data Importation  This sub-section is composed of the following models :   3D shapefile loading ESRI ASCII to grid model Contour Lines Import CSV to Agents Model Convertion of CSV data to Matrix DXF to Agents Model GeoTIFF file to Grid of Cells  Shapefiles Import and Save ASCII File to DEM Representation OBJ File to Geometry Complex Object Loading OSM file to Agents Raster File in a Grid of cells Raster File and Shapefiles Import      ","url":"wiki/Data-Importation.md"},{"id":"wiki/Database-Usage.md","title":" Database Usage","content":"Database Usage  This sub-section is composed of the following models :   SQLConnection  create_agents_Insert_result_MySQL  Simple Species MySql  Simple SQL Command in SQLIte  Agents from Database in MSSQL  Agents from Database in MySQL  Agents from Database in PostGIS  Agents from Database in SQLite   Agents from Database in SQLite QGIS  Agents to Database in MSSQL  Agents to Database in MySQL  Agents to Database in PostGIS  Agents to Database in SQLite  CreateBuildingTableMSSQL  CreateBuildingTableMySQL  CreateBuildingTablePostGIS  CreateBuildingTableSQLite      ","url":"wiki/Database-Usage.md"},{"id":"wiki/Date-and-Time.md","title":" Date and Time","content":"Date and Time  This sub-section is composed of the following models :   Use of the Date variables Simple definition of time property in a model      ","url":"wiki/Date-and-Time.md"},{"id":"wiki/Driving-Skill.md","title":" Driving Skill","content":"Driving Skill  This sub-section is composed of the following models :   OSM Loading Driving Complex Road Network  Simple Road Network  Easy Road Network       ","url":"wiki/Driving-Skill.md"},{"id":"wiki/Graphs.md","title":" Graphs","content":"Graphs  This sub-section is composed of the following models :   3D Graph Graph Generation Graph Generation using Agents Graph from DGS File and Layout Changed Graph Operators Hand Made Graph Multigraph ShortestPath      ","url":"wiki/Graphs.md"},{"id":"wiki/Init-Action.md","title":" Init Action","content":"Init Action  This sub-section is composed of the following models :     InitAction   ","url":"wiki/Init-Action.md"},{"id":"wiki/Map-comparison.md","title":" Map comparison","content":"Map comparison  This sub-section is composed of the following models :   Raster Map Comparison Vector Map Comparison      ","url":"wiki/Map-comparison.md"},{"id":"wiki/Multi-Level-Usage.md","title":" Multi-Level Usage","content":"Multi-Level Usage  This sub-section is composed of the following models :   Balls, Groups and Clouds Multilevel Architecture Corridor Multi-Level Architecture with Mathematics Model and Agent Based Model Corridor Multi-Level Architecture Multi-Level Architecture with Preys and Predators      ","url":"wiki/Multi-Level-Usage.md"},{"id":"wiki/Multi-simulation.md","title":" Multi-simulation","content":"Multi-simulation  This sub-section is composed of the following models :     Multi Simulation   ","url":"wiki/Multi-simulation.md"},{"id":"wiki/Multicriteria-decision.md","title":" Multicriteria decision","content":"Multicriteria decision  This sub-section is composed of the following models :     Multicriteria   ","url":"wiki/Multicriteria-decision.md"},{"id":"wiki/Overlay.md","title":" Overlay","content":"Overlay  This sub-section is composed of the following models :     Overlay   ","url":"wiki/Overlay.md"},{"id":"wiki/Save-statement.md","title":" Save statement","content":"Save statement  This sub-section is composed of the following models :   Save to Ascii Save to CSV Save to Shapefile Save to Text      ","url":"wiki/Save-statement.md"},{"id":"wiki/Spatial-Operators.md","title":" Spatial Operators","content":"Spatial Operators  This sub-section is composed of the following models :   Discretization of Topology Spatial Operators Spatial Interpolation Spatial Operators      ","url":"wiki/Spatial-Operators.md"},{"id":"wiki/Statistics.md","title":" Statistics","content":"Statistics  This sub-section is composed of the following models :     Regression   ","url":"wiki/Statistics.md"},{"id":"wiki/Unit-Test.md","title":" Unit Test","content":"Unit Test  This sub-section is composed of the following models :   Example of Unit Test Example of Unit Test      ","url":"wiki/Unit-Test.md"},{"id":"wiki/User-Interaction.md","title":" User Interaction","content":"User Interaction  This sub-section is composed of the following models :   Event Feature MovingAgents User Command User Command      ","url":"wiki/User-Interaction.md"},{"id":"wiki/Syntax-models-Casting.md","title":" Casting Syntax","content":"# Casting Syntax  Author : A. Drogoul & P. Taillandier  different ways of transforming objects and agents in GAML.  Code of the model :       model Casting  species to_int {  init {   write sample(int(1));   write sample(int(1.0));   write sample(int( 1 ));   write sample(int( 1.0 ));   write sample(int(°pink));   write sample(int(true));   write sample(int(self));   write sample(int([]));   write sample(int([0]));   write sample(int({0,0,0}));   write sample(int(0::0));   write sample(int([0::0]));   write sample(int(#AABBCC));   write sample(int(°meter));      } }  species to_float{  init {   write sample(float(1));   write sample(float(1.0));   write sample(float( 1 ));   write sample(float( 1.0 ));   write sample(float(°pink));   write sample(float(true));   write sample(float(self));   write sample(float([]));   write sample(float([0]));   write sample(float(0::0));   write sample(float([0::0]));   write sample(float({0,0,0}));   write sample(float(#AABBCC));   write sample(float(°meter));      } }  species to_string{  init {   write sample(string(1));   write sample(string(1.0));   write sample(string( 1 ));   write sample(string( 1.0 ));   write sample(string(°pink));   write sample(string(true));   write sample(string(self));   write sample(string([]));   write sample(string([0]));   write sample(string({0,0,0}));   write sample(string(#AABBCC));   write sample(string(°meter));      } }  species to_point{  init {   write sample(point(1));   write sample(point(1.0));   write sample(point( 1 ));   write sample(point( 1.0 ));   write sample(point(°pink));   write sample(point(true));   write sample(point(self));   write sample(point([]));   write sample(point([0]));   write sample(point(0::0));   write sample(point([0::0]));   write sample(point({0,0,0}));   write sample(point(#AABBCC));   write sample(point(°meter));      } } species to_list{  init {   write sample(list(1));   write sample(list(1.0));   write sample(list( 1 ));   write sample(list( 1.0 ));   write sample(list(°pink));   write sample(list(true));   write sample(list(self));   write sample(list([]));   write sample(list([0]));   write sample(list(0::0));   write sample(list([0::0]));    write sample(list({0,0,0}));   write sample(list(#AABBCC));   write sample(list(°meter));      } } species to_pair{  init {   write sample(pair(1));   write sample(pair(1.0));   write sample(pair( 1 ));   write sample(pair( 1.0 ));   write sample(pair(°pink));   write sample(pair(true));   write sample(pair(self));   write sample(pair([]));   write sample(pair([0]));   write sample(pair(0::0));   write sample(pair([0::0]));   write sample(pair({0,0,0}));   write sample(pair(#AABBCC));   write sample(pair(°meter));      } } species to_map{  init {   write sample(map<float, int>(°meter));   write sample(map(1));   write sample(map(1.0));   write sample(map( 1 ));   write sample(map( 1.0 ));   write sample(map(°pink));   write sample(map(true));   write sample(map(self));   write sample(map([]));   write sample(map([0]));   write sample(map(0::0));   write sample(map([0::0]));   write sample(map({0,0,0}));   write sample(map(#AABBCC));   write sample(map<int,string>(1));      } } experiment Casting type: gui{  user_command  to int  {create to_int;}  user_command  to float  {create to_float;}  user_command  to string  {create to_string;}  user_command  to point  {create to_point;}  user_command  to list  {create to_list;}  user_command  to pair  {create to_pair;}  user_command  to map  {create to_map;} }     ","url":"wiki/Syntax-models-Casting.md"},{"id":"wiki/Syntax-models-Lists.md","title":" Lists","content":"# Lists  Author : Alexis Drogoul  Examples of the syntax and various operators used to manipulate the  list  data type. Read the comments and run the model to get a better idea on how to use lists in GAML.  Code of the model :       model Lists  /* Insert your model definition here */  species declaring_list_attributes {  /**  * Declarations of list attributes  */  // The simplest declaration identifies empty_list as a list that can contain any type of objects.   // Its default value will be [] (the empty list) if it is not initialized. list empty_list; // To provide it with an initial value, use the  <-  (or  init: ) facet list explicit_empty_list <- []; // lists can also be provided with a default size, in which case they are filled with the nil element list list_of_size_10 <-[];// list_size(10); // => [nil,nil,nil,nil,nil,nil,nil,nil,nil,nil] // to fill them with a given initial value, use the  list_with  operator list list_of_size_10_with_0 <- list_with(10, 0); // => [0,0,0,0,0,0,0,0,0,0]  // lists can be declared so that they only accept a given type of contents. // For instance, empty_list_of_int will only accept integer elements list<int> empty_list_of_int ;  // the value passed to  list_with  is verified and casted to the contents type of the list if necessary list<int> list_of_int_size_10_filled_with_string<- list<int>(list_with(10, 1 )); // list_of_int_size_10_filled_with_string is filled with the casting of  1  to int, i.e. 1 list<string> list_of_string_size_10_filled_with_string <- list_with(10, 1 ); // while list_of_string_size_10_filled_with_string is filled with the string  1  // the casting is also realized if the list is initialized with a value list<int> list_of_int_with_init_of_string <- list<int>([ 10 ,  20 ]); // => [10,20] list<float> list_of_float_with_init_of_string <- list<float>(list_of_string_size_10_filled_with_string); // => [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0] // When the casting is not obvious, the default value is used list<float> list_of_float_with_impossible_casting <- list<float>([ A , B ]);  // lists can of course contain lists list<list> list_of_lists <- list_with (5,[]); // untyped lists can contain heterogeneous objects list untyped_list <- [ 5 ,5,[5]]; // the casting applies to all elements when a contents type is defined (note the default last value of 0) list<int> recasted_list_with_int <- list<int>(untyped_list); //=> [5,5,0]   init {  write ;  write == DECLARING LISTS ==;  write ;  write sample(empty_list);  write sample(explicit_empty_list);  write sample(list_of_size_10);  write sample(list_of_size_10_with_0);  write sample(empty_list_of_int);  write sample(list_of_int_size_10_filled_with_string);  write sample(list_of_string_size_10_filled_with_string);  write sample(list_of_int_with_init_of_string);  write sample(list_of_float_with_init_of_string);  write sample(list_of_float_with_impossible_casting);  write sample(list_of_lists);  write sample(untyped_list);  write sample(recasted_list_with_int);  write ;  // Declaring temporary variables of type list follows the same pattern  // but there are fewer facets available (notably, size: or fill_with:).  list<string> list_of_string <- [ A , B , C ];  // lists are not always declared litterally and can be obtained from various elements  // by using the casting  list()  operator  // for instance, list(species_name) will return a list of all the instances of species_name  create test_species number:4;  list<test_species> my_agents <- list(test_species);  write sample(my_agents);  list<string> my_names <- my_agents collect each.name;  write sample(my_names);  //  create  can directly declare (and return) a list of the agents created. For instance:  create test_species number: 5 returns: my_agents2;  write (sample(my_agents2));  // Some special casting operations are applied to specific types, like points...  write sample(list(any(my_agents).location));  // ... colors ...  write sample(list(°pink));  // ... or strings  write sample(list(This is a string));     } }  species test_species{}  species accessing_list_elements {  list l1 <- [1,2,3,4,5,6,7,8,9,10];  list l2 <- [ this , is , a , list ,  of , strings ];  init {   write ;   write == ACCESSING LIST ELEMENTS ==;   write ;   write sample(l1);   write sample(l2);   write sample(first(l1));   write sample(last(l1));   write sample(l1 at 1);   write sample(l1[1]);   write sample(length(l1));   write sample(mean(l1));   write sample(max(l1));   write sample(min(l1));   write sample(any(l1));   write sample(3 among l2);   write sample(l1 contains 1);   write sample(l1 contains_all [1,4,6, 14]);   write sample(l1 contains_any [1,23]);   write sample(reverse(l2));   write sample(l1 collect (each + 1));   write sample(l1 collect (norm({each, each, each})));   write sample(l1 where (each > 5));   write sample(l1 count (each > 5));   write sample(l1 group_by (even(each)));   write sample(l2 index_by (each + _index));   write sample(l1 index_of 100);   write sample(l2 last_index_of  is );   write sample(l2 sort_by each);   write sample(l2 sort_by length(each));   write sample(l2 first_with (first(each)  =  o ));   write sample(l2 where (length(each) = 2) );   write sample(l2 with_min_of (length(each)));   write sample(l2 with_max_of (length(each)));   write sample(l2 min_of (length(each)));   write sample(l2 max_of (length(each)));    write sample(copy_between(l2,1,3));   write sample(copy_between(l2, 1, length(l2) - 1));  } }  species combining_lists {  list l1 <- [1,2,3,4,5,6,7,8,9,10];  list l2 <- [1,3,5,7,9];  init {   write ;   write == COMBINING LISTS ==;   write ;   write sample(list<list>([[1,2,3]]));   write sample(l1);   write sample(l2);   write sample(l1 + l2);   write sample(l1 - l2);   write sample(l1 inter l2);   write sample(l1 union l2);   write sample(interleave ([l1,l2]));   list l3 <- list(l1 + l2);   write list l3 <- l1 + l2;  + sample(l3);   write sample(l1 as list);  } }  species modifying_lists {  init {   write   ;   write  == MODIFYING LISTS == ;   write   ;   trace {   // Besides assigning a new value to a list, lists can be manipulated using   // the  add ,  remove  and  put  statements.    // Let s define an empty list supposed to contain integer elements   list l1;   // and add some stuff to it using add   add 1 to: l1;   add 2 to: l1;   add 3 to: l1;   write sample(l1);   // the same can be done with the compact syntax introduced in GAMA 1.6 for add   l1 <+ 4;   l1 <+ 5;   write sample(l1);   // tired of writing lines of add ? The all: facet is here to serve:   add all: [6, 7, 8, 9] to: l1;   // or, in a more compact way:   l1 <<+ [10,11,12,13];   write sample(l1);   // automatic casting applies to any element added to the list    l1 <+ (int(14));   // as well as any container of elements   l1 <<+ (list([15, 16.0]));   write sample(l1);   // elements are by default added to the end of the list   // but they can be introduced at specific positions using the at: facet   add 0 to: l1 at: 0;   // or   l1[0] +<- 0;   // what about replacing some elements once they have been added ?   // put can be used for that purpose   put -2 at: 0 in: l1;   // or, more elegantly:   l1[0] <- -2;   // Trying to put an element outside the bounds of the list will yield an error   // l1[20] <- 10; will return the error Index 20 out of bounds of l1   write sample(l1);   // And what about replacing all the values with a new one ?   l1[] <- 0;   write sample(l1);   // Well, l1 is a bit boring now, isnt t it ?   // Let s fill it again with fresh values   loop i from: 0 to: length(l1) -1 {    l1[i] <- rnd(3);   }   write(sample(l1));   // To remove values from it, the remove statement (and its compact forms) can be used   // For instance, let s try to remove its first element   remove first(l1) from: l1;   // it can also be written   l1 >- first(l1);   write(sample(l1));   // To remove all occurrences of a specific element, all: (or >>-) can be used   // For instance:   l1 >>- 2;   l1 >>- 1;   // or, written using the long syntactic form   remove all: 1 from: l1;   write sample(l1);   // To remove all the elements present in a given container, the same syntax can be used   l1 >>- [0,3];   write (After l1 >>- [0,3] :  + sample( l1));   // By all means, l1 should now be empty! Let s fill it again   loop times: 20 {    l1 <+ rnd(3);   }   write(sample(l1));   // It is also possible to remove an index rather than a value (this will remove the    // value present at this index )   l1[] >- 2;   write(After l1[] >- 2 :  + sample(l1));   // Removing several indexes can be written using a syntax similar to the one used   // for removing values   l1[] >>- [1,2,4];   write(After l1[] >>- [1,2,4] :  + sample(l1));   // Random things to try out   // Using casting back and forth: all number now vary from 1000 to 31000   l1 <- list(l1 collect (string(each) + 1000));   write sample(l1);   // Removing elements based on a criteria   l1 >>- l1 select (each > 20000);   // Removing duplicates   l1 <- remove_duplicates(l1);   // Another way (see ../Maps.gaml)   l1 <- map(l1).values;    write(sample(l1));  }}  }  species looping_on_lists {  init {   write   ;   write  == LOOPING ON LISTS == ;   write   ;   // Besides iterator operators (like  collect ,  where , etc.), which provide    // functional iterations (i.e. filters), one can loop over lists using the imperative   // statement  loop    list l1 <- list(This is a list of strings);   write sample(l1);   int i <- 0;   list l2 <- [];   // Here, the value of  s  will be that of each element of the list   loop s over: l1 {    i <- i + 1;    l2 << Word # + i + :  + s;   }   write sample(l2);   //  loop  can also directly use an integer index (remember lists have a zero-based index)   l2 <- [];   loop i from: 0 to: length(l1) - 1 step:2 {    l2 << l1[i];   }   write sample(l2);   // Finally, list containing agents can be the support of implicit loops in the  ask  statement   create test_species number: 5 returns: my_agents;   l2 <- [];   ask my_agents{    // attributes of each agent can be directly accessed    l2 << name;   }   write sample(l2);   // ... which is formally equivalent to:   l2 <- [];   l2 <<+ my_agents collect each.name;   write sample(l2);   // ... or, even simpler (since the casting of an agent to string returns its name)   list l3 <- list(my_agents);   write sample(l3);   // Powerful filter expressions can be built by combining the various  iterator  operators   l3 <- list(my_agents where even(int(each))) collect (Agent  + each +  has an even id);   write sample(l3);  } }  experiment Lists type: gui {  user_command  Declaring lists  {create declaring_list_attributes;}  user_command  Accessing lists  {create accessing_list_elements;}  user_command  Combining lists  {create combining_lists;}  user_command  Modifying lists  {create modifying_lists;}  user_command  Looping on lists  {create looping_on_lists;}  }     ","url":"wiki/Syntax-models-Lists.md"},{"id":"wiki/Syntax-models-Maps.md","title":" Maps","content":"# Maps  Author : Alexis Drogoul  Examples of the syntax and various operators used to manipulate the  map  data type. Read the comments and run the model to get a better idea on how to use maps in GAML.  Code of the model :       model Maps  /* Maps is a data structure consisting of a list of pair<key, value> where each key is unique */  species declaring_map_attributes {  /**  * Declarations of map attributes  */  // The simplest declaration identifies empty_map as a map that can contain any type of objects.   // Its default value will be [] (the empty list/map) if it is not initialized. map empty_map; // To provide it with a literal initial value, use the  <-  (or  init: ) facet and pass a map map explicit_empty_map <- []; // Or, more explicitely map explicit_empty_map2 <- map([]); // Values can be declared litterally in this map, which is nothing more than a list of pair objects map explicit_filled_map <- [First::1, Second::2]; // If a map is initialized with a list that contains non-pair objects, the pairs element::element are added to the map map map_initialized_with_list <- map<int, int>([1,2,3,4]); // maps can be declared so that they only accept a given type of keys and values // For instance, empty_map_of_int will accept string keys and integer values map<string, int> empty_map_of_int; // The appropriate casting is realized if the map is initialized with a list of values map<string, int> map_of_int_with_init_of_string <- map<string, int>([ 10 ,  20 ]); // => [ 10 ::10, 20 ::20] // or with another map map<int, float> map_of_float_with_init_of_map <- map<int, float>(map_initialized_with_list);  // When the casting is not obvious, the default values are used // Here, the list is first casted to return pairs, and they are casted to pair<string, float> map<string, float> map_of_float_with_impossible_casting <- map<string, float>([ A , B ]);  // maps can of course contain maps map<string, map> map_of_maps <- map<string, map>([ A ::[],  B ::[]]); // untyped maps can contain heterogeneous objects map untyped_map <- [10:: 5 , 11 ::5,[12]::[5]]; // the casting applies to all elements when a key and contents type is defined map<int, string> recasted_map_with_int_and_string <- map<int, string>(untyped_map); //=> [5,5,0]   init {  write ;  write == DECLARING MAPS ==;  write ;  write sample(empty_map);  write sample(explicit_empty_map);  write sample(empty_map_of_int);  write sample(explicit_filled_map);  write sample(map_initialized_with_list);  write sample(map_of_int_with_init_of_string);  write sample(map_of_float_with_init_of_map);  write sample(map_of_float_with_impossible_casting);  write sample(map_of_maps);  write sample(untyped_map);  write sample(recasted_map_with_int_and_string);  write ;  // Declaring temporary variables of type map follows the same pattern  map<int,string> map_of_string <- [1:: A ,2:: B ,3:: C ];  // maps are not always declared litterally and can be obtained from various elements  // by using the casting  map()  operator  // for instance, map(species_name) will return a list of all the agents of species_name  // using pairs of agent::agent. If the key is explicit, it is used in the casting:  create test_species number:4;  map<string, test_species> my_agents <- map<string, test_species>(test_species);  write sample(my_agents);  // Some special casting operations are applied to specific types, like agents (returns a copy of their attributes)  write sample(map(any(my_agents)));  // The  as_map(pair)  iterator operator also provides a way to build more complex maps  write sample(list(This is a string) as_map (length(each)::each));  // As well as group_by or index_by  write sample(my_agents index_by (each distance_to {0,0}));  write sample([1,2,3,4,5,6,7] group_by ((each mod 3) = 0));   } }   species test_species{}  species accessing_map_elements {  map<int, int> l1 <- map<int, int>([1,2,3,4,5,6,7,8,9,10]);  map<int, string> l2 <- [1:: this ,2:: is ,3:: a ,4:: list , 5:: of ,6:: strings ];  init {   write   ;   write  == ACCESSING MAPS ELEMENTS == ;   write   ;   write sample(l1);   write sample(l2);   write sample(first(l1));   write sample(last(l1));   write sample(l1 at 1);   write sample(l1[1]);   write sample(length(l1));   write sample(mean(l1));   write sample(max(l1));   write sample(min(l1));   write sample(any(l1));   write sample(3 among l1);   write sample(l1 contains 1);   write sample(l1 contains_all [1,4,6, 14]);   write sample(l1 contains_any [1,23]);   write sample(reverse(l2));   write sample(l1 collect (each + 1));   write sample(l1 collect (norm({each, each, each})));   write sample(l1 where (each > 5));   write sample(l1 count (each > 5));   write sample(l1 group_by (even(each)));   write sample(l2 index_by (each +  _index ));   write sample(l1 index_of 100);   write sample(l2 last_index_of  is );   write sample(l2 sort_by each);   write sample(l2 sort_by length(each));   write sample(l2 first_with (first(each)  =  o ));   write sample(l2 where (length(each) = 2) );   write sample(l2 with_min_of (length(each)));   write sample(l2 with_max_of (length(each)));   write sample(l2 min_of (length(each)));   write sample(l2 max_of (length(each)));  } }  species combining_maps {  map<int, int> l1 <- map<int, int>([1,2,3,4,5,6,7,8,9,10]);  map<int, int> l2 <- map<int, int>([1,3,5,7,9]);  init {   write ;  write == COMBINING MAPS ==;  write ;  write sample(l1);  write sample(l2);  write sample(l1 + l2);  write sample(l1 - l2);  write sample(l1 inter l2);  write sample(l1 union l2);  map<string> l3 <- map<int, string>(l1 + l2);  write map<string> l3 <- l1 + l2;  + sample(l3); } }   species modifying_maps {  init {   write   ;   write  == MODIFYING MAPS == ;   write   ;   // Besides assigning a new value to a map, maps can be manipulated using   // the  add ,  remove  and  put  statements.    // Let s define an empty list supposed to contain integer keys and values   trace { map<int, int> m1 <- [0::0];    // and add some stuff to it using  add    add 1::1 to: m1;   add 2::2 to: m1;   add 3::3 to: m1;   write sample(m1);   // the same can be done with the compact syntax introduced in GAMA 1.6.1 for  add    m1 <+ 4::4;   m1 <+ 5::5;   write sample(m1);   // tired of writing lines of add ? The  all:  facet is here to serve:   add [6, 7, 8, 9] to: m1 all: true;   // or, in a more compact way:   m1 «+ [10,11,12,13];   write sample(m1);   // automatic casting applies to any element added to the map   m1 <+ int( 14 );   // as well as any container of elements   m1 «+ map<int, int>([15:: 15 , 16::16.0]);   write sample(m1);   // elements are by default added to the map while their keys are unique   // So, what about replacing some elements once they have been added ?   //  put  can be used for that purpose   put -2 at: 0 in: m1;   // or, more simply:   m1[0] <- -3;   // Trying to put an element outside the  bounds  of the map will of course not yield an error    m1[20] <- 10;    write sample(m1);   // And what about replacing all the values with a new one ?   m1[] <- 0;   write( m1[] <- 0; );   write sample(m1);   // Well, m1 is a bit boring now, isnt t it ?   // Let s fill it again with fresh values   loop i over: m1.keys {    m1[i] <- rnd(3);   }   write(sample(m1));   // To remove values from it, the  remove  statement (and its compact  >-  form) can be used   // WARNING: this form operation on the values of the map (i.e. it will remove the first pair   // whose value = 0   remove 0 from: m1;   // it can also be written   m1 >- 0;   write(sample(m1));   // To remove all occurrences of pairs with a specific value,  all:  (or  »- ) can be used   // For instance:   m1 »- 2;   // or, written using the long syntactic form   remove 1 from: m1 all: true;   write sample(m1);   // To remove keys instead, the same syntax can be used, but on the keys of the map (i.e. map[])   m1[] >- 1; // This will remove the (unique) pair whose key = 1   // The equivalent long syntax is   remove key: 1 from: m1;   // To remove a set of keys, the following syntax can be used   m1[] »- [2,3,4];    // And to remove all the keys present in a given map (using the  keys  attribute)   m1[] »- m1.keys;   write sample(m1);   // By all means, m1 should now be empty! Let s fill it again   int i <- 0;   loop times: 20 {    i <- i + 1;    m1 <+ i::rnd(3);   }   // Random things to try out   // Using the  pairs  attribute: all number now vary from 1000 to 1003   m1 <- m1.pairs as_map (each.key::((each.value) + 1000));   write sample(m1);   // Removing values based on a criteria   m1 »- m1 select (each > 1001);   write(sample(m1));  }  }   }  species looping_on_maps {  init {   write   ;   write  == LOOPING ON MAPS == ;   write   ;   // Besides iterator operators (like  collect ,  where , etc.), which provide    // functional iterations (i.e. filters), one can loop over maps using the imperative   // statement  loop    list strings <- list(This a list of string);   write sample(strings);   map<string, string> l1 <- strings as_map (first(each)::each);   write sample(l1);   int i <- 0;   list l2 <- [];   // Here, the value of  s  will be that of each value of each pairs of the list   loop s over: l1 { // equivalent to  loop s over: l1.values     i <- i + 1;    l2 << Word # + i + :  + s;   }   write sample(l2);   // To loop on the keys of l1, simply use its  keys  attribute   l2 <- [];    i <- 0;   loop s over: l1.keys{    i <- i + 1;    l2 << Key # + i + :  + s;   }   write(sample(l2));   // Looping on indexes allows to gain access to each element in turn   l2 <- [];   loop i over: l1.keys {    l2 <+ l1[i];   }   write sample(l2);   // Finally, maps containing agents can be the support of implicit loops in the  ask  statement   create test_species number: 5 returns: my_agents;   map<int, test_species> map_of_agents <- map<int, test_species>(my_agents);   write(sample(map_of_agents));   l2 <- [];   ask map_of_agents{    // attributes of each agent can be directly accessed    l2 << name;   }   write sample(l2);   // Of course, this can be done more simply like this   l2 <- map_of_agents collect each.name;   }  }  experiment Maps type: gui {  user_command  Declaring maps  {create declaring_map_attributes;}  user_command  Accessing maps  {create accessing_map_elements;}  user_command  Combining maps  {create combining_maps;}  user_command  Modifying maps  {create modifying_maps;}  user_command  Looping on maps  {create looping_on_maps;}  }     ","url":"wiki/Syntax-models-Maps.md"},{"id":"wiki/Syntax-models-Syntax-(1.6).md","title":" Syntax","content":"# Syntax  Author : Alexis Drogoul  An overview of the new syntactic constructs that have been introduced in GAMA 1.6  Code of the model :       @no_warning model syntax  /**  * The global section can now sport skills and control, just like other agents.   * The example below shows a potentially moving world that can be controlled by a finite state machine.  */ global skills: [moving] control: fsm {  /**  * EQUATIONS  */   float x;  float y;  float t;  equation eq {   diff(x, t) = x / 2;   diff(y, t) = x + y * 2;  }  reflex solving {solve eq step: 1 method: rk4;}  /**   * ATTRIBUTES  */   // Attributes can be declared in different ways, ranging from  classic …  list a1 const: true <- [1, 2, 3] of: int;  list a2 <- [1, 2, 3] of: int;  // ... to compact Java-like syntax.  list a3 <- [1, 2, 3];  // The declaration of a default size/value in containers is now working correctly list<float> f <- list_with(2000,0.0);  // Functions can be declared using the regular facet -> / function:  int b1 -> { 100 + length(a1) }; int b2 function: { 100 + length(a1) }; // ... or using a block (like a statement -- note the absence of semi-column at the end) int b3 {  100 + length(a1) } state first_state initial: true { //...  } init {  create species0 number: 20; }   /**  * UNITS  */ // The usage of units is improved ( # being replaced by °), and they can be combined float c <- 10 °meter; float speed <- 10 °meter / °sec;  // Attributes can (finally!) be named after unit names float meter <- 10.0;  // Some mathematical constants have been introduced alongside units float pi_4 <- °pi / 4; float e <- °e;  /**   * ACTIONS   */ // Actions can also be declared in different ways. Classic: action dummy1 type: list of: int {  arg a type: int default: 100;  arg b type: float;  return [a, int(b)]; } // Semi-classic (prefixed by the type) list dummy2 of: int {  arg a type: int default: 100;  arg b type: float;  return [a, int(b)]; } //Compact list<int> dummy1 (int a <- 100, float b) {  return [a, int(b)]; }  // An action that returns nothing can still be called action action dummy_void {  write dummy_void; }  /**  * DEALING WITH VARIABLES  */ reflex variables {  // Temporary variables can use the same syntax as attributes. The classic form:  //let name: t1 type: int value: length(a1);  // is equivalent to the more compact one:  int t2 <- length(a1);   // Assigning a value to variables is also sporting a new syntax   set t2 value: 100;  // ... can be replaced by   set t2 <- 100;  // ... or even by  t2 <- 100;   // Species can now act as direct containers of their agents..  list<species0> spec_with_location <- species0 select (each.location = { 0, 0 });  species0 agent0 <- species0[10];  write string(agent0);   // ...  and agents as direct containers of their attributes (mimicking the internal attributes map). This virtual map will now contain, in addition to the attributes,   // all the variables loaded from CSV, SQL or shape files (some stored in the agent itself, others in the shape).  agent0[departure] <- { 0, 0 };  write string(agent0);   // Keys are not necessarily strings, by the way ! A warning is emitted in such cases, but it is just a warning.  agent0[0] <- 0;   // Accesses can be combined  species0[10].name <- A new name; // which is equivalent to (spec at 10).name = A new name;   // Points can be used (with or without curly parentheses) to access agents in species  species0 agent1 <- species0[10, 10]; // returns the agent closest to point {10,10} for a regular species  // The behavior is a bit tweaked for grids, to allow for a natural access  my_grid cell0 <- my_grid[10, 10]; // Here, it is the cell at {10, 10} in the matrix of cells   // Shapes also act as containers of CVS/Shapefile attributes (in case they are loaded without being attributed to an agent), as well as 3D properties (for the display).  agent0.name <- string(agent0.shape[ID]);  geometry geom <- square(100);  geom[type] <- cube;      // All these attributes can be accessed using the casting of agents to map  write string(map(agent0));   //This access can be used everywhere, easing the use of shape files (and data files in general)  list<geometry> shapes <- list<geometry>(file(something.shp));   // If we suppose val1, val2, etc. are defined in the shape file  float max <- min(shapes collect float(each[val1]));   //To allow for an easier access in case the modeler only uses agents, agents  attributes can pass through towards their shape s attributes   //(in case the same attribute has not been defined in the agent, of course)  create species0 from: shapes;  max <- min(species0 collect float(each[val1])); // equivalent to each.shape[val1].   //This last sentence only works, however, for *reading* values.  any(species0)[val1] <- 100; // will result in the creation of a new attribute in the agent (not in its shape)  any(species0).shape[val1] <- 100; // will be correct in that case   // Container variables have seen their usability clearly improved   map m <- map([]);  list<int> l <- [1, 2, 3, 4, 5];   // Adding a value  add 1 to: l;  // ... can now be written  l <+ 1;   // Removing a value  remove 1 from: l;  remove type from: geom;   // ... can now be written  l >- 1;  geom >- type;  any(species0)[] >- name; // removes the name attribute from a random agent. Can be dangerous in some cases...    // Setting/putting a value  put a at:  key  in: m;  put 1 at: 0 in: l;  // ... can now be written  m[ key ] <- a;  l[0] <- 1;  list<list> ll <- [];  ll <+ []; // [[]]  ll[0] <+ 10; // [[10]]  }  // TODO Species can now be written within the global section (to enforce the idea that the top-level species are indeed contained in the world) species inside_global { }  /**   * INVOCATION OF ACTIONS   */ reflex calling_actions { // IN IMPERATIVE MODE (i.e. in a statement) // The classic way  do dummy1 with: [a::10, b::100.0];   // Another by distributing the arguments  do dummy1 a: 10 b: 100.0;   // The new alternative one   do dummy1(a: 10, b: 100.0);  ask any(species1) {   do goto(target: { 10, 10 }, speed: 100);  }  // ... which has been introduced to unify the functional/imperative use of actions.   // And finally the new functional way, probably reserved to simple calls (as all the arguments must be passed).  do dummy1(10, 100.0);   // IN FUNCTIONAL MODE (i.e. as part of expressions)  // The classic way of calling actions. Note that in that case, dummy1 is used like a binary operator (callee on the left, argument map on the right)  list d1 <- self dummy1 [a::10, b::100.0];   // First improvement, argument maps can now be simplified, which results in a functional syntax with named arguments  list d2 <- self dummy1 (b: 100.0); // a is not passed as it has a default value.   // To improve the readability of this way of calling actions, the dotted notation is now allowed as well   list d3 <- self.dummy1(a: 100, b: 100.0);  float s <- any(species1).compute_speed_using_an_action(max: 100);   // Finally, the functional syntax is also introduced. In that case, all the arguments need to be passed as they are not named.  // This unifies the way of calling operators and actions furthermore.    // The action can be called as a n_ary operator, and in that case, the callee is implicitely the agent that executes the call  list d4 <- dummy1(10, 100.0);   // And it can also be called using the dotted syntax, in which case the callee needs to be explicit (can be self of course)  path p <- world.move(100, 45, shape); // speed, heading, bounds    /**      *  As a summary, the syntaxes kept for future developments of models will likely be:       */   // CALLING WITH NAMED ARGUMENTS + OPTIONAL DOTTED SYNTAX IN EXPRESSIONS + IMPLICIT CALLEE IN CASE OF SELF   // This method is convenient as it allows to pass only some arguments (if defaults are defined, which is implicitely the case in primitives),    // but also to pass them in any order   do wander(speed: 100, amplitude: 10);   path p1 <- path(self.wander(amplitude: 10, speed: 100));   path p2 <- path(self wander (speed: 100, bounds: square(10)));   path p3 <- path(wander(speed: 100));   path p4 <- path(wander());   // CALLING WITH COMPLETE ARGUMENTS + OPTIONAL DOTTED SYNTAX IN EXPRESSIONS + IMPLICIT CALLEE IN CASE OF SELF  // This method is convenient as it follows the functional syntax of operators and then allows to declare quasi-operators in species, even to redefine existing ones.  do wander(100, 100, self.shape); // speed, amplitude, bounds as defined in primitive wander  int d5 <- self.max(10, 100);  int d6 <- self max (10, 100);  int d7 <- max(10, 100);  list others <- filter(species1);   // As a side note, the new syntax for arguments maps is not only usable in action calls, but also in create, for instance  create species0 with: (location: { 100, 100 }, name: ); }  // The ternary operator (condition) ? statement_if_condition_true : statement_if_condition_false can be used as follow : int max (int i, int j) {  return i > j ? i : j; }  list<agent> filter (container<agent> my_agents) {  return my_agents where (each.location = nil); }  /**   * USE OF OPERATORS    */ reflex operators {  // All the operators can now be written using a function-like form // It is true for unary operators (as before)  bool a <- flip(0.4);  // .. but also for binary ones (in addition to the classic way)  int b <- div(100, 23) + 100 div 23;  geometry c1 <- union(square(1), circle(10));  // The only exception to this rule is that of the built-in operators (like and/or) and the ones whose names are not alphanumeric (like +)   // The big news is that operators are now allowed to be written using any number of parameters (not 1 or 2)  // Here is an example with the between operator (written specially in Java to test this feature)  // @operator(value = between, can_be_const = true)  // public static Boolean between(final Integer a, final Integer inf, final Integer sup) {  //     if ( inf > sup ) { return false; }  //  return a >= sup ? false : a > inf;   // }  bool e1 <- between(5, 1, 10); } /**   * DEFINITION OF ASPECTS   */ aspect default { // draw now accepts any kind of arguments and decides what to do based on the type of the argument  draw circle(1);  draw name;  draw file(image.jpg);   // special units (that take a value in the drawing scope) have been introduced to allow for a better control of the display  // This statement will draw a circle of radius 10 pixels, whatever the level of zoom and size of the display  draw circle(10 °px);  draw Display dimensions:  + °display_width +   + °display_height; }   }  /** Species can  mirror  a list of agents (or another species). That is, their population is dynamically computed after the list or species mirrored. * Their instances, which are actually  proxy  agents, possess an attribute called  target  that points towards the agent they mirror. Very useful for building graphs, for instance. * The update of the population tries to preserve, as much as possible, the existing mapping (that is, proxy agents do not change targets if they do not die or disappear from the list) */ species species0 {  float speed <- float(rnd(1000)); }  species species1 mirrors: species0 skills: [moving] {  point location update: target.location + { 10, 10 };  float speed1 update: self compute_speed_using_an_action (); // No parameter as  max  is defaulted  float speed2 update: compute_speed_using_a_functional_attribute;  float compute_speed_using_a_functional_attribute {   speed of target  }  float compute_speed_using_an_action (int max <- 100) {   return min([max, int(speed of target)]);  }  init {  write I am  + self.name +  and my target is  + target.name; }   }  grid my_grid width: 100 height: 100 { }  experiment exp1 type: gui {  output {   display Display type: opengl {   // Layers include a new keyword,  graphics , that allows to draw arbitrary shapes using the syntax found in the aspects of species   // The same capability will be soon added to species/agents layers (in order to define on-the-fly aspects without changing the species itself)    graphics  G  {     draw sphere(10) at: { 50, 50 };     if (true) {      draw  true ;     } else {      draw  false ;     }    }   }  }   }     ","url":"wiki/Syntax-models-Syntax-(1.6).md"},{"id":"wiki/Syntax-models.md","title":" Syntax models","content":"Syntax models  This sub-section is composed of the following models :   Casting Syntax Lists Maps Syntax      ","url":"wiki/Syntax-models.md"},{"id":"wiki/Ants-(Foraging-and-Sorting)-Ant-Foraging-(Charts-examples).md","title":" Ant Foraging (Charts examples)","content":"# Ant Foraging (Charts examples)  _Author : _  Toy Model ant using the question of how ants search food and use pheromons to return to their nest once they did find food. In this model, the charts are particularly used.   Code of the model :      model ants  global {  //Number of ants  int ants_number <- 100 min: 1 max: 2000 ;  //Evaporation value per cycle for the pheromons  float evaporation_per_cycle <- 5.0 min: 0.0 max: 240.0 ;  //Diffusion rate for the pheromons  float diffusion_rate <- 1.0 min: 0.0 max: 1.0 ;  bool use_icons <- true ;  bool display_state <- true;  //Size of the grid  int gridsize <- 75 ;  //Center of the grid to put the location of the nest  const center type: point <- { (gridsize / 2),  (gridsize / 2)} ;  const types type: file <- (pgm_file( ../images/environment75x75.pgm )) ;  const ant_shape_empty type: string <-  ../icons/ant.png  ;  const ant_shape_full type: string <-  ../icons/full_ant.png   ;  const C00CC00 type: rgb <- rgb( #00CC00 ) ;    const C009900 type: rgb <- rgb( #009900 ) ;   const C005500 type: rgb <- rgb( #005500 ) ;   int food_gathered <- 0 ;   geometry shape <- square(gridsize);  init{   //Ant are placed randomly in the nest   create ant number: ants_number with: [location::any_location_in (ant_grid(center))] ;  }  //Reflex to diffuse the road of pheromon on the grid reflex diffuse {   diffuse var:road on:ant_grid proportion: diffusion_rate radius:2 propagation: gradient;    }   }  //Grid to discretize space for the food and the nest grid ant_grid width: gridsize height: gridsize neighbors: 8 use_regular_agents: false {  bool multiagent <- true ;  float road <- 0.0 max:240.0 update: (road<=evaporation_per_cycle) ? 0.0 : road-evaporation_per_cycle;  int type <- int(types at {grid_x,grid_y}) ;  bool isNestLocation <- (self distance_to center) < 4 ;   bool isFoodLocation <- type = 2 ;   rgb color <- isNestLocation ? °violet:((food > 0)? °blue : ((road < 0.001)? rgb ([100,100,100]) : ((road > 2)? °white : ((road > 0.5)? (C00CC00) : ((road > 0.2)? (C009900) : (C005500)))))) update: isNestLocation ? °violet:((food > 0)? °blue : ((road < 0.001)? rgb ([100,100,100]) : ((road > 2)? °white : ((road > 0.5)? (C00CC00) : ((road > 0.2)? (C009900) : (C005500)))))) ;  int food <- isFoodLocation ? 5 : 0 ;  const nest type: int <- 300 - int(self distance_to center) ;  } //Species ant that will move and follow a final state machine species ant skills: [moving] control: fsm {  float speed <- 2.0 ;  ant_grid place update: ant_grid (location );   string im <-  ant_shape_empty  ;  bool hasFood <- false ;  reflex diffuse_road when:hasFood=true{       ant_grid(location).road <- ant_grid(location).road + 100.0;    }    //Action to pick food  action pick {   im <- ant_shape_full ;   hasFood <- true ;   place.food <- place.food - 1 ;  }  //Action to drop food  action drop {   food_gathered <- food_gathered + 1 ;   hasFood <- false ;   heading <- heading - 180 ;  }  //Action to chose the best place according to the possible food in the neighbour cells  action choose_best_place type: ant_grid {   list list_places <- place.neighbors ;   if (list_places count (each.food > 0)) > 0  {    return (list_places first_with (each.food > 0)) ;   } else {     int min_nest  <-  (list_places min_of (each.nest)) ;     list_places <- list_places sort ((each.nest = min_nest) ? each.road :  0.0) ;     return last(list_places) ;    }  }  //Initial state of the ant : wander until it finds food or find a road to follow state wandering initial: true {  do wander amplitude:120 ;  transition to: carryingFood when: place.food > 0 {   do pick ;  }  transition to: followingRoad when: place.road > 0.05 ; } //State to carry food to the nest once the food is found state carryingFood {  do goto target: center ;  transition to: wandering when: place.isNestLocation {    do drop ;  } } //State to follow a road  state followingRoad {  location <- (self choose_best_place []) as point ;  transition to: carryingFood when: place.food > 0 {   do pick ;  }  transition to: wandering when: (place.road < 0.05) ; } aspect text {  if use_icons {   draw  hasFood ? file(ant_shape_full) : file(ant_shape_empty) rotate: heading at: location size: {7,5} ;  } else {   draw circle(1.0) empty: !hasFood color: rgb ( orange ) ;  }  if display_state {   draw state at: location + {-3,1.5} color: °white size: 0.8 ;  } } aspect default {  draw circle(1.0) empty: !hasFood color: #orange ;  } } experiment Ant type: gui { //Parameters to play with  in the gui parameter  Number of ants:  var: ants_number category:  Model  ; parameter  Evaporation of the signal (unit/cycle):  var: evaporation_per_cycle category:  Model  ; parameter  Rate of diffusion of the signal (%/cycle):  var: diffusion_rate category:  Model  ; parameter  Use icons for the agents:  var: use_icons category:  Display  ; parameter  Display state of agents:  var: display_state category:  Display  ;  list<list<int>> nbants<-[[0]]; list<string> statesnames<-[]; list<string> categnames<-[empty,carry]; list<list<int>> nbantsbydist<-[[0]]; list xytestvallist<-[[[1,1],[2,2],[3,3]],[[1,2],[2,1],[3,4]],[[1,3],[2,3],[0,1]],[[1,4],[2,5],[0,0]]]; list<list<int>> xyval<-[[1,1],[2,1],[3,2]];  //Reflex to update the charts, belonging to the experiment bloc as it will not be used by other experiment which don t have the charts reflex update_charts {  nbants<-[];  statesnames<-[];  categnames<-[empty,carry];  nbantsbydist<-[];  ant x<-one_of(world.ant);  loop x over:list(world.ant)  {   if !(statesnames contains (x.state))   {       add [(list(ant) count (each.state=x.state and !each.hasFood)),(list(ant) count (each.state=x.state and each.hasFood))] to: nbants;   add (x.state) to:statesnames;       int d<-0;   list<int> nl<-[];   loop d from:0 to:9    {   add (list(ant) count (each.state=x.state and (((each distance_to center)>gridsize/20*d) and ((each distance_to center)<gridsize/20*(d+1))))) to: nl;    }   add nl to:nbantsbydist;   } //   add length((list(world.ant) collect (each.next_place distance_to each.location)) where (each=x)) to:nbants;  }  //write(nbants+nbants);  //write(nbantsbydist+nbantsbydist);  //write(states+statesnames);   } //The different displays output {  display Ants type: opengl {   grid ant_grid ;   species ant aspect: text ;  }  display ChartPie {   chart DataPie type:pie   {    data empty_ants value:(list(ant) count (!each.hasFood)) color:°red;    data carry_food_ants value:(list(ant) count (each.hasFood)) color:°green;       }      }  display ChartPieList {   chart DataListPie type:pie style:exploded   {    datalist [empty,carry] value:[(list(ant) count (!each.hasFood)),(list(ant) count (each.hasFood))] color:[°red,°green];       }  }  display ChartHisto {   chart DataBar type:histogram   {    data empty_ants value:(list(ant) count (!each.hasFood)) color:°red;    data carry_food_ants value:(list(ant) count (each.hasFood)) color:°green;       }      }  display ChartHistoList {   chart DataListBar type:histogram style:3d   {    datalist [empty,carry] value:[(list(ant) count (!each.hasFood)),(list(ant) count (each.hasFood))] color:[°red,°green];       }  }  display ChartHistoListList {   chart DataListListBar type:histogram   {    datalist categoriesnames:categnames  value:nbants legend:statesnames inverse_series_categories :false style:stack;   }  }  display ChartSerie {   chart DataSeries type:series   {    data empty_ants value:float((list(ant) count (!each.hasFood))) color:°red;    data carry_food_ants value:float((list(ant) count (each.hasFood))) color:°green;       }      }   display Dispscaleoption  {   chart simpleserieslist type:series  y_range:{-6.11, -4.11} x_tick_unit:0.5 y_tick_unit:0.05   {    data value:[-5,-6,-8] legend:prems color:°blue marker_shape:marker_square fill:false;    data value:[-5.5,-4.11,-5.645] legend:sec color:°red marker_shape:marker_empty;    data value:[-7,-6,-4.654] legend:third color:°green marker_shape:marker_hor_ellipse fill:false;   }  }  display Cyclevalues  {   chart simplecyclelist type:xy x_tick_unit:0.5 y_tick_unit:0.5   {    data value:{-5+cycle,-4} legend:prems color:°blue marker_shape:marker_square fill:false;    data value:{-5.5+cycle,-3.5} legend:sec color:°red marker_shape:marker_diamond;    data value:{-7+cycle,-4.654} legend:third color:°green marker_shape:marker_hor_ellipse fill:false;   }  }   display ChartSerieList {   chart DataListSeries type:series   {    datalist [food,empty] value:[(list(ant) count (each.hasFood)),(list(ant) count (!each.hasFood))] color:[°purple,°black] style:area;       }  }  display ChartSeriesListList {   chart DataListListSeries type:series   {    datalist categoriesnames:categnames  value:nbants legend:statesnames inverse_series_categories :false style:line;   }  }  display ChartScatter {   chart DataScatter type:scatter   {    data empty_ants value:((list(ant) where (!each.hasFood)) collect each.location) color:°red line_visible:false;    data carry_food_ants value:((list(ant) where (each.hasFood)) collect each.location) color:°green line_visible:false;       }      }  display ChartScatterList {   chart DataListScatter type:scatter   {    datalist [empty,carry] value:[((list(ant) where (!each.hasFood))  collect each.location),((list(ant) where (each.hasFood))  collect each.location)] color:[°red,°green] line_visible:false;       }  }  display ChartScatterHistory {   chart DataListScatterHistory type:scatter   {    datalist [empty,carry] value:[mean((list(ant) where (!each.hasFood)) collect each.location),mean((list(ant) where (each.hasFood)) collect each.location)]      color:[°red,°green] line_visible:true;       }  }   }  }   //Experiment with only two display : the grid and the ants, and a chart experiment AntOneDisp type: gui {  parameter  Number of ants:  var: ants_number category:  Model  ;  parameter  Evaporation of the signal unit/cycle):  var: evaporation_per_cycle category:  Model  ;  parameter  Rate of diffusion of the signal (%/cycle):  var: diffusion_rate category:  Model  ;  parameter  Use icons for the agents:  var: use_icons category:  Display  ;  parameter  Display state of agents:  var: display_state category:  Display  ;  list<list<int>> nbants<-[[0]]; list<string> statesnames<-[]; list<string> categnames<-[empty,carry]; list<list<int>> nbantsbydist<-[[0]]; list xytestvallist<-[[[1,1],[2,2],[3,3]],[[1,2],[2,1],[3,4]],[[1,3],[2,3],[0,1]],[[1,4],[2,5],[0,0]]]; list<list<int>> xyval<-[[1,1],[2,1],[3,2]];  reflex update_charts {  ant x<-one_of(world.ant);  loop x over:list(world.ant)  {   if !(statesnames contains (x.state))   {       add [(list(ant) count (each.state=x.state and !each.hasFood)),(list(ant) count (each.state=x.state and each.hasFood))] to: nbants;   add (x.state) to:statesnames;       int d<-0;   list<int> nl<-[];   loop d from:0 to:9    {   add (list(ant) count (each.state=x.state and (((each distance_to center)>gridsize/20*d) and ((each distance_to center)<gridsize/20*(d+1))))) to: nl;    }   add nl to:nbantsbydist;   }  }  write(nbants+nbants);  write(nbantsbydist+nbantsbydist);  write(states+statesnames);   } output {  display Ants type: opengl {   grid ant_grid ;   species ant aspect: text ;  }   display ChartSerieList {   chart DataListScatterHistory type:scatter   {    datalist [empty,carry] value:[mean((list(ant) where (!each.hasFood)) collect each.location),mean((list(ant) where (each.hasFood)) collect each.location)]      color:[°red,°green] line_visible:true;       }  } } }       ","url":"wiki/Ants-(Foraging-and-Sorting)-Ant-Foraging-(Charts-examples).md"},{"id":"wiki/Ants-(Foraging-and-Sorting)-Ant-Foraging-(Classic).md","title":" Ant Foraging (Classic)","content":"# Ant Foraging (Classic)  _Author : _  Toy Model ant using the question of how ants search food and use pheromons to return to their nest once they did find food. This model is considered as the classic one.  Code of the model :      model ants  global {  //Number of ants  int ants_number <- 100 min: 1 max: 2000 ;  //Evaporation value per cycle  float evaporation_per_cycle <- 5.0 min: 0.0 max: 240.0 ;  //Diffusion rate for the pheromon diffused among the grid  float diffusion_rate <- 0.5 min: 0.0 max: 1.0 ;  bool use_icons <- true ;  bool display_state <- true;  //Size of the grid  int gridsize <- 75 ;  //Center of the grid that will be used as a nest for the ants  point center const: true <- { (gridsize / 2),  (gridsize / 2)} ;  file types const: true <- (pgm_file( ../images/environment75x75.pgm )) ;  string ant_shape_empty const: true <-  ../icons/ant.png  ;  string ant_shape_full const: true <-  ../icons/full_ant.png   ;  rgb C00CC00 const: true <- rgb( #00CC00 ) ;    rgb C009900 const: true <- rgb( #009900 ) ;   rgb C005500 const: true <- rgb( #005500 ) ;   int food_gathered <- 0 ;    geometry shape <- square(gridsize);  init{   //Creation of the ants that will be placed randomly in the nest   create ant number: ants_number with: [location::any_location_in (ant_grid(center))] ;  }  //Reflex to diffuse the pheromon among the grid  reflex diffuse {       diffuse var:road on:ant_grid proportion: diffusion_rate radius:2 propagation: gradient;    }  }  //Grid that will be used to place the food in a discretized space grid ant_grid width: gridsize height: gridsize neighbors: 8 use_regular_agents: false {  list neighbours <- self neighbors_at 1;  float road <- 0.0 max:240.0 update: (road<=evaporation_per_cycle) ? 0.0 : road-evaporation_per_cycle;  int type <- int(types at {grid_x,grid_y}) ;  bool isNestLocation <- (self distance_to center) < 4 ;  bool isFoodLocation <- type = 2 ;   rgb color <- isNestLocation ? °sienna:((food > 0)? °brown : ((road < 0.001)? #darkgoldenrod: ((road > 2)? °white : ((road > 0.5)? (C00CC00) : ((road > 0.2)? (C009900) : (C005500)))))) update: isNestLocation ? °sienna:((food > 0)? °brown : ((road < 0.001)?#darkgoldenrod : ((road > 2)? °white : ((road > 0.5)? (C00CC00) : ((road > 0.2)? (C009900) : (C005500)))))) ;  int food <- isFoodLocation ? 5 : 0 ;  int nest const: true <- 300 - int(self distance_to center) ;  } //Species ant that will move and follow a final state machine species ant skills: [moving] control: fsm {  float speed <- 2.0 ;  ant_grid place update: ant_grid (location );   string im <-  ant_shape_empty  ;  bool hasFood <- false ;  //Reflex to allow the diffusion of the road of pheromon by putting pheromon inside a cell  reflex diffuse_road when:hasFood=true{       ant_grid(location).road <- ant_grid(location).road + 100.0;    }    //Action to pick the food  action pick {   im <- ant_shape_full ;   hasFood <- true ;   place.food <- place.food - 1 ;  }  //Action to drop the food  action drop {   food_gathered <- food_gathered + 1 ;   hasFood <- false ;   heading <- heading - 180 ;  }  //Action to find the best cell in the neighbourhood of the ant  action choose_best_place type: ant_grid {   list list_places <- place.neighbours ;   if (list_places count (each.food > 0)) > 0  {     return (list_places first_with (each.food > 0)) ;   } else {     int min_nest  <-  (list_places min_of (each.nest)) ;     list_places <- list_places sort ((each.nest = min_nest) ? each.road :  0.0) ;     return last(list_places) ;    }  }   //initial state of the ant that will make it wander until it finds food or a road  state wandering initial: true {    do wander amplitude:120 ;   transition to: carryingFood when: place.food > 0 {    do pick ;  }  transition to: followingRoad when: place.road > 0.05 ;  } //State to carry food to the nest once it has been found state carryingFood {  do goto target: center ;  transition to: wandering when: place.isNestLocation {    do drop ;  } } //State to follow a pheromon road once it has been found state followingRoad {  location <- (self choose_best_place()) as point ;  transition to: carryingFood when: place.food > 0 {   do pick ;  }  transition to: wandering when: (place.road < 0.05) ; } aspect text {  if use_icons {   draw  hasFood ? file(ant_shape_full) : file(ant_shape_empty) rotate: heading at: location size: {8,5} ;  } else {   draw circle(1.0) empty: !hasFood color: rgb ( orange ) ;  }  if display_state {   draw state at: location + {-3,1.5} color: °white font: font(Helvetica, 14 * #zoom, #plain) perspective:true;  } }  aspect default {  draw circle(1.0) empty: !hasFood color: #orange ;  }  }   experiment Ant type: gui {  parameter  Number of ants:  var: ants_number category:  Model  ;  parameter  Evaporation of the signal (unit/cycle):  var: evaporation_per_cycle category:  Model  ;  parameter  Rate of diffusion of the signal (%/cycle):  var: diffusion_rate category:  Model  ;  parameter  Use icons for the agents:  var: use_icons category:  Display  ;  parameter  Display state of agents:  var: display_state category:  Display  ;  output {   display Ants type: opengl  {    grid ant_grid ;    species ant aspect: text ;   }  } }      ","url":"wiki/Ants-(Foraging-and-Sorting)-Ant-Foraging-(Classic).md"},{"id":"wiki/Ants-(Foraging-and-Sorting)-Ant-Foraging-(Complex).md","title":" Ant Foraging (Complex)","content":"# Ant Foraging (Complex)  _Author : _  Toy Model ant using the question of how ants search food and use pheromons to return to their nest once they did find food. Two experiments are proposed to show how to use batch : Batch and Genetic.  Code of the model :      model ants  global {  //Evaporation value per cycle  float evaporation_per_cycle <- 5.0 min: 0.0 max: 240.0 parameter:  Evaporation of the signal (unit/cycle):  category:  Signals ;  //Diffusion rate of the pheromon among the grid  float diffusion_rate <- 1.0 min: 0.0 max: 1.0 parameter:  Rate of diffusion of the signal (%/cycle):  category:  Signals ;  //Size of the grid  int gridsize <- 100 min: 30 parameter:  Width and Height of the grid:  category:  Environment and Population ;  //Number of ants  int ants_number <- 200 min: 1 parameter:  Number of ants:  category:  Environment and Population ;  //Frequency of update of the grid  int grid_frequency <- 1 min: 1 max: 100 parameter:  Grid updates itself every:  category:  Environment and Population ;  //Number of food places among the grid  int number_of_food_places <- 5 min: 1 parameter:  Number of food depots:  category:  Environment and Population ;  float grid_transparency <- 1.0;  file ant_shape_empty const: true <- file( ../icons/ant.png );  image_file ant_shape_full const: true <- file( ../icons/full_ant.png );  //The center of the grid that will be considered as the nest location  point center const: true <- { round(gridsize / 2), round(gridsize / 2) };  int food_gathered <- 1;  int food_placed <- 1;  rgb background const: true <- rgb(#99CC66);  rgb food_color const: true <- rgb(#312200);  rgb nest_color const: true <- rgb(#000000);  geometry shape <- square(gridsize); init {  //Creation of the food places placed randomly with a certain distance between each  loop times: number_of_food_places {   point loc <- { rnd(gridsize - 10) + 5, rnd(gridsize - 10) + 5 };   list<ant_grid> food_places <- (ant_grid where ((each distance_to loc) < 5));   ask food_places {    if food = 0 {     food <- 5;     food_placed <- food_placed + 5;     color <- food_color;      }      }  }  //Creation of the ants that will be placed in the nest  create ant number: ants_number with: (location: center); } //Reflex to diffuse the pheromon among the grid reflex diffuse {   diffuse var:road on:ant_grid proportion: diffusion_rate radius:3 propagation: gradient method:convolution;    }   }  //Grid used to discretize the space to place food grid ant_grid width: gridsize height: gridsize neighbors: 8 frequency: grid_frequency use_regular_agents: false use_individual_shapes: false{  bool is_nest const: true <- (topology(ant_grid) distance_between [self, center]) < 4;  float road <- 0.0 max: 240.0 update: (road <= evaporation_per_cycle) ? 0.0 : road - evaporation_per_cycle;  rgb color <- is_nest ? nest_color : ((food > 0) ? food_color : ((road < 0.001) ? background : rgb(#009900) + int(road * 5))) update: is_nest ? nest_color : ((food > 0) ?  food_color : ((road < 0.001) ? background : rgb(#009900) + int(road * 5)));  int food <- 0; } //Species ant that will move and follow a final state machine species ant skills: [moving] control: fsm {  float speed <- 1.0;  bool has_food <- false;  //Reflex to place a pheromon stock in the cell reflex diffuse_road when:has_food=true{   ant_grid(location).road <- ant_grid(location).road + 100.0;    } //Action to pick food action pick (int amount) {  has_food <- true;  ant_grid place <- ant_grid(location);  place.food <- place.food - amount; } //Action to drop food action drop {  food_gathered <- food_gathered + 1;  has_food <- false;  heading <- heading - 180; } //Action to find the best place in the neighborhood cells point choose_best_place {  container list_places <- ant_grid(location).neighbors;  if (list_places count (each.food > 0)) > 0 {   return point(list_places first_with (each.food > 0));  } else {   list_places <- (list_places where ((each.road > 0) and ((each distance_to center) > (self distance_to center)))) sort_by (each.road);   return point(last(list_places));  }  } //Reflex to drop food once the ant is in the nest reflex drop when: has_food and (ant_grid(location)).is_nest {  do drop(); } //Reflex to pick food when there is one at the same location reflex pick when: !has_food and (ant_grid(location)).food > 0 {  do pick(1); } //Initial state to make the ant wander  state wandering initial: true {  do wander(amplitude: 90);  float pr <- (ant_grid(location)).road;  transition to: carryingFood when: has_food;  transition to: followingRoad when: (pr > 0.05) and (pr < 4); } //State to carry food once it has been found state carryingFood {  do goto(target: center);  transition to: wandering when: !has_food; } //State to follow a pheromon road if once has been found state followingRoad {  point next_place <- choose_best_place();  float pr <- (ant_grid(location)).road;  location <- next_place;  transition to: carryingFood when: has_food;  transition to: wandering when: (pr < 0.05) or (next_place = nil); }  aspect info {  draw circle(1) empty: !has_food color: #red;  if (destination != nil) {   draw line([location + {0,0,0.5}, destination + {0,0,0.5}]) + 0.1 color: #white border: false;  }   draw circle(4) empty: true color: #white;  draw string(self as int) color: #white font: font(Helvetica, 12 * #zoom, #bold) at: my location - {1, 1, -0.5};  draw state color: #yellow  font: font(Helvetica, 10 * #zoom, #plain) at: my location + { 1, 1, 0.5 } perspective: false; }  aspect icon {  draw ant_shape_empty size: {7,5} rotate: my heading + 1; }  aspect default {  draw square(1) empty: !has_food color: #blue rotate: my heading; } }  //Simple experiment to display the ants experiment Displays type: gui { point quadrant_size <- { 0.5, 0.5 }; float inc <- 0.001; float pos <- 0.0; reflex moving_quadrant { //pos <- pos + inc;  if (pos > 0.5 or pos <= 0) {   inc <- -inc;  }   }  output {  display Ants background: #white type: opengl {   image  ../images/soil.jpg  position: { pos, pos } size: quadrant_size;   agents agents transparency: 0.5 position: { pos, pos } size: quadrant_size value: (ant_grid as list) where ((each.food > 0) or (each.road > 0) or (each.is_nest));   species ant position: { pos, pos } size: quadrant_size aspect: icon;   grid ant_grid lines: #darkgray position: { 0.5, 0 } size: quadrant_size;   species ant position: { 0.5, 0 } size: quadrant_size aspect: info;  } } } //Complete experiment that will inspect all ants in a table experiment Complete type: gui { parameter  Number:  var: ants_number init: 100 unit:  ants  category:  Environment and Population ; parameter  Grid dimension:  var: gridsize init: 100 unit:  (number of rows and columns)  category:  Environment and Population ; parameter  Number of food depots:  var: number_of_food_places init: 5 min: 1 category:  Environment and Population ;  // Experimentator  init {  write Experimentator agent running  + self;    ants_number <- 200; }   output {  display Ants2D type: java2D {   image  ../images/soil.jpg  position: { 0.05, 0.05 } size: { 0.9, 0.9 };   agents agents transparency: 0.7 position: { 0.05, 0.05 } size: { 0.9, 0.9 } value: (ant_grid as list) where ((each.food > 0) or (each.road > 0) or (each.is_nest)) ;   species ant position: { 0.05, 0.05 } size: { 0.9, 0.9 } aspect: icon;   overlay Texts transparency: 0.3 background: rgb (99, 85, 66,255)  position: {10°px, 10°px} size: {250°px, 150°px} border: rgb (99, 85, 66,255) rounded: true{    draw ant_shape_full at: {60°px, 70°px} size: {140°px, 100°px} rotate: -60;    draw ( Food foraged:   + (((food_placed = 0 ? 0 : food_gathered / food_placed) * 100) with_precision 2) +  % ) at: {40°px,70°px} font:font(Arial, 18, #bold) color: #white;    draw ( Carrying ants:   + (((100 * ant count (each.has_food or each.state = followingRoad)) / length(ant)) with_precision 2) +  % ) at: {40°px, 100°px} font:font(Arial, 18 , #bold) color: #white;   }       }  inspect All ants type: table value: ant attributes: [ name ,  location ,  heading , state ]; } } //Batch experiment to find the best way to maximize the food gathered using exhaustive method experiment Batch type: batch repeat: 4 keep_seed: true until: (food_gathered = food_placed) or (time > 1000) { parameter  Size of the grid:  var: gridsize init: 75 unit:  width and height ; parameter  Number:  var: ants_number among:[10,20,50] unit:  ants ; parameter   Evaporation:  var: evaporation_per_cycle among: [0.1, 0.5, 2.0, 10.0] unit:  units every cycle ; parameter   Diffusion:  var: diffusion_rate min: 0.1 max: 1.0 unit:  rate every cycle (1.0 means 100%)  step: 0.2; method exhaustive maximize: food_gathered;   permanent {  display Comparison background: #white {   chart Food Gathered type: series {     data Min value:  min(ants_model collect each.food_gathered ) style: spline color: #darkgreen ;     data Max value:  max(ants_model collect each.food_gathered ) style: spline color: #red ;   }  } } }   //Batch experiment to find the best way to maximize the food gathered using genetic method experiment Genetic type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed) or (time > 1000) {  parameter  Size of the grid:  var: gridsize init: 75 unit:  (width and height) ;  parameter  Number:  var: ants_number among:[10,20,50] unit:  ants ;  parameter   Evaporation:  var: evaporation_per_cycle among: [0.1, 0.5, 2.0, 10.0] unit:  units every cycle ;  parameter  Diffusion:  var: diffusion_rate min: 0.1 max: 1.0 unit:  rate every cycle (1.0 means 100%)  step: 0.2;  method genetic maximize: food_gathered pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 20;   permanent {  display Comparison background: #white {   chart Food Gathered type: series {     data Min value:  min(ants_model collect each.food_gathered ) style: spline color: #darkgreen ;     data Max value:  max(ants_model collect each.food_gathered ) style: spline color: #red ;   }  } } }       ","url":"wiki/Ants-(Foraging-and-Sorting)-Ant-Foraging-(Complex).md"},{"id":"wiki/Ants-(Foraging-and-Sorting)-Ant-Foraging-(Multi-Simulation).md","title":" Ant Foraging (Multi-Simulation)","content":"# Ant Foraging (Multi-Simulation)  _Author : _  Toy Model ant using the question of how ants search food and use pheromons to return to their nest once they did find food.  Code of the model :      model ants  global {  //Evaporation value per cycle of the pheromons  float evaporation_per_cycle <- 5.0 min: 0.0 max: 240.0 parameter:  Evaporation of the signal (unit/cycle):  category:  Signals ;  //Diffusion rate of the pheromons  float diffusion_rate <- 1.0 min: 0.0 max: 1.0 parameter:  Rate of diffusion of the signal (%/cycle):  category:  Signals ;  //Size of the grid  int gridsize <- 100 min: 30 parameter:  Width and Height of the grid:  category:  Environment and Population ;  //Number of ants that will be created  int ants_number <- 50 min: 1 parameter:  Number of ants:  category:  Environment and Population ;  //Number of food places to create  int number_of_food_places <- 5 min: 1 parameter:  Number of food depots:  category:  Environment and Population ;  float grid_transparency <- 1.0;  file ant_shape_empty const: true <- file( ../icons/ant.png );  string ant_shape_full const: true <-  ../icons/full_ant.png ;  point center const: true <- { round(gridsize / 2), round(gridsize / 2) };  int food_gathered  <- 1;  int food_placed  <- 1;  rgb background const: true <- rgb(#99CC66);  rgb food_color const: true <- rgb(#312200);  rgb nest_color const: true <- rgb(#000000);  geometry shape <- square(gridsize); init {  //Creation of the food places placed randomly with a certain distance between each  loop times: number_of_food_places {   point loc <- { rnd(gridsize - 10) + 5, rnd(gridsize - 10) + 5 };   list<ant_grid> food_places <- (ant_grid where ((each distance_to loc) < 5));   ask food_places {    if food = 0 {     food <- 5;     food_placed <- food_placed + 5;     color <- food_color;      }      }  }  //Creation of the ants that will be placed in the nest  create ant number: ants_number with: (location: center);  //Write the index of the simulation  write Simulation  + int(self) +  created; } //Reflex to diffuse the pheromon among the grid reflex diffuse {   diffuse var:road on:ant_grid proportion: diffusion_rate radius:2 propagation: gradient;    }   }  //Grid used to discretize the space to place food grid ant_grid width: gridsize height: gridsize neighbors: 8 /frequency: grid_frequency/ use_regular_agents: false use_individual_shapes: false{  bool is_nest const: true <- (topology(ant_grid) distance_between [self, center]) < 4;  float road <- 0.0 max:240.0 update: (road<=evaporation_per_cycle) ? 0.0 : road-evaporation_per_cycle;  rgb color <- is_nest ? nest_color : ((food > 0) ? food_color : ((road < 0.001) ? background : rgb(#009900) + int(road * 5))) update: is_nest ? nest_color : ((food > 0) ?  food_color : ((road < 0.001) ? background : rgb(#009900) + int(road * 5)));  int food <- 0; } //Species ant that will move and follow a final state machine species ant skills: [moving] control: fsm {  float speed <- 1.0;  bool has_food <- false;  //Reflex to place a pheromon stock in the cell reflex diffuse_road when:has_food=true{   ant_grid(location).road <- ant_grid(location).road + 100.0;    } //Action to pick food action pick (int amount) {  has_food <- true;  ant_grid place <- ant_grid(location);  place.food <- place.food - amount; } //Action to drop food action drop {  food_gathered <- food_gathered + 1;  has_food <- false;  heading <- heading - 180; } //Action to find the best place in the neighborhood cells  point choose_best_place {  list<ant_grid> list_places <- ant_grid(location).neighbors;  if (list_places count (each.food > 0)) > 0 {   return point(list_places first_with (each.food > 0));  } else {   list_places <- (list_places where ((each.road > 0) and ((each distance_to center) > (self distance_to center)))) sort_by (each.road);   return point(last(list_places));  } } //Reflex to drop food once the ant is in the nest  reflex drop when: has_food and (ant_grid(location)).is_nest {  do drop(); } //Reflex to pick food when there is one at the same location reflex pick when: !has_food and (ant_grid(location)).food > 0 {  do pick(1); } //Initial state to make the ant wander  state wandering initial: true {  do wander(amplitude: 90);  float pr <- (ant_grid(location)).road;  transition to: carryingFood when: has_food;  transition to: followingRoad when: (pr > 0.05) and (pr < 4); } //State to carry food once it has been found state carryingFood {  do goto(target: center);  transition to: wandering when: !has_food; } //State to follow a pheromon road if once has been found state followingRoad {  point next_place <- choose_best_place();  float pr <- (ant_grid(location)).road;  location <- next_place;  transition to: carryingFood when: has_food;  transition to: wandering when: (pr < 0.05) or (next_place = nil); }  aspect icon {  draw ant_shape_empty size: {8,6} rotate: my heading + 1; }   }  //Experiment to show how to make multi simulations experiment  4 Simulations  type: gui {  parameter  Number:  var: ants_number init: 100 unit:  ants  category:  Environment and Population ;  parameter  Grid dimension:  var: gridsize init: 100 unit:  (number of rows and columns)  category:  Environment and Population ;  parameter  Number of food depots:  var: number_of_food_places init: 5 min: 1 category:  Environment and Population ;  // We create three supplementary simulations using the species name  ants_model  (automatically created from the name of the model +  _model )  init {  create ants_model with: [ants_number::200,evaporation_rate::0.7,diffusion_rate::0.2];  create ants_model with: [ants_number::50,evaporation_rate::0.05,diffusion_rate::0.8];  create ants_model with: [ants_number::10,evaporation_rate::0.3,diffusion_rate::0.6]; }  permanent {  display Comparison background: #white {   chart Food Gathered type: series {    loop s over: simulations {     data Food  + int(s) value: s.food_gathered color: s.color marker: false style: line ;    }   }  } }   output {  display Ants background: #white type: opengl{   image  ../images/soil.jpg  position: { 0.05, 0.05 } size: { 0.9, 0.9 };   agents agents transparency: 0.5 position: { 0.05, 0.05 } size: { 0.9, 0.9 } value: (ant_grid as list) where ((each.food > 0) or (each.road > 0) or (each.is_nest));   species ant position: { 0.05, 0.05 } size: { 0.9, 0.9 } aspect: icon;  }  } }       ","url":"wiki/Ants-(Foraging-and-Sorting)-Ant-Foraging-(Multi-Simulation).md"},{"id":"wiki/Ants-(Foraging-and-Sorting)-Ant-Foraging-(Simple).md","title":" Ant Foraging (Simple)","content":"# Ant Foraging (Simple)  _Author : _  Toy Model ant using the question of how ants search food and use pheromons to return to their nest once they did find food. This model is the simple one.  Code of the model :      model ants  global {  int t <- 1;  //Evaporation value per cycle of the pheromons  float evaporation_per_cycle <- 5.0 min: 0.01 max: 240.0 ;  //Diffusion rate of the pheromons  float diffusion_rate const: true <- 1.0 min: 0.0 max: 1.0 ;  //Size of the grid  int gridsize const: true <- 75;   //Number of ants to create  int ants_number  <- 50 min: 1 max: 200 parameter:  Number of Ants: ;  //Variable to keep information about the food remaining  int food_remaining update: list ( ant_grid ) count ( each . food > 0) <- 10;  //Center of the grid that will be considered as the nest of ants  point center const: true <- { round ( gridsize / 2 ) , round ( gridsize / 2 ) };  matrix types <- matrix (pgm_file (  ../images/environment75x75_scarce.pgm  ));  geometry shape <- square(gridsize);  init {  //Creation of the ants placed in the nest  create ant number: ants_number with: [ location :: center ]; }   //Different actions triggered by an user interaction action press (point loc, list selected_agents) {  write(press  + loc.x +   + loc.y +  +selected_agents); } action release (point loc, list selected_agents) {  write(release); } action click  (point loc, list selected_agents) {  write(click); } action click2   (point loc, list selected_agents) {  write(click2); } //Reflex to diffuse the pheromons among the grid reflex diffuse {   diffuse var:road on:ant_grid proportion: diffusion_rate radius:2 propagation: gradient;    }   }  //Grid used to discretize space to place food in cells grid ant_grid width: gridsize height: gridsize neighbors: 8 {  bool isNestLocation  <- ( self distance_to center ) < 4;  bool isFoodLocation <-  types[grid_x , grid_y] = 2;       list neighbours <- self neighbors_at 1;    float road <- 0.0 max:240.0 update: (road<=evaporation_per_cycle) ? 0.0 : road-evaporation_per_cycle;  rgb color <- rgb([ self.road > 15 ? 255 : ( isNestLocation ? 125 : 0 ) , self.road * 30 , self.road > 15 ? 255 : food * 50 ]) update: rgb([ self.road > 15 ? 255 : ( isNestLocation ? 125 : 0 ) ,self.road * 30 , self.road > 15 ? 255 : food * 50 ]);   int food <- isFoodLocation ? 5 : 0;   int nest const: true <- int(300 - ( self distance_to center )); }  //Species ant that will move species ant skills: [ moving ] {     rgb color <- #red;  ant_grid place function: {ant_grid ( location )};  bool hasFood <- false;   bool hasRoad <- false update: place . road > 0.05;  //Reflex to diffuse pheromon on the cell once the agent has food reflex diffuse_road when:hasFood=true{   ant_grid(location).road <- ant_grid(location).road + 100.0;    } //Reflex to wander while the ant has no food reflex wandering when: ( ! hasFood ) and ( ! hasRoad ) and ( place . food = 0) {  do wander amplitude: 120 speed: 1.0; } //Reflex to search food when the agent has no food nor pheromon road close reflex looking when: ( ! hasFood ) and ( hasRoad ) and ( place . food = 0 ) {   list<ant_grid> list_places <- place . neighbours;  ant_grid goal <- list_places first_with ( each . food > 0 );  if goal != nil {   location <- goal.location ;   } else {   int min_nest <- ( list_places min_of ( each . nest ) );   list_places <- list_places sort ( ( each . nest = min_nest ) ? each . road : 0.0 ) ;   location <- point ( last ( list_places ) ) ;  } } //Reflex to take food reflex taking when: ( ! hasFood ) and ( place . food > 0 ) {   hasFood <- true ;  place . food <- place . food - 1 ; } //Reflex to make the ant return to the nest once it has food reflex homing when: ( hasFood ) and ( ! place . isNestLocation ) {  do goto target:center  speed:1.0; } //Reflex to drop food once the ant arrived at the nest reflex dropping when: ( hasFood ) and ( place . isNestLocation ) {  hasFood <- false ;  heading <- heading - 180 ; } aspect default {  draw circle(2.0) color: color; }   } //Experiment simple to display ant and have user interaction experiment Simple type:gui {  parameter  Evaporation:  var: evaporation_per_cycle;  parameter  Diffusion Rate:  var: diffusion_rate;  output {    display Ants refresh: every(2) {     grid ant_grid;    species ant aspect: default;    graphics  displayText  {     draw string ( food_remaining ) size: 24.0 at: { 20 , 20 } color: rgb (  white  );    }    //Event triggering the action passed in parameter    event mouse_down action:press;    event mouse_up action:release;   }   display Ants_2 refresh: every(2) {     grid ant_grid;    graphics  displayText  {     draw string ( food_remaining ) size: 24.0 at: { 20 , 20 } color: rgb (  white  );    }    event mouse_down action:press;    event mouse_up action:click2;   }  } }  // This experiment explores two parameters with an exhaustive strategy,  // repeating each simulation two times, in order to find the best combination  // of parameters to minimize the time taken by ants to gather all the food experiment  Exhaustive optimization  type: batch repeat: 2 keep_seed: true until: ( food_remaining = 0 ) or ( time > 400 ) {  parameter  Evaporation  var: evaporation_per_cycle among: [ 0.1 , 1.0 , 2.0 , 5.0 ,  10.0 ];  parameter  Diffusion rate  var: diffusion_rate min: 0.1 max: 1.0 step:  0.3;  method exhaustive minimize: time; }  // This experiment simply explores two parameters with an exhaustive strategy,  // repeating each simulation two times experiment Repeated type: batch repeat: 2 keep_seed: true until: ( food_remaining = 0 ) or ( time > 400 ) {  parameter  Evaporation  var: evaporation_per_cycle among: [ 0.1 , 1.0 , 2.0 , 5.0 ,  10.0 ];  parameter  Diffusion rate  var: diffusion_rate min: 0.1 max: 1.0 step:0.3; }  // This experiment explores two parameters with a GA strategy,  // repeating each simulation two times, in order to find the best combination  // of parameters to minimize the time taken by ants to gather all the food  experiment Genetic type: batch keep_seed: true repeat: 3 until: ( food_remaining = 0 ) or ( time > 400 ) {  parameter  Evaporation  var: evaporation_per_cycle min: 0.05 max: 10.0  step: 0.1;  parameter  Diffusion rate  var: diffusion_rate min: 0.0 max: 1.0 step:  0.01;  method genetic pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1  nb_prelim_gen: 1 max_gen: 20 minimize: time; }     ","url":"wiki/Ants-(Foraging-and-Sorting)-Ant-Foraging-(Simple).md"},{"id":"wiki/Ants-(Foraging-and-Sorting)-Ant-Sorting.md","title":" Ant Sorting","content":"# Ant Sorting  _Author : _  This model is loosely based on the behavior of ants sorting different elements in their nest. A of mobile agents - the ants - is placed on a grid. The grid itself contains cells of different colors. Each step, the agents move randomly. If they enter a colored cell, they pick this color if its density in the neighbourhood is less than number_of_objects_around. If they have picked a color, they drop it on a black cell if they have encountered at least number_of_objects_in_history cells with the same color.\\n After a while, colors begin to be aggregated.  Code of the model :       model ant_sort  global  {  // Parameters   int number_of_different_colors <- 5 max: 9 ;  int density_percent <- 30 min: 0 max: 99 ;  int number_of_objects_in_history <- 3 min: 0 ;  int number_of_objects_around  <- 5 min: 0 max: 8;  int width_and_height_of_grid <- 128 max: 400 min: 10 ;  int ants <- 20 min: 1 ;  //Action to kill all the ants action kill_all {  ask ant {do die;} }  //Action to create all the ants action create_all {  create ant number: ants; }  rgb black <- #black  ;  list<rgb> colors const: true <- [#yellow,#red, #orange, #blue, #green,#cyan, #gray,#pink,#magenta] ; //Action to write the description of the model action description {  write \\n Description. \\n This model is loosely based on the behavior of ants sorting different elements in their nest. \\n A of mobile agents - the ants - is placed on a grid. The grid itself contains cells of different colors. Each step, the agents move randomly. If they enter a colored cell, they pick this color if its density in the neighbourhood is less than *number_of_objects_around*. If they have picked a color, they drop it on a black cell if they have encountered at least *number_of_objects_in_history* cells with the same color.\\n After a while, colors begin to be aggregated.  ;  }   init {   do description ;  do create_all; }  } //Species ant that will move and follow a final state machine species ant skills: [ moving ] control: fsm {  rgb color <- #white ;  ant_grid place -> {ant_grid (location)} ;  //Reflex to make the ant wander reflex wandering {   do wander amplitude: 120; } //Initial state that will change to full state empty initial: true {  transition to: full when: (place.color != black) and ( (place.neighbors count (each.color = place.color)) < (rnd(number_of_objects_around))) {   color <- place.color ;   place.color <- black ;   } } //State full that will change to black if the place color is empty and drop the color inside it state full {  enter {    int encountered <- 0;   }  if place.color = color {    encountered <- encountered + 1 ;  }  transition to: empty when: (place.color = black) and (encountered > number_of_objects_in_history) {   place.color <- color ;   color <- black ;  } } aspect default {  draw file(../images/ant_normal.svg) size:5 color: color rotate: heading - 90;  draw circle(5) empty: true color: color; } } //Grid that will use the density to determine the color grid ant_grid width: width_and_height_of_grid height: width_and_height_of_grid neighbors: 8 use_regular_agents: false frequency: 0{ rgb color <- (rnd(100)) < density_percent ? (colors at rnd(number_of_different_colors - 1)) : #black ; }   experiment sort type: gui{  parameter  Number of colors:  var: number_of_different_colors category:  Environment  ;  parameter  Density of colors:  var: density_percent category:  Environment  ;  parameter  Number of similar colors in memory necessary to put down:  var: number_of_objects_in_history category:  Agents  ;  parameter  Number of similar colors in perception necessary to pick up:  var: number_of_objects_around category:  Agents  ;  parameter  Width and height of the grid:  var: width_and_height_of_grid category:  Environment  ;  parameter  Number of agents:  var: ants category:  Agents  ;  output {  display OpenGL type: opengl  {   grid ant_grid ;   species ant transparency: 0.2 ;  } } }       ","url":"wiki/Ants-(Foraging-and-Sorting)-Ant-Sorting.md"},{"id":"wiki/Articles-Prima_model1.md","title":" Prima 1","content":"# Prima 1  _Author : _  This model shows how to create agent and make them move randomly in the world. Some agents are infected, and others can gain the infection if they are in a certain range.  Code of the model :       model SI_city  global{  geometry shape<-envelope(square(500));  //Creation of the people agents init{  create people number:1000; } } //People species with agents moving and can be infected species people skills:[moving]{   float speed <- 5.0 + rnd(5); bool is_infected <- flip(0.01); //Make the agent wander at each step with a certain speed. reflex move{  do wander; } //Infect the agent if it is not already infected, and according to the infected people in a range reflex infect when: is_infected{  ask people at_distance 10 {   if flip(0.01) {    is_infected <- true;   }  } } aspect circle{  draw circle(5) color:is_infected ? #red : #green; } }   experiment main_experiment type:gui{  output {   display map  {    species people aspect:circle;      }  } }     ","url":"wiki/Articles-Prima_model1.md"},{"id":"wiki/Articles-Prima_model2.md","title":" Prima 2","content":"# Prima 2  _Author : _  This model shows how to create agent and make them move randomly in the world. Some agents are infected, and others can gain the infection if they are in a certain range. The people are now placed in buildings at the initial state. Those buildings are created thanks to a shapefile. Roads are also created thanks to an other shapefile.  Code of the model :      model model2  global {  //Shapefile for the roads  file roads_shapefile <- file( ../includes/road.shp );  //Shapefile for the buildings  file buildings_shapefile <- file( ../includes/building.shp );  //Definition of the shape as the bounds of the roads shapefile  geometry shape <- envelope(roads_shapefile);  init {   //Creation of the road agents using the shapefile   create roads from: roads_shapefile;   //Creation of the building agents using the shapefile   create buildings from: buildings_shapefile;   //Creation of the people agent and place them in one of the building and chose a target in the building agents   create people number:1000 {    location <- any_location_in(one_of(buildings));    target <- any_location_in(one_of(buildings));   }  } }  //People species with agents moving and can be infected species people skills:[moving]{    float speed <- 5.0 + rnd(5);  bool is_infected <- flip(0.01);  point target;  //Make the agent wander at each step with a certain speed.  reflex move {   do wander;  }  //Infect the agent if it is not already infected, and according to the infected people in a range  reflex infect when: is_infected{   ask people at_distance 10 {    if flip(0.01) {     is_infected <- true;    }   }  }  aspect circle{   draw circle(5) color:is_infected ? #red : #green;  } }  species roads {  aspect geom {   draw shape color: #black;  } }  species buildings {  aspect geom {   draw shape color: #gray;  } }  experiment main_experiment type:gui{  output {   display map {    species roads aspect:geom;    species buildings aspect:geom;    species people aspect:circle;      }  } }     ","url":"wiki/Articles-Prima_model2.md"},{"id":"wiki/Articles-Prima_model3.md","title":" Prima 3","content":"# Prima 3  _Author : _  This model shows how to create agent and make them move randomly in the world.Some agents are infected, and others can gain the infection if they are in a certain range. The people are now placed in buildings at the initial state. Those buildings are created thanks toa shapefile. Roads are also created thanks to an other shapefile. A graph is now created fromthe road agents, and the people move from their location to a targent on the graph.  Code of the model :      model model3  global {  //Shapefile for the roads  file roads_shapefile <- file( ../includes/road.shp );  //Shapefile for the buildings  file buildings_shapefile <- file( ../includes/building.shp );  //The bounds of the world are the same as the bounds of the roads shapefile  geometry shape <- envelope(roads_shapefile);  //We need now a graph on which people will move  graph road_network;  init {   //Create the roads using the shapefiles   create roads from: roads_shapefile;   //Create the graph using the road agents as edges of the graph   road_network <- as_edge_graph(roads);   //Create the buildings using the shapefiles   create buildings from: buildings_shapefile;   //Create the people agents and choose their location and target   create people number:1000 {    location <- any_location_in(one_of(buildings));    target <- any_location_in(one_of(buildings));   }  } } //Species people that will move from a location to a target species people skills:[moving]{    float speed <- 5.0 + rnd(5);  bool is_infected <- flip(0.01);  point target;  //Reflex to make the agent move to a target  reflex move {   do goto target:target on: road_network;   //Each time the agent is at the target s location, chose an other target   if (location = target) {    target <- any_location_in(one_of(buildings));   }  }  //check if the agent is infected if it is not infected already and if there are infected people nearby  reflex infect when: is_infected{   ask people at_distance 10 {    if flip(0.01) {     is_infected <- true;    }   }  }  aspect circle{   draw circle(5) color:is_infected ? #red : #green;  } }  species roads {  aspect geom {   draw shape color: #black;  } }  species buildings {  aspect geom {   draw shape color: #gray;  } }  experiment main_experiment type:gui{  output {   display map {    species roads aspect:geom;    species buildings aspect:geom;    species people aspect:circle;      }  } }     ","url":"wiki/Articles-Prima_model3.md"},{"id":"wiki/Articles-Prima_model4.md","title":" Prima 4","content":"# Prima 4  _Author : _  This model shows how to create agent and make them move randomly in the world.Some agents are infected, and others can gain the infection if they are in a certain range. The people are now placed in buildings at the initial state. Those buildings are created thanks toa shapefile. Roads are also created thanks to an other shapefile. A graph is now created fromthe road agents, and the people move from their location to a targent on the graph. The displayis now a 3D display.  Code of the model :      model model4  global {  //Shapefile for the roads  file roads_shapefile <- shape_file( ../includes/road.shp );  //Shapefile for the buildings  file buildings_shapefile <- file( ../includes/building.shp );  //The world bounds are now the shapefile roads  s boundss  geometry shape <- envelope(roads_shapefile);  //The graph of roads on which people will move  graph road_network;  init {   //Creation of the roads using the road shapefile   create roads from: roads_shapefile;   //Creation of the graph using roads as the edges of the graph   road_network <- as_edge_graph(roads);   //Creation of the buildings from the building shapefile   create buildings from: buildings_shapefile;   //Creation of the people agent, located in one of the building   create people number:1000 {    buildings init_place <- one_of(buildings);    location <- any_location_in(init_place) + {0,0, init_place.height};    target <- any_location_in(one_of(buildings));   }  } } //Species people that will move from a location to a target and can be infected species people skills:[moving]{    float speed <- 5.0 + rnd(5);  bool is_infected <- flip(0.01);  point target;  //Reflex to move to the target on the graph of roads reflex move {  do goto target:target on: road_network;  //Once the target is reached, find an other target  if (location = target) {   target <- any_location_in(one_of(buildings));  } } //Reflex to check if we are infected if we aren t already and infected people are nearby reflex infect when: is_infected{  ask people at_distance 10 {   if flip(0.01) {    is_infected <- true;   }  } } aspect circle{  draw sphere(5) color:is_infected ? #red : #green; } }   species roads {  aspect geom {   draw shape color: #black;  } }  species buildings {  float height <- 10.0+ rnd(10);  aspect geom {   draw shape color: #gray depth: height;  } }  experiment main_experiment type:gui{  output {   //Type opengl to display in 3D   display map type: opengl {    species roads aspect:geom;    species buildings aspect:geom;    species people aspect:circle;      }  } }     ","url":"wiki/Articles-Prima_model4.md"},{"id":"wiki/Articles-Prima_model5.md","title":" Prima 5","content":"# Prima 5  _Author : _  This model shows how to create agent and make them move randomly in the world.Some agents are infected, and others can gain the infection if they are in a certain range. The people are now placed in buildings at the initial state. Those buildings are created thanks toa shapefile. Roads are also created thanks to an other shapefile. A graph is now created fromthe road agents, and the people move from their location to a targent on the graph. The displayis now a 3D display. The model adds a new level as people going inside a building will be nowa new species belonging to the building and that will be manage by the building agent concerned  Code of the model :      model model5  global {  //Shapefile of the roads  file roads_shapefile <- file( ../includes/road.shp );  //Shapefile of the buildings  file buildings_shapefile <- file( ../includes/building.shp );  //The bounds of the world are the bounds of the roads shapefile  geometry shape <- envelope(roads_shapefile);  //The graph of road on which people agents will move  graph road_network;  init {   //Creation of the roads using the road shapefile   create roads from: roads_shapefile;   //Creation of the graph using the road agents as edge   road_network <- as_edge_graph(roads);   //Creation of the building using the building shapefile   create buildings from: buildings_shapefile;   //Creation of the people that will be placed in a building randomly chosen   create people number:1000 {    buildings init_place <- one_of(buildings);    location <- any_location_in(init_place) + {0,0, init_place.height};    target <- any_location_in(one_of(buildings));   }  } } //Species people that can be infected and will move from a location to a target species people skills:[moving]{    float speed <- 5.0 + rnd(5);  bool is_infected <- flip(0.01);  point target;  //Make the agent move to its target  reflex move {   do goto target:target on: road_network;   //Change the target once it has been reached   if (location = target) {    target <- any_location_in(one_of(buildings));   }  }  //Reflex to infect the people agent if it is not infected already and if there are infected people nearby  reflex infect when: is_infected{   ask people at_distance 10 {    if flip(0.01) {     is_infected <- true;    }   }  }  aspect circle{   draw sphere(5) color:is_infected ? #red : #green;  } }  species roads {  aspect geom {   draw shape color: #black;  } } //Species buildings that will change the people agents inside it to people in building agent //Managing them once they have been captured, and releasing them once they reached a //leaving time species buildings {  float height <- 10.0+ rnd(10);  int nb_I -> {members count (people_in_building(each).is_infected)};  aspect geom {  draw shape color: empty(members) ? #gray : (nb_I/length(members) > 0.5 ? #red : #green) depth: height; } //Species people in building that will be managed by the building agents species people_in_building parent: people schedules: [] {  int leaving_time;  aspect circle{} } //Reflex to capture the people entering inside the building, changing them in people in building species and puting a leaving time to know when lettiing // them out reflex let_people_enter {  list<people> entering_people <- (people inside self);  if !(empty (entering_people)) {   //Change the species of the people captured from people species to people_in_building species   capture entering_people as: people_in_building returns: people_captured;   ask people_captured {    leaving_time <- int(time + 50 + rnd(50));   }    } } //Reflex to let the people_in_building agents go out if there leaving time is reached, releasing them in the world as people agent reflex let_people_leave  {  list<people_in_building> leaving_people <- members of_species people_in_building where (time >= each.leaving_time);  if !(empty (leaving_people)) {   release leaving_people as: people in: world;  } } }   experiment main_experiment type:gui{  output {   display map type: opengl {    species roads aspect:geom;    species buildings aspect:geom;    species people aspect:circle;      }  } }     ","url":"wiki/Articles-Prima_model5.md"},{"id":"wiki/Articles-Prima_model6.md","title":" Prima 5","content":"# Prima 5  _Author : _  This model shows how to create agent and make them move randomly in the world.Some agents are infected, and others can gain the infection if they are in a certain range. The people are now placed in buildings at the initial state. Those buildings are created thanks toa shapefile. Roads are also created thanks to an other shapefile. A graph is now created fromthe road agents, and the people move from their location to a targent on the graph. The displayis now a 3D display. The model adds a new level as people going inside a building will be nowa new species belonging to the building and that will be manage by the building agent concernedThe people_in_building agent will be infected inside a building respecting an ordinary differentialequation system.  Code of the model :      model model6  global {  //Shapefile of roads  file roads_shapefile <- file( ../includes/road.shp );  //Shapefile of buildings  file buildings_shapefile <- file( ../includes/building.shp );  //Bounds of the world will be the bounds of the shapefile of roads  geometry shape <- envelope(roads_shapefile);  //The graph of roads on which people agents will move  graph road_network;  //The beta used for the ODE system float beta <- 0.4;  init {  //Creation of the roads using the shapefile  create roads from: roads_shapefile;  //Creation of the graph using the road agents as edge  road_network <- as_edge_graph(roads);  //Creation of the buildings using the shapefile  create buildings from: buildings_shapefile;  //Creation of the people that will be placed in a building randomly chosen  create people number:1000 {   buildings init_place <- one_of(buildings);   location <- any_location_in(init_place) + {0,0, init_place.height};   target <- any_location_in(one_of(buildings));  } } }   //Species people that can be infected and will move from a location to a target species people skills:[moving]{    float speed <- 5.0 + rnd(5);  bool is_infected <- flip(0.01);  point target;  //Reflex to make the agent move from its location to its target on the graph  reflex move {   do goto target:target on: road_network;   //Change the target once it has been reached   if (location = target) {    target <- any_location_in(one_of(buildings));   }  }  //Reflex to know if a non-infected agent is infected by the agents nearby  reflex infect when: is_infected{   ask people at_distance 10 {    if flip(0.01) {     is_infected <- true;    }   }  }  aspect circle{   draw sphere(5) color:is_infected ? #red : #green;  } }  species roads {  aspect geom {   draw shape color: #black;  } }  //Species buildings that will change the people agents inside it to people in building agent //Managing them once they have been captured, and releasing them once they reached a //leaving time species buildings {  float height <- 10.0+ rnd(10);  //Variable to know the number of people infected inside the buildings  int nb_I -> {members count (people_in_building(each).is_infected)};  //Variable to know the number of people inside the building  int nbInhabitants update: length(members);  //List of all the people_in_building agents not infected      list membersS update: list(members) where (!each.is_infected);  //List of all the people_in_building agents infected      list membersI update: list(members) where (each.is_infected);  float t;  //Float used in the ODE system representing the number of non infected agents      float S update: length(membersS) as float;   //Float used in the ODE system representing the number of infected agents      float I update: length(membersI) as float;     float I_to_1 <- 0.0;     float h<-0.1;  aspect geom {  draw shape color: empty(members) ? #gray : (nb_I/length(members) > 0.5 ? #red : #green) depth: height; } //Species people in building that will be managed by the building agents species people_in_building parent: people schedules: [] {  int leaving_time;  aspect circle{} } //Reflex to capture the people entering inside the building, changing them in people in building species and puting a leaving time to know when lettiing // them out reflex let_people_enter {  list<people> entering_people <- (people inside self);  if !(empty (entering_people)) {   capture entering_people as: people_in_building returns: people_captured;   ask people_captured {    leaving_time <- int(time + 50 + rnd(50));   }    } } //Reflex to let the people_in_building agents go out if there leaving time is reached, releasing them in the world as people agent reflex let_people_leave  {  list<people_in_building> leaving_people <- list<people_in_building>(members) where (time >= each.leaving_time);  if !(empty (leaving_people)) {   release leaving_people as: people in: world;  } } //ODE system to represent the infection among the building equation SIR{   diff(S,t) = (- beta * S * I / nbInhabitants) ;  diff(I,t) = (  beta * S * I / nbInhabitants) ; } //Make the computation of the ODE System only when they are people inside reflex epidemic when:(S>0 and I>0){    float I0 <- I;  solve SIR method: rk4 step: h ;  I_to_1 <- I_to_1 + (I - I0);  if(I_to_1 > 1) {   ask(membersS){    is_infected <- true;    myself.I_to_1 <- myself.I_to_1 - 1;   }  } }     }   experiment main_experiment type:gui{  output {   display map type: opengl {    species roads aspect:geom;    species buildings aspect:geom;    species people aspect:circle;      }  } }     ","url":"wiki/Articles-Prima_model6.md"},{"id":"wiki/Articles-ville_1.md","title":" Ville 1","content":"# Ville 1  _Author : _  This is a simple model showing different circle with a color according to the income of the house.  Code of the model :      model ville  global {  init {   create foyer number: 500;  } }  species batiment {  string type;  int capacite; }  species route { }  species foyer {  float revenu <- gauss(1500, 500);  bool est_satisfait ;  batiment habitation;  batiment lieu_travail;  aspect revenu {  int val <- int(255 * (revenu / 3000));  draw circle(5) color: rgb(255 - val, val, 0); } }   experiment ville type: gui {   output {   display carte_principale {    species foyer aspect: revenu;   }  } }     ","url":"wiki/Articles-ville_1.md"},{"id":"wiki/Articles-ville_2.md","title":" Ville 2","content":"# Ville 2  _Author : _  Creation of buildings and roads thanks to a shape file. The color of the building depends on the type of the building, while the color of a house depend on its income.  Code of the model :       model ville  global {  file shape_file_batiments <- file( ../includes/batiments.shp );  file shape_file_routes <- file( ../includes/routes.shp );  geometry shape <- envelope(shape_file_routes);  init {   create route from: shape_file_routes;   create batiment from: shape_file_batiments with: [type:: string(read( NATURE ))];   create foyer number: 500;  } }  species batiment {  string type;  int capacite <- type =  Industrial  ? 0 : int(shape.area / 60.0);  aspect geometrie {   draw shape color: type =  Industrial  ? #pink : #gray;  } }  species route {  aspect geometrie {   draw shape color: #black;  } }  species foyer {  float revenu <- gauss(1500, 500);  batiment habitation;  batiment lieu_travail;  aspect revenu {  int val <- int(255 * (revenu / 3000));  draw circle(5) color: rgb(255 - val, val, 0); } }   experiment ville type: gui {  output {   display carte_principale {    species batiment aspect: geometrie;    species route aspect: geometrie;    species foyer aspect: revenu;   }  } }     ","url":"wiki/Articles-ville_2.md"},{"id":"wiki/Articles-ville_3.md","title":" Ville 3","content":"# Ville 3  _Author : _  Creation of buildings and roads thanks to a shape file. The color of the building depends on the type of the building, while the color of a house depend on its income. People among the world will try to find the best building according to the mean income of their neighbors and their own income.  Code of the model :      model ville  global {  file shape_file_batiments <- file( ../includes/batiments.shp );  file shape_file_routes <- file( ../includes/routes.shp );  geometry shape <- envelope(shape_file_routes);  init   {   create route from: shape_file_routes;   create batiment from: shape_file_batiments with: [type:: string(read( NATURE ))];   create foyer number: 500;  } }  species foyer {  float revenu <- gauss(1500, 500);  bool est_satisfait update: calculer_satisfaction();  batiment habitation;  batiment lieu_travail;  init {   lieu_travail <- one_of(batiment where (each.type =  Industrial ));   habitation <- choisir_batiment();    do emmenager;  }  bool calculer_satisfaction {   list voisins <- foyer at_distance 50.0;   float revenu_moyen <- mean(voisins collect (each.revenu));   return empty(voisins) or (revenu_moyen > (revenu * 0.7) and revenu_moyen < (revenu / 0.7));  }  action emmenager {   habitation.capacite <- habitation.capacite - 1;   location <- any_location_in(habitation.shape);  }  action demenager {   habitation.capacite <- habitation.capacite + 1;  }  batiment choisir_batiment {   return one_of(batiment where (each.capacite >0));  }  reflex demenagement when: !est_satisfait {   do demenager;   habitation <- choisir_batiment();   do emmenager;  }  aspect revenu {   int val <- int(255 * (revenu / 3000));   draw circle(5) color: rgb(255 - val, val, 0);  } } species batiment {  string type;  int capacite <- type = Industrial ? 0 : int(shape.area / 70.0);  aspect geometrie {   draw shape color: type = Industrial ? #pink : #gray;  }  } species route {  aspect geometrie {   draw shape color: #black;  }  } experiment ville type: gui {  output {   display carte_principale {    species batiment aspect: geometrie;    species route aspect: geometrie;    species foyer aspect: revenu;   }  } }     ","url":"wiki/Articles-ville_3.md"},{"id":"wiki/Articles-ville_4.md","title":" Ville 4","content":"# Ville 4  _Author : _  Creation of buildings and roads thanks to a shape file. The color of the building depends on the type of the building, while the color of a house depend on its income. People among the world will try to find the best building according to the mean income of their neighbors and their own income, but also to their working place.  Code of the model :      model ville  global {  file shape_file_batiments <- file( ../includes/batiments.shp );  file shape_file_routes <- file( ../includes/routes.shp );  geometry shape <- envelope(shape_file_routes);  graph<point, route> reseau_route;  init {   create route from: shape_file_routes;   reseau_route <- as_edge_graph(route);   create batiment from: shape_file_batiments with: [type:: string(read( NATURE ))];   create foyer number: 500;  } } species foyer {  float revenu <- gauss(1500, 500);  bool est_satisfait update: calculer_satisfaction();  batiment habitation;  batiment lieu_travail;  init {   lieu_travail <- one_of(batiment where (each.type =  Industrial ));   habitation <- choisir_batiment();    do emmenager;  }  bool calculer_satisfaction {   list voisins <- foyer at_distance 50.0;   float revenu_moyen <- mean(voisins collect (each.revenu));   return empty(voisins) or (revenu_moyen > (revenu * 0.7) and revenu_moyen < (revenu / 0.7));  }  action emmenager {   habitation.capacite <- habitation.capacite - 1;   location <- any_location_in(habitation.shape);  }  action demenager {   habitation.capacite <- habitation.capacite + 1;  }  batiment choisir_batiment {   return one_of(batiment where ((each.capacite >0) and ( each.distances[lieu_travail]< 1000.0)));  }  reflex demenagement when: !est_satisfait {   do demenager;   habitation <- choisir_batiment();   do emmenager;  }  aspect revenu {   int val <- int(255 * (revenu / 3000));   draw circle(5) color: rgb(255 - val, val, 0);  } } species batiment {  string type;  int capacite <- type = Industrial ? 0 : int(shape.area / 70.0);  map<batiment,float> distances;  init {   loop bat over: batiment where (each.type = Industrial) {    put (topology(reseau_route) distance_between [self,bat]) at: bat in: distances;   }  }  aspect geometrie {   draw shape color: type = Industrial ? #pink : #gray;  } } species route {  aspect geometrie {   draw shape color: #black;  } } experiment ville type: gui {  output {   display carte_principale {    species batiment aspect: geometrie;    species route aspect: geometrie;    species foyer aspect: revenu;   }  } }     ","url":"wiki/Articles-ville_4.md"},{"id":"wiki/Articles-ville_5.md","title":" Ville 5","content":"# Ville 5  _Author : _  Creation of buildings and roads thanks to a shape file. The color of the building depends on the type of the building, while the color of a house depend on its income. People among the world will try to find the best building according to the mean income of their neighbors and their own income, but also to their working place. This model add a new display showing the  color  of each building according to the mean income of its residents  Code of the model :      model ville  global {  file shape_file_batiments <- file( ../includes/batiments.shp );  file shape_file_routes <- file( ../includes/routes.shp );  geometry shape <- envelope(shape_file_routes);  graph<point, route> reseau_route;  init {  create route from: shape_file_routes;  reseau_route <- as_edge_graph(route);  create batiment from: shape_file_batiments with: [type:: string(read(NATURE))];  create foyer number: 500; } }    species foyer {  float revenu <- gauss(1500, 500);  bool est_satisfait update: calculer_satisfaction();  batiment habitation;  batiment lieu_travail;  init {   lieu_travail <- one_of(batiment where (each.type =  Industrial ));   habitation <- choisir_batiment();    do emmenager;  }  bool calculer_satisfaction {   list voisins <- foyer at_distance 50.0;   float revenu_moyen <- mean(voisins collect (each.revenu));   return empty(voisins) or (revenu_moyen > (revenu * 0.7) and revenu_moyen < (revenu / 0.7));  }  action emmenager {   habitation.capacite <- habitation.capacite - 1;   habitation.foyers << self;   location <- any_location_in(habitation.shape) + {0,0, habitation.hauteur};  }  action demenager {   habitation.capacite <- habitation.capacite + 1;   remove self from: habitation.foyers;  }  batiment choisir_batiment {   return one_of(batiment where ((each.capacite >0) and ( each.distances[lieu_travail]< 1000.0)));  }  reflex demenagement when: !est_satisfait {   do demenager;   habitation <- choisir_batiment();   do emmenager;  }  aspect revenu {   int val <- int(255 * (revenu / 3000));   draw sphere(5) color: rgb(255 - val, val, 0);  } } species batiment {  string type;  int capacite <- type = Industrial ? 0 : int(shape.area / 70.0);  map<batiment,float> distances;  int hauteur <- 5 + rnd(10);  list foyers ;  float revenu_moyen update: empty(foyer) ? 0.0 : mean (foyers collect each.revenu);  init {   loop bat over: batiment where (each.type = Industrial) {    put (topology(reseau_route) distance_between [self,bat]) at: bat in: distances;   }  }  aspect geometrie {   draw shape color: type = Industrial ? #pink : #gray depth: hauteur;  }  aspect information_foyer {   draw shape color: type = Industrial ? #pink : (empty(foyers) ? #gray : rgb(int(255 * (1 - (revenu_moyen / 3000))), int(255 * (revenu_moyen / 3000)), 0)) depth: length(foyers);  } } species route {  aspect geometrie {   draw shape color: #black;  } } experiment ville type: gui {  output {   display carte_principale type: java2D {    species batiment aspect: geometrie;    species route aspect: geometrie;    species foyer aspect: revenu;   }   display carte_batiment type: opengl {    species batiment aspect: information_foyer;   }  } }     ","url":"wiki/Articles-ville_5.md"},{"id":"wiki/Articles-ville_6.md","title":" Ville 6","content":"# Ville 6  _Author : _  Creation of buildings and roads thanks to a shape file. The color of the building depends on the type of the building, while the color of a house depend on its income. People among the world will try to find the best building according to the mean income of their neighbors and their own income, but also to their working place. This model add a new display showing the  color  of each building according to the mean income of its residents. The buildings also have a z location given thanks to a mnt file.  Code of the model :      model ville  global {  file shape_file_batiments <- file( ../includes/batiments.shp );  file shape_file_routes <- file( ../includes/routes.shp );  file mnt <- file( ../includes/mnt.asc );  file texture <- file( ../includes/Texture.png );  geometry shape <- envelope(mnt);  graph<point, route> reseau_route;  list industries;  init {  create route from: shape_file_routes;  reseau_route <- as_edge_graph(route);  create batiment from: shape_file_batiments with: [type:: string(read(NATURE))] {   float z <- (mnt_cell(location)).grid_value;      location <- {location.x,location.y,z};  }  industries <- batiment select (each.type = Industrial);  create foyer number: 500; } }   grid mnt_cell file: mnt;  species foyer {  float revenu <- gauss(1500, 500);  bool est_satisfait update: calculer_satisfaction();  batiment habitation;  batiment lieu_travail;  init {   lieu_travail <- one_of(batiment where (each.type =  Industrial ));   habitation <- choisir_batiment();    do emmenager;  }  bool calculer_satisfaction {   list voisins <- foyer at_distance 50.0;   float revenu_moyen <- mean(voisins collect (each.revenu));   return empty(voisins) or (revenu_moyen > (revenu * 0.7) and revenu_moyen < (revenu / 0.7));  }  action emmenager {   habitation.capacite <- habitation.capacite - 1;   location <- any_location_in(habitation.shape) + {0,0, (habitation.hauteur + habitation.location.z)};   habitation.foyers << self;  }  action demenager {   habitation.capacite <- habitation.capacite + 1;   remove self from: habitation.foyers;  }  batiment choisir_batiment {   batiment b  <- one_of(batiment where ((each.capacite >0) and ( each.distances[lieu_travail]< 1000.0)));   return b;  }  reflex demenagement when: !est_satisfait {   do demenager;   habitation <- choisir_batiment();   do emmenager;  }  aspect revenu {   int val <- int(255 * (revenu / 3000));   draw sphere(5) color: rgb(255 - val, val, 0);  } } species batiment {  string type;  int capacite <- type = Industrial ? 0 : int(shape.area / 70.0);  map<batiment,float> distances;  int hauteur <- 5 + rnd(10);  list foyers ;  float revenu_moyen update: empty(foyer) ? 0.0 : mean (foyers collect each.revenu);  init {   loop bat over: batiment where (each.type = Industrial) {    put (topology(reseau_route) distance_between [self,bat]) at: bat in: distances;   }  }  aspect geometrie {   draw shape color: type = Industrial ? #pink : #gray depth: hauteur;  }  aspect information_foyer {   draw shape color: type = Industrial ? #pink : (empty(foyers) ? #gray : rgb(int(255 * (1 - (revenu_moyen / 3000))), int(255 * (revenu_moyen / 3000)), 0)) depth: length(foyers);  } } species route {  aspect geometrie {   draw shape color: #black at:{location.x,location.y,(mnt_cell(location)).grid_value};  } } experiment ville type: gui {  output {   display carte_principale type: opengl {    grid mnt_cell triangulation: true texture:texture elevation:true transparency: 0.3;    species batiment aspect: geometrie;    species route aspect: geometrie;    species foyer aspect: revenu;   }   display carte_batiment type: opengl {    species batiment aspect: information_foyer;   }  } }     ","url":"wiki/Articles-ville_6.md"},{"id":"wiki/Boids-Boids-3D-Analysis.md","title":" Boids 3D Analysis","content":"# Boids 3D Analysis  _Author : _  This model shows the movement of boids following a goal, and creating without their own volonty, a flock . Four experiments are proposed : start is the 3D display of the boids like a real world, trajectory_analysis like the name means is about the analysis of the trajectory of the boids, Space Time Cube adds two display to see the movement of the boids using the time as the z-axis, and the last one represents the differents camera available in GAMA.  Code of the model :      model boids  global torus: torus_environment{   //Number of boids to represent  int number_of_agents parameter:  Number of agents  <- 10 min: 1 max: 1000000;  //Number of obstacles to represent  int number_of_obstacles parameter:  Number of obstacles  <- 4 min: 0;  //Size of the boids  int boids_size parameter:  Boids size  <- 20 min: 1;  //Maximal speed allowed for the boids  float maximal_speed parameter:  Maximal speed  <- 15.0 min: 0.1 max: 15.0;  //Speed radius  float  radius_speed parameter:  radius speed  <- 0.5 min: 0.1;  //Cohesion factor of the boid group  in the range of a boid agent  int cohesion_factor parameter:  Cohesion Factor  <- 200;  //Alignment factor used for the boid group in the range of a boid agent  int alignment_factor parameter:  Alignment Factor  <- 100;   //Minimal distance to move  float minimal_distance parameter:  Minimal Distance  <- 10.0;   //Maximal turn done by the boids  int maximal_turn parameter:  Maximal Turn  <- 90 min: 0 max: 359;  //Parameters of the environment and the simulations int width_and_height_of_environment parameter:  Width/Height of the Environment  <- 800;   bool torus_environment parameter:  Toroidal Environment ?  <- false;  bool apply_cohesion <- true parameter:  Apply Cohesion ? ; bool apply_alignment <- true parameter:  Apply Alignment ? ;    bool apply_separation <- true parameter:  Apply Separation ? ;    bool apply_goal <- true parameter:  Follow Goal ? ;  bool apply_avoid <- true parameter:  Apply Avoidance ? ;    bool apply_wind <- true parameter:  Apply Wind ? ;      bool moving_obstacles <- false parameter:  Moving Obstacles ? ;     int bounds <- int(width_and_height_of_environment / 20);  //Wind vector  point wind_vector <- {0,0} parameter:  Direction of the wind ;   int goal_duration <- 30 update: (goal_duration - 1);  //Goal location point goal <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };  list images of: image_file <- [file( ../images/bird1.png ),file( ../images/bird2.png ),file( ../images/bird3.png )];  string file_path_to_ocean <-  ../images/ocean.jpg ; int xmin <- bounds;     int ymin <- bounds;   int xmax <- (width_and_height_of_environment - bounds);     int ymax <- (width_and_height_of_environment - bounds);    geometry shape <- square(width_and_height_of_environment);   // flock s parameter  float two_boids_distance const: true init: 30.0;   int merging_distance const: true init: 30; bool create_flock  init: false;    init {  //Create the boids and place them randomlly  create boids number: number_of_agents {    location <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };  }       //Create an obstacle and place it randomly  create obstacle number: number_of_obstacles {   location <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };   }  //Create a goal and place it at the goal location  create  boids_goal number: 1 {   location <- goal;  }    create aggregatedboids; }  //Reflex to create flock of boids considering the neighbours of each boids   reflex create_flocks {   if create_flock {    //Create a map using a boid agent as a key and the list of all its neighbours as the value for the key    map<boids, list<boids>> potentialBoidsNeighboursMap;        //Search all the boids within the two boids distance from a boid agent and put them in the map    loop one_boids over: boids {     list<boids> free_neighbours <- boids overlapping (one_boids.shape + (two_boids_distance));     remove one_boids from: free_neighbours;        if !(empty (free_neighbours)) {      add (one_boids::free_neighbours) to: potentialBoidsNeighboursMap;     }     }        //Sorting of all the boids considered as key in the map by the length of their neighbours    list<boids> sorted_free_boids <- (potentialBoidsNeighboursMap.keys) sort_by (length (potentialBoidsNeighboursMap at each));    //Removing of all the boids which has been considered as a key of the map, but  which are already included in a bigger list of neighbours by one of them neighbours    loop one_boids over: sorted_free_boids {     list<boids> one_boids_neighbours <- potentialBoidsNeighboursMap at one_boids;          if  (one_boids_neighbours != nil) {      loop one_neighbour over: one_boids_neighbours {       remove one_neighbour from: potentialBoidsNeighboursMap;       }     }    }    //Remove all the duplicates key of potentialBoidsNeighboursMap    list<boids> boids_neighbours <- (potentialBoidsNeighboursMap.keys);    loop one_key over: boids_neighbours {     put (remove_duplicates (( potentialBoidsNeighboursMap at (one_key)) + one_key)) at: one_key in: potentialBoidsNeighboursMap;    }        //Create a flock of boids considering the key of potentialBoidsNeighboursMap    loop one_key over: (potentialBoidsNeighboursMap.keys) {     list<boids> micro_agents <- potentialBoidsNeighboursMap at one_key;           if ( (length (micro_agents)) > 1 ) {      create flock number: 1 with: [ color::rgb([rnd (255), rnd (255), rnd (255)]) ] {        capture micro_agents as: boids_delegation;      }     }    }   } }   } //Species boids_goal which represents the goal followed by the boids agent, using the skill moving species boids_goal skills: [moving] { float range const: true init: 20.0; int radius <-3;  //Reflex to make the goal move in circle reflex wander_in_circle{    location <- {world.shape.width/2 + world.shape.width/2 * cos (time*radius_speed), world.shape.width/2 + world.shape.width/2 * sin (time*radius_speed)};  goal <- location; }  aspect default {  draw circle(10) color: rgb ( red );  draw circle(40) color: rgb ( orange ) size: 40 empty: true; }  aspect sphere{  draw sphere(10) color: rgb( white ); } }    //Species flock which represents the flock of boids agents, managing the boids agents captured species flock {  //Represent the cohesion index of the flock  float cohesionIndex <- two_boids_distance update: (two_boids_distance + (length (members)));  rgb color <- rgb ([64, 64, 64]);   geometry shape update: !(empty (members)) ? ( (polygon (members collect (boids_delegation (each)).location )) + 2.0 ) : ( polygon ([ {rnd (width_and_height_of_environment), rnd (width_and_height_of_environment)} ]) );  //Species that will represent the boids agents captured or inside a flock species boids_delegation parent: boids topology: topology(world.shape)   {  list<boids> others -> {( (boids_delegation overlapping (shape + range))) - self};      //Action to compute the mass center of the flock  action compute_mass_center type: point   {   loop o over: others    {    if  dead(o)     {     do write message:  in   + name +   agent with others contains death agents ;     }    }      return (length(others) > 0) ? (mean (others collect (each.location)) ) : location;  }   reflex separation when: apply_separation {  }    reflex alignment when: apply_alignment {  }  //Reflex to apply the cohesion on the boids agents  reflex cohesion when: apply_cohesion {   point acc <- (self compute_mass_center []) - location;   acc <- acc / cohesion_factor;   velocity <- velocity + acc;  }    reflex avoid when: apply_avoid {  }   } //Reflex to capture boids agents and release captured boids agents reflex capture_release_boids {   list<boids_delegation> removed_components <- boids_delegation where ((each distance_to location) > cohesionIndex );   if !(empty (removed_components)) {    release removed_components;   }      list<boids> added_components <- boids where ((each distance_to location) < cohesionIndex );   if !(empty (added_components)) {    capture added_components as: boids_delegation;   } } //Reflexe to kill the flock if the boids agents contained is lower than 2 reflex dispose when: ((length (members)) < 2) {   release members;   do die; } //Reflex to merge the flocks too close from each other reflex merge_nearby_flocks {  list<flock> nearby_flocks<- (flock overlapping (shape +  merging_distance));  if !(empty (nearby_flocks)) {    nearby_flocks <- nearby_flocks sort_by (length (each.members));    flock largest_flock <- nearby_flocks at ((length (nearby_flocks)) - 1);         remove largest_flock from: nearby_flocks;         list<boids> added_components ;    loop one_flock over: nearby_flocks {     release one_flock.members returns: released_boids;           loop rb over: released_boids {      add boids(rb) to: added_components;     }    }        if !(empty (added_components)) {      ask largest_flock {      capture added_components as: boids_delegation;     }    }    } }  aspect default {  draw shape color: color; } }   //Species to represent the boids aggregated species aggregatedboids{  reflex updateLocation{    location <- mean (boids collect (each.location));   }  aspect base{        draw sphere(10) color: rgb( red );  } } //Species to represent the boids agent using the skill moving species boids skills: [moving] {  //Speed of the agent  float speed max: maximal_speed <- maximal_speed;  //Range of movement for the neighbours  float range <- minimal_distance * 2;  //Velocity of the agent  point velocity <- {0,0};  float hue <- rnd(360) / 360;  //List of the neighbours boids list<boids> others update: ((boids overlapping (circle (range)))  - self);  //Point of the mass center of the flock considered as the neighbours agents point mass_center update:  (length(others) > 0) ? (mean (others collect (each.location)) )  : location;  //Reflex to do the separation of the agents with the other boids in the minimal distance reflex separation when: apply_separation {  point acc <- {0,0};   loop boid over: (boids overlapping (circle(minimal_distance)))  {   acc <- acc - ((location of boid) - location);  }    velocity <- velocity + acc; }  //Reflex to do the alignement of the boids reflex alignment when: apply_alignment {  point acc <- mean (others collect (each.velocity)) - velocity;  velocity <- velocity + (acc / alignment_factor); }   //Reflex to apply the cohesion using the mass center of the flock reflex cohesion when: apply_cohesion {  point acc <- mass_center - location;  acc <- acc / cohesion_factor;  velocity <- velocity + acc;  } //Reflex to avoid the obstacles reflex avoid when: apply_avoid {  point acc <- {0,0};  list<obstacle> nearby_obstacles <- (obstacle overlapping (circle (range)) );  loop obs over: nearby_obstacles {   acc <- acc - ((location of obs) - my (location));  }  velocity <- velocity + acc;  } //action to represent the bounding of the movement of the boids action bounding {  if  !(torus_environment) {   if  (location.x) < xmin {    velocity <- velocity + {bounds,0};   } else if (location.x) > xmax {    velocity <- velocity - {bounds,0};   }      if (location.y) < ymin {    velocity <- velocity + {0,bounds};   } else if (location.y) > ymax {    velocity <- velocity - {0,bounds};   }     } } //Reflex to follow the goal  reflex follow_goal when: apply_goal {  velocity <- velocity + ((goal - location) / cohesion_factor); } //Reflex to apply the wind vector reflex wind when: apply_wind {  velocity <- velocity + wind_vector; } //action to move   action do_move {    if (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) {   velocity <- {(rnd(4)) -2, (rnd(4)) - 2};   }  point old_location <- location;   do goto target: location + velocity;  velocity <- location - old_location;  }  //Reflex to do the movement, calling both bounding and do_move actions reflex movement {  do bounding;  do do_move; }  aspect basic{  draw triangle(boids_size) color:rgb( black ); } aspect image {  draw (images at (rnd(2))) size: boids_size rotate: heading color: rgb( black ) ;        }    aspect dynamicColor{  rgb cc <- hsb (float(heading)/360.0,1.0,1.0);  draw triangle(20) size: 15 rotate: 90 + heading color: cc border:cc depth:5;  draw name; } }    //Species which represents the obstacles using the skill moving species obstacle skills: [moving] {  float speed <- 0.1;    aspect default {   draw triangle(20) color: rgb( yellow ) depth:5;  } }  experiment start type: gui {  output {   display RealBoids  type:opengl z_fighting:false {    image  background  file:file_path_to_ocean;    species boids aspect: dynamicColor  position:{0,0,0.1} trace: 30;    species boids_goal transparency:0.2 position:{0,0,0.1};    species obstacle position:{0,0,0.1};      }  } }  experiment trajectory_analysis type: gui {  output {   display RealBoids  type:opengl {   image  background  file:file_path_to_ocean;   species boids aspect: dynamicColor transparency:0.5 position:{0,0,0.1};   species boids aspect: image transparency:0.5 position:{0,0,0.11};   species boids_goal transparency:0.2 position:{0,0,0.1};   species obstacle position:{0,0,0.1};     }      display AggregatedBoidsTrajectory  type:opengl  {   image  background  file:file_path_to_ocean;   species aggregatedboids  aspect: base trace:100 fading: true ;   species boids_goal aspect:sphere;    } }  }   experiment SpaceTimeCube type: gui {  output {   display RealBoids  type:opengl {    image  background  file:file_path_to_ocean;    species boids aspect: dynamicColor transparency:0.5 position:{0,0,0.1};    species boids aspect: image transparency:0.5 position:{0,0,0.11};    species boids_goal transparency:0.2 position:{0,0,0.1};    species obstacle position:{0,0,0.1};      }   display SpaceTimeCubeAll  type:opengl {   image  background  file:file_path_to_ocean;   species boids trace:true{       draw triangle(20) size: 15 rotate: 90 + heading color: hsb (float(heading)/360.0,1.0,1.0) border:hsb (float(heading)/360.0,1.0,1.0) depth:5 at: {location.x ,location.y,location.z+time};    }   species boids_goal trace:true{    draw sphere(10) color: rgb( yellow ) at: {location.x ,location.y,location.z+time};   }   }      display SpaceTimeCubeAggregated  type:opengl {   image  background  file:file_path_to_ocean;   species aggregatedboids trace:true{       draw sphere(10) color: rgb( red ) at: {location.x ,location.y,location.z+time};    }   species boids_goal trace:true{    draw sphere(10) color: rgb( yellow ) at: {location.x ,location.y,location.z+time};   }   } } }   experiment MultipleView type: gui {  output {   display RealBoids   type:opengl {   image  background  file:file_path_to_ocean;   species boids aspect: image  transparency:0.5 position:{0,0,0.25};   species boids_goal transparency:0.2 position:{0,0,0.25};   species obstacle ;   species boids  aspect: dynamicColor transparency:0.2 position:{0,0,0.24};    }    display ThirdPersonn  type:opengl camera_interaction:false camera_pos:{int(first(boids).location.x),int(first(boids).location.y),250}   camera_look_pos:{int(first(boids).location.x),first(boids).location.y,0}   camera_up_vector:{0.0,-1.0,0.0} {     image  background  file:file_path_to_ocean;   species obstacle;   species boids  aspect: dynamicColor transparency:0.2 ;   species boids_goal  transparency:0.2;     }       display FirstPerson  type:opengl camera_interaction:false camera_pos:{int(first(boids).location.x),int(first(boids).location.y),10}    camera_look_pos:{cos(first(boids).heading)*first(boids).speed+int(first(boids).location.x),   sin(first(boids).heading)*first(boids).speed+int(first(boids).location.y),10}    camera_up_vector:{0.0,0.0,1.0} {    image  background  file:file_path_to_ocean;   species obstacle ;   species boids  aspect: dynamicColor transparency:0.2 ;   species boids_goal  transparency:0.2;     } } }      ","url":"wiki/Boids-Boids-3D-Analysis.md"},{"id":"wiki/Boids-Boids-3D-Motion.md","title":" Boids 3D Motion","content":"# Boids 3D Motion  _Author : _  This model shows the movement of boids following a goal, and creating without their own volonty, a flock .  The goal agent and the boids will move within the 3D space.  Code of the model :      model boids_3D  global torus: torus_environment{   //Number of boids to create  int number_of_agents parameter:  Number of agents  <- 100 min: 1 max: 1000000;  //Number of obstacles to create  int number_of_obstacles parameter:  Number of obstacles  <- 0 min: 0;  //Size of the boids  int boids_size parameter:  Boids size  <- 50 min: 1;  //Maximal speed of the boids  float maximal_speed parameter:  Maximal speed  <- 15.0 min: 0.1 max: 15.0;  //Factor for the boids flock  int cohesion_factor parameter:  Cohesion Factor  <- 100;   int alignment_factor parameter:  Alignment Factor  <- 100;   float minimal_distance parameter:  Minimal Distance  <- 10.0;   //MAximal angle of turn for the boids  int maximal_turn parameter:  Maximal Turn  <- 90 min: 0 max: 359;   //environment parameters  int width_and_height_of_environment parameter:  Width/Height of the Environment  <- 800;  int z_max parameter:  Z max of the Environment  <- 400;  bool torus_environment parameter:  Toroidal Environment ?  <- false;   //Experiment parameter  bool apply_cohesion <- true parameter:  Apply Cohesion ? ;  bool apply_alignment <- true parameter:  Apply Alignment ? ;   bool apply_separation <- true parameter:  Apply Separation ? ;   bool apply_goal <- true parameter:  Follow Goal ? ;   bool apply_wind <- true parameter:  Apply Wind ? ;     //Wind variable  point wind_vector <- {0,0,0}  parameter:  Direction of the wind ;   //Duration of the goal  int goal_duration <- 30 update: (goal_duration - 1);   //Location of the goal  point goal <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 ,(rnd(z_max - 2) + 1)};   list images <- [file( ../images/bird1.png ),file( ../images/bird2.png ),file( ../images/bird3.png )];   geometry shape <- cube(width_and_height_of_environment);  init {   //Creation of the boids agents that will be placed randomly within the environment   create boids number: number_of_agents {     location <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 , (rnd(z_max - 2) + 1)};   }    //Creation of the goal   create boids_goal {    location <- goal;   }  } }  //Species boids_goal that will represent the goal agent, using the skill moving species boids_goal skills: [moving3D] {  float range init: 20.0;  //Reflex to make the goal agent wander in a certain amplitude and a certain speed,  //Respecting the minimal and maximal z values reflex wander {   do  wander amplitude: 45 speed: 20;   if (location.z) < 0 {   location <- {location.x,location.y,0};  } else if (location.z) > z_max {   location <- {location.x,location.y,z_max};  }  goal <- location; }  aspect default {   draw sphere(10) color: #red ; } }    //Species boids that will represent the boids agents, using the skill moving species boids skills: [moving] {  //Attribute for the speed of the boids  float speed max: maximal_speed <- maximal_speed;  //Range of sensing of the boids  float range <- minimal_distance * 2;  point velocity <- {0,0, 0} ;  //List of the others boids in the range distance of the agent list others update: ((boids at_distance range)  - self); //Mass center of the flock represented as the other boids in the sensing range point mass_center update:  (length(others) > 0) ? (mean (others collect (each.location)) )  : location;  //Reflex to apply separation reflex separation when: apply_separation {  point acc <- {0,0,0};  loop boid over: (boids at_distance (minimal_distance))  {   acc <- acc - ((location of boid) - location);  }    velocity <- velocity + acc; } //Reflex to apply alignment reflex alignment when: apply_alignment {  point acc <- (length(others) > 0) ? (mean (others collect (each.velocity))) : {0.0,0.0,0.0};  acc <- acc - velocity;  velocity <- velocity + (acc / alignment_factor); } //Reflex to apply cohesion reflex cohesion when: apply_cohesion {  point acc <- mass_center - location;  acc <- acc / cohesion_factor;  velocity <- velocity + acc;  } //Action to make the agent location within the environment action bounding {  if (location.z) < 0 {   location <- {location.x,location.y,0};  } else if (location.z) > z_max {   location <- {location.x,location.y,z_max};  } } //Reflex to make the agent follow the goal reflex follow_goal when: apply_goal {  velocity <- velocity + ((goal - location) / cohesion_factor); } //Reflex to apply the wind by using the vector of wind reflex wind when: apply_wind {  velocity <- velocity + wind_vector; } //Action to make the agent moving action do_move {    if (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) and (((velocity.z) as int) = 0) {   velocity <- {(rnd(4)) -2, (rnd(4)) - 2,  ((rnd(4)) - 2)} ;   }  point old_location <- location;  do goto target: location + velocity;  velocity <- location - old_location; } //Reflex to move the agent, calling both bounding and do_move action reflex movement {  do bounding;  do do_move; }  aspect sphere {  draw sphere(10) color: #green; }  aspect image {  draw (images at (rnd(2))) size: boids_size rotate: heading color: #black ;       } }   experiment boids_3D type: gui {  output {    display Sky1 type:opengl  z_fighting:false{   image  background  file: ../images/ocean.jpg  ;   species boids aspect: image;   species boids_goal;   }    } }      ","url":"wiki/Boids-Boids-3D-Motion.md"},{"id":"wiki/Boids-Boids-With-Flocks.md","title":" Boids With Flocks","content":"# Boids With Flocks  _Author : _  This model shows the movement of boids following a goal, and creating without their own volonty, a flock .  Imported model :       model boids  global torus: torus_environment{   //Number of boids that will be created  int number_of_agents <- 50 min: 1 max: 1000000;  //Number of obstacles for the boids movement to represent  int number_of_obstacles <- 0 min: 0;  //Maximal speed of the boids  float maximal_speed <- 15.0 min: 0.1 max: 15.0;  //Factors for the group of boids  int cohesion_factor <- 200;  int alignment_factor <- 100;   //Variables for the movement of the boids  float minimal_distance <- 10.0;   int maximal_turn <- 45 min: 0 max: 359;  int width_and_height_of_environment <- 1000;   bool torus_environment <- false;  bool apply_cohesion <- true ; bool apply_alignment <- true ; bool apply_separation <- true; bool apply_avoid <- true;   bool apply_wind <- true;    bool moving_obstacles <- false;    int bounds <- int(width_and_height_of_environment / 20);  //Vector for the wind point wind_vector <- {0,0};  list images of: image_file <- [file( ../images/bird1.png ),file( ../images/bird2.png ),file( ../images/bird3.png )];  int xmin <- bounds;    int ymin <- bounds;   int xmax <- (width_and_height_of_environment - bounds);      int ymax <- (width_and_height_of_environment - bounds);     //Action to move the goal to the mouse location action move_goal(point mouse) {  ask first(boids_goal) {   do goto target: mouse speed: 30;  } }  geometry shape <- square(width_and_height_of_environment);  init {   //Create the boids agents  create boids number: number_of_agents {     location <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };  }   //Create the obstacles agents  create obstacle number: number_of_obstacles {   location <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };   }  //Create the goal that boids will follow  create  boids_goal;  }  }   //Species boids goal which represents the goal that will be followed by boids agents using the skill moving species boids_goal skills: [moving] {  float range  <- 20.0;  //If the mouse is not used, then the goal just wander reflex wander {    do  wander amplitude: 45 speed: 20;   }  aspect default {  draw circle(10) color: #red ;  draw circle(40) color: #orange empty: true; } }  //Species boids which represents the boids agents whom follow the boid goal agents, using the skill moving species boids skills: [moving] { //Speed of the boids agents float speed max: maximal_speed <- maximal_speed; //Range used to consider the group of the agent float range <- minimal_distance * 2; point velocity <- {0,0};   //Reflex used when the separation is applied to change the velocity of the boid reflex separation when: apply_separation {  point acc <- {0,0};  ask (boids overlapping (circle(minimal_distance)))  {   acc <- acc - ((location) - myself.location);  }    velocity <- velocity + acc; }  //Reflex to align the boid with the other boids in the range reflex alignment when: apply_alignment {  list others  <- ((boids overlapping (circle (range)))  - self);  point acc <- mean (others collect (each.velocity)) - velocity;  velocity <- velocity + (acc / alignment_factor); }   //Reflex to apply the cohesion of the boids group in the range of the agent reflex cohesion when: apply_cohesion {  list others <- ((boids overlapping (circle (range)))  - self);  point mass_center <- (length(others) > 0) ? mean (others collect (each.location)) : location;   point acc <- mass_center - location;  acc <- acc / cohesion_factor;   velocity <- velocity + acc;    }  //Reflex to avoid the obstacles reflex avoid when: apply_avoid {   point acc <- {0,0};  list<obstacle> nearby_obstacles <- (obstacle overlapping (circle (range)) );  loop obs over: nearby_obstacles {   acc <- acc - ((location of obs) - my (location));  }  velocity <- velocity + acc;  }  //action to represent the bounding of the environment considering the velocity of the boid action bounding {  if  !(torus_environment) {   if  (location.x) < xmin {    velocity <- velocity + {bounds,0};   } else if (location.x) > xmax {    velocity <- velocity - {bounds,0};   }      if (location.y) < ymin {    velocity <- velocity + {0,bounds};   } else if (location.y) > ymax {    velocity <- velocity - {0,bounds};   }     } } //Reflex to follow the goal  reflex follow_goal {  velocity <- velocity + ((first(boids_goal).location - location) / cohesion_factor); } //Reflex to apply the wind vector on the velocity reflex wind when: apply_wind {  velocity <- velocity + wind_vector; }  //Action to move the agent   action do_move {    if (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) {   velocity <- {(rnd(4)) -2, (rnd(4)) - 2};  }  point old_location <- copy(location);  do goto target: location + velocity;  velocity <- location - old_location; }  //Reflex to apply the movement by calling the do_move action reflex movement {  do do_move; }  aspect image {  draw (images at (rnd(2))) size: {50,50} rotate: heading ;       } aspect circle {   draw circle(15)  color: #red; }  aspect default {   draw circle(20) color: #lightblue empty: true; } }    //Species obstacle that represents the obstacles avoided by the boids agents using the skill moving species obstacle skills: [moving] {  float speed <- 2.0;  geometry shape <- triangle(15);  //Reflex to move the obstacles if it is available reflex move_obstacles when: moving_obstacles {  //Will make the agent go to a boid with a 50% probability  if flip(0.5)    {    do goto target: one_of(boids);  }   else{    do wander amplitude: 360;     } } aspect default {  draw  triangle(20) color: #black ; }   }  experiment boids_gui type: gui {  parameter  Number of agents  var: number_of_agents;  parameter  Number of obstacles  var: number_of_obstacles;  parameter  Maximal speed  var: maximal_speed;  parameter  Cohesion Factor  var: cohesion_factor;  parameter  Alignment Factor  var: alignment_factor;   parameter  Minimal Distance   var: minimal_distance;   parameter  Maximal Turn   var: maximal_turn;   parameter  Width/Height of the Environment  var: width_and_height_of_environment ;  parameter  Toroidal Environment ?   var: torus_environment ;   parameter  Apply Cohesion ?  var: apply_cohesion ;  parameter  Apply Alignment ?  var: apply_alignment ;   parameter  Apply Separation ?  var: apply_separation ;   parameter  Apply Avoidance ?  var: apply_avoid ;   parameter  Apply Wind ?  var: apply_wind ;     parameter  Moving Obstacles ?  var: moving_obstacles  ;    parameter  Direction of the wind  var: wind_vector ;  //Minimum duration of a step to better see the movements float minimum_cycle_duration <- 0.01;  output {  display Sky  background: #blue type: opengl {    image  ../images/sky.jpg  refresh: false;   species boids aspect: image trace: 10 fading: true ;   species boids_goal;   species obstacle;   //Event to call the action move_goal in global if the mouse move within the experiment   event mouse_move action: move_goal;  }  } }       Code of the model :      model boids_flock //Import the boids model import  Boids.gaml  global {  //Size of the boids  float boids_size <- float(3);  //Shape of the boids  geometry boids_shape <- circle(boids_size);  //Separation between boids  float boids_separation <- 4 * boids_size;  //Distance to allow creation of the flock   int flock_creation_distance <- int(boids_separation + 1);  //Minimum number of member among a flock  int min_group_member <- 3;  //Frequency of update for the flock  int update_frequency <- 10;  //Frequency of merge for the flock  int merge_frequency <- 10;  //Allow the creation of flock  bool create_flocks <- false;  //Perception range of the boids  int base_perception_range <- int(xmax / 100) min: 1;  init {  //Creation of the different agents viewer  create boids_agents_viewer;  create flock_agents_viewer;  create boids_in_flock_viewer; } //Reflex to create the flocks if it is available reflex create_flocks when: create_flocks {    if (length(boids) > 1) {   //Clustering by distance of the boids to determine the satisfying boids groups   list<list<boids>> satisfying_boids_groups <- (boids.population simple_clustering_by_distance flock_creation_distance) where ((length(each)) > min_group_member);   loop one_group over: satisfying_boids_groups {        geometry potential_flock_polygon <- convex_hull(solid(polygon(one_group collect boids(each).location)) + (base_perception_range + 5));    //If there is no obstacle between the boids of a potential flock, then the flock is created and all the boids become boids in flock    if (empty(obstacle overlapping potential_flock_polygon)) {     create flock {      capture one_group as: boids_in_flock;     }    }    }   }  }   }  //Species flock which represent the flock of boids, using the skill moving species flock skills: [moving] {  rgb color <- rgb(rnd(255), rnd(255), rnd(255));  geometry shape <- polygon(((boids_in_flock))) buffer 10;  //Range of perception of the flock  float perception_range <- float(base_perception_range + (rnd(5)));  //Speed of the flock  float speed update: mean(boids_in_flock collect each.speed);  //Reflex to disaggregate the flock if there is a obstacle in the flock  reflex disaggregate {   geometry buffered_shape <- shape + perception_range;   if !(empty(obstacle overlapping buffered_shape)) {    release members as: boids in: world;    do die;   }  } //Reflex to capture the boids nearby in the range of perception with an update_frequency reflex capture_nearby_boids when: ((cycle mod update_frequency) = 0) {  geometry buffered_shape <- shape + perception_range;  list<boids> nearby_boids <- (boids overlapping buffered_shape);  if (!(empty(nearby_boids))) {   geometry new_polygon <- convex_hull(solid(shape + polygon(nearby_boids collect (each.location))));   if (empty(obstacle overlapping new_polygon)) {    capture nearby_boids as: boids_in_flock;   }   }  } //Reflex to merge the intersecting flocks reflex merge_nearby_flocks when: ((cycle mod merge_frequency) = 0)  {  loop f over: (flock) {   if (f != self and (shape intersects f.shape)) {    geometry new_shape <- convex_hull(polygon(shape.points + f.shape.points));    if empty(obstacle overlapping new_shape) {     list<boids> released_boids;     ask f {      release members as: boids in: world returns: released_coms;      released_boids <- list(released_coms);      do die;     }      if (!empty(released_boids)) {      capture released_boids as: boids_in_flock;     }      shape <- convex_hull(polygon(members collect (boids_in_flock(each).location)));    }    }   }  } //Reflex to make the flock follow the goal reflex chase_goal {  int direction_to_nearest_ball <- (self towards (first(boids_goal)));  float step_distance <- speed * step;  float dx <- step_distance * (cos(direction_to_nearest_ball));  float dy <- step_distance * (sin(direction_to_nearest_ball));  geometry envelope <- shape.envelope;  float min_y <- (envelope.points with_min_of (each.y)).y;  float min_x <- (envelope.points with_min_of (each.x)).x;  float max_x <- (envelope.points with_max_of (each.x)).x;  float max_y <- (envelope.points with_max_of (each.y)).y;  if (((dx + min_x) < xmin) and min_x > xmin) or (((dx + max_x) > xmax) and max_x < xmax) {   dx <- 0.0;  }  if (((dy + min_y) < ymin) and min_y > ymin) or (((dy + max_y) > ymax) and max_y < ymax) {   dy <- 0.0;  }    loop com over: boids_in_flock {   (boids_in_flock(com)).location <- (boids_in_flock(com)).location + { dx, dy };  }   shape <- convex_hull(polygon(list(boids_in_flock) collect (each.location))); }  aspect default {  draw shape color: color; } //Species boids_in_flock which represents the boids agents captured by the flock species boids_in_flock parent: boids {  float my_age <- 1.0 update: my_age + 0.01;  reflex separation when: apply_separation {  }   reflex alignment when: apply_alignment {  }   reflex cohesion when: apply_cohesion {  }   reflex avoid when: apply_avoid {  }   reflex follow_goal  {  }   reflex wind when: apply_wind {  }   action do_move {  }   reflex movement {   do do_move;  }   aspect default {   draw circle(my_age) color: ((host as flock).color).darker;  }  }   } //Species flock agents viewer which draw the flock information species flock_agents_viewer {  aspect default {   draw  Flocks:   + (string(length(list(flock)))) at: { width_and_height_of_environment - 810, (width_and_height_of_environment) - 5 } color: #blue size: 80 ;  }  } //Species boids agents viewer which draw the boids information species boids_agents_viewer {  aspect default {   draw  Boids:   + (string(length(list(boids)))) at: { width_and_height_of_environment - 810, (width_and_height_of_environment) - 165 } color: #blue size: 80 ;  }  }  //Species boids_in_flock_viewer which draw the boids in flock information species boids_in_flock_viewer {  aspect default {   draw  Boids in flocks:   + (string(number_of_agents - (length(list(boids))))) at: { width_and_height_of_environment - 810, width_and_height_of_environment - 85 } color:   #blue size: 80 ;  }  }  experiment boids_flocks type: gui {  parameter  Create flock?  var: create_flocks <- true;  parameter  Number of boids  var: number_of_agents <- 300;  parameter  Environment size  var: width_and_height_of_environment <- 1600;  parameter  Moving obstacles?  var: moving_obstacles <- true;  parameter  Torus environment?  var: torus_environment <- false;  parameter  Number of obstacles  var: number_of_obstacles <- 5;  output {   display default_display {    species boids_goal;    species boids aspect: image;    species obstacle;    species flock aspect: default transparency: 0.5 {     species boids_in_flock aspect: default;    }    species flock_agents_viewer;   species boids_agents_viewer;   species boids_in_flock_viewer;  }  }   }     ","url":"wiki/Boids-Boids-With-Flocks.md"},{"id":"wiki/Boids-Boids.md","title":" Boids","content":"# Boids  _Author : _  This model shows the movement of boids following a goal, and creating without their own volonty, a flock. The experiment proposes to display in a 3D view the different boids and allows the user to move the goal to see the behaviour of boids.  Code of the model :       model boids  global torus: torus_environment{   //Number of boids that will be created  int number_of_agents <- 50 min: 1 max: 1000000;  //Number of obstacles for the boids movement to represent  int number_of_obstacles <- 0 min: 0;  //Maximal speed of the boids  float maximal_speed <- 15.0 min: 0.1 max: 15.0;  //Factors for the group of boids  int cohesion_factor <- 200;  int alignment_factor <- 100;   //Variables for the movement of the boids  float minimal_distance <- 10.0;   int maximal_turn <- 45 min: 0 max: 359;  int width_and_height_of_environment <- 1000;   bool torus_environment <- false;  bool apply_cohesion <- true ; bool apply_alignment <- true ; bool apply_separation <- true; bool apply_avoid <- true;   bool apply_wind <- true;    bool moving_obstacles <- false;    int bounds <- int(width_and_height_of_environment / 20);  //Vector for the wind point wind_vector <- {0,0};  list images of: image_file <- [file( ../images/bird1.png ),file( ../images/bird2.png ),file( ../images/bird3.png )];  int xmin <- bounds;    int ymin <- bounds;   int xmax <- (width_and_height_of_environment - bounds);      int ymax <- (width_and_height_of_environment - bounds);     //Action to move the goal to the mouse location action move_goal(point mouse) {  ask first(boids_goal) {   do goto target: mouse speed: 30;  } }  geometry shape <- square(width_and_height_of_environment);  init {   //Create the boids agents  create boids number: number_of_agents {     location <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };  }   //Create the obstacles agents  create obstacle number: number_of_obstacles {   location <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };   }  //Create the goal that boids will follow  create  boids_goal;  }  }   //Species boids goal which represents the goal that will be followed by boids agents using the skill moving species boids_goal skills: [moving] {  float range  <- 20.0;  //If the mouse is not used, then the goal just wander reflex wander {    do  wander amplitude: 45 speed: 20;   }  aspect default {  draw circle(10) color: #red ;  draw circle(40) color: #orange empty: true; } }  //Species boids which represents the boids agents whom follow the boid goal agents, using the skill moving species boids skills: [moving] { //Speed of the boids agents float speed max: maximal_speed <- maximal_speed; //Range used to consider the group of the agent float range <- minimal_distance * 2; point velocity <- {0,0};   //Reflex used when the separation is applied to change the velocity of the boid reflex separation when: apply_separation {  point acc <- {0,0};  ask (boids overlapping (circle(minimal_distance)))  {   acc <- acc - ((location) - myself.location);  }    velocity <- velocity + acc; }  //Reflex to align the boid with the other boids in the range reflex alignment when: apply_alignment {  list others  <- ((boids overlapping (circle (range)))  - self);  point acc <- mean (others collect (each.velocity)) - velocity;  velocity <- velocity + (acc / alignment_factor); }   //Reflex to apply the cohesion of the boids group in the range of the agent reflex cohesion when: apply_cohesion {  list others <- ((boids overlapping (circle (range)))  - self);  point mass_center <- (length(others) > 0) ? mean (others collect (each.location)) : location;   point acc <- mass_center - location;  acc <- acc / cohesion_factor;   velocity <- velocity + acc;    }  //Reflex to avoid the obstacles reflex avoid when: apply_avoid {   point acc <- {0,0};  list<obstacle> nearby_obstacles <- (obstacle overlapping (circle (range)) );  loop obs over: nearby_obstacles {   acc <- acc - ((location of obs) - my (location));  }  velocity <- velocity + acc;  }  //action to represent the bounding of the environment considering the velocity of the boid action bounding {  if  !(torus_environment) {   if  (location.x) < xmin {    velocity <- velocity + {bounds,0};   } else if (location.x) > xmax {    velocity <- velocity - {bounds,0};   }      if (location.y) < ymin {    velocity <- velocity + {0,bounds};   } else if (location.y) > ymax {    velocity <- velocity - {0,bounds};   }     } } //Reflex to follow the goal  reflex follow_goal {  velocity <- velocity + ((first(boids_goal).location - location) / cohesion_factor); } //Reflex to apply the wind vector on the velocity reflex wind when: apply_wind {  velocity <- velocity + wind_vector; }  //Action to move the agent   action do_move {    if (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) {   velocity <- {(rnd(4)) -2, (rnd(4)) - 2};  }  point old_location <- copy(location);  do goto target: location + velocity;  velocity <- location - old_location; }  //Reflex to apply the movement by calling the do_move action reflex movement {  do do_move; }  aspect image {  draw (images at (rnd(2))) size: {50,50} rotate: heading ;       } aspect circle {   draw circle(15)  color: #red; }  aspect default {   draw circle(20) color: #lightblue empty: true; } }    //Species obstacle that represents the obstacles avoided by the boids agents using the skill moving species obstacle skills: [moving] {  float speed <- 2.0;  geometry shape <- triangle(15);  //Reflex to move the obstacles if it is available reflex move_obstacles when: moving_obstacles {  //Will make the agent go to a boid with a 50% probability  if flip(0.5)    {    do goto target: one_of(boids);  }   else{    do wander amplitude: 360;     } } aspect default {  draw  triangle(20) color: #black ; }   }  experiment boids_gui type: gui {  parameter  Number of agents  var: number_of_agents;  parameter  Number of obstacles  var: number_of_obstacles;  parameter  Maximal speed  var: maximal_speed;  parameter  Cohesion Factor  var: cohesion_factor;  parameter  Alignment Factor  var: alignment_factor;   parameter  Minimal Distance   var: minimal_distance;   parameter  Maximal Turn   var: maximal_turn;   parameter  Width/Height of the Environment  var: width_and_height_of_environment ;  parameter  Toroidal Environment ?   var: torus_environment ;   parameter  Apply Cohesion ?  var: apply_cohesion ;  parameter  Apply Alignment ?  var: apply_alignment ;   parameter  Apply Separation ?  var: apply_separation ;   parameter  Apply Avoidance ?  var: apply_avoid ;   parameter  Apply Wind ?  var: apply_wind ;     parameter  Moving Obstacles ?  var: moving_obstacles  ;    parameter  Direction of the wind  var: wind_vector ;  //Minimum duration of a step to better see the movements float minimum_cycle_duration <- 0.01;  output {  display Sky  background: #blue type: opengl {    image  ../images/sky.jpg  refresh: false;   species boids aspect: image trace: 10 fading: true ;   species boids_goal;   species obstacle;   //Event to call the action move_goal in global if the mouse move within the experiment   event mouse_move action: move_goal;  }  } }      ","url":"wiki/Boids-Boids.md"},{"id":"wiki/Circle-Circle.md","title":" Circle","content":"# Circle  _Author : _  This model shows the movement of cells trying to do a circle shape with themselves considering the other cells. The second experiment shows a bigger circle using more cell agents.  Code of the model :      model circle_model  global {   //Number of agents to create  int number_of_agents min: 1 <- 50 ;  //Radius of the circle that the cells will make  int radius_of_circle min: 10 <- 1000 ;  //Repulsion strength of one cell to the others  int repulsion_strength min: 1 <- 5 ;  //Size of the environment  int width_and_height_of_environment min: 10 <- 3000 ;   //Range of the agents  int range_of_agents min: 1 <- 25 ;  //Speed of the agents  float speed_of_agents min: 0.1  <- 2.0 ;   //Size of the agents  int size_of_agents <- 100;  //Center of the considered circle created by the cells  point center const: true <- {width_and_height_of_environment/2,width_and_height_of_environment/2};  geometry shape <- square(width_and_height_of_environment);  init {    //Creation of the cell agents   create cell number: number_of_agents;  } }  //Species cell which represents the cell agents, using the skill moving species cell skills: [moving] {  //Color of the cell, randomly chosen  rgb color const: true <- [100 + rnd (155),100 + rnd (155), 100 + rnd (155)] as rgb;  //Size of the cell  float size const: true <- float(size_of_agents);  //Range of the cell  float range const: true <- float(range_of_agents);   //Speed of the cell  float speed const: true <- speed_of_agents;   //Heading of the cell, the direction it  watches   int heading <- rnd(359);  //Reflex to make the cell agent fo to the center, calling the derivated action move reflex go_to_center {  heading <- (((self distance_to center) > radius_of_circle) ? self towards center : (self towards center) - 180);  do move speed: speed;  } //Reflex to flee of the other cells agents, which will help to design the circle shape reflex flee_others {  cell close <- one_of ( ( (self neighbors_at range) of_species cell) sort_by (self distance_to each) );  if close != nil {   heading <- (self towards close) - 180;   float dist <- self distance_to close;   do move speed: dist / repulsion_strength heading: heading;  } }  aspect default {   draw circle(size)  color: color; } }   experiment main type: gui {  parameter  Number of Agents  var: number_of_agents;  parameter  Radius of Circle  var: radius_of_circle;   parameter  Strength of Repulsion  var: repulsion_strength;   parameter  Dimensions  var: width_and_height_of_environment;  parameter  Range of Agents  var: range_of_agents;  parameter  Speed of Agents  var: speed_of_agents ;  output {  display Circle {   species cell;  } } } experiment main2 type: gui  { parameter Size of Agents var: size_of_agents <- 100; parameter  Number of Agents  var: number_of_agents <- 300; parameter  Radius of Circle  var: radius_of_circle min: 10 <- 15000; parameter  Strength of Repulsion  var: repulsion_strength min: 1 <- 50; parameter  Dimensions  var: width_and_height_of_environment  min: 10 <- 40000; parameter  Range of Agents  var: range_of_agents min: 1 <- 250; parameter  Speed of Agents  var: speed_of_agents min: 0.1 <- 100.0 ;  output {  display Circle  {   species cell;  } } }       ","url":"wiki/Circle-Circle.md"},{"id":"wiki/Clock-Clock.md","title":" Clock","content":"# Clock  _Author : JD _  Code of the model :      model Clock  global {  //Background of the clock  file clock_normal     const: true <- image_file( ../images/clock.png );  //Image for the big hand   file clock_big_hand   const: true <- image_file( ../images/big_hand.png );  //Image for the small hand  file clock_small_hand const: true <- image_file( ../images/small_hand.png );  //Image for the clock alarm  file clock_alarm    const: true <- image_file( ../images/alarm_hand.png );  //Zoom to take in consideration the zoom in the display, to better write the cycle values  int zoom <- 4 min:1 max:100;  //Time value for a cycle  float step<-360000.0#ms min: 1.0 max: 360000.0;  //Alarm parameters int alarm_days <- 0 min:0 max:365; int alarm_hours <- 2 min:0 max:11; int alarm_minutes <- 0 min:0 max:59; int alarm_seconds <- 0 min:0 max:59; bool alarm_am <- true; int alarmCycle <-  int((alarm_seconds+alarm_minutes*60+alarm_hours*3600 + (alarm_am ? 0 : 3600*12) + alarm_days*3600*24) * 1000 / step);  //Time elapsed since the beginning of the experiment int timeElapsed <- 0 update:  int(cycle * step); string reflexType <-; init {  //Creation of the clock  create clock number: 1 {   location <- {world.shape.width/5,world.shape.height/5};  } } } //Species that will represent the clock species  clock {   float nb_minutes<-0.0 update: ((timeElapsed mod 3600000#ms))/60000#ms; //Mod with 60 minutes or 1 hour, then divided by one minute value to get the number of minutes  float nb_hours<-0.0 update:((timeElapsed mod 43200000#ms))/3600000#ms;  reflex update {   write string(nb_hours)+ : +nb_minutes;   if (cycle = alarmCycle)    {     write Time to leave ;       // Uncomment the following statement to play the Alarm.mp3     // But firstly, you need to go to Help -> Install New Software... to install the Audio feature (which is still in the experimental stage).     //start_sound source:../includes/Alarm.mp3 ;   }  }  aspect default {   draw string(#cycles:  + cycle +  cycles)  size:zoom/2 font:times color:°black at:{world.shape.width/3,0};   draw clock_big_hand rotate: nb_minutes*(360/60)  + 90  size: {7 * zoom, 2}; //Modulo with the representation of a minute in ms and divided by 10000 to get the degree of rotation   draw clock_small_hand rotate: nb_hours*(360/12)  + 90  size:{5*zoom, 2} ;      draw clock_alarm rotate:      (alarmCycle/12000)  size: zoom/3 ; // Alarm time  }   }  experiment Display type: gui {  float minimum_cycle_duration <- 0.1#s;  parameter  Zoom:   var: zoom category:  Init  ;  parameter  Milliseconds/cycle  var: step category:  Init ;  parameter  alarm Day  var: alarm_days;  parameter  alarm Hour  var: alarm_hours;  parameter  alarm Am  var: alarm_am;  parameter  alarm Minutes  var: alarm_minutes;  parameter  alarm Seconds  var: alarm_seconds;  output {   display ClockView type: opengl {     graphics  c  refresh: false {draw clock_normal size: 10*zoom at:{world.shape.width/5,world.shape.height/5} ;}    species clock ;   }  }  }      ","url":"wiki/Clock-Clock.md"},{"id":"wiki/Co-model-Example-Comodel_SIR_Switch.md","title":" Comodel SIR Switch","content":"# Comodel SIR Switch  Author : HUYNH Quang Nghi  This is a comodel that implement the dynamic of SIR_switch: it will use the EBM when the density of population is big and ABM when the density of population is low. It demonstrate the capability of using dynamically the legacy models. SIR_ABM_coupling is the coupling that manipulates the elements inside SIR_ABM model and proposes the function would be used from outside. SIR_ABM is a simple example of SIR that use the agents to represent the spreading of disease.. SIR_EBM_coupling is the coupling that manipulates the elements inside SIR_EBM model and proposes the function would be used from outside. SIR_EBM is a simple example of ODE use into agents with the example of the SIR equation system.  Imported models :      model SIR_ABM  global{  geometry shape<-envelope(square(100));  float beta <- 0.5 ;     float nu <- 0.001 ;  float delta <- 0.01;  init{   create Host number:495 ;   create Host number:5{state<-1;}  } }   species Host skills:[moving]{  int state<-0;  list color<-[#green, #red, #yellow];  reflex moving{   do wander;  }  reflex become_infected when: state=1 {  list n<- self neighbors_at(1);  ask n{            if (flip(beta)) {    state<-1;   }  } }  reflex become_immune when: (state=1 and flip(delta)) {  state<-2; } aspect base{  draw circle(1) color: color[state]; } } experiment SIR_ABM_exp type:gui{ output {  display gridDisp{   species Host aspect:base;  } } }           model SIR_ABM_coupling  import  SIR_ABM.gaml  experiment SIR_ABM_coupling_exp type: gui parent: SIR_ABM_exp {  int get_num_S  {   return length(Host where (each.state = 0));  }  int get_num_I {  return length(Host where (each.state = 1)); }  int get_num_R {  return length(Host where (each.state = 2)); }  action set_num_S_I_R (int numS, int numI, int numR) {  unknown call;  call <- set_num_S(numS);  call <- set_num_I(numI);  call <- set_num_R(numR); }  action set_num_S (int num) {  ask (Host where (each.state = 0))  {   do die;  }   create Host number: num  {   state <- 0;  }  }  action set_num_I (int num) {  ask (Host where (each.state = 1))  {   do die;  }   create Host number: num  {   state <- 1;  }  }  action set_num_R (int num) {  ask (Host where (each.state = 2))  {   do die;  }   create Host number: num  {   state <- 2;  }  }  output { }   }          model SIR_EBM  global {  init{   create agent_with_SIR_dynamic;  }  }  species agent_with_SIR_dynamic {  int N <- 495 ;  int iInit <- 5;  float t;   float S <- N - float(iInit);         float I <- float(iInit);  float R <- 0.0;   float alpha <- 0.2; float beta <- 0.8;   float h <- 0.01;     equation SIR{   diff(S,t) = (- beta *   S * I / N);  diff(I,t) = (  beta*  S * I / N) - (alpha * I)  ;  diff(R,t) = (  alpha  *  I) ; }    reflex solving { //     write S;  solve SIR method: rk4 step: h;// cycle_length: 1/h ; }     }   experiment SIR_EBM_exp type: gui {  output {    display display_charts {    chart  SIR_agent  type: series background: #white {     data  S  value: first(list(agent_with_SIR_dynamic)).S color: #green ;         data  I  value: first(list(agent_with_SIR_dynamic)).I color: #red ;     data  R  value: first(list(agent_with_SIR_dynamic)).R color: #blue ;    }   }  } }          model SIR_EBM_coupling  import  SIR_EBM.gaml  experiment SIR_EBM_coupling_exp type: gui parent: SIR_EBM_exp {  int get_num_S  {   return first(agent_with_SIR_dynamic).S;  }  int get_num_I {  return first(agent_with_SIR_dynamic).I; }  int get_num_R {  return first(agent_with_SIR_dynamic).R; }  action set_num_S_I_R (int numS, int numI, int numR) {  unknown call;  call <- set_num_S(numS);  call <- set_num_I(numI);  call <- set_num_R(numR); }  action set_num_S (int num) {  first(agent_with_SIR_dynamic).S <- float(num); }  action set_num_I (int num) {  first(agent_with_SIR_dynamic).I <- float(num); }  action set_num_R (int num) {  first(agent_with_SIR_dynamic).R <- float(num); }  output { }   }      Code of the model :      model Comodel_SIR_Switch  import  Legacy_models/SIR_EBM_coupling.gaml  as SIR_1 import  Legacy_models/SIR_ABM_coupling.gaml  as SIR_2  global {  geometry shape <- envelope(square(100));  int switch_threshold <- 120; // threshold for switching models  int threshold_to_IBM <- 220; // threshold under which the model swith to IBM  int threshold_to_Maths <- 20;  init  {   create SIR_1.SIR_EBM_coupling_exp;   create SIR_2.SIR_ABM_coupling_exp;   create Switch;  }  }  species Switch {  int S <- 495;  int I <- 5;  int R <- 0;  reflex request_from_micro_model  {   //if the size of S population and I population are bigger than a threshold, use the EBM   if (S > threshold_to_Maths and I > threshold_to_Maths)   {    ask world    {     unknown call;     call <- first(SIR_1.SIR_EBM_coupling_exp).set_num_S_I_R(myself.S, myself.I, myself.R);     ask first(SIR_1.SIR_EBM_coupling_exp).simulation     {      loop times: 5      {       do step;      }     }     myself.S <- first(SIR_1.SIR_EBM_coupling_exp).get_num_S();    myself.I <- first(SIR_1.SIR_EBM_coupling_exp).get_num_I();    myself.R <- first(SIR_1.SIR_EBM_coupling_exp).get_num_R();   }   }    //if the size of S population or  I population are smaller  than a threshold, use the ABM  if (I < threshold_to_IBM or S < threshold_to_IBM)  {   ask world   {    unknown call;    call <- first(SIR_2.SIR_ABM_coupling_exp).set_num_S_I_R(myself.S, myself.I, myself.R);    ask first(SIR_2.SIR_ABM_coupling_exp).simulation    {     loop times: 1     {      do _step_;     }     }     myself.S <- first(SIR_2.SIR_ABM_coupling_exp).get_num_S();    myself.I <- first(SIR_2.SIR_ABM_coupling_exp).get_num_I();    myself.R <- first(SIR_2.SIR_ABM_coupling_exp).get_num_R();   }   }  }  aspect base {  draw square(100); }   }  experiment Simple_exp type: gui {  output  {   display co_SIR_chart   {    chart  SIR_agent  type: series background: # white    {     data  S  value: first(Switch).S color: # green;     data  I  value: first(Switch).I color: # red;     data  R  value: first(Switch).R color: # yellow;    }   }  }   }     ","url":"wiki/Co-model-Example-Comodel_SIR_Switch.md"},{"id":"wiki/Co-model-Example-comodelBoidsVoronoi.md","title":" Comodel of Boids and Voronoi","content":"# Comodel of Boids and Voronoi  Author : HUYNH Quang Nghi  Co-model example : Voronoi applied on Boids.  Imported models :       model voronoi  global {  // Parameters   //Number of points  int num_points <- 4 min: 1 max: 1000;  //Size of the environment  int env_width <- 100 min: 10 max: 400;  int env_height <- 100 min: 10 max: 400;  // Environment geometry shape <- rectangle(env_width, env_height);  init {   write  This model shows how Voronoi-like shapes can be drawn on a regular surface. A set of mobile agents is placed on a grid. Each agent possesses an attribute called *inside_color*. Each step, the agents move randomly and the grid cells paint themselves using the *inside_color* of the nearest agent. Dynamical boundaries then appear on the screen without any further calculations. ;  //Creation of all the points  create center number: num_points ;   }    }  //Grid for the voronoi clustering grid cell width: env_width height: env_height neighbors: 8 use_regular_agents: false { // Note: since GAMA 1.7, the topology needs to be specified for this computation to use continuous distances center closest_center <- nil update: (center closest_to self.location) using topology(world); rgb color <- #white update: (closest_center).color; } //Species representing the center of a Voronoi point species center skills: [moving] {  rgb color <- rgb([rnd (255),rnd (255),rnd (255)]);  //Make the center of the cluster wander in the environment reflex wander {  do wander amplitude: 90; }   aspect base {  draw square(1.0) color: color; } }   experiment voronoi type: gui{   parameter  Number of points:  var: num_points;  parameter  Width of the environment:  var: env_width;  parameter  Height of the environment:  var: env_height;  output {  display Voronoi type: opengl {   grid cell  ;   species center aspect: base ;  } }  }           model Voronoi_coupling  import  ../../../Toy Models/Voronoi/Voronoi.gaml   experiment Voronoi_coupling_exp type:gui  parent:voronoi{  list<center> getCenter{  return list(center); } list<cell> getCell{  return list(cell); }   output{ } }            model boids  global torus: torus_environment{   //Number of boids that will be created  int number_of_agents <- 50 min: 1 max: 1000000;  //Number of obstacles for the boids movement to represent  int number_of_obstacles <- 0 min: 0;  //Maximal speed of the boids  float maximal_speed <- 15.0 min: 0.1 max: 15.0;  //Factors for the group of boids  int cohesion_factor <- 200;  int alignment_factor <- 100;   //Variables for the movement of the boids  float minimal_distance <- 10.0;   int maximal_turn <- 45 min: 0 max: 359;  int width_and_height_of_environment <- 1000;   bool torus_environment <- false;  bool apply_cohesion <- true ; bool apply_alignment <- true ; bool apply_separation <- true; bool apply_avoid <- true;   bool apply_wind <- true;    bool moving_obstacles <- false;    int bounds <- int(width_and_height_of_environment / 20);  //Vector for the wind point wind_vector <- {0,0};  list images of: image_file <- [file( ../images/bird1.png ),file( ../images/bird2.png ),file( ../images/bird3.png )];  int xmin <- bounds;    int ymin <- bounds;   int xmax <- (width_and_height_of_environment - bounds);      int ymax <- (width_and_height_of_environment - bounds);     //Action to move the goal to the mouse location action move_goal(point mouse) {  ask first(boids_goal) {   do goto target: mouse speed: 30;  } }  geometry shape <- square(width_and_height_of_environment);  init {   //Create the boids agents  create boids number: number_of_agents {     location <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };  }   //Create the obstacles agents  create obstacle number: number_of_obstacles {   location <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };   }  //Create the goal that boids will follow  create  boids_goal;  }  }   //Species boids goal which represents the goal that will be followed by boids agents using the skill moving species boids_goal skills: [moving] {  float range  <- 20.0;  //If the mouse is not used, then the goal just wander reflex wander {    do  wander amplitude: 45 speed: 20;   }  aspect default {  draw circle(10) color: #red ;  draw circle(40) color: #orange empty: true; } }  //Species boids which represents the boids agents whom follow the boid goal agents, using the skill moving species boids skills: [moving] { //Speed of the boids agents float speed max: maximal_speed <- maximal_speed; //Range used to consider the group of the agent float range <- minimal_distance * 2; point velocity <- {0,0};   //Reflex used when the separation is applied to change the velocity of the boid reflex separation when: apply_separation {  point acc <- {0,0};  ask (boids overlapping (circle(minimal_distance)))  {   acc <- acc - ((location) - myself.location);  }    velocity <- velocity + acc; }  //Reflex to align the boid with the other boids in the range reflex alignment when: apply_alignment {  list others  <- ((boids overlapping (circle (range)))  - self);  point acc <- mean (others collect (each.velocity)) - velocity;  velocity <- velocity + (acc / alignment_factor); }   //Reflex to apply the cohesion of the boids group in the range of the agent reflex cohesion when: apply_cohesion {  list others <- ((boids overlapping (circle (range)))  - self);  point mass_center <- (length(others) > 0) ? mean (others collect (each.location)) : location;   point acc <- mass_center - location;  acc <- acc / cohesion_factor;   velocity <- velocity + acc;    }  //Reflex to avoid the obstacles reflex avoid when: apply_avoid {   point acc <- {0,0};  list<obstacle> nearby_obstacles <- (obstacle overlapping (circle (range)) );  loop obs over: nearby_obstacles {   acc <- acc - ((location of obs) - my (location));  }  velocity <- velocity + acc;  }  //action to represent the bounding of the environment considering the velocity of the boid action bounding {  if  !(torus_environment) {   if  (location.x) < xmin {    velocity <- velocity + {bounds,0};   } else if (location.x) > xmax {    velocity <- velocity - {bounds,0};   }      if (location.y) < ymin {    velocity <- velocity + {0,bounds};   } else if (location.y) > ymax {    velocity <- velocity - {0,bounds};   }     } } //Reflex to follow the goal  reflex follow_goal {  velocity <- velocity + ((first(boids_goal).location - location) / cohesion_factor); } //Reflex to apply the wind vector on the velocity reflex wind when: apply_wind {  velocity <- velocity + wind_vector; }  //Action to move the agent   action do_move {    if (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) {   velocity <- {(rnd(4)) -2, (rnd(4)) - 2};  }  point old_location <- copy(location);  do goto target: location + velocity;  velocity <- location - old_location; }  //Reflex to apply the movement by calling the do_move action reflex movement {  do do_move; }  aspect image {  draw (images at (rnd(2))) size: {50,50} rotate: heading ;       } aspect circle {   draw circle(15)  color: #red; }  aspect default {   draw circle(20) color: #lightblue empty: true; } }    //Species obstacle that represents the obstacles avoided by the boids agents using the skill moving species obstacle skills: [moving] {  float speed <- 2.0;  geometry shape <- triangle(15);  //Reflex to move the obstacles if it is available reflex move_obstacles when: moving_obstacles {  //Will make the agent go to a boid with a 50% probability  if flip(0.5)    {    do goto target: one_of(boids);  }   else{    do wander amplitude: 360;     } } aspect default {  draw  triangle(20) color: #black ; }   }  experiment boids_gui type: gui {  parameter  Number of agents  var: number_of_agents;  parameter  Number of obstacles  var: number_of_obstacles;  parameter  Maximal speed  var: maximal_speed;  parameter  Cohesion Factor  var: cohesion_factor;  parameter  Alignment Factor  var: alignment_factor;   parameter  Minimal Distance   var: minimal_distance;   parameter  Maximal Turn   var: maximal_turn;   parameter  Width/Height of the Environment  var: width_and_height_of_environment ;  parameter  Toroidal Environment ?   var: torus_environment ;   parameter  Apply Cohesion ?  var: apply_cohesion ;  parameter  Apply Alignment ?  var: apply_alignment ;   parameter  Apply Separation ?  var: apply_separation ;   parameter  Apply Avoidance ?  var: apply_avoid ;   parameter  Apply Wind ?  var: apply_wind ;     parameter  Moving Obstacles ?  var: moving_obstacles  ;    parameter  Direction of the wind  var: wind_vector ;  //Minimum duration of a step to better see the movements float minimum_cycle_duration <- 0.01;  output {  display Sky  background: #blue type: opengl {    image  ../images/sky.jpg  refresh: false;   species boids aspect: image trace: 10 fading: true ;   species boids_goal;   species obstacle;   //Event to call the action move_goal in global if the mouse move within the experiment   event mouse_move action: move_goal;  }  } }           model Boids_coupling  import  ../../../Toy Models/Boids/models/Boids.gaml   experiment Boids_coupling_exp type:gui  parent:boids_gui{  list<boids_goal> getBoids_goal{  return list(boids_goal); }  list<boids> getBoids{  return list(boids); }   output{ } }       Code of the model :      model comodelBoidsVoronoi import  Boids_coupling.gaml  as myBoids import  Voronoi_coupling.gaml  as myVoronoi  global {  // set the bound of the environment  geometry shape <- envelope(100);  init {   //create experiment from micro-model myBoids  create myBoids.Boids_coupling_exp with: [shape::square(0.5), width_and_height_of_environment::100, number_of_agents::100];  //create experiment form micro-model myVoronoi  create myVoronoi.Voronoi_coupling_exp with:[num_points::100, env_width::100, env_height::100]; }  reflex simulate_micro_models {  //tell myBoids to step a cycle  ask (myBoids.Boids_coupling_exp collect each.simulation){ do _step_;}  //get all boids s location into a list  list<point> theLocations<-(myBoids.Boids_coupling_exp accumulate each.getBoids()) collect each.location;  //myVoronoi do a step with the location of their agent from the location list above   ask (myVoronoi.Voronoi_coupling_exp collect each.simulation){ ask center{location<-theLocations at (int(self)); }do _step_;} }   }  experiment comodel_Boids_Voronoi_Exp type: gui {  output  {   display  comodel_disp     {    agents  cell  value: (myVoronoi.Voronoi_coupling_exp accumulate each.getCell());    agents boids_goal value: (myBoids.Boids_coupling_exp accumulate each.getBoids_goal()) {draw circle(5) color:#red;}      agents boids value: (myBoids.Boids_coupling_exp accumulate each.getBoids()) {draw circle(1) color:#blue;}     }  }   }     ","url":"wiki/Co-model-Example-comodelBoidsVoronoi.md"},{"id":"wiki/Co-model-Example-comodel_Flood_Evacuation.md","title":" Comodel of Flood and Evacuation model","content":"# Comodel of Flood and Evacuation model  Author : HUYNH Quang Nghi  Co-model example : couple the evacuation model with the flood model. Water win or human win?  Imported models :      model continuous_move  global {   //Shapefile of the buildings  file building_shapefile <- file( ../includes/building.shp );  //Shape of the environment  geometry shape <- envelope(building_shapefile);  int maximal_turn <- 90; //in degree  int cohesion_factor <- 10;  //Size of the people  float people_size <- 2.0;  //Space without buildings  geometry free_space;  //Number of people agent  int nb_people <- 500;  //Point to evacuate  point target_point <- {world.location.x, 0};  init {   free_space <- copy(shape);  //Creation of the buildinds  create building from: building_shapefile {   //Creation of the free space by removing the shape of the different buildings existing   free_space <- free_space - (shape + people_size);  }  //Simplification of the free_space to remove sharp edges  free_space <- free_space simplification(1.0);  //Creation of the people agents  create people number: nb_people {   //People agents are placed randomly among the free space   location <- any_location_in(free_space);   target_loc <-  target_point;  }      }  } //Species which represent the building  species building { //Height of the buildings float height <- 3.0 + rnd(5); aspect default {  draw shape color: #gray depth: height; } } //Species people which move to the evacuation point using the skill moving species people skills:[moving]{ //Target point to evacuate point target_loc; //Speed of the agent float speed <- 0.5 + rnd(1000) / 1000; //Velocity of the agent point velocity <- {0,0}; //Direction of the agent taking in consideration the maximal turn an agent is able to make int heading max: heading + maximal_turn min: heading - maximal_turn;  //Size of the agent float size <- people_size; rgb color <- rgb(rnd(255),rnd(255),rnd(255));   //Reflex to kill the agent when it has evacuated the area reflex end when: location distance_to target_loc <= 2 * people_size{  write name +  is arrived;  do die; } //Reflex to compute the velocity of the agent considering the cohesion factor reflex follow_goal  {  velocity <- velocity + ((target_loc - location) / cohesion_factor); } //Reflex to apply separation when people are too close from each other reflex separation {  point acc <- {0,0};  ask (people at_distance size)  {   acc <- acc - (location - myself.location);  }    velocity <- velocity + acc; } //Reflex to avoid the different obstacles reflex avoid {   point acc <- {0,0};  list<building> nearby_obstacles <- (building at_distance people_size);  loop obs over: nearby_obstacles {   acc <- acc - (obs.location - location);  }  velocity <- velocity + acc;  } //Reflex to move the agent considering its location, target and velocity reflex move {  point old_location <- copy(location);  do goto target: location + velocity ;  if (not empty(building overlapping self )) {   location <- point((location closest_points_with free_space)[1]);  }  velocity <- location - old_location; }  aspect default {  draw pyramid(size) color: color;  draw sphere(size/3) at: {location.x,location.y,size} color: color; } }   experiment main type: gui {  parameter  nb people  var: nb_people min: 1 max: 1000;  output {   display map type: opengl {    species building refresh: false;    species people;    graphics  exit  refresh: false {     draw sphere(2 * people_size) at: target_point color: #green;     }   }  } }           model Evacuation_coupling  import  ../../../Toy Models/Evacuation/models/Continuous Move.gaml  experiment Evacuation_coupling_exp type: gui parent: main {  point centroid <- { 0, 180 };  list getBuilding  {   return list(building);  }  action transform_environement {  loop t over: list(building)  {   t.shape <- t.shape translated_by centroid;   t.shape <- t.shape * 10;   t.location <- t.location * 8;  }   loop t over: list(people)  {   t.speed <- 10.0;   t.size <- 20.0;   t.shape <- t.shape translated_by centroid;   t.location <- t.location * 8;  }   target_point <- point(target_point translated_by centroid); }  list<people> getPeople {  return list(people); }  output { }   }           model hydro  global {    //Shapefile for the river    file river_shapefile <- file( ../includes/RedRiver.shp );    //Shapefile for the dykes    file dykes_shapefile <- file( ../includes/Dykes.shp );    //Shapefile for the buildings    file buildings_shapefile <- file( ../includes/Building.shp );  //Data elevation file    file dem_file <- file( ../includes/mnt50.asc );    //Diffusion rate    float diffusion_rate <- 0.6;    //Height of the dykes    float dyke_height <- 15.0;    //Width of the dyke    float dyke_width <- 15.0;  //Shape of the environment using the dem file    geometry shape <- envelope(dem_file);  //List of the drain and river cells    list drain_cells;    list river_cells;  float step <- 1°h;  init {      //Initialization of the cells       do init_cells;      //Initialization of the water cells       do init_water;      //Initialization of the river cells      river_cells <- cell where (each.is_river);      //Initialization of the drain cells       drain_cells <- cell where (each.is_drain);      //Initialization of the obstacles (buildings and dykes)       do init_obstacles;       //Set the height of each cell       ask cell {   obstacle_height <- compute_highest_obstacle();   do update_color;       }    }    //Action to initialize the altitude value of the cell according to the dem file    action init_cells {       ask cell {   altitude <- grid_value;   neighbour_cells <- (self neighbors_at 1) ;       }    }    //action to initialize the water cells according to the river shape file and the drain    action init_water {       geometry river <- geometry(river_shapefile);       ask cell overlapping river {   water_height <- 10.0;   is_river <- true;   is_drain <- grid_y = matrix(cell).rows - 1;       }    }    //initialization of the obstacles (the buildings and the dykes)    action init_obstacles{       create buildings from: buildings_shapefile  {   do update_cells;       }       create dyke from: dykes_shapefile;       ask dyke { shape <-  shape + dyke_width;   do update_cells;       }    }    //Reflex to add water among the water cells    reflex adding_input_water {       float water_input <- rnd(100)/100;       ask river_cells {   water_height <- water_height + water_input;       }    }    //Reflex to flow the water according to the altitute and the obstacle    reflex flowing {       ask cell {already <- false;}       ask (cell sort_by ((each.altitude + each.water_height + each.obstacle_height))) {   do flow;       }    }    //Reflex to update the color of the cell    reflex update_cell_color {       ask cell {   do update_color;       }    }    //Reflex for the drain cells to drain water    reflex draining {       ask drain_cells {   water_height <- 0.0;       }    }  } //Species which represent the obstacle    species obstacle {       //height of the obstacle       float height min: 0.0;       //Color of the obstacle       rgb color;       //Pressure of the water       float water_pressure update: compute_water_pressure();    //List of cells concerned   list<cell> cells_concerned ;   //List of cells in the neighbourhood    list<cell> cells_neighbours;      //Action to compute the water pressure   float compute_water_pressure {    //If the obstacle doesn t have height, then there will be no pressure      if (height = 0.0) {  return 0.0;      } else {       //The leve of the water is equals to the maximul level of water in the neighbours cells  float water_level <- cells_neighbours max_of (each.water_height);  //Return the water pressure as the minimal value between 1 and the water level divided by the height  return min([1.0,water_level / height]);      }    }      //Action to update the cells   action update_cells {    //All the cells concerned by the obstacle are the ones overlapping the obstacle      cells_concerned <- (cell overlapping self);      ask cells_concerned {      //Add the obstacles to the obstacles of the cell  add myself to: obstacles;  water_height <- 0.0;      }      //Cells neighbours are all the neighbours cells of the cells concerned      cells_neighbours <- cells_concerned + cells_concerned accumulate (each.neighbour_cells);      //The height is now computed     do compute_height();      if (height > 0.0) {   //We compute the water pressure again  water_pressure <- compute_water_pressure();      } else {water_pressure <- 0.0;}   }   action compute_height;   aspect geometry {      int val <- int( 255 * water_pressure);      color <- rgb(val,255-val,0);      draw shape color: color depth: height*5 border: color;   }    }    //Species buildings which is derivated from obstacle    species buildings parent: obstacle {      //The building has a height randomly chosed between 2 and 10   float height <- 2.0 + rnd(8);    }    //Species dyke which is derivated from obstacle    species dyke parent: obstacle{         int counter_wp <- 0;    int breaking_threshold <- 24;      //Action to represent the break of the dyke    action break{      ask cells_concerned {  do update_after_destruction(myself);      }      do die;   }   //Action to compute the height of the dyke as the dyke_height without the mean height of the cells it overlaps   action compute_height    {       height <- dyke_height - mean(cells_concerned collect (each.altitude));      }      //Reflex to break the dynamic of the water   reflex breaking_dynamic {    if (water_pressure = 1.0) {     counter_wp <- counter_wp + 1;     if (counter_wp > breaking_threshold) {      do break;     }    } else {     counter_wp <- 0;    }   }   //user command which allows the possibility to destroy the dyke for the user   user_command Destroy dyke action: break;     }    //Grid cell to discretize space, initialized using the dem file    grid cell file: dem_file neighbors: 8 frequency: 0  use_regular_agents: false use_individual_shapes: false use_neighbors_cache: false {   //Altitude of the cell   float altitude;   //Height of the water in the cell   float water_height <- 0.0 min: 0.0;   //Height of the cell   float height;   //List of the neighbour cells   list<cell> neighbour_cells ;   //Boolean to know if it is a drain cell   bool is_drain <- false;   //Boolean to know if it is a river cell   bool is_river <- false;   //List of all the obstacles overlapping the cell   list<obstacle> obstacles;   //Height of the obstacles   float obstacle_height <- 0.0;   bool already <- false;      //Action to compute the highest obstacle among the obstacles   float compute_highest_obstacle {      if (empty(obstacles))      {  return 0.0;       } else {  return obstacles max_of(each.height);      }   }   //Action to flow the water    action flow {    //if the height of the water is higher than 0 then, it can flow among the neighbour cells      if (water_height > 0) {       //We get all the cells already done  list<cell> neighbour_cells_al <- neighbour_cells where (each.already);  //If there are cells already done then we continue  if (!empty(neighbour_cells_al)) {  //We compute the height of the neighbours cells according to their altitude, water_height and obstacle_height  ask neighbour_cells_al {height <- altitude + water_height + obstacle_height;}  //The height of the cell is equals to its altitude and water height  height <-  altitude +  water_height;  //The water of the cells will flow to the neighbour cells which have a height less than the height of the actual cell  list<cell> flow_cells <- (neighbour_cells_al where (height > each.height)) ;  //If there are cells, we compute the water flowing  if (!empty(flow_cells)) {     loop flow_cell over: shuffle(flow_cells) sort_by (each.height){ float water_flowing <- max([0.0, min([(height - flow_cell.height), water_height * diffusion_rate])]);  water_height <- water_height - water_flowing; flow_cell.water_height <-flow_cell.water_height +  water_flowing; height <- altitude + water_height;     }     }  }      }      already <- true;   }     //Update the color of the cell   action update_color {       int val_water <- 0;      val_water <- max([0, min([255, int(255 * (1 - (water_height / 12.0)))])]) ; color <- rgb([val_water, val_water, 255]);      grid_value <- water_height + altitude;   }   //action to compute the destruction of the obstacle   action update_after_destruction(obstacle the_obstacle){      remove the_obstacle from: obstacles;      obstacle_height <- compute_highest_obstacle();   }   }  experiment main_gui type: gui {    parameter  Shapefile for the river  var:river_shapefile category: Water data ;    parameter  Shapefile for the dykes  var:dykes_shapefile category: Obstacles ;    parameter  Shapefile for the buildings  var:buildings_shapefile category: Obstacles ;    parameter  Height of the dykes  var:dyke_height category: Obstacles ;    parameter  Diffusion rate  var:diffusion_rate category: Water dynamic ;    output { display map type: opengl {   grid cell triangulation: true;   species buildings aspect: geometry;   species dyke aspect: geometry ;       }       display chart_display refresh: every(24) { chart  Pressure on Dykes  type: series {   data  Mean pressure on dykes   value: mean(dyke collect (each.water_pressure)) style: line color: #magenta ;   data  Rate of dykes with max pressure  value: (dyke count (each.water_pressure = 1.0))/ length(dyke) style: line color: #red ;   data  Rate of dykes with high pressure  value: (dyke count (each.water_pressure > 0.5))/ length(dyke) style: line color: #orange ;   data  Rate of dykes with low pressure  value: (dyke count (each.water_pressure < 0.25))/ length(dyke) style: line color: #green ;   }       }    } }          model Flood_coupling  import  ../../../Toy Models/Flood Simulation/models/Hydrological Model.gaml  experiment Flood_coupling_exp type: gui parent: main_gui {  point newSize <- { 0.07, 0.07 };  cell getCellAt (geometry p)  {   ask simulation   {    return cell closest_to p;   }  }  list<cell> getCell {  return list(cell) where (each.grid_value > 8.0); }  list<buildings> getBuildings {  return list(buildings); }  list<dyke> getDyke {  return list(dyke); }  output { }   }      Code of the model :      model comodel_Flood_Evacuation  import  Flood_coupling.gaml  as myFlood import  Evacuation_coupling.gaml  as myEvacuation  global {  //set the bound of environment  geometry shape <- envelope(file( ../../../Toy Models/Flood Simulation/includes/mnt50.asc ));  //counting variable of casualty  int casualty <- 0;  init  {   //create experiment from micro-model myFlood with corresponding parameters   create myFlood.Flood_coupling_exp with:   [buildings_shapefile::file( ../../../Toy Models/Flood Simulation/includes/Building.shp ), river_shapefile::file( ../../../Toy Models/Flood Simulation/includes/RedRiver.shp ), dykes_shapefile::file( ../../../Toy Models/Flood Simulation/includes/Dykes.shp ), dem_file::file( ../../../Toy Models/Flood Simulation/includes/mnt50.asc )];   //create the Evacuation micro-model s experiment   create myEvacuation.Evacuation_coupling_exp with: [nb_people::200, target_point::{ 0, 1580 }, building_shapefile::file( ../../../Toy Models/Evacuation/includes/building.shp )]   {    //transform the environment and the agents to new location (near the river)    do transform_environement;   }  }  reflex doing_cosimulation {  //do a step of Flooding  ask myFlood.Flood_coupling_exp collect each.simulation  {   do _step_;  }   //people evacate   ask myEvacuation.Evacuation_coupling_exp collect each.simulation  {   //depending on the real plan of evacuation, we can test the speed of the evacuation with the speed of flooding by doing more or less simulation step     if (cycle mod 2 = 0)   {    do _step_;   }   }   //loop over the population  loop thePeople over: first(myEvacuation.Evacuation_coupling_exp).getPeople()  {   //get the cell at people s location   cell theWater <- cell(first(myFlood.Flood_coupling_exp).getCellAt(thePeople));   //if the water levele is high than 8 meters and people is overlapped, tell him that he must dead   if (theWater.grid_value > 8.0 and theWater overlaps thePeople)   {    ask thePeople    {     do die;    }    //increase the counting variable    casualty <- casualty + 1;   }   }  }   }  experiment comodel_Flood_Evacuation_exp type: gui {  output  {   display  comodel_disp    {    agents  building  value: first(myEvacuation.Evacuation_coupling_exp).getBuilding();    agents  people  value: first(myEvacuation.Evacuation_coupling_exp).getPeople();    agents  cell  value: first(myFlood.Flood_coupling_exp).getCell();    agents  dyke  value: first(myFlood.Flood_coupling_exp).getDyke();    graphics  CasualtyView     {     draw ( Casualty:   + casualty) at: { 0, 4000 } font: font( Arial , 18, # bold) color: # red;    }   }  }   }     ","url":"wiki/Co-model-Example-comodel_Flood_Evacuation.md"},{"id":"wiki/Co-model-Example-comodel_Urban_Traffic.md","title":" comodel Urban and Traffic model","content":"# comodel Urban and Traffic model  Author : HUYNH Quang Nghi  Co-model example : coupling urban growth model with the traffic model.  Imported models :       model raster3  global {   //File for the ascii grid  file asc_grid <- grid_file( ../includes/cantho_1999_v6.asc );  //Shapefile for the road  file road_shapefile <- shape_file( ../includes/roads15_3.shp );  //Shapefile for the city  file city_center_shapefile <- shape_file( ../includes/city center.shp );  //Shape of the environment  geometry shape <- envelope(asc_grid);  //Graph of the roads  graph roads_network;  // Dynamic list of the cells to consider at each cycle list<plot> empty_plots <- plot where (each.grid_value = 0.0) update: shuffle(plot where (each.grid_value = 0.0));  list<rgb> plot_colors <- [   #lightgray, //empty  #orange, // 1 built  #blue // 2 River-lake ]; //Radius of density int density_radius <- 4; //Weight of density float weight_density <- 0.05; //Weight of the road distance float weight_road_dist <- 0.5; //Weight of the city center distance float weight_cc_dist <- 0.3; //Number of plot allowing to build a building int nb_plots_to_build <- 195;  init {  //Creation of the roads using the shapefile of the road  create roads from: road_shapefile;  //Creation of the city center using the city center shapefile  create city_center from: city_center_shapefile;  //Creation of the graph of the road network  roads_network <- as_edge_graph(roads);    //Each road has to compute its distance from the city center  ask roads {   do compute_cc_dist;  }  //Compute the city distance for each plot  ask empty_plots {   do compute_distances;  }  //Normalization of the distance  do normalize_distances; } //Action to normalize the distance action normalize_distances {  //Maximum distance from the road of all the plots  float max_road_dist <- empty_plots max_of each.dist_route;  //Maximum distance from the city center for all the plots  float max_cc_dist <- empty_plots max_of each.dist_cv;  //Normalization of  each empty plot according to the maximal value of each attribute  ask empty_plots {   dist_cv <- 1 - dist_cv / max_cc_dist;   dist_route <- 1 - dist_route / max_road_dist;  } }   //Reflex representing the global dynamic of the model reflex dynamique_globale when: weight_density != 0 or weight_road_dist != 0 or weight_cc_dist != 0 {  //Ask to each empty plot to compute its constructability  ask empty_plots {   constructability <- compute_constructability();  }  list<plot> ordered_plots <- empty_plots sort_by (each.constructability);  ordered_plots <- nb_plots_to_build last ordered_plots;  //Build on each empty plot having the highest constructability  ask ordered_plots  {   do build;  } }  } //Species representing the city center species city_center { aspect default {  draw circle(300) color: #cyan; }  } //Species representing the roads species roads { float dist_cv; //Action to compute the city center distance for the road action compute_cc_dist {  using topology(roads_network)  {   dist_cv <- self distance_to first(city_center);  } } aspect default {  draw shape color: #black;  } } //Grid species to represent the different building plots grid plot file: asc_grid use_individual_shapes: false use_regular_agents: false neighbors: 4 { rgb color <- grid_value = -1 ? #white : plot_colors[int(grid_value)]; //Distance from the road float dist_route <- 0.0; //Distance from the city center float dist_cv <- 0.0; //Constructability of the plot float constructability;  //Action to compute all the distances for the cell action compute_distances {  roads route_pp <- roads closest_to self;  dist_route <- (self distance_to route_pp) using topology(world);  dist_cv <- dist_route + route_pp.dist_cv; } //Action to build on the cell action build {  grid_value <- 1.0;  color <- plot_colors[1]; } //Action to compute the constructability of the plot cell float compute_constructability {  //Get all the neighbours plots  list<plot> voisins <- (self neighbors_at density_radius);  //Compute the density of all the neighbours plots  float densite <- (voisins count (each.grid_value = 1.0)) / length(voisins);  return (densite * weight_density + dist_route * weight_road_dist + dist_cv * weight_cc_dist) / (weight_density + weight_road_dist + weight_cc_dist); }    }   experiment raster type: gui {   parameter  Weight of the density criteria  var: weight_density;   parameter  Weight of the distance to roads criteria  var: weight_road_dist;   parameter  Weight of the distance to city center criteria  var: weight_cc_dist;   output {    display map type: opengl {    grid plot;    species roads;    species city_center;   }  } }           model Urban_coupling  import  ../../../Toy Models/Urban Growth/models/raster model.gaml  experiment Urban_coupling_exp type: gui parent: raster {  list getPlot  {   return list(plot);  }  }           model traffic  global {  //Shapefile of the buildings  file building_shapefile <- file( ../includes/buildings.shp );  //Shapefile of the roads  file road_shapefile <- file( ../includes/roads.shp );  //Shape of the environment  geometry shape <- envelope(road_shapefile);  //Step value  float step <- 10 #s;  //Graph of the road network  graph road_network;  //Map containing all the weights for the road network graph  map<road,float> road_weights;  init {  //Initialization of the building using the shapefile of buildings  create building from: building_shapefile;  //Initialization of the road using the shapefile of roads  create road from: road_shapefile;    //Creation of the people agents  create people number: 1000{   //People agents are located anywhere in one of the building   location <- any_location_in(one_of(building));    }    //Weights of the road    road_weights <- road as_map (each::each.shape.perimeter);    road_network <- as_edge_graph(road); } //Reflex to update the speed of the roads according to the weights reflex update_road_speed  {  road_weights <- road as_map (each::each.shape.perimeter / each.speed_coeff);  road_network <- road_network with_weights road_weights; } } //Species to represent the people using the skill moving species people skills: [moving]{ //Target point of the agent point target; //Probability of leaving the building float leaving_proba <- 0.05;  //Speed of the agent float speed <- 5 #km/#h; rgb color <- rnd_color(255); //Reflex to leave the building to another building reflex leave when: (target = nil) and (flip(leaving_proba)) {  target <- any_location_in(one_of(building)); } //Reflex to move to the target building moving on the road network reflex move when: target != nil {  do goto target: target on: road_network recompute_path: false move_weights: road_weights;  if (location = target) {   target <- nil;  }  }  aspect default {  draw circle(5) color: color; } } //Species to represent the buildings species building { aspect default {  draw shape color: #gray; } } //Species to represent the roads species road { //Capacity of the road considering its perimeter float capacity <- 1 + shape.perimeter/30; //Number of people on the road int nb_people <- 0 update: length(people at_distance 1); //Speed coefficient computed using the number of people on the road and the capicity of the road float speed_coeff <- 1.0 update:  exp(-nb_people/capacity) min: 0.1;  aspect default {  draw (shape + 3 * speed_coeff) color: #red; } } experiment trafic type: gui { float minimum_cycle_duration <- 0.01; output {  display carte type: opengl{   species building refresh: false;   species road ;   species people ;  } } }           model Traffic_coupling  import  ../../../Toy Models/Traffic/models/Simple traffic model.gaml  experiment Traffic_coupling_exp type: gui parent: trafic {  list getBuilding  {   return list(building);  }  list<people> getPeople {  return list(people); }  list<road> getRoad {  return list(road); }   }      Code of the model :      model comodel_Urban_Traffic  import  Traffic_coupling.gaml  as myTraffic import  Urban_coupling.gaml  as myUrban  global {  //set the bound of the world  geometry shape <- envelope(shape_file( ../../../Toy Models/Traffic/includes/roads.shp ));  init  {   //create Traffic micro-model s experiment   create myTraffic.Traffic_coupling_exp with:   [building_shapefile::file( ../../../Toy Models/Traffic/includes/buildings.shp ), road_shapefile::file( ../../../Toy Models/Traffic/includes/roads.shp )];   //create Urban micro-model;s experiment   create myUrban.Urban_coupling_exp with:   [asc_grid::grid_file( ../../../Toy Models/Urban Growth/includes/cantho_1999_v6.asc ), road_shapefile::shape_file( ../../../Toy Models/Urban Growth/includes/roads15_3.shp ), city_center_shapefile::shape_file( ../../../Toy Models/Urban Growth/includes/city center.shp )];  }  reflex simulate_micro_models {  //ask simulation of micro-model step one  ask myTraffic.Traffic_coupling_exp collect each.simulation  {   do _step_;  }   // tell the urban to grow up every 200 step  ask myUrban.Urban_coupling_exp collect each.simulation  {   if (cycle mod 200 = 0)   {    do _step_;   }   }  }   }  experiment comodel_Urban_Traffic_exp type: gui {  output  {   display  comodel_disp    {    agents  Plotgrid  value: first(myUrban.Urban_coupling_exp).getPlot() size: { 0.037, 0.052 };    agents  building  value: first(myTraffic.Traffic_coupling_exp).getBuilding();    agents  people  value: first(myTraffic.Traffic_coupling_exp).getPeople();    agents  road  value: first(myTraffic.Traffic_coupling_exp).getRoad();   }  }   }     ","url":"wiki/Co-model-Example-comodel_Urban_Traffic.md"},{"id":"wiki/Epidemiology-SIR-(ABM-vs-EBM).md","title":" comparison_ABM_EBM_SIR","content":"# comparison_ABM_EBM_SIR  _Author : Benoit Gaudou _  Comparison between an agent-based and an equation-based model of the SIR model. The ABM use a grid to place the agents, and each cell will be the location of an agent, while the EBM is only using a ODE System and no geographical representation.  Code of the model :      model comparison_ABM_EBM_SIR  global {  //Number of susceptible individuals  int number_S <- 499;   //Number of infectious individuals  int number_I <- 1;   //Number of Resistant individuals  int number_R <- 0;   //Beta parameter used for the infection of susceptible individuals  float beta <- 0.1;   //Gamma parameter used for the resistance gained by the infectious individuals  float gamma <- 0.01;  //Size of the neighbours  int neighbours_size <- 2;  //Total number of individuals  int N <- number_S + number_I + number_R;  //Number of hosts (for ABM)  int nb_hosts <- number_S + number_I + number_R update: length(Host);  //Number of infected hosts (for ABM)  int nb_infected <- number_I update:  Host count (each.is_infected);  float hKR4 <- 0.7;  geometry shape <- square(50);  init {   //Create the number of hosts susceptibles   create Host number: number_S {    is_susceptible <- true;    is_infected <- false;    is_immune <- false;    color <- #green;   }   //Create the number of hosts infectious   create Host number: number_I {    is_susceptible <- false;    is_infected <- true;    is_immune <- false;    color <- #red;   }   //Create the node agent for the SIR ODE System   create node_agent number: 1 {    S <- float(number_S);    I <- float(number_I);    R <- float(number_R);   }  }  } //Grid that will be used to discretize space grid sir_grid width: 50 height: 50 {   rgb color <- #black;   list neighbours <- (self neighbors_at neighbours_size) of_species sir_grid;  }  //Species host which represents the host of the disease species Host {  //Different booleans to know in which state is the host bool is_susceptible <- true; bool is_infected <- false; bool is_immune <- false;  //Color of the host rgb color <- #green;  //Location of the agent among the grid sir_grid myPlace; //Count of neighbors infected  int ngb_infected_number function: {self neighbors_at(neighbours_size) count(each.is_infected)};  init {  //The location is chosen randomly  myPlace <- one_of(sir_grid);  location <- myPlace.location; } //Reflex to move the agent in the neighbours cells reflex basic_move {  myPlace <- one_of(myPlace.neighbours);  location <- myPlace.location; } //Reflex to pass the agent to the state infected  reflex become_infected when: is_susceptible {   //Probability of being infected according to the number of infected among the neighbours   if (flip(1 - (1 - beta)  ^ ngb_infected_number)) {       is_susceptible <-  false;    is_infected <-  true;    is_immune <-  false;    color <-  #red;             }         } //Reflex to pass the agent to the state immune reflex become_immune when: (is_infected and flip(gamma)) {  is_susceptible <- false;  is_infected <- false;  is_immune <- true;  color <- #blue; }   aspect basic {  draw circle(1) color: color; }   } //Species node agent that will represent the SIR Ordinary differential equations system species node_agent {  float t;  float I;  float S;  float R;  equation eqSIR type: SIR vars: [S, I, R, t] params: [N, beta, gamma];  reflex solving {solve eqSIR method: rk4 step: 1;}  }  experiment Simulation_ABM_EBM type: gui {  parameter  Number of Susceptible  type: int var: number_S <- 495 category:  Initial population ;  parameter  Number of Infected  type: int var: number_I <- 5 category:  Initial population ;  parameter  Number of Removed  type: int var: number_R <- 0 category:  Initial population ;  parameter  Beta (S->I)  type: float var: beta <- 0.1 category:  Parameters ;  parameter  Gamma (I->R)  type: float var: gamma <- 0.01 category:  Parameters ;  parameter  Size of the neighbours  type: int var: neighbours_size <- 1 min: 1 max: 5 category:  Infection ;  output {   display sir_display {     grid sir_grid lines: #black;    species Host aspect: basic;    }   display ABM {     chart  Susceptible  type: series background: #lightgray style: exploded {     data  susceptible  value: (Host as list) count (each.is_susceptible) color: #green;     data  infected  value: (Host as list) count (each.is_infected) color: #red;     data  immune  value: (Host as list) count (each.is_immune) color: #blue;    }   }   display EBM {     chart  SIR  type: series background: #white {     data  S  value: first(node_agent).S color: #green;     data  I  value: first(node_agent).I color: #red;     data  R  value: first(node_agent).R color: #blue;    }   }   display ABM_EBM  {     chart  Susceptible  type: series background: #lightgray style: exploded {     data  susceptible  value: (Host as list) count (each.is_susceptible) color: #green-50;     data  infected  value: (Host as list) count (each.is_infected) color: #red-50;     data  immune  value: (Host as list) count (each.is_immune) color: #blue-50;     data  S  value: first(node_agent).S color: #green+50;     data  I  value: first(node_agent).I color: #red+50;     data  R  value: first(node_agent).R color: #blue+50;    }   }  }  }     ","url":"wiki/Epidemiology-SIR-(ABM-vs-EBM).md"},{"id":"wiki/Epidemiology-SIR-(Built-In).md","title":" simple_ODE_SIR_Predefined","content":"# simple_ODE_SIR_Predefined  _Author : hqnghi _  A simple example of ODE use into agents with the example of the SIR equation system.  Code of the model :       model simple_ODE_SIR_Predefined  global {  init {   create predefined_ODE_SIR_agent number: 1;  } }  //Species which represent the Ordinary Differential Equations System  species predefined_ODE_SIR_agent {  //Variable to represent the discrete time for integration  float t;   //Total Population      int N <- 500;     //Number of infected  float I <- 1.0;   //Number of susceptible  float S <- N - I;   //Number of recovered  float R <- 0.0;  //Rate of transmission success for each infected    float beta <- 0.4;    //Rate of passing to resistant     float gamma <- 0.01;        float h <- 0.1;  // Parameters must follow exact order S, I, R, t  and N,beta,gamma   equation eqSIR type:SIR vars: [S,I,R,t] params: [N,beta,gamma] ;  reflex solving {solve eqSIR method:rk4 step:h ;}//cycle_length:int(1/h);} }   experiment mysimulation type: gui {  output {    display display_charts {    chart  SIR_agent  type: series background: #lightgray {     data  S  value: first(predefined_ODE_SIR_agent).S color: #green;     data  I  value: first(predefined_ODE_SIR_agent).I color: #red;     data  R  value: first(predefined_ODE_SIR_agent).R color: #blue;    }   }  } }     ","url":"wiki/Epidemiology-SIR-(Built-In).md"},{"id":"wiki/Epidemiology-SIR-(Split-in-Agents).md","title":" SIR_split_in_agents","content":"# SIR_split_in_agents  _Author : hqnghi _  This model illustrates the possibility to split an equation system into several agents. All the equations are solve together thanks to the simultaneously facet of the equation statement. We also compare the split model with the simple SIR one.  Code of the model :       model SIR_split_in_agents  global {  int number_S <- 495 ; // The number of susceptible  int number_I <- 5   ; // The number of infected  int number_R <- 0   ; // The number of removed  float beta  <- 1.0  ; // The parameter Beta float delta <- 0.01 ; // The parameter Delta  // Note that N will remain constant as demography is not taken into account in the SIR model. int N <- number_S + number_I + number_R ; float hKR4 <- 0.07 ;  init {  //Creation of the representation of the susceptible agents  create S_agt {   Ssize <- float(number_S) ;   self.beta <- myself.beta ;  }  //Creation of the representation of the infected agents  create I_agt {   Isize <- float(number_I) ;   self.beta <- myself.beta ;   self.delta <- myself.delta ;  }  //Creation of the representation of the recovered agents  create R_agt {   Rsize <- float(number_R) ;   self.delta <- myself.delta ;  }  //Creation of the representation of the SIR agent representing the non split system  create SIR_agt {   self.Sm <- float(number_S) ;   self.Im <- float(number_I) ;   self.Rm <- float(number_R) ;      self.beta <- myself.beta ;   self.delta <- myself.delta ;  } } }   //Species which represent the susceptible agents compartiment species S_agt {  float t ;    float Ssize ; //number of susceptible  float beta ; //Equation that will be solved simultaneously with the two other equations systems equation evol simultaneously: [  ( I_agt ) ,  ( R_agt ) ] {  diff ( first ( S_agt ) . Ssize , t ) =    ( - beta * first ( S_agt ) . Ssize * first ( I_agt ) . Isize / N ) ; }  reflex solving {solve evol method: rk4 step: 0.01 ;} } //Species which represent the infected agents compartiment species I_agt { float t ; float Isize ; // number of infected  float beta ; float delta ;  //Equation that will be solved simultaneously with the two other equations systems equation evol simultaneously: [  ( S_agt ) ,  ( R_agt ) ] {  diff ( first ( I_agt ) . Isize , t ) =    ( beta * first ( S_agt ) . Ssize * first ( I_agt ) . Isize / N )    - ( delta * first ( I_agt ) . Isize ) ; } } //Species which represent the resistant agents compartiment species R_agt { float t ;   float Rsize ; //number of resistant  float delta ;  //Equation that will be solved simultaneously with the two other equations systems equation evol simultaneously: [ ( S_agt ) + ( I_agt ) ] {  diff ( first ( R_agt ) . Rsize , t ) =    ( delta * first ( I_agt ) . Isize ) ; } }   //Species which represent the ordinary differential equations system species SIR_agt {  float t ;  float Im ;  float Sm ;  float Rm ;  float beta ; float delta ;  equation SIR {  diff ( Sm , t ) = ( - beta * Sm * Im / N ) ;   diff ( Im , t ) = ( beta * Sm * Im / N ) - ( delta * Im ) ;   diff ( Rm , t ) = ( delta * Im ) ; }  reflex solving {solve SIR method: rk4 step: 0.01 ;} }   experiment Simulation type: gui {  parameter  Number of Susceptible  type: int var: number_S <- 495 category:  Initial population ; // The initial number of susceptibles  parameter  Number of Infected     type: int var: number_I <- 5   category:  Initial population ;  parameter  Number of Removed      type: int var: number_R <- 0   category:  Initial population ;  parameter  Beta (S->I)   type: float var: beta <- 1.0   category: Parameters; parameter  Delta (I->R)  type: float var: delta <- 0.01 category: Parameters;  output {  display split system {   chart  Susceptible  type: series background: rgb (  lightGray  ) {    data  susceptible  value: first ( S_agt ) . Ssize color: rgb (  green  ) ;    data  infected  value: first ( I_agt ) . Isize color: rgb (  red  ) ;    data  removed  value: first ( R_agt ) . Rsize color: rgb (  blue  ) ;   }  }  display unified system{   chart  Susceptible  type: series background: rgb (  lightGray  ) {    data  susceptible_maths  value: first( SIR_agt ).Sm color: rgb (  green  ) ;    data  infected_maths  value: first( SIR_agt ).Im color: rgb (  red  ) ;    data  removed_maths  value: first( SIR_agt ).Rm color: rgb (  blue  ) ;   }  } } }      ","url":"wiki/Epidemiology-SIR-(Split-in-Agents).md"},{"id":"wiki/Epidemiology-SIR-(Switch).md","title":" SIR_switch","content":"# SIR_switch  _Author : tri and hqnghi _  A model which show how to implement ODE system, IBM model, and to switch from one to another using a threshold. Another interesting point seen in this model is the the minimization of the execution time by reducing the number of agents to compute infections.  Code of the model :      model SIR_switch  global {  // Parameters  int initial_S <- 495 ; // The number of susceptible  int initial_I <- 5   ; // The number of infected  int initial_R <- 0   ; // The number of removed  float beta <- 0.1   ; // The parameter Beta  float delta <- 0.01 ; // The parameter Delta   int switch_threshold <- 120 ; // threshold for switching models bool local_infection <- true ; int neighbours_range <- 2 ; bool local_random_walk <- true ;    // Global variables int grid_size <- 50; geometry shape <- square(grid_size); int number_Hosts <- initial_S + initial_I + initial_R; // Total number of individuals SIR_model current_model; // serves as an interface, it is transparent to user if model is maths or IBM  float beta_maths; int gridSize <- 1; //size of the grid float neighbourhoodSize <- 1.0; // average size of the neighbourhood (in number of cells)  float adjust <- 0.721; // to adjust math model to ABM when using random walk bool computeInfectionFromS <- initial_S < initial_I; // if true, use the S list to compute infections. If false, use I list. // the purpose is to minimize the number of evaluation by using the smallest list.  init {  create new_scheduler;  /* determine the size of the neighbourhood and the average count of hosts neighbours */  gridSize <- length(sir_grid);  int nbCells <- 0;    loop cell over: sir_grid {   nbCells <- nbCells + length(cell.neighbours);  }   neighbourhoodSize <- nbCells / gridSize + 1; // +1 to count itself in the neighbourhood;  beta_maths <- beta * neighbourhoodSize * number_Hosts / gridSize * adjust;    write  Switch will happen at population sizes around   +switch_threshold;  write  Basic Reproduction Number (R0):   + string(beta / delta) +  \\n ;    //Creation of the switch_model agent that will manage the switch between the mathematical and the individual based models  create switch_model {   threshold_to_IBM <- switch_threshold;   threshold_to_Maths <- switch_threshold;  }  //Creation of the model according to the one to begin with  if (first(switch_model).start_with_IBM) {  //  write  Starting with IBM model ;   create IBM_model;   current_model <- first(IBM_model);  } else {  //  write  Starting with Maths model ;   create Math_model;   current_model <- first(Math_model);  }  //Initialization of the Susceptible, Infected, Resistant and Total Compartiment  current_model.S <- float(initial_S);  current_model.I <- float(initial_I);  current_model.R <- float(initial_R);  current_model.N <- number_Hosts;    //Ask to the model to initialize itself according to the value initialized  ask current_model {   do initialize;  }    //Create the SIR maths with ODE to compare  create my_SIR_maths {   self.S <- float(myself.initial_S);   self.I <- float(myself.initial_I);   self.R <- float(myself.initial_R);   self.N <- number_Hosts;   self.beta1 <- beta * neighbourhoodSize * (N / gridSize)* adjust;   self.alpha <- delta;  }  }  reflex infection_computation_method { /* computing infection from S has a complexity of S*ngb, where ngb is the size of the neighbourhood.  * computing infection from I has a complexity of I*ngb.  * this reflex determine which method has the lowest cost.  * */  computeInfectionFromS <- (Host count (each.is_susceptible)) < (Host count (each.is_infected)); }   } //Grid which represent the discretized space for the host agents  grid sir_grid width: grid_size height: grid_size {   rgb color <- #black;   list neighbours <- (self neighbors_at neighbours_range) of_species sir_grid;  }  //Species which allows the execution of only Host, IBM_model, Math_model and switch_model at each cycle species new_scheduler schedules: (Host + IBM_model + Math_model + switch_model) ;  //Species which represent the manager between IBM and Math model species switch_model schedules: [] {  int threshold_to_IBM <- 45; // threshold under which the model swith to IBM  int threshold_to_Maths <- 50; // threshold under which the model swith to Maths model   bool start_with_IBM function: { (initial_S < threshold_to_IBM or initial_I < threshold_to_IBM) };  //Switch the model used to IBM when the threshold is higher than the population reflex switch_to_IBM when: (current_model.model_type =  Maths ) {  if (current_model.S < threshold_to_IBM or current_model.I < threshold_to_IBM) {   write  Switch to IBM model at cycle   + string(cycle);   create IBM_model {    self.S <- current_model.S;    self.I <- current_model.I;    self.R <- current_model.R;    self.N <- current_model.N;    do initialize;   }    ask current_model {    do remove_model;   }    current_model <- first(IBM_model);  }  } //Switch the model used to Maths when the threshold is lower than the population reflex switch_to_Maths when: (current_model.model_type =  IBM ) {  if (current_model.S > threshold_to_Maths and current_model.I > threshold_to_Maths) {   write  Switch to Maths model at cycle   + cycle;   create Math_model {    self.S <- current_model.S;    self.I <- current_model.I;    self.R <- current_model.R;    self.N <- current_model.N;    do initialize;   }    ask current_model {    do remove_model;   }    current_model <- first(Math_model);  }  }   } //Species which represent the SIR model used by the IBM and the Math models  species SIR_model schedules: [] {  float S;  float I;  float R;  int N;  string model_type <-  none ;  action remove_model {  do die; }  action initialize ;   }  //Species IBM Model which represent the Individual based model, derivated from SIR_model species IBM_model schedules: [] parent: SIR_model {  string model_type <-  IBM ;  //Action to initialize the Model with SIR compartiments action initialize {    write  Initializing IBM model with S=  + round(S) +  , I=  + round(I) +  , R=  + round(R) +  \\n ;  //Creation of the host agents  create Host number: round(S) {   is_susceptible <- true;   is_infected <- false;   is_immune <- false;   color <- #green;  }   create Host number: round(I) {   is_susceptible <- false;   is_infected <- true;   is_immune <- false;   color <- #red;  }   create Host number: round(R) {   is_susceptible <- false;   is_infected <- false;   is_immune <- true;   color <- #yellow;  }  do count; }  reflex count {  do count; } //Action to update the different compartiments action count {  S <- float(Host count (each.is_susceptible));  I <- float(Host count (each.is_infected));  R <- float(Host count (each.is_immune)); } //Action to remove the model and kill all the agents it contains action remove_model {  ask Host {   do die;  }   do die; }   }  //Species Math Model which represent the mathematical Ordinary Differential Equations model, derivated from SIR_model species Math_model schedules: [] parent: SIR_model {  string model_type <-  Maths ;  float t;  action initialize {  write  Initializing Maths model with S=  + S +  , I=  + I +  , R=  + R +  \\n ; }  equation SIR {  diff(S, t) = (-beta_maths * S * I / N);  diff(I, t) = (beta_maths * S * I / N) - (delta * I);  diff(R, t) = (delta * I); }  reflex solving {solve SIR method: rk4 step: 0.01 ;} } //Species host used by the Individual Based Model which move from one cell to another species Host schedules: [] skills: [moving] { bool is_susceptible <- true; bool is_infected <- false; bool is_immune <- false; rgb color <- #green; sir_grid myPlace;  /* next function computes the number of neighbours of the agent */ int ngb_number function: {  length(((self) neighbors_at (2)) of_species Host) - 1 // -1 is because the agent counts itself };  init {  myPlace <- one_of(sir_grid as list);  location <- myPlace.location; }  //Reflex to move the agents among the cells reflex basic_move {  if (!local_random_walk) {  /* random walk among neighbours */   myPlace <- one_of(myPlace.neighbours);   location <- myPlace.location;  } else {  /* move agent to a random place anywhere in the grid */   myPlace <- any(sir_grid);   location <- myPlace.location;  }  } //Reflex to make the agent infected when the infection is computed from S for a better execution time reflex become_infected when: (is_susceptible and computeInfectionFromS) {  if (flip(1 - (1 - beta) ^ (((self) neighbors_at (2)) of_species Host) count (each.is_infected))) {   is_susceptible <- false;   is_infected <- true;   is_immune <- false;   color <- #red;  }  } //Reflex to make the agent infect others when the infection is not computed from S for a better execution time reflex infecte_others when: (is_infected and not (computeInfectionFromS)) {  loop hst over: ((self) neighbors_at (2)) {   if (hst.is_susceptible) {    if (flip(beta)) {     hst.is_susceptible <- false;     hst.is_infected <- true;     hst.is_immune <- false;     hst.color <- #red;    }   }  } } //Reflex to make the agent resistant reflex become_immune when: (is_infected and flip(delta)) {  is_susceptible <- false;  is_infected <- false;  is_immune <- true;  color <- #yellow; }  aspect basic {  draw circle(1) color: color; }   } //Species which represent the SIR mathematical model  species my_SIR_maths {  float t;  float I <- float(iInit);  float S <- N - I;  float R <- 0.0;  float alpha <- 0.01 min: 0.0 max: 1.0; float beta1 <- 0.1 min: 0.0 max: 1000.0; int N <- 500 min: 1 max: 3000; int iInit <- 1;  equation SIR {  diff(S, t) = (-beta1 * S * I / N);  diff(I, t) = (beta1 * S * I / N) - (alpha * I);  diff(R, t) = (alpha * I); }  reflex solving {solve SIR method:rk4 step:0.01;}   }  experiment mysimulation type: gui {  parameter  Number of Susceptible  type: int var: initial_S <- 495 category:  Initial population ;   parameter  Number of Infected     type: int var: initial_I <- 5   category:  Initial population ;  parameter  Number of Removed      type: int var: initial_R <- 0   category:  Initial population ;  parameter  Beta (S->I)   type: float var: beta <- 1.0   category: Parameters; parameter  Delta (I->R)  type: float var: delta <- 0.01 category: Parameters;   parameter  Is the infection is computed locally?  type: bool var: local_infection <- true category: Infection; parameter  Size of the neighbours  type: int var: neighbours_range <- 2 min:1 max: 5 category: Infection;  parameter  Local Random Walk  type: bool var: local_random_walk <- true category: Agents;   parameter  Switch models at  type: int var: switch_threshold <- 120 category: Model;  output {  display  sir display  {   grid sir_grid lines: #black;   species Host aspect: basic;  }   display  Switch model  {   chart  Susceptible  type: series background: #lightgray style: exploded {    data  susceptible  value: current_model.S color: #green;    data  infected  value: current_model.I color: #red;    data  immune  value: current_model.R color: #yellow;   }   }   display SI_maths  {   chart SI type: series background: #white {    data  S  value: first((my_SIR_maths)).S color: #green;    data  I  value: first((my_SIR_maths)).I color: #red;    data  R  value: first((my_SIR_maths)).R color: #yellow;   }   }  }   }     ","url":"wiki/Epidemiology-SIR-(Switch).md"},{"id":"wiki/Epidemiology-Susceptible-Infected-(SI).md","title":" SI without ODE","content":"# SI without ODE  _Author : _  A simple SI model without Ordinary Differential Equations showing agents moving randomly among a grid and becoming infected  Code of the model :       model si  global {  int number_S <- 495;  // The number of susceptible int number_I <- 5 ; // The number of infected float survivalProbability <- 1/(70*365) ; // The survival probability float beta <- 0.05 ;  // The parameter Beta float nu <- 0.001 ; // The parameter Nu int numberHosts <- number_S+number_I; //Total number of hosts bool local_infection <- true ; //Infection spread locally or not int neighbours_size <- 2 ; //Size of the neighbourhood geometry shape <- square(50); init {   //Creation of all the susceptible hosts  create Host number: number_S {      is_susceptible <- true;      is_infected <-  false;  is_immune <-  false;   color <-  #green;     }     //Creation of all the infected hosts     create Host number: number_I {  is_susceptible <-  false;   is_infected <-  true;  is_immune <-  false;   color <-  #red;      }    }    //Reflex to update the number of infected hosts    reflex compute_nb_infected {      number_I <- Host count (each.is_infected);    }   }   //Grid to discretize space grid si_grid width: 50 height: 50 use_individual_shapes: false use_regular_agents: false frequency: 0{  rgb color <- #black;  list neighbours <- (self neighbors_at neighbours_size) ; } //Species host which represent the possible hosts of a disease species Host  {  //Booleans to represent the state of the agent  bool is_susceptible <- true;  bool is_infected <- false;     bool is_immune <- false;     rgb color <- #green;     int sic_count <- 0;     si_grid myPlace;  //The agent is placed randomly among the grid init {  myPlace <- one_of (si_grid as list);  location <- myPlace.location; }  //Reflex to move the agents in its neighbourhood reflex basic_move {  myPlace <- one_of (myPlace.neighbours) ;     location <- myPlace.location; } //Reflex to infect the agent if it is susceptible and according to the other infected agents reflex become_infected when: is_susceptible {  float rate <- 0.0;  if(local_infection) {   int nb_hosts <- 0;   int nb_hosts_infected <- 0;   loop hst over: ((myPlace.neighbours + myPlace) accumulate (Host overlapping each)) {    nb_hosts <- nb_hosts + 1;    if (hst.is_infected) {     nb_hosts_infected <- nb_hosts_infected + 1;    }   }   rate <- nb_hosts_infected / nb_hosts;  } else {   rate <- number_I / numberHosts;  }  if (flip(beta * rate)) {      is_susceptible <-  false;  is_infected <-  true;  is_immune <-  false;  color <-  #red;  } } //Reflex to kill the agent according to the death rate reflex shallDie when: flip(nu) {  create species(self) {   myPlace <- myself.myPlace ;   location <- myself.location ;   }     do die; }   aspect basic {     draw circle(1) color: color;  } }   experiment Simulation type: gui {    parameter  Number of Susceptible  var: number_S ;// The number of susceptible     parameter  Number of Infected  var: number_I ; // The number of infected     parameter  Survival Probability  var: survivalProbability ; // The survival probability  parameter  Beta (S->I)  var:beta;  // The parameter Beta  parameter  Mortality  var:nu ; // The parameter Nu  parameter  Is the infection is computed locally?  var:local_infection ;  parameter  Size of the neighbours  var:neighbours_size ;    output {      display si_display {  grid si_grid lines: #black;  species Host aspect: basic;     }    display chart refresh: every(10) {   chart Susceptible type: series background: #lightgray style: exploded {    data susceptible value: Host count (each.is_susceptible) color: #green;    data infected value: Host count (each.is_infected) color: #red;   }  }    } }      ","url":"wiki/Epidemiology-Susceptible-Infected-(SI).md"},{"id":"wiki/Epidemiology-Susceptible-Infected-Recovered-(SIR).md","title":" SIR without ODE","content":"# SIR without ODE  _Author : _  A simple SIR model without Ordinary Differential Equations showing agents moving randomly among a grid and becoming infected then resistant to a disease  Code of the model :       model si  global {   //Number of susceptible host at init     int number_S <- 495;     //Number of infected host at init     int number_I <- 5 ;     //Number of resistant host at init     int number_R <- 0 ;     //Rate for the infection success   float beta <- 0.05 ;  //Mortality rate for the host  float nu <- 0.001 ;  //Rate for resistance   float delta <- 0.01;  //Number total of hosts  int numberHosts <- number_S+number_I+number_R;  //Boolean to represent if the infection is computed locally  bool local_infection <- true parameter:  Is the infection is computed locally? ;  //Range of the cells considered as neighbours for a cell  int neighbours_size <- 2 min:1 max: 5 parameter: Size of the neighbours ;  float R0 ; geometry shape <- square(50);  init {  //Creation of all the susceptible Host  create Host number: number_S {      is_susceptible <- true;      is_infected <-  false;  is_immune <-  false;   color <-  #green;     }     //Creation of all the infected Host     create Host number: number_I {  is_susceptible <-  false;  is_infected <-  true;  is_immune <-  false;   color <-  #red;     }    //Creation of all the resistant Host    create Host number: number_R {  is_susceptible <-  false;  is_infected <-  false;  is_immune <-  true;   color <-  #blue;     }  R0 <- beta/(delta+nu);  write Basic Reproduction Number: + R0;    }   //Reflex to update the number of infected    reflex compute_nb_infected {      number_I <- Host count (each.is_infected);    }      }  //Grid used to discretize space  grid sir_grid width: 50 height: 50 use_individual_shapes: false use_regular_agents: false frequency: 0{  rgb color <- #black;  list neighbours <- (self neighbors_at neighbours_size) ; }  //Species host which represent the Host of the disease species Host  {  //Booleans to represent the state of the host agent  bool is_susceptible <- true;  bool is_infected <- false;     bool is_immune <- false;     rgb color <- #green;     sir_grid myPlace;  init {  //Place the agent randomly among the grid  myPlace <- one_of (sir_grid as list);  location <- myPlace.location; }      //Reflex to make the agent move    reflex basic_move {  myPlace <- one_of (myPlace.neighbours) ;     location <- myPlace.location; } //Reflex to make the agent infected if it is susceptible reflex become_infected when: is_susceptible {  float rate  <- 0.0;  //computation of the infection according to the possibility of the disease to spread locally or not  if(local_infection) {   int nb_hosts  <- 0;   int nb_hosts_infected  <- 0;   loop hst over: ((myPlace.neighbours + myPlace) accumulate (Host overlapping each)) {    nb_hosts <- nb_hosts + 1;    if (hst.is_infected) {nb_hosts_infected <- nb_hosts_infected + 1;}   }   rate <- nb_hosts_infected / nb_hosts;  } else {   rate <- number_I / numberHosts;  }  if (flip(beta * rate)) {      is_susceptible <-  false;  is_infected <-  true;  is_immune <-  false;  color <-  #red;  } } //Reflex to make the agent recovered if it is infected and if it success the probability reflex become_immune when: (is_infected and flip(delta)) {  is_susceptible <- false;  is_infected <- false;     is_immune <- true;     color <- #blue; } //Reflex to kill the agent according to the probability of dying reflex shallDie when: flip(nu) {  //Create another agent  create species(self)  {   myPlace <- myself.myPlace ;   location <- myself.location ;   }     do die; }   aspect basic {     draw circle(1) color: color;  } }   experiment Simulation type: gui {    parameter  Number of Susceptible  var: number_S ;// The number of susceptible     parameter  Number of Infected  var: number_I ; // The number of infected     parameter  Number of Resistant  var:number_R ; // The number of removed  parameter  Beta (S->I)  var:beta;  // The parameter Beta  parameter  Mortality  var:nu ; // The parameter Nu  parameter  Delta (I->R)  var: delta; // The parameter Delta  parameter  Is the infection is computed locally?  var:local_infection ;  parameter  Size of the neighbours  var:neighbours_size ;   output {       display sir_display {   grid sir_grid lines: #black;   species Host aspect: basic;      }      display chart refresh: every(10) {   chart Susceptible type: series background: #lightgray style: exploded {    data susceptible value: Host count (each.is_susceptible) color: #green;    data infected value: Host count (each.is_infected) color: #red;    data immune value: Host count (each.is_immune) color: #blue;   }  }    } }      ","url":"wiki/Epidemiology-Susceptible-Infected-Recovered-(SIR).md"},{"id":"wiki/Evacuation-Continuous-Move.md","title":" continuous_move","content":"# continuous_move  Author : Patrick Taillandier  A 3D model which show how to represent an evacuation system with obstacles, cohesion factor and velocity. The people are placed randomly and have to escape by going to a target point  Code of the model :      model continuous_move  global {   //Shapefile of the buildings  file building_shapefile <- file( ../includes/building.shp );  //Shape of the environment  geometry shape <- envelope(building_shapefile);  int maximal_turn <- 90; //in degree  int cohesion_factor <- 10;  //Size of the people  float people_size <- 2.0;  //Space without buildings  geometry free_space;  //Number of people agent  int nb_people <- 500;  //Point to evacuate  point target_point <- {world.location.x, 0};  init {   free_space <- copy(shape);  //Creation of the buildinds  create building from: building_shapefile {   //Creation of the free space by removing the shape of the different buildings existing   free_space <- free_space - (shape + people_size);  }  //Simplification of the free_space to remove sharp edges  free_space <- free_space simplification(1.0);  //Creation of the people agents  create people number: nb_people {   //People agents are placed randomly among the free space   location <- any_location_in(free_space);   target_loc <-  target_point;  }      }  } //Species which represent the building  species building { //Height of the buildings float height <- 3.0 + rnd(5); aspect default {  draw shape color: #gray depth: height; } } //Species people which move to the evacuation point using the skill moving species people skills:[moving]{ //Target point to evacuate point target_loc; //Speed of the agent float speed <- 0.5 + rnd(1000) / 1000; //Velocity of the agent point velocity <- {0,0}; //Direction of the agent taking in consideration the maximal turn an agent is able to make int heading max: heading + maximal_turn min: heading - maximal_turn;  //Size of the agent float size <- people_size; rgb color <- rgb(rnd(255),rnd(255),rnd(255));   //Reflex to kill the agent when it has evacuated the area reflex end when: location distance_to target_loc <= 2 * people_size{  write name +  is arrived;  do die; } //Reflex to compute the velocity of the agent considering the cohesion factor reflex follow_goal  {  velocity <- velocity + ((target_loc - location) / cohesion_factor); } //Reflex to apply separation when people are too close from each other reflex separation {  point acc <- {0,0};  ask (people at_distance size)  {   acc <- acc - (location - myself.location);  }    velocity <- velocity + acc; } //Reflex to avoid the different obstacles reflex avoid {   point acc <- {0,0};  list<building> nearby_obstacles <- (building at_distance people_size);  loop obs over: nearby_obstacles {   acc <- acc - (obs.location - location);  }  velocity <- velocity + acc;  } //Reflex to move the agent considering its location, target and velocity reflex move {  point old_location <- copy(location);  do goto target: location + velocity ;  if (not empty(building overlapping self )) {   location <- point((location closest_points_with free_space)[1]);  }  velocity <- location - old_location; }  aspect default {  draw pyramid(size) color: color;  draw sphere(size/3) at: {location.x,location.y,size} color: color; } }   experiment main type: gui {  parameter  nb people  var: nb_people min: 1 max: 1000;  output {   display map type: opengl {    species building refresh: false;    species people;    graphics  exit  refresh: false {     draw sphere(2 * people_size) at: target_point color: #green;     }   }  } }      ","url":"wiki/Evacuation-Continuous-Move.md"},{"id":"wiki/Evacuation-Goto-on-Grid.md","title":" evacuationgoto","content":"# evacuationgoto  Author : Patrick Taillandier  A 3D model with walls and exit, and people agents trying to evacuate from the area to a exit location, avoiding the walls with a discretized space by a grid  Code of the model :       model evacuationgoto  global {  //Shapefile of the walls  file wall_shapefile <- shape_file( ../includes/walls.shp );  //Shapefile of the exit  file exit_shapefile <- shape_file( ../includes/exit.shp );  //DImension of the grid agent  int nb_cols <- 50;  int nb_rows <- 50;  //Shape of the world initialized as the bounding box around the walls geometry shape <- envelope(wall_shapefile);  init {  //Creation of the wall and initialization of the cell is_wall attribute  create wall from: wall_shapefile {   ask cell overlapping self {    is_wall <- true;   }  }  //Creation of the exit and initialization of the cell is_exit attribute  create exit from: exit_shapefile {   ask (cell overlapping self) where not each.is_wall{    is_exit <- true;   }  }  //Creation of the people agent  create people number: 50{   //People agent are placed randomly among cells which aren t wall   location <- one_of(cell where not each.is_wall).location;   //Target of the people agent is one of the possible exits   target <- one_of(cell where each.is_exit).location;  } } } //Grid species to discretize space grid cell width: nb_cols height: nb_rows neighbors: 8 { bool is_wall <- false; bool is_exit <- false; rgb color <- #white;  } //Species exit which represent the exit species exit { aspect default {  draw shape color: #blue; } } //Species which represent the wall species wall { aspect default {  draw shape color: #black depth: 10; } } //Species which represent the people moving from their location to an exit using the skill moving species people skills: [moving]{ //Evacuation point point target; rgb color <- rnd_color(255);  //Reflex to move the agent  reflex move {  //Make the agent move only on cell without walls  do goto target: target speed: 1 on: (cell where not each.is_wall) recompute_path: false;  //If the agent is close enough to the exit, it dies  if (self distance_to target) < 2.0 {   do die;  } } aspect default {  draw pyramid(2) color: color;  draw sphere(1) at: {location.x,location.y,2} color: color; } } experiment evacuationgoto type: gui { output {  display map type: opengl{   image ../images/floor.jpg;   species wall refresh: false;   species exit refresh: false;   species people;     } } }      ","url":"wiki/Evacuation-Goto-on-Grid.md"},{"id":"wiki/Evacuation-Move-on-Grid.md","title":" grid_move","content":"# grid_move  _Author : _  A 3D model which show how to represent an evacuation system with obstacles, cohesion factor and velocity. The people are placed randomly and have to escape by going to a target point, within a discretized space by a grid. The agents don t use the skill moving to move.  Code of the model :      model grid_move  global {  //Shapefile of the buildings  file building_shapefile <- file( ../includes/building.shp );  //Shape of the world  geometry shape <- envelope(building_shapefile);  //Maximum memory of the agent to avoid loop of the agents  int max_memory <- 5;  //Size of the people agents  float people_size <- 2.0;  //Number of people agents  int nb_people <- 500;  //Evacuation point for the people agents  point target_point <- {world.location.x, 0};  init {  //Creation of the building agents using the shapefile  create building from: building_shapefile  {   //Initialization of the cell is_obstacle attribute   ask cell overlapping self {    is_obstacle <- true;    color <- #black;   }  }   list<cell> free_cell <- cell where not (each.is_obstacle);  cell the_target_cell <- cell closest_to target_point;  //Creation of the people agent  create people number: nb_people {   //People agent are placed randomly among the cells which haven t people or obstacle   current_cell <- one_of(free_cell);   current_cell.is_free <- false;   remove current_cell from: free_cell;   location <- current_cell.location;   target_cell <- the_target_cell;   memory << current_cell;     } } } //Species which represent the buildings species building { float height <- 3.0 + rnd(5); aspect default {  draw shape color: #gray depth: height; } } //Species which represent the people agent moving from one cell to its neighbours species people { //Current cell of the agent cell current_cell; //Evacuation cell of the agent cell target_cell; //List of the cells already passed by the agents and mesmorized list<cell> memory; //Size of the agent float size <- people_size; rgb color <- rgb(rnd(255),rnd(255),rnd(255));   //Reflex to kill the agent once it is close enough to an evacuation point reflex end when: location distance_to target_cell.location <= 2 * people_size {  current_cell.is_free <- true;  do die; } //Reflex to move the agent reflex move {  //List of all the cells possible (which aren t obstacles, without people on it and on which the agent hasn t already passed  list<cell> possible_cells <- current_cell neighbors_at 1 where (not (each.is_obstacle) and each.is_free and not (each in memory));  //If there is possible cell, the agent move on the closest one to the evacuation point  if not empty(possible_cells) {   current_cell.is_free <- true;   current_cell <- shuffle(possible_cells) with_min_of (each.location distance_to target_cell.location);   location <- current_cell.location;   current_cell.is_free <- false;   //Management of the memory of the agents   memory << current_cell;    if (length(memory) > max_memory) {    remove memory[0] from: memory;   }  } }  aspect default {  draw pyramid(size) color: color;  draw sphere(size/3) at: {location.x,location.y,size} color: color; } } //Grid species to discretize space grid cell width: 150 height: 150  neighbors: 8 frequency: 0 { bool is_obstacle <- false; bool is_free <- true; rgb color <- #white; }   experiment main type: gui {  parameter  nb people  var: nb_people min: 1 max: 1000;  output {   display map type: opengl camera_pos: {world.location.x,-world.shape.height*1.5,70}     camera_look_pos:{world.location.x,0,0}    {    image  ../images/soil.jpg ;    species building refresh: false;    species people;    graphics  exit  refresh: false {     draw sphere(2 * people_size) at: target_point color: #green;     }   }  } }     ","url":"wiki/Evacuation-Move-on-Grid.md"},{"id":"wiki/Evacuation-continuous_move.md","title":" continuous_move","content":"# continuous_move  Author : Patrick Taillandier  A 3D model which show how to represent an evacuation system with obstacles, cohesion factor and velocity. The people are placed randomly and have to escape by going to a target point    Code of the model :      model continuous_move  global {   //Shapefile of the buildings  file building_shapefile <- file( ../includes/building.shp );  //Shape of the environment  geometry shape <- envelope(building_shapefile);  int maximal_turn <- 90; //in degree  int cohesion_factor <- 10;  //Size of the people  float people_size <- 2.0;  //Space without buildings  geometry free_space;  //Number of people agent  int nb_people <- 500;  //Point to evacuate  point target_point <- {world.location.x, 0};  init {   free_space <- copy(shape);  //Creation of the buildinds  create building from: building_shapefile {   //Creation of the free space by removing the shape of the different buildings existing   free_space <- free_space - (shape + people_size);  }  //Simplification of the free_space to remove sharp edges  free_space <- free_space simplification(1.0);  //Creation of the people agents  create people number: nb_people {   //People agents are placed randomly among the free space   location <- any_location_in(free_space);   target_loc <-  target_point;  }      }  } //Species which represent the building  species building { //Height of the buildings float height <- 3.0 + rnd(5); aspect default {  draw shape color: #gray depth: height; } } //Species people which move to the evacuation point using the skill moving species people skills:[moving]{ //Target point to evacuate point target_loc; //Speed of the agent float speed <- 0.5 + rnd(1000) / 1000; //Velocity of the agent point velocity <- {0,0}; //Direction of the agent taking in consideration the maximal turn an agent is able to make int heading max: heading + maximal_turn min: heading - maximal_turn;  //Size of the agent float size <- people_size; rgb color <- rgb(rnd(255),rnd(255),rnd(255));   //Reflex to kill the agent when it has evacuated the area reflex end when: location distance_to target_loc <= 2 * people_size{  write name +  is arrived;  do die; } //Reflex to compute the velocity of the agent considering the cohesion factor reflex follow_goal  {  velocity <- velocity + ((target_loc - location) / cohesion_factor); } //Reflex to apply separation when people are too close from each other reflex separation {  point acc <- {0,0};  ask (people at_distance size)  {   acc <- acc - (location - myself.location);  }    velocity <- velocity + acc; } //Reflex to avoid the different obstacles reflex avoid {   point acc <- {0,0};  list<building> nearby_obstacles <- (building at_distance people_size);  loop obs over: nearby_obstacles {   acc <- acc - (obs.location - location);  }  velocity <- velocity + acc;  } //Reflex to move the agent considering its location, target and velocity reflex move {  point old_location <- copy(location);  do goto target: location + velocity ;  if (not empty(building overlapping self )) {   location <- point((location closest_points_with free_space)[1]);  }  velocity <- location - old_location; }  aspect default {  draw pyramid(size) color: color;  draw sphere(size/3) at: {location.x,location.y,size} color: color; } }   experiment main type: gui {  parameter  nb people  var: nb_people min: 1 max: 1000;  output {   display map type: opengl camera_pos: {world.location.x,-world.shape.height*1.5,70}     camera_look_pos:{world.location.x,0,0}    {    image  ../images/soil.jpg ;    species building refresh: false;    species people;    graphics  exit  refresh: false {     draw sphere(2 * people_size) at: target_point color: #green;     }   }  } }      ","url":"wiki/Evacuation-continuous_move.md"},{"id":"wiki/Evacuation-grid_goto.md","title":" evacuationgoto","content":"# evacuationgoto  Author : Patrick Taillandier  A 3D model with walls and exit, and people agents trying to evacuate from the area to a exit location, avoiding the walls with a discretized space by a grid    Code of the model :       model evacuationgoto  global {  //Shapefile of the walls  file wall_shapefile <- shape_file( ../includes/walls.shp );  //Shapefile of the exit  file exit_shapefile <- shape_file( ../includes/exit.shp );  //DImension of the grid agent  int nb_cols <- 50;  int nb_rows <- 50;  //Shape of the world initialized as the bounding box around the walls geometry shape <- envelope(wall_shapefile);  init {  //Creation of the wall and initialization of the cell is_wall attribute  create wall from: wall_shapefile {   ask cell overlapping self {    is_wall <- true;   }  }  //Creation of the exit and initialization of the cell is_exit attribute  create exit from: exit_shapefile {   ask (cell overlapping self) where not each.is_wall{    is_exit <- true;   }  }  //Creation of the people agent  create people number: 50{   //People agent are placed randomly among cells which aren t wall   location <- one_of(cell where not each.is_wall).location;   //Target of the people agent is one of the possible exits   target <- one_of(cell where each.is_exit).location;  } } } //Grid species to discretize space grid cell width: nb_cols height: nb_rows neighbors: 8 { bool is_wall <- false; bool is_exit <- false; rgb color <- #white;  } //Species exit which represent the exit species exit { aspect default {  draw shape color: #blue; } } //Species which represent the wall species wall { aspect default {  draw shape color: #black depth: 10; } } //Species which represent the people moving from their location to an exit using the skill moving species people skills: [moving]{ //Evacuation point point target; rgb color <- rnd_color(255);  //Reflex to move the agent  reflex move {  //Make the agent move only on cell without walls  do goto target: target speed: 1 on: (cell where not each.is_wall) recompute_path: false;  //If the agent is close enough to the exit, it dies  if (self distance_to target) < 2.0 {   do die;  } } aspect default {  draw pyramid(2) color: color;  draw sphere(1) at: {location.x,location.y,2} color: color; } } experiment evacuationgoto type: gui { output {  display map type: opengl{   image ../images/floor.jpg;   species wall refresh: false;   species exit refresh: false;   species people;     } } }      ","url":"wiki/Evacuation-grid_goto.md"},{"id":"wiki/Evacuation-grid_move.md","title":" grid_move","content":"# grid_move  _Author : _  A 3D model which show how to represent an evacuation system with obstacles, cohesion factor and velocity. The people are placed randomly and have to escape by going to a target point, within a discretized space by a grid. The agents don t use the skill moving to move.    Code of the model :      model grid_move  global {  //Shapefile of the buildings  file building_shapefile <- file( ../includes/building.shp );  //Shape of the world  geometry shape <- envelope(building_shapefile);  //Maximum memory of the agent to avoid loop of the agents  int max_memory <- 5;  //Size of the people agents  float people_size <- 2.0;  //Number of people agents  int nb_people <- 500;  //Evacuation point for the people agents  point target_point <- {world.location.x, 0};  init {  //Creation of the building agents using the shapefile  create building from: building_shapefile  {   //Initialization of the cell is_obstacle attribute   ask cell overlapping self {    is_obstacle <- true;    color <- #black;   }  }   list<cell> free_cell <- cell where not (each.is_obstacle);  cell the_target_cell <- cell closest_to target_point;  //Creation of the people agent  create people number: nb_people {   //People agent are placed randomly among the cells which haven t people or obstacle   current_cell <- one_of(free_cell);   current_cell.is_free <- false;   remove current_cell from: free_cell;   location <- current_cell.location;   target_cell <- the_target_cell;   memory << current_cell;     } } } //Species which represent the buildings species building { float height <- 3.0 + rnd(5); aspect default {  draw shape color: #gray depth: height; } } //Species which represent the people agent moving from one cell to its neighbours species people { //Current cell of the agent cell current_cell; //Evacuation cell of the agent cell target_cell; //List of the cells already passed by the agents and mesmorized list<cell> memory; //Size of the agent float size <- people_size; rgb color <- rgb(rnd(255),rnd(255),rnd(255));   //Reflex to kill the agent once it is close enough to an evacuation point reflex end when: location distance_to target_cell.location <= 2 * people_size {  current_cell.is_free <- true;  do die; } //Reflex to move the agent reflex move {  //List of all the cells possible (which aren t obstacles, without people on it and on which the agent hasn t already passed  list<cell> possible_cells <- current_cell neighbors_at 1 where (not (each.is_obstacle) and each.is_free and not (each in memory));  //If there is possible cell, the agent move on the closest one to the evacuation point  if not empty(possible_cells) {   current_cell.is_free <- true;   current_cell <- shuffle(possible_cells) with_min_of (each.location distance_to target_cell.location);   location <- current_cell.location;   current_cell.is_free <- false;   //Management of the memory of the agents   memory << current_cell;    if (length(memory) > max_memory) {    remove memory[0] from: memory;   }  } }  aspect default {  draw pyramid(size) color: color;  draw sphere(size/3) at: {location.x,location.y,size} color: color; } } //Grid species to discretize space grid cell width: 150 height: 150  neighbors: 8 frequency: 0 { bool is_obstacle <- false; bool is_free <- true; rgb color <- #white; }   experiment main type: gui {  parameter  nb people  var: nb_people min: 1 max: 1000;  output {   display map type: opengl camera_pos: {world.location.x,-world.shape.height*1.5,70}     camera_look_pos:{world.location.x,0,0}    {    image  ../images/soil.jpg ;    species building refresh: false;    species people;    graphics  exit  refresh: false {     draw sphere(2 * people_size) at: target_point color: #green;     }   }  } }     ","url":"wiki/Evacuation-grid_move.md"},{"id":"wiki/Flood-Simulation-Hydrological-Model.md","title":" Hydrological Model","content":"# Hydrological Model  Author : Patrick Taillandier  A model showing how to represent a flooding system with dykes and buildings. It uses a grid to discretize space, and has a 3D display. The water can flow from one cell to another considering the height of the cells, and the water pressure. It is also possible to delete dyke by clicking on one of them in the display.  Code of the model :       model hydro  global {    //Shapefile for the river    file river_shapefile <- file( ../includes/RedRiver.shp );    //Shapefile for the dykes    file dykes_shapefile <- file( ../includes/Dykes.shp );    //Shapefile for the buildings    file buildings_shapefile <- file( ../includes/Building.shp );  //Data elevation file    file dem_file <- file( ../includes/mnt50.asc );    //Diffusion rate    float diffusion_rate <- 0.6;    //Height of the dykes    float dyke_height <- 15.0;    //Width of the dyke    float dyke_width <- 15.0;  //Shape of the environment using the dem file    geometry shape <- envelope(dem_file);  //List of the drain and river cells    list drain_cells;    list river_cells;  float step <- 1°h;  init {      //Initialization of the cells       do init_cells;      //Initialization of the water cells       do init_water;      //Initialization of the river cells      river_cells <- cell where (each.is_river);      //Initialization of the drain cells       drain_cells <- cell where (each.is_drain);      //Initialization of the obstacles (buildings and dykes)       do init_obstacles;       //Set the height of each cell       ask cell {   obstacle_height <- compute_highest_obstacle();   do update_color;       }    }    //Action to initialize the altitude value of the cell according to the dem file    action init_cells {       ask cell {   altitude <- grid_value;   neighbour_cells <- (self neighbors_at 1) ;       }    }    //action to initialize the water cells according to the river shape file and the drain    action init_water {       geometry river <- geometry(river_shapefile);       ask cell overlapping river {   water_height <- 10.0;   is_river <- true;   is_drain <- grid_y = matrix(cell).rows - 1;       }    }    //initialization of the obstacles (the buildings and the dykes)    action init_obstacles{       create buildings from: buildings_shapefile  {   do update_cells;       }       create dyke from: dykes_shapefile;       ask dyke { shape <-  shape + dyke_width;   do update_cells;       }    }    //Reflex to add water among the water cells    reflex adding_input_water {       float water_input <- rnd(100)/100;       ask river_cells {   water_height <- water_height + water_input;       }    }    //Reflex to flow the water according to the altitute and the obstacle    reflex flowing {       ask cell {already <- false;}       ask (cell sort_by ((each.altitude + each.water_height + each.obstacle_height))) {   do flow;       }    }    //Reflex to update the color of the cell    reflex update_cell_color {       ask cell {   do update_color;       }    }    //Reflex for the drain cells to drain water    reflex draining {       ask drain_cells {   water_height <- 0.0;       }    }  } //Species which represent the obstacle    species obstacle {       //height of the obstacle       float height min: 0.0;       //Color of the obstacle       rgb color;       //Pressure of the water       float water_pressure update: compute_water_pressure();    //List of cells concerned   list<cell> cells_concerned ;   //List of cells in the neighbourhood    list<cell> cells_neighbours;      //Action to compute the water pressure   float compute_water_pressure {    //If the obstacle doesn t have height, then there will be no pressure      if (height = 0.0) {  return 0.0;      } else {       //The leve of the water is equals to the maximul level of water in the neighbours cells  float water_level <- cells_neighbours max_of (each.water_height);  //Return the water pressure as the minimal value between 1 and the water level divided by the height  return min([1.0,water_level / height]);      }    }      //Action to update the cells   action update_cells {    //All the cells concerned by the obstacle are the ones overlapping the obstacle      cells_concerned <- (cell overlapping self);      ask cells_concerned {      //Add the obstacles to the obstacles of the cell  add myself to: obstacles;  water_height <- 0.0;      }      //Cells neighbours are all the neighbours cells of the cells concerned      cells_neighbours <- cells_concerned + cells_concerned accumulate (each.neighbour_cells);      //The height is now computed     do compute_height();      if (height > 0.0) {   //We compute the water pressure again  water_pressure <- compute_water_pressure();      } else {water_pressure <- 0.0;}   }   action compute_height;   aspect geometry {      int val <- int( 255 * water_pressure);      color <- rgb(val,255-val,0);      draw shape color: color depth: height*5 border: color;   }    }    //Species buildings which is derivated from obstacle    species buildings parent: obstacle {      //The building has a height randomly chosed between 2 and 10   float height <- 2.0 + rnd(8);    }    //Species dyke which is derivated from obstacle    species dyke parent: obstacle{         int counter_wp <- 0;    int breaking_threshold <- 24;      //Action to represent the break of the dyke    action break{      ask cells_concerned {  do update_after_destruction(myself);      }      do die;   }   //Action to compute the height of the dyke as the dyke_height without the mean height of the cells it overlaps   action compute_height    {       height <- dyke_height - mean(cells_concerned collect (each.altitude));      }      //Reflex to break the dynamic of the water   reflex breaking_dynamic {    if (water_pressure = 1.0) {     counter_wp <- counter_wp + 1;     if (counter_wp > breaking_threshold) {      do break;     }    } else {     counter_wp <- 0;    }   }   //user command which allows the possibility to destroy the dyke for the user   user_command Destroy dyke action: break;     }    //Grid cell to discretize space, initialized using the dem file    grid cell file: dem_file neighbors: 8 frequency: 0  use_regular_agents: false use_individual_shapes: false use_neighbors_cache: false {   //Altitude of the cell   float altitude;   //Height of the water in the cell   float water_height <- 0.0 min: 0.0;   //Height of the cell   float height;   //List of the neighbour cells   list<cell> neighbour_cells ;   //Boolean to know if it is a drain cell   bool is_drain <- false;   //Boolean to know if it is a river cell   bool is_river <- false;   //List of all the obstacles overlapping the cell   list<obstacle> obstacles;   //Height of the obstacles   float obstacle_height <- 0.0;   bool already <- false;      //Action to compute the highest obstacle among the obstacles   float compute_highest_obstacle {      if (empty(obstacles))      {  return 0.0;       } else {  return obstacles max_of(each.height);      }   }   //Action to flow the water    action flow {    //if the height of the water is higher than 0 then, it can flow among the neighbour cells      if (water_height > 0) {       //We get all the cells already done  list<cell> neighbour_cells_al <- neighbour_cells where (each.already);  //If there are cells already done then we continue  if (!empty(neighbour_cells_al)) {  //We compute the height of the neighbours cells according to their altitude, water_height and obstacle_height  ask neighbour_cells_al {height <- altitude + water_height + obstacle_height;}  //The height of the cell is equals to its altitude and water height  height <-  altitude +  water_height;  //The water of the cells will flow to the neighbour cells which have a height less than the height of the actual cell  list<cell> flow_cells <- (neighbour_cells_al where (height > each.height)) ;  //If there are cells, we compute the water flowing  if (!empty(flow_cells)) {     loop flow_cell over: shuffle(flow_cells) sort_by (each.height){ float water_flowing <- max([0.0, min([(height - flow_cell.height), water_height * diffusion_rate])]);  water_height <- water_height - water_flowing; flow_cell.water_height <-flow_cell.water_height +  water_flowing; height <- altitude + water_height;     }     }  }      }      already <- true;   }     //Update the color of the cell   action update_color {       int val_water <- 0;      val_water <- max([0, min([255, int(255 * (1 - (water_height / 12.0)))])]) ; color <- rgb([val_water, val_water, 255]);      grid_value <- water_height + altitude;   }   //action to compute the destruction of the obstacle   action update_after_destruction(obstacle the_obstacle){      remove the_obstacle from: obstacles;      obstacle_height <- compute_highest_obstacle();   }   }  experiment main_gui type: gui {    parameter  Shapefile for the river  var:river_shapefile category: Water data ;    parameter  Shapefile for the dykes  var:dykes_shapefile category: Obstacles ;    parameter  Shapefile for the buildings  var:buildings_shapefile category: Obstacles ;    parameter  Height of the dykes  var:dyke_height category: Obstacles ;    parameter  Diffusion rate  var:diffusion_rate category: Water dynamic ;    output { display map type: opengl {   grid cell triangulation: true;   species buildings aspect: geometry;   species dyke aspect: geometry ;       }       display chart_display refresh: every(24) { chart  Pressure on Dykes  type: series {   data  Mean pressure on dykes   value: mean(dyke collect (each.water_pressure)) style: line color: #magenta ;   data  Rate of dykes with max pressure  value: (dyke count (each.water_pressure = 1.0))/ length(dyke) style: line color: #red ;   data  Rate of dykes with high pressure  value: (dyke count (each.water_pressure > 0.5))/ length(dyke) style: line color: #orange ;   data  Rate of dykes with low pressure  value: (dyke count (each.water_pressure < 0.25))/ length(dyke) style: line color: #green ;   }       }    } }     ","url":"wiki/Flood-Simulation-Hydrological-Model.md"},{"id":"wiki/Learning-MAS_KMEANS.md","title":" Agent Based Clustering","content":"# Agent Based Clustering  Author : Jean-Danie Zucker with Patrick Taillandier s and Arnaud Grignard s Help  Code of the model :      model MASKMEANS  global { // the number of classes to create (kmeans) // It corresponds to the centroids  int k <- 4;  // the number of points  int N <- 100;  //number of dimensions  int dimensions;  init  {  //create datapoints agents   create datapoints number: N   {    if (dimensions = 3)    {     location <- { rnd(100), rnd(100), rnd(100) };    }    if (dimensions = 2)   {    location <- { rnd(100), rnd(100) };   }   }   //create centroid agents  create centroids number: k  {   if (dimensions = 3)   {    location <- { rnd(100), rnd(100), rnd(100) };   }    if (dimensions = 2)   {    location <- { rnd(100), rnd(100) };   }   }   //give a random color to each centroid (i.e. to each datapoints agents of the group)  loop c over: centroids  {   rgb col <- rnd_color(255);   ask c   {    color_kmeans <- col;   }   }  }  reflex assign_points_to_centroid when: even(cycle) { // The assignment step is also referred to as expectation step,  ask centroids  {   mypoints <- list<datapoints> ([]);  }   loop pt over: datapoints  {   ask pt   {    mycenter <- (centroids) closest_to self;    color_kmeans <- mycenter.color_kmeans;    add self to: mycenter.mypoints;   }   }  }  reflex update_centroids when: not even(cycle) { // the update step as maximization step, // making this algorithm a variant of the generalized expectation-maximization algorithm.  //We give a random color to each group (i.e. to each datapoints agents of the group)  loop center over: centroids  {  //old code... center.location <- geometry(center.mypoints).location;   center.location <- mean(center.mypoints collect each.location);  }  }   }  species datapoints {  rgb color_kmeans <- # grey;  centroids mycenter;  aspect kmeans_aspect2D  {   draw circle(2) color: color_kmeans;  }  aspect kmeans_aspect3D {  draw sphere(2) color: color_kmeans; }   }  species centroids {  rgb color_kmeans <- # grey;  list mypoints;  aspect kmeans_aspect2D  {   draw cross(3, 0.5) color: color_kmeans border: # black;   loop pt over: mypoints   {    draw line([location, pt]) + 0.1 color: color_kmeans;   }  }  aspect kmeans_aspect3D {  draw cube(5) color: color_kmeans border: # black;  loop pt over: mypoints  {   draw line([location, pt], 0.2) color: color_kmeans;  } }   }  experiment clustering2D type: gui {  parameter  Number of clusters to split the data into  var: k category:  KMEANS ;  parameter  Number of points to be clustered  var: N init: 100;  parameter  Number of dimensions  var: dimensions init: 2 min: 2 max: 2;  font regular <- font( Helvetica , 14, # bold);  point target <- { 20, 95 }; output {  display map_kmeans  {   species datapoints aspect: kmeans_aspect2D;   species centroids aspect: kmeans_aspect2D;   graphics Full target   {    draw rectangle(100, 4) color: # yellow at: target + { 30, 0 };    if (not even(cycle))    {    // the update step as maximization step, (a mean is done to recenter)     draw Next step is maximisation step the centroid will move to the means of its points at: target + { 0, 0 } font: regular color: # red;    } else    {     draw Next step is estimation Step (each point is assigned the color of his nearest centroid at: target + { 0, 0 } font: regular color: # green;    }    }   }  } }   experiment clustering3D type: gui {  parameter  Number of clusters to split the data into  var: k category:  KMEANS ;  parameter  Number of points to be clustered  var: N init: 100;  font regular <- font( Helvetica , 14, # bold);  point target <- { 20, 95 };  parameter  Number of dimensions  var: dimensions init: 3 min: 3 max: 3;  action init {   create MASKMEANS_model with: [dimensions::3];  }  output  {   display map_kmeans type: opengl   {    species datapoints aspect: kmeans_aspect3D;    species centroids aspect: kmeans_aspect3D;   }  }   }      ","url":"wiki/Learning-MAS_KMEANS.md"},{"id":"wiki/Life-Life.md","title":" Life","content":"# Life  _Author : _  A model using a cellular automata to represent the Game of Life, the most famous example of cellular automata. Each cell will see if the number of living neighbours meets the condition to emerge or to live.  Code of the model :      model life  //Declare the world as a torus or not torus environment global torus: torus_environment {  //Size of the environment  int environment_width <- 200 min: 10 max: 1000;  int environment_height <- 200 min: 10 max: 1000;  //Declare as torus or not bool torus_environment <- true; //Density  int density <- 25 min: 1 max: 99; //Conditions to live list<int> living_conditions <- [2, 3]; //Conditions to birth list<int> birth_conditions <- [3]; //Color for living cells rgb livingcolor <- °white; //Color for dying cells rgb dyingcolor <- °red; //Color for emerging cells rgb emergingcolor <- °orange; //Color for dead cells rgb deadcolor <- °black; //Shape of the environment geometry shape <- rectangle(environment_width, environment_height);  //Initialization of the model by writing the description of the model in the console init {  do description; }  //Ask at each life_cell to evolve and update reflex generation {  ask life_cell {   do evolve;  }   ask life_cell {   do update;  }  } //Write the description of the model in the console action description {  write   Description. The Game of Life is a cellular automaton devised by the British mathematician John Horton Conway in 1970. It is the best-known example of a cellular automaton. The game is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input from humans. One interacts with the Game of Life by creating an initial configuration and observing how it evolves.  The universe of the Game of Life is an infinite two-dimensional orthogonal grid of square cells, each of which is in one of two possible states, live or dead. Every cell interacts with its eight neighbors, which are the cells that are directly horizontally, vertically, or diagonally adjacent. At each step in time, the following transitions occur: \\\\n\\  1.Any live cell with fewer than two live neighbours dies, as if caused by underpopulation. \\\\n\\  2.Any live cell with more than three live neighbours dies, as if by overcrowding. \\\\n\\  3.Any live cell with two or three live neighbours lives on to the next generation. \\\\n\\  4.Any dead cell with exactly three live neighbours becomes a live cell. The initial pattern constitutes the seed of the system. The first(generation) is created by applying the above rules simultaneously to every cell in the seed�births and deaths happen simultaneously, and the discrete moment at which this happens is sometimes called a tick (in other words, each generation is a pure function of the one before). The rules continue to be applied repeatedly to create further generations. ; }   }  //Grid species representing a cellular automata grid life_cell width: environment_width height: environment_height neighbors: 8  use_individual_shapes: false use_regular_agents: false frequency: 0 use_neighbors_cache: false {  //Boolean to know if it is the new state of the cell  bool new_state;  //List of all the neighbours  list neighbours <- self neighbors_at 1;  //Boolean  to know if it is a living or dead cell  bool alive <- (rnd(100)) < density;  rgb color <- alive ? livingcolor : deadcolor;  //Action to evolve the cell considering its neighbours action evolve {  //Count the number of living neighbours of the cells  int living <- neighbours count each.alive;  if alive {   //If the number of living respect the conditions, the cell is still alive   new_state <- living in living_conditions;   color <- new_state ? livingcolor : dyingcolor;  } else {   //If the number of living meets the conditions, the cell go to born   new_state <- living in birth_conditions;   color <- new_state ? emergingcolor : deadcolor;  }  } //Action to update the new state of the cell action update {  alive <- new_state; }   }  experiment  Game of Life  type: gui {  parameter  Width:  var: environment_width category:  Board ;  parameter  Height:  var: environment_height category:  Board ;  parameter  Torus?:  var: torus_environment category:  Board ;  parameter  Initial density of live cells:  var: density category:  Cells ;  parameter  Numbers of live neighbours required to stay alive:  var: living_conditions category:  Cells ;  parameter  Numbers of live neighbours required to become alive:  var: birth_conditions category:  Cells ;  parameter  Color of live cells:  var: livingcolor category:  Colors ;  parameter  Color of dying cells:  var: dyingcolor category:  Colors ;  parameter  Color of emerging cells:  var: emergingcolor category:  Colors ;  parameter  Color of dead cells:  var: deadcolor category:  Colors ;  output {   display Life type: opengl{    grid life_cell;   }  }   }     ","url":"wiki/Life-Life.md"},{"id":"wiki/Multi-level-data-analysis-Graph-From-Bug-(Distance-Graph).md","title":" SpatialGraph","content":"# SpatialGraph  Author : Arnaud Grignard  From the reference model  bug.gaml  a spatial graph is created. We create a species node that mirrors the species bug and then a spatial graph is creating using as_distance_graph operator.  Code of the model :       model SpatialGraph //Import the model Common Bug Species model import  ../includes/Common Bug Species.gaml   global {   //Graph that will be computed at each step linking the bug agents according to their distance  graph myGraph;  //Minimal distance to consider two nodes agents (ie the bug) as connected  float distance parameter:  Distance  min: 1.0 <- 10.0 category:  Model ;  //Reflex to update the graph when cycle is greater than 0. Important because the mirroring has one step late from //the original species, and at step 0, the mirroring species aren t created reflex updateGraph when:(cycle>0){  //Kill all the edge agent to create a new graph  ask edge_agent {   do die;  }  //Create a new graph using the distance to compute the edges  myGraph <- as_distance_graph(node_agent, [distance::distance, species::edge_agent]); } } //Species node_agent mirroring the bug species species node_agent mirrors: list(bug) { //Each location will be the one of the bug at the previous step point location <- target.location update: target.location; aspect base {  draw sphere(1.1) color: #green;  } } //Species to represent the edge of the graph species edge_agent { aspect base {  draw shape color: #green; } }   experiment spatialGraph type: gui {  output {    display graph_view type: opengl {        species bug aspect:base;    species node_agent aspect: base position:{0,0,0.1};    species edge_agent aspect: base position:{0,0,0.1};   }  } }     ","url":"wiki/Multi-level-data-analysis-Graph-From-Bug-(Distance-Graph).md"},{"id":"wiki/Multi-level-data-analysis-Graph-From-Bug-(Mirror-Graph).md","title":" SpatialGraph3d","content":"# SpatialGraph3d  Author : Arnaud Grignard  From the reference model  bug.gaml  a spatial graph is created. We create a species node that mirrors the species bug and then a spatial graph is creating using as_distance_graph operator. The species node should then define its own related_to method to decide wether or not a node is related to another one.  Code of the model :       model Graph  //Import the model Common Bug Species model import  ../includes/Common Bug Species.gaml   global {  //Distance to link two bugs  int distance parameter:  Distance  min: 1 <- 25 category:  Model ;  //variable to start the animation of the model  int startAnimation parameter:  Start Animation   min: 1 <- 25 category:  Animation View ;  //Variable to save the time animation  int timeAnim <- 0;  //Reflex to update the time of animation  reflex updateAnimation   {   if (time > startAnimation)    {    timeAnim <- int(time - startAnimation);   }  } } //Species node_agent mirroring the bug species, represented as graph node species node_agent mirrors: list(bug) parent: graph_node edge_species: edge_agent {  //Their location is the one of the target location  point location <- target.location update: target.location;  //Action to know if an agent is related to another agent considering their distance bool related_to (node_agent other) {  using topology(target) {   return (target.location distance_to other.target.location) < distance;  }  }  aspect base {  draw sphere(2) color: #green; }  aspect dynamic {  int degree <- (my_graph) degree_of (self);  draw sphere(1 + (degree / 5.0)) color: #blue; }   } //Species edge to represent the edges of the graph species edge_agent parent: base_edge {  rgb color;  aspect base {   draw shape color: #green;  }  aspect dynamic {  shape <- line([{ self.source.location.x, self.source.location.y, self.source.location.z }, { self.target.location.x, self.target.location.y, self.target.location.z }]);  float val <- 255.0 * (shape.perimeter / distance);  color <- hsb(val, 1.0, 1.0);  draw shape + 0.1 color: color border: color; }   }  experiment AdvancedView type: gui {  output {   display graph_plus_bug_layered type: opengl {      species bug aspect: base;     species node_agent aspect: base position: { 0, 0, 0.2 };     species edge_agent aspect: base position: { 0, 0, 0.2 };     species node_agent aspect: dynamic position: { 0, 0, 0.4 };     species edge_agent aspect: dynamic position: { 0, 0, 0.4 };   }  } }      ","url":"wiki/Multi-level-data-analysis-Graph-From-Bug-(Mirror-Graph).md"},{"id":"wiki/Multi-level-data-analysis-MODAVI.md","title":" Modavi","content":"# Modavi  Author : Arnaud Grignard  From a reference model with node of a given class, a spatial graph is created (or a barabasi graph if spatialGraph is set to false) in the advanced view to represent the interaction in the reference model.An abstract view/controller is created to summarize the interaction in the advanced viewin a macro graph and control the reference model by defining an action (user_command) for each macroNode and macroEdge.  Code of the model :       model modavi  global {  //Graph of the agents  graph<node_agent,edge_agent> my_graph ;  //Number of agents to create int nbAgent parameter:  Number of Agents  min: 1 <- 500 category:  Model ; //Number of value per class int nbValuePerClass parameter:  Number of value per class  min: 1 max:100 <- 15 category:  Model ; //Boolean to know if we display a spatial graph or not bool spatialGraph parameter:  Spatial Graph  <- true category:  Model ; //Distance to link two node agents float distance parameter:  Distance  min: 1.0<- 10.0 category:  Model ; //Threshold int threshold parameter:  Threshold  min: 0 <- 0 category:  Model ;  //Size of a node agent int nodeSize parameter:  Node size  min: 1 <- 1 category:  Aspect ; //Size of a macro node agent int macroNodeSize parameter:  Macro Node size  min: 1 <- 2 category:  Aspect ;  //Number of type of class int nbTypeOfClass <-1;  //Zoom factor int zoomFactor <- nbTypeOfClass;  //List of the different interaction matrices list<matrix<int>> interactionMatrix <-list_with(nbTypeOfClass,matrix([0])); //Number maximum of edges int nbEdgeMax;  //Reflex to update the interaction matrix list reflex updateInteractionMatrix{  //Ask for each edge agent to update it sources and destination to create the matrix  ask edge_agent{   loop i from:0 to: nbTypeOfClass-1{                   src <- my_graph source_of(self);    dest <- my_graph target_of(self);    int tmp <- (interactionMatrix[i]  at {(src.classVector[i]-1),(dest.classVector[i]-1)});    interactionMatrix[i][src.classVector[i]-1,dest.classVector[i]-1] <- (tmp+1);   }  } }  //Reflex to compute te maximum number of edges reflex computeNbEdgeMax{  //Number maximum of edges  nbEdgeMax <-1;  //Ask for each macro edge its aggregated link list number  ask macroEdge{   if(nbAggregatedLinkList[0] > nbEdgeMax){    nbEdgeMax <-nbAggregatedLinkList[0];   }   } }  //Initialization of the model init {  //Initialization of the matrix  do InitInteractionMatrix;  //If we want a spatial graph in that case we create a graph according to their distance, else we create a barabasi albert graph  if(spatialGraph){   create node_agent number:nbAgent;   my_graph <- graph<node_agent, edge_agent>(as_distance_graph(node_agent, ([distance::distance, species::edge_agent])));     }     else{       my_graph <- graph<node_agent, edge_agent>(generate_barabasi_albert(node_agent,edge_agent,nbAgent,2,true));      }       //For each node agent, we compute its class value  ask node_agent as list{   loop i from:0 to:nbTypeOfClass-1{    classVector[i] <- rnd(nbValuePerClass-1)+1;     }    }   int i<-1;  //Creation of the macronode according to the number of value per class  create macroNode number: nbValuePerClass{     class <-i;   location <- {(cos (((class-1)/nbValuePerClass)*360)*50 +50),(sin (((class-1)/nbValuePerClass)*360)*50+50),0};   color <- hsb (i/nbValuePerClass,1.0,1.0);   do updatemyNodes;   i<-i+1;   }  //We finally create the macroGraph  create macroGraph;  }  //Action to initialize the interaction Matrix according to the number of type of classes  action InitInteractionMatrix{   loop i from:0 to:nbTypeOfClass-1{    interactionMatrix[i] <- 0 as_matrix({nbValuePerClass,nbValuePerClass});      }  } }   //Species to represent the node_agent species node_agent  {  //Color of the node agent  rgb color;  //List of the class  list<int> classVector <- list_with (nbTypeOfClass,0);  //List of the position  list<point> posVector <- list_with (nbTypeOfClass,{0,0});  //List of the color  list<rgb> colorList <- list_with (nbTypeOfClass, rgb(0,0,0));          //Shuffle the classes of the node_agent  reflex shuffleClass{   loop i from:0 to: nbTypeOfClass-1{    classVector[i] <- rnd(nbValuePerClass-1)+1;   }   }      aspect real {       draw sphere(nodeSize) color: colorList[0];  }           aspect coloredByClass{   loop i from:0 to: nbTypeOfClass-1{       colorList[i]<- hsb (classVector[i]/nbValuePerClass,1.0,1.0);            posVector[i] <- {(location.x+i*110)*(1/zoomFactor),(location.y)*(1/zoomFactor),0};         draw sphere(nodeSize/zoomFactor) color: colorList[i] at: posVector[i] ;      }  }  }  //Species edge_agent to represent the edge of the graph species edge_agent {   rgb color;  //Source of the edge  node_agent src;  //Target of the edge  node_agent dest;      aspect base {   draw shape color: rgb(125,125,125);  }     aspect edgeGenericSpatialized{   loop i from:0 to: nbTypeOfClass-1{     if ((src != nil) and (dest !=nil) ){    draw line( [ (src.posVector[i]) , (dest.posVector[i])] ) color:rgb(125,125,125);     }   }  } } //Species representing the macro node agents species macroNode{  rgb color;  int class;  //List of all the aggregated nodes  list<int> nbAggregatedNodes <- list_with(nbTypeOfClass,0);  //List of all the position  list<point> posVector <-list_with(nbTypeOfClass,{0,0});     //Update the nodes of the agents  reflex update{   do updatemyNodes;  }  //For each classes, find all the nodes with the same classes  action updatemyNodes{   loop i from:0 to: nbTypeOfClass-1{       nbAggregatedNodes[i]<-0;    ask node_agent as list{      if (classVector[i] = myself.class) {     myself.nbAggregatedNodes[i] <- myself.nbAggregatedNodes[i]+1;      }         }      }       }     aspect sphere{   draw sphere((nbAggregatedNodes[0]/10)*macroNodeSize) color: color at: point([location.x,location.y]) ;  }    aspect Generic{   loop i from:0 to: nbTypeOfClass-1   {   posVector[i] <- {(location.x+i*150)*(1/zoomFactor),(location.y)*(1/zoomFactor),0};    draw sphere((nbAggregatedNodes[i]/10)*macroNodeSize*(1/zoomFactor)) color: color at: posVector[i] ;   }  }    //This action only works when having nbTypeOfClass=1  action removeMicroNode{   ask node_agent as list{      if (classVector[0] = myself.class) {          do die;      }  }  }    user_command Remove all micro node action: removeMicroNode; }  //Species macroEdge representing the macro edges agents species macroEdge  {   rgb color <- #black;  //Source of the macroedge  macroNode src;  //Destination of the macroedge  macroNode dest;  //List of all the aggregated links  list<int> nbAggregatedLinkList <- list_with(nbTypeOfClass,0);    aspect base {   loop i from:0 to: nbTypeOfClass-1{    if(nbAggregatedLinkList[i]>threshold){    draw (line([src.posVector[i],dest.posVector[i]]) buffer ((nbAggregatedLinkList[i])/((length(edge_agent)))*nbEdgeMax)) color: rgb(125,125,125) border:rgb(125,125,125);      }   }  }    //Action to remove a micro edge  action removeMicroEdge{   ask edge_agent as list{      if ((self.src.classVector[0] =  myself.src.class) and (self.dest.classVector[0] =  myself.dest.class)) {          do die;      }  }  }    user_command Remove all micro edge action: removeMicroEdge;  }  //Species macroGraph representing the macro graph composed of macroNode and macroEdge species macroGraph {      //Reflex to update the graph by killing all the previous edges first  reflex updateAllMacroEdge {     ask macroEdge as list{     do die;    }    loop h from:0 to: nbTypeOfClass-1{    loop i from: 0 to: nbValuePerClass-1{        loop j from: 0 to: nbValuePerClass-1{   int tmp <- interactionMatrix[h] at {i,j};     if(i!=j){    create macroEdge{      nbAggregatedLinkList[h] <- tmp;      src <- macroNode[i];          dest <- macroNode[j];    }      }              }      }     }    }    //Reflex to initialize the matrix    reflex initMatrix{     loop i from:0 to:nbTypeOfClass-1{       interactionMatrix[i] <- 0 as_matrix({nbValuePerClass,nbValuePerClass});      }    }  }   experiment MODAVI type: gui {  output {      display MODAVI type:opengl draw_env:false {    graphics  ReferenceModel {     draw  Reference model  at:{200,50,0} size:5 color: #black perspective:false;    }    species node_agent aspect: real position:{100,0,0.01} ;    graphics  View1 {    draw Advanced view at:{50,210,0} size:5 color: #black perspective:false;   }   species node_agent aspect: coloredByClass position: {0,100,0.02};   species edge_agent aspect: edgeGenericSpatialized position: {0,100,0.02};      graphics  AbstractView {    draw Abstract view/controller at:{250,210,0} size:5 color: #black perspective:false;   }   species macroNode aspect:Generic position: {200,100,0.01};   species macroEdge aspect:base position: {200,100,0.01};   } }   }       ","url":"wiki/Multi-level-data-analysis-MODAVI.md"},{"id":"wiki/Predator-Prey-Lotka-Volterra-(Influence-of-Integration-Step).md","title":" ODE_LotkaVolterra","content":"# ODE_LotkaVolterra  Author : Huynh Quang Nghi & Nathalie Corson  Code of the model :       model ODE_LotkaVolterra_InfluenceTimeStep  global {  float prey_birth_rate ;   // natural birth rate of preys float predation_rate ;    // death rate of preys due to predators float predator_death_rate ;  // natural death rate of predators float predation_efficiency ;  // birth rate of predators due to prey consumption  float nb_prey_init ;    // initial number of preys float nb_predator_init  ;   // initial number of predators  float integration_step ;  // integration time step of the Runge Kutta 4 method float t;        // simulation time : t = n * integration_time_step  where n is the number of already computed time step   float integration_time_step1  <- 1.0;  // first integration time step to compare  float integration_time_step2  <- 0.1;  // second integration time step to compare  float integration_time_step3  <- 0.01;  // third integration time step to compare   list<LotkaVolterra_agent> LV_agents;  init{  create LotkaVolterra_agent number: 1 with:[integration_time_step::integration_time_step1];  // creation of an agent containing the ODE model with an integration time step of value integration_time_step1  create LotkaVolterra_agent number: 1 with:[integration_time_step::integration_time_step2];  // creation of an agent containing the ODE model with an integration time step of value integration_time_step2  create LotkaVolterra_agent number: 1 with:[integration_time_step::integration_time_step3];  // creation of an agent containing the ODE model with an integration time step of value integration_time_step3  LV_agents <- list(LotkaVolterra_agent); } }   species LotkaVolterra_agent {  float nb_prey <- nb_prey_init ;     // number of preys initialized with the values given by the user float nb_predator <- nb_predator_init ;   // number of predators initialized with the values given by the user  float integration_time_step ;      // integration time step used in the Runge Kutta 4 method    equation lotka_volterra {   diff(nb_prey,t) =   nb_prey * (prey_birth_rate - predation_rate * nb_predator);      // evolution of the number of preys duting an integration time step  diff(nb_predator,t) = - nb_predator * (predator_death_rate - predation_efficiency * nb_prey);   // evolution of the number of predator during an integration time step   }   reflex solving {   solve lotka_volterra method: rk4 step:integration_time_step;// cycle_length:1/integration_time_step;    // use of runge kutta 4 method with an integration time step of value integration_time_step    } }   experiment maths type: gui {  parameter Prey birth rate var: prey_birth_rate <- 0.05 min: 0.0 max: 1.0 category: Prey;      // the user defines the value of parameter prey_birth_rate on the interface, the default value is 0.05 and this value must be between 0 and 1 parameter Predation rate var: predation_rate <- 0.001 min: 0.0 max: 1.0 category: Prey;       // the user defines the value of parameter prey_birth_rate on the interface, the default value is 0.001 and this value must be between 0 and 1 parameter Predator death rate var: predator_death_rate <- 0.03 min: 0.0 max: 1.0 category: Predator;    // the user defines the value of parameter predator_death_rate on the interface, the default value is 0.03 and this value must be between 0 and 1 parameter Predation efficiency var: predation_efficiency <- 0.0002 min: 0.0 max: 1.0 category: Predator;  // the user defines the value of parameter predation_efficiency on the interface, the default value is 0.0002 and this value must be between 0 and 1  parameter Initial number of prey var: nb_prey_init <- 250.0 min: 1.0 category: Prey;        // the user defines the value of parameter predation_efficiency on the interface, the default value is 250, the minimum possible value is 1 parameter Initial number of predator var: nb_predator_init <- 45.0 min: 1.0 category: Predator;     // the user defines the value of parameter predation_efficiency on the interface, the default value is 45, the minimum possible value is 1  parameter Integration time step of the first chart  var:  integration_time_step1 <- 1.0  min: 0.0 max:1.0 category: Integration time steps;  // the user defines the value of the first integration step he wants to compare, the default value is 1 and this value must be between 0 and 1 parameter Integration time step of the second chart  var:  integration_time_step2 <- 0.1  min: 0.0 max: 1.0 category: Integration time steps;  // the user defines the value of the second integration step he wants to compare, the default value is 0.1 and this value must be between 0 and 1 parameter Integration time step of the third chart  var:  integration_time_step3 <- 0.01  min: 0.0 max: 1.0 category: Integration time steps;  // the user defines the value of the third integration step he wants to compare, the default value is 0.01 and this value must be between 0 and 1   output {      display TimeSeries  { // creation of a display to show time series of the model, values are plotted at every step. Since there is more than one chart plotted in one display, every chart has a position and a size   chart Lotka Volterra Time Series - Integration time step = 1  type: series background: #white position: {0,0} size:{1,0.33} x_range: 1000 {   // one chart, of type  serie , is named Lotka Volterra Time Series - Integration time step = 1, it shows quantities according to time, and the background is white    data  Number of preys  value: first(LotkaVolterra_agent where (each.integration_time_step = 1.0)).nb_prey color: #green ;   // number of preys in the case where the integration time step is 1 is plotted in green      data  Number of predators  value: first(LotkaVolterra_agent where (each.integration_time_step = 1.0)).nb_predator color: #red ;  // number of predators in the case where the integration time step is 1 is plotted in red    }   chart Lotka Volterra Time Series - Integration time step = 0.1  type: series background: #white position: {0,0.33} size:{1,0.33} x_range: 1000{    data  Number of preys  value: first(LotkaVolterra_agent where (each.integration_time_step = 0.1)).nb_prey color: #green ;        data  Number of predators  value: first(LotkaVolterra_agent where (each.integration_time_step = 0.1)).nb_predator color: #red ;   }   chart Lotka Volterra Time Series - Integration time step = 0.01  type: series background: #white position: {0,0.66} size:{1,0.33}x_range: 1000{    data  Number of preys  value: first(LotkaVolterra_agent where (each.integration_time_step = 0.01)).nb_prey color: #green ;        data  Number of predators  value: first(LotkaVolterra_agent where (each.integration_time_step = 0.01)).nb_predator color: #red ;   }  }  display PhasePortrait {      chart Lotka Volterra Phase Portrait - Integration time step = 1 type: xy background: #white position: {0,0} size:{1,0.33} {  // creation of a display to show phase portrait of the model, values are plotted at every step. Since there is more than one chart plotted in one display, every chart has a position and a size   data  Number of preys according to number of predators  value:{LV_agents[0].nb_prey, LV_agents[0].nb_predator} color: #black ; // number of predators are plotted in black according to the number of preys in the case where the integration time step is 1     }   chart Lotka Volterra Phase Portrait - Integration time step = 0.1 type: xy background: #white position: {0,0.33} size:{1,0.33}{   data  Number of preys according to number of predators  value:{LV_agents[1].nb_prey, LV_agents[1].nb_predator} color: #black ;       }   chart Lotka Volterra Phase Portrait - Integration time step = 0.01 type: xy background: #white position: {0,0.66} size:{1,0.33} {   data  Number of preys according to number of predators  value:{LV_agents[1].nb_prey, LV_agents[1].nb_predator} color: #black ;       }  } } }      ","url":"wiki/Predator-Prey-Lotka-Volterra-(Influence-of-Integration-Step).md"},{"id":"wiki/Predator-Prey-Lotka-Volterra-(Simple).md","title":" ODE_LotkaVolterra","content":"# ODE_LotkaVolterra  Author : Huynh Quang Nghi & Nathalie Corson  Code of the model :       model ODE_LotkaVolterra  global {  float prey_birth_rate<- 0.05 ;   // natural birth rate of preys float predation_rate <- 0.001;    // death rate of preys due to predators float predator_death_rate<- 0.03 ;  // natural death rate of predators float predation_efficiency<- 0.0002 ;  // birth rate of predators due to prey consumption  float nb_prey_init <- 250.0;    // initial number of preys float nb_predator_init <- 45.0 ;   // initial number of predators  float integration_time_step <- 0.01;  // integration time step used in the Runge Kutta 4 method float t;       // simulation time : t = n * integration_time_step  where n is the number of already computed time step  init{  create LotkaVolterra_agent number:1 ;  // creation of an agent containing the ODE model } }   species LotkaVolterra_agent {  float nb_prey <- nb_prey_init ;    // number of preys initialized with the values given by the user float nb_predator <- nb_predator_init ;   // number of predators initialized with the values given by the user  equation lotka_volterra {  diff(nb_prey,t) =   nb_prey * (prey_birth_rate - predation_rate * nb_predator);      // evolution of the number of preys duting an integration time step  diff(nb_predator,t) = - nb_predator * (predator_death_rate - predation_efficiency * nb_prey);   // evolution of the number of predator during an integration time step   }   reflex solving {     solve lotka_volterra method: rk4 step:integration_time_step ;//cycle_length:1/step;    // use of runge kutta 4 method with an integration time step of value integration_time_step    } }   experiment maths type: gui {  parameter Prey birth rate var: prey_birth_rate <- 0.05 min: 0.0 max: 1.0 category: Prey;      // the user defines the value of parameter prey_birth_rate on the interface, the default value is 0.05 and this value must be between 0 and 1 parameter Predation rate var: predation_rate <- 0.001 min: 0.0 max: 1.0 category: Prey;       // the user defines the value of parameter prey_birth_rate on the interface, the default value is 0.001 and this value must be between 0 and 1 parameter Predator death rate var: predator_death_rate <- 0.03 min: 0.0 max: 1.0 category: Predator;    // the user defines the value of parameter predator_death_rate on the interface, the default value is 0.03 and this value must be between 0 and 1 parameter Predation efficiency var: predation_efficiency <- 0.0002 min: 0.0 max: 1.0 category: Predator;  // the user defines the value of parameter predation_efficiency on the interface, the default value is 0.0002 and this value must be between 0 and 1  parameter Initial number of prey var: nb_prey_init <- 250.0 min: 1.0 category: Prey;        // the user defines the value of parameter predation_efficiency on the interface, the default value is 250, the minimum possible value is 1 parameter Initial number of predator var: nb_predator_init <- 45.0 min: 1.0 category: Predator;     // the user defines the value of parameter predation_efficiency on the interface, the default value is 45, the minimum possible value is 1  parameter Integration time step var: integration_time_step <- 0.01 min: 0.0 max:0.1 category: Integration method;  // the user defines the value of the integration step, the default value is 0.01 and this value must be between 0 and 1  output {    display TimeSeries  {                 // creation of a display to show time series of the model, values are plotted at every step   chart Lotka Volterra Time Series type: series background: #white {        // the chart, of type  serie , is named Lotka Volterra Time Series, it shows quantities according to time, and the background is white    data  Number of preys  value: first(LotkaVolterra_agent).nb_prey color: #green ;   // number of preys is plotted in green    data  Number of predators  value: first(LotkaVolterra_agent).nb_predator color: #red ;  // number of predators is plotted in red   }  }  display PhasePortrait  {                // creation of a display to show the phase portait, values are plotted at every time step   chart Lotka Volterra Phase Portrait type: xy background: #white {       // the chart, os type  xy , is named Lotka Volterra Phase portrait, it shows a quantity according to another one, and the background is white   data     value: {predator_death_rate / predation_efficiency, prey_birth_rate/predation_rate} color: °blue; // equilibrium point   data  Number of preys according to number of predators  value:{first(LotkaVolterra_agent).nb_prey, first(LotkaVolterra_agent).nb_predator} color: #black ; // number of predators according to the number of preys plotted in black   }  } } }      ","url":"wiki/Predator-Prey-Lotka-Volterra-(Simple).md"},{"id":"wiki/Segregation-(Schelling)-Segregation-(Agents).md","title":" segregationAgents","content":"# segregationAgents  _Author : _  A model showing the segregation of the people just by putting a similarity wanted parameter using agents to represent the individuals  Imported model :      model segregation_base  global {  //Different colors for the group  rgb color_1 <- rgb ( yellow ) parameter:  Color of group 1:  category:  User interface ;  rgb color_2 <- rgb ( red ) parameter:  Color of group 2:  category:  User interface ;  rgb color_3 <- rgb ( blue ) parameter:  Color of group 3:  category:  User interface ;  rgb color_4 <- rgb ( orange ) parameter:  Color of group 4:  category:  User interface ;  rgb color_5 <- rgb ( green ) parameter:  Color of group 5:  category:  User interface ;  rgb color_6 <- rgb ( pink ) parameter:  Color of group 6:  category:  User interface ;   rgb color_7 <- rgb ( magenta ) parameter:  Color of group 7:  category:  User interface ;  rgb color_8 <- rgb ( cyan ) parameter:  Color of group 8:  category:  User interface ;     list colors <- [color_1, color_2, color_3, color_4, color_5, color_6, color_7, color_8] of: rgb;  //Number of groups int number_of_groups <- 2 max: 8 parameter: Number of groups: category: Population; //Density of the people float density_of_people <- 0.7 parameter: Density of people: category: Population min: 0.01 max: 0.99; //Percentage of similar wanted for segregation float percent_similar_wanted <- 0.5 min: float (0) max: float (1) parameter: Desired percentage of similarity: category: Population; //Dimension of the grid int dimensions <- 40 max: 400 min: 10 parameter: Width and height of the environment: category: Environment; //Neighbours distance for the perception of the agents int neighbours_distance <- 2 max: 10 min: 1 parameter: Distance of perception: category: Population; //Number of people agents int number_of_people <- 0; //Number of happy people int sum_happy_people <- 0 update: all_people count (each.is_happy); //Number of similar neighbours int sum_similar_neighbours <- 0 update: sum (all_people collect each.similar_nearby); //Number of neighbours int sum_total_neighbours <- 1 update: sum (all_people collect each.total_nearby) min: 1; //List of all the places list<agent> all_places; //List of all the people list<base> all_people;    //Action to write the description of the model in the console action description {  write  \\\\n\\\\u25B6 Description. \\\\n\\\\u25B6 Thomas Schelling model of residential segregation is a classic study of the effects of local decisions on global dynamics. Agents with mild preferences for same-type neighbors, but without preferences for segregated neighborhoods, can wind up producing complete segregation.\\\\n\\\\u25B6 In this model, agents populate a grid with a given *density*. They are in two different states : happy when the percentage of same-color neighbours is above their *desired percentage of similarity*; unhappy otherwise. In the latter case, they change their location randomly until they find a neighbourhood that fits their desire. \\\\n\\\\u25B6 In addition to the previous parameter, one can adjust the *distance of perception* (i.e.  the distance at which they consider other agents as neighbours) of the agents to see how it affects the global process. ; } //Initialization of the model init {  //Write the description of the model   do description;  //Initialization of the places  do initialize_places;  //Computation of the number of people according to the density of people  number_of_people <- int( length (all_places) * density_of_people);  //Initialization of the people  do initialize_people; } //Action to initialize places defined in the subclasses action initialize_places virtual: true; //Action to initialize people in the subclasses action initialize_people virtual: true; }   //Species base representing the people agents species base {  rgb color;  //List of all the neighbours agents  list my_neighbours;  //computation of the similar neighbours  int similar_nearby -> {   (my_neighbours count (each.color = color))  };  //Computation of the total neighbours nearby  int total_nearby -> {   length (my_neighbours)  };  //Boolean to know if the agent is happy or not  bool is_happy -> {similar_nearby >= (percent_similar_wanted * total_nearby )} ; }       Code of the model :       model segregation  //import the Common Schelling Segregation model import  ../include/Common Schelling Segregation.gaml   global {  //List of all the free places  list free_places ;  //List of all the places  list all_places ;  //Shape of the world  geometry shape <- square(dimensions);  //Action to initialize the people agents action initialize_people {   create people number: number_of_people;   all_people <- people as list ;   }  //Action to initialize the places action initialize_places {   all_places <- shuffle (space);  free_places <- all_places;   }  } //Grid to discretize space, each cell representing a free space for the people agents grid space width: dimensions height: dimensions neighbors: 8 use_regular_agents: false frequency: 0{ rgb color  <- #black; }   //Species representing the people agents species people parent: base  {  //Color of the people agent  rgb color <- colors at (rnd (number_of_groups - 1));  //List of all the neighbours of the agent  list my_neighbours -> {people at_distance neighbours_distance} ;  //Cell representing the place of the agent  space my_place;  init {   //The agent will be located on one of the free places   my_place <- one_of(free_places);   location <- my_place.location;    //As one agent is in the place, the place is removed from the free places   free_places >> my_place;  }   //Reflex to migrate the people agent when it is not happy   reflex migrate when: !is_happy {   //Add the place to the free places as it will move to another place   free_places << my_place;   //Change the place of the agent   my_place <- one_of(free_places);   location <- my_place.location;    //Remove the new place from the free places   free_places >> my_place;  }  aspect default{   draw circle (0.5) color: color;  } }   experiment schelling type: gui {   output {   display Segregation {    species people;   }    display Charts {    chart  Proportion of happiness  type: pie background: #gray style: exploded position: {0,0} size: {1.0,0.5}{     data  Unhappy  value: number_of_people - sum_happy_people color: #green;     data  Happy  value: sum_happy_people color: #yellow;    }    chart  Global happiness and similarity  type: series background: #gray axes: #white position: {0,0.5} size: {1.0,0.5} {     data  happy  color: #blue value:  (sum_happy_people / number_of_people) * 100 style: spline ;     data  similarity  color: #red value:  (sum_similar_neighbours / sum_total_neighbours) * 100 style: step ;    }   }  } }     ","url":"wiki/Segregation-(Schelling)-Segregation-(Agents).md"},{"id":"wiki/Segregation-(Schelling)-Segregation-(Cellular-Automata).md","title":" segregationGrid","content":"# segregationGrid  _Author : _  Imported model :      model segregation_base  global {  //Different colors for the group  rgb color_1 <- rgb ( yellow ) parameter:  Color of group 1:  category:  User interface ;  rgb color_2 <- rgb ( red ) parameter:  Color of group 2:  category:  User interface ;  rgb color_3 <- rgb ( blue ) parameter:  Color of group 3:  category:  User interface ;  rgb color_4 <- rgb ( orange ) parameter:  Color of group 4:  category:  User interface ;  rgb color_5 <- rgb ( green ) parameter:  Color of group 5:  category:  User interface ;  rgb color_6 <- rgb ( pink ) parameter:  Color of group 6:  category:  User interface ;   rgb color_7 <- rgb ( magenta ) parameter:  Color of group 7:  category:  User interface ;  rgb color_8 <- rgb ( cyan ) parameter:  Color of group 8:  category:  User interface ;     list colors <- [color_1, color_2, color_3, color_4, color_5, color_6, color_7, color_8] of: rgb;  //Number of groups int number_of_groups <- 2 max: 8 parameter: Number of groups: category: Population; //Density of the people float density_of_people <- 0.7 parameter: Density of people: category: Population min: 0.01 max: 0.99; //Percentage of similar wanted for segregation float percent_similar_wanted <- 0.5 min: float (0) max: float (1) parameter: Desired percentage of similarity: category: Population; //Dimension of the grid int dimensions <- 40 max: 400 min: 10 parameter: Width and height of the environment: category: Environment; //Neighbours distance for the perception of the agents int neighbours_distance <- 2 max: 10 min: 1 parameter: Distance of perception: category: Population; //Number of people agents int number_of_people <- 0; //Number of happy people int sum_happy_people <- 0 update: all_people count (each.is_happy); //Number of similar neighbours int sum_similar_neighbours <- 0 update: sum (all_people collect each.similar_nearby); //Number of neighbours int sum_total_neighbours <- 1 update: sum (all_people collect each.total_nearby) min: 1; //List of all the places list<agent> all_places; //List of all the people list<base> all_people;    //Action to write the description of the model in the console action description {  write  \\\\n\\\\u25B6 Description. \\\\n\\\\u25B6 Thomas Schelling model of residential segregation is a classic study of the effects of local decisions on global dynamics. Agents with mild preferences for same-type neighbors, but without preferences for segregated neighborhoods, can wind up producing complete segregation.\\\\n\\\\u25B6 In this model, agents populate a grid with a given *density*. They are in two different states : happy when the percentage of same-color neighbours is above their *desired percentage of similarity*; unhappy otherwise. In the latter case, they change their location randomly until they find a neighbourhood that fits their desire. \\\\n\\\\u25B6 In addition to the previous parameter, one can adjust the *distance of perception* (i.e.  the distance at which they consider other agents as neighbours) of the agents to see how it affects the global process. ; } //Initialization of the model init {  //Write the description of the model   do description;  //Initialization of the places  do initialize_places;  //Computation of the number of people according to the density of people  number_of_people <- int( length (all_places) * density_of_people);  //Initialization of the people  do initialize_people; } //Action to initialize places defined in the subclasses action initialize_places virtual: true; //Action to initialize people in the subclasses action initialize_people virtual: true; }   //Species base representing the people agents species base {  rgb color;  //List of all the neighbours agents  list my_neighbours;  //computation of the similar neighbours  int similar_nearby -> {   (my_neighbours count (each.color = color))  };  //Computation of the total neighbours nearby  int total_nearby -> {   length (my_neighbours)  };  //Boolean to know if the agent is happy or not  bool is_happy -> {similar_nearby >= (percent_similar_wanted * total_nearby )} ; }       Code of the model :      model segregation  //Importation of the Common Schelling Segregation model import  ../include/Common Schelling Segregation.gaml   //Define the environment as torus global torus: true{  //List of all the free places  list free_places ;  //List of all the places  list all_places  ;  //List of all the people  list all_people;  //Shape of the environment  geometry shape <- square(dimensions);  //Action to initialize the places action initialize_places {  all_places <- shuffle(space);  free_places <- shuffle(all_places); } //Action to initialize the people agents action initialize_people {  //Place all the people agent in the cellular automata  loop i from: 0 to: number_of_people - 1 {   space pp <- all_places at i;   remove pp from: free_places;   add pp to: all_people;   pp.color <- colors at (rnd(number_of_groups - 1));  }  } //Reflex to migrate all the people agents reflex migrate {  ask copy(all_people) {   do migrate;  }  }   }  //Grid species representing the places and the people in each cell grid space parent: base width: dimensions height: dimensions neighbors: 8  {  rgb color <- #black;  //List of the neighbours of the places  list my_neighbours <- self neighbors_at neighbours_distance;  //Action to migrate the agent in another cell if it is not happy  action migrate {   if !is_happy {    //Change the space of the agent to a free space    space pp <- any(my_neighbours where (each.color = #black));    if (pp != nil) {     free_places <+ self;     free_places >- pp;     all_people >- self;     all_people << pp;     pp.color <- color;     color <- #black;    }   }  } }  experiment schelling type: gui {  output {   display Segregation {    grid space;   }   display Charts {   chart Proportion of happiness type: pie background: #lightgray style: exploded position: { 0, 0 } size: { 1.0, 0.5 } {    data Unhappy value: number_of_people - sum_happy_people color: #green;    data Happy value: sum_happy_people color: #yellow;   }    chart Global happiness and similarity type: series background: #lightgray axes: #white position: { 0, 0.5 } size: { 1.0, 0.5 }  x_range: 50{    data happy color: #blue value: (sum_happy_people / number_of_people) * 100 style: spline;    data similarity color: #red value: (sum_similar_neighbours / sum_total_neighbours) * 100 style: step;   }   }  }   }     ","url":"wiki/Segregation-(Schelling)-Segregation-(Cellular-Automata).md"},{"id":"wiki/Segregation-(Schelling)-Segregation-(GIS).md","title":" segregationGIS","content":"# segregationGIS  _Author : _  A model showing the segregation of the people just by putting a similarity wanted parameter using agents to represent the individuals and GIS file for the places  Imported model :      model segregation_base  global {  //Different colors for the group  rgb color_1 <- rgb ( yellow ) parameter:  Color of group 1:  category:  User interface ;  rgb color_2 <- rgb ( red ) parameter:  Color of group 2:  category:  User interface ;  rgb color_3 <- rgb ( blue ) parameter:  Color of group 3:  category:  User interface ;  rgb color_4 <- rgb ( orange ) parameter:  Color of group 4:  category:  User interface ;  rgb color_5 <- rgb ( green ) parameter:  Color of group 5:  category:  User interface ;  rgb color_6 <- rgb ( pink ) parameter:  Color of group 6:  category:  User interface ;   rgb color_7 <- rgb ( magenta ) parameter:  Color of group 7:  category:  User interface ;  rgb color_8 <- rgb ( cyan ) parameter:  Color of group 8:  category:  User interface ;     list colors <- [color_1, color_2, color_3, color_4, color_5, color_6, color_7, color_8] of: rgb;  //Number of groups int number_of_groups <- 2 max: 8 parameter: Number of groups: category: Population; //Density of the people float density_of_people <- 0.7 parameter: Density of people: category: Population min: 0.01 max: 0.99; //Percentage of similar wanted for segregation float percent_similar_wanted <- 0.5 min: float (0) max: float (1) parameter: Desired percentage of similarity: category: Population; //Dimension of the grid int dimensions <- 40 max: 400 min: 10 parameter: Width and height of the environment: category: Environment; //Neighbours distance for the perception of the agents int neighbours_distance <- 2 max: 10 min: 1 parameter: Distance of perception: category: Population; //Number of people agents int number_of_people <- 0; //Number of happy people int sum_happy_people <- 0 update: all_people count (each.is_happy); //Number of similar neighbours int sum_similar_neighbours <- 0 update: sum (all_people collect each.similar_nearby); //Number of neighbours int sum_total_neighbours <- 1 update: sum (all_people collect each.total_nearby) min: 1; //List of all the places list<agent> all_places; //List of all the people list<base> all_people;    //Action to write the description of the model in the console action description {  write  \\\\n\\\\u25B6 Description. \\\\n\\\\u25B6 Thomas Schelling model of residential segregation is a classic study of the effects of local decisions on global dynamics. Agents with mild preferences for same-type neighbors, but without preferences for segregated neighborhoods, can wind up producing complete segregation.\\\\n\\\\u25B6 In this model, agents populate a grid with a given *density*. They are in two different states : happy when the percentage of same-color neighbours is above their *desired percentage of similarity*; unhappy otherwise. In the latter case, they change their location randomly until they find a neighbourhood that fits their desire. \\\\n\\\\u25B6 In addition to the previous parameter, one can adjust the *distance of perception* (i.e.  the distance at which they consider other agents as neighbours) of the agents to see how it affects the global process. ; } //Initialization of the model init {  //Write the description of the model   do description;  //Initialization of the places  do initialize_places;  //Computation of the number of people according to the density of people  number_of_people <- int( length (all_places) * density_of_people);  //Initialization of the people  do initialize_people; } //Action to initialize places defined in the subclasses action initialize_places virtual: true; //Action to initialize people in the subclasses action initialize_people virtual: true; }   //Species base representing the people agents species base {  rgb color;  //List of all the neighbours agents  list my_neighbours;  //computation of the similar neighbours  int similar_nearby -> {   (my_neighbours count (each.color = color))  };  //Computation of the total neighbours nearby  int total_nearby -> {   length (my_neighbours)  };  //Boolean to know if the agent is happy or not  bool is_happy -> {similar_nearby >= (percent_similar_wanted * total_nearby )} ; }       Code of the model :      model segregation  //Import the model Common Schelling Segregation import  ../include/Common Schelling Segregation.gaml   global {  //List of all the free places  list free_places  ;    //List of all the places  list all_places ;  //Neighbours distance for the perception of an agent  int neighbours_distance <- 50 min: 1 parameter: Distance of perception: category: Population max: 1000;  //Shapefile to load  file shape_file_name <- file(../gis/nha2.shp) parameter: Shapefile to load: category: GIS specific;  //Shape of the environment  geometry shape <- envelope(shape_file_name);  //Square meters per people in m2  int square_meters_per_people <- 200 parameter: Occupancy of people (in m2): category: GIS specific;  //Action to initialize people agents action initialize_people {   //Create all the places with a surface given within the shapefile  create space from: shape_file_name with: [surface :: float(read(AREA))];  all_places  <- shuffle(space);  //Compute the number of people to create considering the density of people  number_of_people <- int( density_of_people * sum (all_places collect (each.capacity)));   create people number: number_of_people;       all_people <- people as list ;      //Move all the people to a new place  ask people  {     do move_to_new_place;  }    }       //Action to initialize the places action initialize_places {}      }  //Species people representing the people species people parent: base {   //Size of the people agent  float size const: true <- 2.0;  //Color of the people agent  rgb color const: true <- colors at (rnd (number_of_groups - 1));   int red const: true <- (color as list) at 0;   int green const: true <- (color as list) at 1;  int blue const: true <- (color as list) at 2;  //Building in which the agent lives  space current_building <- nil;  //List of all the neighbour people agents  list my_neighbours -> {people at_distance neighbours_distance};  //Action to move to a new place action move_to_new_place {    current_building <- (shuffle(all_places) first_with (((each).capacity) > 0));  ask current_building {   do accept one_people: myself;     } } //Reflex to migrate to another place if the agent isn t happy reflex migrate when: !is_happy {  if current_building != nil {   ask current_building {     do remove_one one_people: myself;   }  }   do move_to_new_place; }  aspect simple {  draw circle(5) color: color; } }   //Species space representing a space for a people agent to live in species space {   //List of all the people agents living within  list insiders;  rgb color <- rgb(255, 255, 255);   //Surface of the place  float surface;  //Capacity of the place  int capacity  <- 1 + int(surface / square_meters_per_people);  //Action to accept a people agent   action accept (people one_people) {  add one_people to: insiders;  location of one_people <- any_location_in(shape);  capacity <- capacity - 1; } //Action to remove a people agent action remove_one (people one_people){  remove one_people from: insiders;  capacity <- capacity + 1; } aspect simple {  color <- empty(insiders) ? #white : rgb ([mean (insiders collect each.red), mean (insiders collect each.green), mean (insiders collect each.blue)]);  draw  square(40) color: color; } aspect gis {  color <- empty(insiders) ? #white : rgb( [mean (insiders collect each.red), mean (insiders collect each.green), mean (insiders collect each.blue)]);  draw shape color: color border: #black; }  aspect highlighted {  color <- #blue;  draw shape+10 color: color; } }   experiment schelling type: gui {   output {   display Town_display  {    species space aspect: gis;    species people  aspect: simple;   }   display Charts {    chart  Proportion of happiness  type: histogram background: #lightgray gap:0.05 position: {0,0} size: {1.0,0.5}{     data  Unhappy  value: number_of_people - sum_happy_people color: #green;     data  Happy  value: sum_happy_people color: #yellow ;    }    chart  Global happiness and similarity  type: series background: #lightgray axes: #white position: {0,0.5} size: {1.0,0.5} {     data  happy  color: #blue value:  ((sum_happy_people * 100) / number_of_people)  style: spline ;     data  similarity  color: #red value:  (sum_similar_neighbours / sum_total_neighbours) * 100 style: step ;    }   }  } }     ","url":"wiki/Segregation-(Schelling)-Segregation-(GIS).md"},{"id":"wiki/Segregation-(Schelling)-Segregation-(Google-Map).md","title":" segregationGoogleMap","content":"# segregationGoogleMap  _Author : _  A model showing the segregation of the people just by putting a similarity wanted parameter using agents to represent the individuals and a grid to discretize space. Use the colors of the image to know if it is a possible space or not  Imported model :      model segregation_base  global {  //Different colors for the group  rgb color_1 <- rgb ( yellow ) parameter:  Color of group 1:  category:  User interface ;  rgb color_2 <- rgb ( red ) parameter:  Color of group 2:  category:  User interface ;  rgb color_3 <- rgb ( blue ) parameter:  Color of group 3:  category:  User interface ;  rgb color_4 <- rgb ( orange ) parameter:  Color of group 4:  category:  User interface ;  rgb color_5 <- rgb ( green ) parameter:  Color of group 5:  category:  User interface ;  rgb color_6 <- rgb ( pink ) parameter:  Color of group 6:  category:  User interface ;   rgb color_7 <- rgb ( magenta ) parameter:  Color of group 7:  category:  User interface ;  rgb color_8 <- rgb ( cyan ) parameter:  Color of group 8:  category:  User interface ;     list colors <- [color_1, color_2, color_3, color_4, color_5, color_6, color_7, color_8] of: rgb;  //Number of groups int number_of_groups <- 2 max: 8 parameter: Number of groups: category: Population; //Density of the people float density_of_people <- 0.7 parameter: Density of people: category: Population min: 0.01 max: 0.99; //Percentage of similar wanted for segregation float percent_similar_wanted <- 0.5 min: float (0) max: float (1) parameter: Desired percentage of similarity: category: Population; //Dimension of the grid int dimensions <- 40 max: 400 min: 10 parameter: Width and height of the environment: category: Environment; //Neighbours distance for the perception of the agents int neighbours_distance <- 2 max: 10 min: 1 parameter: Distance of perception: category: Population; //Number of people agents int number_of_people <- 0; //Number of happy people int sum_happy_people <- 0 update: all_people count (each.is_happy); //Number of similar neighbours int sum_similar_neighbours <- 0 update: sum (all_people collect each.similar_nearby); //Number of neighbours int sum_total_neighbours <- 1 update: sum (all_people collect each.total_nearby) min: 1; //List of all the places list<agent> all_places; //List of all the people list<base> all_people;    //Action to write the description of the model in the console action description {  write  \\\\n\\\\u25B6 Description. \\\\n\\\\u25B6 Thomas Schelling model of residential segregation is a classic study of the effects of local decisions on global dynamics. Agents with mild preferences for same-type neighbors, but without preferences for segregated neighborhoods, can wind up producing complete segregation.\\\\n\\\\u25B6 In this model, agents populate a grid with a given *density*. They are in two different states : happy when the percentage of same-color neighbours is above their *desired percentage of similarity*; unhappy otherwise. In the latter case, they change their location randomly until they find a neighbourhood that fits their desire. \\\\n\\\\u25B6 In addition to the previous parameter, one can adjust the *distance of perception* (i.e.  the distance at which they consider other agents as neighbours) of the agents to see how it affects the global process. ; } //Initialization of the model init {  //Write the description of the model   do description;  //Initialization of the places  do initialize_places;  //Computation of the number of people according to the density of people  number_of_people <- int( length (all_places) * density_of_people);  //Initialization of the people  do initialize_people; } //Action to initialize places defined in the subclasses action initialize_places virtual: true; //Action to initialize people in the subclasses action initialize_people virtual: true; }   //Species base representing the people agents species base {  rgb color;  //List of all the neighbours agents  list my_neighbours;  //computation of the similar neighbours  int similar_nearby -> {   (my_neighbours count (each.color = color))  };  //Computation of the total neighbours nearby  int total_nearby -> {   length (my_neighbours)  };  //Boolean to know if the agent is happy or not  bool is_happy -> {similar_nearby >= (percent_similar_wanted * total_nearby )} ; }       Code of the model :      model segregation  //Import the model Common Schelling Segregation import  ../include/Common Schelling Segregation.gaml   global {  //List of all the free places  list free_places ;   //List of all the places  list all_places;  //Shape of the environment  geometry shape <- square(dimensions);  //Percentage of similarity wanted by an agent  float percent_similar_wanted <- 0.6;  //Distance of perception of the neighbours  int neighbours_distance <- 4;   //Number of groups of people  int number_of_groups <- 3;  list google_buildings  <- [rgb(#EBE6DC), rgb(#D1D0CD), rgb(#F2EFE9), rgb(#EEEBE1), rgb(#F9EFE8)] ;  //List of all the available places  list available_places ;  //Image file to load  file bitmap_file_name <- file<unknown, int>(../images/hanoi.png) parameter: Name of image file to load: category: Environment ;  matrix map_colors;    //Action to initialize the people agents action initialize_people {  create people number: number_of_people ;    all_people <- people as list ;   } //Action to initialize the places using the color in the image action initialize_places {   map_colors <- (bitmap_file_name) as_matrix {dimensions,dimensions} ;  ask space as list {   color <- rgb(map_colors at {grid_x,grid_y}) ;  }  all_places <- shuffle (space where (each.color in google_buildings)) ;  free_places <- copy(all_places); }   } //Grid to discretize the space grid space width: dimensions height: dimensions neighbors: 8 use_individual_shapes: false use_regular_agents: false frequency: 0 ;    //Species people representing the people agent species people parent: base  {  rgb color <- colors at (rnd (number_of_groups - 1));  //List of all the neighbours  list my_neighbours -> {(self neighbors_at neighbours_distance) of_species people};  //Launched at the initialization of the agent init {  //Set the place of the agent as one of the free place  location <- (one_of(free_places)).location;   remove location as space from: free_places; }  //Reflex to migrate the agent when it s not happy reflex migrate when: !is_happy {   add location as space to: free_places;  location <- any(free_places).location;  remove location as space from: free_places; } aspect geom {  draw square(1) color: color  ; } aspect default {  draw  square(2) color: #black ; } }   experiment schelling type: gui {   output {   display Segregation {    image  bg  file: bitmap_file_name.path ;    species people transparency: 0.5 aspect: geom;   }    display Charts {    chart  Proportion of happiness  type: pie background: #lightgray style: exploded position: { 0, 0 } size: { 1.0, 0.5 } {     data  Unhappy  value: number_of_people - sum_happy_people color: #green;     data  Happy  value: sum_happy_people color: #yellow;    }    chart Global happiness and similarity type: series background: #lightgray axes: #white position: { 0, 0.5 } size: { 1.0, 0.5 } x_range: 20 y_range: 20 {    data happy color: °blue value: (sum_happy_people / number_of_people) * 100 style: spline fill: false;    data similarity color: °red value: (sum_similar_neighbours / sum_total_neighbours) * 100 style: line fill: true ;   }  } } }      ","url":"wiki/Segregation-(Schelling)-Segregation-(Google-Map).md"},{"id":"wiki/Soccer-soccer.md","title":" Soccer Game","content":"# Soccer Game  Author : Julien  This model shows how can we make an easy simulation of collective games, such as soccer.  Each player have an offensive and a defensive position, and a behavior associated. Each player of the defensive team can either search to catch the ball or mark an other player (offensive player) according to his defensive position. Each player of the offensive team can either run to its offensive place (when he does not have the ball), run with the balloon / pass the ball / try to score a goal (when he has the ball). By changing the different parameters, you can see the concequences in real time.  Code of the model :       model soccer  global {  geometry shape <- rectangle(120#m,90#m);  float red_players_speed <- 1.0;  float blue_players_speed <- 1.0;  float red_size_play_area <- 30.0 min:1.0 max:100.0;  float blue_size_play_area <- 30.0 min: 1.0 max:100.0;  float previous_red_size_play_area <- red_size_play_area; // just to check if the parameter value has been changed  float previous_blue_size_play_area <- blue_size_play_area; // just to check if the parameter value has been changed  float red_collective_play <- 0.5 min:0.0 max:1.0;  float blue_collective_play <- 0.5 min:0.0 max:1.0;  float red_recuperation_ability <- 0.5 min:0.0 max:1.0;  float blue_recuperation_ability <- 0.5 min:0.0 max:1.0;  int red_score <- 0; int red_possession <- 0; int nb_red_pass <- 0; int nb_red_pass_succeed <- 0; int nb_red_interception <- 0; int blue_score <- 0; int blue_possession <- 0; int nb_blue_pass <- 0; int nb_blue_pass_succeed <- 0; int nb_blue_interception <- 0;  bool show_status <- false; bool show_area <- false; bool show_marked_player <- false; bool show_ball_indicator <- false;  bool play_with_offside <- true;  list<point> bluePlayerPosition <- [{8,10}, {8,80}, {10,30}, {10,60},  {30,25}, {28,45}, {30,65},  {50,25}, {50,65}, {55,45} ];  list<point> redPlayerPosition <- [{120-8,10}, {120-8,80}, {120-10,30}, {120-10,60},  {120-30,25}, {120-28,45}, {120-30,65},  {120-50,25}, {120-50,65}, {120-55,45} ];  ball ball_agent; player closest_red_player_from_the_ball; player closest_blue_player_from_the_ball; player called_player; string team_possession <- ; float blue_offside_pos <- 120.0; float red_offside_pos <- 0.0;  init {  loop pos over:redPlayerPosition {   create player with:[team::red, location::pos];  }  loop pos over:bluePlayerPosition {   create player with:[team::blue, location::pos];  }  create ball with:[location::location] returns:ball_agt;  ball_agent<-ball_agt at 0;  create goal with:[location::{0,location.y}, team::blue];  create goal with:[location::{120,location.y}, team::red]; }  reflex update {  float shortest_distance <- 100.0;  float offside_pos <- 0.0;  ask player where (each.team = red) {   if (distance_to_ball < shortest_distance and inactivity_time=0) {    closest_red_player_from_the_ball <- self;    shortest_distance <- distance_to_ball;   }   if (location.x > offside_pos) {    offside_pos <- location.x;    red_offside_pos <- offside_pos;   }  }  if (not play_with_offside) {   red_offside_pos <- 120.0;  }    shortest_distance <- 100.0;  offside_pos <- 100.0;  ask player where (each.team = blue) {   if (distance_to_ball < shortest_distance and inactivity_time=0) {    closest_blue_player_from_the_ball <- self;    shortest_distance <- distance_to_ball;   }   if (location.x < offside_pos) {    offside_pos <- location.x;    blue_offside_pos <- offside_pos;   }  }  if (not play_with_offside) {   blue_offside_pos <- 0.0;  }    if (previous_red_size_play_area != red_size_play_area) {   ask area where (each.team = red) {    do update_size;   }   previous_red_size_play_area <- red_size_play_area;  }  if (previous_blue_size_play_area != blue_size_play_area) {   ask area where (each.team = blue) {    do update_size;   }   previous_blue_size_play_area <- blue_size_play_area;  }  if (team_possession = blue) {   blue_possession <- blue_possession + 1;  }  if (team_possession = red) {   red_possession <- red_possession + 1;  } }  action reinit_phase {  ask player {   location <- init_pos;   previous_pos <- init_pos;  }  ball_agent.location <- location;  ball_agent.destination <- location;  ball_agent.speed <- 0.0; } }   species player skills:[moving] {  string team <-   ; // value :  blue  (left side) or  red  (right side)  bool possess_ball <- false;  int inactivity_time <- 0 update:(inactivity_time<=0) ? 0 : inactivity_time-1;  int seed <- rnd(100);  point init_pos;  point previous_pos;  // strategy area defensive_pos; area offensive_pos; player marked_player; float collective_mark <- 0.5 update:(team=red) ? red_collective_play : blue_collective_play; float recuperation_mark <- 0.5 update:(team=red) ? red_recuperation_ability : blue_recuperation_ability;  string status <- ;  // moving attributes float running_speed_without_ball <- 0.8 update:(team=red) ? red_players_speed*0.8 : blue_players_speed*0.8; float running_speed_with_ball <- 0.6 update:(team=red) ? red_players_speed*0.5 : blue_players_speed*0.5; float speed <- 0.0 max:1.2; point velocity <- {0,0};  float distance_to_closest_ennemy <- 100.0; float distance_to_ennemy_goal <- 100.0 update:self distance_to ( (goal where (each.team != team)) at 0); float distance_to_ball <- 100.0 update:self distance_to ball_agent;  init {  init_pos <- location;  previous_pos <- location;  create area with:[location::init_pos, team::self.team, position::init_pos] returns:def_pos;  defensive_pos <- def_pos at 0;  point offensivePos <- {(team=red) ? init_pos.x-60 : init_pos.x+60,init_pos.y};  create area with:[location::offensivePos, team::self.team, position::offensivePos] returns:off_pos;  offensive_pos <- off_pos at 0; }  reflex update_status {  distance_to_closest_ennemy <- 100.0;  loop pl over:player where (each.team != team) {   float distance_to_ennemy <- self distance_to pl;   if (distance_to_ennemy < distance_to_closest_ennemy) {    distance_to_closest_ennemy <- distance_to_ennemy;   }  } }  reflex defensive_behavior when:team_possession != team {  // the ball is not possessed by the team.  do apply_inertia;  if (self = closest_red_player_from_the_ball or self = closest_blue_player_from_the_ball) {   do run_to_ball;  }  else {   do defensive_move;  } }  reflex offensive_behavior when:team_possession = team {  do apply_inertia;  if (possess_ball) {   do run_with_ball;   if (distance_to_ennemy_goal < 30 and flip(1/(distance_to_ennemy_goal*distance_to_ennemy_goal/10+1))) {    // shoot !    do kick_ball_to_goal;   }   else {    // pass !    if (distance_to_closest_ennemy < 5) {     if (flip(collective_mark)) {      do pass_the_ball;     }    }    else if flip(collective_mark/50) {     do pass_the_ball;    }   }  }  else if (ball_agent.belong_to_team =  and   (self = closest_red_player_from_the_ball or self = closest_blue_player_from_the_ball   or self = called_player)  ) {   do run_to_ball;  }  else {   do offensive_move;  } }  reflex choose_player_to_mark when:(cycle mod 20=seed or cycle=0) {  if ( not empty(player where(each.offensive_pos intersects defensive_pos)) ) {   marked_player <- 1 among (player where((each.offensive_pos intersects defensive_pos) and (each.team != team))) at 0;  } }  action apply_inertia {  point prev_pos <- location;  point inertia_vect <- {(location.x-previous_pos.x)*0.8,(location.y-previous_pos.y)*0.8};  float max_inertia <- running_speed_without_ball;  if (norm(inertia_vect) > max_inertia) {   float inertia_x <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));   float inertia_y <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));   inertia_x <- (inertia_vect.x < 0) ? -inertia_x : inertia_x;   inertia_y <- (inertia_vect.y < 0) ? -inertia_y : inertia_y;   inertia_vect <- {inertia_x,inertia_y};  }  location <- location + inertia_vect;  previous_pos <- prev_pos; }  action run_to_ball {  point targetPos;  if (ball_agent.ball_direction intersects circle(1)) {   targetPos <- ball_agent.location;  }  else {   targetPos <- (ball_agent.ball_direction closest_points_with self) at 0;  }  do goto with:[target::targetPos, speed::running_speed_without_ball];    status <- run to the ball;    // if close enough, catch the ball  if (location distance_to ball_agent.location < 1.5#m) {   if (self = called_player) {    do take_ball;   }   else if (ball_agent.belong_to_team = ) {    if flip(1/(ball_agent.speed*recuperation_mark+1)) {     do take_ball;    }   }   else {    if (team_possession = team) {     // result of a long pass for instance     if (flip(recuperation_mark*1.5)) {      do take_ball;     }    }    else {     // interception of the ball     if (flip(recuperation_mark*0.8)) {      do take_ball;     }    }   }  } }  action run_with_ball {  status <- run with the ball;  point goal_pos;  ask goal {   if (self.team != myself.team) {    goal_pos <- location;   }  }  do goto with:[target::goal_pos, speed::running_speed_with_ball];  ball_agent.location <- location; }  action offensive_move {  // try to reach an offensive postion  point target_location;  geometry possible_pos <- (team=red) ? world inter (rectangle({blue_offside_pos,0},{120,90}))  : world inter (rectangle({0,0},{red_offside_pos,90}));      // check if the player is in the field  if (location.y < 0) {   target_location <- {location.x,90};  }  else if (location.y > 90) {   target_location <- {location.x,0};  }  // check if the player is in offside position  else if ( (location.x > red_offside_pos and team = blue) or (location.x < blue_offside_pos and team = red)) {   target_location <- (team=red) ? {120,location.y} : {0,location.y};   status <- run to a non offside position;  }  else {   status <- run to a offensive place;   if (not (possible_pos intersects offensive_pos)) {    target_location <- (team=red) ? {blue_offside_pos,location.y} : {red_offside_pos,location.y};   }   else   {    target_location <- any_location_in(offensive_pos inter possible_pos);   }  }  do goto target:target_location speed:running_speed_without_ball; }  action defensive_move {  // try to mark an ennemy player  status <- mark ennemy player;  if (not (marked_player = nil)) {   do goto with:[target::marked_player.location+((team=red)?{2+rnd(5.0),rnd(2.0)-1} : {-2-rnd(5.0),rnd(2.0)-1}), speed::running_speed_without_ball];  } }  action kick_ball_to_goal {  do loose_ball;  ask ball_agent {   do shooted speed_atr:4.0 target_position:((goal where (each.team != myself.team)) at 0).location;  }  inactivity_time <- 20; }  action pass_the_ball {  float wisest_choice_mark <- -100.0;  player wisest_target;  ask player  where(each.team = team and each != self and (self distance_to each > 15)) {   int number_of_ennemies_on_range <- length(player at_distance 5 where (each.team != myself.team));   float wise_choice_mark <- 100-distance_to_ball+number_of_ennemies_on_range*10-2*distance_to_ennemy_goal;   if (wise_choice_mark > wisest_choice_mark) {    wisest_target <- self;    wisest_choice_mark <- wise_choice_mark;   }  }  if (wisest_choice_mark > -100.0) {   // a target has been found   do loose_ball;   ask ball_agent {    do shooted target_position:wisest_target.location speed_atr:wisest_target.distance_to_ball/8;   }   called_player <- wisest_target;   inactivity_time <- 20;   if (team = red) {nb_red_pass <- nb_red_pass+1;}   else {nb_blue_pass <- nb_blue_pass+1;}  } }  action take_ball {  if (ball_agent.belong_to_team !=  and ball_agent.belong_to_team != team) {   ask ball_agent.belong_to_player {    do loose_ball;   }  }  team_possession <- team;  possess_ball <- true;  ball_agent.belong_to_team <- team;  ball_agent.belong_to_player <- self;  ball_agent.speed <- 0.0;  if (self = called_player) {   if (team = red) {nb_red_pass_succeed <- nb_red_pass_succeed+1;}   else {nb_blue_pass_succeed <- nb_blue_pass_succeed+1;}  }  else {   if (team = red) {nb_red_interception <- nb_red_interception+1;}   else {nb_blue_interception <- nb_blue_interception+1;}  }  called_player <- nil; }  action loose_ball {  possess_ball <- false;  ball_agent.belong_to_team <- ; }  aspect base {  draw circle(1) color:(team=red) ? #red : #blue;  if (show_status) {   draw string(status);   if (marked_player != nil) {    draw polyline([location,marked_player.location]);   }  }  if (marked_player != nil and show_marked_player) {   draw polyline([location,marked_player.location]) end_arrow:1 color:#chartreuse;  } } }   species area {  string team <-   ;  point position;  init {  shape <- ((team=red) ? square(red_size_play_area) : square(blue_size_play_area)) inter world; }  action update_size {  location <- position;  shape <- ((team=red) ? square(red_size_play_area) : square(blue_size_play_area)) inter world; }  aspect base {  if (show_area) {   draw shape color:rgb(128,128,128,50) border:(team=red) ? rgb(256,0.0,0.0,100) : rgb(0.0,0.0,256.0,100);  } } }   species ball skills:[moving]{  string belong_to_team <-   ;  player belong_to_player;  float speed <- 0.0 update:speed*0.9;  list nextPlace;  geometry ball_direction;  reflex update {   float future_speed <- speed;   point tmpPos<-location;   loop i from:0 to:10 {    tmpPos <- {tmpPos.x+cos(heading)*speed,tmpPos.y+sin(heading)*speed};    future_speed <- future_speed*0.9;   }   ball_direction <- line([location,tmpPos]);   if ((location.x+cos(heading)*speed) > 120) {    blue_score <- blue_score + 1;    ask world {     do reinit_phase;    }   }   if ((location.x+cos(heading)*speed) < 0) {    red_score <- red_score + 1;    ask world {     do reinit_phase;    }   }   do wander amplitude:1;  }  action shooted (point target_position, float speed_atr) {   speed <- speed_atr;   do goto target:target_position;  }  aspect base {   draw circle(0.5) color:#white border:#black;   if (show_ball_indicator) {    draw ball_direction end_arrow:1 color:#chartreuse;    if (team_possession=red) {     draw circle(0.5) color:#darkred border:#black;    }    else if (team_possession=blue) {     draw circle(0.5) color:#darkblue border:#black;    }   }  } }  species goal {  string team <-   ;  aspect base {   draw rectangle(0.1,7.32) color:#black;  } }  experiment match type:gui {  parameter  blue running speed  var:blue_players_speed category: Blue Team ;  parameter  red running speed  var:red_players_speed category: Red Team ;  // speed of players when they run. Note that a player which have the ball will run at 50% of his max capacity, and he will run at 80% of his max capacity if he does not have the ball.  parameter blue collective play var:blue_collective_play category:Blue Team; parameter red collective play var:red_collective_play category:Red Team; // propention of giving the ball to an other player of the team. If the value is 0, the player will never pass the ball.  parameter blue recuperation ability var:blue_recuperation_ability category:Blue Team; parameter red recuperation ability var:red_recuperation_ability category:Red Team; // ability to catch the ball when no player has it and when a player of the other team has it. 1 for very good hability, 0 for very poor hability.  parameter blue play area size var:blue_size_play_area category:Blue Team; parameter red play area size var:red_size_play_area category:Red Team; // change the size of the area of each player. The bigger this area is, the less players will maintains their position.  parameter display status var:show_status category:Display; // displays or not the current status of the player (his intentions)  parameter display play area var:show_area category:Display; // displays or not the offensive and defensive area of each player. The bigger this area is, the less players will maintains their position.  parameter display marked player var:show_marked_player category:Display; // displays or not an arrow between the player that are marked each other.  parameter display ball indicators var:show_ball_indicator category:Display; // changes the color of the ball if the ball is possessed by the blue or the red team. Display also the direction of the ball when it has been shooted.  parameter play with offside position var:play_with_offside category:Rules; // play with or without the offside rule.  output {  display soccer_field {   // display the field.   image ../images/soccer_field.png;   species player aspect:base;   species ball aspect:base;   species goal aspect:base;   species area aspect:base;   graphics score_display {    draw Blue side - +string(blue_score) color:#blue at: {10,5} font: font(Helvetica, 18 * #zoom, #bold) perspective:true;    draw string(red_score)+ - Red side color:#red at: {100,5} font: font(Helvetica, 18 * #zoom, #bold) perspective:true;    if (show_status) {     draw line([{red_offside_pos,0},{red_offside_pos,90}]) color:#red;     draw line([{blue_offside_pos,0},{blue_offside_pos,90}]) color:#blue;    }   }  }  display match_stats {   // display some statistics about the game   chart ball_possession type:pie position:{0,0} size:{0.5,0.5} {    data Red possession value:red_possession color:#red;    data Blue possession value:blue_possession color:#blue;   }   chart red pass type:pie position:{0,0.5} size:{0.5,0.5} {    // note that a pass is said successful if the player that has the ball was the player called initially. A failed pass does not necessary means that the team have lost the ball.     data Red pass succeed value:(nb_red_pass = 0) ? 0 : float(nb_red_pass_succeed)/float(nb_red_pass) color:#red;     data Red pass failed value:(nb_red_pass = 0) ? 0 : 1-float(nb_red_pass_succeed)/float(nb_red_pass) color:#darkred;   }   chart blue pass type:pie position:{0.5,0.5} size:{0.5,0.5} {    // note that a pass is said successful if the player that has the ball was the player called initially. A failed pass does not necessary means that the team have lost the ball.    data Blue pass succeed value:(nb_blue_pass = 0) ? 0 : float(nb_blue_pass_succeed)/float(nb_blue_pass) color:#blue;    data Blue pass failed value:(nb_blue_pass = 0) ? 0 : 1-float(nb_blue_pass_succeed)/float(nb_blue_pass) color:#darkblue;   }   chart number pass type:series position:{0.5,0} size:{0.5,0.5} {    data Number pass red value:nb_red_pass color:#red;    data Number pass blue value:nb_blue_pass color:#blue;   }  } } }      ","url":"wiki/Soccer-soccer.md"},{"id":"wiki/Soccer-soccer_base.md","title":" _soccerbase","content":"# _soccerbase  Author : Julien  This model contains the parent classes of the model  Code of the model :       model soccerbase  species soccer_game {  // contains the global informations of the game  rgb back_color_team;  rgb front_color_team;  ball_sp ball; // the ball agent goal_sp front_goal; // contains the goal at the front of the field (y = 120) goal_sp back_goal; // contains the goal at the back of the field (y = 0) list<base_team> teams; // contains the 2 teams list<base_player> players; // contains all the players of the game  base_team team_possession; // the last team which possess the ball. This value is used to determine if the behavior of the team has to be defensive or offensive.  init {  // create the entities ball and the 2 goals  create ball_sp with:[location::world.location] returns:var_ball;  ball <- first(var_ball);  create goal_sp with:[location::{world.location.x,120},position::front] returns:var_goal1;  front_goal <- first(var_goal1);  create goal_sp with:[location::{world.location.x,0},position::back] returns:var_goal2;  back_goal <- first(var_goal2); }  action reinit_phase {  // this action is called when a goal has been scored : the players are placed with their initial position, and the ball is reset to the center  ask players {   location <- init_pos;   previous_pos <- init_pos;  }  ball.location <- world.location;  ball.destination <- world.location;  ball.speed <- 0.0; } }   species base_player skills:[moving] {  // ATTRIBUTES ////////////////////////////////////////////////  // ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE float recuperation_ability <- 0.2; // a mark from 0 to 1 to be able to catch the ball if another player has it float speed_without_ball; float speed_with_ball; point previous_pos; // used to apply inertia bool displacement_effectued<-false update:false; // we can apply only one displacement by step !  // ATTRIBUTE USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !) base_team team; soccer_game game; base_team ennemy_team <- nil update:first(game.teams where (each.position != team.position)); ball_sp ball <- nil update:first(ball_sp); goal_sp own_goal <- nil update:first(goal_sp where (each.position = team.position)); goal_sp ennemy_goal <- nil update:first(goal_sp where (each.position != team.position)); // ratio of avancement of the ball (from the point of view of the current team) float ball_advancement <- 0.0 update:(team.position = back) ? ball.location.y / 120 : 1 - ball.location.y / 120;  bool possess_ball; point init_pos; point init_pos_in_percent; float distance_to_closest_ennemy_player <- 100.0 update:self distance_to closest_ennemy_player; // the number of ennemy players in a range of 15 meters int number_of_ennemy_player_in_range <- 0 update:length((game.players where (each.team != team)) where ((each intersects circle(15))=true)); float distance_to_ball <- 100.0 update:(ball = nil) ? 100.0 : self distance_to ball; float distance_to_goal <- 100.0 update:(ennemy_goal = nil) ? 100.0 : self distance_to ennemy_goal; // the closest player of this team base_player closest_friend_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team = team and each != self))   where (each distance_to self = min( (game.players where (each.team = team and each != self)) collect (each distance_to self) ) )  ); // the closest ennemy player base_player closest_ennemy_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team != team and each != self))   where (each distance_to self = min( (game.players where (each.team != team and each != self)) collect (each distance_to self) ) )  ); // the player of this team wich has the best position_mark base_player best_position_player <- nil update:first((team.players where (each != self))   where (each.position_mark = max((team.players where (each != self)) collect (each.position_mark))) ); float current_speed<-1.0 update:(possess_ball) ? speed_with_ball : speed_without_ball;  // ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRAGEGY FILE float position_mark <- 0.0 update:-distance_to_goal; // a mark attributed according to the position of the player (the higher the note is, the best the position is).  // By default, this mark is equal to -distance_to_goal. string status <- ; // the current status of the player (can be useful to build the model) geometry influence_area <- nil update:circle(15); // the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.   // CONSTRUCTOR ///////////////////////////////////////////// init {  init_pos <- location;  previous_pos <- location;  possess_ball <- false;  speed_with_ball <- 0.4;  speed_without_ball <- 0.5; }  // ACTIONS ////////////////////////////////////////////////////  // ACTIONS TO CALL FROM THE STRATEGY FILE // action to run to a particular position action run_to(point target) {  if (!displacement_effectued) {    do goto target:target speed:current_speed;   if (possess_ball) {    ball.location <- location;   }   displacement_effectued <- true;  }  else {   write WARNING : only ONE action of displacement is allowed each step;  } }  // action to run to the ball action run_to_ball {  point targetPos;  if (ball.ball_direction intersects circle(1)) {   targetPos <- ball.location;  }  else {   targetPos <- (ball.ball_direction closest_points_with self) at 0;  }  do run_to(targetPos); }  // action to run to the ennemy goal action run_to_ennemy_goal {  do run_to( ennemy_goal.location ); }  // action to run to its own goal action run_to_own_goal {  do run_to( own_goal.location ); }  // action to mark a player action mark_player (base_player player) {  float rnd_area <- 4.0; // the player will choose a position in a square of rnd_area m.  point pos <- (team.position = front) ? {player.location.x,player.location.y-rnd_area/2} : {player.location.x,player.location.y+rnd_area/2};  do run_to( {pos.x-rnd_area/2+rnd(rnd_area),pos.y-rnd_area/2+rnd(rnd_area)} ); }  // action ot shoot the ball to the ennemy goal action shoot {  do loose_ball;  ask ball {   do shooted speed_atr:3.0 target_position:myself.ennemy_goal.location;  } }  // action to pass the ball to an ally action pass_the_ball (base_player target_player) {  do loose_ball;  ask ball {   do shooted target_position:target_player.location speed_atr:target_player.distance_to_ball/15;  }  team.called_player <- target_player; }  // action to pass the ball to an ally action pass_the_ball_ahead (base_player target_player,float number_of_meter_ahead) {  do loose_ball;  ask ball {   float offset <- ((myself.team.position = back) ? number_of_meter_ahead : -number_of_meter_ahead);   point target_point <- {target_player.location.x,target_player.location.y+offset};   do shooted target_position:target_point speed_atr:target_player.distance_to_ball/15;  }  team.called_player <- target_player; }  // ACTION AUTOMATICALLY CALLED IN THE BASE CLASSE // try to take the ball if it is close enough action try_to_take_ball {  // if no player has the ball  if (!team.possess_ball and !ennemy_team.possess_ball) {   // if the player is the one called (result of a pass)   if (team.called_player = self) {    do take_ball;   }   // if the player is not the one called (interception of the ball), probability to catch the ball inversly proportionnal with the speed of the ball   else {    if (flip(1/(1+2*ball.speed))) {     do take_ball;    }   }  }  // the ball is possessed by the ennemy team  else if (ennemy_team.possess_ball) {   // try to catch the ball from the other player   if flip(recuperation_ability) {    do take_ball;   }  } }  // action of taking the ball action take_ball {  if (ennemy_team.possess_ball) {   ask ennemy_team.player_with_ball {    do loose_ball;   }  }  possess_ball <- true;  ball.speed <- 0.0;  ball.destination <- ball.location;  team.called_player <- nil;  team.player_with_ball <- self;  team.possess_ball <- true;  game.team_possession <- team; }  // action of loosing the ball action loose_ball {  possess_ball <- false;  team.player_with_ball <- nil;  team.possess_ball <- false; }  // apply the inertia action apply_inertia {  point prev_pos <- location;  point inertia_vect <- {(location.x-previous_pos.x)*0.7,(location.y-previous_pos.y)*0.7};  float max_inertia <- current_speed;  if (norm(inertia_vect) > max_inertia) {   float inertia_x <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));   float inertia_y <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));   inertia_x <- (inertia_vect.x < 0) ? -inertia_x : inertia_x;   inertia_y <- (inertia_vect.y < 0) ? -inertia_y : inertia_y;   inertia_vect <- {inertia_x,inertia_y};  }  location <- location + inertia_vect;  previous_pos <- prev_pos; }  // useful functions // this function returns the real x if we pass a percentage : 0 is the extreme left point, 100 is the extreme right point. float getXPos(float x_ratio) {  float result;  if (team.position=back) {   result <- 90-x_ratio*90;  }  else {   result <- x_ratio*90;  }  return result; }  // this function returns the real y if we pass a percentage : 0 is the extreme defensive point, 100 is the extreme attack point. float getYPos(float y_ratio) {  float result;  if (team.position=back) {   result <- y_ratio*120;  }  else {   result <- 120-y_ratio*120;  }  return result; }  ///////////////////////////////////////////////////////  // The update function, calls the adequate behavior reflex update when:cycle>1 {  do apply_inertia;  // verify if it is a non-offside position  if ( (((team.position = back) and (location.y > team.offside_pos))   or ((team.position = front) and (location.y < team.offside_pos)))    and (!possess_ball) and (self != team.called_player)  ) {   // offside position, go back to a correct position   point target_pos <- {location.x,(team.position = back) ? location.y-current_speed:location.y+current_speed};   do run_to(target_pos);   status <- offside position !;  }  else if ((distance_to_ball < 2) and !possess_ball) {   do try_to_take_ball;  }  else if (game.team_possession = team) {   do offensive_behavior;  }  else {   do defensive_behavior;  } }  // defensive behavior, need to be redefined in the strategy file. // this action is called when the last player who was holding the ball was a player of the ennemy team action defensive_behavior virtual:true {   } // defensive behavior, need to be redefined in the strategy file. // this action is called when the last player who was holding the ball was a player of this team action offensive_behavior virtual:true {   }   // ASPECT //////////////////////////////////////////////////////// aspect player {  // the player wich possess the ball is displayed with a square. It is displayed with a circle otherwise.  if (possess_ball) {   draw square(2) color:(team.position = back) ? game.back_color_team : game.front_color_team;  }  else {   draw circle(1) color:(team.position = back) ? game.back_color_team : game.front_color_team;  } } }   species base_team {  // ATTRIBUTES ////////////////////////////////////////////////  // ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE float offside_pos <- 0.0 update: (position = back) ? max((game.players where (each.team != self)) collect (each.location.y))  : min((game.players where (each.team != self)) collect (each.location.y));  // ATTRIBUTES USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !) string position; // can be front or back. list<base_player> players; // all the players of the team. soccer_game game;  base_player closest_player_to_ball <- first(players) update: first( players where (each distance_to each.ball = min (players collect (each distance_to each.ball) ) ) ); base_player called_player; bool possess_ball <- false;// update: ! empty ( players where (each.possess_ball=true) ); base_player player_with_ball <- nil;// update: first(players where (each.possess_ball = true));  // ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRATEGY FILE list<point> player_init_position; }   species ball_sp skills:[moving] {  // The ball agent.  float speed <- 0.0;  geometry ball_direction; // the direction of the ball is used to be followed by the player  reflex update {   speed <- speed0.95;   float future_speed <- speed;   point tmpPos<-location;   loop i from:0 to:10 {    tmpPos <- {tmpPos.x+cos(heading)speed,tmpPos.y+sin(heading)speed};    future_speed <- future_speed0.9;   }   ball_direction <- line([location,tmpPos]);   do wander amplitude:1;   // anticipation of the ball position to detect a goal  if ((location.y+sin(heading)*speed) > 120) {   write back team score a goal !!;   ask first(soccer_game) {    do reinit_phase;   }  }  if ((location.y+sin(heading)*speed) < 0) {   write front team score a goal !!;   ask first(soccer_game) {    do reinit_phase;   }  } } action shooted (point target_position, float speed_atr) {  // action called when a player shoots the ball  speed <- speed_atr;  do goto target:target_position; }  aspect ball {  draw circle(0.5) color:#white; } }   species goal_sp {  string position; // can be  front  or  back .  init {  create goal_keeper with:[position::position]; }  aspect goal {  draw rectangle(7.32,1.0) color:#black; } }   species goal_keeper {  // the goal has a basic behavior : he tries to catch the ball when it is close enough, and when   string position; // can be  front  or  back .  ball_sp ball <- nil update:first(ball_sp);  reflex update when:cycle>0 {  location <- {ball.location.x/90*12+(90-12)/2,location.y};  if (ball distance_to self < 2) {   if (flip(1/(1+2*ball.speed))) {    first(soccer_game).team_possession <- first(first(soccer_game).teams where (each.position = position));    ask ball {     do shooted ({30+rnd(30),60},5.0);    }   }  } }  init {  location <- {45,(position=front) ? 117 : 3}; }  action offensive_behavior { }  action defensive_behavior { }  aspect goal_keeper {  draw circle(1) color:(position = back) ? first(soccer_game).back_color_team : first(soccer_game).front_color_team; } }      ","url":"wiki/Soccer-soccer_base.md"},{"id":"wiki/Soccer-soccer_expe.md","title":" Soccer game (Various strategies)","content":"# Soccer game (Various strategies)  Author : Julien  This model shows a game between two teams, with the same of with different strategies : * The  stupidTeam  has a very basic strategy : when a player has the ball, he runs to the ennemy goal, he runs to the ball otherwise. * The  intelligentTeam  is composed of players that each one have a strategical place wich they are able to keep. They also do pass when they are in dangerous position, to the  safer  player. This model is designed to show how, with the same set of rules and some predefined actions, we can build a strategy of a team. You are free to change the imported files  team1_strategy.gaml  and  team2_strategy.gaml , using the read-only and the read-write attributes of the mother species.  Imported models :       model soccerbase  species soccer_game {  // contains the global informations of the game  rgb back_color_team;  rgb front_color_team;  ball_sp ball; // the ball agent goal_sp front_goal; // contains the goal at the front of the field (y = 120) goal_sp back_goal; // contains the goal at the back of the field (y = 0) list<base_team> teams; // contains the 2 teams list<base_player> players; // contains all the players of the game  base_team team_possession; // the last team which possess the ball. This value is used to determine if the behavior of the team has to be defensive or offensive.  init {  // create the entities ball and the 2 goals  create ball_sp with:[location::world.location] returns:var_ball;  ball <- first(var_ball);  create goal_sp with:[location::{world.location.x,120},position::front] returns:var_goal1;  front_goal <- first(var_goal1);  create goal_sp with:[location::{world.location.x,0},position::back] returns:var_goal2;  back_goal <- first(var_goal2); }  action reinit_phase {  // this action is called when a goal has been scored : the players are placed with their initial position, and the ball is reset to the center  ask players {   location <- init_pos;   previous_pos <- init_pos;  }  ball.location <- world.location;  ball.destination <- world.location;  ball.speed <- 0.0; } }   species base_player skills:[moving] {  // ATTRIBUTES ////////////////////////////////////////////////  // ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE float recuperation_ability <- 0.2; // a mark from 0 to 1 to be able to catch the ball if another player has it float speed_without_ball; float speed_with_ball; point previous_pos; // used to apply inertia bool displacement_effectued<-false update:false; // we can apply only one displacement by step !  // ATTRIBUTE USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !) base_team team; soccer_game game; base_team ennemy_team <- nil update:first(game.teams where (each.position != team.position)); ball_sp ball <- nil update:first(ball_sp); goal_sp own_goal <- nil update:first(goal_sp where (each.position = team.position)); goal_sp ennemy_goal <- nil update:first(goal_sp where (each.position != team.position)); // ratio of avancement of the ball (from the point of view of the current team) float ball_advancement <- 0.0 update:(team.position = back) ? ball.location.y / 120 : 1 - ball.location.y / 120;  bool possess_ball; point init_pos; point init_pos_in_percent; float distance_to_closest_ennemy_player <- 100.0 update:self distance_to closest_ennemy_player; // the number of ennemy players in a range of 15 meters int number_of_ennemy_player_in_range <- 0 update:length((game.players where (each.team != team)) where ((each intersects circle(15))=true)); float distance_to_ball <- 100.0 update:(ball = nil) ? 100.0 : self distance_to ball; float distance_to_goal <- 100.0 update:(ennemy_goal = nil) ? 100.0 : self distance_to ennemy_goal; // the closest player of this team base_player closest_friend_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team = team and each != self))   where (each distance_to self = min( (game.players where (each.team = team and each != self)) collect (each distance_to self) ) )  ); // the closest ennemy player base_player closest_ennemy_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team != team and each != self))   where (each distance_to self = min( (game.players where (each.team != team and each != self)) collect (each distance_to self) ) )  ); // the player of this team wich has the best position_mark base_player best_position_player <- nil update:first((team.players where (each != self))   where (each.position_mark = max((team.players where (each != self)) collect (each.position_mark))) ); float current_speed<-1.0 update:(possess_ball) ? speed_with_ball : speed_without_ball;  // ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRAGEGY FILE float position_mark <- 0.0 update:-distance_to_goal; // a mark attributed according to the position of the player (the higher the note is, the best the position is).  // By default, this mark is equal to -distance_to_goal. string status <- ; // the current status of the player (can be useful to build the model) geometry influence_area <- nil update:circle(15); // the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.   // CONSTRUCTOR ///////////////////////////////////////////// init {  init_pos <- location;  previous_pos <- location;  possess_ball <- false;  speed_with_ball <- 0.4;  speed_without_ball <- 0.5; }  // ACTIONS ////////////////////////////////////////////////////  // ACTIONS TO CALL FROM THE STRATEGY FILE // action to run to a particular position action run_to(point target) {  if (!displacement_effectued) {    do goto target:target speed:current_speed;   if (possess_ball) {    ball.location <- location;   }   displacement_effectued <- true;  }  else {   write WARNING : only ONE action of displacement is allowed each step;  } }  // action to run to the ball action run_to_ball {  point targetPos;  if (ball.ball_direction intersects circle(1)) {   targetPos <- ball.location;  }  else {   targetPos <- (ball.ball_direction closest_points_with self) at 0;  }  do run_to(targetPos); }  // action to run to the ennemy goal action run_to_ennemy_goal {  do run_to( ennemy_goal.location ); }  // action to run to its own goal action run_to_own_goal {  do run_to( own_goal.location ); }  // action to mark a player action mark_player (base_player player) {  float rnd_area <- 4.0; // the player will choose a position in a square of rnd_area m.  point pos <- (team.position = front) ? {player.location.x,player.location.y-rnd_area/2} : {player.location.x,player.location.y+rnd_area/2};  do run_to( {pos.x-rnd_area/2+rnd(rnd_area),pos.y-rnd_area/2+rnd(rnd_area)} ); }  // action ot shoot the ball to the ennemy goal action shoot {  do loose_ball;  ask ball {   do shooted speed_atr:3.0 target_position:myself.ennemy_goal.location;  } }  // action to pass the ball to an ally action pass_the_ball (base_player target_player) {  do loose_ball;  ask ball {   do shooted target_position:target_player.location speed_atr:target_player.distance_to_ball/15;  }  team.called_player <- target_player; }  // action to pass the ball to an ally action pass_the_ball_ahead (base_player target_player,float number_of_meter_ahead) {  do loose_ball;  ask ball {   float offset <- ((myself.team.position = back) ? number_of_meter_ahead : -number_of_meter_ahead);   point target_point <- {target_player.location.x,target_player.location.y+offset};   do shooted target_position:target_point speed_atr:target_player.distance_to_ball/15;  }  team.called_player <- target_player; }  // ACTION AUTOMATICALLY CALLED IN THE BASE CLASSE // try to take the ball if it is close enough action try_to_take_ball {  // if no player has the ball  if (!team.possess_ball and !ennemy_team.possess_ball) {   // if the player is the one called (result of a pass)   if (team.called_player = self) {    do take_ball;   }   // if the player is not the one called (interception of the ball), probability to catch the ball inversly proportionnal with the speed of the ball   else {    if (flip(1/(1+2*ball.speed))) {     do take_ball;    }   }  }  // the ball is possessed by the ennemy team  else if (ennemy_team.possess_ball) {   // try to catch the ball from the other player   if flip(recuperation_ability) {    do take_ball;   }  } }  // action of taking the ball action take_ball {  if (ennemy_team.possess_ball) {   ask ennemy_team.player_with_ball {    do loose_ball;   }  }  possess_ball <- true;  ball.speed <- 0.0;  ball.destination <- ball.location;  team.called_player <- nil;  team.player_with_ball <- self;  team.possess_ball <- true;  game.team_possession <- team; }  // action of loosing the ball action loose_ball {  possess_ball <- false;  team.player_with_ball <- nil;  team.possess_ball <- false; }  // apply the inertia action apply_inertia {  point prev_pos <- location;  point inertia_vect <- {(location.x-previous_pos.x)*0.7,(location.y-previous_pos.y)*0.7};  float max_inertia <- current_speed;  if (norm(inertia_vect) > max_inertia) {   float inertia_x <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));   float inertia_y <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));   inertia_x <- (inertia_vect.x < 0) ? -inertia_x : inertia_x;   inertia_y <- (inertia_vect.y < 0) ? -inertia_y : inertia_y;   inertia_vect <- {inertia_x,inertia_y};  }  location <- location + inertia_vect;  previous_pos <- prev_pos; }  // useful functions // this function returns the real x if we pass a percentage : 0 is the extreme left point, 100 is the extreme right point. float getXPos(float x_ratio) {  float result;  if (team.position=back) {   result <- 90-x_ratio*90;  }  else {   result <- x_ratio*90;  }  return result; }  // this function returns the real y if we pass a percentage : 0 is the extreme defensive point, 100 is the extreme attack point. float getYPos(float y_ratio) {  float result;  if (team.position=back) {   result <- y_ratio*120;  }  else {   result <- 120-y_ratio*120;  }  return result; }  ///////////////////////////////////////////////////////  // The update function, calls the adequate behavior reflex update when:cycle>1 {  do apply_inertia;  // verify if it is a non-offside position  if ( (((team.position = back) and (location.y > team.offside_pos))   or ((team.position = front) and (location.y < team.offside_pos)))    and (!possess_ball) and (self != team.called_player)  ) {   // offside position, go back to a correct position   point target_pos <- {location.x,(team.position = back) ? location.y-current_speed:location.y+current_speed};   do run_to(target_pos);   status <- offside position !;  }  else if ((distance_to_ball < 2) and !possess_ball) {   do try_to_take_ball;  }  else if (game.team_possession = team) {   do offensive_behavior;  }  else {   do defensive_behavior;  } }  // defensive behavior, need to be redefined in the strategy file. // this action is called when the last player who was holding the ball was a player of the ennemy team action defensive_behavior virtual:true {   } // defensive behavior, need to be redefined in the strategy file. // this action is called when the last player who was holding the ball was a player of this team action offensive_behavior virtual:true {   }   // ASPECT //////////////////////////////////////////////////////// aspect player {  // the player wich possess the ball is displayed with a square. It is displayed with a circle otherwise.  if (possess_ball) {   draw square(2) color:(team.position = back) ? game.back_color_team : game.front_color_team;  }  else {   draw circle(1) color:(team.position = back) ? game.back_color_team : game.front_color_team;  } } }   species base_team {  // ATTRIBUTES ////////////////////////////////////////////////  // ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE float offside_pos <- 0.0 update: (position = back) ? max((game.players where (each.team != self)) collect (each.location.y))  : min((game.players where (each.team != self)) collect (each.location.y));  // ATTRIBUTES USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !) string position; // can be front or back. list<base_player> players; // all the players of the team. soccer_game game;  base_player closest_player_to_ball <- first(players) update: first( players where (each distance_to each.ball = min (players collect (each distance_to each.ball) ) ) ); base_player called_player; bool possess_ball <- false;// update: ! empty ( players where (each.possess_ball=true) ); base_player player_with_ball <- nil;// update: first(players where (each.possess_ball = true));  // ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRATEGY FILE list<point> player_init_position; }   species ball_sp skills:[moving] {  // The ball agent.  float speed <- 0.0;  geometry ball_direction; // the direction of the ball is used to be followed by the player  reflex update {   speed <- speed0.95;   float future_speed <- speed;   point tmpPos<-location;   loop i from:0 to:10 {    tmpPos <- {tmpPos.x+cos(heading)speed,tmpPos.y+sin(heading)speed};    future_speed <- future_speed0.9;   }   ball_direction <- line([location,tmpPos]);   do wander amplitude:1;   // anticipation of the ball position to detect a goal  if ((location.y+sin(heading)*speed) > 120) {   write back team score a goal !!;   ask first(soccer_game) {    do reinit_phase;   }  }  if ((location.y+sin(heading)*speed) < 0) {   write front team score a goal !!;   ask first(soccer_game) {    do reinit_phase;   }  } } action shooted (point target_position, float speed_atr) {  // action called when a player shoots the ball  speed <- speed_atr;  do goto target:target_position; }  aspect ball {  draw circle(0.5) color:#white; } }   species goal_sp {  string position; // can be  front  or  back .  init {  create goal_keeper with:[position::position]; }  aspect goal {  draw rectangle(7.32,1.0) color:#black; } }   species goal_keeper {  // the goal has a basic behavior : he tries to catch the ball when it is close enough, and when   string position; // can be  front  or  back .  ball_sp ball <- nil update:first(ball_sp);  reflex update when:cycle>0 {  location <- {ball.location.x/90*12+(90-12)/2,location.y};  if (ball distance_to self < 2) {   if (flip(1/(1+2*ball.speed))) {    first(soccer_game).team_possession <- first(first(soccer_game).teams where (each.position = position));    ask ball {     do shooted ({30+rnd(30),60},5.0);    }   }  } }  init {  location <- {45,(position=front) ? 117 : 3}; }  action offensive_behavior { }  action defensive_behavior { }  aspect goal_keeper {  draw circle(1) color:(position = back) ? first(soccer_game).back_color_team : first(soccer_game).front_color_team; } }            model team2strategy  import  ./soccer_base.gaml   species player_stupidTeam parent:base_player {  // READ ONLY ATTRIBUTES :  // position : can be  front  or  back .  // players : list of all the players of the team.  // game  //closest_player_to_ball  // called_player : the player called for a pass  // possess_ball : true or false  // player_with_ball : player currently with the ball  // READ AND WRITE ATTRIBUTES : // position_mark // status : the current status of the player (can be useful to build the model) // influence_area : the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.   action defensive_behavior {   // very basic defensive behavior : run to the ball  do run_to_ball; }  action offensive_behavior {   // very basic offensive behavior : run to the ennemy goal, or shoot the ball when close enough from the ennemy goal.  if ((possess_ball) and (distance_to_goal < 30)) {   do shoot;  }  else {   do run_to_ennemy_goal;  } }   }  species stupidTeam parent:base_team {  // READ ONLY ATTRIBUTES :  // position : can be  front  or  back .  // players : list of all the players of the team.  // game.  // closest_player_to_ball.  // called_player : the player called for a pass.  // possess_ball : true when a player of the team possess the ball.  // player_with_ball  // READ AND WRITE ATTRIBUTES : // player_init_position  // initial position of the player in percentage : for each point, //    the first value corresponds to the percentage from left to right (0 for the point the most in the left side) //    the second value corresponds to the percentage from the goal position to the mid position (0 for the goal position) list<point> player_init_position <- [{20,20},{50,20},{80,20},{30,50},{70,50},{50,70},{30,90},{50,90},{70,90}]; }             model soccerbase  species soccer_game {  // contains the global informations of the game  rgb back_color_team;  rgb front_color_team;  ball_sp ball; // the ball agent goal_sp front_goal; // contains the goal at the front of the field (y = 120) goal_sp back_goal; // contains the goal at the back of the field (y = 0) list<base_team> teams; // contains the 2 teams list<base_player> players; // contains all the players of the game  base_team team_possession; // the last team which possess the ball. This value is used to determine if the behavior of the team has to be defensive or offensive.  init {  // create the entities ball and the 2 goals  create ball_sp with:[location::world.location] returns:var_ball;  ball <- first(var_ball);  create goal_sp with:[location::{world.location.x,120},position::front] returns:var_goal1;  front_goal <- first(var_goal1);  create goal_sp with:[location::{world.location.x,0},position::back] returns:var_goal2;  back_goal <- first(var_goal2); }  action reinit_phase {  // this action is called when a goal has been scored : the players are placed with their initial position, and the ball is reset to the center  ask players {   location <- init_pos;   previous_pos <- init_pos;  }  ball.location <- world.location;  ball.destination <- world.location;  ball.speed <- 0.0; } }   species base_player skills:[moving] {  // ATTRIBUTES ////////////////////////////////////////////////  // ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE float recuperation_ability <- 0.2; // a mark from 0 to 1 to be able to catch the ball if another player has it float speed_without_ball; float speed_with_ball; point previous_pos; // used to apply inertia bool displacement_effectued<-false update:false; // we can apply only one displacement by step !  // ATTRIBUTE USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !) base_team team; soccer_game game; base_team ennemy_team <- nil update:first(game.teams where (each.position != team.position)); ball_sp ball <- nil update:first(ball_sp); goal_sp own_goal <- nil update:first(goal_sp where (each.position = team.position)); goal_sp ennemy_goal <- nil update:first(goal_sp where (each.position != team.position)); // ratio of avancement of the ball (from the point of view of the current team) float ball_advancement <- 0.0 update:(team.position = back) ? ball.location.y / 120 : 1 - ball.location.y / 120;  bool possess_ball; point init_pos; point init_pos_in_percent; float distance_to_closest_ennemy_player <- 100.0 update:self distance_to closest_ennemy_player; // the number of ennemy players in a range of 15 meters int number_of_ennemy_player_in_range <- 0 update:length((game.players where (each.team != team)) where ((each intersects circle(15))=true)); float distance_to_ball <- 100.0 update:(ball = nil) ? 100.0 : self distance_to ball; float distance_to_goal <- 100.0 update:(ennemy_goal = nil) ? 100.0 : self distance_to ennemy_goal; // the closest player of this team base_player closest_friend_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team = team and each != self))   where (each distance_to self = min( (game.players where (each.team = team and each != self)) collect (each distance_to self) ) )  ); // the closest ennemy player base_player closest_ennemy_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team != team and each != self))   where (each distance_to self = min( (game.players where (each.team != team and each != self)) collect (each distance_to self) ) )  ); // the player of this team wich has the best position_mark base_player best_position_player <- nil update:first((team.players where (each != self))   where (each.position_mark = max((team.players where (each != self)) collect (each.position_mark))) ); float current_speed<-1.0 update:(possess_ball) ? speed_with_ball : speed_without_ball;  // ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRAGEGY FILE float position_mark <- 0.0 update:-distance_to_goal; // a mark attributed according to the position of the player (the higher the note is, the best the position is).  // By default, this mark is equal to -distance_to_goal. string status <- ; // the current status of the player (can be useful to build the model) geometry influence_area <- nil update:circle(15); // the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.   // CONSTRUCTOR ///////////////////////////////////////////// init {  init_pos <- location;  previous_pos <- location;  possess_ball <- false;  speed_with_ball <- 0.4;  speed_without_ball <- 0.5; }  // ACTIONS ////////////////////////////////////////////////////  // ACTIONS TO CALL FROM THE STRATEGY FILE // action to run to a particular position action run_to(point target) {  if (!displacement_effectued) {    do goto target:target speed:current_speed;   if (possess_ball) {    ball.location <- location;   }   displacement_effectued <- true;  }  else {   write WARNING : only ONE action of displacement is allowed each step;  } }  // action to run to the ball action run_to_ball {  point targetPos;  if (ball.ball_direction intersects circle(1)) {   targetPos <- ball.location;  }  else {   targetPos <- (ball.ball_direction closest_points_with self) at 0;  }  do run_to(targetPos); }  // action to run to the ennemy goal action run_to_ennemy_goal {  do run_to( ennemy_goal.location ); }  // action to run to its own goal action run_to_own_goal {  do run_to( own_goal.location ); }  // action to mark a player action mark_player (base_player player) {  float rnd_area <- 4.0; // the player will choose a position in a square of rnd_area m.  point pos <- (team.position = front) ? {player.location.x,player.location.y-rnd_area/2} : {player.location.x,player.location.y+rnd_area/2};  do run_to( {pos.x-rnd_area/2+rnd(rnd_area),pos.y-rnd_area/2+rnd(rnd_area)} ); }  // action ot shoot the ball to the ennemy goal action shoot {  do loose_ball;  ask ball {   do shooted speed_atr:3.0 target_position:myself.ennemy_goal.location;  } }  // action to pass the ball to an ally action pass_the_ball (base_player target_player) {  do loose_ball;  ask ball {   do shooted target_position:target_player.location speed_atr:target_player.distance_to_ball/15;  }  team.called_player <- target_player; }  // action to pass the ball to an ally action pass_the_ball_ahead (base_player target_player,float number_of_meter_ahead) {  do loose_ball;  ask ball {   float offset <- ((myself.team.position = back) ? number_of_meter_ahead : -number_of_meter_ahead);   point target_point <- {target_player.location.x,target_player.location.y+offset};   do shooted target_position:target_point speed_atr:target_player.distance_to_ball/15;  }  team.called_player <- target_player; }  // ACTION AUTOMATICALLY CALLED IN THE BASE CLASSE // try to take the ball if it is close enough action try_to_take_ball {  // if no player has the ball  if (!team.possess_ball and !ennemy_team.possess_ball) {   // if the player is the one called (result of a pass)   if (team.called_player = self) {    do take_ball;   }   // if the player is not the one called (interception of the ball), probability to catch the ball inversly proportionnal with the speed of the ball   else {    if (flip(1/(1+2*ball.speed))) {     do take_ball;    }   }  }  // the ball is possessed by the ennemy team  else if (ennemy_team.possess_ball) {   // try to catch the ball from the other player   if flip(recuperation_ability) {    do take_ball;   }  } }  // action of taking the ball action take_ball {  if (ennemy_team.possess_ball) {   ask ennemy_team.player_with_ball {    do loose_ball;   }  }  possess_ball <- true;  ball.speed <- 0.0;  ball.destination <- ball.location;  team.called_player <- nil;  team.player_with_ball <- self;  team.possess_ball <- true;  game.team_possession <- team; }  // action of loosing the ball action loose_ball {  possess_ball <- false;  team.player_with_ball <- nil;  team.possess_ball <- false; }  // apply the inertia action apply_inertia {  point prev_pos <- location;  point inertia_vect <- {(location.x-previous_pos.x)*0.7,(location.y-previous_pos.y)*0.7};  float max_inertia <- current_speed;  if (norm(inertia_vect) > max_inertia) {   float inertia_x <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));   float inertia_y <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));   inertia_x <- (inertia_vect.x < 0) ? -inertia_x : inertia_x;   inertia_y <- (inertia_vect.y < 0) ? -inertia_y : inertia_y;   inertia_vect <- {inertia_x,inertia_y};  }  location <- location + inertia_vect;  previous_pos <- prev_pos; }  // useful functions // this function returns the real x if we pass a percentage : 0 is the extreme left point, 100 is the extreme right point. float getXPos(float x_ratio) {  float result;  if (team.position=back) {   result <- 90-x_ratio*90;  }  else {   result <- x_ratio*90;  }  return result; }  // this function returns the real y if we pass a percentage : 0 is the extreme defensive point, 100 is the extreme attack point. float getYPos(float y_ratio) {  float result;  if (team.position=back) {   result <- y_ratio*120;  }  else {   result <- 120-y_ratio*120;  }  return result; }  ///////////////////////////////////////////////////////  // The update function, calls the adequate behavior reflex update when:cycle>1 {  do apply_inertia;  // verify if it is a non-offside position  if ( (((team.position = back) and (location.y > team.offside_pos))   or ((team.position = front) and (location.y < team.offside_pos)))    and (!possess_ball) and (self != team.called_player)  ) {   // offside position, go back to a correct position   point target_pos <- {location.x,(team.position = back) ? location.y-current_speed:location.y+current_speed};   do run_to(target_pos);   status <- offside position !;  }  else if ((distance_to_ball < 2) and !possess_ball) {   do try_to_take_ball;  }  else if (game.team_possession = team) {   do offensive_behavior;  }  else {   do defensive_behavior;  } }  // defensive behavior, need to be redefined in the strategy file. // this action is called when the last player who was holding the ball was a player of the ennemy team action defensive_behavior virtual:true {   } // defensive behavior, need to be redefined in the strategy file. // this action is called when the last player who was holding the ball was a player of this team action offensive_behavior virtual:true {   }   // ASPECT //////////////////////////////////////////////////////// aspect player {  // the player wich possess the ball is displayed with a square. It is displayed with a circle otherwise.  if (possess_ball) {   draw square(2) color:(team.position = back) ? game.back_color_team : game.front_color_team;  }  else {   draw circle(1) color:(team.position = back) ? game.back_color_team : game.front_color_team;  } } }   species base_team {  // ATTRIBUTES ////////////////////////////////////////////////  // ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE float offside_pos <- 0.0 update: (position = back) ? max((game.players where (each.team != self)) collect (each.location.y))  : min((game.players where (each.team != self)) collect (each.location.y));  // ATTRIBUTES USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !) string position; // can be front or back. list<base_player> players; // all the players of the team. soccer_game game;  base_player closest_player_to_ball <- first(players) update: first( players where (each distance_to each.ball = min (players collect (each distance_to each.ball) ) ) ); base_player called_player; bool possess_ball <- false;// update: ! empty ( players where (each.possess_ball=true) ); base_player player_with_ball <- nil;// update: first(players where (each.possess_ball = true));  // ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRATEGY FILE list<point> player_init_position; }   species ball_sp skills:[moving] {  // The ball agent.  float speed <- 0.0;  geometry ball_direction; // the direction of the ball is used to be followed by the player  reflex update {   speed <- speed0.95;   float future_speed <- speed;   point tmpPos<-location;   loop i from:0 to:10 {    tmpPos <- {tmpPos.x+cos(heading)speed,tmpPos.y+sin(heading)speed};    future_speed <- future_speed0.9;   }   ball_direction <- line([location,tmpPos]);   do wander amplitude:1;   // anticipation of the ball position to detect a goal  if ((location.y+sin(heading)*speed) > 120) {   write back team score a goal !!;   ask first(soccer_game) {    do reinit_phase;   }  }  if ((location.y+sin(heading)*speed) < 0) {   write front team score a goal !!;   ask first(soccer_game) {    do reinit_phase;   }  } } action shooted (point target_position, float speed_atr) {  // action called when a player shoots the ball  speed <- speed_atr;  do goto target:target_position; }  aspect ball {  draw circle(0.5) color:#white; } }   species goal_sp {  string position; // can be  front  or  back .  init {  create goal_keeper with:[position::position]; }  aspect goal {  draw rectangle(7.32,1.0) color:#black; } }   species goal_keeper {  // the goal has a basic behavior : he tries to catch the ball when it is close enough, and when   string position; // can be  front  or  back .  ball_sp ball <- nil update:first(ball_sp);  reflex update when:cycle>0 {  location <- {ball.location.x/90*12+(90-12)/2,location.y};  if (ball distance_to self < 2) {   if (flip(1/(1+2*ball.speed))) {    first(soccer_game).team_possession <- first(first(soccer_game).teams where (each.position = position));    ask ball {     do shooted ({30+rnd(30),60},5.0);    }   }  } }  init {  location <- {45,(position=front) ? 117 : 3}; }  action offensive_behavior { }  action defensive_behavior { }  aspect goal_keeper {  draw circle(1) color:(position = back) ? first(soccer_game).back_color_team : first(soccer_game).front_color_team; } }            model team1strategy  import  ./soccer_base.gaml   species player_intelligentTeam parent:base_player {  // READ ONLY ATTRIBUTES :  // position : can be  front  or  back .  // players : list of all the players of the team.  // game  //closest_player_to_ball  // called_player : the player called for a pass  // possess_ball : true or false  // player_with_ball : player currently with the ball  // READ AND WRITE ATTRIBUTES : // position_mark // status : the current status of the player (can be useful to build the model) // influence_area : the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.  float position_mark <- 0.0 update: location.y - 20*number_of_ennemy_player_in_range + self.distance_to_closest_ennemy_player;  string role; // a value between defense, mid and attack. string wing; // a value between left, center and right. geometry influence_area <- circle(15,init_pos);  float defense_mid_pos <- 30.0; // the y percent chosed to separate the defense from the mid position. float mid_attack_pos <- 60.0; // the y percent chosen to separate the mid from the attack position.  init {  // set the role of the player (between defense, mid and attack).  if ( init_pos_in_percent.y < defense_mid_pos ) {   role <- defense;  }  else if ( (init_pos_in_percent.y > mid_attack_pos ) ) {   role <- attack;  }  else {   role <- mid;  }  // set the wing of the player (between left, center and right)  if ( init_pos_in_percent.x < 40 ) {   wing <- left;  }  else if ( init_pos_in_percent.x > 60 ) {   wing <- right;  }  else {   wing <- center;  } }  action update_influence_area {  status <- wing +   + role;  float y_ratio;  if (role = defense) { // defense position from 0% to 70% from the own goal, multiplied by the percentage of advancement of the ball   y_ratio <- 0.7 * ball_advancement;  }  if (role = mid) { // mid position from 15% to 85% from the own goal, multiplied by the percentage of advancement of the ball   y_ratio <- 0.15 + 0.7 * ball_advancement;  }  if (role = attack) { // attack position from 30% to 100% from the own goal, multiplied by the percentage of advancement of the ball   y_ratio <- 0.3 + 0.7 * ball_advancement;  }  float x_ratio;  if (wing = center) {   x_ratio <- 0.5;  }  else if (wing = left) {   x_ratio <- 0.5 - 0.3 * cos( (y_ratio-0.5)*120 ); // the side wings are more marked if the player is in the center of the field.  }  else {   x_ratio <- 0.5 + 0.3 * cos( (y_ratio-0.5)*120 );  }  influence_area <- circle(15,{getXPos(x_ratio),getYPos(y_ratio)}); }  action defensive_behavior {   do update_influence_area;  // advanced defensive behavior  // run to the ball if the player is the closest player from the ball.  if ((self = team.closest_player_to_ball) or (self distance_to ball < 5)) {   status <- getStatus(run to ball);   do run_to_ball;  }  else {   // if there is an ennemy player in the influence area, mark the player.   if ( length(self.ennemy_team.players where (each intersects influence_area)) != 0 ) {    base_player marked_player <- first(1 among (self.ennemy_team.players where (each intersects influence_area)));    status <- getStatus(mark player +marked_player);    do mark_player( marked_player );   }   // if there is no ennemy player in the influence area, stay in influence area.   else {    status <- getStatus(run to influence area);    do run_to(influence_area.location);   }  } }  action offensive_behavior {   do update_influence_area;  // advanced offensive behavior  if (possess_ball) {   // if the player has the ball and is close enough to the ennemy goal, shoot.   if (distance_to_goal < 35 and flip(1/(0.1+(self.distance_to_goal/10)^2))) {    status <- getStatus(shoot the ball);    do shoot;   }   // if the player has the ball and is in a safe position, run to the ennemy goal.   else if ( (position_mark = max( team.players collect (each.position_mark) )) or (distance_to_closest_ennemy_player > 2) )   {    status <- getStatus(run to ennemy goal);    do run_to_ennemy_goal;   }   // if the player has the ball but is in a dangerous situation, pass the ball to another player.   else {    base_player target_player <- first(team.players where (each.position_mark = max( team.players collect (each.position_mark)) ) );    status <- getStatus(pass the ball to +target_player);    do pass_the_ball_ahead ( target_player,10.0 );   }  }  // if the player has not the ball but is the called player, run to the ball.  else if (self = team.called_player) {   status <- getStatus(run to ball);   do run_to_ball;   status <- called player;  }  // else, run to influence area.  else {   status <- getStatus(run to influence area);   do run_to(influence_area.location);  } }  string getStatus(string str) {  return wing +   + role + | action :  + str; }   }  species intelligentTeam parent:base_team {  // READ ONLY ATTRIBUTES :  // position : can be  front  or  back .  // players : list of all the players of the team.  // game.  // closest_player_to_ball.  // called_player : the player called for a pass.  // possess_ball : true when a player of the team possess the ball.  // player_with_ball  // READ AND WRITE ATTRIBUTES : // player_init_position  // initial position of the player in percentage : for each point, //    the first value corresponds to the percentage from left to right (0 for the point the most in the left side) //    the second value corresponds to the percentage from the goal position to the mid position (0 for the goal position) list<point> player_init_position <- [{20,20},{50,20},{80,20},{30,50},{70,50},{50,70},{30,90},{50,90},{70,90}]; }        Code of the model :       model soccerexpe  // import the 2 strategies import  ./team1_strategy.gaml  import  ./team2_strategy.gaml   global {  // set the size of the environment  geometry shape <- rectangle(90#m,120#m);  bool show_info <- false;  rgb back_color_team <- #blue; rgb front_color_team <- #red; }   species info_player1 mirrors:player_intelligentTeam {  // mirror species that shows additionnal information about the player  point location <- target.location update:target.location;  string status <- target.status update:target.status;  float speed <- target.speed update:target.speed;  geometry influence_area <- target.influence_area update:target.influence_area;  aspect info {   if (show_info) {    draw status color:#black;    draw influence_area color:rgb(200,200,255,0) border:rgb(200,200,255,255);   }  } }  species info_player2 mirrors:player_stupidTeam {  // mirror species that shows additionnal information about the player  point location <- target.location update:target.location;  string status <- target.status update:target.status;  float speed <- target.speed update:target.speed;  geometry influence_area <- target.influence_area update:target.influence_area;  aspect info {   if (show_info) {    draw status color:#black;    draw influence_area color:rgb(255,200,200,0) border:rgb(255,200,200,255);   }  } }  experiment intelligentTeam_vs_stupidTeam type:gui {  init {   // instantialization of the game (contains global information about the game)   create soccer_game with:(back_color_team::back_color_team,front_color_team::front_color_team) returns:soccerGame;   // instantialization of the teams   create intelligentTeam with:(game:first(soccerGame),position: back );   create stupidTeam with:(game:first(soccerGame),position: front );   add first(intelligentTeam) to:first(soccerGame).teams;   add first(stupidTeam) to:first(soccerGame).teams;   // create players of the team1   list player_list1;   loop pos over:first(intelligentTeam).player_init_position {    // compute the real position of each player according to the percentage given in player_init_position    point real_pos <- (first(intelligentTeam).position = back) ? {90-pos.x/100*90,pos.y/100*60} : {pos.x/100*90,120-pos.y/100*60};    create player_intelligentTeam with:(team:first(intelligentTeam),game:first(intelligentTeam).game,location:real_pos,init_pos_in_percent:pos) returns:pl;    add first(pl) to:player_list1;   }   first(intelligentTeam).players <- player_list1;   // create players of the team2   list player_list2;   loop pos over:first(stupidTeam).player_init_position {    // compute the real position of each player according to the percentage given in player_init_position    point real_pos <- (first(stupidTeam).position = back) ? {90-pos.x/100*90,pos.y/100*60} : {pos.x/100*90,120-pos.y/100*60};    create player_stupidTeam with:(team:first(stupidTeam),game:first(stupidTeam).game,location:real_pos,init_pos_in_percent:pos) returns:pl;    add first(pl) to:player_list2;   }   first(stupidTeam).players <- player_list2;   first(soccerGame).players <- player_list1+player_list2;  }  parameter show player info var:show_info;  output {   display soccer_field  {    // display the field.    image ../images/soccer_field2.png;    // display the species with their correct aspect    species player_intelligentTeam aspect:player;    species player_stupidTeam aspect:player;    species ball_sp aspect:ball;    species goal_sp aspect:goal;    species goal_keeper aspect:goal_keeper;    species info_player1 aspect:info;    species info_player2 aspect:info;   }  } }  experiment intelligentTeam_vs_intelligentTeam type:gui {  init {   // instantialization of the game (contains global information about the game)   create soccer_game with:(back_color_team::back_color_team,front_color_team::front_color_team) returns:soccerGame;   // instantialization of the teams   create intelligentTeam with:(game:first(soccerGame),position: back ) returns:backTeam;   create intelligentTeam with:(game:first(soccerGame),position: front ) returns:frontTeam;   add first(backTeam) to:first(soccerGame).teams;  add first(frontTeam) to:first(soccerGame).teams;  // create players of the team1  list<player_intelligentTeam> player_list1;  loop pos over:first(backTeam).player_init_position {   // compute the real position of each player according to the percentage given in player_init_position   point real_pos <- (first(backTeam).position = back) ? {90-pos.x/100*90,pos.y/100*60} : {pos.x/100*90,120-pos.y/100*60};   create player_intelligentTeam with:(team:first(backTeam),game:first(backTeam).game,location:real_pos,init_pos_in_percent:pos) returns:pl;   add first(pl) to:player_list1;  }  first(backTeam).players <- player_list1;  // create players of the team2  list<player_intelligentTeam> player_list2;  loop pos over:first(frontTeam).player_init_position {   // compute the real position of each player according to the percentage given in player_init_position   point real_pos <- (first(frontTeam).position = back) ? {90-pos.x/100*90,pos.y/100*60} : {pos.x/100*90,120-pos.y/100*60};   create player_intelligentTeam with:(team:first(frontTeam),game:first(frontTeam).game,location:real_pos,init_pos_in_percent:pos) returns:pl;   add first(pl) to:player_list2;  }  first(frontTeam).players <- player_list2;  first(soccerGame).players <- player_list1+player_list2; } parameter show player info var:show_info; output {  display soccer_field  {   // display the field.   image ../images/soccer_field2.png;   // display the species with their correct aspect   species player_intelligentTeam aspect:player;   species ball_sp aspect:ball;   species goal_sp aspect:goal;   species goal_keeper aspect:goal_keeper;   species info_player1 aspect:info;   species info_player2 aspect:info;  } } }      ","url":"wiki/Soccer-soccer_expe.md"},{"id":"wiki/Soccer-team1_strategy.md","title":" _team1strategy","content":"# _team1strategy  Author : Julien  This model contains one of the 2 team strategy. This strategy is quite advanced, attributing role for each player, with a custom influence_area and a custom position_mark.  Imported model :       model soccerbase  species soccer_game {  // contains the global informations of the game  rgb back_color_team;  rgb front_color_team;  ball_sp ball; // the ball agent goal_sp front_goal; // contains the goal at the front of the field (y = 120) goal_sp back_goal; // contains the goal at the back of the field (y = 0) list<base_team> teams; // contains the 2 teams list<base_player> players; // contains all the players of the game  base_team team_possession; // the last team which possess the ball. This value is used to determine if the behavior of the team has to be defensive or offensive.  init {  // create the entities ball and the 2 goals  create ball_sp with:[location::world.location] returns:var_ball;  ball <- first(var_ball);  create goal_sp with:[location::{world.location.x,120},position::front] returns:var_goal1;  front_goal <- first(var_goal1);  create goal_sp with:[location::{world.location.x,0},position::back] returns:var_goal2;  back_goal <- first(var_goal2); }  action reinit_phase {  // this action is called when a goal has been scored : the players are placed with their initial position, and the ball is reset to the center  ask players {   location <- init_pos;   previous_pos <- init_pos;  }  ball.location <- world.location;  ball.destination <- world.location;  ball.speed <- 0.0; } }   species base_player skills:[moving] {  // ATTRIBUTES ////////////////////////////////////////////////  // ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE float recuperation_ability <- 0.2; // a mark from 0 to 1 to be able to catch the ball if another player has it float speed_without_ball; float speed_with_ball; point previous_pos; // used to apply inertia bool displacement_effectued<-false update:false; // we can apply only one displacement by step !  // ATTRIBUTE USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !) base_team team; soccer_game game; base_team ennemy_team <- nil update:first(game.teams where (each.position != team.position)); ball_sp ball <- nil update:first(ball_sp); goal_sp own_goal <- nil update:first(goal_sp where (each.position = team.position)); goal_sp ennemy_goal <- nil update:first(goal_sp where (each.position != team.position)); // ratio of avancement of the ball (from the point of view of the current team) float ball_advancement <- 0.0 update:(team.position = back) ? ball.location.y / 120 : 1 - ball.location.y / 120;  bool possess_ball; point init_pos; point init_pos_in_percent; float distance_to_closest_ennemy_player <- 100.0 update:self distance_to closest_ennemy_player; // the number of ennemy players in a range of 15 meters int number_of_ennemy_player_in_range <- 0 update:length((game.players where (each.team != team)) where ((each intersects circle(15))=true)); float distance_to_ball <- 100.0 update:(ball = nil) ? 100.0 : self distance_to ball; float distance_to_goal <- 100.0 update:(ennemy_goal = nil) ? 100.0 : self distance_to ennemy_goal; // the closest player of this team base_player closest_friend_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team = team and each != self))   where (each distance_to self = min( (game.players where (each.team = team and each != self)) collect (each distance_to self) ) )  ); // the closest ennemy player base_player closest_ennemy_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team != team and each != self))   where (each distance_to self = min( (game.players where (each.team != team and each != self)) collect (each distance_to self) ) )  ); // the player of this team wich has the best position_mark base_player best_position_player <- nil update:first((team.players where (each != self))   where (each.position_mark = max((team.players where (each != self)) collect (each.position_mark))) ); float current_speed<-1.0 update:(possess_ball) ? speed_with_ball : speed_without_ball;  // ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRAGEGY FILE float position_mark <- 0.0 update:-distance_to_goal; // a mark attributed according to the position of the player (the higher the note is, the best the position is).  // By default, this mark is equal to -distance_to_goal. string status <- ; // the current status of the player (can be useful to build the model) geometry influence_area <- nil update:circle(15); // the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.   // CONSTRUCTOR ///////////////////////////////////////////// init {  init_pos <- location;  previous_pos <- location;  possess_ball <- false;  speed_with_ball <- 0.4;  speed_without_ball <- 0.5; }  // ACTIONS ////////////////////////////////////////////////////  // ACTIONS TO CALL FROM THE STRATEGY FILE // action to run to a particular position action run_to(point target) {  if (!displacement_effectued) {    do goto target:target speed:current_speed;   if (possess_ball) {    ball.location <- location;   }   displacement_effectued <- true;  }  else {   write WARNING : only ONE action of displacement is allowed each step;  } }  // action to run to the ball action run_to_ball {  point targetPos;  if (ball.ball_direction intersects circle(1)) {   targetPos <- ball.location;  }  else {   targetPos <- (ball.ball_direction closest_points_with self) at 0;  }  do run_to(targetPos); }  // action to run to the ennemy goal action run_to_ennemy_goal {  do run_to( ennemy_goal.location ); }  // action to run to its own goal action run_to_own_goal {  do run_to( own_goal.location ); }  // action to mark a player action mark_player (base_player player) {  float rnd_area <- 4.0; // the player will choose a position in a square of rnd_area m.  point pos <- (team.position = front) ? {player.location.x,player.location.y-rnd_area/2} : {player.location.x,player.location.y+rnd_area/2};  do run_to( {pos.x-rnd_area/2+rnd(rnd_area),pos.y-rnd_area/2+rnd(rnd_area)} ); }  // action ot shoot the ball to the ennemy goal action shoot {  do loose_ball;  ask ball {   do shooted speed_atr:3.0 target_position:myself.ennemy_goal.location;  } }  // action to pass the ball to an ally action pass_the_ball (base_player target_player) {  do loose_ball;  ask ball {   do shooted target_position:target_player.location speed_atr:target_player.distance_to_ball/15;  }  team.called_player <- target_player; }  // action to pass the ball to an ally action pass_the_ball_ahead (base_player target_player,float number_of_meter_ahead) {  do loose_ball;  ask ball {   float offset <- ((myself.team.position = back) ? number_of_meter_ahead : -number_of_meter_ahead);   point target_point <- {target_player.location.x,target_player.location.y+offset};   do shooted target_position:target_point speed_atr:target_player.distance_to_ball/15;  }  team.called_player <- target_player; }  // ACTION AUTOMATICALLY CALLED IN THE BASE CLASSE // try to take the ball if it is close enough action try_to_take_ball {  // if no player has the ball  if (!team.possess_ball and !ennemy_team.possess_ball) {   // if the player is the one called (result of a pass)   if (team.called_player = self) {    do take_ball;   }   // if the player is not the one called (interception of the ball), probability to catch the ball inversly proportionnal with the speed of the ball   else {    if (flip(1/(1+2*ball.speed))) {     do take_ball;    }   }  }  // the ball is possessed by the ennemy team  else if (ennemy_team.possess_ball) {   // try to catch the ball from the other player   if flip(recuperation_ability) {    do take_ball;   }  } }  // action of taking the ball action take_ball {  if (ennemy_team.possess_ball) {   ask ennemy_team.player_with_ball {    do loose_ball;   }  }  possess_ball <- true;  ball.speed <- 0.0;  ball.destination <- ball.location;  team.called_player <- nil;  team.player_with_ball <- self;  team.possess_ball <- true;  game.team_possession <- team; }  // action of loosing the ball action loose_ball {  possess_ball <- false;  team.player_with_ball <- nil;  team.possess_ball <- false; }  // apply the inertia action apply_inertia {  point prev_pos <- location;  point inertia_vect <- {(location.x-previous_pos.x)*0.7,(location.y-previous_pos.y)*0.7};  float max_inertia <- current_speed;  if (norm(inertia_vect) > max_inertia) {   float inertia_x <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));   float inertia_y <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));   inertia_x <- (inertia_vect.x < 0) ? -inertia_x : inertia_x;   inertia_y <- (inertia_vect.y < 0) ? -inertia_y : inertia_y;   inertia_vect <- {inertia_x,inertia_y};  }  location <- location + inertia_vect;  previous_pos <- prev_pos; }  // useful functions // this function returns the real x if we pass a percentage : 0 is the extreme left point, 100 is the extreme right point. float getXPos(float x_ratio) {  float result;  if (team.position=back) {   result <- 90-x_ratio*90;  }  else {   result <- x_ratio*90;  }  return result; }  // this function returns the real y if we pass a percentage : 0 is the extreme defensive point, 100 is the extreme attack point. float getYPos(float y_ratio) {  float result;  if (team.position=back) {   result <- y_ratio*120;  }  else {   result <- 120-y_ratio*120;  }  return result; }  ///////////////////////////////////////////////////////  // The update function, calls the adequate behavior reflex update when:cycle>1 {  do apply_inertia;  // verify if it is a non-offside position  if ( (((team.position = back) and (location.y > team.offside_pos))   or ((team.position = front) and (location.y < team.offside_pos)))    and (!possess_ball) and (self != team.called_player)  ) {   // offside position, go back to a correct position   point target_pos <- {location.x,(team.position = back) ? location.y-current_speed:location.y+current_speed};   do run_to(target_pos);   status <- offside position !;  }  else if ((distance_to_ball < 2) and !possess_ball) {   do try_to_take_ball;  }  else if (game.team_possession = team) {   do offensive_behavior;  }  else {   do defensive_behavior;  } }  // defensive behavior, need to be redefined in the strategy file. // this action is called when the last player who was holding the ball was a player of the ennemy team action defensive_behavior virtual:true {   } // defensive behavior, need to be redefined in the strategy file. // this action is called when the last player who was holding the ball was a player of this team action offensive_behavior virtual:true {   }   // ASPECT //////////////////////////////////////////////////////// aspect player {  // the player wich possess the ball is displayed with a square. It is displayed with a circle otherwise.  if (possess_ball) {   draw square(2) color:(team.position = back) ? game.back_color_team : game.front_color_team;  }  else {   draw circle(1) color:(team.position = back) ? game.back_color_team : game.front_color_team;  } } }   species base_team {  // ATTRIBUTES ////////////////////////////////////////////////  // ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE float offside_pos <- 0.0 update: (position = back) ? max((game.players where (each.team != self)) collect (each.location.y))  : min((game.players where (each.team != self)) collect (each.location.y));  // ATTRIBUTES USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !) string position; // can be front or back. list<base_player> players; // all the players of the team. soccer_game game;  base_player closest_player_to_ball <- first(players) update: first( players where (each distance_to each.ball = min (players collect (each distance_to each.ball) ) ) ); base_player called_player; bool possess_ball <- false;// update: ! empty ( players where (each.possess_ball=true) ); base_player player_with_ball <- nil;// update: first(players where (each.possess_ball = true));  // ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRATEGY FILE list<point> player_init_position; }   species ball_sp skills:[moving] {  // The ball agent.  float speed <- 0.0;  geometry ball_direction; // the direction of the ball is used to be followed by the player  reflex update {   speed <- speed0.95;   float future_speed <- speed;   point tmpPos<-location;   loop i from:0 to:10 {    tmpPos <- {tmpPos.x+cos(heading)speed,tmpPos.y+sin(heading)speed};    future_speed <- future_speed0.9;   }   ball_direction <- line([location,tmpPos]);   do wander amplitude:1;   // anticipation of the ball position to detect a goal  if ((location.y+sin(heading)*speed) > 120) {   write back team score a goal !!;   ask first(soccer_game) {    do reinit_phase;   }  }  if ((location.y+sin(heading)*speed) < 0) {   write front team score a goal !!;   ask first(soccer_game) {    do reinit_phase;   }  } } action shooted (point target_position, float speed_atr) {  // action called when a player shoots the ball  speed <- speed_atr;  do goto target:target_position; }  aspect ball {  draw circle(0.5) color:#white; } }   species goal_sp {  string position; // can be  front  or  back .  init {  create goal_keeper with:[position::position]; }  aspect goal {  draw rectangle(7.32,1.0) color:#black; } }   species goal_keeper {  // the goal has a basic behavior : he tries to catch the ball when it is close enough, and when   string position; // can be  front  or  back .  ball_sp ball <- nil update:first(ball_sp);  reflex update when:cycle>0 {  location <- {ball.location.x/90*12+(90-12)/2,location.y};  if (ball distance_to self < 2) {   if (flip(1/(1+2*ball.speed))) {    first(soccer_game).team_possession <- first(first(soccer_game).teams where (each.position = position));    ask ball {     do shooted ({30+rnd(30),60},5.0);    }   }  } }  init {  location <- {45,(position=front) ? 117 : 3}; }  action offensive_behavior { }  action defensive_behavior { }  aspect goal_keeper {  draw circle(1) color:(position = back) ? first(soccer_game).back_color_team : first(soccer_game).front_color_team; } }       Code of the model :       model team1strategy  import  ./soccer_base.gaml   species player_intelligentTeam parent:base_player {  // READ ONLY ATTRIBUTES :  // position : can be  front  or  back .  // players : list of all the players of the team.  // game  //closest_player_to_ball  // called_player : the player called for a pass  // possess_ball : true or false  // player_with_ball : player currently with the ball  // READ AND WRITE ATTRIBUTES : // position_mark // status : the current status of the player (can be useful to build the model) // influence_area : the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.  float position_mark <- 0.0 update: location.y - 20*number_of_ennemy_player_in_range + self.distance_to_closest_ennemy_player;  string role; // a value between defense, mid and attack. string wing; // a value between left, center and right. geometry influence_area <- circle(15,init_pos);  float defense_mid_pos <- 30.0; // the y percent chosed to separate the defense from the mid position. float mid_attack_pos <- 60.0; // the y percent chosen to separate the mid from the attack position.  init {  // set the role of the player (between defense, mid and attack).  if ( init_pos_in_percent.y < defense_mid_pos ) {   role <- defense;  }  else if ( (init_pos_in_percent.y > mid_attack_pos ) ) {   role <- attack;  }  else {   role <- mid;  }  // set the wing of the player (between left, center and right)  if ( init_pos_in_percent.x < 40 ) {   wing <- left;  }  else if ( init_pos_in_percent.x > 60 ) {   wing <- right;  }  else {   wing <- center;  } }  action update_influence_area {  status <- wing +   + role;  float y_ratio;  if (role = defense) { // defense position from 0% to 70% from the own goal, multiplied by the percentage of advancement of the ball   y_ratio <- 0.7 * ball_advancement;  }  if (role = mid) { // mid position from 15% to 85% from the own goal, multiplied by the percentage of advancement of the ball   y_ratio <- 0.15 + 0.7 * ball_advancement;  }  if (role = attack) { // attack position from 30% to 100% from the own goal, multiplied by the percentage of advancement of the ball   y_ratio <- 0.3 + 0.7 * ball_advancement;  }  float x_ratio;  if (wing = center) {   x_ratio <- 0.5;  }  else if (wing = left) {   x_ratio <- 0.5 - 0.3 * cos( (y_ratio-0.5)*120 ); // the side wings are more marked if the player is in the center of the field.  }  else {   x_ratio <- 0.5 + 0.3 * cos( (y_ratio-0.5)*120 );  }  influence_area <- circle(15,{getXPos(x_ratio),getYPos(y_ratio)}); }  action defensive_behavior {   do update_influence_area;  // advanced defensive behavior  // run to the ball if the player is the closest player from the ball.  if ((self = team.closest_player_to_ball) or (self distance_to ball < 5)) {   status <- getStatus(run to ball);   do run_to_ball;  }  else {   // if there is an ennemy player in the influence area, mark the player.   if ( length(self.ennemy_team.players where (each intersects influence_area)) != 0 ) {    base_player marked_player <- first(1 among (self.ennemy_team.players where (each intersects influence_area)));    status <- getStatus(mark player +marked_player);    do mark_player( marked_player );   }   // if there is no ennemy player in the influence area, stay in influence area.   else {    status <- getStatus(run to influence area);    do run_to(influence_area.location);   }  } }  action offensive_behavior {   do update_influence_area;  // advanced offensive behavior  if (possess_ball) {   // if the player has the ball and is close enough to the ennemy goal, shoot.   if (distance_to_goal < 35 and flip(1/(0.1+(self.distance_to_goal/10)^2))) {    status <- getStatus(shoot the ball);    do shoot;   }   // if the player has the ball and is in a safe position, run to the ennemy goal.   else if ( (position_mark = max( team.players collect (each.position_mark) )) or (distance_to_closest_ennemy_player > 2) )   {    status <- getStatus(run to ennemy goal);    do run_to_ennemy_goal;   }   // if the player has the ball but is in a dangerous situation, pass the ball to another player.   else {    base_player target_player <- first(team.players where (each.position_mark = max( team.players collect (each.position_mark)) ) );    status <- getStatus(pass the ball to +target_player);    do pass_the_ball_ahead ( target_player,10.0 );   }  }  // if the player has not the ball but is the called player, run to the ball.  else if (self = team.called_player) {   status <- getStatus(run to ball);   do run_to_ball;   status <- called player;  }  // else, run to influence area.  else {   status <- getStatus(run to influence area);   do run_to(influence_area.location);  } }  string getStatus(string str) {  return wing +   + role + | action :  + str; }   }  species intelligentTeam parent:base_team {  // READ ONLY ATTRIBUTES :  // position : can be  front  or  back .  // players : list of all the players of the team.  // game.  // closest_player_to_ball.  // called_player : the player called for a pass.  // possess_ball : true when a player of the team possess the ball.  // player_with_ball  // READ AND WRITE ATTRIBUTES : // player_init_position  // initial position of the player in percentage : for each point, //    the first value corresponds to the percentage from left to right (0 for the point the most in the left side) //    the second value corresponds to the percentage from the goal position to the mid position (0 for the goal position) list<point> player_init_position <- [{20,20},{50,20},{80,20},{30,50},{70,50},{50,70},{30,90},{50,90},{70,90}]; }       ","url":"wiki/Soccer-team1_strategy.md"},{"id":"wiki/Soccer-team2_strategy.md","title":" _team2strategy","content":"# _team2strategy  Author : Julien  This model contains one of the 2 team strategy. This strategy is very stupid : when you have the ball, run to the ennemy goal, else run to the ball  Imported model :       model soccerbase  species soccer_game {  // contains the global informations of the game  rgb back_color_team;  rgb front_color_team;  ball_sp ball; // the ball agent goal_sp front_goal; // contains the goal at the front of the field (y = 120) goal_sp back_goal; // contains the goal at the back of the field (y = 0) list<base_team> teams; // contains the 2 teams list<base_player> players; // contains all the players of the game  base_team team_possession; // the last team which possess the ball. This value is used to determine if the behavior of the team has to be defensive or offensive.  init {  // create the entities ball and the 2 goals  create ball_sp with:[location::world.location] returns:var_ball;  ball <- first(var_ball);  create goal_sp with:[location::{world.location.x,120},position::front] returns:var_goal1;  front_goal <- first(var_goal1);  create goal_sp with:[location::{world.location.x,0},position::back] returns:var_goal2;  back_goal <- first(var_goal2); }  action reinit_phase {  // this action is called when a goal has been scored : the players are placed with their initial position, and the ball is reset to the center  ask players {   location <- init_pos;   previous_pos <- init_pos;  }  ball.location <- world.location;  ball.destination <- world.location;  ball.speed <- 0.0; } }   species base_player skills:[moving] {  // ATTRIBUTES ////////////////////////////////////////////////  // ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE float recuperation_ability <- 0.2; // a mark from 0 to 1 to be able to catch the ball if another player has it float speed_without_ball; float speed_with_ball; point previous_pos; // used to apply inertia bool displacement_effectued<-false update:false; // we can apply only one displacement by step !  // ATTRIBUTE USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !) base_team team; soccer_game game; base_team ennemy_team <- nil update:first(game.teams where (each.position != team.position)); ball_sp ball <- nil update:first(ball_sp); goal_sp own_goal <- nil update:first(goal_sp where (each.position = team.position)); goal_sp ennemy_goal <- nil update:first(goal_sp where (each.position != team.position)); // ratio of avancement of the ball (from the point of view of the current team) float ball_advancement <- 0.0 update:(team.position = back) ? ball.location.y / 120 : 1 - ball.location.y / 120;  bool possess_ball; point init_pos; point init_pos_in_percent; float distance_to_closest_ennemy_player <- 100.0 update:self distance_to closest_ennemy_player; // the number of ennemy players in a range of 15 meters int number_of_ennemy_player_in_range <- 0 update:length((game.players where (each.team != team)) where ((each intersects circle(15))=true)); float distance_to_ball <- 100.0 update:(ball = nil) ? 100.0 : self distance_to ball; float distance_to_goal <- 100.0 update:(ennemy_goal = nil) ? 100.0 : self distance_to ennemy_goal; // the closest player of this team base_player closest_friend_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team = team and each != self))   where (each distance_to self = min( (game.players where (each.team = team and each != self)) collect (each distance_to self) ) )  ); // the closest ennemy player base_player closest_ennemy_player <- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team != team and each != self))   where (each distance_to self = min( (game.players where (each.team != team and each != self)) collect (each distance_to self) ) )  ); // the player of this team wich has the best position_mark base_player best_position_player <- nil update:first((team.players where (each != self))   where (each.position_mark = max((team.players where (each != self)) collect (each.position_mark))) ); float current_speed<-1.0 update:(possess_ball) ? speed_with_ball : speed_without_ball;  // ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRAGEGY FILE float position_mark <- 0.0 update:-distance_to_goal; // a mark attributed according to the position of the player (the higher the note is, the best the position is).  // By default, this mark is equal to -distance_to_goal. string status <- ; // the current status of the player (can be useful to build the model) geometry influence_area <- nil update:circle(15); // the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.   // CONSTRUCTOR ///////////////////////////////////////////// init {  init_pos <- location;  previous_pos <- location;  possess_ball <- false;  speed_with_ball <- 0.4;  speed_without_ball <- 0.5; }  // ACTIONS ////////////////////////////////////////////////////  // ACTIONS TO CALL FROM THE STRATEGY FILE // action to run to a particular position action run_to(point target) {  if (!displacement_effectued) {    do goto target:target speed:current_speed;   if (possess_ball) {    ball.location <- location;   }   displacement_effectued <- true;  }  else {   write WARNING : only ONE action of displacement is allowed each step;  } }  // action to run to the ball action run_to_ball {  point targetPos;  if (ball.ball_direction intersects circle(1)) {   targetPos <- ball.location;  }  else {   targetPos <- (ball.ball_direction closest_points_with self) at 0;  }  do run_to(targetPos); }  // action to run to the ennemy goal action run_to_ennemy_goal {  do run_to( ennemy_goal.location ); }  // action to run to its own goal action run_to_own_goal {  do run_to( own_goal.location ); }  // action to mark a player action mark_player (base_player player) {  float rnd_area <- 4.0; // the player will choose a position in a square of rnd_area m.  point pos <- (team.position = front) ? {player.location.x,player.location.y-rnd_area/2} : {player.location.x,player.location.y+rnd_area/2};  do run_to( {pos.x-rnd_area/2+rnd(rnd_area),pos.y-rnd_area/2+rnd(rnd_area)} ); }  // action ot shoot the ball to the ennemy goal action shoot {  do loose_ball;  ask ball {   do shooted speed_atr:3.0 target_position:myself.ennemy_goal.location;  } }  // action to pass the ball to an ally action pass_the_ball (base_player target_player) {  do loose_ball;  ask ball {   do shooted target_position:target_player.location speed_atr:target_player.distance_to_ball/15;  }  team.called_player <- target_player; }  // action to pass the ball to an ally action pass_the_ball_ahead (base_player target_player,float number_of_meter_ahead) {  do loose_ball;  ask ball {   float offset <- ((myself.team.position = back) ? number_of_meter_ahead : -number_of_meter_ahead);   point target_point <- {target_player.location.x,target_player.location.y+offset};   do shooted target_position:target_point speed_atr:target_player.distance_to_ball/15;  }  team.called_player <- target_player; }  // ACTION AUTOMATICALLY CALLED IN THE BASE CLASSE // try to take the ball if it is close enough action try_to_take_ball {  // if no player has the ball  if (!team.possess_ball and !ennemy_team.possess_ball) {   // if the player is the one called (result of a pass)   if (team.called_player = self) {    do take_ball;   }   // if the player is not the one called (interception of the ball), probability to catch the ball inversly proportionnal with the speed of the ball   else {    if (flip(1/(1+2*ball.speed))) {     do take_ball;    }   }  }  // the ball is possessed by the ennemy team  else if (ennemy_team.possess_ball) {   // try to catch the ball from the other player   if flip(recuperation_ability) {    do take_ball;   }  } }  // action of taking the ball action take_ball {  if (ennemy_team.possess_ball) {   ask ennemy_team.player_with_ball {    do loose_ball;   }  }  possess_ball <- true;  ball.speed <- 0.0;  ball.destination <- ball.location;  team.called_player <- nil;  team.player_with_ball <- self;  team.possess_ball <- true;  game.team_possession <- team; }  // action of loosing the ball action loose_ball {  possess_ball <- false;  team.player_with_ball <- nil;  team.possess_ball <- false; }  // apply the inertia action apply_inertia {  point prev_pos <- location;  point inertia_vect <- {(location.x-previous_pos.x)*0.7,(location.y-previous_pos.y)*0.7};  float max_inertia <- current_speed;  if (norm(inertia_vect) > max_inertia) {   float inertia_x <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));   float inertia_y <-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));   inertia_x <- (inertia_vect.x < 0) ? -inertia_x : inertia_x;   inertia_y <- (inertia_vect.y < 0) ? -inertia_y : inertia_y;   inertia_vect <- {inertia_x,inertia_y};  }  location <- location + inertia_vect;  previous_pos <- prev_pos; }  // useful functions // this function returns the real x if we pass a percentage : 0 is the extreme left point, 100 is the extreme right point. float getXPos(float x_ratio) {  float result;  if (team.position=back) {   result <- 90-x_ratio*90;  }  else {   result <- x_ratio*90;  }  return result; }  // this function returns the real y if we pass a percentage : 0 is the extreme defensive point, 100 is the extreme attack point. float getYPos(float y_ratio) {  float result;  if (team.position=back) {   result <- y_ratio*120;  }  else {   result <- 120-y_ratio*120;  }  return result; }  ///////////////////////////////////////////////////////  // The update function, calls the adequate behavior reflex update when:cycle>1 {  do apply_inertia;  // verify if it is a non-offside position  if ( (((team.position = back) and (location.y > team.offside_pos))   or ((team.position = front) and (location.y < team.offside_pos)))    and (!possess_ball) and (self != team.called_player)  ) {   // offside position, go back to a correct position   point target_pos <- {location.x,(team.position = back) ? location.y-current_speed:location.y+current_speed};   do run_to(target_pos);   status <- offside position !;  }  else if ((distance_to_ball < 2) and !possess_ball) {   do try_to_take_ball;  }  else if (game.team_possession = team) {   do offensive_behavior;  }  else {   do defensive_behavior;  } }  // defensive behavior, need to be redefined in the strategy file. // this action is called when the last player who was holding the ball was a player of the ennemy team action defensive_behavior virtual:true {   } // defensive behavior, need to be redefined in the strategy file. // this action is called when the last player who was holding the ball was a player of this team action offensive_behavior virtual:true {   }   // ASPECT //////////////////////////////////////////////////////// aspect player {  // the player wich possess the ball is displayed with a square. It is displayed with a circle otherwise.  if (possess_ball) {   draw square(2) color:(team.position = back) ? game.back_color_team : game.front_color_team;  }  else {   draw circle(1) color:(team.position = back) ? game.back_color_team : game.front_color_team;  } } }   species base_team {  // ATTRIBUTES ////////////////////////////////////////////////  // ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE float offside_pos <- 0.0 update: (position = back) ? max((game.players where (each.team != self)) collect (each.location.y))  : min((game.players where (each.team != self)) collect (each.location.y));  // ATTRIBUTES USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !) string position; // can be front or back. list<base_player> players; // all the players of the team. soccer_game game;  base_player closest_player_to_ball <- first(players) update: first( players where (each distance_to each.ball = min (players collect (each distance_to each.ball) ) ) ); base_player called_player; bool possess_ball <- false;// update: ! empty ( players where (each.possess_ball=true) ); base_player player_with_ball <- nil;// update: first(players where (each.possess_ball = true));  // ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRATEGY FILE list<point> player_init_position; }   species ball_sp skills:[moving] {  // The ball agent.  float speed <- 0.0;  geometry ball_direction; // the direction of the ball is used to be followed by the player  reflex update {   speed <- speed0.95;   float future_speed <- speed;   point tmpPos<-location;   loop i from:0 to:10 {    tmpPos <- {tmpPos.x+cos(heading)speed,tmpPos.y+sin(heading)speed};    future_speed <- future_speed0.9;   }   ball_direction <- line([location,tmpPos]);   do wander amplitude:1;   // anticipation of the ball position to detect a goal  if ((location.y+sin(heading)*speed) > 120) {   write back team score a goal !!;   ask first(soccer_game) {    do reinit_phase;   }  }  if ((location.y+sin(heading)*speed) < 0) {   write front team score a goal !!;   ask first(soccer_game) {    do reinit_phase;   }  } } action shooted (point target_position, float speed_atr) {  // action called when a player shoots the ball  speed <- speed_atr;  do goto target:target_position; }  aspect ball {  draw circle(0.5) color:#white; } }   species goal_sp {  string position; // can be  front  or  back .  init {  create goal_keeper with:[position::position]; }  aspect goal {  draw rectangle(7.32,1.0) color:#black; } }   species goal_keeper {  // the goal has a basic behavior : he tries to catch the ball when it is close enough, and when   string position; // can be  front  or  back .  ball_sp ball <- nil update:first(ball_sp);  reflex update when:cycle>0 {  location <- {ball.location.x/90*12+(90-12)/2,location.y};  if (ball distance_to self < 2) {   if (flip(1/(1+2*ball.speed))) {    first(soccer_game).team_possession <- first(first(soccer_game).teams where (each.position = position));    ask ball {     do shooted ({30+rnd(30),60},5.0);    }   }  } }  init {  location <- {45,(position=front) ? 117 : 3}; }  action offensive_behavior { }  action defensive_behavior { }  aspect goal_keeper {  draw circle(1) color:(position = back) ? first(soccer_game).back_color_team : first(soccer_game).front_color_team; } }       Code of the model :       model team2strategy  import  ./soccer_base.gaml   species player_stupidTeam parent:base_player {  // READ ONLY ATTRIBUTES :  // position : can be  front  or  back .  // players : list of all the players of the team.  // game  //closest_player_to_ball  // called_player : the player called for a pass  // possess_ball : true or false  // player_with_ball : player currently with the ball  // READ AND WRITE ATTRIBUTES : // position_mark // status : the current status of the player (can be useful to build the model) // influence_area : the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.   action defensive_behavior {   // very basic defensive behavior : run to the ball  do run_to_ball; }  action offensive_behavior {   // very basic offensive behavior : run to the ennemy goal, or shoot the ball when close enough from the ennemy goal.  if ((possess_ball) and (distance_to_goal < 30)) {   do shoot;  }  else {   do run_to_ennemy_goal;  } }   }  species stupidTeam parent:base_team {  // READ ONLY ATTRIBUTES :  // position : can be  front  or  back .  // players : list of all the players of the team.  // game.  // closest_player_to_ball.  // called_player : the player called for a pass.  // possess_ball : true when a player of the team possess the ball.  // player_with_ball  // READ AND WRITE ATTRIBUTES : // player_init_position  // initial position of the player in percentage : for each point, //    the first value corresponds to the percentage from left to right (0 for the point the most in the left side) //    the second value corresponds to the percentage from the goal position to the mid position (0 for the goal position) list<point> player_init_position <- [{20,20},{50,20},{80,20},{30,50},{70,50},{50,70},{30,90},{50,90},{70,90}]; }       ","url":"wiki/Soccer-team2_strategy.md"},{"id":"wiki/Sugarscape-Sugarscape.md","title":" sugarscape","content":"# sugarscape  _Author : _  A model with animal moving on a grid to find sugar. The animal agents have a life duration and die if it is reached or if they don t have anymore sugar.  Code of the model :      model sugarscape  global {  // Parameters  //Growth rate of the sugar int sugarGrowthRate <- 1; //Minimum age of death int minDeathAge <- 60; //Maximum age of death int maxDeathAge <- 100; //Metabolism maximum int maxMetabolism <- 3;  //Maximum and Minimum initial sugar int maxInitialSugar <- 25 ; int minInitialSugar <- 5; //Maximum range int maxRange <- 6; bool replace <- true; //Number of agents int numberOfAgents <- 400;   // Environment geometry shape <- rectangle(50, 50);   file<int> types  <- file<int>( ../images/sugarscape.pgm ); rgb FFFFAA const: true <- rgb( #FFFFAA ); rgb FFFF55 const: true <- rgb( #FFFF55 ); rgb dark_yellow const: true <- rgb( #EEB422 ); rgb less_red const: true <- rgb( #FF5F5F );  init {    //Create the animal  create animal number: numberOfAgents;    //Ask to each sugar cell to set its sugar  ask sugar_cell {   maxSugar <- (types at {grid_x,grid_y});   sugar <- maxSugar;   color <- [#white,FFFFAA,FFFF55,#yellow,dark_yellow] at sugar;  } } }  //Grid species representing the sugar cells grid sugar_cell width: 50 height: 50 neighbors: 4 use_individual_shapes: false use_regular_agents: false{   //Maximum sugar  int maxSugar;  //Sugar contained in thecell  int sugar update: sugar + sugarGrowthRate max: maxSugar;  rgb color update: [#white,FFFFAA,FFFF55,#yellow,dark_yellow] at sugar;  map<int,list<sugar_cell>> neighbours;    //Initialization of the neighbours  init {   loop i from: 1 to: maxRange {    neighbours[i] <- self neighbors_at i;    }  } }    //Species animal representing the animal agents species animal {  //Color of the animal  rgb color  <- #red;  //Speed of the animal  float speed  <- 1.0;  //Metabolism of the animal  int metabolism  min: 1 <- rnd(maxMetabolism);  //Perception range of the animal  int vision  min: 1 <- rnd(maxRange);  //Maximal age of the animal  int maxAge  min: minDeathAge max: maxDeathAge <- rnd (maxDeathAge - minDeathAge) + minDeathAge;  //Size of the animal  float size  <- 0.5;  //Sugar of the animal  int sugar min: 0 <- (rnd (maxInitialSugar - minInitialSugar)) + minInitialSugar update: sugar - metabolism;  //Age of the animal  int age max: maxAge <- 0 update: int(age + step);  //Place of the animal  sugar_cell place ;  //Launched at the initialization of the animal agent init {  //Set the place as one of the sugar cell  place <- one_of(sugar_cell);  location <- place.location; } //Move the agent to another place and collect the sugar of the previous place reflex basic_move {   sugar <- sugar + place.sugar;  place.sugar <- 0;  list<sugar_cell> neighbours <- place.neighbours[vision];  list<sugar_cell> poss_targets <- (neighbours) where (each.sugar > 0);  //If no sugar is found in the neighbours cells, move randomly  place <- empty(poss_targets) ? one_of (neighbours) : one_of (poss_targets);  location <- place.location; } //Reflex to kill the animal once it reaches its maximal age or it doesn t have sugar anymore reflex end_of_life when: (sugar = 0) or (age = maxAge) {  if replace {   create animal ;  }  do die; } aspect default {  draw circle(0.5) color: #red; } }   experiment sugarscape type: gui{  parameter  Growth rate of sugar:  var: sugarGrowthRate category:  Environment ;  parameter  Minimum age of death:  var: minDeathAge <- 60 category:  Agents ;  parameter  Maximum age of death:  var: maxDeathAge <- 100 category:  Agents ;  parameter  Maximum metabolism:  var: maxMetabolism <- 3 category:  Agents ;  parameter  Maximum initial sugar per cell:   var: maxInitialSugar <- 25 category:  Environment ;  parameter  Minimum initial sugar per cell:  var: minInitialSugar <- 5 category:  Environment ;  parameter  Maximum range of vision:  var: maxRange <- 6 category:  Agents ;  parameter  Replace dead agents ?  var: replace <- true category:  Agents ;  parameter  Number of agents:  var: numberOfAgents <- 400 category:  Agents ;  output {  display grille {   grid sugar_cell;   species animal;  }  display chart refresh: every(5) {   chart  Energy  type: pie background: #lightgray style: exploded {    data strong value: (animal as list) count (each.sugar > 8) color: #green;    data weak value: (animal as list) count (each.sugar < 9) color: #red;   }  }  display chart2 refresh: every(5) {   chart  Energy  type: histogram background: #lightgray {    data strong value: (animal as list) count (each.sugar > 8)  color: #green;    data weak value: (animal as list) count (each.sugar < 9)  color: #red;   }  } } }      ","url":"wiki/Sugarscape-Sugarscape.md"},{"id":"wiki/Traffic-LWR-Traffic-Flow-Model.md","title":" Trafic Group (R2D2) MAPS7 - LWR Model","content":"# Trafic Group (R2D2) MAPS7 - LWR Model  Author : A. Banos, N. Corson, C. Pivano, L. Rajaonarivo, P. Taillandier  The LWR model was proposed by Lighthill and Whitham (1955) and by Richards (1956). It describes the trafic at a global level considering the speed, concentration and flows without taking into account the individual behavior af vehicles. Speed, concentration and flow are the three components of the LWR model. This models reproduces flow of traffic and congestion in specific conditions (homogeneous traffic), going from one equilibrium state to another (see the fundamental diagramm of traffic, which gives flow according to concentration). In this model, a road is divided into sections and we arbitrarily give to the middle section a lower speed and critical concentration.  Code of the model :       model TraficGroup  global {  float road_size <- 10 #km ;       // Size of the road  geometry shape <- rectangle (road_size, 200 #m) ;  // The world is a rectangle with a length equals to the size of the road and a height of 200m   float time_step <- 1.0 ;        // Time step  int nb_sections <- 10 ;        // Number of sections of the road float section_size <- road_size / nb_sections ;  // Size of a section  float car_size <- 4 #m ;         // Size of a car float nb_max_cars_on_section <- section_size / car_size ; // Maximum number of cars on one section      init{            // Creation of the nb_sections sections which compose the road.            loop i from: 0 to: (nb_sections - 1){        create section with: [shape:: line([{i * section_size , 100},{(i +1) * section_size , 100}])];     }            // For each section, as we need to have information concerning the previous and the next one, we define which section is the previous and which is the next.      // The previous section is the one which last point corresponds to the first point of the actual section.       // The next section is the one which first point corresponds to the last point of the actual section.             ask section{       previous <- section first_with (last(each.shape.points) = first(self.shape.points)) ;       next <- section first_with (first(each.shape.points) = last(self.shape.points)) ;      }       // For each section, we define a critical concentration (see the fundamental diagram), a maximum speed, a concentration and a flow (which are = 0 at initialization).       // A fundamental relation about trafic gives : flow = concentration * speed.            ask section{       critical_concentration <- 125.0 ; //Kc    max_speed <- 50 #km/#h; // Vl    current_concentration <- 0.0 ;    current_flow <- current_concentration * max_speed ;    max_flow <- critical_concentration * max_speed ;       }                  // The concentration and flow ot first section are initialized.            ask section[0]{       current_concentration <- nb_max_cars_on_section ;    current_flow <- current_concentration * max_speed ;      }            // The middle section is supposed to have a different maximum speed and a different critical concentration so that we can observe congestion phenomenon.      // This middle section is green.            ask section[int(nb_sections/2)] {        critical_concentration <- 10.0 ;         max_flow <- critical_concentration * max_speed ;         max_speed <- 10 #km/#h;      color <- #green;      }  }   // To update flow and concentration at each time step in each section, we use an offer and a demand function.     // These functions define the welcome capacity (offer) and the emission capacity (demand) of a section.  reflex offer_function {      ask section {     if current_concentration <= critical_concentration {      offer <- max_flow ;     }     else {      offer <- max([0 , (- max_flow / critical_concentration) * current_concentration + 2 * max_flow ]);     }       } }  reflex demand_function {  ask section{     if current_concentration <= critical_concentration {       demand <- max([0 , ( max_flow / critical_concentration) * current_concentration]) ;     }     else {       demand <- max_flow ;     }  } }  // The flow and concentration are then updated according to the offer and demand functions of the current section, but also of the next and previous ones.  // During a time step, the flow of a section take the minimum value between its demand and the offer of the next section. // The flow of the last section is equal to its demand.   reflex update_flow{  ask section  {   float next_offer <-  (self.next != nil) ? (self.next).offer : self.demand;   current_flow <- min([self.demand, next_offer]);  } }   // After a time step, the concentration is updated from the current concentration, according to the incoming and outgoing concentrations. // The first section concentration on ly takes into account the outgoing concentration of vehicles.  reflex update_concentration{  ask section   {   float previous_flow <- (self.previous != nil) ? (self.previous).current_flow : 0.0;   current_concentration <- current_concentration + time_step/section_size *(previous_flow - self.current_flow) ;  }  }  // When there is less than one car left on the road, the simulation stops.  reflex stop_simulation when: sum(section collect each.current_concentration) < 1.0 {  do pause; } }   // A road is divided into sections.  // Each section has a concentration, a flow, an offer and a demand, a critical concentration, a maximum speed and a maximum flow,  // and a previous and a next section.  species section {  float current_concentration  ;  float current_flow  ;  float offer ; float demand  ;  rgb color;  float critical_concentration ;  float max_speed ;  float max_flow ;   section previous ; section next ;  // The width of a section depends on its concentration.  aspect shape_section {  draw shape + (1 + 15 * ln (current_concentration + 1)) color: color;   }    }  experiment TraficGroup type: gui {  // Users can chose the number of sections and the time step.  parameter  Number of sections  var: nb_sections category: Section parameter; parameter  Time step - DeltaT  var: time_step category: Time parameter;      output {    // A monitor gives the number of cars on the road at every time step.    monitor Sum Concentrations value: sum(section collect each.current_concentration);    // A display shows the road. Section width depend on their concentration.    display TheRoad{   species section aspect: shape_section ;  }    // The greeen time series correspond to the middle section (on which concentration and maximum speed are lower).  // The red time series correspond to the section just before the middle one.      display Concentrations {   chart Concentrations type: series  {    data  Section 0  value: section[0].current_concentration color: #gray marker: false ;        data  Section 1  value: section[1].current_concentration color: #gray marker: false;    data  Section 2  value: section[2].current_concentration color: #gray marker: false;    data  Section 3  value: section[3].current_concentration color: #gray marker: false;        data  Section 4  value: section[int(nb_sections/2 - 1 ) ].current_concentration color: #red marker: false;    data  Section 5  value: section[int(nb_sections/2)].current_concentration color: #green marker: false;    data  Section 6  value: section[6].current_concentration color: #gray marker: false;        data  Section 7  value: section[7].current_concentration color: #gray marker: false;    data  Section 8  value: section[8].current_concentration color: #gray marker: false;    data  Section 9  value: section[9].current_concentration color: #gray marker: false;    }   }      display Flows {       chart Flows type: series  {    data  Section 0  value: section[0].current_flow color: #gray marker: false;        data  Section 1  value: section[1].current_flow color: #gray marker: false;    data  Section 2  value: section[2].current_flow color: #gray marker: false;    data  Section 3  value: section[3].current_flow color: #gray marker: false;        data  Section 4  value: section[int(nb_sections/2 - 1)].current_flow color: #red marker: false;    data  Section 5  value: section[int(nb_sections/2)].current_flow color: #green marker: false;    data  Section 6  value: section[6].current_flow color: #gray marker: false;        data  Section 7  value: section[7].current_flow color: #gray marker: false;    data  Section 8  value: section[8].current_flow color: #gray marker: false;    data  Section 9  value: section[9].current_flow color: #gray marker: false;    }   } } }      ","url":"wiki/Traffic-LWR-Traffic-Flow-Model.md"},{"id":"wiki/Traffic-Simple-traffic-model.md","title":" Traffic","content":"# Traffic  Author : Patrick Taillandier  A simple road network model: the speed on a road depends on the number of people on this road (the highest, the slowest)  Code of the model :       model traffic  global {  //Shapefile of the buildings  file building_shapefile <- file( ../includes/buildings.shp );  //Shapefile of the roads  file road_shapefile <- file( ../includes/roads.shp );  //Shape of the environment  geometry shape <- envelope(road_shapefile);  //Step value  float step <- 10 #s;  //Graph of the road network  graph road_network;  //Map containing all the weights for the road network graph  map<road,float> road_weights;  init {  //Initialization of the building using the shapefile of buildings  create building from: building_shapefile;  //Initialization of the road using the shapefile of roads  create road from: road_shapefile;    //Creation of the people agents  create people number: 1000{   //People agents are located anywhere in one of the building   location <- any_location_in(one_of(building));    }    //Weights of the road    road_weights <- road as_map (each::each.shape.perimeter);    road_network <- as_edge_graph(road); } //Reflex to update the speed of the roads according to the weights reflex update_road_speed  {  road_weights <- road as_map (each::each.shape.perimeter / each.speed_coeff);  road_network <- road_network with_weights road_weights; } } //Species to represent the people using the skill moving species people skills: [moving]{ //Target point of the agent point target; //Probability of leaving the building float leaving_proba <- 0.05;  //Speed of the agent float speed <- 5 #km/#h; rgb color <- rnd_color(255); //Reflex to leave the building to another building reflex leave when: (target = nil) and (flip(leaving_proba)) {  target <- any_location_in(one_of(building)); } //Reflex to move to the target building moving on the road network reflex move when: target != nil {  do goto target: target on: road_network recompute_path: false move_weights: road_weights;  if (location = target) {   target <- nil;  }  }  aspect default {  draw circle(5) color: color; } } //Species to represent the buildings species building { aspect default {  draw shape color: #gray; } } //Species to represent the roads species road { //Capacity of the road considering its perimeter float capacity <- 1 + shape.perimeter/30; //Number of people on the road int nb_people <- 0 update: length(people at_distance 1); //Speed coefficient computed using the number of people on the road and the capicity of the road float speed_coeff <- 1.0 update:  exp(-nb_people/capacity) min: 0.1;  aspect default {  draw (shape + 3 * speed_coeff) color: #red; } } experiment trafic type: gui { float minimum_cycle_duration <- 0.01; output {  display carte type: opengl{   species building refresh: false;   species road ;   species people ;  } } }      ","url":"wiki/Traffic-Simple-traffic-model.md"},{"id":"wiki/Urban-Growth-raster-model.md","title":" Cellular Automaton Based Urban Growth","content":"# Cellular Automaton Based Urban Growth  Author : Truong Chi Quang, Patrick Taillandier, Benoit Gaudou & Alexis Drogoul  model based on the one proposed by (Raimbault et al., 2014): At each simulation step the nb_plots_to_build empty plots with the highest constructability are built The constructability is computed from 3 criteria: the density of construction in the neighborhood, the distance to a road, the distance to the city center (using the road network).  Code of the model :       model raster3  global {   //File for the ascii grid  file asc_grid <- grid_file( ../includes/cantho_1999_v6.asc );  //Shapefile for the road  file road_shapefile <- shape_file( ../includes/roads15_3.shp );  //Shapefile for the city  file city_center_shapefile <- shape_file( ../includes/city center.shp );  //Shape of the environment  geometry shape <- envelope(asc_grid);  //Graph of the roads  graph roads_network;  // Dynamic list of the cells to consider at each cycle list<plot> empty_plots <- plot where (each.grid_value = 0.0) update: shuffle(plot where (each.grid_value = 0.0));  list<rgb> plot_colors <- [   #lightgray, //empty  #orange, // 1 built  #blue // 2 River-lake ]; //Radius of density int density_radius <- 4; //Weight of density float weight_density <- 0.05; //Weight of the road distance float weight_road_dist <- 0.5; //Weight of the city center distance float weight_cc_dist <- 0.3; //Number of plot allowing to build a building int nb_plots_to_build <- 195;  init {  //Creation of the roads using the shapefile of the road  create roads from: road_shapefile;  //Creation of the city center using the city center shapefile  create city_center from: city_center_shapefile;  //Creation of the graph of the road network  roads_network <- as_edge_graph(roads);    //Each road has to compute its distance from the city center  ask roads {   do compute_cc_dist;  }  //Compute the city distance for each plot  ask empty_plots {   do compute_distances;  }  //Normalization of the distance  do normalize_distances; } //Action to normalize the distance action normalize_distances {  //Maximum distance from the road of all the plots  float max_road_dist <- empty_plots max_of each.dist_route;  //Maximum distance from the city center for all the plots  float max_cc_dist <- empty_plots max_of each.dist_cv;  //Normalization of  each empty plot according to the maximal value of each attribute  ask empty_plots {   dist_cv <- 1 - dist_cv / max_cc_dist;   dist_route <- 1 - dist_route / max_road_dist;  } }   //Reflex representing the global dynamic of the model reflex dynamique_globale when: weight_density != 0 or weight_road_dist != 0 or weight_cc_dist != 0 {  //Ask to each empty plot to compute its constructability  ask empty_plots {   constructability <- compute_constructability();  }  list<plot> ordered_plots <- empty_plots sort_by (each.constructability);  ordered_plots <- nb_plots_to_build last ordered_plots;  //Build on each empty plot having the highest constructability  ask ordered_plots  {   do build;  } }  } //Species representing the city center species city_center { aspect default {  draw circle(300) color: #cyan; }  } //Species representing the roads species roads { float dist_cv; //Action to compute the city center distance for the road action compute_cc_dist {  using topology(roads_network)  {   dist_cv <- self distance_to first(city_center);  } } aspect default {  draw shape color: #black;  } } //Grid species to represent the different building plots grid plot file: asc_grid use_individual_shapes: false use_regular_agents: false neighbors: 4 { rgb color <- grid_value = -1 ? #white : plot_colors[int(grid_value)]; //Distance from the road float dist_route <- 0.0; //Distance from the city center float dist_cv <- 0.0; //Constructability of the plot float constructability;  //Action to compute all the distances for the cell action compute_distances {  roads route_pp <- roads closest_to self;  dist_route <- (self distance_to route_pp) using topology(world);  dist_cv <- dist_route + route_pp.dist_cv; } //Action to build on the cell action build {  grid_value <- 1.0;  color <- plot_colors[1]; } //Action to compute the constructability of the plot cell float compute_constructability {  //Get all the neighbours plots  list<plot> voisins <- (self neighbors_at density_radius);  //Compute the density of all the neighbours plots  float densite <- (voisins count (each.grid_value = 1.0)) / length(voisins);  return (densite * weight_density + dist_route * weight_road_dist + dist_cv * weight_cc_dist) / (weight_density + weight_road_dist + weight_cc_dist); }    }   experiment raster type: gui {   parameter  Weight of the density criteria  var: weight_density;   parameter  Weight of the distance to roads criteria  var: weight_road_dist;   parameter  Weight of the distance to city center criteria  var: weight_cc_dist;   output {    display map type: opengl {    grid plot;    species roads;    species city_center;   }  } }      ","url":"wiki/Urban-Growth-raster-model.md"},{"id":"wiki/Voronoi-Voronoi.md","title":" Voronoi","content":"# Voronoi  _Author : _  A model showing how to clusterize space using the closest center as the kernel of our cluster. The space is discretized using a grid, each cell computing its distance from a center to know in which cluster it is.  Code of the model :       model voronoi  global {  // Parameters   //Number of points  int num_points <- 4 min: 1 max: 1000;  //Size of the environment  int env_width <- 100 min: 10 max: 400;  int env_height <- 100 min: 10 max: 400;  // Environment geometry shape <- rectangle(env_width, env_height);  init {   write  This model shows how Voronoi-like shapes can be drawn on a regular surface. A set of mobile agents is placed on a grid. Each agent possesses an attribute called *inside_color*. Each step, the agents move randomly and the grid cells paint themselves using the *inside_color* of the nearest agent. Dynamical boundaries then appear on the screen without any further calculations. ;  //Creation of all the points  create center number: num_points ;   }    }  //Grid for the voronoi clustering grid cell width: env_width height: env_height neighbors: 8 use_regular_agents: false { // Note: since GAMA 1.7, the topology needs to be specified for this computation to use continuous distances center closest_center <- nil update: (center closest_to self.location) using topology(world); rgb color <- #white update: (closest_center).color; } //Species representing the center of a Voronoi point species center skills: [moving] {  rgb color <- rgb([rnd (255),rnd (255),rnd (255)]);  //Make the center of the cluster wander in the environment reflex wander {  do wander amplitude: 90; }   aspect base {  draw square(1.0) color: color; } }   experiment voronoi type: gui{   parameter  Number of points:  var: num_points;  parameter  Width of the environment:  var: env_width;  parameter  Height of the environment:  var: env_height;  output {  display Voronoi type: opengl {   grid cell  ;   species center aspect: base ;  } }  }      ","url":"wiki/Voronoi-Voronoi.md"},{"id":"wiki/Vote-Vote.md","title":" vote","content":"# vote  _Author : MAPS TEAM (Frederic Amblard, Thomas Louail, Romain Reulier, Paul Salze et Patrick Taillandier) _  Modeling of an election  Code of the model :       model vote  global {  //Shape of the environment  geometry shape <- rectangle({200, 200});  //Number of electors int nb_electors <- 1500; //Number of candidates int nb_candidates <- 7; //Weight of each candidates int weight_candidates <- 50; //Threshold for the attraction candidates int threshold_attraction_candidates <- 80; //Threshold for the repulsion candidates int threshold_repulsion_candidates <- 200; //Threshold for the attraction electors int threshold_attraction_electors <- 20;  //Distance traveled float distance_traveled <- 7.0; //Distribution of the electors string distribution_electors <- Uniform among: [Uniform, Normal]; //Distribution of candidates string distribution_candidates <- Polygon among: [Random, Polygon, Line, Diagonal]; //Strategy of the candidates string strategy_candidates <- No strategy among: [No strategy, Search electors, Distinction, Group, Go closer to the best,Random ]; //Count of max group int cpt_Group_max <- 5; //Count  of group int cpt_Group <- cpt_Group_max;  float entropy;  //List of all the active candidates list<candidate> active_candidates ;  init {  //Creation of the elector  create elector number: nb_electors;  do creation_candidates; } //Action to create the candidates according to the distribution of candidates action creation_candidates {  switch distribution_candidates {    match Polygon {    list<point> liste_points <- list(nb_candidates points_at 50.0);    int cpt <- 0;    create candidate number: nb_candidates{      color <- rgb (rnd(255), rnd(255), rnd(255));       location <- liste_points at cpt;      cpt <- cpt + 1;     }   }   match Line {    int cpt  <- 0;    create candidate number: nb_candidates{     color <- rgb ([rnd(255), rnd(255), rnd(255)]);      float x_cord  <- 200 * cpt / nb_candidates;     float y_cord <- 100.0;     location <- {x_cord, y_cord};     cpt <- cpt + 1;    }   }   match Diagonal {    int cpt <- 0;    create candidate number: nb_candidates{     color <- rgb ([rnd(255), rnd(255), rnd(255)]);      float x_cord <- 200 * cpt / nb_candidates;     float y_cord <- x_cord;     location <- {x_cord, y_cord};     cpt <- cpt + 1;    }   }  }  //Initialization of all the active candidates as the list of candidates  active_candidates <- list(copy(candidate));  } //Reflex representing the dynamics of the models reflex dynamique {  //For each elector, ask to move  ask elector {   do moving;  }  //For each candidate, ask to move  ask active_candidates{   do moving;   my_electors <- list<elector>([]);  }  //For each elector, do its definition  ask elector {   do definition_candidate;  }  int nb_electors_max <- 0;  candidate candidat_elected <- nil;     //Ask to all the active candidates to compute their percentage of vote and set the number of maximum electors to know which candidate is elected  ask active_candidates{    int nb_el <- length(my_electors) ;   percentage_vote <- (nb_el/nb_electors * 100) with_precision 2;   if (nb_el > nb_electors_max) {    nb_electors_max <- nb_el;     candidat_elected <- self;   }  }  //update of the state of the candidate  ask candidate {   is_elected <- false;   }  ask candidat_elected {   is_elected <- true;   } } //Reflex to show the final results reflex resultats_finaux when: time = 72 {  candidate elected <- active_candidates with_max_of (each.percentage_vote);  //Display a window telling who is the winner and halt the model  do tell message: The winner is  + elected.name;   do halt; }  //Reflex to compute the creation of group when one candidate chooses this strategy reflex creation_Group when: (strategy_candidates in [Group, Random]) {   if (cpt_Group = cpt_Group_max) {    //Kill all the group of electors    ask Group_electors as list {     do die;    }    //Compute the list of elector according to their distance   list<list<elector>> Groups;   geometry geoms <- union(elector collect ((each.shape) buffer ([distance::float(threshold_attraction_electors) , quadrantSegments::4, endCapStyle::1])));   loop geom over: geoms.geometries {     if (geom != nil and !empty(geom.points)) {     list<elector> els  <- (elector inside geom);      add els to: Groups;    }   }   //Create new groups of electors according to the list of electors   loop gp over: Groups {     create Group_electors {      effectif <- length(gp);       electors_dans_Group <- gp;       location <- mean(electors_dans_Group collect (each.location)) ;     }    }    }  cpt_Group <- cpt_Group - 1;  if (cpt_Group = 0) { cpt_Group <- cpt_Group_max;}  } //Reflex to compute the entropy reflex calcule_entropy {  entropy <- 0.0;  //Compute the abstinence rate  float abst <- (nb_electors - sum (active_candidates  collect (length(each.my_electors)))) / nb_electors;  if (abst > 0) {   entropy <- entropy - (abst * ln(abst));  }  //Ask to all the active candidates their number of electors to compute the entropy  ask active_candidates {   float p <- length(my_electors) / nb_electors;   if (p > 0) {    entropy <- entropy - (p * ln(p));   }  }  entropy <- entropy / ln (length(active_candidates) + 1); } }   //Species representing a group of electors species Group_electors {  int effectif <- 0;  //List of all the elector agents in the group  list electors_dans_Group ;  aspect default {   draw square(2) color: #orange;  }  } //Species representing the elector moving  species elector skills: [moving]{  init {  //At initialization, place the elector in a certain place according to the distribution of electors  if (distribution_electors = Normal) {   float x_cord <- max([0.0, min([200.0, gauss ({100, 35})])]);   float y_cord <- max([0.0, min([200.0, gauss ({100, 35})])]);   location <- {x_cord, y_cord};  } } rgb color <- #white; //Candidate chosen by the elector candidate my_candidate;    aspect base {  draw triangle(2) color: color ; }  //Action to define the candidate action definition_candidate {  //The candidate chosen is the one closest to the elector in the attraction range  my_candidate <- active_candidates with_min_of (self distance_to each);  my_candidate <- (self distance_to my_candidate < threshold_attraction_candidates) ? my_candidate : nil;  if (my_candidate != nil) {   add self to: my_candidate.my_electors;    color <- my_candidate.color;  } } //Action to move the elector action moving {  //Make the agent move closer to another elector, representing the influence of this one  if ( rnd(100) > (weight_candidates)) {   elector my_elector <- shuffle(elector) first_with ((self distance_to each) < threshold_attraction_electors);   if (my_elector != nil) {    do goto target:my_elector speed: distance_traveled;   }   } else {   //Move the elector closer to one of the candidate to represent its repulsion or attraction   candidate the_candidate <- one_of(candidate) ;   if (the_candidate != nil) {    float dist <- self distance_to the_candidate;    if dist < threshold_attraction_candidates {     do goto target: the_candidate speed: distance_traveled;    } else if dist > threshold_repulsion_candidates {     do goto target: location + location - the_candidate.location speed: distance_traveled;    }   }  }   }    } //Species candidate using the skill moving species candidate skills:[moving]{  rgb color <- rgb([100 + rnd(155),100 + rnd(155),100 + rnd(155)]);  //Boolean to know if the candidate is active  bool active <- true;  //Float representing the percentage of vote for the candidate  float percentage_vote;   //List of all the electors of the candidate  list my_electors of: elector;  //Boolean to know if the candidate is elected  bool is_elected <- false;  aspect default {   draw circle(3) color: color;  }   aspect dynamic {   if (active) {    float radius  <- 1 + (percentage_vote / 4.0);    if (is_elected) {     draw square( radius *1.5) color: #red;      draw circle(radius) color: color;    } else {     draw circle(radius) color: color;    }    draw string(percentage_vote) size: 5 color: #white;   }  }  //Action to move the candidate according to its strategy  action moving {   switch strategy_candidates {    match  No strategy  {}    match  Search electors  {do strategy_1;}    match  Distinction  {do strategy_2;}    match  Group  {do strategy_3;}    match  Go closer to the best  {do strategy_4;}    match  Random  {      switch (rnd(4)) {      match 0 {}      match 1 {do strategy_1;}       match 2 {do strategy_2;}       match 3 {do strategy_3;}       match 4 {do strategy_4;}       }    }   }  }  action strategy_1 {  //go closer to electors  elector my_elector <- shuffle(elector) first_with ((self distance_to each) < threshold_attraction_electors);  if (my_elector != nil) {   do goto target:my_elector speed: distance_traveled;  }  }  action strategy_2 {  //go in opposite directions to other candidates  list<candidate> cands <- list(copy(candidate));  remove self from: cands;  candidate the_candidate <- one_of(cands) ;  if (the_candidate != nil) {   do goto target: (location + location - the_candidate.location) speed: distance_traveled;   } }  action strategy_3 {  //go closer to a group of electors  Group_electors mon_Group  <- (Group_electors where ((self distance_to each) < threshold_attraction_electors)) with_max_of (each.effectif);  if (mon_Group != nil) {   do goto target:mon_Group speed: distance_traveled;  }  }  action strategy_4 {  //go toward the candidate with max of votes  candidate the_candidate <- candidate with_max_of (percentage_vote) ;  if (the_candidate != nil) {   do goto target:the_candidate speed: distance_traveled;   } }   }  experiment vote type: gui {  /** Insert here the definition of the input and output of the model */  parameter  Number of electors :   var: nb_electors category:  elector ;  parameter  Moving speed of electors toward another electors :   var: distance_traveled category:  elector ;  parameter  Attraction distance between electors :   var: threshold_attraction_electors category:  elector ;  parameter  Number of candidates :   var: nb_candidates category:  Candidate ;  parameter  Attraction distance between candidates and electors :   var: threshold_attraction_candidates category:  elector ;  parameter Repulsion distance between candidates :  var: threshold_repulsion_candidates category: elector; parameter weight of candidates :  var: weight_candidates category: Candidate;  parameter Distribution type of electors :  var: distribution_electors category: elector; parameter Distribution type of  candidates :  var: distribution_candidates category: Candidate; parameter Strategy of candidates :  var: strategy_candidates category: Candidate;  output {  display main background: #black {    species elector aspect: base;   species candidate aspect: dynamic;   species Group_electors;     }  display votants {   chart Distribution of electors type: pie background: #white  {     loop cand over: candidate {      data  cand.name value:cand.percentage_vote color: cand.color ;     }    }      }  display indicateurs {   chart Shannon Entropy type: series background: #white size: {1,0.5} position: {0, 0} {    data entropy value: entropy color: #blue ;   }   chart Opinion distribution type: series background: #white size: {1,0.5} position: {0, 0.5} {    data Space area covered value: (union(candidate collect (each.shape buffer threshold_attraction_candidates))).area / 40000 color: #blue ;   }  } } }      ","url":"wiki/Vote-Vote.md"},{"id":"wiki/Ants-(Foraging-and-Sorting).md","title":" Ants (Foraging and Sorting)","content":"Ants (Foraging and Sorting)  This sub-section is composed of the following models :   Ant Foraging (Classic) Ant Foraging (Complex) Ant Foraging (Multi-Simulation) Ant Foraging (Simple) Ant Sorting      ","url":"wiki/Ants-(Foraging-and-Sorting).md"},{"id":"wiki/Articles.md","title":" Articles","content":"Articles  This sub-section is composed of the following models :   Ville 1 Ville 2 Ville 3 Ville 4 Ville 5 Ville 6 Prima 1 Prima 2 Prima 3 Prima 4 Prima 5 Prima 5      ","url":"wiki/Articles.md"},{"id":"wiki/Boids.md","title":" Boids","content":"Boids  This sub-section is composed of the following models :   Boids 3D Analysis Boids 3D Motion Boids With Flocks Boids      ","url":"wiki/Boids.md"},{"id":"wiki/Circle.md","title":" Circle","content":"Circle  This sub-section is composed of the following models :     Circle   ","url":"wiki/Circle.md"},{"id":"wiki/Clock.md","title":" Clock","content":"Clock  This sub-section is composed of the following models :     Clock   ","url":"wiki/Clock.md"},{"id":"wiki/Co-model-Example.md","title":" Co-model Example","content":"Co-model Example  This sub-section is composed of the following models :   Comodel of Boids and Voronoi Comodel of Flood and Evacuation model Comodel SIR Switch comodel Urban and Traffic model      ","url":"wiki/Co-model-Example.md"},{"id":"wiki/Epidemiology.md","title":" Epidemiology","content":"Epidemiology  This sub-section is composed of the following models :   comparison_ABM_EBM_SIR simple_ODE_SIR_Predefined SIR_split_in_agents SIR_switch SI without ODE SIR without ODE      ","url":"wiki/Epidemiology.md"},{"id":"wiki/Evacuation.md","title":" Evacuation","content":"Evacuation  This sub-section is composed of the following models :   continuous_move evacuationgoto grid_move      ","url":"wiki/Evacuation.md"},{"id":"wiki/Flood-Simulation.md","title":" Flood Simulation","content":"Flood Simulation  This sub-section is composed of the following models :     Hydrological Model   ","url":"wiki/Flood-Simulation.md"},{"id":"wiki/Learning.md","title":" Learning","content":"Learning  This sub-section is composed of the following models :     Agent Based Clustering   ","url":"wiki/Learning.md"},{"id":"wiki/Life.md","title":" Life","content":"Life  This sub-section is composed of the following models :     Life   ","url":"wiki/Life.md"},{"id":"wiki/Multi-level-data-analysis.md","title":" Multi-level data analysis","content":"Multi-level data analysis  This sub-section is composed of the following models :   SpatialGraph SpatialGraph3d Modavi      ","url":"wiki/Multi-level-data-analysis.md"},{"id":"wiki/Predator-Prey.md","title":" Predator Prey","content":"Predator Prey  This sub-section is composed of the following models :   ODE_LotkaVolterra ODE_LotkaVolterra      ","url":"wiki/Predator-Prey.md"},{"id":"wiki/Segregation-(Schelling).md","title":" Segregation (Schelling)","content":"Segregation (Schelling)  This sub-section is composed of the following models :   segregationAgents segregationGrid segregationGIS segregationGoogleMap      ","url":"wiki/Segregation-(Schelling).md"},{"id":"wiki/Soccer.md","title":" Soccer","content":"Soccer  This sub-section is composed of the following models :   Soccer Game Soccer game (Various strategies)      ","url":"wiki/Soccer.md"},{"id":"wiki/Sugarscape.md","title":" Sugarscape","content":"Sugarscape  This sub-section is composed of the following models :     sugarscape   ","url":"wiki/Sugarscape.md"},{"id":"wiki/Traffic.md","title":" Traffic","content":"Traffic  This sub-section is composed of the following models :   Trafic Group (R2D2) MAPS7 - LWR Model Traffic      ","url":"wiki/Traffic.md"},{"id":"wiki/Urban-Growth.md","title":" Urban Growth","content":"Urban Growth  This sub-section is composed of the following models :     Cellular Automaton Based Urban Growth   ","url":"wiki/Urban-Growth.md"},{"id":"wiki/Voronoi.md","title":" Voronoi","content":"Voronoi  This sub-section is composed of the following models :     Voronoi   ","url":"wiki/Voronoi.md"},{"id":"wiki/Vote.md","title":" Vote","content":"Vote  This sub-section is composed of the following models :     vote   ","url":"wiki/Vote.md"},{"id":"wiki/Incremental-Model-Incremental-Model-1.md","title":" Simple SI Model","content":"# Simple SI Model  First part of the tutorial : Incremental Model  Code of the model :       model SI_city  global{   int nb_people <- 500;  float infection_distance <- 2.0 #m;  float proba_infection <- 0.05;  int nb_infected_init <- 5;  float step <- 1 #minutes;  geometry shape<-envelope(square(500 #m));  init{  create people number:nb_people {   speed <- 5.0 #km/#h;  }  ask nb_infected_init among people {   is_infected <- true;  } }   }  species people skills:[moving]{    bool is_infected <- false;  reflex move{   do wander;  }  reflex infect when: is_infected{   ask people at_distance infection_distance {    if flip(proba_infection) {     is_infected <- true;    }   }  }  aspect circle{   draw circle(5) color:is_infected ? #red : #green;  } }  experiment main_experiment type:gui{  parameter  Infection distance  var: infection_distance;  parameter  Proba infection  var: proba_infection min: 0.0 max: 1.0;  parameter  Nb people infected at init  var: nb_infected_init ;  output {   display map {    species people aspect:circle;      }  } }     ","url":"wiki/Incremental-Model-Incremental-Model-1.md"},{"id":"wiki/Incremental-Model-Incremental-Model-2.md","title":" Charts","content":"# Charts  Second part of the tutorial : Incremental Model  Code of the model :       model SI_city  global{  int nb_people <- 500;  float step <- 1 #minutes;  geometry shape<-envelope(square(500 #m));  float infection_distance <- 2.0 #m;  float proba_infection <- 0.05;  int nb_infected_init <- 5;  int current_hour update: (cycle / 60) mod 24;  int nb_people_infected <- nb_infected_init update: people count (each.is_infected);  int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;  float infected_rate update: nb_people_infected/length(people);  init{  create people number:nb_people {   speed <- 5.0 #km/#h;  }  ask nb_infected_init among people {   is_infected <- true;  } } reflex end_simulation when: infected_rate = 1.0 {  do halt; } }   species people skills:[moving]{    bool is_infected <- false;  reflex move{   do wander;  }  reflex infect when: is_infected{   ask people at_distance infection_distance {    if flip(proba_infection) {     is_infected <- true;    }   }  }  aspect circle{   draw circle(5) color:is_infected ? #red : #green;  } }  experiment main_experiment type:gui{  parameter  Infection distance  var: infection_distance;  parameter  Proba infection  var: proba_infection min: 0.0 max: 1.0;  parameter  Nb people infected at init  var: nb_infected_init ;  output {   monitor  Current hour  value: current_hour;   monitor  Infected people rate  value: infected_rate;   display map {    species people aspect:circle;      }   display chart refresh: every(10) {    chart  Disease spreading  type: series {     data  susceptible  value: nb_people_not_infected color: #green;     data  infected  value: nb_people_infected color: #red;    }   }  } }     ","url":"wiki/Incremental-Model-Incremental-Model-2.md"},{"id":"wiki/Incremental-Model-Incremental-Model-3.md","title":" Integration of GIS Data","content":"# Integration of GIS Data  third part of the tutorial : Incremental Model  Code of the model :       model model3  global {  int nb_people <- 500;  float step <- 1 #minutes;  float infection_distance <- 2.0 #m;  float proba_infection <- 0.05;  int nb_infected_init <- 5;  file roads_shapefile <- file( ../includes/road.shp );  file buildings_shapefile <- file( ../includes/building.shp );  geometry shape <- envelope(roads_shapefile);  int current_hour update: (cycle / 60) mod 24;  int nb_people_infected <- nb_infected_init update: people count (each.is_infected);  int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;  float infected_rate update: nb_people_infected/length(people); init {  create road from: roads_shapefile;  create building from: buildings_shapefile;  create people number:nb_people {   speed <- 5.0 #km/#h;   building bd <- one_of(building);   location <- any_location_in(bd);  }  ask nb_infected_init among people {   is_infected <- true;  } } reflex end_simulation when: infected_rate = 1.0 {  do halt; } }   species people skills:[moving]{    bool is_infected <- false;  reflex move{  do wander; } reflex infect when: is_infected{  ask people at_distance infection_distance {   if flip(proba_infection) {    is_infected <- true;   }  } } aspect circle{  draw circle(5) color:is_infected ? #red : #green; } }   species road {  aspect geom {   draw shape color: #black;  } }  species building {  aspect geom {   draw shape color: #gray;  } }  experiment main_experiment type:gui{  parameter  Infection distance  var: infection_distance;  parameter  Proba infection  var: proba_infection min: 0.0 max: 1.0;  parameter  Nb people infected at init  var: nb_infected_init ;  output {   monitor  Current hour  value: current_hour;   monitor  Infected people rate  value: infected_rate;   display map {    species road aspect:geom;    species building aspect:geom;    species people aspect:circle;      }   display chart refresh: every(10) {    chart  Disease spreading  type: series {     data  susceptible  value: nb_people_not_infected color: #green;     data  infected  value: nb_people_infected color: #red;    }   }  } }     ","url":"wiki/Incremental-Model-Incremental-Model-3.md"},{"id":"wiki/Incremental-Model-Incremental-Model-4.md","title":" Movement on Graph","content":"# Movement on Graph  4th part of the tutorial : Incremental Model  Code of the model :       model model4  global {  int nb_people <- 500;  float step <- 1 #minutes;  float infection_distance <- 2.0 #m;   float proba_infection <- 0.05;  int nb_infected_init <- 5;  file roads_shapefile <- file( ../includes/road.shp );  file buildings_shapefile <- file( ../includes/building.shp );  geometry shape <- envelope(roads_shapefile);  int current_hour update: (cycle / 60) mod 24;  graph road_network;  float staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));  int nb_people_infected <- nb_infected_init update: people count (each.is_infected);  int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;  float infected_rate update: nb_people_infected/length(people); init {  create road from: roads_shapefile;  road_network <- as_edge_graph(road);  create building from: buildings_shapefile;   create people number:nb_people {   speed <- 5.0 #km/#h;   building bd <- one_of(building);    location <- any_location_in(bd);  }  ask nb_infected_init among people {   is_infected <- true;  } } reflex end_simulation when: infected_rate = 1.0 {  do halt; }   }   species people skills:[moving]{    bool is_infected <- false;  point target;  int staying_counter;  reflex staying when: target = nil {   staying_counter <- staying_counter + 1;   if flip(staying_counter / staying_coeff) {    target <- any_location_in (one_of(building));   }  }  reflex move when: target != nil{  do goto target:target on: road_network;  if (location = target) {   target <- nil;   staying_counter <- 0;  }  } reflex infect when: is_infected{  ask people at_distance infection_distance {   if flip(proba_infection) {    is_infected <- true;   }  } } aspect circle{  draw circle(5) color:is_infected ? #red : #green; } }   species road {  aspect geom {   draw shape color: #black;  } }  species building {  aspect geom {   draw shape color: #gray;  } }  experiment main_experiment type:gui{  parameter  Infection distance  var: infection_distance;  parameter  Proba infection  var: proba_infection min: 0.0 max: 1.0;  parameter  Nb people infected at init  var: nb_infected_init ;  output {   monitor  Current hour  value: current_hour;   monitor  Infected people rate  value: infected_rate;   display map {    species road aspect:geom;    species building aspect:geom;    species people aspect:circle;      }   display chart refresh: every(10) {    chart  Disease spreading  type: series {     data  susceptible  value: nb_people_not_infected color: #green;     data  infected  value: nb_people_infected color: #red;    }   }  } }     ","url":"wiki/Incremental-Model-Incremental-Model-4.md"},{"id":"wiki/Incremental-Model-Incremental-Model-5.md","title":" 3D visualization","content":"# 3D visualization  5th part of the tutorial : Incremental Model  Code of the model :       model model5  global {  int nb_people <- 500;  float step <- 1 #minutes;  float infection_distance <- 2.0 #m;  float proba_infection <- 0.05;  int nb_infected_init <- 5;  file roads_shapefile <- file( ../includes/road.shp );  file buildings_shapefile <- file( ../includes/building.shp );  geometry shape <- envelope(roads_shapefile);  graph road_network;  int current_hour update: (cycle / 60) mod 24;  float staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));  int nb_people_infected <- nb_infected_init update: people count (each.is_infected);  int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;  bool is_night <- true update: current_hour < 7 or current_hour > 20;  float infected_rate update: nb_people_infected/length(people); init {  create road from: roads_shapefile;  road_network <- as_edge_graph(road);  create building from: buildings_shapefile;  create people number:nb_people {   speed <- 5.0 #km/#h;   building bd <- one_of(building);   location <- any_location_in(bd);  }  ask nb_infected_init among people {   is_infected <- true;  } } reflex end_simulation when: infected_rate = 1.0 {  do halt; } }   species people skills:[moving]{    bool is_infected <- false;  point target;  int staying_counter;  reflex stay when: target = nil {   staying_counter <- staying_counter + 1;   if flip(staying_counter / staying_coeff) {    target <- any_location_in (one_of(building));   }  }  reflex move when: target != nil{  do goto target:target on: road_network;  if (location = target) {   target <- nil;   staying_counter <- 0;  }  } reflex infect when: is_infected{  ask people at_distance infection_distance {   if flip(proba_infection) {    is_infected <- true;   }  } } aspect circle{  draw circle(5) color:is_infected ? #red : #green; } aspect sphere3D{  draw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green; } }   species road {  geometry display_shape <- shape + 2.0;  aspect geom {   draw display_shape color: #black depth: 3.0;  } }  species building skills:[moving] {  float height <- 10#m + rnd(10) #m;  aspect geom {   draw shape color: #gray depth: height;  } }  experiment main_experiment type:gui{  parameter  Infection distance  var: infection_distance;  parameter  Proba infection  var: proba_infection min: 0.0 max: 1.0;  parameter  Nb people infected at init  var: nb_infected_init ;  output {   monitor  Current hour  value: current_hour;   monitor  Infected people rate  value: infected_rate;   display map_3D type: opengl {    light 1 color:(is_night ? 50 : 255) update:true;    image  ../includes/soil.jpg ;    species road aspect:geom;    species people aspect:sphere3D;       species building aspect:geom transparency: 0.5;   }   display chart refresh: every(10) {    chart  Disease spreading  type: series {     data  susceptible  value: nb_people_not_infected color: #green;     data  infected  value: nb_people_infected color: #red;    }   }  } }     ","url":"wiki/Incremental-Model-Incremental-Model-5.md"},{"id":"wiki/Incremental-Model-Incremental-Model-6.md","title":" Multi-level","content":"# Multi-level  6th part of the tutorial : Incremental Model  Code of the model :       model model6  global  {  int nb_people <- 500;  float step <- 1 #minutes;  float infection_distance <- 2.0 #m;  float proba_infection <- 0.05;  int nb_infected_init <- 5;  file roads_shapefile <- file( ../includes/road.shp );  file buildings_shapefile <- file( ../includes/building.shp );  geometry shape <- envelope(roads_shapefile);  graph road_network;  int current_hour update: (cycle / 60) mod 24;  float staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));  list<people_in_building> list_people_in_buildings update: (building accumulate each.people_inside) where (not dead(each)); int nb_people_infected <- nb_infected_init update: people count (each.is_infected) + (empty(list_people_in_buildings) ? 0 : list_people_in_buildings count (each.is_infected));  int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected; bool is_night <- true update: current_hour < 7 or current_hour > 20;  float infected_rate update: nb_people_infected/nb_people; init {  create road from: roads_shapefile;  road_network <- as_edge_graph(road);  create building from: buildings_shapefile;  create people number:nb_people {   speed <- 5.0 #km/#h;   building bd <- one_of(building);   location <- any_location_in(bd);  }  ask nb_infected_init among people {   is_infected <- true;  }   } reflex end_simulation when: infected_rate = 1.0 {    do halt; } }   species people skills:[moving]{    bool is_infected <- false;  point target;  int staying_counter;  reflex move when: target != nil{  do goto target:target on: road_network;  if (location = target) {   target <- any_location_in (one_of(building));   target <- nil;   staying_counter <- 0;  }  } reflex infect when: is_infected{  ask people at_distance infection_distance {   if flip(proba_infection) {    is_infected <- true;   }  } } aspect circle{  draw circle(5) color:is_infected ? #red : #green; } aspect sphere3D{  draw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green; } }   species road {  geometry display_shape <- shape + 2.0;  aspect geom {   draw display_shape color: #black depth: 3.0;  } }  species building {  float height <- 10#m + rnd(10) #m;  list people_inside -> {members collect people_in_building(each)};  aspect geom {  int nbI <- members count people_in_building(each).is_infected;  int nbT <- length(members);  draw shape color:nbT = 0 ? #gray : (float(nbI)/nbT > 0.5 ? #red : #green) depth: height; }  species people_in_building parent: people schedules: [] {  aspect circle{}  aspect sphere3D{} }  reflex let_people_leave  {  ask members as: people_in_building{   staying_counter <- staying_counter + 1;  }  list<people_in_building> leaving_people <- list<people_in_building>(members where (flip(people_in_building(each).staying_counter / staying_coeff)));  if not (empty (leaving_people)) {   release leaving_people as: people in: world returns: released_people;   ask released_people {    target <- any_location_in (one_of(building));   }  } } reflex let_people_enter {  list<people> entering_people <- people inside self where (each.target = nil);  if not (empty (entering_people)) {   capture entering_people as: people_in_building ;    } } }   experiment main_experiment type:gui{  parameter  Infection distance  var: infection_distance;  parameter  Proba infection  var: proba_infection min: 0.0 max: 1.0;  parameter  Nb people infected at init  var: nb_infected_init ;  output {   monitor  Current hour  value: current_hour;   monitor  Infected people rate  value: infected_rate;   display map_3D type: opengl {    light 1 color:(is_night ? 50 : 255) update:true;    image  ../includes/soil.jpg ;    species road aspect:geom;    species people aspect:sphere3D;       species building aspect:geom transparency: 0.5;   }   display chart refresh: every(10) {    chart  Disease spreading  type: series {     data  susceptible  value: nb_people_not_infected color: #green;     data  infected  value: nb_people_infected color: #red;    }   }  } }     ","url":"wiki/Incremental-Model-Incremental-Model-6.md"},{"id":"wiki/Incremental-Model-Incremental-Model-7.md","title":" Differential Equation","content":"# Differential Equation  7th part of the tutorial : Incremental Model  Code of the model :       model model7  global  {  int nb_people <- 500;  float step <- 1 #minutes;  float infection_distance <- 2.0 #m;  float proba_infection <- 0.05;  int nb_infected_init <- 5;  file roads_shapefile <- file( ../includes/road.shp );  file buildings_shapefile <- file( ../includes/building.shp );  geometry shape <- envelope(roads_shapefile);  graph road_network;  int current_hour update: (cycle / 60) mod 24;  float staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));  float beta <- 0.01;  float h<-0.1;  list list_people_in_buildings update: (building accumulate each.people_inside) where (not dead(each));  int nb_people_infected <- nb_infected_init update: people count (each.is_infected) + (empty(list_people_in_buildings) ? 0 : list_people_in_buildings count (each.is_infected));  int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected; bool is_night <- true update: current_hour < 7 or current_hour > 20;  float infected_rate update: nb_people_infected/nb_people; init {  create road from: roads_shapefile;  road_network <- as_edge_graph(road);  create building from: buildings_shapefile;  create people number:nb_people {   speed <- 5.0 #km/#h;   building bd <- one_of(building);   location <- any_location_in(bd);  }  ask nb_infected_init among people {   is_infected <- true;  }   } reflex end_simulation when: infected_rate = 1.0 {    do halt; } }   species people skills:[moving]{    bool is_infected <- false;  point target;  int staying_counter;  reflex move when: target != nil{  do goto target:target on: road_network;  if (location = target) {   target <- any_location_in (one_of(building));   target <- nil;   staying_counter <- 0;  }  } reflex infect when: is_infected{  ask people at_distance infection_distance {   if flip(proba_infection) {    is_infected <- true;   }  } } aspect circle{  draw circle(5) color:is_infected ? #red : #green; } aspect sphere3D{  draw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green; } }   species road {  geometry display_shape <- shape + 2.0;  aspect geom {   draw display_shape color: #black depth: 3.0;  } }  species building {  float height <- 10#m + rnd(10) #m;  list people_inside -> {members collect people_in_building(each)};  float I;  float S;  float T;     float t;        float I_to1;  aspect geom {  int nbI <- members count people_in_building(each).is_infected;  int nbT <- length(members);  draw shape color:nbT = 0 ? #gray : (float(nbI)/nbT > 0.5 ? #red : #green) depth: height; }  species people_in_building parent: people schedules: [] {  aspect circle{}  aspect sphere3D{} }  reflex let_people_leave  {  ask members as: people_in_building{   staying_counter <- staying_counter + 1;  }  list<people_in_building> leaving_people <- list<people_in_building>(members where (flip(people_in_building(each).staying_counter / staying_coeff)));  if not (empty (leaving_people)) {   release leaving_people as: people in: world returns: released_people;   ask released_people {    target <- any_location_in (one_of(building));   }  } } reflex let_people_enter {  list<people> entering_people <- people inside self where (each.target = nil);  if not (empty (entering_people)) {   capture entering_people as: people_in_building ;    } } equation SIR{   diff(S,t) = (- beta * S * I / T) ;  diff(I,t) = (  beta * S * I / T) ; }  reflex epidemic when: not empty(members){    T <- float(length(members));  list<people_in_building> S_members <- list<people_in_building>(members where not (people_in_building(each).is_infected));  S <- float(length(S_members));  I <- T-S;  float I0 <- I;  if (I > 0 and S > 0) {   solve SIR method: rk4 step: h;   I_to1 <- I_to1 + (I - I0);   int I_int <- min([int(S),int(I_to1)]);      I_to1 <- I_to1 - I_int;      ask(I_int among S_members){       is_infected <- true;      }  } }   }   experiment main_experiment type:gui{  parameter  Infection distance  var: infection_distance;  parameter  Proba infection  var: proba_infection min: 0.0 max: 1.0;  parameter  Nb people infected at init  var: nb_infected_init ;  output {   monitor  Current hour  value: current_hour;   monitor  Infected people rate  value: infected_rate;   display map_3D type: opengl {    light 1 color:(is_night ? 50 : 255) update:true;    image  ../includes/soil.jpg ;    species road aspect:geom;    species people aspect:sphere3D;       species building aspect:geom transparency: 0.5;   }   display chart refresh: every(10) {    chart  Disease spreading  type: series {     data  susceptible  value: nb_people_not_infected color: #green;     data  infected  value: nb_people_infected color: #red;    }   }  } }     ","url":"wiki/Incremental-Model-Incremental-Model-7.md"},{"id":"wiki/Predator-Prey-Model-01.md","title":" Basic model (prey agents)","content":"Basic model (prey agents)  First part of the tutorial : Predator Prey  Code of the model :       model prey_predator  global {  int nb_preys_init <- 200;  init {   create prey number: nb_preys_init ;  } }  species prey {  float size <- 1.0 ;  rgb color <- #blue;  aspect base {  draw circle(size) color: color ; } }    experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init min: 1 max: 1000 category:  Prey  ;  output {   display main_display {    species prey aspect: base ;   }  } }      ","url":"wiki/Predator-Prey-Model-01.md"},{"id":"wiki/Predator-Prey-Model-02.md","title":" Dynamic of the vegetation (grid)","content":"# Dynamic of the vegetation (grid)  Second part of the tutorial : Predator Prey  Code of the model :       model prey_predator  global {  int nb_preys_init <- 200;  init {   create prey number: nb_preys_init ;  } }  species prey {  float size <- 1.0 ;  rgb color <- #blue;  vegetation_cell myCell <- one_of (vegetation_cell) ;  init {  location <- myCell.location; }   aspect base {  draw circle(size) color: color ; } }   grid vegetation_cell width: 50 height: 50 neighbors: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ; }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init min: 1 max: 1000 category:  Prey  ;  output {   display main_display {    grid vegetation_cell lines: #black ;    species prey aspect: base ;   }  } }      ","url":"wiki/Predator-Prey-Model-02.md"},{"id":"wiki/Predator-Prey-Model-03.md","title":" Behavior of the prey agent","content":"Behavior of the prey agent  Third part of the tutorial : Predator Prey  Code of the model :       model prey_predator  global {  int nb_preys_init <- 200;  float prey_max_energy <- 1.0;  float prey_max_transfert <- 0.1;  float prey_energy_consum <- 0.05;  init {  create prey number: nb_preys_init ; } }   species prey {  float size <- 1.0 ;  rgb color <- #blue;  float max_energy <- prey_max_energy ;  float max_transfert <- prey_max_transfert ;  float energy_consum <- prey_energy_consum ;  vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;   init {   location <- myCell.location; }   reflex basic_move {   myCell <- one_of (myCell.neighbours) ;  location <- myCell.location ; } reflex eat when: myCell.food > 0 {   float energy_transfert <- min([max_transfert, myCell.food]) ;  myCell.food <- myCell.food - energy_transfert ;  energy <- energy + energy_transfert ; } reflex die when: energy <= 0 {  do die ; }  aspect base {  draw circle(size) color: color ; } }   grid vegetation_cell width: 50 height: 50 neighbors: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;  list neighbours  <- (self neighbors_at 2); }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init min: 1 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfert:   var: prey_max_transfert  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  output {   display main_display {    grid vegetation_cell lines: #black ;    species prey aspect: base ;   }  } }     ","url":"wiki/Predator-Prey-Model-03.md"},{"id":"wiki/Predator-Prey-Model-04.md","title":" Use of Inspectors/monitors","content":"# Use of Inspectors/monitors  4th part of the tutorial : Predator Prey  Code of the model :       model prey_predator  global {  int nb_preys_init <- 200 ;  float prey_max_energy <- 1.0;  float prey_max_transfert <- 0.1;  float prey_energy_consum <- 0.05;  int nb_preys -> {length (prey)};  init {  create prey number: nb_preys_init ; } } species prey { float size <- 1.0 ; rgb color <- #blue; float max_energy <- prey_max_energy ; float max_transfert <- prey_max_transfert ; float energy_consum <- prey_energy_consum ;   vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;   init {   location <- myCell.location; }   reflex basic_move {   myCell <- one_of (myCell.neighbours) ;  location <- myCell.location ; } reflex eat when: myCell.food > 0 {   float energy_transfert <- min([max_transfert, myCell.food]) ;  myCell.food <- myCell.food - energy_transfert ;  energy <- energy + energy_transfert ; } reflex die when: energy <= 0 {  do die ; }  aspect base {  draw circle(size) color: color ; } }   grid vegetation_cell width: 50 height: 50 neighbors: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;  list neighbours  <- (self neighbors_at 2); }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init min: 1 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfert:   var: prey_max_transfert  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  output {   display main_display {    grid vegetation_cell lines: #black ;    species prey aspect: base ;   }   monitor  Number of preys  value: nb_preys ;  } }     ","url":"wiki/Predator-Prey-Model-04.md"},{"id":"wiki/Predator-Prey-Model-05.md","title":" Predator agents (parent species)","content":"# Predator agents (parent species)  5th part of the tutorial : Predator Prey  Code of the model :       model prey_predator  global {  int nb_preys_init <- 200;  int nb_predators_init <- 20;  float prey_max_energy <- 1.0;  float prey_max_transfert <- 0.1 ;  float prey_energy_consum <- 0.05;  float predator_max_energy <- 1.0;  float predator_energy_transfert <- 0.5;  float predator_energy_consum <- 0.02;  int nb_preys -> {length (prey)};  int nb_predators -> {length (predator)};  init {  create prey number: nb_preys_init ;   create predator number: nb_predators_init ; } }   species generic_species {  float size <- 1.0;  rgb color  ;  float max_energy;  float max_transfert;  float energy_consum;  vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;  init {  location <- myCell.location; }   reflex basic_move {  myCell <- one_of (myCell.neighbours) ;  location <- myCell.location ; }   reflex die when: energy <= 0 {  do die ; }  aspect base {  draw circle(size) color: color ; } }   species prey parent: generic_species {  rgb color <- #blue;  float max_energy <- prey_max_energy ;  float max_transfert <- prey_max_transfert ;  float energy_consum <- prey_energy_consum ;  reflex eat when: myCell.food > 0 {  float energy_transfert <- min([max_transfert, myCell.food]) ;  myCell.food <- myCell.food - energy_transfert ;  energy <- energy + energy_transfert ; } }   species predator parent: generic_species {  rgb color <- #red ;  float max_energy <- predator_max_energy ;  float energy_transfert <- predator_energy_transfert ;  float energy_consum <- predator_energy_consum ;  list reachable_preys update: prey inside (myCell);  reflex eat when: ! empty(reachable_preys) {  ask one_of (reachable_preys) {   do die ;  }  energy <- energy + energy_transfert ; } }   grid vegetation_cell width: 50 height: 50 neighbors: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;  list neighbours  <- (self neighbors_at 2);  }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init  min: 0 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfert:   var: prey_max_transfert  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  parameter  Initial number of predators:   var: nb_predators_init  min: 0 max: 200 category:  Predator  ;  parameter  Predator max energy:   var: predator_max_energy category:  Predator  ;  parameter  Predator energy transfert:   var: predator_energy_transfert  category:  Predator  ;  parameter  Predator energy consumption:   var: predator_energy_consum  category:  Predator  ;  output {  display main_display {   grid vegetation_cell lines: #black ;   species prey aspect: base ;   species predator aspect: base ;  }  monitor Number of preys value: nb_preys;  monitor Number of predators value: nb_predators; } }       ","url":"wiki/Predator-Prey-Model-05.md"},{"id":"wiki/Predator-Prey-Model-06.md","title":" Breeding of prey and predator agents","content":"# Breeding of prey and predator agents  6th part of the tutorial : Predator Prey  Code of the model :       model prey_predator  global {  int nb_preys_init <- 200;  int nb_predators_init <- 20;  float prey_max_energy <- 1.0;  float prey_max_transfert <- 0.1 ;  float prey_energy_consum <- 0.05;  float predator_max_energy <- 1.0;  float predator_energy_transfert <- 0.5;  float predator_energy_consum <- 0.02;  float prey_proba_reproduce <- 0.01;  int prey_nb_max_offsprings <- 5;   float prey_energy_reproduce <- 0.5;   float predator_proba_reproduce <- 0.01;  int predator_nb_max_offsprings <- 3;  float predator_energy_reproduce <- 0.5;  int nb_preys -> {length (prey)}; int nb_predators -> {length (predator)};  init {  create prey number: nb_preys_init ;   create predator number: nb_predators_init ; } }   species generic_species {  float size <- 1.0;  rgb color  ;  float max_energy;  float max_transfert;  float energy_consum;  float proba_reproduce ;  float nb_max_offsprings;  float energy_reproduce;  vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;  init {  location <- myCell.location; }   reflex basic_move {  myCell <- one_of (myCell.neighbours) ;  location <- myCell.location ; }   reflex die when: energy <= 0 {  do die ; }  reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {   int nb_offsprings <-int(1 + rnd(nb_max_offsprings -1));   create species(self) number: nb_offsprings {    myCell <- myself.myCell ;    location <- myCell.location ;    energy <- myself.energy / nb_offsprings ;   }   energy <- energy / nb_offsprings ;  }  aspect base {  draw circle(size) color: color ; } }   species prey parent: generic_species {  rgb color <- #blue;  float max_energy <- prey_max_energy ;  float max_transfert <- prey_max_transfert ;  float energy_consum <- prey_energy_consum ;  float proba_reproduce <- prey_proba_reproduce ;  int nb_max_offsprings <- prey_nb_max_offsprings ;  float energy_reproduce <- prey_energy_reproduce ;  reflex eat when: myCell.food > 0 {  float energy_transfert <- min([max_transfert, myCell.food]) ;  myCell.food <- myCell.food - energy_transfert ;  energy <- energy + energy_transfert ; } }   species predator parent: generic_species {  rgb color <- #red ;  float max_energy <- predator_max_energy ;  float energy_transfert <- predator_energy_transfert ;  float energy_consum <- predator_energy_consum ;  list reachable_preys update: prey inside (myCell);  float proba_reproduce <- predator_proba_reproduce ;  int nb_max_offsprings <- predator_nb_max_offsprings ;  float energy_reproduce <- predator_energy_reproduce ;  reflex eat when: ! empty(reachable_preys) {  ask one_of (reachable_preys) {   do die ;  }  energy <- energy + energy_transfert ; } }   grid vegetation_cell width: 50 height: 50 neighbors: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;  list neighbours  <- (self neighbors_at 2);  }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init  min: 0 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfert:   var: prey_max_transfert  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  parameter  Initial number of predators:   var: nb_predators_init  min: 0 max: 200 category:  Predator  ;  parameter  Predator max energy:   var: predator_max_energy category:  Predator  ;  parameter  Predator energy transfert:   var: predator_energy_transfert  category:  Predator  ;  parameter  Predator energy consumption:   var: predator_energy_consum  category:  Predator  ;  parameter  Prey probability reproduce:   var: prey_proba_reproduce category:  Prey  ;  parameter  Prey nb max offsprings:   var: prey_nb_max_offsprings category:  Prey  ;  parameter  Prey energy reproduce:   var: prey_energy_reproduce category:  Prey  ;  parameter  Predator probability reproduce:   var: predator_proba_reproduce category:  Predator  ;  parameter  Predator nb max offsprings:   var: predator_nb_max_offsprings category:  Predator  ;  parameter  Predator energy reproduce:   var: predator_energy_reproduce category:  Predator  ;  output {  display main_display {   grid vegetation_cell lines: #black ;   species prey aspect: base ;   species predator aspect: base ;  }  monitor Number of preys value: nb_preys;  monitor Number of predators value: nb_predators; } }      ","url":"wiki/Predator-Prey-Model-06.md"},{"id":"wiki/Predator-Prey-Model-07.md","title":" Agent display (aspect)","content":"# Agent display (aspect)  6th part of the tutorial: Predator Prey  Code of the model :       model prey_predator  global {  int nb_preys_init <- 200;  int nb_predators_init <- 20;  float prey_max_energy <- 1.0;  float prey_max_transfert <- 0.1 ;  float prey_energy_consum <- 0.05;  float predator_max_energy <- 1.0;  float predator_energy_transfert <- 0.5;  float predator_energy_consum <- 0.02;  float prey_proba_reproduce <- 0.01;  int prey_nb_max_offsprings <- 5;   float prey_energy_reproduce <- 0.5;   float predator_proba_reproduce <- 0.01;  int predator_nb_max_offsprings <- 3;  float predator_energy_reproduce <- 0.5;  int nb_preys -> {length (prey)}; int nb_predators -> {length (predator)};  init {  create prey number: nb_preys_init ;   create predator number: nb_predators_init ; } }   species generic_species {  float size <- 1.0;  rgb color  ;  float max_energy;  float max_transfert;  float energy_consum;  float proba_reproduce ;  float nb_max_offsprings;  float energy_reproduce;  image_file my_icon;  vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;  init {  location <- myCell.location; }   reflex basic_move {  myCell <- one_of (myCell.neighbours) ;  location <- myCell.location ; }   reflex die when: energy <= 0 {  do die ; }  reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {   int nb_offsprings <- int(1 + rnd(nb_max_offsprings -1));   create species(self) number: nb_offsprings {    myCell <- myself.myCell ;    location <- myCell.location ;    energy <- myself.energy / nb_offsprings ;   }   energy <- energy / nb_offsprings ;  }  aspect base {  draw circle(size) color: color ; } aspect icon {  draw my_icon size: 2 * size ; } aspect info {  draw square(size) color: color ;  draw string(energy with_precision 2) size: 3 color: #black ; } }   species prey parent: generic_species {  rgb color <- #blue;  float max_energy <- prey_max_energy ;  float max_transfert <- prey_max_transfert ;  float energy_consum <- prey_energy_consum ;  float proba_reproduce <- prey_proba_reproduce ;  int nb_max_offsprings <- prey_nb_max_offsprings ;  float energy_reproduce <- prey_energy_reproduce ;  file my_icon <- file( ../includes/data/sheep.png ) ;  reflex eat when: myCell.food > 0 {  float energy_transfert <- min([max_transfert, myCell.food]) ;  myCell.food <- myCell.food - energy_transfert ;  energy <- energy + energy_transfert ; } }   species predator parent: generic_species {  rgb color <- #red ;  float max_energy <- predator_max_energy ;  float energy_transfert <- predator_energy_transfert ;  float energy_consum <- predator_energy_consum ;  list reachable_preys update: prey inside (myCell);  float proba_reproduce <- predator_proba_reproduce ;  int nb_max_offsprings <- predator_nb_max_offsprings ;  float energy_reproduce <- predator_energy_reproduce ;  file my_icon <- file(../includes/data/wolf.png) ;  reflex eat when: ! empty(reachable_preys) {  ask one_of (reachable_preys) {   do die ;  }  energy <- energy + energy_transfert ; } }   grid vegetation_cell width: 50 height: 50 neighbors: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;  list neighbours  <- (self neighbors_at 2);  }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init  min: 0 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfert:   var: prey_max_transfert  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  parameter  Initial number of predators:   var: nb_predators_init  min: 0 max: 200 category:  Predator  ;  parameter  Predator max energy:   var: predator_max_energy category:  Predator  ;  parameter  Predator energy transfert:   var: predator_energy_transfert  category:  Predator  ;  parameter  Predator energy consumption:   var: predator_energy_consum  category:  Predator  ;  parameter  Prey probability reproduce:   var: prey_proba_reproduce category:  Prey  ;  parameter  Prey nb max offsprings:   var: prey_nb_max_offsprings category:  Prey  ;  parameter  Prey energy reproduce:   var: prey_energy_reproduce category:  Prey  ;  parameter  Predator probability reproduce:   var: predator_proba_reproduce category:  Predator  ;  parameter  Predator nb max offsprings:   var: predator_nb_max_offsprings category:  Predator  ;  parameter  Predator energy reproduce:   var: predator_energy_reproduce category:  Predator  ;  output {  display main_display {   grid vegetation_cell lines: #black ;   species prey aspect: icon ;   species predator aspect: icon ;  }  display info_display {   grid vegetation_cell lines: #black ;   species prey aspect: info ;   species predator aspect: info ;  }  monitor Number of preys value: nb_preys;  monitor Number of predators value: nb_predators; } }      ","url":"wiki/Predator-Prey-Model-07.md"},{"id":"wiki/Predator-Prey-Model-08.md","title":" Complex behaviors for the preys and predators","content":"# Complex behaviors for the preys and predators  8th part of the tutorial: Predator Prey  Code of the model :       model prey_predator  global {  int nb_preys_init <- 200;  int nb_predators_init <- 20;  float prey_max_energy <- 1.0;  float prey_max_transfert <- 0.1 ;  float prey_energy_consum <- 0.05;  float predator_max_energy <- 1.0;  float predator_energy_transfert <- 0.5;  float predator_energy_consum <- 0.02;  float prey_proba_reproduce <- 0.01;  int prey_nb_max_offsprings <- 5;   float prey_energy_reproduce <- 0.5;   float predator_proba_reproduce <- 0.01;  int predator_nb_max_offsprings <- 3;  float predator_energy_reproduce <- 0.5;  int nb_preys -> {length (prey)}; int nb_predators -> {length (predator)};  init {  create prey number: nb_preys_init ;   create predator number: nb_predators_init ; } }   species generic_species {  float size <- 1.0;  rgb color  ;  float max_energy;  float max_transfert;  float energy_consum;  float proba_reproduce ;  float nb_max_offsprings;  float energy_reproduce;  image_file my_icon;  vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;  init {  location <- myCell.location; }   reflex basic_move {   myCell <- choose_cell();   location <- myCell.location;  }   vegetation_cell choose_cell {  return nil; }   reflex die when: energy <= 0 {  do die ; }  reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {   int nb_offsprings <- int(1 + rnd(nb_max_offsprings -1));   create species(self) number: nb_offsprings {    myCell <- myself.myCell ;    location <- myCell.location ;    energy <- myself.energy / nb_offsprings ;   }   energy <- energy / nb_offsprings ;  }  aspect base {  draw circle(size) color: color ; } aspect icon {  draw my_icon size: 2 * size ; } aspect info {  draw square(size) color: color ;  draw string(energy with_precision 2) size: 3 color: #black ; } }   species prey parent: generic_species {  rgb color <- #blue;  float max_energy <- prey_max_energy ;  float max_transfert <- prey_max_transfert ;  float energy_consum <- prey_energy_consum ;  float proba_reproduce <- prey_proba_reproduce ;  int nb_max_offsprings <- prey_nb_max_offsprings ;  float energy_reproduce <- prey_energy_reproduce ;  file my_icon <- file( ../includes/data/sheep.png ) ;  reflex eat when: myCell.food > 0 {  float energy_transfert <- min([max_transfert, myCell.food]) ;  myCell.food <- myCell.food - energy_transfert ;  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  return (myCell.neighbours) with_max_of (each.food); } }   species predator parent: generic_species {  rgb color <- #red ;  float max_energy <- predator_max_energy ;  float energy_transfert <- predator_energy_transfert ;  float energy_consum <- predator_energy_consum ;  list reachable_preys update: prey inside (myCell);  float proba_reproduce <- predator_proba_reproduce ;  int nb_max_offsprings <- predator_nb_max_offsprings ;  float energy_reproduce <- predator_energy_reproduce ;  file my_icon <- file(../includes/data/wolf.png) ;  reflex eat when: ! empty(reachable_preys) {  ask one_of (reachable_preys) {   do die ;  }  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  vegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));  if myCell_tmp != nil {   return myCell_tmp;  } else {   return one_of (myCell.neighbours);  }  } }   grid vegetation_cell width: 50 height: 50 neighbors: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;  list neighbours  <- (self neighbors_at 2);  }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init  min: 0 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfert:   var: prey_max_transfert  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  parameter  Initial number of predators:   var: nb_predators_init  min: 0 max: 200 category:  Predator  ;  parameter  Predator max energy:   var: predator_max_energy category:  Predator  ;  parameter  Predator energy transfert:   var: predator_energy_transfert  category:  Predator  ;  parameter  Predator energy consumption:   var: predator_energy_consum  category:  Predator  ;  parameter  Prey probability reproduce:   var: prey_proba_reproduce category:  Prey  ;  parameter  Prey nb max offsprings:   var: prey_nb_max_offsprings category:  Prey  ;  parameter  Prey energy reproduce:   var: prey_energy_reproduce category:  Prey  ;  parameter  Predator probability reproduce:   var: predator_proba_reproduce category:  Predator  ;  parameter  Predator nb max offsprings:   var: predator_nb_max_offsprings category:  Predator  ;  parameter  Predator energy reproduce:   var: predator_energy_reproduce category:  Predator  ;  output {  display main_display {   grid vegetation_cell lines: #black ;   species prey aspect: icon ;   species predator aspect: icon ;  }  display info_display {   grid vegetation_cell lines: #black ;   species prey aspect: info ;   species predator aspect: info ;  }  monitor Number of preys value: nb_preys;  monitor Number of predators value: nb_predators; } }      ","url":"wiki/Predator-Prey-Model-08.md"},{"id":"wiki/Predator-Prey-Model-09.md","title":" Adding of a stopping condition","content":"# Adding of a stopping condition  9th part of the tutorial: Predator Prey  Code of the model :       model prey_predator  global {  int nb_preys_init <- 200;  int nb_predators_init <- 20;  float prey_max_energy <- 1.0;  float prey_max_transfert <- 0.1 ;  float prey_energy_consum <- 0.05;  float predator_max_energy <- 1.0;  float predator_energy_transfert <- 0.5;  float predator_energy_consum <- 0.02;  float prey_proba_reproduce <- 0.01;  int prey_nb_max_offsprings <- 5;   float prey_energy_reproduce <- 0.5;   float predator_proba_reproduce <- 0.01;  int predator_nb_max_offsprings <- 3;  float predator_energy_reproduce <- 0.5;  int nb_preys -> {length (prey)}; int nb_predators -> {length (predator)};  init {  create prey number: nb_preys_init ;   create predator number: nb_predators_init ; }  reflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {  do halt ; }  }   species generic_species {  float size <- 1.0;  rgb color  ;  float max_energy;  float max_transfert;  float energy_consum;  float proba_reproduce ;  float nb_max_offsprings;  float energy_reproduce;  image_file my_icon;  vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;  init {  location <- myCell.location; }   reflex basic_move {   myCell <- choose_cell();   location <- myCell.location;  }   vegetation_cell choose_cell {  return nil; }   reflex die when: energy <= 0 {  do die ; }  reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {   int nb_offsprings <- int(1 + rnd(nb_max_offsprings -1));   create species(self) number: nb_offsprings {    myCell <- myself.myCell ;    location <- myCell.location ;    energy <- myself.energy / nb_offsprings ;   }   energy <- energy / nb_offsprings ;  }  aspect base {  draw circle(size) color: color ; } aspect icon {  draw my_icon size: 2 * size ; } aspect info {  draw square(size) color: color ;  draw string(energy with_precision 2) size: 3 color: #black ; } }   species prey parent: generic_species {  rgb color <- #blue;  float max_energy <- prey_max_energy ;  float max_transfert <- prey_max_transfert ;  float energy_consum <- prey_energy_consum ;  float proba_reproduce <- prey_proba_reproduce ;  int nb_max_offsprings <- prey_nb_max_offsprings ;  float energy_reproduce <- prey_energy_reproduce ;  file my_icon <- file( ../includes/data/sheep.png ) ;  reflex eat when: myCell.food > 0 {  float energy_transfert <- min([max_transfert, myCell.food]) ;  myCell.food <- myCell.food - energy_transfert ;  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  return (myCell.neighbours) with_max_of (each.food); } }   species predator parent: generic_species {  rgb color <- #red ;  float max_energy <- predator_max_energy ;  float energy_transfert <- predator_energy_transfert ;  float energy_consum <- predator_energy_consum ;  list reachable_preys update: prey inside (myCell);  float proba_reproduce <- predator_proba_reproduce ;  int nb_max_offsprings <- predator_nb_max_offsprings ;  float energy_reproduce <- predator_energy_reproduce ;  file my_icon <- file(../includes/data/wolf.png) ;  reflex eat when: ! empty(reachable_preys) {  ask one_of (reachable_preys) {   do die ;  }  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  vegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));  if myCell_tmp != nil {   return myCell_tmp;  } else {   return one_of (myCell.neighbours);  }  } }   grid vegetation_cell width: 50 height: 50 neighbors: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;  list neighbours  <- (self neighbors_at 2);  }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init  min: 0 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfert:   var: prey_max_transfert  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  parameter  Initial number of predators:   var: nb_predators_init  min: 0 max: 200 category:  Predator  ;  parameter  Predator max energy:   var: predator_max_energy category:  Predator  ;  parameter  Predator energy transfert:   var: predator_energy_transfert  category:  Predator  ;  parameter  Predator energy consumption:   var: predator_energy_consum  category:  Predator  ;  parameter  Prey probability reproduce:   var: prey_proba_reproduce category:  Prey  ;  parameter  Prey nb max offsprings:   var: prey_nb_max_offsprings category:  Prey  ;  parameter  Prey energy reproduce:   var: prey_energy_reproduce category:  Prey  ;  parameter  Predator probability reproduce:   var: predator_proba_reproduce category:  Predator  ;  parameter  Predator nb max offsprings:   var: predator_nb_max_offsprings category:  Predator  ;  parameter  Predator energy reproduce:   var: predator_energy_reproduce category:  Predator  ;  output {  display main_display {   grid vegetation_cell lines: #black ;   species prey aspect: icon ;   species predator aspect: icon ;  }  display info_display {   grid vegetation_cell lines: #black ;   species prey aspect: info ;   species predator aspect: info ;  }  monitor Number of preys value: nb_preys;  monitor Number of predators value: nb_predators; } }      ","url":"wiki/Predator-Prey-Model-09.md"},{"id":"wiki/Predator-Prey-Model-10.md","title":" Definition of charts","content":"# Definition of charts  10th part of the tutorial: Predator Prey  Code of the model :       model prey_predator  global {  int nb_preys_init <- 200;  int nb_predators_init <- 20;  float prey_max_energy <- 1.0;  float prey_max_transfert <- 0.1 ;  float prey_energy_consum <- 0.05;  float predator_max_energy <- 1.0;  float predator_energy_transfert <- 0.5;  float predator_energy_consum <- 0.02;  float prey_proba_reproduce <- 0.01;  int prey_nb_max_offsprings <- 5;   float prey_energy_reproduce <- 0.5;   float predator_proba_reproduce <- 0.01;  int predator_nb_max_offsprings <- 3;  float predator_energy_reproduce <- 0.5;  int nb_preys -> {length (prey)}; int nb_predators -> {length (predator)};  init {  create prey number: nb_preys_init ;   create predator number: nb_predators_init ; }  reflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {  do halt ; }  }   species generic_species {  float size <- 1.0;  rgb color  ;  float max_energy;  float max_transfert;  float energy_consum;  float proba_reproduce ;  float nb_max_offsprings;  float energy_reproduce;  image_file my_icon;  vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;  init {  location <- myCell.location; }    reflex basic_move {   myCell <- choose_cell();   location <- myCell.location;  }   vegetation_cell choose_cell {  return nil; }   reflex die when: energy <= 0 {  do die ; }  reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {   int nb_offsprings <- int(1 + rnd(nb_max_offsprings -1));   create species(self) number: nb_offsprings {    myCell <- myself.myCell ;    location <- myCell.location ;    energy <- myself.energy / nb_offsprings ;   }   energy <- energy / nb_offsprings ;  }  aspect base {  draw circle(size) color: color ; } aspect icon {  draw my_icon size: 2 * size ; } aspect info {  draw square(size) color: color ;  draw string(energy with_precision 2) size: 3 color: #black ; } }   species prey parent: generic_species {  rgb color <- #blue;  float max_energy <- prey_max_energy ;  float max_transfert <- prey_max_transfert ;  float energy_consum <- prey_energy_consum ;  float proba_reproduce <- prey_proba_reproduce ;  int nb_max_offsprings <- prey_nb_max_offsprings ;  float energy_reproduce <- prey_energy_reproduce ;  file my_icon <- file( ../includes/data/sheep.png ) ;  reflex eat when: myCell.food > 0 {  float energy_transfert <- min([max_transfert, myCell.food]) ;  myCell.food <- myCell.food - energy_transfert ;  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  return (myCell.neighbours) with_max_of (each.food); } }   species predator parent: generic_species {  rgb color <- #red ;  float max_energy <- predator_max_energy ;  float energy_transfert <- predator_energy_transfert ;  float energy_consum <- predator_energy_consum ;  list reachable_preys update: prey inside (myCell);  float proba_reproduce <- predator_proba_reproduce ;  int nb_max_offsprings <- predator_nb_max_offsprings ;  float energy_reproduce <- predator_energy_reproduce ;  file my_icon <- file(../includes/data/wolf.png) ;  reflex eat when: ! empty(reachable_preys) {  ask one_of (reachable_preys) {   do die ;  }  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  vegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));  if myCell_tmp != nil {   return myCell_tmp;  } else {   return one_of (myCell.neighbours);  }  } }   grid vegetation_cell width: 50 height: 50 neighbors: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;  list neighbours  <- (self neighbors_at 2);  }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init  min: 0 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfert:   var: prey_max_transfert  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  parameter  Initial number of predators:   var: nb_predators_init  min: 0 max: 200 category:  Predator  ;  parameter  Predator max energy:   var: predator_max_energy category:  Predator  ;  parameter  Predator energy transfert:   var: predator_energy_transfert  category:  Predator  ;  parameter  Predator energy consumption:   var: predator_energy_consum  category:  Predator  ;  parameter  Prey probability reproduce:   var: prey_proba_reproduce category:  Prey  ;  parameter  Prey nb max offsprings:   var: prey_nb_max_offsprings category:  Prey  ;  parameter  Prey energy reproduce:   var: prey_energy_reproduce category:  Prey  ;  parameter  Predator probability reproduce:   var: predator_proba_reproduce category:  Predator  ;  parameter  Predator nb max offsprings:   var: predator_nb_max_offsprings category:  Predator  ;  parameter  Predator energy reproduce:   var: predator_energy_reproduce category:  Predator  ;  output {  display main_display {   grid vegetation_cell lines: #black ;   species prey aspect: icon ;   species predator aspect: icon ;  }  display info_display {   grid vegetation_cell lines: #black ;   species prey aspect: info ;   species predator aspect: info ;  }  display Population_information refresh: every(5) {   chart Species evolution type: series size: {1,0.5} position: {0, 0} {    data number_of_preys value: nb_preys color: #blue ;    data number_of_predator value: nb_predators color: #red ;   }   chart Prey Energy Distribution type: histogram background: #lightgray size: {0.5,0.5} position: {0, 0.5} {    data ]0;0.25] value: prey count (each.energy <= 0.25) color:#blue;    data ]0.25;0.5] value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;    data ]0.5;0.75] value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;    data ]0.75;1] value: prey count (each.energy > 0.75) color:#blue;   }   chart Predator Energy Distribution type: histogram background: #lightgray size: {0.5,0.5} position: {0.5, 0.5} {    data ]0;0.25] value: predator count (each.energy <= 0.25) color: #red ;    data ]0.25;0.5] value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red ;    data ]0.5;0.75] value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red ;    data ]0.75;1] value: predator count (each.energy > 0.75) color: #red;   }  }  monitor Number of preys value: nb_preys;  monitor Number of predators value: nb_predators; } }      ","url":"wiki/Predator-Prey-Model-10.md"},{"id":"wiki/Predator-Prey-Model-11.md","title":" Writing files","content":"# Writing files  11th part of the tutorial: Predator Prey  Code of the model :       model prey_predator  global {  int nb_preys_init <- 200;  int nb_predators_init <- 20;  float prey_max_energy <- 1.0;  float prey_max_transfert <- 0.1 ;  float prey_energy_consum <- 0.05;  float predator_max_energy <- 1.0;  float predator_energy_transfert <- 0.5;  float predator_energy_consum <- 0.02;  float prey_proba_reproduce <- 0.01;  int prey_nb_max_offsprings <- 5;   float prey_energy_reproduce <- 0.5;   float predator_proba_reproduce <- 0.01;  int predator_nb_max_offsprings <- 3;  float predator_energy_reproduce <- 0.5;  int nb_preys -> {length (prey)}; int nb_predators -> {length (predator)};  init {  create prey number: nb_preys_init ;   create predator number: nb_predators_init ; }  reflex save_result when: (nb_preys > 0) and (nb_predators > 0){  save (cycle: + cycle + ; nbPreys:  + nb_preys   + ; minEnergyPreys:  + ((prey as list) min_of each.energy)   + ; maxSizePreys:  + ((prey as list) max_of each.energy)       + ; nbPredators:  + nb_predators       + ; minEnergyPredators:  + ((predator as list) min_of each.energy)      + ; maxSizePredators:  + ((predator as list) max_of each.energy))       to: results.txt type: text ; }  reflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {  do halt ; }  }   species generic_species {  float size <- 1.0;  rgb color  ;  float max_energy;  float max_transfert;  float energy_consum;  float proba_reproduce ;  float nb_max_offsprings;  float energy_reproduce;  image_file my_icon;  vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;  init {  location <- myCell.location; }   reflex basic_move {   myCell <- choose_cell();   location <- myCell.location;  }   vegetation_cell choose_cell {  return nil; }   reflex die when: energy <= 0 {  do die ; }  reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {   int nb_offsprings <- int(1 + rnd(nb_max_offsprings -1));   create species(self) number: nb_offsprings {    myCell <- myself.myCell ;    location <- myCell.location ;    energy <- myself.energy / nb_offsprings ;   }   energy <- energy / nb_offsprings ;  }  aspect base {  draw circle(size) color: color ; } aspect icon {  draw my_icon size: 2 * size ; } aspect info {  draw square(size) color: color ;  draw string(energy with_precision 2) size: 3 color: #black ; } }   species prey parent: generic_species {  rgb color <- #blue;  float max_energy <- prey_max_energy ;  float max_transfert <- prey_max_transfert ;  float energy_consum <- prey_energy_consum ;  float proba_reproduce <- prey_proba_reproduce ;  int nb_max_offsprings <- prey_nb_max_offsprings ;  float energy_reproduce <- prey_energy_reproduce ;  file my_icon <- file( ../includes/data/sheep.png ) ;  reflex eat when: myCell.food > 0 {  float energy_transfert <- min([max_transfert, myCell.food]) ;  myCell.food <- myCell.food - energy_transfert ;  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  return (myCell.neighbours) with_max_of (each.food); } }   species predator parent: generic_species {  rgb color <- #red ;  float max_energy <- predator_max_energy ;  float energy_transfert <- predator_energy_transfert ;  float energy_consum <- predator_energy_consum ;  list reachable_preys update: prey inside (myCell);  float proba_reproduce <- predator_proba_reproduce ;  int nb_max_offsprings <- predator_nb_max_offsprings ;  float energy_reproduce <- predator_energy_reproduce ;  file my_icon <- file(../includes/data/wolf.png) ;  reflex eat when: ! empty(reachable_preys) {  ask one_of (reachable_preys) {   do die ;  }  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  vegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));  if myCell_tmp != nil {   return myCell_tmp;  } else {   return one_of (myCell.neighbours);  }  } }   grid vegetation_cell width: 50 height: 50 neighbors: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;  list neighbours  <- (self neighbors_at 2);  }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init  min: 0 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfert:   var: prey_max_transfert  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  parameter  Initial number of predators:   var: nb_predators_init  min: 0 max: 200 category:  Predator  ;  parameter  Predator max energy:   var: predator_max_energy category:  Predator  ;  parameter  Predator energy transfert:   var: predator_energy_transfert  category:  Predator  ;  parameter  Predator energy consumption:   var: predator_energy_consum  category:  Predator  ;  parameter  Prey probability reproduce:   var: prey_proba_reproduce category:  Prey  ;  parameter  Prey nb max offsprings:   var: prey_nb_max_offsprings category:  Prey  ;  parameter  Prey energy reproduce:   var: prey_energy_reproduce category:  Prey  ;  parameter  Predator probability reproduce:   var: predator_proba_reproduce category:  Predator  ;  parameter  Predator nb max offsprings:   var: predator_nb_max_offsprings category:  Predator  ;  parameter  Predator energy reproduce:   var: predator_energy_reproduce category:  Predator  ;  output {  display main_display {   grid vegetation_cell lines: #black ;   species prey aspect: icon ;   species predator aspect: icon ;  }  display info_display {   grid vegetation_cell lines: #black ;   species prey aspect: info ;   species predator aspect: info ;  }  display Population_information refresh: every(5) {   chart Species evolution type: series size: {1,0.5} position: {0, 0} {    data number_of_preys value: nb_preys color: #blue ;    data number_of_predator value: nb_predators color: #red ;   }   chart Prey Energy Distribution type: histogram background: #lightgray size: {0.5,0.5} position: {0, 0.5} {    data ]0;0.25] value: prey count (each.energy <= 0.25) color:#blue;    data ]0.25;0.5] value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;    data ]0.5;0.75] value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;    data ]0.75;1] value: prey count (each.energy > 0.75) color:#blue;   }   chart Predator Energy Distribution type: histogram background: #lightgray size: {0.5,0.5} position: {0.5, 0.5} {    data ]0;0.25] value: predator count (each.energy <= 0.25) color: #red ;    data ]0.25;0.5] value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red ;    data ]0.5;0.75] value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red ;    data ]0.75;1] value: predator count (each.energy > 0.75) color: #red;   }  }  monitor Number of preys value: nb_preys;  monitor Number of predators value: nb_predators; } }      ","url":"wiki/Predator-Prey-Model-11.md"},{"id":"wiki/Predator-Prey-Model-12.md","title":" Image loading (raster data)","content":"# Image loading (raster data)  12th part of the tutorial: Predator Prey  Code of the model :       model prey_predator  global {  int nb_preys_init <- 200;  int nb_predators_init <- 20;  float prey_max_energy <- 1.0;  float prey_max_transfert <- 0.1 ;  float prey_energy_consum <- 0.05;  float predator_max_energy <- 1.0;  float predator_energy_transfert <- 0.5;  float predator_energy_consum <- 0.02;  float prey_proba_reproduce <- 0.01;  int prey_nb_max_offsprings <- 5;   float prey_energy_reproduce <- 0.5;   float predator_proba_reproduce <- 0.01;  int predator_nb_max_offsprings <- 3;  float predator_energy_reproduce <- 0.5;  file map_init <- image_file( ../includes/data/raster_map.png );  int nb_preys -> {length (prey)}; int nb_predators -> {length (predator)};  init {  create prey number: nb_preys_init ;   create predator number: nb_predators_init ;  ask vegetation_cell {   color <- rgb (map_init at {grid_x,grid_y}) ;   food <- 1 - (((color as list) at 0) / 255) ;   foodProd <- food / 100 ;   } }  reflex save_result when: (nb_preys > 0) and (nb_predators > 0){  save (cycle: + cycle + ; nbPreys:  + nb_preys   + ; minEnergyPreys:  + ((prey as list) min_of each.energy)   + ; maxSizePreys:  + ((prey as list) max_of each.energy)       + ; nbPredators:  + nb_predators       + ; minEnergyPredators:  + ((predator as list) min_of each.energy)      + ; maxSizePredators:  + ((predator as list) max_of each.energy))       to: results.txt type: text ; }  reflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {  do halt ; }  }   species generic_species {  float size <- 1.0;  rgb color  ;  float max_energy;  float max_transfert;  float energy_consum;  float proba_reproduce ;  float nb_max_offsprings;  float energy_reproduce;  image_file my_icon;  vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;  init {  location <- myCell.location; }   reflex basic_move {   myCell <- choose_cell();   location <- myCell.location;  }   vegetation_cell choose_cell {  return nil; }   reflex die when: energy <= 0 {  do die ; }  reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {   int nb_offsprings <- int(1 + rnd(nb_max_offsprings -1));   create species(self) number: nb_offsprings {    myCell <- myself.myCell ;    location <- myCell.location ;    energy <- myself.energy / nb_offsprings ;   }   energy <- energy / nb_offsprings ;  }  aspect base {  draw circle(size) color: color ; } aspect icon {  draw my_icon size: 2 * size ; } aspect info {  draw square(size) color: color ;  draw string(energy with_precision 2) size: 3 color: #black ; } }   species prey parent: generic_species {  rgb color <- #blue;  float max_energy <- prey_max_energy ;  float max_transfert <- prey_max_transfert ;  float energy_consum <- prey_energy_consum ;  float proba_reproduce <- prey_proba_reproduce ;  int nb_max_offsprings <- prey_nb_max_offsprings ;  float energy_reproduce <- prey_energy_reproduce ;  file my_icon <- file( ../includes/data/sheep.png ) ;  reflex eat when: myCell.food > 0 {  float energy_transfert <- min([max_transfert, myCell.food]) ;  myCell.food <- myCell.food - energy_transfert ;  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  return (myCell.neighbours) with_max_of (each.food); } }   species predator parent: generic_species {  rgb color <- #red ;  float max_energy <- predator_max_energy ;  float energy_transfert <- predator_energy_transfert ;  float energy_consum <- predator_energy_consum ;  list reachable_preys update: prey inside (myCell);  float proba_reproduce <- predator_proba_reproduce ;  int nb_max_offsprings <- predator_nb_max_offsprings ;  float energy_reproduce <- predator_energy_reproduce ;  file my_icon <- file(../includes/data/wolf.png) ;  reflex eat when: ! empty(reachable_preys) {  ask one_of (reachable_preys) {   do die ;  }  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  vegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));  if myCell_tmp != nil {   return myCell_tmp;  } else {   return one_of (myCell.neighbours);  }  } }   grid vegetation_cell width: 50 height: 50 neighbors: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;  list neighbours  <- (self neighbors_at 2);  }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init  min: 0 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfert:   var: prey_max_transfert  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  parameter  Initial number of predators:   var: nb_predators_init  min: 0 max: 200 category:  Predator  ;  parameter  Predator max energy:   var: predator_max_energy category:  Predator  ;  parameter  Predator energy transfert:   var: predator_energy_transfert  category:  Predator  ;  parameter  Predator energy consumption:   var: predator_energy_consum  category:  Predator  ;  parameter  Prey probability reproduce:   var: prey_proba_reproduce category:  Prey  ;  parameter  Prey nb max offsprings:   var: prey_nb_max_offsprings category:  Prey  ;  parameter  Prey energy reproduce:   var: prey_energy_reproduce category:  Prey  ;  parameter  Predator probability reproduce:   var: predator_proba_reproduce category:  Predator  ;  parameter  Predator nb max offsprings:   var: predator_nb_max_offsprings category:  Predator  ;  parameter  Predator energy reproduce:   var: predator_energy_reproduce category:  Predator  ;  output {  display main_display {   grid vegetation_cell lines: #black ;   species prey aspect: icon ;   species predator aspect: icon ;  }  display info_display {   grid vegetation_cell lines: #black ;   species prey aspect: info ;   species predator aspect: info ;  }  display Population_information refresh: every(5) {   chart Species evolution type: series size: {1,0.5} position: {0, 0} {    data number_of_preys value: nb_preys color: #blue ;    data number_of_predator value: nb_predators color: #red ;   }   chart Prey Energy Distribution type: histogram background: #lightgray size: {0.5,0.5} position: {0, 0.5} {    data ]0;0.25] value: prey count (each.energy <= 0.25) color:#blue;    data ]0.25;0.5] value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;    data ]0.5;0.75] value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;    data ]0.75;1] value: prey count (each.energy > 0.75) color:#blue;   }   chart Predator Energy Distribution type: histogram background: #lightgray size: {0.5,0.5} position: {0.5, 0.5} {    data ]0;0.25] value: predator count (each.energy <= 0.25) color: #red ;    data ]0.25;0.5] value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red ;    data ]0.5;0.75] value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red ;    data ]0.75;1] value: predator count (each.energy > 0.75) color: #red;   }  }  monitor Number of preys value: nb_preys;  monitor Number of predators value: nb_predators; } }      ","url":"wiki/Predator-Prey-Model-12.md"},{"id":"wiki/Predator-Prey-Model-13.md","title":" Exploration (batch)","content":"# Exploration (batch)  13th part of the tutorial: Predator Prey  Code of the model :       model prey_predator  global {  int nb_preys_init <- 200;  int nb_predators_init <- 20;  float prey_max_energy <- 1.0;  float prey_max_transfert <- 0.1 ;  float prey_energy_consum <- 0.05;  float predator_max_energy <- 1.0;  float predator_energy_transfert <- 0.5;  float predator_energy_consum <- 0.02;  float prey_proba_reproduce <- 0.01;  int prey_nb_max_offsprings <- 5;   float prey_energy_reproduce <- 0.5;   float predator_proba_reproduce <- 0.01;  int predator_nb_max_offsprings <- 3;  float predator_energy_reproduce <- 0.5;  file map_init <- image_file( ../includes/data/raster_map.png );  int nb_preys -> {length (prey)}; int nb_predators -> {length (predator)};  init {  create prey number: nb_preys_init ;   create predator number: nb_predators_init ;  ask vegetation_cell {   color <- rgb (map_init at {grid_x,grid_y}) ;   food <- 1 - (((color as list) at 0) / 255) ;   foodProd <- food / 100 ;   } }  reflex save_result when: (nb_preys > 0) and (nb_predators > 0){  save (cycle: + cycle + ; nbPreys:  + nb_preys   + ; minEnergyPreys:  + ((prey as list) min_of each.energy)   + ; maxSizePreys:  + ((prey as list) max_of each.energy)       + ; nbPredators:  + nb_predators       + ; minEnergyPredators:  + ((predator as list) min_of each.energy)      + ; maxSizePredators:  + ((predator as list) max_of each.energy))       to: results.txt type: text ; }  reflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {  do halt ; }  }   species generic_species {  float size <- 1.0;  rgb color  ;  float max_energy;  float max_transfert;  float energy_consum;  float proba_reproduce ;  float nb_max_offsprings;  float energy_reproduce;  image_file my_icon;  vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;  init {  location <- myCell.location; }   reflex basic_move {   myCell <- choose_cell();   location <- myCell.location;  }   vegetation_cell choose_cell {  return nil; }   reflex die when: energy <= 0 {  do die ; }  reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {   int nb_offsprings <- int(1 + rnd(nb_max_offsprings -1));   create species(self) number: nb_offsprings {    myCell <- myself.myCell ;    location <- myCell.location ;    energy <- myself.energy / nb_offsprings ;   }   energy <- energy / nb_offsprings ;  }  aspect base {  draw circle(size) color: color ; } aspect icon {  draw my_icon size: 2 * size ; } aspect info {  draw square(size) color: color ;  draw string(energy with_precision 2) size: 3 color: #black ; } }   species prey parent: generic_species {  rgb color <- #blue;  float max_energy <- prey_max_energy ;  float max_transfert <- prey_max_transfert ;  float energy_consum <- prey_energy_consum ;  float proba_reproduce <- prey_proba_reproduce ;  int nb_max_offsprings <- prey_nb_max_offsprings ;  float energy_reproduce <- prey_energy_reproduce ;  file my_icon <- file( ../includes/data/sheep.png ) ;  reflex eat when: myCell.food > 0 {  float energy_transfert <- min([max_transfert, myCell.food]) ;  myCell.food <- myCell.food - energy_transfert ;  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  return (myCell.neighbours) with_max_of (each.food); } }   species predator parent: generic_species {  rgb color <- #red ;  float max_energy <- predator_max_energy ;  float energy_transfert <- predator_energy_transfert ;  float energy_consum <- predator_energy_consum ;  list reachable_preys update: prey inside (myCell);  float proba_reproduce <- predator_proba_reproduce ;  int nb_max_offsprings <- predator_nb_max_offsprings ;  float energy_reproduce <- predator_energy_reproduce ;  file my_icon <- file(../includes/data/wolf.png) ;  reflex eat when: ! empty(reachable_preys) {  ask one_of (reachable_preys) {   do die ;  }  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  vegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));  if myCell_tmp != nil {   return myCell_tmp;  } else {   return one_of (myCell.neighbours);  }  } }   grid vegetation_cell width: 50 height: 50 neighbors: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;  list neighbours  <- (self neighbors_at 2);  }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init  min: 0 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfert:   var: prey_max_transfert  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  parameter  Initial number of predators:   var: nb_predators_init  min: 0 max: 200 category:  Predator  ;  parameter  Predator max energy:   var: predator_max_energy category:  Predator  ;  parameter  Predator energy transfert:   var: predator_energy_transfert  category:  Predator  ;  parameter  Predator energy consumption:   var: predator_energy_consum  category:  Predator  ;  parameter  Prey probability reproduce:   var: prey_proba_reproduce category:  Prey  ;  parameter  Prey nb max offsprings:   var: prey_nb_max_offsprings category:  Prey  ;  parameter  Prey energy reproduce:   var: prey_energy_reproduce category:  Prey  ;  parameter  Predator probability reproduce:   var: predator_proba_reproduce category:  Predator  ;  parameter  Predator nb max offsprings:   var: predator_nb_max_offsprings category:  Predator  ;  parameter  Predator energy reproduce:   var: predator_energy_reproduce category:  Predator  ;  output {  display main_display {   grid vegetation_cell lines: #black ;   species prey aspect: icon ;   species predator aspect: icon ;  }  display info_display {   grid vegetation_cell lines: #black ;   species prey aspect: info ;   species predator aspect: info ;  }  display Population_information refresh: every(5) {   chart Species evolution type: series size: {1,0.5} position: {0, 0} {    data number_of_preys value: nb_preys color: #blue ;    data number_of_predator value: nb_predators color: #red ;   }   chart Prey Energy Distribution type: histogram background: #lightgray size: {0.5,0.5} position: {0, 0.5} {    data ]0;0.25] value: prey count (each.energy <= 0.25) color:#blue;    data ]0.25;0.5] value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;    data ]0.5;0.75] value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;    data ]0.75;1] value: prey count (each.energy > 0.75) color:#blue;   }   chart Predator Energy Distribution type: histogram background: #lightgray size: {0.5,0.5} position: {0.5, 0.5} {    data ]0;0.25] value: predator count (each.energy <= 0.25) color: #red ;    data ]0.25;0.5] value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red ;    data ]0.5;0.75] value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red ;    data ]0.75;1] value: predator count (each.energy > 0.75) color: #red;   }  }  monitor Number of preys value: nb_preys;  monitor Number of predators value: nb_predators; } }   experiment Optimization type: batch repeat: 2 keep_seed: true until: ( time > 200 ) {  parameter  Prey max transfert:  var: prey_max_transfert min: 0.05 max: 0.5 step: 0.05 ;  parameter  Prey energy reproduce:  var: prey_energy_reproduce min: 0.05 max: 0.75 step: 0.05;  parameter  Predator energy transfert:  var: predator_energy_transfert min: 0.1 max: 1.0 step: 0.1 ;  parameter  Predator energy reproduce:  var: predator_energy_reproduce min: 0.1 max: 1.0 step: 0.1;  method tabu maximize: nb_preys + nb_predators iter_max: 10 tabu_list_size: 3; }     ","url":"wiki/Predator-Prey-Model-13.md"},{"id":"wiki/Road-Traffic-Model-01.md","title":" Loading of GIS data (buildings and roads)","content":"# Loading of GIS data (buildings and roads)  first part of the tutorial: Road Traffic  Code of the model :       model tutorial_gis_city_traffic  global {  file buildings_shapefile <- file( ../includes/building.shp );  file roads_shapefile <- file( ../includes/road.shp );  geometry shape <- envelope(envelope(buildings_shapefile) + envelope(roads_shapefile));  float step <- 10 #mn;  init {  create building from: buildings_shapefile ;  create road from: roads_shapefile ; } }   species building {  string type;   rgb color <- #gray  ;  aspect base {  draw shape color: color ; } }   species road  {  rgb color <- #red ;  aspect base {   draw shape color: color ;  } }  experiment road_traffic type: gui {  output {  display city_display type:opengl {   species building aspect: base ;   species road aspect: base ;  } } }      ","url":"wiki/Road-Traffic-Model-01.md"},{"id":"wiki/Road-Traffic-Model-02.md","title":" Definition of people agents","content":"# Definition of people agents  second part of the tutorial: Road Traffic  Code of the model :       model tutorial_gis_city_traffic  global {  file shape_file_buildings <- file( ../includes/building.shp );  file shape_file_roads <- file( ../includes/road.shp );  file shape_file_bounds <- file( ../includes/bounds.shp );  geometry shape <- envelope(shape_file_bounds);  float step <- 10 #mn;  int nb_people <- 100;  init {  create building from: shape_file_buildings with: [type::string(read (NATURE))] {   if type=Industrial {    color <- #blue ;   }  }  create road from: shape_file_roads ;  list<building> residential_buildings <- building where (each.type=Residential);  create people number: nb_people {   location <- any_location_in (one_of (residential_buildings));  } } }   species building {  string type;   rgb color <- #gray  ;  aspect base {  draw shape color: color ; } }   species road  {  rgb color <- #black ;  aspect base {   draw shape color: color ;  } }  species people {  rgb color <- #yellow ;  aspect base {  draw circle(10) color: color; } }   experiment road_traffic type: gui {  parameter  Shapefile for the buildings:  var: shape_file_buildings category:  GIS  ;  parameter  Shapefile for the roads:  var: shape_file_roads category:  GIS  ;  parameter  Shapefile for the bounds:  var: shape_file_bounds category:  GIS  ;  parameter  Number of people agents  var: nb_people category:  People  ;  output {  display city_display type:opengl {   species building aspect: base ;   species road aspect: base ;   species people aspect: base ;  } } }      ","url":"wiki/Road-Traffic-Model-02.md"},{"id":"wiki/Road-Traffic-Model-03.md","title":" Movement of the people agents","content":"# Movement of the people agents  third part of the tutorial: Road Traffic  Code of the model :       model tutorial_gis_city_traffic  global {  file shape_file_buildings <- file( ../includes/building.shp );  file shape_file_roads <- file( ../includes/road.shp );  file shape_file_bounds <- file( ../includes/bounds.shp );  geometry shape <- envelope(shape_file_bounds);  float step <- 10 #mn;  int nb_people <- 100;  int current_hour update: (time / #hour) mod 24;  int min_work_start <- 6;  int max_work_start <- 8;  int min_work_end <- 16;   int max_work_end <- 20;   float min_speed <- 1.0 #km / #h;  float max_speed <- 5.0 #km / #h;   graph the_graph;  init {  create building from: shape_file_buildings with: [type::string(read (NATURE))] {   if type=Industrial {    color <- #blue ;   }  }  create road from: shape_file_roads ;  the_graph <- as_edge_graph(road);      list<building> residential_buildings <- building where (each.type=Residential);  list<building>  industrial_buildings <- building  where (each.type=Industrial) ;  create people number: nb_people {   speed <- min_speed + rnd (max_speed - min_speed) ;   start_work <- min_work_start + rnd (max_work_start - min_work_start) ;   end_work <- min_work_end + rnd (max_work_end - min_work_end) ;   living_place <- one_of(residential_buildings) ;   working_place <- one_of(industrial_buildings) ;   objective <- resting;   location <- any_location_in (living_place);   } } }   species building {  string type;   rgb color <- #gray  ;  aspect base {  draw shape color: color ; } }   species road  {  rgb color <- #black ;  aspect base {   draw shape color: color ;  } }  species people skills:[moving] {  rgb color <- #yellow ;  building living_place <- nil ;  building working_place <- nil ;  int start_work ;  int end_work  ;  string objective ;   point the_target <- nil ;  reflex time_to_work when: current_hour = start_work and objective = resting{  objective <- working ;  the_target <- any_location_in (working_place); }   reflex time_to_go_home when: current_hour = end_work and objective = working{  objective <- resting ;  the_target <- any_location_in (living_place);  }    reflex move when: the_target != nil {  do goto target: the_target on: the_graph ;   if the_target = location {   the_target <- nil ;  } }  aspect base {  draw circle(10) color: color; } }   experiment road_traffic type: gui {  parameter  Number of people agents  var: nb_people category:  People  ;  parameter  minimal speed  var: min_speed category:  People  min: 0.1 #km/#h ;  parameter  maximal speed  var: max_speed category:  People  max: 50 #km/#h;  output {  display city_display type: opengl {   species building aspect: base refresh: false;   species road aspect: base refresh: false;   species people aspect: base ;  } } }      ","url":"wiki/Road-Traffic-Model-03.md"},{"id":"wiki/Road-Traffic-Model-04.md","title":" Definition of weight for the road network","content":"# Definition of weight for the road network  4th part of the tutorial: Road Traffic  Code of the model :       model tutorial_gis_city_traffic  global {  file shape_file_buildings <- file( ../includes/building.shp );  file shape_file_roads <- file( ../includes/road.shp );  file shape_file_bounds <- file( ../includes/bounds.shp );  geometry shape <- envelope(shape_file_bounds);  float step <- 10 #mn;  int nb_people <- 100;  int current_hour update: (time / #hour) mod 24;  int min_work_start <- 6;  int max_work_start <- 8;  int min_work_end <- 16;   int max_work_end <- 20;   float min_speed <- 1.0 #km / #h;  float max_speed <- 5.0 #km / #h;   graph the_graph;  init {  create building from: shape_file_buildings with: [type::string(read (NATURE))] {   if type=Industrial {    color <- #blue ;   }  }  create road from: shape_file_roads ;  map<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));  the_graph <- as_edge_graph(road) with_weights weights_map;      list<building> residential_buildings <- building where (each.type=Residential);  list<building>  industrial_buildings <- building  where (each.type=Industrial) ;  create people number: nb_people {   speed <- min_speed + rnd (max_speed - min_speed) ;   start_work <- min_work_start + rnd (max_work_start - min_work_start) ;   end_work <- min_work_end + rnd (max_work_end - min_work_end) ;   living_place <- one_of(residential_buildings) ;   working_place <- one_of(industrial_buildings) ;   objective <- resting;   location <- any_location_in (living_place);   } } }   species building {  string type;   rgb color <- #gray  ;  aspect base {  draw shape color: color ; } }   species road  {  float destruction_coeff <- 1 + ((rnd(100))/ 100.0) max: 2.0;  int colorValue <- int(255(destruction_coeff - 1)) update: int(255(destruction_coeff - 1));  rgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;  aspect base {  draw shape color: color ; } }   species people skills:[moving] {  rgb color <- #yellow ;  building living_place <- nil ;  building working_place <- nil ;  int start_work ;  int end_work  ;  string objective ;   point the_target <- nil ;  reflex time_to_work when: current_hour = start_work and objective = resting{  objective <- working ;  the_target <- any_location_in (working_place); }   reflex time_to_go_home when: current_hour = end_work and objective = working{  objective <- resting ;  the_target <- any_location_in (living_place);  }    reflex move when: the_target != nil {  do goto target: the_target on: the_graph ;   if the_target = location {   the_target <- nil ;  } }  aspect base {  draw circle(10) color: color; } }   experiment road_traffic type: gui {  parameter  Shapefile for the buildings:  var: shape_file_buildings category:  GIS  ;  parameter  Shapefile for the roads:  var: shape_file_roads category:  GIS  ;  parameter  Shapefile for the bounds:  var: shape_file_bounds category:  GIS  ;  parameter  Number of people agents  var: nb_people category:  People  ;  parameter  Earliest hour to start work  var: min_work_start category:  People  min: 2 max: 8;  parameter  Latest hour to start work  var: max_work_start category:  People  min: 8 max: 12;  parameter  Earliest hour to end work  var: min_work_end category:  People  min: 12 max: 16;  parameter  Latest hour to end work  var: max_work_end category:  People  min: 16 max: 23;  parameter  minimal speed  var: min_speed category:  People  min: 0.1 #km/#h ;  parameter  maximal speed  var: max_speed category:  People  max: 10 #km/#h;  output {  display city_display type:opengl {   species building aspect: base ;   species road aspect: base ;   species people aspect: base ;  } } }      ","url":"wiki/Road-Traffic-Model-04.md"},{"id":"wiki/Road-Traffic-Model-05.md","title":" Dynamic update of the road network","content":"# Dynamic update of the road network  5th part of the tutorial: Road Traffic  Code of the model :       model tutorial_gis_city_traffic  global {  file shape_file_buildings <- file( ../includes/building.shp );  file shape_file_roads <- file( ../includes/road.shp );  file shape_file_bounds <- file( ../includes/bounds.shp );  geometry shape <- envelope(shape_file_bounds);  float step <- 10 #mn;  int nb_people <- 100;  int current_hour update: (time / #hour) mod 24;  int min_work_start <- 6;  int max_work_start <- 8;  int min_work_end <- 16;   int max_work_end <- 20;   float min_speed <- 1.0 #km / #h;  float max_speed <- 5.0 #km / #h;   float destroy <- 0.02;  graph the_graph;  init {  create building from: shape_file_buildings with: [type::string(read (NATURE))] {   if type=Industrial {    color <- #blue ;   }  }  create road from: shape_file_roads ;  map<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));  the_graph <- as_edge_graph(road) with_weights weights_map;      list<building> residential_buildings <- building where (each.type=Residential);  list<building>  industrial_buildings <- building  where (each.type=Industrial) ;  create people number: nb_people {   speed <- min_speed + rnd (max_speed - min_speed) ;   start_work <- min_work_start + rnd (max_work_start - min_work_start) ;   end_work <- min_work_end + rnd (max_work_end - min_work_end) ;   living_place <- one_of(residential_buildings) ;   working_place <- one_of(industrial_buildings) ;   objective <- resting;   location <- any_location_in (living_place);   } }  reflex update_graph{  map<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));  the_graph <- the_graph with_weights weights_map; } }   species building {  string type;   rgb color <- #gray  ;  aspect base {  draw shape color: color ; } }   species road  {  float destruction_coeff <- 1 + ((rnd(100))/ 100.0) max: 2.0;  int colorValue <- int(255(destruction_coeff - 1)) update: int(255(destruction_coeff - 1));  rgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;  aspect base {  draw shape color: color ; } }   species people skills:[moving] {  rgb color <- #yellow ;  building living_place <- nil ;  building working_place <- nil ;  int start_work ;  int end_work  ;  string objective ;   point the_target <- nil ;  reflex time_to_work when: current_hour = start_work and objective = resting{  objective <- working ;  the_target <- any_location_in (working_place); }   reflex time_to_go_home when: current_hour = end_work and objective = working{  objective <- resting ;  the_target <- any_location_in (living_place);  }    reflex move when: the_target != nil {  path path_followed <- self goto [target::the_target, on::the_graph, return_path:: true];  list<geometry> segments <- path_followed.segments;  loop line over: segments {   float dist <- line.perimeter;   ask road(path_followed agent_from_geometry line) {     destruction_coeff <- destruction_coeff + (destroy * dist / shape.perimeter);   }  }  if the_target = location {   the_target <- nil ;  } }  aspect base {  draw circle(10) color: color; } }   experiment road_traffic type: gui {  parameter  Shapefile for the buildings:  var: shape_file_buildings category:  GIS  ;  parameter  Shapefile for the roads:  var: shape_file_roads category:  GIS  ;  parameter  Shapefile for the bounds:  var: shape_file_bounds category:  GIS  ;  parameter  Number of people agents  var: nb_people category:  People  ;  parameter  Earliest hour to start work  var: min_work_start category:  People  min: 2 max: 8;  parameter  Latest hour to start work  var: max_work_start category:  People  min: 8 max: 12;  parameter  Earliest hour to end work  var: min_work_end category:  People  min: 12 max: 16;  parameter  Latest hour to end work  var: max_work_end category:  People  min: 16 max: 23;  parameter  minimal speed  var: min_speed category:  People  min: 0.1 #km/#h ;  parameter  maximal speed  var: max_speed category:  People  max: 10 #km/#h;  parameter  Value of destruction when a people agent takes a road  var: destroy category:  Road  ;  output {   display city_display type:opengl {    species building aspect: base ;    species road aspect: base ;    species people aspect: base ;   }  } }     ","url":"wiki/Road-Traffic-Model-05.md"},{"id":"wiki/Road-Traffic-Model-06.md","title":" Definition of a chart display","content":"# Definition of a chart display  6th part of the tutorial: Road Traffic  Code of the model :       model tutorial_gis_city_traffic  global {  file shape_file_buildings <- file( ../includes/building.shp );  file shape_file_roads <- file( ../includes/road.shp );  file shape_file_bounds <- file( ../includes/bounds.shp );  geometry shape <- envelope(shape_file_bounds);  float step <- 10 #mn;  int nb_people <- 100;  int current_hour update: (time / #hour) mod 24;  int min_work_start <- 6;  int max_work_start <- 8;  int min_work_end <- 16;   int max_work_end <- 20;   float min_speed <- 1.0 #km / #h;  float max_speed <- 5.0 #km / #h;   float destroy <- 0.02;  graph the_graph;  init {  create building from: shape_file_buildings with: [type::string(read (NATURE))] {   if type=Industrial {    color <- #blue ;   }  }  create road from: shape_file_roads ;  map<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));  the_graph <- as_edge_graph(road) with_weights weights_map;      list<building> residential_buildings <- building where (each.type=Residential);  list<building>  industrial_buildings <- building  where (each.type=Industrial) ;  create people number: nb_people {   speed <- min_speed + rnd (max_speed - min_speed) ;   start_work <- min_work_start + rnd (max_work_start - min_work_start) ;   end_work <- min_work_end + rnd (max_work_end - min_work_end) ;   living_place <- one_of(residential_buildings) ;   working_place <- one_of(industrial_buildings) ;   objective <- resting;   location <- any_location_in (living_place);   } }  reflex update_graph{  map<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));  the_graph <- the_graph with_weights weights_map; } }   species building {  string type;   rgb color <- #gray  ;  aspect base {  draw shape color: color ; } }   species road  {  float destruction_coeff <- 1 + ((rnd(100))/ 100.0) max: 2.0;  int colorValue <- int(255(destruction_coeff - 1)) update: int(255(destruction_coeff - 1));  rgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;  aspect base {  draw shape color: color ; } }   species people skills:[moving] {  rgb color <- #yellow ;  building living_place <- nil ;  building working_place <- nil ;  int start_work ;  int end_work  ;  string objective ;   point the_target <- nil ;  reflex time_to_work when: current_hour = start_work and objective = resting{  objective <- working ;  the_target <- any_location_in (working_place); }   reflex time_to_go_home when: current_hour = end_work and objective = working{  objective <- resting ;  the_target <- any_location_in (living_place);  }    reflex move when: the_target != nil {  path path_followed <- self goto [target::the_target, on::the_graph, return_path:: true];  list<geometry> segments <- path_followed.segments;  loop line over: segments {   float dist <- line.perimeter;   ask road(path_followed agent_from_geometry line) {     destruction_coeff <- destruction_coeff + (destroy * dist / shape.perimeter);   }  }  if the_target = location {   the_target <- nil ;  } }  aspect base {  draw circle(10) color: color; } }   experiment road_traffic type: gui {  parameter  Shapefile for the buildings:  var: shape_file_buildings category:  GIS  ;  parameter  Shapefile for the roads:  var: shape_file_roads category:  GIS  ;  parameter  Shapefile for the bounds:  var: shape_file_bounds category:  GIS  ;  parameter  Number of people agents  var: nb_people category:  People  ;  parameter  Earliest hour to start work  var: min_work_start category:  People  min: 2 max: 8;  parameter  Latest hour to start work  var: max_work_start category:  People  min: 8 max: 12;  parameter  Earliest hour to end work  var: min_work_end category:  People  min: 12 max: 16;  parameter  Latest hour to end work  var: max_work_end category:  People  min: 16 max: 23;  parameter  minimal speed  var: min_speed category:  People  min: 0.1 #km/#h ;  parameter  maximal speed  var: max_speed category:  People  max: 10 #km/#h;  parameter  Value of destruction when a people agent takes a road  var: destroy category:  Road  ;  output {   display city_display type:opengl {    species building aspect: base ;    species road aspect: base ;    species people aspect: base ;   }   display chart_display refresh: every(10) {     chart  Road Status  type: series size: {1, 0.5} position: {0, 0} {     data  Mean road destruction  value: mean (road collect each.destruction_coeff) style: line color: #green ;     data  Max road destruction  value: road max_of each.destruction_coeff style: line color: #red ;    }    chart  People Objectif  type: pie style: exploded size: {1, 0.5} position: {0, 0.5}{     data  Working  value: people count (each.objective= working ) color: #magenta ;     data  Resting  value: people count (each.objective= resting ) color: #blue ;    }   }  } }     ","url":"wiki/Road-Traffic-Model-06.md"},{"id":"wiki/Road-Traffic-Model-07.md","title":" Automatic repair of roads","content":"# Automatic repair of roads  7th part of the tutorial: Road Traffic  Code of the model :       model tutorial_gis_city_traffic  global {  file shape_file_buildings <- file( ../includes/building.shp );  file shape_file_roads <- file( ../includes/road.shp );  file shape_file_bounds <- file( ../includes/bounds.shp );  geometry shape <- envelope(shape_file_bounds);  float step <- 10 #mn;  int nb_people <- 100;  int current_hour update: (time / #hour) mod 24;  int min_work_start <- 6;  int max_work_start <- 8;  int min_work_end <- 16;   int max_work_end <- 20;   float min_speed <- 1.0 #km / #h;  float max_speed <- 5.0 #km / #h;   float destroy <- 0.02;  int repair_time <- 2 ;  graph the_graph;  init {  create building from: shape_file_buildings with: [type::string(read (NATURE))] {   if type=Industrial {    color <- #blue ;   }  }  create road from: shape_file_roads ;  map<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));  the_graph <- as_edge_graph(road) with_weights weights_map;      list<building> residential_buildings <- building where (each.type=Residential);  list<building>  industrial_buildings <- building  where (each.type=Industrial) ;  create people number: nb_people {   speed <- min_speed + rnd (max_speed - min_speed) ;   start_work <- min_work_start + rnd (max_work_start - min_work_start) ;   end_work <- min_work_end + rnd (max_work_end - min_work_end) ;   living_place <- one_of(residential_buildings) ;   working_place <- one_of(industrial_buildings) ;   objective <- resting;   location <- any_location_in (living_place);   } }  reflex update_graph{  map<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));  the_graph <- the_graph with_weights weights_map; } reflex repair_road when: every(repair_time #hour / step) {  road the_road_to_repair <- road with_max_of (each.destruction_coeff) ;  ask the_road_to_repair {   destruction_coeff <- 1.0 ;  } } }   species building {  string type;   rgb color <- #gray  ;  aspect base {  draw shape color: color ; } }   species road  {  float destruction_coeff <- 1 + ((rnd(100))/ 100.0) max: 2.0;  int colorValue <- int(255(destruction_coeff - 1)) update: int(255(destruction_coeff - 1));  rgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;  aspect base {  draw shape color: color ; } }   species people skills:[moving] {  rgb color <- #yellow ;  building living_place <- nil ;  building working_place <- nil ;  int start_work ;  int end_work  ;  string objective ;   point the_target <- nil ;  reflex time_to_work when: current_hour = start_work and objective = resting{  objective <- working ;  the_target <- any_location_in (working_place); }   reflex time_to_go_home when: current_hour = end_work and objective = working{  objective <- resting ;  the_target <- any_location_in (living_place);  }    reflex move when: the_target != nil {  path path_followed <- self goto [target::the_target, on::the_graph, return_path:: true];  list<geometry> segments <- path_followed.segments;  loop line over: segments {   float dist <- line.perimeter;   ask road(path_followed agent_from_geometry line) {     destruction_coeff <- destruction_coeff + (destroy * dist / shape.perimeter);   }  }  if the_target = location {   the_target <- nil ;  } }  aspect base {  draw circle(10) color: color; } }   experiment road_traffic type: gui {  parameter  Shapefile for the buildings:  var: shape_file_buildings category:  GIS  ;  parameter  Shapefile for the roads:  var: shape_file_roads category:  GIS  ;  parameter  Shapefile for the bounds:  var: shape_file_bounds category:  GIS  ;  parameter  Number of people agents  var: nb_people category:  People  ;  parameter  Earliest hour to start work  var: min_work_start category:  People  min: 2 max: 8;  parameter  Latest hour to start work  var: max_work_start category:  People  min: 8 max: 12;  parameter  Earliest hour to end work  var: min_work_end category:  People  min: 12 max: 16;  parameter  Latest hour to end work  var: max_work_end category:  People  min: 16 max: 23;  parameter  minimal speed  var: min_speed category:  People  min: 0.1 #km/#h ;  parameter  maximal speed  var: max_speed category:  People  max: 10 #km/#h;  parameter  Value of destruction when a people agent takes a road  var: destroy category:  Road  ;  parameter  Number of hours between two road repairs  var: repair_time category:  Road  ;  output {  display city_display type:opengl {   species building aspect: base ;   species road aspect: base ;   species people aspect: base ;  }  display chart_display refresh: every(10) {    chart Road Status type: series size: {1, 0.5} position: {0, 0} {    data Mean road destruction value: mean (road collect each.destruction_coeff) style: line color: #green ;    data Max road destruction value: road max_of each.destruction_coeff style: line color: #red ;   }   chart People Objectif type: pie style: exploded size: {1, 0.5} position: {0, 0.5}{    data Working value: people count (each.objective=working) color: #magenta ;    data Resting value: people count (each.objective=resting) color: #blue ;   }  } } }      ","url":"wiki/Road-Traffic-Model-07.md"},{"id":"wiki/Incremental-Model.md","title":" Incremental Model","content":"Incremental Model  This sub-section is composed of the following models :   Simple SI Model Charts Integration of GIS Data Movement on Graph 3D visualization Multi-level Differential Equation      ","url":"wiki/Incremental-Model.md"},{"id":"wiki/Predator-Prey.md","title":" Predator Prey","content":"Predator Prey  This sub-section is composed of the following models :   Basic model (prey agents) Dynamic of the vegetation (grid) Behavior of the prey agent Use of Inspectors/monitors Predator agents (parent species) Breeding of prey and predator agents Agent display (aspect) Complex behaviors for the preys and predators Adding of a stopping condition Definition of charts Writing files Image loading (raster data) Exploration (batch)      ","url":"wiki/Predator-Prey.md"},{"id":"wiki/Road-Traffic.md","title":" Road Traffic","content":"Road Traffic  This sub-section is composed of the following models :   Loading of GIS data (buildings and roads) Definition of people agents Movement of the people agents Definition of weight for the road network Dynamic update of the road network Definition of a chart display Automatic repair of roads      ","url":"wiki/Road-Traffic.md"},{"id":"wiki/Additionnal-Plugins.md","title":" Additionnal Plugins","content":"Additionnal Plugins  This section is composed of the following sub-section :   Diffusion Statement Ordinary Differential Equations      ","url":"wiki/Additionnal-Plugins.md"},{"id":"wiki/Features.md","title":" Features","content":"Features  This section is composed of the following sub-section :   3D Visualization Agent movement Batch Charts Clustering Co-model Usage Color Data Importation Database Usage Date and Time Driving Skill Graphs Init Action Map comparison Multi-Level Usage Multi-simulation Multicriteria decision Overlay Save statement Spatial Operators Statistics Unit Test User Interaction      ","url":"wiki/Features.md"},{"id":"wiki/Syntax.md","title":" Syntax","content":"Syntax  This section is composed of the following sub-section :     Syntax models   ","url":"wiki/Syntax.md"},{"id":"wiki/Toy-Models.md","title":" Toy Models","content":"Toy Models  This section is composed of the following sub-section :   Ants (Foraging and Sorting) Articles Boids Circle Clock Co-model Example Epidemiology Evacuation Flood Simulation Learning Life Multi-level data analysis Predator Prey Segregation (Schelling) Soccer Sugarscape Traffic Urban Growth Voronoi Vote      ","url":"wiki/Toy-Models.md"},{"id":"wiki/Tutorials.md","title":" Tutorials","content":"Tutorials  This section is composed of the following sub-section :   3D Incremental Model Predator Prey Road Traffic      ","url":"wiki/Tutorials.md"},{"id":"wiki/GamlEditorGeneralities.md","title":" The GAML Editor - Generalities","content":"The GAML Editor - Generalities  The GAML Editor is a text editor that proposes several services to support the modeler in writing correct models: an integrated live validation system, a ribbon header that gives access to experiments, information, warning and error markers.  Table of contents     The GAML Editor - Generalities  Creating a first model       Status of models in editors       Editor Preferences       Multiple editors       Local history Creating a first model  Editing a model requires that at least one project is created in User Models. If there is none, right-click on User Models and choose  New… > Gama Project…  (if you already have user projects and want to create a model in one of them, skip the next step).    A dialog is then displayed, offering you to enter the name of the project as well as its location on the filesystem. Unless you are absolutely sure of what you are doing, keep the  Use default location  option checked. An error will be displayed if the project name already exists in the workspace, in which case you will have to change it. Two projects with similar names can not coexist in the workspace (even if they belong to different categories).    Once the project is created (or if you have an existing project), navigate to it and right-click on it. This time, choose  New…>Model file…  to create a new model.    A new dialog is displayed, which asks for several required or optional information. The Container is normally the name of the project you have selected, but you can choose to place the file elsewhere. An error will be displayed if the container does not exist (yet) in the workspace. You can then choose whether you want to use a template or not for producing the initial file, and you are invited to give this file a name. An error is displayed if this name already exists in this project. The name of the model, which is by default computed with respect to the name of the file, can be actually completely different (but it may not contain white spaces or punctuation characters). The name of the author, as well as the textual description of the model and the creation of an HTML documentation, are optional.    Status of models in editors  Once this dialog is filled and accepted, GAMA will display the new  empty  model.    Although GAML files are just plain text files, and can therefore be produced or modified in any text processor, using the dedicated GAML editor offers a number of advantages, among which the live display of errors and model statuses. A model can actually be in four different states, which are visually accessible above the editing area: Functional (orange color), Experimentable (green color), InError (red color), InImportedError_(yellow color). See the section on model compilation for more precise information about these statuses._  In its initial state, a model is always in the Functional state, which means it compiles without problems, but cannot be used to launch experiments. The InError state, depicted below, occurs when the file contains errors (syntactic or semantic ones).    While the file is not saved, these errors remain displayed in the editor and nowhere else. If you save the file, they are now considered as  workspace errors  and get displayed in the  Problems  view below the editor.    Reaching the Experimentable state requires that all errors are eliminated and that at least one experiment is defined in the model, which is the case now in our toy model. The experiment is immediately displayed as a button in the toolbar, and clicking on it will allow to launch this experiment on your model. See the section about running experiments for more information on this point.    Experiment buttons are updated in real-time to reflect what s in your code. If more than one experiment is defined, corresponding buttons will be displayed in addition to the first one.    Editor Preferences  Text editing in general, and especially in Eclipse-based editors, sports a number of options and preferences. You might want to turn off/on the numbering of the lines, change the fonts used, change the colors used to highlight the code, etc. All of these preferences are accessible from the  Preferences…  item of the editor contextual menu.    Explore the different items present there, keeping in mind that these preferences will apply to all the editors of GAMA and will be stored in your workspace.    Additional informations in the Editor    You can choose to display or not some informations in your Editor  One particular option, shipped by default with GAMA, is the possibility to not only highlight the code of your model, but also its structure (complementing, in that sense, the Outline view). It is a slightly modified version of a plugin called EditBox, which can be activated by clicking on the  green square  icon in the toolbar.    The Default theme of EditBox might not suit everyone s tastes, so the preferences allow to entirely customize how the  boxes  are displayed and how they can support the modeler in better understanding  where  it is in the code. The  themes  defined in this way are stored in the workspace, but can also be exported for reuse in other workspaces, or sharing them with other modelers.    Multiple editors GAMA inherits from Eclipse the possibility to entirely configure the placement of the views, editors, etc. This can be done by rearranging their position using the mouse (click and hold on an editor s title and move it around). In particular, you can have several editors side by side, which can be useful for viewing the documentation while coding a model.    Local history Among the various options present to work with models, which you are invited to try out and test at will, one, called Local history is particularly interesting and worth a small explanation. When you edit models, GAMA keeps in the background all the successive versions you save (the history duration is configurable in the preferences), whether or not you are using a versioning system like SVN or Git. This local history is accessible from different places in GAMA (the Navigator, the Views menu, etc.), including the contextual menu of the editor.    This command invokes the opening of a new view, which you can see on the figure below, and which lists the different versions of your file so far. You can then choose one and, right-clicking on it, either open it in a new editor, or compare it to your current version.    This allows you to precisely pinpoint the modifications brought to the file and, in case of problems, to revert them easily, or even revert the entire file to a previous version. Never lose your work again !    This short introduction to GAML editors is now over. You might want to take a look, now, at how the models you edit are parsed, validated and compiled, and how this information is accessible to the modeler. ","url":"wiki/GamlEditorGeneralities.md"},{"id":"wiki/GamlEditorToolbar.md","title":" The GAML Editor Toolbar","content":"The GAML Editor Toolbar  The GAML Editor provide some tools to make the editing easier, covering a lot of functionalities, such as tools for changes of visualization, tools for navigation through your model, tools to format your code, or also tools to help you finding the correct keywords to use in a given context.    Table of contents     The GAML Editor Toolbar    * Visualization tools in the editor    * Navigation tools in the editor    * Format tools in the editor    * Vocabulary tools in the editor   Visualization tools in the editor    You can choose to display or not some informations in your Editor. Here are the different features for this part:  Display the number of lines  The first toggle is used to show / hide the number of lines.  Expand / Collapse lines  The second toggle provides you the possibility to expand or collapse lines in your model depending on the indentation. This feature can be very useful for big models, to collapse the part you have already finished.  Mark the occurrences  This third toggle is used to show occurrences when your cursor is pointing on one word.  Display colorization of code section  One particular option, shipped by default with GAMA, is the possibility to not only highlight the code of your model, but also its structure (complementing, in that sense, the Outline view). It is a slightly modified version of a plugin called EditBox, which can be activated by clicking on the  green square  icon in the toolbar.    The Default theme of EditBox might not suit everyone s tastes, so the preferences allow to entirely customize how the  boxes  are displayed and how they can support the modeler in better understanding  where  it is in the code. The  themes  defined in this way are stored in the workspace, but can also be exported for reuse in other workspaces, or sharing them with other modelers.    Change the font size  The two last tools of this section are used to increase / decrease the size of the displayed text.  Navigation tools in the editor    In the Editor toolbar, you have some tools for search and navigation through the code. Here are the explanation for each functionalities:  The search engine  In order to search an occurrence of a word (or the part of a word), you can type your search in the field, and the result will be highlighted automatically in the text editor.    With the left / right arrows, you can highlight the previous / next occurrence of the word. The two toggles just in the right side of the search field are used to constraint the results as  case sensitive  or  whole word . If you prefer the eclipse interface for the search engine, you can also access to the tool by taping Ctrl+F.  Previous / Next location  The two arrow shape buttons that are coming after are used to jump from the current location of your cursor to the last position, even if the last position was in an other file (and even if this file has been closed !).  Show outline  This last tool of this section is used to show the global architecture of your model, with explicit icons for each section. A search field is also available, if you want to search a specific section. By double clicking one line of the outline, you can jump directly to the chosen section. This feature can be useful if you have big model to manipulate.    Format tools in the editor    Some other tools are available in the toolbar to help for the indentation of the model:  Shift left / shift right  Those two first buttons are used to shift a line (or a group of lines) on the left or the right.  Format  This useful feature re-indent automatically all your model.  Re-serialize  Re-serialize your model.  Comment  The two last buttons of this section are useful to comment a line (or a group of lines).  Vocabulary tools in the editor    The last group of buttons are used to search the correct way to write a certain keyword.  Templates  The templates button is used to insert directly a code snippet in the current position of the cursor. Some snippets are already available, ordered by scope. You can custom the list of template as much as you want, it is very easy to add a new template.  Built-in attributes, built-in actions  With this feature, you can easily know the list of built-in attributes and built-in actions you can use in such or such context. With this feature, you can also insert some templates to help you, for example to insert a pre-made species using a particular skill, as it is shown it the following screenshot:    … will generate the following code:    All the comments are generated automatically from the current documentation.  Operators  Once again, this powerful feature is used to generate example of structures for all the operators, ordered by categories.  Colors  Here is the list of the name for the different pre-made colors you can use. You can also add some custom colors.   ","url":"wiki/GamlEditorToolbar.md"},{"id":"wiki/GraphicalEditor.md","title":" The Graphical Editor","content":"The Graphical Editor  The graphical editor that allow to build diagram (gadl files) is based on the Graphiti Eclipse plugin. It allows to define a GAMA model through a graphical interface. It a allows as well to produce a graphical model (diagram) from a gaml model.    Table of contents     The Graphical Editor  Installing the graphical editor       Creating a first model       Status of models in editors       Diagram definition framework       Features   agents species     grid     Inheriting link     world     agent features action     reflex     aspect     experiment GUI experiment     display     batch experiment       Pictogram color modification       GAML Model generation Installing the graphical editor Using the graphical editor requires to install the graphical modeling plug-in. See here for information about plug-ins and their installation.  The graphical editor plug-in is called Graphical_modeling and is directly available from GAMA update site https://gama-platform.googlecode.com/svn/update_site/*.    Note that the graphical editor is still under development. Updates of the plug-in will be add to the GAMA website. After installing the plug-in (and periodically), check for updates for this plug-in: in the  Help  menu, choose  Check for Updates  and install the proposed updates for the graphical modeling plug-in.  Creating a first model  A new diagram can be created in a new GAMA project. First, right click on a project, then select  New  on the contextual menu. In the New Wizard, select  GAMA -> Model Diagram , then  Next>    In the next Wizard dialog, select the type of diagram (Empty, Skeleton or Example) then the name of the file and the author.    Skeleton and Example diagram types allow to add to the diagram some basic features.  Status of models in editors  Similarly to GAML editor, the graphical editor proposes a live display of errors and model statuses. A graphical model can actually be in three different states, which are visually accessible above the editing area: Functional (orange color), Experimentable (green color) and InError (red color). See the section on model compilation for more precise information about these statuses.  In its initial state, a model is always in the Functional state, which means it compiles without problems, but cannot be used to launch experiments. The InError state occurs when the file contains errors (syntactic or semantic ones).  Reaching the Experimentable state requires that all errors are eliminated and that at least one experiment is defined in the model. The experiment is immediately displayed as a button in the toolbar, and clicking on it will allow to launch this experiment on your model.  Experiment buttons are updated in real-time to reflect what s in your code. If more than one experiment is defined, corresponding buttons will be displayed in addition to the first one.  Diagram definition framework  The following figure presents the editing framework:   Features  agents #### species    The species feature allows to define a species with a continuous topology. A species is always a micro-species of another species. The top level (macro-species of all species) is the world species.     source: a species (macro-species)   target: -      grid    The grid feature allows to define a species with a grid topology. A grid is always a micro-species of another species.     source: a species (macro-species)   target: -     Inheriting link The inheriting link feature allows to define an inheriting link between two species.     source: a species (parent)   target: a species (child)     world    When a model is created, a world species is always defined. It represent the global part of the model. The world species, which is unique, is the top level species. All other species are micro-species of the world species.    agent features  action   The action feature allows to define an action for a species.     source: a species (owner of the action)   target: -     reflex   The reflex feature allows to define a reflex for a species.     source: a species (owner of the reflex)   target: -     aspect   The aspect feature allows to define an aspect for a species.     source: a species (owner of the aspect)   target: -      ### experiment #### GUI experiment    The GUI Experiment feature allows to define a GUI experiment.     source: world species   target: -     display    The display feature allows to define a display.     source: GUI experiment   target: -       batch experiment    The Batch Experiment feature allows to define a Batch experiment.     source: world species   target: -   Pictogram color modification It is possible to change the color of a pictogram.   * Right click on a pictogram, then select the  Chance the color .  GAML Model generation It is possible to automatically generate a Gaml model from a diagram.   * Right click on the graphical framework (where the diagram is defined), then select the  Generate Gaml model . A new GAML model with the same name as the diagram is created (and open). ","url":"wiki/GraphicalEditor.md"},{"id":"wiki/ValidationOfModels.md","title":" Validation of Models","content":"Validation of Models  When editing a model, GAMA will continuously validate (i.e. compile) what the modeler is entering and indicate, with specific visual affordances, various information on the state of the model. This information ranges from documentation items to errors indications. We will review some of them in this section.  Table of contents     Validation of Models  Syntactic errors       Semantic errors       Semantic warnings       Semantic information       Semantic documentation       Changing the visual indicators       Errors in imported files       Cleaning models Syntactic errors These errors are produced when the modeler enters a sentence that has no meaning in the grammar of GAML (see the documentation of the language). It can either be a non-existing symbol (like  globals  (instead of global) in the example below), a wrong punctuation scheme, or any other construct that puts the parser in the incapacity of producing a correct syntax tree. These errors are extremely common when editing models (since incomplete keywords or sentences are continuously validated). GAMA will report them using several indicators: the icon of the file in the title of the editor will sport an error icon and the gutter of the editor (i.e. the vertical space beside the line numbers) will use error markers to report two or more errors: one on the statement defining the model, and one (or more) in the various places where the parser has failed to produce the syntax tree. In addition, the toolbar over the editor will turn red and indicate that errors have been detected.    Hovering over one of these markers indicates what went wrong during the syntactic validation. Note that these errors are sometimes difficult to interpret, since the parser might fail in places that are not precisely those where a wrong syntax is being used (it will usually fail after).    Semantic errors When syntactic errors are eliminated, the validation enters a so-called semantic phase, during which it ensures that what the modeler has written makes sense with respect to the various rules of the language. To understand the difference between the two phases, take a look at the following example.  This sentence below is syntactically correct:  species my_species parent: my_species;  But it is semantically incorrect because a species cannot be parent of itself. No syntactic errors will be reported here, but the validation will fail with a semantic error.    Semantic errors are reported in a way similar to syntactic errors, except that no marker are displayed beside the model statement. The compiler tries to report them as precisely as possible, underlining the places where they have been found and outputting hopefully meaningful error messages. In the example below, for instance, we use a wrong number of arguments for defining a square geometry. Although the sentence is syntactically correct, GAMA will nevertheless issue an error and prevent the model from being experimentable.    The message accompanying this error can be obtained by hovering over the error marker found in the gutter (multiple messages can actually be produced for a same error, see below).    While the editor is in a so-called dirty state (i.e. the model has not been saved), errors are only reported locally (in the editor itself). However, as soon as the user saves a model containing syntactic or semantic errors, they are  promoted  to become workspace errors, and, as such, indicated in other places: the file icon in the Navigator, and a new line in the Errors view.    Semantic warnings  The semantic validation phase does not only report errors. It also outputs various indicators that can help the modeler in verifying the correctness of his/her model. Among them are warnings. A warning is an indication that something is not completely right in the way the model is written, although it can probably be worked around by GAMA when the model will be executed. For instance, in the example below, we pass a string argument to the facet  number:  of the  create  statement. GAMA will emit a warning in such a case, indicating that  number:  expects an integer, and that the string passed will be casted to int when the model will be executed. Warnings are to be considered seriously, as they usually indicate some flaws in the logic of the model.    Hovering over the warning marker will allow the modeler to have access to the explanation and hopefully fix the cause of the warning.    Semantic information Besides warnings, another type of harmless feedback is produce by the semantic validation phase: information markers. They are used to indicate useful information to the modeler, for example that an attribute has been redefined in a sub-species, or that some operation will take place when running the model (for instance, the truncation of a float to an int). The visual affordance used in this case is voluntarily discrete (a small  i  in the editor s gutter).    As with the other types of markers, information markers unveil their messages when being hovered.    Semantic documentation The last type of output of the semantic validation phase consists in a complete documentation of the various elements present in the model, which the user can retrieve by hovering over the different symbols. Note that although the best effort is being made in producing a complete and consistent documentation, it may happen that some symbols do not produce anything. In that case, please report a new Issue here.    Changing the visual indicators The default visual indicators depicted in the examples above to report errors, warnings and information can be customized to be less (or more) intrusive. This can be done by choosing the  Preferences…  item of the editor contextual menu and navigating to  General > Editors > Text Editors > Annotations . There, you will find the various markers used, and you will be able to change how they are displayed in the editor s view. For instance, if you prefer to highlight errors in the text, you can change it here.    Which will result in the following visual feedback for errors:    Errors in imported files  Finally, even if your model has been cleansed of all errors, it may happen that it refuses to launch because it imports another model that cannot be compiled. In the following screenshot,  My First Model.gaml  imports  My Imported Model.gaml , which sports a syntactic error.    In such a case, the importing model refuses to compile (although it is itself valid) and to propose experiments. There are cases, however, where the same importation can work. Consider the following example, where, this time,  My Imported Model.gaml  sports a semantic error in the definition of the global  shape  attribute. Without further modifications, the use case is similar to the first one.    However, if  My First Model.gaml  happens to redefine the shape attribute (in global), it is now considered as valid. All the valid sections of  My Imported Model.gaml  are effectively imported, while the erroneous definition is superseded by the new one.    This process is described by the information marker next to the redefinition.    Cleaning models It may happen that the metadata that GAMA maintains about the different projects (which includes the various markers on files in the workspace, etc.) becomes corrupted from time to time. This especially happens if you frequently switch workspaces, but not only. In those (hopefully rare) cases, GAMA may report incorrect errors for perfectly legible files.  When such odd behaviors are detected, or if you want to regularly keep your metadata in a good shape, you can clean all your project, by clicking on the button  Clear and validate all projects  (in the syntax errors view).   ","url":"wiki/ValidationOfModels.md"},{"id":"wiki/Headless.md","title":" Headless Mode","content":"Headless Mode  The aim of this feature is to be able to run one or multiple instances of GAMA without any user interface, so that models and experiments can be launched on a grid or a cluster. Without GUI, the memory footprint, as well as the speed of the simulations, are usually greatly improved.  In this mode, GAMA can only be used to run experiments and that editing or managing models is not possible. In order to launch experiments and still benefit from a user interface (which can be used to prepare headless experiments), launch GAMA normally (see here) and refer to this page for instructions.  Table of contents     Headless Mode  Command   Shell Script Java Command   Experiment Input File   Heading Parameters Outputs   Output Directory       Simulation Output   Step Variable   Snapshot files Command  There are two ways to run a GAMA experiment in headless mode: using a dedicated shell script (recommended) or directly from the command line. These commands take 2 arguments: an experiment file and an output directory.  Shell Script It can be found in the headless directory located inside Gama. Its name is gama-headless.sh on MacOSX and Linux, and gama-headless.bat on Windows.    sh gama-headless.sh [m/c/t/hpc/v] $1 $2      with:  $1 input parameter file : an xml file determining experiment parameters and attended outputs       $2 output directory path : a directory which contains simulation results (numerical data and simulation snapshot)       options [-m/c/t/hpc/v]   -m memory : memory allocated to gama -c : console mode, the simulation description could be written with the stdin -t : tunneling mode, simulation description are read from the stdin, simulation results are printed out in stdout -hpc nb_of_cores : allocate a specific number of cores for the experiment plan -v : verbose mode. trace are displayed in the console       For example (using the provided sample), navigate in your terminal to the GAMA root folder and type :    sh headless/gama-headless.sh headless/samples/predatorPrey.xml outputHeadLess   As specified in predatorPrey.xml, this command runs the prey - predator model for 1000 steps and record a screenshot of the main display every 5 steps. The screenshots are recorded in the directory outputHeadLess (under the GAMA root folder).  Not that the current directory to run gama-headless command must be $GAMA_PATH/headless  Java Command   java -cp $GAMA_CLASSPATH -Xms512m -Xmx2048m -Djava.awt.headless=true org.eclipse.core.launcher.Main -application msi.gama.headless.id4 $1 $2      with:  $GAMA_CLASSPATH gama classpath: contains relative or absolute path of jars inside the gama plugin directory and jars created by users       $1 input parameter file: an xml file determining experiment parameters and attended outputs       $2 output directory path: a directory which contains simulation results (numerical data and simulation snapshot) Note that the output directory is created during the experiment and should not exist before.  Experiment Input File  The XML input file contains for example:            Note that several simulations could be determined in one experiment plan. These simulations are run in parallel according to the number of allocated cores.  Heading            * with:  *  id : permits to prefix output files for experiment plan with huge simulations.  *  sourcePath : contains the relative or absolute path to read the gaml model.  *  finalStep : determines the number of simulation step you want to run.  *  experiment : determines which experiment should be run on the model. This experiment should exist, otherwise the headless mode will exit.  ### Parameters One line per parameter you want to specify a value to:              * with:     *  name :  name of the parameter in the gaml model     *  type :  type of the parameter (INT, FLOAT, BOOLEAN, STRING)     *  value : the chosen value  ### Outputs One line per output value you want to retrieve. Outputs can be names of monitors or displays defined in the  output  section of experiments, or the names of attributes defined in the experiment or the model itself (in the  global  section).          ... with the name of a monitor defined in the  output  section of the experiment...   ... with the name of a (built-in) variable defined in the experiment itself...           * with:  *  name  : name of the output in the  output / permanent  section in the experiment or name of the experiment/model attribute to retrieve  *  framerate  : the frequency of the monitoring (each step, each 2 steps,  each 100 steps...).  * Note that :  * the lower the framerate value the longer the experiment.  * if the chosen output is a display, an image is produced and the output file contains the path to access this image    ## Output Directory During headless experiments, a directory is created with the following structure:      Outputed-directory-path/     |-simulation-output.xml     |- snapshot |- main_display2-0.png |- main_display2-10.png |- ...      * with:  *  simulation-output.xml : containing the results  *  snapshot : containing the snapshots produced during the simulation  Is it possible to change the output directory for the images by adding the attribute output_path in the xml :   If we write  <Output id=1 name=my_display file:/F:/path/imageName framerate=10 /> , then the display my_display will have the name imageName-stepNb.png and will be written in the folder /F:/path/  ## Simulation Output A file named  simulation-output.xml  is created with the following contents when the experiment runs.                                  ...      * With:  *    : block containing results of the simulation 2 (this Id is identified in the Input Experiment File)  *   ...  : one block per step done. The id corresponds to the step number  ### Step                        There is one Variable block per Output identified in the output experiment file.  ### Variable             * with:  *  name : name of the output, the model variable  *  value : the current value of model variable.  Note that the value of an output is repeated according to the framerate defined in the input experiment file.     ## Snapshot files This directory contains images generated during the experiment. There is one image per displayed output per step (according to the framerate). File names follow a naming convention, e.g:         [outputName][SimulationID]_[stepID].png -> main_display2-20.png      Note that images are saved in  .png  format.  ","url":"wiki/Headless.md"},{"id":"wiki/Installation.md","title":" Installation","content":"Installation  GAMA 1.7 comes in 5 different versions (32 & 64 bits for Windows & Linux, and 64 bits for MacOS X). You first need to determine which version to use (it depends on your computer, which may, or not, support 64 bits instructions, but also on the version of Java already installed, as the number of bits of the two versions must match).  You can then download the right version from the Downloads page, expand the zip file wherever you want on your machine, and launch GAMA.  Table of contents     Installation  System Requirements       Installation of Java   On MacOS X On Windows On Ubuntu & Linux       System Requirements  GAMA 1.7 requires that Java 1.8 be installed on your machine, approximately 200MB of disk space and a minimum of 4GB of RAM (to increase the portion of memory usable by GAMA, please refer to these instructions).  MacOS  In some cases,  Archive utility.app  in MacOS may damage the files when extracting them from the zip or tar.gz archive files. This problem manifests itself by a dialog opening and explaining that the application is damaged and cannot be launched (see Issue 2082 and also this thread. In that case, to expand the files, consider using a different utility, like the free Stuffit Expander or directly from the command line.  MacOS Sierra has introduced a series of issues linked to the so-called  quarantine  mode (where applications downloaded from Internet prevent to use and update their internal components, such as the models of the library or the self-updating of the application). See this page for background information. To be certain that Gama will work, and until we find an easier solution, the installation should follow these steps:     Download the GAMA zip file   Unzip it (possibly with another archive utility, see above)   Copy and paste Gama in the Applications folder   Launch Terminal.app   Type cd /Applications and hit return.   Type xattr -d -r com.apple.quarantine Gama.app/ and hit return to remove the quarantine attribute   From now on, Gama should be fully functional.  Installation of Java  On all environments, the recommended Java Virtual Machine under which GAMA has been tested is the one distributed by Oracle (http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html#javasejdk).  Please make sure to install the JDK (Java Development Kit) and not the JRE (Java Runtime Environment). GAMA may work with the standard JRE, although it will be slower and may even crash (esp. under MacOS X).  On MacOS The latest version of GAMA requires a JVM (or JDK or JRE) compatible with Java 1.8 to run.  Note for GAMA 1.6.1 users: if you plan to keep a copy of GAMA 1.6.1, you will need to have both Java 1.6 (distributed by Apple) and Java 1.8 (distributed by Oracle) installed at the same time. Because of this bug in SWT (https://bugs.eclipse.org/bugs/show_bug.cgi?id=374199), GAMA 1.6.1 will not run correctly under Java 1.8 (all the displays will appear empty). To install the JDK 1.6 distributed by Apple, follow the instructions here : http://support.apple.com/kb/DL1572. Alternatively, you might want to go to https://developer.apple.com/downloads and, after a free registration step if you re not an Apple Developer, get the complete JDK from the list of downloads.  On Windows Please notice that, by default, Internet Explorer and Chrome browsers will download a 32 bits version of the JRE. Running GAMA 32 bits for Windows is ok, but you may want to download the latest JDK instead, in order to both improve the performances of the simulator and be able to run GAMA 64 bits.     To download the appropriate java version, follow this link: http://www.java.com/en/download/manual.jsp   Execute the downloaded file   You can check that a Java\\jre8 folder has been installed at the location C:\\Program Files\\   In order for Java to be found by Windows, you may have to modify environment variables:     Go to the Control Panel   In the new window, go to System   On the left, click on Advanced System parameters   In the bottom, click on Environment Variables   In System Variables, choose to modify the Path variable   At the end, add ;C:\\Program Files\\Java\\jre8\\bin (or jre8\\bin)   On Ubuntu & Linux  To have a complete overview of java management on Ubuntu, have a look at:     Ubuntu Java documentation   for French speaking users: http://doc.ubuntu-fr.org/java#installations_alternatives   Basically, you need to do:  sudo add-apt-repository ppa:webupd8team/java sudo apt-get update sudo apt-get install oracle-java8-installer    You can then switch between java version using:  sudo update-alternatives --config java   See the troubleshooting page for more information on workaround for problems on Unbuntu. ","url":"wiki/Installation.md"},{"id":"wiki/InstallingPlugins.md","title":" Installing Plugins","content":"Installing Plugins  Besides the plugins delivered by the developers of the GAMA platform, which can be installed and updated as explained here, there are a number of additional plugins that can be installed to add new functionalities to GAMA or enhance the existing ones. GAMA being based on Eclipse, a number of plugins developed for Eclipse are then available (a complete listing of Eclipse plugins can be found in the so-called Eclipse MarketPlace).  There are, however, three important restrictions:     The current version of GAMA is based on Eclipse Juno (version number 3.8.2), which excludes de facto all the plugins targeting solely the 4.3 (Kepler) or 4.4 (Luna) versions of Eclipse. These will refuse to install anyway.   The Eclipse foundations in GAMA are only a subset of the complete Eclipse platform, and a number of libraries or frameworks (for example the Java Development Toolkit) are not (and will never be) installed in GAMA. So plugins relying on their existence will refuse to install as well.   Some components of GAMA rely on a specific version of other plugins and will refuse to work with other versions, essentially because their compatibility will not be ensured anymore. For instance, the parser and validator of the GAML language in GAMA 1.6.1 require XText v. 2.4.1 to be installed (and neither XText 2.5.4 nor XText 2.3 will satisfy this dependency).   With these restrictions in mind, it is however possible to install interesting additional plugins. We propose here a list of some of these plugins (known to work with GAMA), but feel free to either add a comment if you have tested plugins not listed here or create an issue if a plugin does not work, in order for us to see what the requirements to make it work are and how we can satisfy them (or not) in GAMA.  Table of contents     Installing Plugins  Installation       Selected Plugins   Overview Git [CKEditor] (#ckeditor) Startexplorer Pathtools CSV Edit Quickimage       Installation Installing new plugins is a process identical to the one described when updating GAMA, with one exception: the update site to enter is normally provided by the vendor of the additional plugin and must be entered instead of GAMA s one in the dialog. Let us suppose, for instance, that we want to install a RSS feed reader available on this site. An excerpt from the page reads that :     All plugins are installed with the standard update manager of Eclipse. It will guide you through the installation process and also eases keeping your plugins up-to-date. Just add the update site: http://www.junginger.biz/eclipse/   So we just have to follow these instructions, which leads us to the following dialog, in which we select  RSS view  and click  Next .    The initial dialog is followed by two other ones, a first to report that the plugin satisfies all the dependencies, a second to ask the user to accept the license agreement.  ||| |—|—|  Once we dismiss the warning that the plugin is not signed and accept to restart GAMA, we can test the new plugin by going to the  Views  menu.    The new RSS view is available in the list of views that can be displayed in GAMA.    And we can enjoy (after setting some preferences available in its local menu) monitoring the Issues of GAMA from within GAMA itself !    Selected Plugins In addition to the RSS reader described above, below is a list of plugins that have been tested to work with GAMA. There are many others so take the time to explore them !  Overview    A very useful plugin for working with large model files. It renders an overview of the file in a separate view (with a user selectable font size), allowing to know where the edition takes place, but also to navigate very quickly and efficiently to different places in the model.   Update site: http://sandipchitaleseclipseplugins.googlecode.com/svn/trunk/text.overview.updatesite/site.xml   After installing the plugin, an error might happen when closing GAMA. It is harmless. After restarting GAMA, go to Views > Open View > Others… > Overview >.   Git    Git is a version control system (like CVS or SVN, extensively used in GAMA) http://git-scm.com/. Free sharing space are provided on GitHub among others. Installing Git allows to share or gather models that are available in Git repositories.   Update site (general): http://download.eclipse.org/releases/mars/ (Alternatively, you can use http://download.eclipse.org/egit/updates)   Select the two following plugins:  Eclipse EGit       Git Team Provider Core CKEditor    CKEditor is a lightweight and powerful web-based editor, perfect for almost WYSIWYG edition of HTML files. It can be installed, directly in GAMA, in order to edit .html, .htm, .xml, .svg, etc. files directly without leaving the platform. No other dependencies are required. A must !   Update site: http://kosz.bitbucket.org/eclipse-ckeditor/update-site   Startexplorer    A nice utility that allows the user to select files, folders or projects in the Navigator and open them in the filesystem (either the UI Explorer, Finder, whatever, or in a terminal).   Update site: http://basti1302.github.com/startexplorer/update/     Pathtools    Same purpose as StartExplorer, but much more complete, and additionally offers the possibility to add new commands to handle files (open them in specific editors, execute external programs on them, etc.). Very nice and professional. Works flawlessly in GAMA except that contributions to the toolbar are not accepted (so you have to rely on the commands present in the Navigator pop-up menu).   Update site: http://pathtools.googlecode.com/svn/trunk/PathToolsUpdateSite/site.xml   Website: https://pathtools.googlecode.com   CSV Edit     An editor for CSV files. Quite handy if you do not want to launch Excel every time you need to inspect or change the CSV data files used in models.   Update site: http://csvedit.googlecode.com/svn/trunk/csvedit.update     TM Terminal     A powerful, yet simple, terminal which can connect locally or via ssh or other methods.   Update site (general): http://download.eclipse.org/releases/mars/   Select the following plugin: TM Terminal   Quickimage     A lightweight viewer of images, which can be useful when several images are used in a model.   Update site: http://psnet.nu/eclipse/updates    ","url":"wiki/InstallingPlugins.md"},{"id":"wiki/Launching.md","title":" Launching GAMA","content":"Launching GAMA  Running GAMA for the first time requires that you launch the application (Gama.app on MacOS X, Gama.exe on Windows, Gama on Linux, located in the folder called Gama once you have unzipped the archive). Other folders and files are present here, but you don t have to care about them for the moment. In case you are unable to launch the application, of if error messages appear, please refer to the installation or troubleshooting instructions.  Table of contents     Launching GAMA  Launching the Application       Choosing a Workspace       Welcome Page Launching the Application  Note that GAMA can also be launched in two different other ways:     In a so-called headless mode (i.e. without user interface, from the command line, in order to conduct experiments or to be run remotely). Please refer to the corresponding instructions.   From the terminal, using a path to a model file and the name or number of an experiment, in order to allow running this experiment directly (note that the two arguments are optional: if the second is omitted, the file is imported in the workspace if not already present and opened in an editor; if both are omitted, GAMA is launched as usual):      Gama.app/Contents/MacOS/Gama path_to_a_model_file#experiment_name_or_number on MacOS X   Gama path_to_a_model_file#experiment_name_or_number on Linux   Gama.exe path_to_a_model_file#experiment_name_or_number on Windows     Choosing a Workspace Past the splash screen, GAMA will ask you to choose a workspace in which to store your models and their associated data and settings. The workspace can be any folder in your filesystem on which you have read/write privileges. If you want GAMA to remember your choice next time you run it (it can be handy if you run Gama from the command line), simply check the corresponding option. If this dialog does not show up when launching GAMA, it probably means that you inherit from an older workspace used with GAMA 1.6 or 1.5.1 (and still  remembered ). In that case, a warning will be produced to indicate that the models library is out of date, offering you the possibility to create a new workspace.    You can enter its address or browse your filesystem using the appropriate button. If the folder already exists, it will be reused (after a warning if it is not already a workspace). If not, it will be created. It is always a good idea, when you launch a new version of GAMA for the first time, to create a new workspace. You will then, later, be able to import your existing models into it. Failing to do so might lead to odd errors in the various validation processes.    Welcome Page As soon as the workspace is created, GAMA will open and you will be presented with its first window. GAMA is based on Eclipse and reuses most of its visual metaphors for organizing the work of the modeler. The main window is then composed of several parts, which can be views or editors, and are organized in a perspective. GAMA proposes 2 main perspectives: Modeling, dedicated to the creation of models, and Simulation, dedicated to their execution and exploration. Other perspectives are available if you use shared models.  The default perspective in which GAMA opens is Modeling. It is composed of a central area where GAML editors are displayed, which is surrounded by a Navigator view on the left-hand side of the window, an Outline view (linked with the open editor) and the Problems view, which indicates errors and warnings present in the models stored in the workspace.    In the absence of previously open models, GAMA will display a Welcome page (actually a web page), from which you can find links to the website, current documentation, tutorials, etc. This page can be kept open (for instance if you want to display the documentation when editing models) but it can also be safely closed (and reopened later from the  Views  menu).    From this point, you are now able to edit a new model, navigate in the models libraries, or import an existing model. ","url":"wiki/Launching.md"},{"id":"wiki/Troubleshooting.md","title":" Troubleshooting","content":"Troubleshooting  This page exposes some of the most common problems a user may encounter when running GAMA — and offers advices and workarounds for them. It will be regularly enriched with new contents. Note also that the Issues section of the website might contain precious information on crashes and bugs encountered by other users. If neither the workarounds described here nor the solutions provided by other users allow to solve your particular problem, please submit a new issue report to the developers.  Table of contents     Troubleshooting  Table of contents       On Ubuntu (& Linux Systems)   Workaround if GAMA crashes when displaying web contents Workaround if GAMA does not display the menus (the  Edit  menu is the only one working)   On Windows       On MacOS X   Workaround in case of glitches in the UI Workaround in case of corrupted icons in menus under El Capitan   Memory problems       Submitting an Issue On Ubuntu (& Linux Systems) ### Workaround if GAMA crashes when displaying web contents In case GAMA crashes whenever trying to display a web page or the pop-up online documentation, you may try to edit the file Gama.ini and add the line -Dorg.eclipse.swt.browser.DefaultType=mozilla to it. This workaround is described here: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=705420 and in Issue 700 (on Google Code).  Workaround if GAMA does not display the menus (the  Edit  menu is the only one working) If, when selecting a menu, nothing happens (or, in the case of the  Agents  menu, all population submenus appear empty), it is likely that you have run into this issue: https://bugs.eclipse.org/bugs/show_bug.cgi?id=330563. The only workaround known is to launch GAMA from the command line (or from a shell script) after having told Ubuntu to attach its menu back to its main window. For example (if you are in the directory where the  Gama  executable is present):   export UBUNTU_MENUPROXY=0 ./Gama   No fix can be provided from the GAMA side for the moment.  On Windows No common trouble…  On MacOS X  Workaround in case of glitches in the UI  The only problems reported so far on MacOS X (from Lion to Yosemite) concern visual glitches in the UI and problems with displays, either not showing or crashing the JVM. Most (all ?) of these problems are usually related to the fact that GAMA does not run under the correct version of Java Virtual Machine. In that case, follow these instructions to install the correct version.  Workaround in case of corrupted icons in menus under El Capitan  For some particular configurations (in particular some particular graphic cards), the icons of the menus (e.g. Edit menu) may be corrupted. This bug is documented for all RCP products under El Capitan. See these references: https://bugs.eclipse.org/bugs/show_bug.cgi?id=479590 https://trac.filezilla-project.org/ticket/10669  These is nothing we can do now except using the workaround that consists in switching the language of the OS to English (in System Preferences, Language & Region).  Memory problems The most common causes of problems when running GAMA are memory problems. Depending on your activities, on the size of the models you are editing, on the size of the experiments you are running, etc., you have a chance to require more memory than what is currently allocated to GAMA. A typical GAMA installation  will need between 40 and 200MB of memory to run  normally  and launch small models. Memory problems are easy to detect: on the bottom right corner of its window, GAMA will always display the status of the current memory. The first number represents the memory currently used (in MB), the second (always larger) the memory currently allocated by the JVM. And the little trash icon allows to  garbage collect  the memory still used by agents that are not used anymore (if any). If GAMA appears to hang or crash and if you can see that the two numbers are very close, it means that the memory required by GAMA exceeds the memory allocated.    There are two ways to circumvent this problem: the first one is to increase the memory allocated to GAMA by the Java Virtual Machine. The second, detailed on this page is to try to optimize your models to reduce their memory footprint at runtime. To increase the memory allocated, first locate the file called Gama.ini. On Windows and Ubuntu, it is located next to the executable. On MacOS X, you have to right-click on Gama.app, choose  Display Package Contents… , and you will find Gama.ini in Contents/MacOS. This file typically looks like the following (some options/keywords may vary depending on the system), and we are interested in two JVM arguments:    -Xms supplies the minimal amount of memory the JVM should allocate to GAMA, -Xmx the maximal amount. By changing these values (esp. the second one, of course, for example to 4096M, or 4g), saving the file and relaunching GAMA, you can probably solve your problem. Note that 32 bits versions of GAMA will not accept to run with a value of -Xmx greater than 1500M. See here for additional information on these two options.  Submitting an Issue If you think you have found a new bug/issue in GAMA, it is time to create an issue report here ! Alternatively, you can click the Issues tab on the project site, search if a similar problem has already been reported (and, maybe, solved) and, if not, enter a new issue with as much information as possible:   * A complete description of the problem and how it occurred.   * The GAMA model or code you are having trouble with. If possible, attach a complete model.   * Screenshots or other files that help describe the issue.  Two files may be particularly interesting to attach to your issue: the configuration details and the error log. Both can be obtained quite easily from within GAMA itself in a few steps. First, click the  About GAMA…  menu item (under the  Gama  menu on MacOS X,  Help  menu on Linux & Windows)  In the dialog that appears, you will find a button called  Installation Details .    Click this button and a new dialog appears with several tabs.    To provide a complete information about the status of your system at the time of the error, you can  (1) copy and paste the text found in the tab  Configuration  into your issue. Although, it is preferable to attach it as a text file (using textEdit, Notepad or Emacs e.g.) as it may be too long for the comment section of the issue form.  (2) click the  View error log  button, which will bring you to the location, in your file system, of a file called  log , which you can then attach to your issue as well.   ","url":"wiki/Troubleshooting.md"},{"id":"wiki/Updating.md","title":" Updating GAMA","content":"Updating GAMA  Unless you are using the version of GAMA built from the sources available in the GIT repository of the project (see here), you are normally running a specific release of GAMA that sports a given version number (e.g. GAMA 1.6.1, GAMA 1.7, etc.). When new features were developed, or when serious issues were fixed, the release you had on your disk, prior to GAMA 1.6.1, could not benefit from them. Since this version, however, GAMA has been enhanced to support a self_update mechanism, which allows to import from the GAMA update site additional plugins (offering new features) or updated versions of the plugins that constitute the core of GAMA.  Table of contents     Updating GAMA  Manual Update       Automatic Update Manual Update To activate this feature, you have to invoke the  Check for Updates  or  Install New Software…  menu commands in the  Help  menu.  The first one will only check if the existing plugins have any updates available, while the second will, in addition, scan the update site to detect any new plugins that might be added to the current installation.    In general, it is preferable to use the second command, as more options (including that of desinstalling some plugins) are provided. Once invoked, it makes the following dialog appear:    GAMA expects the user to enter a so-called update site. You can copy and paste the following line (or choose it from the drop-down menu as this address is built inside GAMA):  http://updates.gama-platform.org   GAMA will then scan the entire update site, looking both for new plugins (the example below) and updates to existing plugins. The list available in your installation will of course be different from the one displayed here.    Choose the ones you want to install (or update) and click  Next… . A summary page will appear, indicating which plugins will actually be installed (since some plugins might require additional plugins to run properly), followed by a license page that you have to accept. GAMA will then proceed to the installation (that can be cancelled any time) of the plugins chosen.  During the course of the installation, you might receive the following warning, that you can dismiss by clicking  OK .    Once the plugins are installed, GAMA will ask you whether you want to restart or not. It is always safer to do so, so select  Yes  and let it close by itself, register the new plugins and restart.    Automatic Update GAMA offers a mechanism to monitor the availability of updates to the plugins already installed. To install this feature, open the preferences of GAMA and choose the button  Advanced… , which gives access to additional preferences.    In the dialog that appears, navigate to  Install/Update > Automatic Updates . Then, enable the option using the check-box on the top of the dialog and choose the best settings for your workflow. Clicking on  OK  will save these preferences and dismiss the dialog.    From now on, GAMA will continuously support you in having an up-to-date version of the platform, provided you accept the updates. ","url":"wiki/Updating.md"},{"id":"wiki/BatchSpecific.md","title":" Batch Specific UI","content":"Batch Specific UI  When an experiment of type Batch is run, a dedicated UI is displayed, depending on the parameters to explore and of the exploration methods.  Table of contents     Batch Specific UI  Information bar       Batch UI Information bar  In batch mode, the top information bar displays 3 distinct information (instead of only the cycle number in the GUI experiment):   * The run number: One run corresponds to X executions of simulation with one given parameters values (X is an integer given by the facet repeat in the definition of the exploration method);   * The simulation number: the number of replications done (and the number of replications specified with the repeat facet);   * The number of thread: the number of threads used for the simulation.    Batch UI  The parameters view is also a bit different in the case of a Batch UI. The following interface is generated given the following model part:     experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed) or (time > 400) {    parameter  Size of the grid:  var: gridsize init: 75 unit:  width and height ;    parameter  Number:  var: ants_number init: 200 unit:  ants ;    parameter  Evaporation:  var: evaporation_rate among: [0.1, 0.2, 0.5, 0.8, 1.0] unit:  rate every cycle (1.0 means 100%) ;    parameter  Diffusion:  var: diffusion_rate min: 0.1 max: 1.0 unit:  rate every cycle (1.0 means 100%)  step: 0.3;  method exhaustive maximize: food_gathered;        The interface summarizes all model parameters and the parameters given to the exploration method:   * Environment and Population: displays all the model parameters that should not be explored;   * Parameters to explore: the parameters to explore are the parameters defined in the experiment with a range of values (with among facet or min, max and step facets);   * Exploration method: it summarizes the Exploration method and the stop condition. For exhaustive method it also evaluates the parameter space. For other methods, it also displays the method parameters (e.g. mutation or crossover probability…). Finally the best fitness found and the last fitness found are displayed (with the associated parameter set). ","url":"wiki/BatchSpecific.md"},{"id":"wiki/Displays.md","title":" Displays","content":"Displays  GAMA allows modelers to define several and several kinds of displays in a GUI experiment:   * java 2D displays   * OpenGL displays  These 2 kinds of display allows the modeler to display the same objects (agents, charts, texts …). The OpenGL display offers extended features in particular in terms of 3D visualisation. The OpenGL displays offers in addition better performance when zooming in and out.  Table of contents     Displays  Classical displays (java2D)       OpenGL displays Classical displays (java2D)  The classical displays displaying any kind of content can be manipulated via the mouse (if no mouse event has been defined): * the mouse left press and move allows to move the camera (in 2D), * the mouse right click opens a context menu allowing the modeler to inspect displayed agents, * the wheel allows the modeler to zoom in or out.    Each display provides several buttons to manipulate the display (from left to right):   * Show/hide side bar,   * Show/hide overlay,   * Browse through all displayed agents: open a context menu to inspect agents,   * Update every X step: configure the refresh frequence of the display,   * Pause the-display: when pressed, the display will not be displayed anymore, the simulation is still running,   * Synchronize the display and the execution of the model,   * Zoom in,   * Zoom to fit view,   * Zoom out,   * Take a snapshot: take a snapshot saved as a png image in the snapshots folder of the models folder.  The Show/Hide side bar button opens a side panel in the display allowing the modeler to configure:   * Properties of the display: background and highlight color, display the scale bar   * For each layer, we can configure visibility, transparency, position and size of the layer. For grid layers, we can in addition show/hide grids. For species layers, we can also configure the displayed aspect. For text layers, we can the expression displayed with the color and the font.  The bottom overlay bar displays information about the way it is displayed:   * the position of the mouse in the display,   * the zoom ratio,   * the scale of the display (depending on the zoom).    OpenGL displays  The OpenGL display has an additional button 3D Options providing 3D features:   * Use FreeFly camera/Use Arcball camera: switch between cameras, the default camera is the Arcball one,   * Use mouse to rotate/Use mouse to drag (only with Arcball camera): use left click for one of the 2 actions, left click + Ctrl for the other of the 2 actions.   * Apply inertia (only with Arcball camera): in inertia mode, when the modeler stops moving the camera, there is no straight halt but a kind of inertia.   * Rotate scene: rotate the scene around an axis orthogonal to the scene,   * Split layers/Merge layers: display each layer at a distinct height,   * Triangulate scene: display the polygon primitives.    In addition, the bottom overlay bar provides the Camera position in 3D.  FreeFly camera commands       Key       Function   Double Click       Zoom Fit       +       Zoom In       -       Zoom Out       Up       Move forward       Down       Move backward       Left       Strafe left       Right       Strafe right       SHIFT+Up       Look up       SHIFT+Down       Look down       SHIFT+Left       Look left       SHIFT+Right       Look right       MOUSE       Makes the camera look up, down, left and right       MouseWheel       Zoom-in/out to the current target (center of the screen) ArcBall camera commands       Key       Function   Double Click       Zoom Fit       +       Zoom In       -       Zoom Out       Up       Horizontal movement to the top       Down       Horizontal movement to the bottom       Left       Horizontal movement to the left       Right       Horizontal movement to the right       SHIFT+Up       Rotate the model up (decrease the phi angle of the spherical coordinates)       SHIFT+Down       Rotate the model down (increase the phi angle of the spherical coordinates)       SHIFT+Left       Rotate the model left (increase the theta angle of the spherical coordinates)       SHIFT+Right       Rotate the model right (decrease the theta angle of the spherical coordinates)       SPACE       Reset the pivot to the center of the envelope       KEYPAD 2,4,6,8       Quick rotation (increase/decrease phi/theta by 30°)       CMD+MOUSE1       Makes the camera rotate around the model       ALT+LEFT_MOUSE       Enables ROI Agent Selection       SHIFT+LEFT_MOUSE       Enables ROI Zoom       SCROLL       Zoom-in/out to the current target (center of the sphere)       WHEEL CLICK       Reset the pivot to the center of the envelope   ","url":"wiki/Displays.md"},{"id":"wiki/ErrorsView.md","title":" Errors View","content":"Errors View  Whenever a runtime error, or a warning, is issued by the currently running experiment, a view called  Errors  is opened automatically. This view provides, together with the error/warning itself, some contextual information about who raised the error (i.e. which agent(s)) and where (i.e. in which portion of the model code). As with other  status  in GAMA, errors will appear in red color and warnings in orange.  Since an error appearing in the code is likely to be raised by several agents at once, GAMA groups similar errors together, simply indicating which agent(s) raised them. Note that, unless the error is raised by the experiment agent itself, its message will indicate that at least 2 agents raised it: the original agent and the experiment in which it is plunged.   ","url":"wiki/ErrorsView.md"},{"id":"wiki/ExperimentsUserInterface.md","title":" Experiments User Interface","content":"Experiments User Interface  As soon as an experiment is launched, the modeler is facing a new environment (with different menus and views) called the Simulation Perspective). The Navigator is still opened in this perspective, though, and it is still possible to edit models in it, but it is considered as good practice to use each perspective for what is has been designed for. Switching perspectives is easy. The small button in the top-left corner of the window allows to switch back and forth the two perspectives.    The actual contents of the simulation perspective will depend on the experiment being run and the outputs it defines. The next sections will present the most common ones (inspectors, monitors and displays), as well as the views that are not defined in outputs, like the Parameters or Errors view. An overview of the menus and commands specific to the simulation perspective is also available. ","url":"wiki/ExperimentsUserInterface.md"},{"id":"wiki/InspectorsAndMonitors.md","title":" Inspectors and monitors","content":"Inspectors and monitors  GAMA offers some tools to obtain informations about one or several agents. There are two kinds of tools : * agent browser * agent inspector  GAMA offers as well a tool to get the value of a specific expression: monitors.  Table of contents     Inspectors and monitors  Agent Browser       Agent Inspector       Monitor Agent Browser The species browser provides informations about all or a selection of agents of a species.  The agent browser is available through the Agents menu or by right clicking on a display (screenshots from the ).      It displays in a table all the values of the agent variables of the considered species; each line corresponding to an agent. The list of attributes is displayed on the left side of the view, and you can select the attributes you want to be displayed, simply by clicking on it (Ctrl + Click for multi-selection).    By clicking on the right mouse button on a line, it is possible to do some action for the corresponding agent.  Agent Inspector The agent inspector provides information about one specific agent. It also allows to change the values of its variables during the simulation. The agent inspector is available from the Agents menu, by right_clicking on a display, in the species inspector or when inspecting another agent.    It is possible to «highlight» the selected agent.    To change the color of the highlighted agent, go to Preferences/Display.    Monitor Monitors allow to follow the value of a GAML expression. For instance the following monitor allow to follow the number of infected people agents during the simulation. The monitor is updated at each simulation step.    It is possible to define a monitor inside a model (see this page). It is also possible to define a monitor through the graphical interface.  To define a monitor, first choose Add Monitor in the Views menu (or by clicking on the icon in the Monitor view), then define the display legend and the expression to monitor.    In the following example, we defined a monitor with the legend  Number initial of preys  and that has for value the global variable  nb_preys_init .    The expression should be written with the GAML language. See this page for more details about the GAML language. ","url":"wiki/InspectorsAndMonitors.md"},{"id":"wiki/LaunchingExperiments.md","title":" Launching Experiments from the User Interface","content":"Launching Experiments from the User Interface  GAMA supports multiple ways of launching experiments from within the Modeling Perspective, in editors or in the navigator.  Table of contents     Launching Experiments from the User Interface  From an Editor       From the Navigator       Running Experiments Automatically       Running Several Simulations From an Editor As already mentioned on this page, GAML editors will provide the easiest way to launch experiments. Whenever a model that contains the definition of experiments is validated, these experiments will appear as distinct buttons, in the order in which they are defined in the file, in the header ribbon above the text. Simply clicking one of these buttons launches the corresponding experiment.    For each of those launching buttons, you can see 2 different pictograms, showing the type of experiment. An experiment can either be a GUI Experiment or a Batch Experiment.    From the Navigator You can also launch your experiments from the navigator, by expanding a model and double clicking on one of the experiments available (The number of experiments for each model is visible also in the navigator). As for the editor, the two types of experimentations (gui and batch) are differentiated by a pictogram.    Running Experiments Automatically Once an experiment has been launched (unless it is run in headless mode, of course), it normally displays its views and waits from an input from the user, usually a click on the  Run  or  Step  buttons (see here).  It is however possible to make experiments run directly once launched, without requiring any intervention from the user.  To install this feature, open the preferences of GAMA. On the first tab, simply check  Auto-run experiments when they are launched  (which is unchecked by default) and hit  OK  to dismiss the dialog. Next time you ll launch an experiment, it will run automatically (this option also applies to experiments launched from the command line).    Running Several Simulations  It is possible in GAMA to run several simulations. Each simulation will be launched with the same seed (which means that if the parameters are the same, then the result will be exactly the same). All those simulations are synchronized in the same cycle.  To run several experiments, you have to write it directly in your model.   ","url":"wiki/LaunchingExperiments.md"},{"id":"wiki/MenusAndCommands.md","title":" Menus and Commands","content":"Menus and Commands  The simulation perspective adds on the user interface a number of new menus and commands (i.e. buttons) that are specific to experiment-related tasks.  Table of contents     Menus and Commands  Experiment Menu       Agents Menu       General Toolbar Experiment Menu A menu, called  Experiment , allows to control the current experiment. It shares some of its commands with the general toolbar (see below).       Run/Pause: allows to run or pause the experiment depending on its current state.   Step by Step: runs the experiment for one cycle and pauses it after.   Reload: stops the current experiment, deletes its contents, and reloads it, taking into account the parameters values that might have been changed by the user.   Stop at first error: if checked, the current experiment will stop running when an error is issued. The default value can be configured in the preferences.   Treat warnings as errors: if checked, a warning will be considered as an error (and if the previous item is checked, will stop the experiment). The default value can be configured in the preferences.   Display warnings and errors: if checked, displays the errors and warnings issued by the experiment. If not, do not display them. The default value can be configured in the preferences.   Force interrupt: forces the experiment to stop, whatever it is currently doing, purges the memory from it, and switches to the modeling perspective. Use this command with caution, as it can have undesirable effects depending on the state of the experiment (for example, if it is reading files, or outputting data, etc.).   Agents Menu  A second menu is added in the simulation perspective:  Agents . This menu allows for an easy access to the different agents that populate an experiment.    This hierarchical menu is always organized in the same way, whatever the experiment being run. A first level is dedicated to the current simulation agent: it allows to browse its population or to inspect the simulation agent itself. Browsing the population will give access to the current experiment agent (the  host  of this population). A second level lists the  micro-populations  present in the simulation agent. And the third level will give access to each individual agent in these populations. This organization is of course recursive: if these agents are themselves hosts of micro-populations, they will be displayed in their individual menu.    Each agent, when selected, will reveal a similar individual menu. This menu will contain a set of predefined actions, the commands defined by the user for this species, if any, and then the micro-populations hosted by this agent, if any. Agents (like the instances of  ant  below) that do not host other agents and whose species has no user commands will have a  simple  individual menu.    These are the 4 actions that will be there most of the time:     Inspect: open an inspector on this agent.   Highlight: makes this agent the current  highlighted  agent, forcing it to appear  highlighted  in all the displays that might have been defined.   Focus: this option is not accessible if no displays are defined. Makes the current display zoom on the selected agent (if it is displayed) so that it occupies the whole view.   Kill: destroys the selected agent and disposes of it. Use this command with caution, as it can have undesirable effects if the agent is currently executing its behavior.   If an agent hosts other agents (it is the case in multi-level architecture), you can access to the micro-population quite easily:    If user commands are defined for a species (for example in the existing model Features/Driving Skill/Road Traffic simple (City)), their individual menu will look like the following:    General Toolbar  The last piece of user interface specific to the Simulation Perspective is a toolbar, which contains controls and information displays related to the current experiment.  This toolbar is voluntarily minimalist, with three buttons already present in the experiment menu (namely,  Play/Pause ,  Step by Step  and  Reload ), which don t need to be detailed here, and two new controls ( Experiment status  and  Cycle Delay ), which are explained below.    While opening an experiment, the status will display some information about what s going on. For instance, that GAMA is busy instantiating the agents, or opening the displays.      The orange color usually means that, although the experiment is not ready, things are progressing without problems (a red color message is an indication that something went wrong). When the loading of the experiment is finished, GAMA displays the message  Simulation ready  on a green background. If the user runs the simulation, the status changes and displays the number of cycles already elapsed in the simulation currently managed by the experiment.    Hovering over the status produces a more accurate information about the internal clock of the simulation.    From top to bottom of this hover, we find the number of cycles elapsed, the simulated time already elapsed (in the example above, one cycle lasts one second of simulated time), the duration of cycle in milliseconds, the average duration of one cycle (computed over the number of cycles elapsed), and the total duration, so far, of the simulation (still in milliseconds).  Although these durations are entirely dependent on the speed of the simulation engine (and, of course, the number of agents, their behaviors, etc.), there is a way to control it partially with the second control, which allows the user to force a minimal duration (in milliseconds) for a cycle, from 0 (its initial position) to 1000. Note that this minimal duration (or delay) will remain the same for the subsequent reloads of the experiment.    In case it is necessary to have more than 1s of delay, it has to be defined, instead, as an attribute of the experiment. ","url":"wiki/MenusAndCommands.md"},{"id":"wiki/ParametersView.md","title":" Parameters View","content":"Parameters View  In the case of an experiment, the modeler can define the parameters he wants to be able to modify to explore the simulation, and thus the ones he wants to be able to display and alter in the GUI interface.  It important to notice that all modification made in the parameters are used for simulation reload only. Creation of a new simulation from the model will erase the modifications.  Table of contents     Parameters View  Built-in parameters       Parameters View       Modification of parameters values Built-in parameters Every GUI experiment displays a pane named  Parameters  containing at least two built-in parameters related to the random generator:   * the Random Number Generator, with a choice between 3 RNG implementations,   * the Random Seed    Parameters View The modeler can define himself parameters that can be displayed in the GUI and that are sorted by categories. Note that the interface will depend on the data type of the parameter: for example, for integer or float parameters, a simple text box will be displayed whereas a color selector will be available for color parameters. The parameters value displayed are the initial value provided to the variables associated to the parameters in the model.    The above parameters view is generated from the following code:     global {  int i;  float f;  string s;  list l;  matrix m;  pair p;  rgb c; }  experiment maths type: gui {     parameter  my_integer  var: i <- 0 category: Simple types ;     parameter  my_float  var: f <- 0.0 category: Simple types ;     parameter  my_string  var: s <-    category: Simple types ;  parameter my_list var: l <- [] category:Complex types; parameter my_matrix var: m <- matrix([[1,2],[3,4]]) category:Complex types; parameter my_pair var: p <- 3::5 category:Complex types; parameter my_color var: c <- #green category:Complex types;  output {} }     Click on Edit button in case of list or map parameters or the color or matrix will open an additional window to modify the parameter value.   Modification of parameters values  The modeler can modify the parameter values. After modifying the parameter values, you can reload the simulation by clicking on the top-right circular arrow button.  You can also add a new simulation to the old one, using those new parameters, by clicking on the top-right plus symbol button.  If he wants to come back to the initial value of parameters, he can click on the top-right red curved arrow of the parameters view. ","url":"wiki/ParametersView.md"},{"id":"wiki/ChangingWorkspace.md","title":" Changing Workspace","content":"Changing Workspace  It is possible, and actually common, to store different projects/models in different workspaces and to tell GAMA to switch between these workspaces. Doing so involves being able to create one or several new workspace locations (even if GAMA has been told to remember the current one) and being able to easily switch between them.  Table of contents     Changing Workspace  Switching to another Workspace       Cloning the Current Workspace Switching to another Workspace This process is similar to the choice of the workspace location when GAMA is launched for the first time. The only preliminary step is to invoke the appropriate command ( Switch Workspace ) from the  File  menu.    In the dialog that appears, the current workspace location should already be entered. Changing it to a new location (or choosing one in the file selector invoked by clicking on  Browse… ) and pressing  OK  will then either create a new workspace if none existed at that location or switch to this new workspace. Both operations will restart GAMA and set the new workspace location. To come back to the previous location, just repeat this step (the previous location is normally now accessible from the combo box).    Cloning the Current Workspace Another possibility, if you have models in your current workspace that you would like to keep in the new one (and that you do not want to import one by one after switching workspace), or if you change workspace because you suspect the current one is corrupted, or outdated, etc. but you still want to keep your models, is to clone the current workspace into a new (or existing) one.  Please note that cloning (as its name implies) is an operation that will make a copy of the files into a new workspace. So, if projects are stored in the current workspace, this will result in two different instances of the same projets/models with the same name in the two workspaces. However, for projects that are simply linked from the current workspace, only the link will be copied (which allows to have different workspaces  containing  the same project)  This can be done by entering the new workspace location and choosing  Clone current workspace  in the previous dialog instead of  Ok .    If the new location does not exist, GAMA will ask you to confirm the creation and cloning using a specific dialog box. Dismissing it will cancel the operation.    If the new location is already the location of an existing workspace, another confirmation dialog is produced. It is important to note that all projects in the target workspace will be erased and replaced by the projects in the current workspace if you proceed. Dismissing it will cancel the operation.    There are two cases where cloning is not accepted. The first one is when the user tries to clone the current workspace into itself (i.e. the new location is the same as the current location).    The second case is when the user tries to clone the current workspace into one of its subdirectories (which is not feasible).   ","url":"wiki/ChangingWorkspace.md"},{"id":"wiki/ImportingModels.md","title":" Importing Models","content":"Importing Models  Importing a model refers to making a model file (or a complete project) available for edition and experimentation in the workspace. With the exception of headless experiments, GAMA requires that models be manageable in the current workspace to be able to validate them and eventually experiment them.  There are many situations where a model needs to be imported by the user: someone sent it to him/her by mail, it has been attached to an issue report, it has been shared on the web or an SVN server, or it belongs to a previous workspace after the user has switched workspace. The instructions below apply equally to all these situations.  Since model files need to reside in a project to be managed by GAMA, it is usually preferable to import a whole project rather than individual files (unless, of course, the corresponding models are simple enough to not require any additional resources, in which case, the model file can be imported with no harm into an existing project). GAMA will then try to detect situations where a model file is imported alone and, if a corresponding project can be found (for instance, in the upper directories of this file), to import the project instead of the file. As the last resort, GAMA will import orphan model files into a generic project called  Unclassified Models  (which will be created if it does not exist yet).  Table of contents     Importing Models  The  Import…  Menu Command       Silent import       Drag n Drop / Copy-Paste Limitations The  Import…  Menu Command The simplest, safest and most secure way to import a project into the workspace is to use the built-in  Import…  menu command, available in the  File  menu or in the contextual menu of the Navigator.    When invoked, this command will open a dialog asking the user to choose the source of the importation. It can be a directory in the filesystem (in which GAMA will look for existing projects), a zip file, a SVN site, etc. It is safer in any case to choose  Existing Projects into Workspace .    Note that when invoked from the contextual menu,  Import…  will directly give access to a shortcut of this source in a submenu.    Both options will lead the user to a last dialog where he/she will be asked to:     Enter a location (or browse to a location) containing the GAMA project(s) to import   Choose among the list of available projects (computed by GAMA) the ones to effectively import   Indicate whether or not these projects need to be copied to or linked from the workspace (the latter is done by default)     Silent import Another (possibly simpler, but less controllable) way of importing projects and models is to either pass a path to a model when launching GAMA from the command line or to double-click on a model file (ending in .gaml) in the Explorer or Finder (depending on your OS).  If the file is not already part of an imported project in the current workspace, GAMA will:     silently import the project (by creating a link to it),   open an editor on the file selected.   This procedure may fail, however, if a project of the same name (but in a different location) already exists in the workspace, in which case GAMA will refuse to import the project (and hence, the file). The solution in this case is to rename the project to import (or to rename the existing project in the workspace).  Drag n Drop / Copy-Paste Limitations Currently, there is no way to drag and drop an entire project into GAMA Navigator (or to copy a project in the filesystem and paste it in the Navigator). Only individual model files, folders or resources can be moved this way (and they have to be dropped or pasted into existing projects).  This limitation might be removed some time in the future, however, allowing users to use the Navigator as a project drop or paste target, but it is not the case yet. ","url":"wiki/ImportingModels.md"},{"id":"wiki/NavigatingWorkspace.md","title":" Navigating in the Workspace","content":"Navigating in the Workspace  All the models that you edit or run using GAMA are accessible from a central location: the Navigator, which is always on the left-hand side of the main window and cannot be closed. This view presents the models currently present in (or linked from) your workspace.    Table of contents     Navigating in the Workspace  The Different Categories of Models   Models library Plugin models User models   Inspect Models       Moving Models Around       Closing and Deleting Projects The Different Categories of Models  In the Navigator, models are organized in three different categories: Models library, Plugin models, and User models. This organization is purely logical and does not reflect where the models are actually stored in the workspace (or elsewhere). Whatever their actual location, model files need to be stored in projects, which may contain also other files (called resources) necessary for the models to function. A project may of course contain several model files, especially if they are importing each other, if they represent different models on the same topic, or if they share the same resources.    Models library  This category represents the models that are shipped with each version of GAMA. They do not reside in the workspace, but are considered as linked from it. This link is established every time a new workspace is created. Their actual location is within a plugin (msi.gama.models) of the GAMA application. This category contains four main projects in GAMA 1.6.1, which are further refined in folders and sub-folders that contain model files and resources.    It may happen, in some occasions, that the library of models is not synchronized with the version of GAMA that uses your workspace. This is the case if you use different versions of GAMA to work with the same workspace. In that case, it is required that the library be manually updated. This can be done using the  Update library  item in the contextual menu.    To look up for a particular model in the library, users can use the  Search for file  menu item. A search dialog is then displayed, which allows to look for models by their title (for example, models containing  GIS  in the example below).     Plugin models  This category represents the models that are related to a specific plugin (additional or integrated by default). The corresponding plugin is shown between parenthesis.    For each projects, you can see the list of plugins needed, and a caption to show you if the plugin is actually installed in your GAMA version or not : green if the plugin is installed, red otherwise.  User models  This category regroups all the projects that have been created or imported in the workspace by the user. Each project is actually a folder that resides in the folder of the workspace (so they can be easily located from within the filesystem). Any modification (addition, removal of files…) made to them in the file system (or using another application) is immediately reflected in the Navigator and vice-versa.  Model files, although it is by no means mandatory, usually reside in a sub-folder of the project called  models .    Inspect Models  Each models is presented as a node in the navigation workspace, including Experiment buttons and/or Requires node and/or Uses node.  Experiment button : Experiment button are present if your model contains experiments (it is usually the case !). To run the corresponding experiment, just click on it. To learn more about running experiments, jump into this section. Require node : The node Require is present if your model uses some plugins (additional or integrated by default). Each plugin is listed in this node, with a green icon if the plugin is already installed in your GAMA, and a red one if it is not the case. If the plugin you want in not installed, an error will be raised in your model. Please read about how to install plugins to learn some more about it. Uses node : The node Uses is present if your model uses some external resources, and if the path to the resource is correct (if the path to the resource is not correct, the resource will not be displayed under Uses)      Moving Models Around Model files, as well as resources, or even complete projects, can be moved around between the  Models Library / Plugin Models  and  Users Models  categories, or within them, directly in the Navigator. Drag n drop operations are supported, as well as copy and paste. For example, the model  Life.gaml , present in the  Models Library , can perfectly be copied and then pasted in a project in the  Users Model . This local copy in the workspace can then be further edited by the user without altering the original one.    Closing and Deleting Projects Users can choose to get rid of old projects by either closing or deleting them. Closing a project means that it will still reside in the workspace (and be still visible, although a bit differently, in the Navigator) but its model(s) won t participate to the build process and won t be displayable until the project is opened again.     Deleting a project must be invoked when the user wants this project to not appear in the workspace anymore (unless, that is, it is imported again). Invoking this command will effectively make the workspace  forget  about this project, and this can be further doubled with a deletion of the projects resources and models from the filesystem.    ","url":"wiki/NavigatingWorkspace.md"},{"id":"wiki/EditingModels.md","title":" Editing models","content":"Editing models  Editing models in GAMA is very similar to editing programs in a modern IDE like Eclipse. After having successfully launched the program, the user has two fundamental concepts at its disposal: a workspace, which contains models or links to models organized like a hierarchy of files in a filesystem, and the workbench (aka, the main window), which contains the tools to create, modify and experiment these models.  Understanding how to navigate in the workspace is covered in another section and, for the purpose of this section, we just need to understand that it is organized in projects, which contain models and their associated data. Projects are further categorized, in GAMA, into three categories : Models Library (built-in models shipped with GAMA and automatically linked from the workspace), Shared Models, and User Models.  This section covers the following sub-sections :       GAML Editor Generalities   GAML Editor Toolbar   Validation of Models   Graphical Editor   ","url":"wiki/EditingModels.md"},{"id":"wiki/InstallationAndLaunching.md","title":" Installation and Launching","content":"Installation and Launching  The GAMA platform can be easily installed in your machine, either if you are using Windows, Mac OS or Ubuntu. GAMA can then be extended by using a number of additional plugins.  This part is dedicated to explain how to install GAMA, launching GAMA and extend the platform by installing additional plugins. All the known issues concerning installation are also explain. The GAMA team provides you a continuous support by proposing corrections to some serious issues through updating patchs. In this part, we will also present you briefly an other way to launch GAMA without any GUI : the headless mode.     Installation   Launching GAMA   Headless Mode   Updating GAMA   Installing Plugins   Troubleshooting  ","url":"wiki/InstallationAndLaunching.md"},{"id":"wiki/Preferences.md","title":" Preferences","content":"Preferences  Various preferences are accessible in GAMA to allow users and modelers to personalize their working environment. This section review the different preference tabs available in the current version of GAMA, as well as how to access the preferences and settings inherited by GAMA from Eclipse.  Please note that the preferences specific to GAMA will be shared, on a same machine, and for a same user, among all the workspaces managed by GAMA. Changing workspace will not alter them. If you happen to run several instances of GAMA, they will also share these preferences.  Table of contents     Preferences  Opening Preferences       Simulation       Display       Editor       External       Advanced Preferences Opening Preferences To open the preferences dialog of GAMA, either click on the small  form  button on the top-left corner of the window or select  Preferences…  from the Gama,  Help  or  Views  menu depending on your OS.    Simulation       Random Number Generation: all the options pertaining to generating random numbers in simulations  Random Number Generator: the name of the generator to use by default (if none is specified in the model).       Define a default seed: whether or not a default seed should be used if none is specified in the model  (otherwise it is chosen randomly by GAMA)       Default Seed value: the value of this default seed       Include in the parameters of models: whether the choice of generator and seed is included by default in the parameters views of experiments or not. Errors: how to manage and consider simulation errors  Display Errors: whether errors should be displayed or not.       Number of errors to display: how many errors should be displayed at once       Display most recent first: errors will be sorted in the inverse chronological order if true.       Stop simulation at first error: if false, the simulations will display the errors and continue (or try to).       Treat warnings as errors: if true, no more distinction is made between warnings (which do not stop the simulation) and errors (which can potentially stop it. Runtime: various settings regarding the execution of experiments.  Default Step for Delay Slider: the number of seconds that one step of the slider used to impose a delay between two cycles of a simulation lasts.       Auto-run experiments when they are launched: see this page.       Ask to close the previous simulation before launching a new one: if false, previous simulations (if any) will be closed without warning. UI       Menus  Break down agents in menu every: when inspecting a large number of agents, how many should be displayed before the decision is made to separate the population in sub-menus.       Sort colors menu by       Sort operators menu by Console  Max. number of characters to display in the console (-1 means no limit)       Max. number of characters to keep in memory when console is paused (-1 means no limit) Icons  Icons and buttons dark mode (restart to see the change): Change the highlight for the icons and the button.       Size of icons in the UI (restart to see the change): Size of the icons in pixel Viewers  Default shapefile viewer fill color:       Default shapefile viewer line color:       Default image viewer background color: Background color for the image viewer (when you select an image from the model explorer for example) General       Startup  Display welcome page at startup: if true, and if no editors are opened, the welcome page is displayed when opening GAMA. Display       Properties: various properties of displays  Default display method: use either  Java2D  or  OpenGL  if nothing is specified in the declaration of a display.       Synchronize displays with simulations: if true, simulation cycles will wait for the displays to have finished their rendering before passing to the next cycle (this setting can be changed on an individual basis dynamically here).       Show display overlay: if true, the bottom overlay is visible when opening a display.       Show scale bar in overlay: if true, the scale bar is displayed in the bottom overlay.       Apply antialiasing: if true, displays are drawn using antialiasing, which is slower but renders a better quality of image and text (this setting can be changed on an individual basis dynamically here).       Default background color: indicates which color to use when none is specified in the declaration of a display.       Default highlight color: indicates which color to use for highlighting agents in the displays.       Stack displays on screen…: if true, the display views, in case they are stacked on one another, will put the first display declared in the model on top of the stack. Default Aspect: which aspect to use when an  agent  or  species  layer does not indicate it  Default shape: a choice between  shape  (which represents the actual geometrical shape of the agent) and geometrical operators ( square , etc.).       Default size: what size to use. This expression must be a constant.       Default color: what color to use.       Default font to use in text layers or draw statements when none is specified OpenGL: various properties specific to OpenGL-based displays  Use improved z positioning: if true, two agents positioned at the same z value will be slightly shifted in z in order to draw them more accurately.       Draw 3D referential: if true, the shape of the world and the 3 axes are drawn       Show number of frames per second       Enable lighting: if true, lights can be defined in the display       Draw normals to objects: if true, the  normal  of each object is displayed together with it.       Display as a cube: if true, the scene is drawn on all the facets of a cube. Editor    Most of the settings and preferences regarding editors can be found in the advanced preferences.     Options  Automatically switch to Modeling Persepective: if true, if a model is edited in the Simulation Perspective, then the perspective is automatically switched to Modeling (inactive for the moment)       Automatically close curly brackets ({)       Automatically close square brackets (])       Automatically close parenthesis       Mark occurrences of symbols in models: if true, when a symbol is selected in a model, all its occurrences are also highlighted.       Applying formatting to models on save: if true, every time a model file is saved, its code is formatted.       Save all model files before launching an experiment       Ask before saving each file Validation  Show warning markers when editing a model       Show information markers when editing a model Presentation  Turn on colorization of code sections by default       Font of editors       Background color of editors Toolbars  Show edition toolbar by default       Show other models  experiments in toolbar: if true, you are able to launch other models  experiments from a particular model. External    These preferences pertain to the use of external libraries or data with GAMA.     Paths  Path to Spatialite: the path to the Spatialite library (http://www.gaia-gis.it/gaia-sins/) in the system.       Path to RScript: the path to the RScript library (http://www.r-project.org) in the system. GIS Coordinate Reference Systems: settings about CRS to use when loading or saving GIS files  Let GAMA decide which CRS to use to project GIS data: if true, GAMA will decide which CRS, based on input, should be used to project GIS data. Default is false (i.e. only one CRS, entered below, is used to project data in the models)       …or use the following CRS (EPSG code): choose a CRS that will be applied to all GIS data when projected in the models. Please refer to http://spatialreference.org/ref/epsg/ for a list of EPSG codes.       When no .prj file or CRS is supplied, consider GIS data to be already projected: if true, GIS data that is not accompanied by a CRS information will be considered as projected using the above code.       …or use the following CRS (EPSG code): choose a CRS that will represent the default code for loading uninformed GIS data.       When no CRS is provided, save the GIS data with the current CRS: if true, saving GIS data will use the projected CRS unless a CRS is provided.       …or use the following CRS (EPSG code): otherwise, you might enter a CRS to use to save files. Advanced Preferences  The set of preferences described above are specific to GAMA. But there are other preferences or settings that are inherited from the Eclipse underpinnings of GAMA, which concern either the  core  of the platform (workspace, editors, updates, etc.) or plugins (like SVN, for instance) that are part of the distribution of GAMA.  These  advanced  preferences are accessible by clicking on the  Advanced…  button in the Preferences view.    Depending on what is installed, the second view that appears will contain a tree of options on the left and preference pages on the right. Contrary to the first set of preferences, please note that these preferences will be saved in the current workspace, which means that changing workspace will revert them to their default values. It is however possible to import them in the new workspace using of the wizards provided in the standard  Import…  command (see here).   ","url":"wiki/Preferences.md"},{"id":"wiki/RunningExperiments.md","title":" Running Experiments","content":"Running Experiments  Running an experiment is the only way, in GAMA, to execute simulations on a model. Experiments can be run in different ways.   1. The first, and most common way, consists in launching an experiment from the Modeling perspective, using the user interface proposed by the simulation perspective to run simulations.   1. The second way, detailed on this page, allows to automatically launch an experiment when opening GAMA, subsequently using the same user interface.   1. The last way, known as running headless experiments, does not make use of the user interface and allows to manipulate GAMA entirely from the command line.  All three ways are strictly equivalent in terms of computations (with the exception of the last one omitting all the computations necessary to render simulations on displays or in the UI). They simply differ by their usage:   1. The first one is heavily used when designing models or demonstrating several models.   1. The second is intended to be used when demonstrating or experimenting a single model.   1. The last one is useful when running large sets of simulations, especially over networks or grids of computers. ","url":"wiki/RunningExperiments.md"},{"id":"wiki/WorkspaceProjectsAndModels.md","title":" Workspace, Projects and Models","content":"Workspace, Projects and Models  The workspace is a directory in which GAMA stores all the current projects on which the user is working, links to other projects, as well as some meta-data like preference settings, current status of the different projects, error markers, and so on.  Except when running in headless mode, GAMA cannot function without a valid workspace.  The workspace is organized in 3 categories, which are themselves organized into projects.  The projects present in the workspace can be either directly stored within it (as sub-directories), which is usually the case when the user creates a new project, or linked from it (so the workspace will only contain a link to the directory of the project, supposed to be somewhere in the filesystem or on the network). A same project can be linked from different workspaces.  GAMA models files are stored in these projects, which may contain also other files (called resources) necessary for the models to function. A project may of course contain several model files, especially if they are importing each other, if they represent different views on the same topic, or if they share the same resources.  Learning how to navigate in the workspace, how to switch workspace or how to import, export is a necessity to use GAMA correctly. It is the purpose of the following sections.       Navigating in the Workspace   Changing Workspace   Importing Models   ","url":"wiki/WorkspaceProjectsAndModels.md"},{"id":"wiki/Extension_cenres.gaml.extensions.hydro.md","title":" Extension","content":"Extension    cenres.gaml.extensions.hydro  Table of Contents ### Operators water_area_for, water_level_for, water_polylines_for,  Statements  Skills  Architectures  Species    Operators    ### water_area_for  Possible use:    geometry water_area_for float —>  float   water_area_for (geometry , float) —>  float   Special cases:    if the left operand is a polyline and the right operand a float for the water y coordinate, returrns the area of the water (water flow area)   Examples:  waterarea <- my_river_polyline water_area_for my_height_value     ### water_level_for  Possible use:    geometry water_level_for float —>  float   water_level_for (geometry , float) —>  float   Special cases:    if the left operand is a polyline and the right operand a float for the area, returrns the y coordinate of the water (water level)   Examples:  waterlevel <- my_river_polyline water_level_for my_area_value     ### water_polylines_for  Possible use:    geometry water_polylines_for float —>  msi.gama.util.IList<msi.gama.util.IList<msi.gama.metamodel.shape.GamaPoint>>   water_polylines_for (geometry , float) —>  msi.gama.util.IList<msi.gama.util.IList<msi.gama.metamodel.shape.GamaPoint>>   Special cases:    if the left operand is a polyline and the right operand a float for the water y coordinate, returrns the shapes of the river sections (list of list of points)   Examples:  waterarea <- my_river_polyline water_area_for my_height_value     Skills    Statements    Species    Architectures  ","url":"wiki/Extension_cenres.gaml.extensions.hydro.md"},{"id":"wiki/Extension_cict.gaml.extensions.netcdf.md","title":" Extension","content":"Extension    cict.gaml.extensions.netcdf  Table of Contents ### Operators is_netcdf, netcdf_file, reduce_dimension,  Statements  Skills  Architectures  Species    Operators    ### is_netcdf  Possible use:    is_netcdf (any) —>  bool   Result: Tests whether the operand is a netcdf file.    ### netcdf_file  Possible use:    netcdf_file (string) —>  file   Result: Constructs a file of type netcdf. Allowed extensions are limited to nc    ### reduce_dimension  Possible use:    string reduce_dimension container —>  container   reduce_dimension (string , container) —>  container   Result: general operator to manipylate multidimension netcdf data.    Skills    Statements    Species    Architectures  ","url":"wiki/Extension_cict.gaml.extensions.netcdf.md"},{"id":"wiki/Extension_dream.gama.opengis.md","title":" Extension","content":"Extension    dream.gama.opengis  Table of Contents ### Operators gml_from_wfs, image_from_direct_wms, image_from_wms, read_json_rest,  Statements  Skills  Architectures  Species    Operators    ### gml_from_wfs  Possible use:    gml_from_wfs (string, string, string) —>  msi.gama.util.IList<msi.gama.util.IList<java.lang.Object>>   Result: WMS: A simple call to WFS/GML2    ### image_from_direct_wms  Possible use:    string image_from_direct_wms string —>  file   image_from_direct_wms (string , string) —>  file   Result: WMS: A simple call to WMS    ### image_from_wms  Possible use:    image_from_wms (string, string, int, int, int, float, float, float, float) —>  file   Result: WMS: A simple call to WMS    ### read_json_rest  Possible use:    string read_json_rest string —>  msi.gama.util.IList<msi.gama.util.IList<java.lang.Object>>   read_json_rest (string , string) —>  msi.gama.util.IList<msi.gama.util.IList<java.lang.Object>>   Result: REST: Read data from RESTService    Skills    Statements    Species    Architectures  ","url":"wiki/Extension_dream.gama.opengis.md"},{"id":"wiki/Extension_idees.gama.mapcomparison.md","title":" Extension","content":"Extension    idees.gama.mapcomparison  Table of Contents ### Operators fuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,  Statements  Skills  Architectures  Species    Operators    ### fuzzy_kappa  Possible use:    fuzzy_kappa (list<agent>, list, list, list<float>, list, matrix<float>, float) —>  float   fuzzy_kappa (list<agent>, list, list, list<float>, list, matrix<float>, float, list) —>  float   Result: fuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling & Software, 21 fuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance, weights). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling & Software, 21  Examples:  fuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2) fuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2, [1.0,3.0,2.0,2.0,4.0])     ### fuzzy_kappa_sim  Possible use:    fuzzy_kappa_sim (list<agent>, list, list, list, list<float>, list, matrix<float>, float) —>  float   fuzzy_kappa_sim (list<agent>, list, list, list, list<float>, list, matrix<float>, float, list) —>  float   Result: fuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800,  fuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance, weights). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800,  Examples:  fuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2) fuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2,[1.0,3.0,2.0,2.0,4.0])     ### kappa  Possible use:    kappa (list, list, list) —>  float   kappa (list, list, list, list) —>  float   Result: kappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20. kappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories, weights). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20.  Examples:  kappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3]) float var1 <- kappa([1,3,5,1,5],[1,1,1,1,5],[1,3,5]);  // var1 equals the similarity between 0 and 1 float var2 <- kappa([1,1,1,1,5],[1,1,1,1,5],[1,3,5]);  // var2 equals 1.0 kappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3], [1.0, 2.0, 3.0, 1.0, 5.0])     ### kappa_sim  Possible use:    kappa_sim (list, list, list, list) —>  float   kappa_sim (list, list, list, list, list) —>  float   Result: kappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories, weights). Reference: van Vliet, J., Bregt, A.K. & Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8) kappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories). Reference: van Vliet, J., Bregt, A.K. & Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8).  Examples:  kappa([cat1,cat1,cat2,cat2,cat2],[cat2,cat1,cat2,cat1,cat3],[cat2,cat1,cat2,cat3,cat3], [cat1,cat2,cat3],[1.0, 2.0, 3.0, 1.0, 5.0]) kappa([cat1,cat1,cat2,cat2,cat2],[cat2,cat1,cat2,cat1,cat3],[cat2,cat1,cat2,cat3,cat3], [cat1,cat2,cat3])     ### percent_absolute_deviation  Possible use:    list<float> percent_absolute_deviation list<float> —>  float   percent_absolute_deviation (list<float> , list<float>) —>  float   Result: percent absolute deviation indicator for 2 series of values: percent_absolute_deviation(list_vals_observe,list_vals_sim)  Examples:  percent_absolute_deviation([200,300,150,150,200],[250,250,100,200,200])     Skills    Statements    Species    Architectures  ","url":"wiki/Extension_idees.gama.mapcomparison.md"},{"id":"wiki/Extension_idees.gama.weka.md","title":" Extension","content":"Extension    idees.gama.weka  Table of Contents ### Operators clustering_cobweb, clustering_DBScan, clustering_em, clustering_farthestFirst, clustering_simple_kmeans, clustering_xmeans,  Statements  Skills  Architectures  Species    Operators    ### clustering_cobweb  Possible use:    clustering_cobweb (list<agent>, list<string>, map<string,unknown>) —>  list<list<agent>>   Result: A list of agent groups clusteredby CobWeb Algorithm based on the given attributes. Some paremeters can be defined: acuity: minimum standard deviation for numeric attributes; cutoff: category utility threshold by which to prune nodes seed  Examples:  list<list<agent>> var0 <- clustering_cobweb([ag1, ag2, ag3, ag4, ag5],[size,age, weight],[acuity::3.0, cutoff::0.5);  // var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]   See also: clustering_xmeans, clustering_em, clustering_farthestFirst, clustering_simple_kmeans, clustering_cobweb,    ### clustering_DBScan  Possible use:    clustering_DBScan (list<agent>, list<string>, map<string,unknown>) —>  list<list<agent>>   Result: A list of agent groups clustered by DBScan Algorithm based on the given attributes. Some paremeters can be defined: distance_f: The distance function to use for instances comparison (euclidean or manhattan); min_points: minimun number of DataObjects required in an epsilon-range-queryepsilon: epsilon – radius of the epsilon-range-queries  Examples:  list<list<agent>> var0 <- clustering_DBScan([ag1, ag2, ag3, ag4, ag5],[size,age, weight],[distance_f::manhattan]);  // var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]   See also: clustering_xmeans, clustering_em, clustering_farthestFirst, clustering_simple_kmeans, clustering_cobweb,    ### clustering_em  Possible use:    clustering_em (list<agent>, list<string>, map<string,unknown>) —>  list<list<agent>>   Result: A list of agent groups clustered by EM Algorithm based on the given attributes. Some paremeters can be defined: max_iterations: the maximum number of iterations to perform;num_clusters: the number of clusters; minStdDev: minimum allowable standard deviation  Examples:  list<list<agent>> var0 <- clustering_em([ag1, ag2, ag3, ag4, ag5],[size,age, weight],[max_iterations::10, num_clusters::3]);  // var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]   See also: clustering_xmeans, clustering_simple_kmeans, clustering_farthestFirst, clustering_DBScan, clustering_cobweb,    ### clustering_farthestFirst  Possible use:    clustering_farthestFirst (list<agent>, list<string>, map<string,unknown>) —>  list<list<agent>>   Result: A list of agent groups clustered by Farthest First Algorithm based on the given attributes. Some paremeters can be defined: num_clusters: the number of clusters  Examples:  list<list<agent>> var0 <- clustering_farthestFirst([ag1, ag2, ag3, ag4, ag5],[size,age, weight],[num_clusters::3]);  // var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]   See also: clustering_xmeans, clustering_simple_kmeans, clustering_em, clustering_DBScan, clustering_cobweb,    ### clustering_simple_kmeans  Possible use:    clustering_simple_kmeans (list<agent>, list<string>, map<string,unknown>) —>  list<list<agent>>   Result: A list of agent groups clustered by K-Means Algorithm based on the given attributes. Some paremeters can be defined: distance_f: The distance function to use. 4 possible distance functions: euclidean (by default) ;  chebyshev ,  manhattan  or  levenshtein ; dont_replace_missing_values: if false, replace missing values globally with mean/mode; max_iterations: the maximum number of iterations to perform;num_clusters: the number of clusters  Examples:  list<list<agent>> var0 <- clustering_simple_kmeans([ag1, ag2, ag3, ag4, ag5],[size,age, weight],[distance_f::manhattan, num_clusters::3]);  // var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]   See also: clustering_xmeans, clustering_em, clustering_farthestFirst, clustering_DBScan, clustering_cobweb,    ### clustering_xmeans  Possible use:    clustering_xmeans (list<agent>, list<string>, map<string,unknown>) —>  list<list<agent>>   Result: A list of agent groups clustered by X-Means Algorithm based on the given attributes. Some paremeters can be defined: bin_value: value given for true value of boolean attributes; cut_off_factor: the cut-off factor to use;distance_f: The distance function to use. 4 possible distance functions: euclidean (by default) ;  chebyshev ,  manhattan  or  levenshtein ; max_iterations: the maximum number of iterations to perform; max_kmeans: the maximum number of iterations to perform in KMeans; max_kmeans_for_children: the maximum number of iterations KMeans that is performed on the child centers;max_num_clusters: the maximum number of clusters; min_num_clusters: the minimal number of clusters  Examples:  list<list<agent>> var0 <- clustering_xmeans([ag1, ag2, ag3, ag4, ag5],[size,age, weight, is_male],[bin_value::1.0, distance_f::manhattan, max_num_clusters::10, min_num_clusters::2]);  // var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]   See also: clustering_simple_kmeans, clustering_em, clustering_farthestFirst, clustering_DBScan, clustering_cobweb,    Skills    Statements    Species    Architectures  ","url":"wiki/Extension_idees.gama.weka.md"},{"id":"wiki/Extension_irit.maelia.gaml.additions.md","title":" Extension","content":"Extension    irit.maelia.gaml.additions  Table of Contents ### Operators  Statements  Skills  Architectures  Species    Operators    Skills    Statements    Species    Architectures  ","url":"wiki/Extension_irit.maelia.gaml.additions.md"},{"id":"wiki/Extension_miat.gama.extension.ifcfile.md","title":" Extension","content":"Extension    miat.gama.extension.ifcfile  Table of Contents ### Operators eleldkdjxuxsnel, ifc_file, is_ifc,  Statements  Skills  Architectures  Species    Operators    ### eleldkdjxuxsnel  Possible use:    rgb eleldkdjxuxsnel rgb —>  string   eleldkdjxuxsnel (rgb , rgb) —>  string     ### ifc_file  Possible use:    ifc_file (string) —>  file   Result: Constructs a file of type ifc. Allowed extensions are limited to ifc    ### is_ifc  Possible use:    is_ifc (any) —>  bool   Result: Tests whether the operand is a ifc file.    Skills    Statements    Species    Architectures  ","url":"wiki/Extension_miat.gama.extension.ifcfile.md"},{"id":"wiki/Extension_msi.gaml.extensions.cplex.md","title":" Extension","content":"Extension    msi.gaml.extensions.cplex  Table of Contents ### Operators  Statements  Skills  Architectures  Species    Operators    Skills    Statements    Species    Architectures  ","url":"wiki/Extension_msi.gaml.extensions.cplex.md"},{"id":"wiki/Extension_msi.gaml.extensions.humanmoving.md","title":" Extension","content":"Extension    msi.gaml.extensions.humanmoving  Table of Contents ### Operators  Statements  Skills  Architectures  Species    Operators    Skills    Statements    Species    Architectures  ","url":"wiki/Extension_msi.gaml.extensions.humanmoving.md"},{"id":"wiki/Extension_msi.gaml.extensions.traffic2d.md","title":" Extension","content":"Extension    msi.gaml.extensions.traffic2d  Table of Contents ### Operators  Statements  Skills  Architectures  Species    Operators    Skills    Statements    Species    Architectures  ","url":"wiki/Extension_msi.gaml.extensions.traffic2d.md"},{"id":"wiki/Extension_simtools.graphanalysis.fr.md","title":" Extension","content":"Extension    simtools.graphanalysis.fr  Table of Contents ### Operators  Statements layout_forceatlas2, layout_yifanhu,  Skills  Architectures  Species    Operators    Skills    Statements    ### layout_forceatlas2  #### Facets     graph (graph), (omissible) : the graph to apply the layout.   approximate_repulsion (boolean): Barnes Hut optimization: n2 complexity to n.ln(n); allows larger graphs. default: false   approximation (float): Theta of the Barnes Hut optimization. default: 1.2   bounded_point1 (point): The new nodes positions are bounded within the two bound points if both are not null. default: null   bounded_point2 (point): The new nodes positions are bounded within the two bound points if both are not null. default: null   dissuade_hubs (boolean): Distributes attraction along outbound edges. Hubs attract less and thus are pushed to the borders (default: false).   edge_weight_influence (float): How much influence you give to the edges wight. 0 is no influence, 1 is normal. default: 1.0   gravity (float): Attracts nodes to the center. Prevents islands from drifting away. default: 1.0   linlog_mode (boolean): Switch model from lin-lin to lin-log. Makes clusters more tight (default: false).   nb_steps (int): The number of steps of the algorithm to perform (default 1).   prevent_overlap (boolean): Should not be used with approximate_repulsion default: false   scaling (float): How much repulsion you want. More makes a more sparse graph. default: 2.0   stronger_gravity (boolean): A stronger gravity law default: false   thread_number (int): More threads means more speed (default: 1).   tolerance (float): How much swinging you allow. Above 1 discouraged. Lower gives less speed and more precision. default: 0.1   Embedments    The layout_forceatlas2 statement is of type: Single statement   The layout_forceatlas2 statement can be embedded into: Behavior, Sequence of statements or action,   The layout_forceatlas2 statement embeds statements:     ### layout_yifanhu  #### Facets     graph (graph), (omissible) : the graph to apply the layout.   bounded_point1 (point): The new nodes positions are bounded within the two bound points if both are not null. default: null   bounded_point2 (point): The new nodes positions are bounded within the two bound points if both are not null. default: null   nb_steps (int): The number of steps of the algorithm to perform (default 1).   optimal_distance (float): the natural length of the springs. Bigger values mean nodes will be farther apart (default: 100).   quadtree_max_level (int): The maximum level to be used in the quadtree representation. Greater values mean more accuracy (default: 10).   relative_strength (float): The relative strength between electrical force (repulsion) and spring force (attriaction). default: 0.2   step_size (float): The step size used in the algorithm. It has to be a meaningful size compared to the optimal distance (e.g. 10%). default: 10   theta (float): The theta parameter for Barnes-Hut opening criteria. Smaller values mean more accuracy (default: 1.2).   Embedments    The layout_yifanhu statement is of type: Single statement   The layout_yifanhu statement can be embedded into: Behavior, Sequence of statements or action,   The layout_yifanhu statement embeds statements:     Species    Architectures  ","url":"wiki/Extension_simtools.graphanalysis.fr.md"},{"id":"wiki/Extension_ummisco.gama.communicator.md","title":" Extension","content":"Extension    ummisco.gama.communicator  Table of Contents ### Operators  Statements  Skills  Architectures  Species    Operators    Skills    Statements    Species    Architectures  ","url":"wiki/Extension_ummisco.gama.communicator.md"},{"id":"wiki/Extension_ummisco.gama.gpu.md","title":" Extension","content":"Extension    ummisco.gama.gpu  Table of Contents ### Operators CPU_path_between, GPU_path_between,  Statements  Skills  Architectures  Species    Operators    ### CPU_path_between  Possible use:    CPU_path_between (graph, geometry, geometry) —>  path   Result: The shortest path between a list of two objects in a graph computed with CPU  Examples:  path var0 <- my_graph CPU_path_between (ag1:: ag2);  // var0 equals A path between ag1 and ag2     ### GPU_path_between  Possible use:    GPU_path_between (graph, geometry, geometry) —>  path   Result: The shortest path between a list of two objects in a graph computed with GPU  Examples:  path var0 <- my_graph GPU_path_between (ag1:: ag2);  // var0 equals A path between ag1 and ag2     Skills    Statements    Species    Architectures  ","url":"wiki/Extension_ummisco.gama.gpu.md"},{"id":"wiki/Extension_ummisco.gaml.extensions.rjava.md","title":" Extension","content":"Extension    ummisco.gaml.extensions.rjava  Table of Contents ### Operators  Statements  Skills  Architectures  Species    Operators    Skills    Statements    Species    Architectures  ","url":"wiki/Extension_ummisco.gaml.extensions.rjava.md"},{"id":"wiki/Extension_ummisco.gaml.extensions.sound.md","title":" Extension","content":"Extension    ummisco.gaml.extensions.sound  Table of Contents ### Operators  Statements pause_sound, resume_sound, start_sound, stop_sound,  Skills  Architectures  Species    Operators    Skills    Statements    ### pause_sound  #### Facets  Embedments    The pause_sound statement is of type: Sequence of statements or action   The pause_sound statement can be embedded into: Behavior, Sequence of statements or action,   The pause_sound statement embeds statements:     ### resume_sound  #### Facets  Embedments    The resume_sound statement is of type: Sequence of statements or action   The resume_sound statement can be embedded into: Behavior, Sequence of statements or action,   The resume_sound statement embeds statements:     ### start_sound  #### Facets     source (string): The path to music file. This path is relative to the path of the model.   mode (an identifier), takes values in: {overwrite, ignore}: Mode of   repeat (boolean):   Embedments    The start_sound statement is of type: Sequence of statements or action   The start_sound statement can be embedded into: Behavior, Sequence of statements or action,   The start_sound statement embeds statements:     ### stop_sound  #### Facets  Embedments    The stop_sound statement is of type: Sequence of statements or action   The stop_sound statement can be embedded into: Behavior, Sequence of statements or action,   The stop_sound statement embeds statements:     Species    Architectures  ","url":"wiki/Extension_ummisco.gaml.extensions.sound.md"},{"id":"wiki/Extension_ummisco.gaml.extensions.stats.md","title":" Extension","content":"Extension    ummisco.gaml.extensions.stats  Table of Contents ### Operators auto_correlation, beta, binomial_coeff, binomial_complemented, binomial_sum, chi_square, chi_square_complemented, correlation, covariance, dnorm, durbin_watson, gamma, gamma_distribution, gamma_distribution_complemented, incomplete_beta, incomplete_gamma, incomplete_gamma_complement, kurtosis, lgamma, log_gamma, moment, normal_area, normal_density, normal_inverse, pbinom, pchisq, percentile, pgamma, pnorm, pValue_for_fStat, pValue_for_tStat, quantile, quantile_inverse, rank_interpolated, rms, skew, student_area, student_t_inverse, variance,  Statements  Skills  Architectures  Species    Operators    ### auto_correlation  Possible use:    container auto_correlation int —>  float   auto_correlation (container , int) —>  float   Result: Returns the auto-correlation of a data sequence    ### beta  Possible use:    float beta float —>  float   beta (float , float) —>  float   Result: Returns the beta function with arguments a, b.    ### binomial_coeff  Possible use:    int binomial_coeff int —>  float   binomial_coeff (int , int) —>  float   Result: Returns n choose k as a double. Note the integerization of the double return value.    ### binomial_complemented  Possible use:    binomial_complemented (int, int, float) —>  float   Result: Returns the sum of the terms k+1 through n of the Binomial probability density, where n is the number of trials and P is the probability of success in the range 0 to 1.    ### binomial_sum  Possible use:    binomial_sum (int, int, float) —>  float   Result: Returns the sum of the terms 0 through k of the Binomial probability density, where n is the number of trials and p is the probability of success in the range 0 to 1.    ### chi_square  Possible use:    float chi_square float —>  float   chi_square (float , float) —>  float   Result: Returns the area under the left hand tail (from 0 to x) of the Chi square probability density function with df degrees of freedom.    ### chi_square_complemented  Possible use:    float chi_square_complemented float —>  float   chi_square_complemented (float , float) —>  float   Result: Returns the area under the right hand tail (from x to infinity) of the Chi square probability density function with df degrees of freedom.    ### correlation  Possible use:    container correlation container —>  float   correlation (container , container) —>  float   Result: Returns the correlation of two data sequences    ### covariance  Possible use:    container covariance container —>  float   covariance (container , container) —>  float   Result: Returns the covariance of two data sequences    ### dnorm Same signification as normal_density    ### durbin_watson  Possible use:    durbin_watson (container) —>  float   Result: Durbin-Watson computation    ### gamma  Possible use:    gamma (float) —>  float   Result: Returns the value of the Gamma function at x.    ### gamma_distribution  Possible use:    gamma_distribution (float, float, float) —>  float   Result: Returns the integral from zero to x of the gamma probability density function.  Comment: incomplete_gamma(a,x) is equal to pgamma(a,1,x).    ### gamma_distribution_complemented  Possible use:    gamma_distribution_complemented (float, float, float) —>  float   Result: Returns the integral from x to infinity of the gamma probability density function.    ### incomplete_beta  Possible use:    incomplete_beta (float, float, float) —>  float   Result: Returns the regularized integral of the beta function with arguments a and b, from zero to x.    ### incomplete_gamma  Possible use:    float incomplete_gamma float —>  float   incomplete_gamma (float , float) —>  float   Result: Returns the regularized integral of the Gamma function with argument a to the integration end point x.    ### incomplete_gamma_complement  Possible use:    float incomplete_gamma_complement float —>  float   incomplete_gamma_complement (float , float) —>  float   Result: Returns the complemented regularized incomplete Gamma function of the argument a and integration start point x.    ### kurtosis  Possible use:    kurtosis (container) —>  float   float kurtosis float —>  float   kurtosis (float , float) —>  float   Result: Returns the kurtosis (aka excess) of a data sequence Returns the kurtosis (aka excess) of a data sequence    ### lgamma Same signification as log_gamma    ### log_gamma  Possible use:    log_gamma (float) —>  float   Result: Returns the log of the value of the Gamma function at x.    ### moment  Possible use:    moment (container, int, float) —>  float   Result: Returns the moment of k-th order with constant c of a data sequence    ### normal_area  Possible use:    normal_area (float, float, float) —>  float   Result: Returns the area to the left of x in the normal distribution with the given mean and standard deviation.    ### normal_density  Possible use:    normal_density (float, float, float) —>  float   Result: Returns the probability of x in the normal distribution with the given mean and standard deviation.    ### normal_inverse  Possible use:    normal_inverse (float, float, float) —>  float   Result: Returns the x in the normal distribution with the given mean and standard deviation, to the left of which lies the given area. normal.Inverse returns the value in terms of standard deviations from the mean, so we need to adjust it for the given mean and standard deviation.    ### pbinom Same signification as binomial_sum    ### pchisq Same signification as chi_square    ### percentile Same signification as quantile_inverse    ### pgamma Same signification as gamma_distribution    ### pnorm Same signification as normal_area    ### pValue_for_fStat  Possible use:    pValue_for_fStat (float, int, int) —>  float   Result: Returns the P value of F statistic fstat with numerator degrees of freedom dfn and denominator degress of freedom dfd. Uses the incomplete Beta function.    ### pValue_for_tStat  Possible use:    float pValue_for_tStat int —>  float   pValue_for_tStat (float , int) —>  float   Result: Returns the P value of the T statistic tstat with df degrees of freedom. This is a two-tailed test so we just double the right tail which is given by studentT of -|tstat|.    ### quantile  Possible use:    container quantile float —>  float   quantile (container , float) —>  float   Result: Returns the phi-quantile; that is, an element elem for which holds that phi percent of data elements are less than elem. The quantile need not necessarily be contained in the data sequence, it can be a linear interpolation.    ### quantile_inverse  Possible use:    container quantile_inverse float —>  float   quantile_inverse (container , float) —>  float   Result: Returns how many percent of the elements contained in the receiver are <= element. Does linear interpolation if the element is not contained but lies in between two contained elements.    ### rank_interpolated  Possible use:    container rank_interpolated float —>  float   rank_interpolated (container , float) —>  float   Result: Returns the linearly interpolated number of elements in a list less or equal to a given element. The rank is the number of elements <= element. Ranks are of the form {0, 1, 2,…, sortedList.size()}. If no element is <= element, then the rank is zero. If the element lies in between two contained elements, then linear interpolation is used and a non integer value is returned.    ### rms  Possible use:    int rms float —>  float   rms (int , float) —>  float   Result: Returns the RMS (Root-Mean-Square) of a data sequence. The RMS of data sequence is the square-root of the mean of the squares of the elements in the data sequence. It is a measure of the average size of the elements of a data sequence.    ### skew  Possible use:    skew (container) —>  float   float skew float —>  float   skew (float , float) —>  float   Result: Returns the skew of a data sequence. Returns the skew of a data sequence, which is moment(data,3,mean) / standardDeviation3    ### student_area  Possible use:    float student_area int —>  float   student_area (float , int) —>  float   Result: Returns the area to the left of x in the Student T distribution with the given degrees of freedom.    ### student_t_inverse  Possible use:    float student_t_inverse int —>  float   student_t_inverse (float , int) —>  float   Result: Returns the value, t, for which the area under the Student-t probability density function (integrated from minus infinity to t) is equal to x.    ### variance  Possible use:    variance (float) —>  float   variance (int, float, float) —>  float   Result: Returns the variance from a standard deviation. Returns the variance of a data sequence. That is (sumOfSquares - mean*sum) / size with mean = sum/size.    Skills    Statements    Species    Architectures  ","url":"wiki/Extension_ummisco.gaml.extensions.stats.md"},{"id":"wiki/Extension_ummisco.miro.extension.md","title":" Extension","content":"Extension    ummisco.miro.extension  Table of Contents ### Operators  Statements  Skills  Architectures  Species    Operators    Skills    Statements    Species    Architectures  ","url":"wiki/Extension_ummisco.miro.extension.md"},{"id":"wiki/Extension_ummisco.miro.extension.traffic.md","title":" Extension","content":"Extension    ummisco.miro.extension.traffic  Table of Contents ### Operators  Statements  Skills  Architectures  Species    Operators    Skills    Statements    Species    Architectures  ","url":"wiki/Extension_ummisco.miro.extension.traffic.md"},{"id":"wiki/Extension.md","title":" Extensions","content":"Extensions  This file is automatically generated from java files. Do Not Edit It.    Introduction This page provides a link to each of the extension pages. Extensions are the additional GAMA plugins that exist in the GAMA GitHub repository but will not be packaged with the release. These extensions are not maintained by GAMA core team but by their authors. * idees.gama.weka * ummisco.gaml.extensions.stats * miat.gama.extension.ifcfile * ummisco.gaml.extensions.sound * simtools.graphanalysis.fr * ummisco.gaml.extensions.rjava ","url":"wiki/Extension.md"},{"id":"wiki/GamlReferences.md","title":" Gaml Reference","content":"Gaml Reference  The following pages introduce the various constructs that are made available to the modelers in GAML. All these constructs are built-in, i.e. defined in Java, either in the core of GAMA or in its extensions. They include species, skills, control architectures, statements, data types, and various types of expressions, including a long and quite exhaustive list of operators.  This set of pages is to be used as a reference, which means its role is not to explain how to properly use these constructs but to detail their structures and components.  If you are not familiar yet with GAML language, please read carefully the section Learn GAML Step by Step before. ","url":"wiki/GamlReferences.md"},{"id":"wiki/ModelLibrary.md","title":" Models Library","content":"Models Library  Here is the list of models accessible when you download GAMA. Do not hesitate to consult those models to have an idea of the possibilities of the platform.  Models are divided within 5 categories :     Features : very short models designed to present the differents features of the platform.   Syntax : some gaml files in order to show you the syntax to use for basic things (casting, containers manipulation…).   Toy Models : some pre-made models designed to answer to concrete problematics.   Tutorials : models build in the tutorial section.   Additionnal Plugins : models using particular additionnal plugins.  ","url":"wiki/ModelLibrary.md"},{"id":"wiki/PlatformDocumentation.md","title":" Platform","content":"Platform  GAMA consists of a single application that is based on the RCP architecture provided by Eclipse. Within this single application software, often referred to as a platform, users can undertake, without the need of additional third-parties softwares, most of the activities related to modeling and simulation, namely editing models and simulating, visualizing and exploring them using dedicated tools.  First-time users may however be intimidated by the apparent complexity of the platform, so this part of the documentation has been designed to ease their first contact with it, by clearly identifying tasks of interest to modelers and how they can be accomplished within GAMA.  It is accomplished by firstly providing some background about important notions found throughout the platform, especially those of workspace and projects and explaining how to organize and navigate through models. Then we take a look at the edition of models and its various tools and components (dedicated editors and related tools, of course, but also validators). Finally, we show how to run experiments on these models and what support the user interface can provide to users in this task. ","url":"wiki/PlatformDocumentation.md"},{"id":"wiki/PluginDocumentation.md","title":" Extensions","content":"Extensions  In this part, we will present you all the different plugins available for GAMA.  Introduction This page provides a link to each of the extension pages. Extensions are the additional GAMA plugins that exist in the GAMA GitHub repository but will not be packaged with the release. These extensions are not maintained by GAMA core team but by their authors. * msi.gaml.extensions.humanmoving * ummisco.gaml.extensions.stats * ummisco.gama.gpu * ummisco.gama.communicator * ummisco.gaml.extensions.rjava * ummisco.gaml.extensions.sound * ummisco.miro.extension.traffic * cenres.gaml.extensions.hydro * irit.maelia.gaml.additions * ummisco.miro.extension * dream.gama.opengis * msi.gaml.extensions.cplex * idees.gama.weka * msi.gaml.extensions.traffic2d * simtools.graphanalysis.fr ","url":"wiki/PluginDocumentation.md"},{"id":"wiki/GraphSpecies.md","title":" Graph Species","content":"# Graph Species //: # (keyword|type_graph) //: # (keyword|concept_topology)  Using a graph species enables to easily show interaction between agents of a same species. This kind of species is particularly useful when trying to show the interaction (especially the non-spatial one) that exist between agents.  Index     Declaration  Declare a graph with handmade agents       Declare a graph by using an geometry file       Declare a graph with nodes and edges Useful operators with graph  Knowing the degree of a node       Get the neighbors of a node       Compute the shortest path       Control the weight in graph Example   Declaration  Declare a graph with handmade agents  To instantiate this graph species, several steps must be followed. First the graph species must inherit from the abstract species graph_node, then the method related_to must be redefined and finally an auxiliary species that inherits from base_edge used to represent the edges of the generated graph must be declared. A graph node is an abstract species that must redefine one method called related_to.      species graph_agent parent: graph_node edge_species: edge_agent{   bool related_to(graph_agent other){    return true;   } }  species edge_agent parent: base_edge { }      The method related_to returns a boolean, and take the agents from the current species in argument. If the method returns true, the two agents (the current instance and the one as argument) will be linked.      global{  int number_of_agents <- 5;  init {   create graph_agent number:number_of_agents;  } }  species graph_agent parent: graph_node edge_species: edge_agent{   bool related_to(graph_agent other){    return true;   }   aspect base {    draw circle(1) color:#green;   } }  species edge_agent parent: base_edge {  aspect base {    draw shape color:#blue;   } }  experiment MyExperiment type: gui {     output {  display MyDisplay type: java2D {   species graph_agent aspect:base;   species edge_agent aspect:base;  }     } }        You can for example link 2 agents when they are closer than a certain distance. Beware: The topology used in graph species is the graph topology, and not the continuous topology. You can force the use of the continuous topology with the action using as follow:   bool related_to(graph_agent other){    using topology:topology(world) {     return (self.location distance_to other.location < 20);    } }     The abstract mother species  graph_node  has an attribute  my_graph , with the type  graph . The graph type represent a graph composed of vertices linked with edges. This type has built-in attributes such as edges (the list of all the edges agents), or vertices (the list of all the vertices agents).  Declare a graph by using an geometry file  In most cases, you will have to construct a graph from an existing file (example: a  shp  file). In that case, you will have to first instantiate a species from the shape file (with the create statement, using the facet from). When, you will have to extract a graph from the agent, using the operator as_edge_graph.      model load_shape_file  global {  file roads_shapefile <- file( ../includes/road.shp );  geometry shape <- envelope(roads_shapefile);  graph road_network;  init {  create road from: roads_shapefile;  road_network <- as_edge_graph(road); } }   species road {  aspect geom {   draw shape color: #black;  } }  experiment main_experiment type:gui{  output {   display map {    species road aspect:geom;     }  } }      Declare a graph with nodes and edges  Another way to create a graph is building it manually nodes by nodes, and then edges by edges, without using agent structures. Use the add_node operator and the add_edge operator to do so. Here is an example of how to do:      add point(0.0,0.0) to:nodes; add point(90.0,90.0) to:nodes; add point(20.0,20.0) to:nodes; add point(40.0,50.0) to:nodes; add point(100.0,0.0) to:nodes;  loop nod over:nodes {  my_graph <- my_graph add_node(nod); }  my_graph <- my_graph add_edge (nodes at 0::nodes at 2); my_graph <- my_graph add_edge (nodes at 2::nodes at 3); my_graph <- my_graph add_edge (nodes at 3::nodes at 1); my_graph <- my_graph add_edge (nodes at 0::nodes at 4); my_graph <- my_graph add_edge (nodes at 4::nodes at 1);      Using this solution, my_graph can have two types: it can be an a-spatial graph, or a spatial graph. The spatial graph will have a proper geometry, with segments that follow the position of your graph (you can access to the segments by using the built-in  segments ). The a-spatial graph will not have any shape.      global {  graph my_spatial_graph<-spatial_graph([]);  graph my_aspatial_graph<-graph([]);  init {  point node1 <- {0.0,0.0};  point node2 <- {10.0,10.0};  my_spatial_graph <- my_spatial_graph add_node(node1);  my_spatial_graph <- my_spatial_graph add_node(node2);  my_spatial_graph <- my_spatial_graph add_edge(node1::node2);  write my_spatial_graph.edges;  // the output is [polyline ([{0.0,0.0,0.0},{10.0,10.0,0.0}])]  my_aspatial_graph <- my_aspatial_graph add_node(node1);  my_aspatial_graph <- my_aspatial_graph add_node(node2);  my_aspatial_graph <- my_aspatial_graph add_edge(node1::node2);  write my_aspatial_graph.edges;  // the output is [{0.0,0.0,0.0}::{10.0,10.0,0.0}] } }       Useful operators with graph  Knowing the degree of a node  The operator degree_of returns the number of edge attached to a node. To use it, you have to specify a graph (on the left side of the operator), and a node (on the right side of the operator).  The following code (to put inside the node species) displays the number of edges attached to each node:   aspect base {  draw text:string(my_graph degree_of node(5)) color:# black;  status <- 0; }   Get the neighbors of a node  To get the list of neighbors of a node, you should use the neighbors_of operator. On the left side of the operator, specify the graph you are using, and on the right side, specify the node. The operator returns the list of nodes located at a distance inferior or equal to 1, considering the graph topology.   species graph_agent parent: graph_node edge_species: edge_agent {   list<graph_agent> list_neighbors <- list<graph_agent>(my_graph neighbors_of (self)); }   Here is an example of model using those two previous concepts (a random node is chosen each step, displayed in red, and his neighbors are displayed in yellow):        model graph_model  global {  int number_of_agents <- 50;  init  {   create graph_agent number: number_of_agents;  }  reflex update {  ask graph_agent(one_of(graph_agent)) {   status <- 2;   do update_neighbors;  } } }   species graph_agent parent: graph_node edge_species: edge_agent {  int status <- 0;  list list_connected_index;  init {  int i<-0;  loop over:graph_agent {   if (flip(0.1)) {    add i to:list_connected_index;   }   i <- i+1;  } }  bool related_to(graph_agent other){    if (list_connected_index contains (graph_agent index_of other)) {     return true;    }    return false; }  action update_neighbors {   list<graph_agent> list_neighbors <- list<graph_agent>(my_graph neighbors_of (self));   loop neighb over:list_neighbors {   neighb.status <- 1;  } }  aspect base {  if (status = 0) {   draw circle(2) color: # green;  }  else if (status = 1) {   draw circle(2) color: # yellow;  }  else if (status = 2) {   draw circle(2) color: # red;  }  draw text:string(my_graph degree_of self) color:# black size:4 at:point(self.location.x-1,self.location.y-2);  status <- 0; } }   species edge_agent parent: base_edge {  aspect base  {   draw shape color: # blue;  } }  experiment MyExperiment type: gui {  output  {   display MyDisplay type: java2D   {    species graph_agent aspect: base;    species edge_agent aspect: base;   }  } }      Compute the shortest path  To compute the shortest path to go from a point to another, pick a source and a destination among the vertices you have for your graph. Store those values as point type.   point source; point destination; source <- point(one_of(my_graph.vertices)); destination <- point(one_of(my_graph.vertices));   Then, you can use the operator path_between to return the shortest path. To use this action, you have to give the graph, then the source point, and the destination point. This action returns a path type.   path shortest_path; shortest_path <- path_between (my_graph, source,destination);   Another operator exists, paths_between, that returns a list of shortest paths between two points. Please read the documentation to learn more about this operator.  Here is an example of code that show the shortest path between two points of a graph:        model graph_model  global {  int number_of_agents <- 50;  point source;  point target;  graph my_graph;  path shortest_path;  init {  create graph_agent number: number_of_agents; }  reflex pick_two_points {  if (my_graph=nil) {   ask graph_agent {    myself.my_graph <- self.my_graph;    break;   }  }  shortest_path <- nil;  loop while:shortest_path=nil {   source <- point(one_of(my_graph.vertices));   target <- point(one_of(my_graph.vertices));   if (source != target) {    shortest_path <- path_between (my_graph, source,target);   }  } } }   species graph_agent parent: graph_node edge_species: edge_agent {  list list_connected_index;  init {  int i<-0;  loop over:graph_agent {   if (flip(0.1)) {    add i to:list_connected_index;   }   i <- i+1;  } }  bool related_to(graph_agent other) {    using topology:topology(world) {      return (self.location distance_to other.location < 20);     } }  aspect base {  draw circle(2) color: # green; } }   species edge_agent parent: base_edge {  aspect base {   draw shape color: # blue;  } }  experiment MyExperiment type: gui {  output {   display MyDisplay type: java2D {    species graph_agent aspect: base;    species edge_agent aspect: base;    graphics  shortest path  {     if (shortest_path != nil) {      draw circle(3) at: source color: #yellow;      draw circle(3) at: target color: #cyan;      draw (shortest_path.shape+1) color: #magenta;     }    }   }  } }      Control the weight in graph  You can add a map of weight for the edges that compose the graph. Use the operator with_weights to put weights in your graph. The graph has to be on the left side of the operator, and the map has to be on the right side. In the map, you have to put edges as key, and the weight for that edge as value. One common use is to put the distance as weight:   my_graph <- my_graph with_weights (my_graph.edges as_map (each::geometry(each).perimeter));   The calculation of shortest path can change according to the weight you choose for your edges. For example, here is the result of the calculation of the shortest path when all the edges have 1 as weight value (it is the default graph topology), and when the edges have their length as weight.    Here is an example of implementation:      model shortest_path_with_weight  global {  graph my_graph<-spatial_graph([]);  path shortest_path;  list nodes;  init {  add point(10.0,10.0) to:nodes;  add point(90.0,90.0) to:nodes;  add point(40.0,20.0) to:nodes;  add point(80.0,50.0) to:nodes;  add point(90.0,20.0) to:nodes;   loop nod over:nodes {   my_graph <- my_graph add_node(nod);  }    my_graph <- my_graph add_edge (nodes at 0::nodes at 2);  my_graph <- my_graph add_edge (nodes at 2::nodes at 3);  my_graph <- my_graph add_edge (nodes at 3::nodes at 1);  my_graph <- my_graph add_edge (nodes at 0::nodes at 4);  my_graph <- my_graph add_edge (nodes at 4::nodes at 1);    // comment/decomment the following line to see the difference.  my_graph <- my_graph with_weights (my_graph.edges as_map (each::geometry(each).perimeter));    shortest_path <- path_between(my_graph,nodes at 0, nodes at 1); } }   experiment MyExperiment type: gui {  output {   display MyDisplay type: java2D {    graphics  shortest path  {     if (shortest_path != nil) {      draw circle(3) at: point(shortest_path.source) color: #yellow;      draw circle(3) at: point(shortest_path.target) color: #cyan;      draw (shortest_path.shape+1) color: #magenta;     }     loop edges over: my_graph.edges {      draw edges color: #black;     }    }   }  } }     //: # (endConcept|graph) ","url":"wiki/GraphSpecies.md"},{"id":"wiki/GridSpecies.md","title":" Grid Species","content":"# Grid Species //: # (keyword|concept_topology)  A grid is a particular species of agents. Indeed, a grid is a set of agents that share a grid topology (until now, we only saw species with continuous topology). As other agents, a grid species can have attributes, attributes, behaviors, aspects However, contrary to regular species, grid agents are created automatically at the beginning of the simulation. It is thus not necessary to use the create statement to create them. Moreover, in addition to classic built-in variables, grid a provided with a set of additional built-in variables.  Index     Declaration   Built-in attributes   Access to cells   Display grid   Grid with matrix   Example   Declaration  Instead of using the species keyword, use the keyword grid to declare a grid species. The grid species has exactly the same facets of the regular species, plus some others. To declare a grid, you have to specify the number of columns and rows first. You can do it two different ways:  Using the two facets width: and height: to fix the number of cells (the size of each cells will be determined thanks to the environment dimension).   grid my_grid width:8 height:10 { // my_grid has 8 columns and 10 rows }   Using the two facets cell_width: and cell_height: to fix the size of each cells (the number cells will be determined thanks to the environment dimension).   grid my_grid cell_width:3 cell_height:2 { // my_grid has cells with dimension 3m width by 2m height }   By default, a grid is composed by 100 rows and 100 columns.  Another facet exists for grid only, very useful. It is the neighbors facet, used to determine how many neighbors has each cell. You can choose among 3 values: 4 (Von Neumann), 6 (hexagon) or 8 (Moore).    A grid can also be provided with specific facets that allows to optimize the computation time and the memory space, such as use_regular_agents, use_indivitual_shapes and use_neighbours_cache. Please refer to the GAML Reference for more explanation about those particular facets.  Built-in attributes  grid_x This variable stores the column index of a cell.     grid cell width: 10 height: 10 neighbors: 4 {  init {    write my column index is: + grid_x;  }    }   grid_y This variable stores the row index of a cell.     grid cell width: 10 height: 10 neighbors: 4 {  init {    write my row index is: + grid_y;  }    }  ### agents  return the set of agents located inside the cell. Note the use of this variable is deprecated. It is preferable to use the inside operator: //: # (keyword|operator_inside)    grid cell width: 10 height: 10 neighbors: 4 {   list<bug> bugs_inside -> {bug inside self};    }   ### color The color built-in variable is used by the optimized grid display. Indeed, it is possible to use for grid agents an optimized aspect by using in a display the grid keyword. In this case, the grid will be displayed using the color defined by the color variable. The border of the cells can be displayed with a specific color by using the lines facet.  Here an example of the display of a grid species named cell with black border.   experiment main_xp type: gui{  output {   display map {    grid cell lines: rgb(black) ;   }  } }   ### neighbors The neighbors built-in variable returns the list of cells at a distance of 1.   grid my_grid {   reflex writeNeighbors {     write neighbors;   } }   grid_value The grid_value built-in variable is used when initializing a grid from grid file (see later). It is also used for the 3D representation of DEM.  Access to a cell  there are several ways to access to a specific cell:     by a location: by casting a location to a cell (the unity (#m, #cm, etc…) is defined when you choose your environment size, in the global species.          global {   init {    write  cell at {57.5, 45} :  + cell({57.5, 45});   }    }  grid cell width: 10 height: 10 neighbors: 4 {    }         by the row and column indexes: like matrix, it is possible to directly access to a cell from its indexes       global {   init {    write cell [5,8] : + cell[5,8];   }    }    grid cell width: 10 height: 10 neighbors: 4 {    }   The operator grid_at also exists to get a particular cell. You just have to specify the index of the cell you want (in x and y):      global {   init {    agent cellAgent <- cell grid_at {5,8};    write cell [5,8] : + cellAgent;   }    }    grid cell width: 10 height: 10 neighbors: 4 {    }   Display Grid  You can easily display your grid in your experiment as followed :   experiment MyExperiment type: gui {     output {  display MyDisplay type: opengl {   grid MyGrid;  }     } }   The grid will be displayed, using the color you defined for each cell (with the  color  built-in attribute). You can also show border of each cell by using the facet  line:  and choosing a rgb color:   grid MyGrid line:#black;   An other way to display a grid will be to define an aspect in your grid agent (the same way as for a regular species), and define your grid as a regular species then in your experiment, choosing your aspect :      grid MyGrid {     aspect firstAspect {  draw square(1);     }     aspect secondAspect {  draw circle(1);     } }  experiment MyExperiment type: gui {     output {  display MyDisplay type: opengl {   species MyGrid aspect:firstAspect;  }     } }      Beware : don t use this second display when you have large grids : it s much slower.  ## Grid from a matrix  An easy way to load some values in a grid is to use matrix data. A matrix is a type of container (we invite you to learn some more about this useful type here). Once you have declared your matrix, you can set the values of your cells using the ask statement :   global {   init {     matrix data <- matrix([[0,1,1],[1,2,0]]);     ask cell {       grid_value <- float(data[grid_x, grid_y]);     }    } }   Declaring larger matrix in GAML can be boring as you can imagine. You can load your matrix directly from a csv file with the operator matrix (used for the contruction of the matrix).   file my_file <- csv_file(path/file.csv,separator); matrix my_matrix <- matrix(my_file);   You can try to read the following csv :  0,0,0,0,0,0,0,0,0,0,0 0,0,0,1,1,1,1,1,0,0,0 0,0,1,1,0,0,0,1,1,0,0 0,1,1,0,0,0,0,0,0,0,0 0,1,1,0,0,1,1,1,1,0,0 0,0,1,1,0,0,1,1,1,0,0 0,0,0,1,1,1,1,0,1,0,0 0,0,0,0,0,0,0,0,0,0,0   With the following model :      model import_csv  global {   file my_csv_file <- csv_file( ../includes/test.csv , , );   init {     matrix data <- matrix(my_csv_file);     ask my_gama_grid {       grid_value <- float(data[grid_x,grid_y]);       write data[grid_x,grid_y];     }   } }  grid my_gama_grid width: 11 height: 8 {   reflex update_color {     write grid_value;     color <- (grid_value = 1) ? #blue : #white;   } }  experiment main type: gui{   output {     display display_grid {       grid my_gama_grid;     }   } }      For more complicated models, you can read some other files, such as ASCII files (asc), DEM files…       //: # (endConcept       grid) Example  To practice a bit those notions, we will build a quick model. A  regular  species will move randomly on the environment. A grid is displayed, and its cells becomes red when an instance of the regular species is waking inside this cell, and yellow when the regular agent is in the surrounding of this cell. If no regular agent is on the surrounding, the cell turns green.    Here is an example of implementation:      model my_grid_model  global{  float max_range <- 5.0;  int number_of_agents <- 5;  init {   create my_species number:number_of_agents;  }  reflex update {   ask my_species {    do wander amplitude:180;     ask my_grid at_distance(max_range)    {     if(self overlaps myself)     {      self.color_value <- 2;     }     else if (self.color_value != 2)     {      self.color_value <- 1;     }    }   }   ask my_grid {    do update_color;   }   } }  species my_species skills:[moving] {  float speed <- 2.0;  aspect default {   draw circle(1) color:#blue;  } }  grid my_grid width:30 height:30 {  int color_value <- 0;  action update_color {   if (color_value = 0) {    color <- #green;   }   else if (color_value = 1) {    color <- #yellow;   }   else if (color_value = 2) {    color <- #red;   }   color_value <- 0;  } }  experiment MyExperiment type: gui {     output {  display MyDisplay type: java2D {   grid my_grid lines:#black;   species my_species aspect:default;   }     } }     ","url":"wiki/GridSpecies.md"},{"id":"wiki/MirrorSpecies.md","title":" Mirror species","content":"# Mirror species  A mirror species is a species whose population is automatically managed with respect to another species. Whenever an agent is created or destroyed from the other species, an instance of the mirror species is created or destroyed. Each of these  mirror agents  has access to its reference agent (called its target). Mirror species can be used in different situations but the one we describe here is more oriented towards visualization purposes.  Index     Declaration   Example   Declaration  A mirror species can be defined using the mirrors keyword as following:   species B mirrors: A{ }   In this case the species B mirrors the species A.  By default the location of the species B will be random but in many cases, once want to place the mirror agent at the same location of the reference species. This can be achieve by simply adding the following lines in the mirror species :   species B mirrors: A{     point location <- target.location update: target.location; }   target is a built-in attribute of a mirror species. It refers to the instance of the species tracked.  In the same spirit any attribute of a reference species can be reach using the same syntax. For instance if the species A has an attribute called attribute1 of type int is is possible to get this attribute from the mirror species B using the following syntax:   int value <- target.attribute1;  //: # (endConcept|mirror_species)  Example  To practice a bit with the mirror notion, we will now build a simple model displaying a species A (aspect: white circle) moving randomly, and another species B (aspect: blue sphere) with the species A location on x and y, with an upper value for the z axis.    Here is an example of implementation for this model:      model Mirror  global {   init{     create A number:100;     } }  species A skills:[moving]{     reflex update{  do wander;     }     aspect base{  draw circle(1) color: #white;     } } species B mirrors: A{     point location <- target.location update: point(target.location.x,target.location.y,target.location.z+5);     aspect base {  draw sphere(2) color: #blue;     } }  experiment mirroExp type: gui {     output {  display superposedView type: opengl{  species A aspect: base; species B aspect: base transparency:0.5;  }     } }     ","url":"wiki/MirrorSpecies.md"},{"id":"wiki/MultiLevelArchitecture.md","title":" Multi-level architecture","content":"# Multi-level architecture  The multi-level architecture offers the modeler the following possibilities: the declaration of a species as a micro-species of another species, the representation of an entity as different types of agent (i.e., GAML species), the dynamic migration of agents between populations.  Index     Declaration of micro-species   Access to micro-agents / host agent   Representation of an entity as different types of agent   Dynamic migration of agents   Example   Declaration of micro-species  A species can have other species as micro-species. The micro-species of a species is declared inside the species  declaration.   species macro_species {       species micro_species_in_group {       } }   In the above example,  micro_species_in_group  is a micro-species of  macro_species . An agent of  macro_species  can have agents  micro_species_in_group  as micro-agents. Agents of  micro_species_in_group  have an agent of  macro_species  as  host  agent.  As the species  micro_species_in_group  is declared inside the species  macro_species ,  micro_species_in_group  will return a list of  micro_species_in_group  agent inside the given  macro_species  agent.      global {  init {   create macro_species number:5;  } }  species macro_species  {   init {   create micro_species_in_group number:rnd(10);   write  the macro species named  +name+  contains  +length(micro_species_in_group)+  micro-species. ;  }  species micro_species_in_group { } }   experiment my_experiment type: gui { }      In this above example, we create 5 macro-species, and each one of these macro-species create a random number of inner micro-species. We can see that  micro_species_in_group  refers to the list of micro-species inside the given macro-species.  Access to micro-agents, host agent  To access to micro-agents (from a macro-agent), and to host agent (from a micro-agents), you have to use two built-in attributes.  The members built-in attribute is used inside the macro-agent, to get the list of all its micro-agents.      species macro_species  {  init {   create first_micro_species number:3;   create second_micro_species number:6;   write  the macro species named  +name+  contains  +length(members)+  micro-species. ;  }  species first_micro_species { }  species second_micro_species { } }       The host built-in attribute is used inside the micro-agent to get the host macro-agent.      species macro_species {  micro_species_in_group micro_agent;  init {  create micro_species_in_group number:rnd(10);  write the macro species named +name+ contains +length(members)+ micro-species.; }  species micro_species_in_group {  init {   write the micro species named +name+ is hosted by +host;  } } }       NB: We already said that the world agent is a particular agent, instantiated just once. In fact, the world agent is the host of all the agents. You can try to get the host for a regular species, you will get the world agent itself (named as you named your model). You can also try to get the members of your world (from the global scope for example), and you will get the list of the agents presents in the world.      global {  init {   create macro_species number:5;   write  the world has  +length(members)+  members. ;  } }  species macro_species  {   init {   write  the macro species named  +name+  is hosted by  +host;  } }      Representation of an entity as different types of agent  The multi-level architecture is often used in order to represent an entity through different types of agent. For example, an agent  bee  can have a behavior when it is alone, but when the agent is near from a lot of agents, he can changes his type to  bee_in_swarm , defined as a micro-species of a macro-species  swarm . Other example: an agent  pedestrian  can have a certain behavior when walking on the street, and then change his type to  pedestrian_in_building  when he is in a macro-species  building . You have then to distinguish two different species to define your micro-species: - The first can be seen as a regular species (it is the  bee  or the  pedestrian  for instance). We will name this species as  micro_species . - The second is the real micro-species, defined inside the macro-species (it is the  bee_in_swarm  or the  pedestrian_in_building  for instance). We will name this species as  micro_species_in_group . This species has to inherit from the  micro_species .      species micro_species { }  species macro_species  {   species micro_species_in_group parent: micro_species {  } }      Dynamic migration of agents  In our example about bees, a  swarm  entity is composed of nearby flying  bee  entities. When a  bee  entity approaches a  swarm  entity, this  bee  entity will become a member of the group. To represent this, the modeler lets the  bee  agent change its species to  bee_in_swarm  species. The  bee  agent hence becomes a  bee_in_swarm  agent. To change species of agent, we can use one of the following statements: capture, release, migrate.  The statement capture is used by the  macro_species  to capture one (or several)  micro_species  agent(s), and turn it (them) to a  micro_species_in_group . You can specify which agent (or list of agents) you want to capture by using the facet target. The facet as is used to cast the agent from  micro_species  to  micro_species_in_group . You can use the facet return to get the newly captured agent(s).   capture target:micro_species as:micro_species_in_group;   The statement release is used by the  macro_species  to release one (or several)  micro_species_in_group  agent(s), and turn it (them) to a  micro_species . You can specify which agent (or list of agents) you want to release by using the facet target. The facet as is used to cast the agent from  micro_species_in_group  to  micro_species . The facet in is used to specify the new host (by default, it is the host of the  macro_species ). You can use the facet return to get the newly released agent(s).   release target:list(micro_species_in_group) as:micro_species in:world;   The statement migrate, less used, permits agents to migrate from one population/species to another population/species and stay in the same host after the migration. Read the GAML Reference to learn more about this statement. //: # (endConcept|multi_level)  Example:  Here is an example of micro_species that gather together in macro_species when they are close enough.        model multilevel  global {  int release_time <- 20;  int capture_time <- 100;  int remaining_release_time <- 0;  int remaining_capture_time <- capture_time;  init {   create micro_species number:200;  }  reflex reflex_timer {   if (remaining_release_time=1)   {    remaining_release_time <- 0;    remaining_capture_time <- capture_time;   }   else if (remaining_capture_time=1)   {    remaining_capture_time <- 0;    remaining_release_time <- release_time;   }   remaining_release_time <- remaining_release_time - 1;   remaining_capture_time <- remaining_capture_time - 1;  }  reflex capture_micro_species when:(remaining_capture_time>0 and flip(0.1)) {   ask macro_species {    list micro_species_in_range <- micro_species at_distance 1;    if (micro_species_in_range != []) {     do capture_micro_species(micro_species_in_range);    }   }   ask micro_species {    list micro_species_list_to_be_captured <- micro_species at_distance 1;    if(micro_species_list_to_be_captured != []) {     create macro_species {      location <- myself.location;      add item:myself to:micro_species_list_to_be_captured;      do capture_micro_species(micro_species_list_to_be_captured);     }    }   }  } }  species micro_species skills:[moving] {  geometry shape <- circle(1);  aspect base {   draw shape;  }  reflex move{   do wander;  } }  species macro_species {  geometry shape <- circle(1) update:circle(length(members));  species micro_species_in_group parent:micro_species { }  action capture_micro_species(list<micro_species> micro_list) {  loop mic_sp over:micro_list {   capture mic_sp as:micro_species_in_group;  } }  reflex release_reflex when:(remaining_release_time>0 and flip(0.1)) {  release members as:micro_species /*in:world*/;  do die; }  aspect base {  draw shape;  draw text:string(length(members)) color:#black size:4; } }   experiment MyExperiment type: gui {  output {   display MyDisplay type: java2D {    species macro_species aspect: base;    species micro_species aspect: base;   }  } }     ","url":"wiki/MultiLevelArchitecture.md"},{"id":"wiki/Defining3DDisplays.md","title":" Defining 3D Displays","content":"# Defining 3D Displays  Table of contents     OpenGL display  Position       Size Camera   Dynamic camera  Camera position       Camera direction (Look Position)       Camera orientation (Up Vector)   Default view First person view Third Person view       Lighting   ## OpenGL display     Define the attribute type of the display with type:opengl in the output of your model (or use the preferences->display windows to use it by default):  output { display DisplayName type:opengl {   species mySpecies; }    The opengl display share most of the feature that the java2D offers and that are described here.  Using 3D display offers many way to represent a simulation. A layer can be positioned and scaled in a 3D world. It is possible to superpose layer on different z value and display different information on the model at different position on the screen.  Position Layer can be drawn on different position (x,y and z)  value using the position facet  Size Layer can be drawn with different size (x,y and z) using the size facet  Here is an example of display using all the previous facet (experiment factice to add to the model Incremental Model 5). You can also dynamically change those value by showing the side bar in the display.   experiment expe_test type:gui {  output {   display city_display type: opengl{    species road aspect: geom refresh:false;    species building aspect: geom transparency:0.5 ;    species people aspect: sphere3D position:{0,0,0.1};    species road aspect: geom size:{0.3,0.3,0.3};   }  } }     ## Camera  <img src= http://img.youtube.com/vi/rMIVQlul1Ag/0.jpg  width= 425  height=344 />  Arcball Camera  FreeFly Camera  Dynamic camera  User have the possibility to set dynamically the parameter of the camera (observer). The basic camera properties are its position, the direction in which is pointing, and its orientation. Those 3 parameters can be set dynamically at each iteration of the simulation.  Camera position The facet camera_pos(x,y,z) places the camera at the given position. The default camera positon is (world.width/2,world/height/2,world.maxDim*1.5) to place the camera at the middle of the environement at an altitude that enables to see the entire environment.  Camera direction (Look Position) The facet camera_look_pos(x,y,z) points the camera toward the given position.  The default look position is (world.width/2,world/height/2,0) to look at the center of the environment.  Camera orientation (Up Vector) The camera camera_up_vector(x,y,z) sets the up vector of the camera. The up vector direction in your scene is the up direction on your display screen. The default value is (0,1,0)  Here are some examples that can be done using those 3 parameters. You can test it by running the following model:  <img src= http://img.youtube.com/vi/lQVGD8aDKZY/0.jpg  width= 425  height=344 />  Boids 3D Camera movement  Default view  display RealBoids   type:opengl{ ...   }   First person view You can set the position as a first person shooter video game using:  display FirstPerson  type:opengl  camera_pos:{boids(1).location.x,-boids(1).location.y,10}  camera_look_pos:{cos(boids(1).heading)*world.shape.width,-sin(boids(1).heading)*world.shape.height,0}  camera_up_vector:{0.0,0.0,1.0}{ ... }   Third Person view You can follow an agent during a simulation by positioning the camera above it using:   display ThirdPerson  type:opengl camera_pos:{boids(1).location.x,-boids(1).location.y,250}  camera_look_pos:{boids(1).location.x,-boids(1).location.y,boids(1).location.z}{ ... }    ## Lighting  In a 3D scene once can define light sources. The way how light sources and 3D object interact is called lighting. Lighting is an important factor to render realistic scenes.  In a real world, the color that we see depend on the interaction between color material surfaces, the light sources and the position of the viewer. There are four kinds of lighting called ambient, diffuse, specular and emissive.  Gama handle ambient and diffuse light.     ambient_light: Allows to define the value of the ambient light either using an int (ambient_light:(125)) or a rgb color ((ambient_light:rgb(255,255,255)). default is rgb(125,125,125).   diffuse_light: Allows to define the value of the diffuse light either using an int (diffuse_light:(125)) or a rgb color ((diffuse_light:rgb(255,255,255)). default is rgb(125,125,125).   diffuse_light_pos: Allows to define the position of the diffuse light either using an point (diffuse_light_pos:{x,y,z}). default is {world.shape.width/2,world.shape.height/2,world.shape.width*2}.   is_light_on: Allows to enable/disable the light. Default is true.   draw_diffuse_light: Allows to enable/disable the drawing of the diffuse light. Default is false )),   Here is an example using all the available facet to define a diffuse light that rotate around the world.  <img src= http://img.youtube.com/vi/op56elmEEYs/0.jpg  width= 425  height=344 />   display View1  type:opengl draw_diffuse_light:true ambient_light:(0) diffuse_light:(255) diffuse_light_pos:{50+ 150*sin(time*2),50,150*cos(time*2){ ... }  //: # (endConcept|3d_displays) ","url":"wiki/Defining3DDisplays.md"},{"id":"wiki/DefiningCharts.md","title":" Defining Charts","content":"# Defining Charts  To visualize result and make analysis about you model, you will certainly have to use charts. You can define 3 types of charts in GAML: histograms, pie, and series. For each type, you will have to determine the data you want to highlight.  Index     Define a chart   Data definition   Different types of charts   Define a chart  To define a chart, we have to use the chart statement. A chart has to be named (with the name facet), and the type has to be specified (with the type facet). The value of the type facet can be histogram, pie, series, scatter, xy. A chart has to be defined inside a display.   experiment my_experiment type: gui {  output {   display my_display {    chart my_chart type:pie {    }   }  } }   After declaring your chart, you have to define the data you want to display in your chart.  Data definition  Data can be specified with: * several data statements to specify each series * one datalist statement to give a list of series. It can be useful if the number of series is unknown, variable or too high.  The data statement is used to specify which variable will be displayed. You have to give your data a name (that will be displayed in your chart), the value of the variable you want to follow (using the value facet). You can add come optional facets such as color to specify the color of your data.       global {  int numberA <- 2 update:numberA*2;  int numberB <- 10000 update:numberB-1000; }  experiment my_experiment type: gui {  output {   display  my_display  {    chart  my_chart  type:pie {     data  numberA  value:numberA color:#red;     data  numberB  value:numberB color:#blue;    }   }  } }      (TODO_IMAGE)  The datalist statement is used several variables in one statement.  Instead of giving simple values, datalist is used with lists.   datalist [numberA,numberB] value:[numberA,numberB] color:[#red,#blue];  [TODO] Datalist provides you some additional facets you can use. If you want to learn more about them, please read the documentation [URL]  Different types of chart  As we already said, you can display 3 types of graphs: the histograms, the pies and the series.  The histograms  [TODO]       //: # (endConcept       defining_charts)   ","url":"wiki/DefiningCharts.md"},{"id":"wiki/DefiningDisplaysGeneralities.md","title":" Defining displays (Generalities)","content":"# Defining displays (Generalities) //: # (keyword|concept_display) //: # (keyword|concept_layer) //: # (keyword|concept_output)  Index     Displays and layers   Organize your layers   Example of layers  agents layer       species layer       image layer       text layer       graphics layer Displays and layers  A display is the graphical output of your simulation. You can define several displays related with what you want to represent from your model execution. To define a display, use the keyword display inside the output scope, and specify a name (name facet).   experiment my_experiment type: gui {  output {   display display1 {   }   display name:display2 {   }  } }   Other facets are available when defining your display: * Use background to define a color for your background  display my_display background:#red  //: # (keyword|concept_refresh) * Use refresh if you want to refresh the display when a condition is true (to refresh your display every number of steps, use the operator every)  display my_display refresh:every(10)   You can choose between two types of displays, by using the facet type: * java2D displays will be used when you want to have 2D visualization. It is used for example when you manipulate charts. This is the default value for the facet type.  * opengl displays allows you to have 3D visualization.  You can save the display on the disk, as a png file, in the folder name_of_model/models/snapshots, by using the facet autosave. This facet takes one a boolean as argument (to allow or not to save each frame) or a point (to define the size of your image). By default, the resolution of the output image is 500x500px (note that when no unit is provided, the unit is #px (pixel) ).   display my_display autosave:true type:java2D {}   is equivalent to :   display my_display autosave:{500,500} type:java2D {}   Each display can be decomposed in one or several layers. Here is a screenshot (from the Toy Model Ant) to better understand those different notions we are about to tackle in this session.    Organize your layers  In one 2D display, you will have several types of layers, giving what you want to display in your model. You have a large number of layers available. You already know some of them, such as species, agents, grid, but other specific layers such as image (to display image) and graphics (to freely draw shapes/geometries/texts without having to define a species) are also available  Each layer will be displayed in the same order as you declare them. The last declared layer will be above the others.  Thus, the following code:   experiment expe type:gui {     output {  display my_display {   graphics layer1 {       draw square(20) at:{10,10} color:#gold;   }   graphics layer2 {       draw square(20) at:{15,15} color:#darkorange;   }   graphics layer3 {       draw square(20) at:{20,20} color:#cornflowerblue;   }  }     } }   Will have this output:    Most of the layers have the transparency facet in order to see the layers which are under.   experiment expe type:gui {  output {   display my_display {    graphics layer1 {     draw square(20) at:{10,10} color:#darkorange;    }    graphics layer2 transparency:0.5 {     draw square(20) at:{15,15} color:#cornflowerblue;    }   }  } }     To specify a position and a size for your layer, you can use the position and the size facets. The position facet is used with a point type, between {0,0} and {1,1}, which corresponds to the position of the upper left corner of your layer in percentage. Then, if you choose the point {0.5,0.5}, the upper left corner of your layer will be in the center of your display. By default, this value is {0,0}. The size facet is used with a point type, between {0,0} and {1,1} also. It corresponds to the size occupied by the layer in percentage. By default, this value is {1,1}.   experiment expe type:gui {  output {   display my_display {    graphics layer1 position:{0,0} size:{0.5,0.8} {     draw shape color:#darkorange;    }    graphics layer2 position:{0.3,0.1} size:{0.6,0.2} {     draw shape color:#cornflowerblue;    }    graphics layer3 position:{0.4,0.2} size:{0.3,0.8} {     draw shape color:#gold;    }   }  } }     NB : displays can have background, while graphics can t. If you want to put a background for your graphics, a solution can be to draw the shape of the world (which is, by default, a square 100m*100m).  A lot of other facets are available for the different layers. Please read the documentation of graphics for more information.  Example of layers  agents layer agents allows the modeler to display only the agents that fulfill a given condition.  Please read the documentation about agents statement if you are interested.  species layer species allows modeler to display all the agent of a given species in the current display. In particular, modeler can choose the aspect used to display them.  Please read the documentation about species statement if you are interested.  image layer image allows modeler to display an image (e.g. as background of a simulation).  Please read the documentation about image statement if you are interested.  ### graphics layer graphics allows the modeler to freely draw shapes/geometries/texts without having to define a species.  Please read the documentation about graphics statement if you are interested.       //: # (endConcept       2d_displays)   ","url":"wiki/DefiningDisplaysGeneralities.md"},{"id":"wiki/DefiningExportFiles.md","title":" Defining export files","content":"# Defining export files  Index     The Save Statement   Export files in experiment   Autosave   The Save Statement  Allows to save data in a file. The type of file can be  shp ,  text  or  csv . The save statement can be use in an init block, a reflex, an action or in a user command. Do not use it in experiments.  Facets     to (string): an expression that evaluates to an string, the path to the file   data (any type), (omissible) : any expression, that will be saved in the file   crs (any type): the name of the projectsion, e.g. crs: EPSG:4326  or its EPSG id, e.g. crs:4326. Here a list of the CRS codes (and EPSG id): http://spatialreference.org   rewrite (boolean): an expression that evaluates to a boolean, specifying whether the save will ecrase the file or append data at the end of it   type (an identifier): an expression that evaluates to an string, the type of the output file (it can be only  shp ,  text  or  csv )   with (map):   Usages     Its simple syntax is:    save data to: output_file type: a_type_file;      To save data in a text file:    save (string(cycle) + ->  + name + : + location) to: save_data.txt type: text;      To save the values of some attributes of the current agent in csv file:    save [name, location, host] to: save_data.csv type: csv;      To save the geometries of all the agents of a species into a shapefile (with optional attributes):    save species_of(self) to: save_shapefile.shp type: shp with: [name::nameAgent, location::locationAgent] crs: EPSG:4326;   Export files in experiment  Displays are not the only output you can manage in GAMA. Saving data to a file during an experiment can also be achieved in several ways, depending on the needs of the modeler. One way is provided by the save statement, which can be used everywhere in a model or a species. The other way, described here, is to include an output_file statement in the output section.   output_file name:file_name type:file_type data:data_to_write;    with:  file_type: text, csv or xml file_name: string data_to_write: string  Example:   file name: results type: text data: time + ;  + nb_preys + ; + nb_predators refresh:every(2);     Each time step (or according to the frequency defined in the refresh facet of the file output), a new line will be added at the end of the file. If rewrite: false is defined in its facets, a new file will be created for each simulation (identified by a timestamp in its name).  Optionally, a footer and a header can also be described with the corresponding facets (of type string).  Autosave  Image files can be exported also through the autosave facet of the display, as explained in this previous part. //: # (endConcept|export_files) ","url":"wiki/DefiningExportFiles.md"},{"id":"wiki/DefiningMonitorsAndInspectors.md","title":" Defining monitors and inspectors","content":"# Defining monitors and inspectors  Other outputs can be very useful to study better the behavior of your agents.  Index     Define a monitor   Define an inspector   ## Define a monitor  A monitor allows to follow the value of an arbitrary expression in GAML. It will appear, in the User Interface, in a small window on its own and be recomputed every time step (or according to its refresh facet).  Definition of a monitor:   monitor monitor_name value: an_expression refresh:boolean_statement;   with: * value: mandatory, the expression whose value will be displayed by the monitor. * refresh: bool statement, optional : the new value is computed if the bool statement returns true.  Example:   experiment my_experiment type: gui {  output {   monitor monitor_name value: cycle refresh:every(1);  } }   NB : you can also declare monitors during the simulation, by clicking on the button  Add new monitor , and specifying the name of the variable you want to follow.  ## Define an inspector  During the simulation, the user interface of GAMA provides the user the possibility to inspect an agent, or a group of agents. But you can also define the inspector you want directly from your model, as an output of the experiment.  Use the statement inspect to define your inspector, in the output scope of your gui experiment. The inspector has to be named (using the facet name), a value has to be specified (with the value facet).   inspect name:inspector_name value:the_value_you_want_to_display;   Note that you can inspect any type of species (regular species, grid species, even the world…).  The optional facet type is used to specify the type of your inspector. 2 values are possible :  * agent (default value) if you want to display the information as a regular agent inspector. Note that if you want to inspect a large number of agents, this can take a lot of time. In this case, prefer the other type table * table if you want to display the information as an agent browser  The optional facet attribute is used to filter the attributes you want to be displayed in your inspector.  Beware : only one agent inspector (type:agent) can be used for an experiment. Beside, you can add as many agent browser (type:table) as you want for your experiment.  Example of implementation :      model new  global {  init {   create my_species number:3;  } }  species my_species {  int int_attr <- 6;  string str_attr <-  my_value ;  string str_attr_not_important <-  blabla ; }  grid my_grid_species width: 10 height: 10 {  int rnd_value <- rnd(5); }  experiment my_experiment type:gui {  output {   inspect name: my_species_inspector  value:my_species attributes:[ int_attr , str_attr ];   inspect name: my_species_browser  value:my_species type:table;   inspect name: my_grid_species_browser  value:5 among my_grid_species type:table;  } }      Another statement, browse, is doing a similar thing, but preferring the table type (if you want to browse an agent species, the default type will be the table type). //: # (endConcept|monitors_and_inspectors) ","url":"wiki/DefiningMonitorsAndInspectors.md"},{"id":"wiki/DefiningParameters.md","title":" Defining Parameters","content":"# Defining Parameters //: # (keyword|concept_gui)  When playing simulation, you have the possibility to define input parameters, in order to change them and replay the simulation. Defining parameters allows to make the value of a global variable definable by the user through the user graphic interface.  Index     Defining parameters   Additional facets   Defining parameters  You can define parameters inside the global scope, when defining your global variables with the facet parameter:   global {  int my_integer_global_value <- 5 parameter: My integer global value; }   When launching your experiment, the parameter will appear in your  Parameters  panel, with the name you chose for the parameter facet.    You can also define your parameter inside the experiment, using the statement parameter. You have to specify first the name of your parameter, then the name of the global variable through the facet var.   global {  int my_integer_global_value <- 5; }   experiment MyExperiment type: gui {  parameter  My integer global value  var:my_integer_global_value; }  NB: This variable has to be initialized with a value. If you don t want to initialize your value on the global scope, you can initialize the value directly on the parameter statement, using the facet init.      global {  int my_integer_global_value; }  experiment MyExperiment type: gui {  parameter  My integer global value  var:my_integer_global_value init:5; }      Additional facets  You can use some facets to arrange your parameters. For example, you can categorize your parameters under a label, using the facet category:   global {  int attr_1 <- 5 parameter:attr 1 category:category 1;  int attr_2 <- 5 parameter:attr 2 category:category 1;  int attr_3 <- 5 parameter:attr 3 category:category 2; }     You also can add some facets such as min, max or among to improve the declaration of the parameter.      global {  string fruit <-  none  among:[ none , apple , banana ] parameter: fruit  category: food ;  string vegetable <-  none  among:[ none , cabbage , carrot ] parameter: vegetable  category: food ;  int integer_variable <- 5 parameter: integer variable  min:0 max:100  category: other ; }  experiment MyExperiment type: gui { }       //: # (endConcept|define_parameters) ","url":"wiki/DefiningParameters.md"},{"id":"wiki/DefiningUserInteraction.md","title":" Defining user interaction","content":"# Defining user interaction  During the simulation, GAML provides you the possibility to define some function the user can execute during the execution. In this chapter, we will see how to define buttons to execute action during the simulation, how to catch click event, and how to use the user control architecture.  Index     Catch Mouse Event   Define User command  … in the GUI Experiment scope       … in global or regular species       user_location       user_input User Control Architecture   Catch Mouse Event  You can catch mouse event during the simulation using the statement event. This statement has 2 required facets: * name (identifier) : Specify which event do you want to trigger (among the following values : mouse_down, mouse_down, mouse_move, mouse_enter, mouse_exit). * action (identifier) : Specify the name of the global action to call.   event mouse_down action: my_action;   The event statement has to be defined in the experiment/output/display scope. Once the event is triggered, the global action linked will be called. The action linked has to have 2 arguments : the location of the click (type point) and the list of agents which are displayed at this position.      global {  action my_action (point loc, list selected_agents)  {   write do action;  }  }  species my_species { }  experiment my_experiment type: gui {  output  {   display my_display   {    species my_species;    event mouse_down action: my_action;   }  } }      Define User command  Anywhere in the global block, in a species or in an (GUI) experiment, user_command statements can be implemented. They can either call directly an existing action (with or without arguments) or be followed by a block that describes what to do when this command is run.  Their syntax can be (depending of the modeler needs) either:   user_command cmd_name action: action_without_arg_name; //or user_command cmd_name action: action_name with: [arg1::val1, arg2::val2]; //or user_command cmd_name {    // statements }   For instance:   user_command kill_myself action: die; //or user_command kill_myself action: some_action with: [arg1::5, arg2::3]; //or user_command kill_myself {     do die; }   Defining User command in GUI Experiment scope  The user command can be defined directly inside the GUI experiment scope. In that case, the implemented action appears as a button in the top of the parameter view.  Here is a very short code example :      model quick_user_command_model  global {  action createAgent  {   create my_species;  } }  species my_species {  aspect base {   draw circle(1) color:#blue;  } }  experiment expe type:gui {  user_command cmd_inside_experiment action:createAgent;  output {   display my_display {    species my_species aspect:base;   }  } }      And here is screenshots of the execution :    Defining User command in a global or regular species  The user command can also be defined inside a species scope (either global or regular one). Here is a quick example of model :      model quick_user_command_model  global {  init {   create my_species number:10;  } }  species my_species {  user_command cmd_inside_experiment action:die;  aspect base {   draw circle(1) color:#blue;  } }  experiment expe type:gui {  output {   display my_display {    species my_species aspect:base;   }  } }      During the execution, you have 2 ways to access to the action : * When the agent is inspected, they appear as buttons above the agents  attributes   * When the agent is selected by a right-click in a display, these command appear under the usual  Inspect ,  Focus  and  Highlight  commands in the pop-up menu.    Remark: The execution of a command obeys the following rules: * when the command is called from right-click pop-menu, it is executed immediately * when the command is called from panels, its execution is postponed until the end of the current step and then executed at that time.  user_location  In the special case when the user_command is called from the pop-up menu (from a right-click on an agent in a display), the location chosen by the user (translated into the model coordinates) is passed to the execution scope under the name user_location.  Example:   global {    user_command Create agents here {       create my_species number: 10 with: [location::user_location];    } }   This will allow the user to click on a display, choose the world (always present now), and select the menu item  Create agents here .  Note that if the world is inspected (this user_command appears thus as a button) and the user chooses to push the button, the agent will be created at a random location.  user_input  As it is also, sometimes, necessary to ask the user for some values (not defined as parameters), the user_input unary operator has been introduced. This operator takes a map [string::value] as argument (the key is the name of the chosen parameter, the value is the default value), displays a dialog asking the user for these values, and returns the same map with the modified values (if any). You can also add a text as first argument of the operator, which will be displayed as a title for your dialog popup. The dialog is modal and will interrupt the execution of the simulation until the user has either dismissed or accepted it. It can be used, for instance, in an init section like the following one to force the user to input new values instead of relying on the initial values of parameters.  Here is an example of implementation:      model quick_user_command_model  global {    init {       map values <- user_input( choose a number of agent to create ,[ Number  :: 100]);       create my_species number : int(values at  Number );    } }  species my_species {  aspect base {   draw circle(1) color:#blue;  } }  experiment expe type:gui {  output {   display my_display {    species my_species aspect:base;   }  } }      When running this model, you will first have to input a number:    User Control Architecture  An other way to define user interaction is to use the user control architecture. Please jump directly to the section user control architecture if you want to learn more about this point. ","url":"wiki/DefiningUserInteraction.md"},{"id":"wiki/BatchExperiments.md","title":" Defining Batch Experiments","content":"# Defining Batch Experiments  Batch experiments allows to execute numerous successive simulation runs.They are used to explore the parameter space of a model or to optimize a set of model parameters.  A Batch experiment is defined by:   experiment exp_title type: batch {    [parameter to explore]    [exploration method]    [reflex]    [permanent] }   Table of contents     The batch experiment facets   Action _step   Reflexes   Permanent   The batch experiment facets Batch experiment have the following three facets: * until: (expression) Specifies when to stop each simulations. Its value is a condition on variables defined in the model. The run will stop when the condition is evaluated to true. If omitted, the first simulation run will go forever, preventing any subsequent run to take place (unless a halt command is used in the model itself). * repeat: (integer) A parameter configuration corresponds to a set of values assigned to each parameter. The attribute repeat specifies the number of times each configuration will be repeated, meaning that as many simulations will be run with the same parameter values. Different random seeds are given to the pseudo-random number generator. This allows to get some statistical power from the experiments conducted. Default value is 1. * keep_seed: (boolean) If true, the same series of random seeds will be used from one parameter configuration to another. Default value is false.   experiment my_batch_experiment type: batch repeat: 5 keep_seed: true until: time = 300 {    [parameter to explore]    [exploration method] }   Action _step The_step_action of an experiment is called at the end of a simulation. It is possible to override this action to apply a specific action at the end of each simulation. Note that at the experiment level, you have access to all the species and all the global variables._  For instance, the following experiment runs the simulation 5 times, and, at the end of each simulation, saves the people agents in a shapefile.     experiment  Run 5 simulations  type: batch repeat: 5 keep_seed: true until: ( time > 1000 ) {  int cpt <- 0;  action step {   save people type: shp  to: people_shape  + cpt +  .shp  with: [is_infected:: INFECTED ,is_immune:: IMMUNE ];   cpt <- cpt + 1;  } }  A second solution to achieve the same result is to use reflexes (see below).      Reflexes It is possible to write reflexes inside a batch experiment. This reflex will be executed at the end of each simulation. For instance, the following reflex writes at the end of each simulation the value of the variable food_gathered:   reflex info_sim {  write Running a new simulation  + simulation +  ->  + food_gathered; }   ## Permanent The permanent section allows to define a output block that will not be re-initialized at the beginning of each simulation but will be filled at the end of each simulation. For instance, this permanent section will allows to display for each simulation the end value of the food_gathered variable.  permanent {  display Ants background: rgb( white ) refresh:every(1) {   chart Food Gathered type: series {    data Food value: food_gathered;   }  } }  ","url":"wiki/BatchExperiments.md"},{"id":"wiki/ExplorationMethods.md","title":" Exploration Methods","content":"# Exploration Methods  Several batch methods are currently available. Each is described below.  Table of contents     The method element   Exhaustive exploration of the parameter space   Hill Climbing   Simulated Annealing   Tabu Search   Reactive Tabu Search   Genetic Algorithm   ## The method element The optional method element controls the algorithm which drives the batch.  If this element is omitted, the batch will run in a classical way, changing one parameter value at each step until all the possible combinations of parameter values have been covered. See the Exhaustive exploration of the parameter space for more details.  When used, this element must contain at least a name attribute to specify the algorithm to use. It has theses facets: * minimize or a maximize (mandatory for optimization method): a attribute defining the expression to be optimized. * aggregation (optional): possible values ( min ,  max ). Each combination of parameter values is tested repeat times. The aggregated fitness of one combination is by default the average of fitness values obtained with those repetitions. This facet can be used to tune this aggregation function and to choose to compute the aggregated fitness value as the minimum or the maximum of the obtained fitness values. * other parameters linked to exploration method (optional) : see below for a description of these parameters.  Exemples of use of the method elements:     method exhaustive minimize: nb_infected ;  method genetic pop_dim: 3 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 5  minimize: nb_infected aggregation:  max ;      ## Exhaustive exploration of the parameter space  Parameter definitions accepted: List with step and Explicit List. Parameter type accepted: all.  This is the standard batch method. The exhaustive mode is defined by default when there is no method element present in the batch section. It explores all the combination of parameter values in a sequential way.  Example (models/ants/batch/ant_exhaustive_batch.xml):   experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time > 400 ) {  parameter  Evaporation:  var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit:  rate every cycle (1.0 means 100%) ;  parameter  Diffusion:  var: diffusion_rate min: 0.1 max: 1.0 unit:  rate every cycle (1.0 means 100%)  step: 0.3; }   The order of the simulations depends on the order of the param. In our example, the first combinations will be the followings: * evaporation_rate = 0.1, diffusion_rate = 0.1, (2 times) * evaporation_rate = 0.1, diffusion_rate = 0.4, (2 times) * evaporation_rate = 0.1, diffusion_rate = 0.7, (2 times) * evaporation_rate = 0.1, diffusion_rate = 1.0, (2 times) * evaporation_rate = 0.2, diffusion_rate = 0.1, (2 times) * …  Note: this method can also be used for optimization by adding an method element with maximize or a minimize attribute:   experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time > 400 ) {  parameter  Evaporation:  var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit:  rate every cycle (1.0 means 100%) ;  parameter  Diffusion:  var: diffusion_rate min: 0.1 max: 1.0 unit:  rate every cycle (1.0 means 100%)  step: 0.3;  method exhaustive maximize: food_gathered; }   Hill Climbing  Name: hill_climbing Parameter definitions accepted: List with step and Explicit List. Parameter type accepted: all.  This algorithm is an implementation of the Hill Climbing algorithm. See the wikipedia article.  Algorithm:    Initialization of an initial solution s   iter = 0  While iter <= iter_max, do:    Choice of the solution s  in the neighborhood of s that maximize the fitness function    If f(s ) > f(s)      s = s     Else      end of the search process    EndIf    iter = iter + 1  EndWhile   Method parameters: * iter_max: number of iterations  Example (models/ants/batch/ant_hill_climbing_batch.xml):   experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time > 400 ) {  parameter  Evaporation:  var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit:  rate every cycle (1.0 means 100%) ;  parameter  Diffusion:  var: diffusion_rate min: 0.1 max: 1.0 unit:  rate every cycle (1.0 means 100%)  step: 0.3;  method hill_climbing iter_max: 50 maximize : food_gathered; }   Simulated Annealing Name: annealing Parameter definitions accepted: List with step and Explicit List. Parameter type accepted: all.  This algorithm is an implementation of the Simulated Annealing algorithm. See the wikipedia article.  Algorithm:    Initialization of an initial solution s   temp = temp_init  While temp > temp_end, do:    iter = 0    While iter < nb_iter_cst_temp, do:      Random choice of a solution s2 in the neighborhood of s df = f(s2)-f(s)      If df > 0  s = s2      Else, rand = random number between 0 and 1 If rand < exp(df/T)   s = s2 EndIf      EndIf      iter = iter + 1    EndWhile    temp = temp * nb_iter_cst_temp  EndWhile   Method parameters: * temp_init: Initial temperature * temp_end: Final temperature * temp_decrease: Temperature decrease coefficient * nb_iter_cst_temp: Number of iterations per level of temperature  Example (models/ants/batch/ant_simulated_annealing_batch.xml):   experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time > 400 ) {  parameter  Evaporation:  var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit:  rate every cycle (1.0 means 100%) ;  parameter  Diffusion:  var: diffusion_rate min: 0.1 max: 1.0 unit:  rate every cycle (1.0 means 100%)  step: 0.3;  method annealing temp_init: 100  temp_end: 1 temp_decrease: 0.5 nb_iter_cst_temp: 5 maximize: food_gathered; }   Tabu Search Name: tabu Parameter definitions accepted: List with step and Explicit List. Parameter type accepted: all.  This algorithm is an implementation of the Tabu Search algorithm. See the wikipedia article.  Algorithm:    Initialization of an initial solution s   tabuList = {}  iter = 0  While iter <= iter_max, do:    Choice of the solution s2 in the neighborhood of s such that:      s2 is not in tabuList      the fitness function is maximal for s2    s = s2    If size of tabuList = tabu_list_size      removing of the oldest solution in tabuList     EndIf    tabuList = tabuList + s    iter = iter + 1  EndWhile   Method parameters: * iter_max: number of iterations * tabu_list_size: size of the tabu list   experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time > 400 ) {  parameter  Evaporation:  var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit:  rate every cycle (1.0 means 100%) ;  parameter  Diffusion:  var: diffusion_rate min: 0.1 max: 1.0 unit:  rate every cycle (1.0 means 100%)  step: 0.3;  method tabu iter_max: 50 tabu_list_size: 5 maximize: food_gathered; }   Reactive Tabu Search  Name: reactive_tabu Parameter definitions accepted: List with step and Explicit List. Parameter type accepted: all.  This algorithm is a simple implementation of the Reactive Tabu Search algorithm ((Battiti et al., 1993)). This Reactive Tabu Search is an enhance version of the Tabu search. It adds two new elements to the classic Tabu Search. The first one concerns the size of the tabu list: in the Reactive Tabu Search, this one is not constant anymore but it dynamically evolves according to the context. Thus, when the exploration process visits too often the same solutions, the tabu list is extended in order to favor the diversification of the search process. On the other hand, when the process has not visited an already known solution for a high number of iterations, the tabu list is shortened in order to favor the intensification of the search process. The second new element concerns the adding of cycle detection capacities. Thus, when a cycle is detected, the process applies random movements in order to break the cycle.  Method parameters: * iter_max: number of iterations * tabu_list_size_init: initial size of the tabu list * tabu_list_size_min: minimal size of the tabu list * tabu_list_size_max: maximal size of the tabu list * nb_tests_wthout_col_max: number of movements without collision before shortening the tabu list * cycle_size_min: minimal size of the considered cycles * cycle_size_max: maximal size of the considered cycles   experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time > 400 ) {  parameter  Evaporation:  var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit:  rate every cycle (1.0 means 100%) ;  parameter  Diffusion:  var: diffusion_rate min: 0.1 max: 1.0 unit:  rate every cycle (1.0 means 100%)  step: 0.3;  method reactive_tabu iter_max: 50 tabu_list_size_init: 5 tabu_list_size_min: 2 tabu_list_size_max: 10 nb_tests_wthout_col_max: 20 cycle_size_min: 2 cycle_size_max: 20 maximize: food_gathered; }   Genetic Algorithm Name: genetic Parameter definitions accepted: List with step and Explicit List. Parameter type accepted: all.  This is a simple implementation of Genetic Algorithms (GA). See the wikipedia article. The principle of GA is to search an optimal solution by applying evolution operators on an initial population of solutions There are three types of evolution operators: * Crossover: Two solutions are combined in order to produce new solutions * Mutation: a solution is modified * Selection: only a part of the population is kept. Different techniques can be applied for this selection. Most of them are based on the solution quality (fitness).  Representation of the solutions: * Individual solution: {Param1 = val1; Param2 = val2; …} * Gene: Parami = vali  Initial population building: the system builds nb_prelim_gen random initial populations composed of pop_dim individual solutions. Then, the best pop_dim solutions are selected to be part of the initial population.  Selection operator: roulette-wheel selection: the probability to choose a solution is equals to: fitness(solution)/ Sum of the population fitness. A solution can be selected several times. Ex: population composed of 3 solutions with fitness (that we want to maximize) 1, 4 and 5. Their probability to be chosen is equals to 0.1, 0.4 and 0.5.  Mutation operator: The value of one parameter is modified. Ex: The solution {Param1 = 3; Param2 = 2} can mute to {Param1 = 3; Param2 = 4}  Crossover operator: A cut point is randomly selected and two new solutions are built by taking the half of each parent solution. Ex: let {Param1 = 4; Param2 = 1} and {Param1 = 2; Param2 = 3} be two solutions. The crossover operator builds two new solutions: {Param1 = 2; Param2 = 1} and {Param1 = 4; Param2 = 3}.  Method parameters: * pop_dim: size of the population (number of individual solutions) * crossover_prob: crossover probability between two individual solutions * mutation_prob: mutation probability for an individual solution * nb_prelim_gen: number of random populations used to build the initial population * max_gen: number of generations   experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time > 400 ) {  parameter  Evaporation:  var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit:  rate every cycle (1.0 means 100%) ;  parameter  Diffusion:  var: diffusion_rate min: 0.1 max: 1.0 unit:  rate every cycle (1.0 means 100%)  step: 0.3;  method genetic maximize: food_gathered pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 20;  }  //: # (endConcept|exploration_methods) ","url":"wiki/ExplorationMethods.md"},{"id":"wiki/RunSeveralSimulations.md","title":" Run Several Simulations","content":"# Run Several Simulations  To explore a model, the easiest and the most intuitive way to proceed is running several simulations with several parameter value, and see the differences from the output. GAMA provides you the possibility to launch several simulations from the GUI.  Index     Create a simulation   Manipulate simulations   Random seed  Defining the seed from the model       Defining the seed from the experiment       Run several simulations with the same random numbers       Change the RNG Create a simulation  Let s remind you that in GAMA, everything is an agent. We already saw that the  world  agent is the agent of the model. The model is thus a species, called modelName_model :   model toto // <- the name of the species is toto_model   New highlight of the day : an Experiment is also an agent ! It s a special agent which will instantiate automatically an agent from the model species. You can then perfectly create agents (model agents) from your experiment, using the statement create :      model multi_simulations // the  world  is an instance of the  multi_simulations_model   global { }  experiment my_experiment type:gui  {  init {   create multi_simulations_model;  } }      This sort model will instantiate 2 simulations (two instance of the model) : one is created automatically by the experiment, and the second one is explicitly created through the statement create.  To simplify the syntax, you can use the built-in attribute simulation of your experiment. When you have a model called  multi_simulations , the two following lines are strictly equal :   create multi_simulations_model; create simulation;   As it was the case for creating regular species, you can specify the parameters of your agent during the creation through the facet with: :      model multi_simulations  global {  rgb bgd_color; }  experiment my_experiment type:gui  {  parameter name: background color:  var:bgd_color init:#blue;  init {   create simulation with:[bgd_color::#red];  }  output {   display  my_display  background:bgd_color{}  } }      Manipulate simulations  When you think the simulations as agents, it gives you a lot of new possibilities. You can for example create a reflex from your experiment, asking to create simulations during the experiment execution !  The following short model for example will create a new simulation at each 10 cycles :      model multi_simulations  global {  init {   write  new simulation created ! Its name is  +name;  } }  experiment my_experiment type:gui  {  init {  }  reflex when:(mod(cycle,10)=0 and cycle!=0) {   create simulation;  }  output {  } }      You may ask, what is the purpose of such a thing ? Well, with such a short model, it is not very interesting, for sure. But you can imagine running a simulation, and if the simulation reaches a certain state, it can be closed, and another simulation can be run instead with different parameters (a simulation can be closed by doing a  do die  on itself). You can also imagine to run two simulations, and to communicate from one to an other through the experiment, as it is shown in this easy model, where agents can move from one simulation to another :        model smallWorld  global {  int grid_size <- 10;  bool modelleft <- true;  int id<- 0;  int nb_agents <- 50;  init {  create people number: nb_agents {   my_cell <- one_of(cell);   location <- my_cell.location;  }  if (modelleft) {   ask cell where (each.grid_x = (grid_size - 1))  {    color <- #red;    }  } else {   ask cell where (each.grid_x = 0)  {    color <- #red;    }  } }  action changeWorld(rgb color, point loc) {  create people with:[color::color, location::loc] {   my_cell <- cell(location);  } } }   species people {  rgb color <- rnd_color(255);  cell my_cell;  reflex move {  if (modelleft and my_cell.color = #red) {   ask smallWorld_model[1] {    do changeWorld(myself.color, {100 - myself.location.x,myself.location.y});    }    do die;  } else {   list<cell> free_cells <- list<cell> (my_cell.neighbors) where empty(people inside each);   if not empty(free_cells) {    my_cell <- one_of(free_cells);    location <- my_cell.location;   }  }   }  aspect default {  draw circle(50/grid_size) color: color; }  }   grid cell width: grid_size height: grid_size;  experiment fromWorldToWorld type: gui {  init {    create simulation with:[grid_size::20, modelleft::false, id::1, nb_agents::0];  }  output {  display map {   grid cell lines: #black;   species people;  } } }       Here is an other example of application of application, available in the model library. Here we run 4 times the Ant Foraging model, with different parameters.  //: # (endConcept       run_simulations_as_agents)       //: # (startConcept       control_randomness) ## Random seed  Defining the seed from the model  If you run several simulations, you may want to use the same seed for each one of those simulations (to compare the influence of a certain parameter, in exactly the same conditions).  Let s remind you that seed is a built-in attribute of the model. You than just need to specify the value of your seed during the creation of the simulation if you want to fix the seed :   create simulation with:[seed::10.0];   You can also specify the seed if you are inside the init scope of your global agent.   global {  init {   seed<-10.0;  } }   Notice that if you affect the value of your seed built-in directly in the global scope, the affectation of the parameters (for instance specified with the facet with of the statement create), and the  init  will be done after  will be done at the end.  Defining the seed from the experiment  The experiment agent also have a built-in attribute seed. The value of this seed is defined in your simulation preferences. The first simulation created is created with the seed value of the experiment.  The following sequence diagram can explain you better how the affectation of the seed attribute works :    The affectation of an attribute is always done in this order : (1) the attribute is affected with a specific value in the species scope. If no attribute value is specified, the value is a default value. (2) if a value is specified for this attribute in the create statement, then the attribute value is affected again. (3) the attribute value can be changed again in the init scope.  Run several simulations with the same random numbers  The following code shows how to run several simulations with a specific seed, determined from the experiment agent :      model multi_simulations  global {  init {   create my_species;  } }  species my_species skills:[moving] {  reflex update {   do wander;  }  aspect base {   draw circle(2) color:#green;  } }  experiment my_experiment type:gui  {  float seedValue <- 10.0;  float seed <- seedValue; // force the value of the seed.  init {   // create a second simulation with the same seed as the main simulation   create simulation with:[seed::seedValue];  }  output {   display my_display {    species my_species aspect:base;   }  } }      When you run this simulation, their execution is exactly similar.    Let s try now to add a new species in this model, and to add a parameter to the simulation for the number of agents created for this species.      model multi_simulations  global {  int number_of_speciesB <- 1;  init {   create my_speciesA;   create my_speciesB number:number_of_speciesB;  } }  species my_speciesA skills:[moving] {  reflex update {   do wander;  }  aspect base {   draw circle(2) color:#green;  } }  species my_speciesB skills:[moving] {  reflex update {   do wander;  }  aspect base {   draw circle(2) color:#red;  } }  experiment my_experiment type:gui  {  float seedValue <- 10.0;  float seed <- seedValue; // force the value of the seed.  init {   create simulation with:[seed::seedValue,number_of_speciesB::2];  }  output {   display my_display {    species my_speciesA aspect:base;    species my_speciesB aspect:base;   }  } }      Then you run the experiment, you may find something strange…    Even if the first step seems ok (the greed agent and one of the two red agent is initialized with the same location), the simulation differs completly. You should have expected to have the same behavior for the greed agent in both of the simulation, but it is not the case. The explaination of this behavior is that a random number generator has generated more random numbers in the second simulation than in the first one.  If you don t understand, here is a short example that may help you to understand better :      model multi_simulations  global {  int iteration_number <- 1;  reflex update {   float value;   loop times:iteration_number {    value<-rnd(10.0);    write value;   }   write  cycle  +cycle+  in experiment  +name+  :  +value;  } }  experiment my_experiment type:gui  {  float seedValue <- 10.0;  float seed <- seedValue; // force the value of the seed.  init {   create simulation with:[seed::seedValue,iteration_number::2];  }  output {  } }      The output will be something like that :   7.67003069780383 cycle 0 in experiment multi_simulations_model0 : 7.67003069780383 7.67003069780383 0.22889843360303863 cycle 0 in experiment multi_simulations_model1 : 0.22889843360303863 0.22889843360303863 cycle 1 in experiment multi_simulations_model0 : 0.22889843360303863 4.5220913306263855 0.8363180333035425 cycle 1 in experiment multi_simulations_model1 : 0.8363180333035425 4.5220913306263855 cycle 2 in experiment multi_simulations_model0 : 4.5220913306263855 5.460148568140819 4.158355846617511 cycle 2 in experiment multi_simulations_model1 : 4.158355846617511 0.8363180333035425 cycle 3 in experiment multi_simulations_model0 : 0.8363180333035425 1.886091659169562 4.371253083874633 cycle 3 in experiment multi_simulations_model1 : 4.371253083874633   Which means :       Cycle       Value generated in simulation 0       Value generated in simulation 1   1       7.67003069780383       7.67003069780383                       0.22889843360303863       2       0.22889843360303863       4.5220913306263855                       0.8363180333035425       3       4.5220913306263855       5.460148568140819                       4.158355846617511 When writing your models, you have to be aware of this behavior. Remember that each simulation has it s own random number generator.  Change the RNG  The RNG (random number generator) can also be changed : rng is a string built-in attribute of the experiment (and also of the model). You can choose among the following rng : - mersenne (by default) - cellular - java  The following model shows how to run 4 simulations with the same seed but with some different RNG :      model multi_simulations  global {  init {   create my_species number:50;  } }  species my_species skills:[moving] {  reflex update {   do wander;  }  aspect base {   draw square(2) color:#blue;  } }  experiment my_experiment type:gui  {  float seed <- 10.0;  init {   create simulation with:[rng:: cellular ,seed::10.0];   create simulation with:[rng:: java ,seed::10.0];  }  output {   display my_display {    species my_species aspect:base;    graphics  my_graphic  {     draw rectangle(35,10) at:{0,0} color:#lightgrey;     draw rng at:{3,3} font:font( Helvetica , 20 , #plain) color:#black;    }   }  } }     //: # (endConcept|control_randomness) ","url":"wiki/RunSeveralSimulations.md"},{"id":"wiki/AttachingSkills.md","title":" Attaching Skills","content":"# Attaching Skills  GAMA allows to attach skills to agents through the facet skills. Skills are built-in modules that provide a set of related built-in attributes and built-in actions (in addition to those already proposed by GAMA) to the species that declare them.  Index     The moving skill   Other skills   Example of implementation   Skills  A declaration of skill is done by filling the skills facet in the species definition:   species my_species skills: [skill1,skill2] { }   A very useful and common skill is the moving skill.   species my_species skills: [moving] { }   Once your species has the moving skill, it earns automatically the following attributes: speed, heading, destination and the following actions: move, goto, follow, wander and wander_3D.  Attributes:     speed (float) designs the speed of the agent, in m/s.   heading (int) designs the heading of an agent in degrees, which means that is the maximum angle the agent can turn around each step.   destination (point) is the updated destination of the agent, with respect to its speed and heading. It s a read-only attribute, you can t change its value.   Actions:  follow moves the agent along a given path passed in the arguments.     returns: path   speed (float): the speed to use for this move (replaces the current value of speed)   path (path): a path to be followed.   move_weights (map): Weights used for the moving.   return_path (boolean): if true, return the path followed (by default: false)   goto moves the agent towards the target passed in the arguments.     returns: path   target (agent,point,geometry): the location or entity towards which to move.   speed (float): the speed to use for this move (replaces the current value of speed)   on (graph): graph that restrains this move   recompute_path (boolean): if false, the path is not recompute even if the graph is modified (by default: true)   return_path (boolean): if true, return the path followed (by default: false)   move_weights (map): Weights used for the moving.   move moves the agent forward, the distance being computed with respect to its speed and heading. The value of the corresponding variables are used unless arguments are passed.     returns: path   speed (float): the speed to use for this move (replaces the current value of speed)   heading (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2)   bounds (geometry,agent): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry   wander Moves the agent towards a random location at the maximum distance (with respect to its speed). The heading of the agent is chosen randomly if no amplitude is specified. This action changes the value of heading.     returns: void   speed (float): the speed to use for this move (replaces the current value of speed)   amplitude (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2)   bounds (agent,geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry   wander_3D Moves the agent towards a random location (3D point) at the maximum distance (with respect to its speed). The heading of the agent is chosen randomly if no amplitude is specified. This action changes the value of heading.     returns: path   speed (float): the speed to use for this move (replaces the current value of speed)   amplitude (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2)   z_max (int): the maximum altitude (z) the geometry can reach   bounds (agent,geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry   Other skills  A lot of other skills are available. Some of them can be built in skills, integrated by default in GAMA, other are linked to additional plugins.  This is the list of skills: Advanced_driving, communication, driving, GAMASQL, graphic, grid, MDXSKILL, moving, moving3D, physical3D, skill_road, skill_road, skill_road_node, SQLSKILL  Example  We can now build a model using the skill moving. Let s design 2 species, one is  species_red , the other is  species_green .  Species_green agents are moving randomly with a certain speed and a certain heading. Species_red agents wait for a species_green agent to be in a certain range of distance. Once it is the case, the agent move toward the species_green agent. A line link the red_species agent and its target.    Here is an example of implementation:      model green_and_red_species  global{  float distance_to_intercept <- 10.0;  int number_of_green_species <- 50;  int number_of_red_species <- 50;  init {   create speciesA number:number_of_green_species;   create speciesB number:number_of_red_species;  } }  species speciesA skills:[moving] {  init {   speed <- 1.0;  }  reflex move {   do wander amplitude:90;  }  aspect default {   draw circle(1) color:#green;  } }  species speciesB skills:[moving] {  speciesA target;  init {   speed <- 0.0;   heading <- 90;  }  reflex search_target when:target=nil {   ask speciesA at_distance(distance_to_intercept) {    myself.target <- self;   }  }  reflex follow when:target!=nil {   speed <- 0.8;   do goto target:target;  }  aspect default {   draw circle(1) color:#red;   if (target!=nil) {    draw polyline([self.location,target.location]) color:#black;   }  } }  experiment my_experiment type:gui {  output{   display myDisplay {    species speciesA aspect:default;    species speciesB aspect:default;   }  } }     //: # (endConcept|attaching_skills) ","url":"wiki/AttachingSkills.md"},{"id":"wiki/DefiningActionsAndBehaviors.md","title":" Defining actions and behaviors","content":"# Defining actions and behaviors //: # (keyword|concept_behavior)  Both actions and behaviors can be seen as methods in OOP. They can be defined in any species.  Index     Action  Declare an action       Call an action Behavior   Example   Action  Declare an action  An action is a function run by an instance of species. An action can return a value (in that case, the type of return has to be specify just before the name of the action), or not (in that case, you just have to put the keyword action before the name of the action).   species my_species {  int action_with_return_value {   // statements...   return 1;  }  action action_without_return_value {   // statements...  } }   Arguments can also be mandated in your action. You have to specify the type and the name of the argument:   action action_without_return_value (int argA, float argB) {  // statements... }   If you want to have some optional arguments in the list, you can give some by default values to turn them optional. Nb: it is better to define the optional arguments at the end of the list of argument.   action my_action (int argA, float argB <- 5.1, point argC <- {0,0}) {  // statements... }   Call an action  To call an action, you have to use the statement do. You can use the statement do different ways:     With facets : after specifying the name of your action, you can specify the values of your arguments as if the name of your arguments were facets:    do my_action argA:5 argB:5.1;      With parenthesis : after specifying the name of your action, you can specify the values of your arguments in the same order they were declared, between parenthesis:    do my_action (5,5.1);   We incite you to promote the second writing. To catch the returned value, you can also skip the do statement, and store the value directly in a temporary variable:   int var1 <- my_action(5,5.1);   Behavior  A behavior, or reflex, is an action which is called automatically at each time step by an agent.   reflex my_reflex {  write (Executing the inconditional reflex); // statements... }   With the facet when, this reflex is only executed when the boolean expression evaluates to true. It is a convenient way to specify the behavior of agents.   reflex my_reflex when:flip(0.5) {  write (Executing the conditional reflex); // statements... }   Reflex, unlike actions, cannot be called from another context. But a reflex can, of course, call actions.  Nb : Init is a special reflex, that occurs only when the agent is created.  Example  To practice a bit with those notions, we will build an easy example. Let s build a model with a species balloon that has 2 attributes: balloon_size (float) and balloon_color (rgb). Each balloon has a random position and color, his aspect is a sphere. Each step, a balloon has a probability to spawn in the environment. Once a balloon is created, its size is 10cm, and each step, the size increases by 1cm. Once the balloon size reaches 50cm, the balloon has a probability to burst. Once 10 balloons are destroyed, the simulation stops. The volume of each balloon is displayed in the balloon position.    Here is one of the multiple possible implementation:      model burst_the_baloon  global{  float worldDimension <- 5#m;  geometry shape <- square(worldDimension);  int nbBaloonDead <- 0;  reflex buildBaloon when:(flip(0.1)) {  create species:balloon number:1; }  reflex endSimulation when:nbBaloonDead>10 {  do halt; } }   species balloon {  float balloon_size;  rgb balloon_color;  init {   balloon_size <- 0.1;   balloon_color <- rgb(rnd(255),rnd(255),rnd(255));  }  reflex balloon_grow {  balloon_size <- balloon_size + 0.01;  if (balloon_size > 0.5) {   if (flip(0.2)) {    do balloon_burst;   }  } }  float balloon_volume (float diameter) {  float exact_value <- 2/3*#pi*diameter^3;  float round_value <- (round(exact_value*1000))/1000;  return round_value; }  action balloon_burst {  write the baloon is dead !;  nbBaloonDead <- nbBaloonDead + 1;  do die; }  aspect balloon_aspect {  draw circle(balloon_size) color:balloon_color;  draw text:string(balloon_volume(balloon_size)) color:#black; } }   experiment my_experiment type:gui {  output{   display myDisplay {    species balloon aspect:balloon_aspect;   }  } }     //: # (endConcept|actions_and_behaviors) ","url":"wiki/DefiningActionsAndBehaviors.md"},{"id":"wiki/GlobalSpecies.md","title":" The global species","content":"# The global species //: # (keyword|concept_global)  We will start this chapter by studying a special species: the global species.  In the global species you can define the attributes, actions and behaviors that describe the world agent. There is one unique world agent per simulation: it is this agent that is created when a user runs an experiment and that initializes the simulation through its init scope. The global species is a species like other and can be manipulated as them. In addition, the global species automatically inherits from several of built-in variables and actions. Note that a specificity of the global species is that all its attributes can be referred by all agents of the simulation.  Index     Declaration   Environment Size   Built-in Attributes   Built-in Actions   The init statement   Declaration  A GAMA model contains a unique global section that defines the global species.   global {  // definition of global attributes, actions, behaviours }   global can use facets, such as the torus facet, to make the environment a torus or not (if it is a torus, all the agents going out of the environment will appear in the other side. If it s not, the agents won t be able to go out of the environment). By default, the environment is not a torus.     global torus:true {  // definition of global attributes, actions, behaviours }   Other facets such as control or schedules are also available, but we will explain them later.  Directly in the global scope, you have to declare all your global attributes (can be seen as  static members  in Java or C++). To declare them, proceed exactly as for declaring basic variables. Those attributes are accessible wherever you want inside the species scope.  Environment size  In the global context, you have to define a size and a shape for your environment. In fact, an attribute already exists for the global species: it s called shape, and its type is a geometry. By default, shape is equal to a 100m*100m square. You can change the geometry of the shape by affecting another value:   geometry shape <- circle(50#mm); geometry shape <- rectangle(10#m,20#m); geometry shape <- polygon([{1°m,2°m},{3°m,50°cm},{3.4°m,60°dm}]);   nb: there are just examples. Try to avoid mixing dimensions! If no dimensions are specify, it ll be meter by default.  Built-in attributes  Some attributes exist by default for the global species. The attribute shape is one of them (refers to the shape of the environment). Here is the list of the other built-in attributes:  Like the other attributes of the global species, global built-in attributes can be accessed (and sometimes modified) by the world agent and every other agents in the model.  world    represents the sole instance of the model species (i.e. the one defined in the global section). It is accessible from everywhere (including experiments) and gives access to built-in or user-defined global attributes and actions.   ### cycle * integer, read-only, designates the (integer) number of executions of the simulation cycles. Note that the first cycle is the cycle with number 0.  To learn more about time, please read the recipe about dates.  step    float,  is the length, in model time, of an interval between two cycles, in seconds. Its default value is 1 (second). Each turn, the value of time is incremented by the value of step. The definition of step must be coherent with that of the agents  variables like speed. The use of time unit is particularly relevant for its definition.   To learn more about time, please read the recipe about dates.   global { ...     float step <- 10°h; ... }   ### time * float, read-only, represents the current simulated time in seconds (the default unit). It is time in the model time. Begins at zero. Basically, we have:   time = cycle * step  .   global { ...     int nb_minutes function: { int(time / 60)}; ... }   To learn more about time, please read the recipe about dates.  duration    string, read-only, represents the value that is equal to the duration in real machine time of the last cycle.   total_duration    string, read-only, represents the sum of duration since the beginning of the simulation.   average_duration    string, read-only, represents the average of duration since the beginning of the simulation.   ### machine_time * float, read-only, represents the current machine time in milliseconds.  agents    list, read-only, returns a list of all the agents of the model that are considered as  active  (i.e. all the agents with behaviors, excluding the places). Note that obtaining this list can be quite time consuming, as the world has to go through all the species and get their agents before assembling the result. For instance, instead of writing something like:    ask agents of_species my_species { ... }   one would prefer to write (which is much faster):   ask my_species { ... }  Note that any agent has the agents attribute, representing the agents it contains. So to get all the agents of the simulation, we need to access the agents of the world using: world.agents.  ## Built-in Actions The global species is provided with two specific actions.  ### halt * stops the simulation.   global {      ...      reflex halting when: empty (agents) {   do halt;      } }   ### pause * pauses the simulation, which can then be continued by the user.   global {      ...      reflex toto when: time = 100 {   do pause;      } }   ## The init statement  After declaring all the global attributes and defining your environment size, you can define an initial state (before launching the simulation). Here, you normally initialize your global variables, and you instantiate your species. We will see in the next session how to initialize a regular species.  //: # (endConcept|global_species) ","url":"wiki/GlobalSpecies.md"},{"id":"wiki/Inheritance.md","title":" Inheritance","content":"# Inheritance  As for multiple programming language, inheritance can be used in GAML. It is used to structure better your code, when you have some complex models.  Index     Mother species / child species   Virtual actions   Get all the subspecies from a species   Mother species / child species  To make a species inherit from a mother species, you have to add the facet parent, and specify the mother species.      species mother_species { }  species child_species parent:mother_species { }      Thus, all the attributes, actions and reflex of the mother species are inherited to the child species.      species mother_species {  int attribute_A;  action action_A {} }  species child_species parent:mother_species {  init {   attribute_A <- 5;   do action_A;  } }      If the mother species has a particular skill, its children will inherit all the attributes and actions.      species mother_species skills:[moving] { }  species child_species parent:mother_species {  init {   speed <- 2.0;  }  reflex update {   do wander;  } }      You can redefine an action or a reflex by declaring an action or a reflex with the same name.  Virtual action  You have also the possibility to declare a virtual action in the mother species, which means an action without implementation, by using the facet virtual:   action virtual_action virtual:true;   When you declare an action as virtual in a species, this species becomes abstract, which means you cannot instantiate agent from it. All the children of this species has to implement this virtual action.      species virtual_mother_species {  action my_action virtual:true; }  species child_species parent:virtual_mother_species {  action my_action {   // some statements  } }      Get all the subspecies from a species  If you declare a  mother  species, you create a  child  agent, then  mother  will return the population of agents  mother  and not the population of agents  child , as it is shown in the following example :      global {     init {  create child number:2;  create mother number:1;     }     reflex update {  write length(mother); // will write 1 and not 3     } }  species mother {}  species child parent:mother {}      We reminds you that  subspecies  is a built-in attribute of the agent. Using this attribute, you can easily get all the subspecies agents of the mother species by writing the following gaml function :      global {     init {  create child number:2;  create mother number:1;     }     reflex update {  write length(get_all_instances(mother)); // will write 3 (1+2)     }     list get_all_instances(species spec) {  return spec.population +  spec.subspecies accumulate (get_all_instances(each));     } }  species mother {}  species child parent:mother {}     //: # (endConcept|inheritance) ","url":"wiki/Inheritance.md"},{"id":"wiki/InteractionBetweenAgents.md","title":" Interaction between agents","content":"# Interaction between agents  In this part, we will learn how interaction between agents works. We will also present you a bunch of operators useful for your modelling.  Index     The ask statement   Pseudo variables   Some useful interaction operators   Example   The ask statement  The ask statement can be used in any reflex or action scope. It is used to specify the interaction between the instances of your species and the other agents. You only have to specify the species of the agents you want to interact with. Here are the different ways of calling the ask statement:     If you want to interact with one particular agent (for example, defined as an attribute of your species):    species my_species {  agent target;  reflex update {   ask target {    // statements   }  } }      If you want to interact with a group of agents:    species my_species {  list<agent> targets;  reflex update {   ask targets {    // statements   }  } }      If you want to interact with agents, as if they were instance of a certain species (can raise an error if it s not the case!):    species my_species {  list<agent> targets;  reflex update {   ask targets as:my_species {    // statements   }  } }      If you want to interact with all the agent of a species:       species my_species {  list targets;  reflex update {   ask other_species {    // statements   }  } }  species other_species { }      Note that you can use the attribute population of species if you find it more explicit:   ask other_species.population      If you want to interact with all the agent of a particular species from a list of agents (for example, using the global variable  agents ):    species my_specie {  reflex update {   ask species of_species my_specie {    // statements   }  } }   Pseudo variables  Once you are in the ask scope, you can use some pseudo variables to refer to the receiver agent (the one specify just after the ask statement) or the transmitter agent (the agent which is asking).  We use the pseudo variable self to refer to the receiver agent, and the pseudo variable myself to refer to the transmitter agent. The pseudo variable self can be omitted when calling actions or attributes.      species speciesA {  init {   name <-  speciesA ;  }  reflex update {   ask speciesB { write name; // output :  speciesB     write self.name; // output :  speciesB     write myself.name; // output :  speciesA    }  } }  species speciesB {  init {   name <-  speciesB ;  } }      Now, if we introduce a third species, we can write an ask statement inside another.      species speciesA {  init {   name <-  speciesA ;  }  reflex update {   ask speciesB {    write self.name; // output :  speciesB     write myself.name; // output :  speciesA     ask speciesC {     write self.name; // output :  speciesC      write myself.name; // output :  speciesB     }   }  } }  species speciesB {  init {   name <-  speciesB ;  } }  species speciesC {  init {   name <-  speciesC ;  } }      Nb: try to avoid multiple imbrications of ask statements. Most of the time, there is another way to do the same thing.  Some useful interaction operators  The operator at_distance can be used to know the list of agents that are in a certain distance from another agent.   species my_species {  reflex update {   list<agent> neighbours <- agents at_distance(5);   // neighbours contains the list of all the agents located at a distance <= 5 from the caller agent.  } }   The operator closest_to returns the closest agent of a position among a container.      species my_species {  reflex update {   agent agentA <- agents closest_to(self);   // agentA contains the closest agent from the caller agent.   agent agentB <- other_specie closest_to({2,3});   // agentB contains the closest instance of other_specie from the location {2,3}.  } }  species other_specie { }      Example  To practice those notions, here is a short basic example. Let s build a model with a fix number of agents with a circle shape. They can move randomly on the environment, and when they are close enough from another agent, a line is displayed between them. This line is destroyed when the distance between the two agents is too important. Hint: use the operator polyline to construct a line. List the points between angle brackets [].    Here is one example of implementation:      model connect_the_neighbours  global{  float speed <- 0.2;  float distance_to_intercept <- 10.0;  int number_of_circle <- 100;  init {   create my_species number:number_of_circle;  } }  species my_species {  reflex move {   location <- {location.x+rnd(-speed,speed),location.y+rnd(-speed,speed)};  }  aspect default {   draw circle(1);   ask my_species at_distance(distance_to_intercept) {    draw polyline([self.location,myself.location]) color:#black;   }  } }  experiment my_experiment type:gui {  output{   display myDisplay {    species my_species aspect:default;   }  } }     //: # (endConcept|interaction_between_agents) ","url":"wiki/InteractionBetweenAgents.md"},{"id":"wiki/RegularSpecies.md","title":" Regular species","content":"# Regular species  Regular species are composed of attributes, actions, reflex, aspect etc… They describes the behavior of our agents. You can instantiate as much as you want agents from a regular species, and you can define as much as you want different regular species. You can see a species as a  class  in OOP.  Index     Declaration   Built-in Attributes   Built-in Actions   The init statement   The aspect statement   Instantiate an agent   Declaration  The regular species declaration starts with the keyword species followed by the name (or followed by the facet name:) :   species my_specie { }   or:   species name:my_specie { }   Directly in the  species  scope, you have to declare all your attributes (or  member  in OOP). You declare them exactly the way you declare basic variables. Those attributes are accessible wherever you want inside the species scope.   species my_specie {  int variableA; }   Built-in attributes  As for the global species, some attributes exist already by default in a regular species. Here is the list of built-in attributes:     name (type: string) is used to name your agent. By default, the name is equal to the name of your species + an incremental number. This name is the one visible on the species inspector.   location (type: point) is used to control the position of your agent. It refers to the center of the envelop of the shape associated to the agent.   shape (type: geometry) is used to describe the geometry of your agent. If you want to use some intersection operator between agents for instance, it is this geometry that is computed (nb : it can be totally different from the aspect you want to display for your agent !). By default, the shape is a point.   host (type: agent) is used when your agent is part of another agent. We will see this concept a bit further, in the topic multi-level architecture.   All those 4 built-in attributes can be accessed in both reading and writing very easily:   species my_species {  init {   name <- custom_name;   location <- {0,1};   shape <- rectangle(5,1);  } }   All those built-in attributes are attributes of an agent (an instance of a species). Species has also their own attributes, which can be accessed with the following syntax (read only) :   name_of_your_species.attribute_you_want   Notice that the world agent is also an agent ! It has all the built-in attributes declared above. The world agent is defined inside the global scope. From the global scope then, you can for example access to the center of the envelop of the world shape :   global {     init {      write location; // writes {50.0,50.0,0.0}     } }   Here is the list of those attributes:     name (type: string) returns the name of your species   attributes (type: list of string) returns the list of the names of the attributes of your species   population (type: list) returns the list of agent that belong to it   subspecies (type: list of string) returns the list of species that inherit directly from this species (we will talk about the concept of inheritance later)   parent (type: species) returns its parent species if it belongs to the model, or nil otherwise (we will talk about the concept of inheritance later)   ## Built-in action  Some actions are define by default for a minimal agent. We already saw quickly the action write, used to display a message in the console. Another very useful built-in action is the action die, used to destroy an agent.   species my_species{     reflex being_killed {  do die;     } }   Here is the list of the other built-in actions which you can find in the documentation: debug, message, tell.  ## The init statement  After declaring all the attributes of your species, you can define an initial state (before launching the simulation). It can be seen as the  constructor of the class  in OOP.   species my_species {  int variableA;  init {   variableA <- 5;  } }   ## The aspect statement  Inside each species, you can define one or several aspects. This scope allows you to define how you want your species to be represented in the simulation. Each aspect has a special name (so that they can be called from the experiment). Once again, you can name your aspect by using the facet name:, or simply by naming it just after the aspect keyword.   species my_species {  aspect standard_aspect { // or aspect name:standard_aspect  } }   You can then define your aspect by using the statement draw. You can then choose a geometry for your aspect (facet geometry), a color (facet color), an image (facet image), a text (facet text)… We invite you to read the documentation about the draw statement to know more about.   species name:my_species {  aspect name:standard_aspect {   draw geometry:circle(1) color:#blue;  } }   In the experiment scope, you have to tell the program to display a particular species with a particular aspect (nb : you can also choose to display your species with several aspect in the same display).   experiment my_experiment type:gui {  output{   display my_display {    species my_species aspect:standard_aspect;   }  } }   Now there is only one thing missing to display our agent: we have to instantiate them.  Instantiate an agent  As already said quickly in the last session, the instantiation of the agents is most often in the init scope of the global species (this is not mandatory of course. You can instantiate your agents from an action / behavior of any specie). Use the statement create to instantiate an agent.  The facet species is used to specify which species you want to instantiate.  The facet number is used to tell how many instantiation you want.  The facet with is used to specify some default values for some attributes of your instance. For example, you can specify the location.      global{  init{   create species:my_species number:1 with:(location:{0,0},vA:8);  } }  species name:my_specie {  int vA; }      Here is an example of model that display an agent with a circle aspect in the center of the environment:      model display_one_agent  global{  float worldDimension <- 50#m;  geometry shape <- square(worldDimension);  init{   point center <- {(worldDimension/2),(worldDimension/2)};   create species:my_species number:1 with:(location:center);  } }  species name:my_species {  aspect name:standard_aspect {   draw geometry:circle(1#m);  } }  experiment my_experiment type:gui {  output{   display myDisplay {    species my_species aspect:standard_aspect;   }  } }     //: # (endConcept|regular_species) ","url":"wiki/RegularSpecies.md"},{"id":"wiki/ControlArchitecture.md","title":" Control Architectures","content":"# Control Architectures  GAMA allows to attach built-in control architecture to agents.  These control architectures will give the possibility to the modeler to use for a species a specific control architecture in addition to the common behavior structure. Note that only one control architecture can be used per species.  The attachment of a control architecture to a species is done through the facets control.  For example, the given code allows to attach the fsm control architecture to the dummy species.  species dummy control: fsm { }   GAMA integrates several agent control architectures that can be used in addition to the common behavior structure:     fsm: finite state machine based behavior model. During its life cycle, the agent can be in several states. At any given time step, it is in one single state. Such an agent needs to have one initial state (the state in which it will be at its initialization)   weighted_tasks: task-based control architecture. At any given time, only the task only the task with the maximal weight is executed.   sorted_tasks: task-based control architecture. At any given time, the tasks are all executed in the order specified by their weights (highest first).   probabilistic_tasks: task-based control architecture. This architecture uses the weights as a support for making a weighted probabilistic choice among the different tasks. If all tasks have the same weight, one is randomly chosen at each step.   user_only: allows users to take control over an agent during the course of the simulation. With this architecture, only the user control the agents (no reflexes).   user_first: allows users to take control over an agent during the course of the simulation. With this architecture, the user actions are executed before the agent reflexes.   user_last: allows users to take control over an agent during the course of the simulation. With this architecture, the user actions are executed after the agent reflexes.   Index     Finite State Machine  Declaration       State Task Based  Declaration       Task User Control Architecture  user_only, user_first, user_last       user_panel       user_controlled Other Control Architectures   ## Finite State Machine  FSM (Finite State Machine) is a finite state machine based behavior model. During its life cycle, the agent can be in several states. At any given time step, it is in one single state. Such an agent needs to have one initial state (the state in which it will be at its initialization).  At each time step, the agent will:     first (only if he just entered in its current state) execute statement embedded in the enter statement,   then all the statements in the state statement   it will evaluate the condition of each embedded transition statements. If one condition is fulfilled, the agent execute the embedded statements   Note that an agent executes only one state at each step.  Declaration  Using the FSM architecture for a species require to use the control facet:   species dummy control: fsm {    ... }   State  Attributes    initial: a boolean expression, indicates the initial state of agent.   final: a boolean expression, indicates the final state of agent.   Sub Statements    enter: a sequence of statements to execute upon entering the state.   exit: a sequence of statements to execute right before exiting the state. Note that the exit statement will be executed even if the fired transition points to the same state (the FSM architecture in GAMA does not implement  internal transitions  like the ones found in UML state charts: all transitions, even  self-transitions , follow the same rules).   transition: allows to define a condition that, when evaluated to true, will designate the next state of the life cycle. Note that the evaluation of transitions is short-circuited: the first one that evaluates to true, in the order in which they have been defined, will be followed. I.e., if two transitions evaluate to true during the same time step, only the first one will be triggered.   Things worth to be mentioned regarding these sub-statements:     Obviously, only one definition of exit and enter is accepted in a given state   Transition statements written in the middle of the state statements will only be evaluated at the end, so, even if it evaluates to true, the remaining of the statements found after the definition of the transition will be nevertheless executed. So, despite the appearance, a transition written somewhere in the sequence will  not stop  the state at that point (but only at the end).   Definition A state can contain several statements that will be executed, at each time step, by the agent. There are three exceptions to this rule:     statements enclosed in enter will only be executed when the state is entered (after a transition, or because it is the initial state).   Those enclosed in exit will be executed when leaving the state as a result of a successful transition (and before the statements enclosed in the transition).   Those enclosed in a transition will be executed when performing this transition (but after the exit sequence has been executed).   For example, consider the following example:      species dummy control: fsm {       state state1 initial: true {    write string(cycle) +  :  + name +  ->  +  state1 ;   transition to: state2 when: flip(0.5) {    write string(cycle) +  :  + name +  ->  +  transition to state1 ;   }   transition to: state3 when: flip(0.2) ;   }  state state2 {  write string(cycle) + : + name + -> + state2;  transition to: state1 when: flip(0.5) {    write string(cycle) + : + name + -> + transition to state1;  }  exit {   write string(cycle) + : + name + -> + leave state2;  } }  state state3 {  write string(cycle) + : + name + -> + state3;  transition to: state1 when: flip(0.5)  {   write string(cycle) + : + name + -> + transition to state1;  }  transition to: state2 when: flip(0.2)  ; }    }       the dummy agents start at state1. At each simulation step they have a probability of 0.5 to change their state to state2. If they do not change their state to state2, they have a probability of 0.2 to change their state to state3. In state2, at each simulation step, they have a probability of 0.5 to change their state to state1. At last, in step3, at each simulation step they have a probability of 0.5 to change their state to state1. If they do not change their state to state1, they have a probability of 0.2 to change their state to state2.  Here a possible result that can be obtained with one dummy agent:   0:dummy0->state1 0:dummy0->transition to state1 1:dummy0->state2 2:dummy0->state2 2:dummy0->leave state2 2:dummy0->transition to state1 3:dummy0->state1 3:dummy0->transition to state1 4:dummy0->state2 5:dummy0->state2 5:dummy0->leave state2 5:dummy0->transition to state1 6:dummy0->state1 7:dummy0->state3 8:dummy0->state2  //: # (endConcept|finite_state_machine)  ## Task Based  GAMA integrated several task-based control architectures. Species can define any number of tasks within their body. At any given time, only one or several tasks are executed according to the architecture chosen:     weighted_tasks : in this architecture, only the task with the maximal weight is executed.   sorted_tasks : in this architecture, the tasks are all executed in the order specified by their weights (biggest first)   probabilistic_tasks: this architecture uses the weights as a support for making a weighted probabilistic choice among the different tasks. If all tasks have the same weight, one is randomly chosen each step.   Declaration  Using the Task architectures for a species require to use the control facet:   species dummy control: weighted_tasks {    ... }    species dummy control: sorted_tasks {    ... }    species dummy control: probabilistic_tasks {    ... }   Task  Sub elements Besides a sequence of statements like reflex, a task contains the following sub elements:   * weight: Mandatory. The priority level of the task.  Definition As reflex, a task is a sequence of statements that can be executed, at each time step, by the agent. If an agent owns several tasks, the scheduler chooses a task to execute based on its current priority weight value.  For example, consider the following example:  species dummy control: weighted_tasks {     task task1 weight: cycle mod 3 {    write string(cycle) + : + name + -> + task1;  }  task task2 weight: 2 {    write string(cycle) + : + name + -> + task2;  } }   As the weighted_tasks control architecture was chosen, at each simulation step, the dummy agents execute only the task with the highest behavior. Thus,  when cycle modulo 3 is higher to 2, task1 is executed; when cycle modulo 3 is lower than 2, task2 is executed. In case when cycle modulo 3 is equal 2 (at cycle 2, 5, …), the only the first task defined (here task1) is executed.  Here the result obtained with one dummy agent:  0:dummy0->task2 1:dummy0->task2 2:dummy0->task1 3:dummy0->task2 4:dummy0->task2 5:dummy0->task1 6:dummy0->task2  //: # (endConcept|task_based)  ## User Control Architecture  user_only, user_first, user_last  A specific type of control architecture has been introduced to allow users to take control over an agent during the course of the simulation. It can be invoked using three different keywords: user_only, user_first, user_last.  species user control: user_only {    ... }   If the control chosen is user_first, it means that the user controlled panel is opened first, and then the agent has a chance to run its  own  behaviors (reflexes, essentially, or  init  in the case of a  user_init  panel). If the control chosen is user_last, it is the contrary.  user_panel  This control architecture is a specialization of the Finite State Machine Architecture where the  behaviors  of agents can be defined by using new constructs called user_panel (and one user_init), mixed with  states  or  reflexes . This user_panel translates, in the interface, in a semi-modal view that awaits the user to choose action buttons, change attributes of the controlled agent, etc. Each user_panel, like a state in FSM, can have a enter and exit sections, but it is only defined in terms of a set of user_commands which describe the different action buttons present in the panel.  user_commands can also accept inputs, in order to create more interesting commands for the user. This uses the user_input statement (and not operator), which is basically the same as a temporary variable declaration whose value is asked to the user. Example:  As user_panel is a specialization of state, the modeler has the possibility to describe several panels and choose the one to open depending on some condition, using the same syntax than for finite state machines :   * either adding transitions to the user_panels,   * or setting the state attribute to a new value, from inside or from another agent.  This ensures a great flexibility for the design of the user interface proposed to the user, as it can be adapted to the different stages of the simulation, etc…  Follows a simple example, where, every 10 steps, and depending on the value of an attribute called  advanced , either the basic or the advanced panel is proposed.      species user control:user_only {    user_panel default initial: true {       transition to:  Basic Control  when: every (10) and !advanced_user_control;       transition to:  Advanced Control  when: every(10) and advanced_user_control;    }  user_panel  Basic Control  {       user_command  Kill one cell  {   ask (one_of(cell)){   do die;   }       }       user_command  Create one cell  {  create cell ;       } transition to: default when: true;    }    user_panel  Advanced Control  {       user_command  Kill cells  {  user_input  Number  returns: number type: int <- 10;  ask (number among cell){  do die;  }       }       user_command  Create cells  {  user_input  Number  returns: number type: int <- 10;  create cell number: number ;       } transition to: default when: true;    } }      The panel marked with the  initial: true  facet will be the one run first when the agent is supposed to run. If none is marked, the first panel (in their definition order) is chosen.  A special panel called user_init will be invoked only once when initializing the agent if it is defined. If no panel is described or if all panels are empty (i.e. no user_commands), the control view is never invoked. If the control is said to be  user_only , the agent will then not run any of its behaviors.  user_controlled  Finally, each agent provided with this architecture inherits a boolean attribute called user_controlled. If this attribute becomes false, no panels will be displayed and the agent will run  normally  unless its species is defined with a user_only control. //: # (endConcept|user_control_architecture)  Other Control Architectures  Some other control architectures are available in additional plugins. For instance, BDI (Belief, desire, intention) architecture is available. Feel free to read about it if you want to learn more.  You need some other control architectures for your model ? Feel free to make your suggestion to the team of developer through the mailing list. Remember also that GAMA is an open-source platform, you can design your own control architecture easily. Go to the section Community/contribute if you want to jump into coding ! ","url":"wiki/ControlArchitecture.md"},{"id":"wiki/Equations.md","title":" Using Equations","content":"# Using Equations //: # (endConcept|concept_math)  Introduction  ODEs (Ordinary Differential Equations) are often used in ecology or in epidemiology to describe the macroscopic evolution over time of a population. Generally the whole population is split into several compartments. The state of the population is described by the number of individuals in each compartment. Each equation of the ODE system describes the evolution of the number of individual in a compartment. In such an approach individuals are not taken into account individually, with own features and behaviors. In contrary they are aggregated in a compartment and reduced to a number.  A classical example is the SIR epidemic model representing the spreading of a disease in a population. The population is split into 3 compartments: S (Susceptible), I (Infected), R (Recovered). (see below for the equation)  In general the ODE systems cannot be analytically solved, i.e. it is not possible to find the equation describing the evolution of the number of S, I or R. But these systems can be numerically integrated in order to get the evolution. A numerical integration computes step after step the value of S, I and R. Several integration methods exist (e.g. Euler, Runge-Kutta…), each of them being a compromise between accuracy and computation time. The length of the integration step has also a huge impact on precision. These models are deterministic.  This approach makes a lot of strong hypotheses. The model does not take into account space. The population is considered has infinite and homogeneously mixed, so that any agent can interact with any other one.  Example of a SIR model  In the SIR model, the population is split into 3 compartments: S (Susceptible), I (Infected), R (Recovered). This can be represented by the following Forrester diagram: boxes represent stocks (i.e. compartments) and arrows are flows. Arrows hold the rate of a compartment population flowing to another compartment.    The corresponding ODE system contains one equation per stock. For example, the I compartment evolution is influenced by an inner (so positive) flow from the S compartment and an outer (so negative) flow to the R compartment.    Integrating this system using the Runge-Kutta 4 method provides the evolution of S, I and R over time. The initial values are: * S = 499 * I = 1 * R = 0 * beta = 0.4 * gamma = 0.1  * h = 0.1    Why and when can we use ODE in agent-based models ?  These hypotheses are very strong and cannot be fulfilled in agent-based models.  But in some multi-scale models, some entities can be close. For example if we want to implement a model describing the worldwide epidemic spread and the impact of air traffic on it, we cannot simulate the 7 billions people. But we can represent only cities with airports and airplanes as agents. In this case, cities are entities with a population of millions inhabitants, that will not been spatially located. As we are only interested in the disease spread, we are only interested in the number of infected people in the cities (and susceptibles and recovered too). As a consequence, it appears particularly relevant to describe the evolution of the disease in the city using a ODE system.  In addition these models have the advantage to not be sensible to population size in the integration process. Dozens or billions people does not bring a computation time increase, contrarily to agent-based models.  Use of ODE in a GAML model  A stereotypical use of ODE in a GAMA agent-based model is to describe species where some agents attributes evolution is described using an ODE system.  As a consequence, the GAML language has been increased by two main concepts (as two statements): * equations can be written with the equation statement. An equation block is composed of a set of diff statement describing the evolution of species attributes. * an equation can be numerically integrated using the solve statement  equation ### Defining an ODE system Defining a new ODE system needs to define a new equation block in a species. As example, the following eqSI system describes the evolution of a population with 2 compartments (S and I) and the flow from S to I compartment:       species userSI {  float t ;  float I ;   float S ;   int N ;  float beta<-0.4 ;  float h ;  equation eqSI {  diff(S,t) = -beta * S * I / N ;  diff(I,t) = beta * S * I / N ; } }        This equation has to be defined in a species with   t  ,   S   and   I   attributes.   beta   (and other similar parameters) can be defined either in the specific species (if it is specific to each agents) or in the   global   if it is a constant.   Note: the t attribute will be automatically updated using the solve statement ; it contains the time elapsed in the equation integration.  Using a built-in ODE system In order to ease the use of very classical ODE system, some built-in systems have been implemented in GAMA. For example, the previous SI system can be written as follows. Three additional facets are used to define the system: * type: the identifier of the built-in system (here SI) (the list of all built-in systems are described below), * vars: this facet is expecting a list of variables of the species, that will be matched with the variables of the system, * params: this facet is expecting a list of variables of the species (of of the global), that will be matched with the parameters of the system.  equation eqBuiltInSI type: SI vars: [S,I,t] params: [N,beta] ;   Split a system into several agents  An equation system can be split into several species and each part of the system are synchronized using the simultaneously facet of equation. The system split into several agents can be integrated using a single call to the solve statement. Notice that all the equation definition must have the same name.  For example the SI system presented above can be defined in two different species S_agt (containing the equation defining the evolution of the S value) and I_agt (containing the equation defining the evolution of the I value). These two equations are linked using the simultaneously facet of the equation statement. This facet expects a set of agents. The integration is called only once in a simulation step, e.g. in the S_agt agent.     species S_agt {  float t ;    float Ssize ;  equation evol simultaneously: [ I_agt ] {  diff(Ssize, t) = (- sum(I_agt accumulate [each.beta * each.Isize]) * self.Ssize / N); }  reflex solving {solve evol method : rk4 step : hKR4 ;}  }   species I_agt {  float t ;  float Isize ; // number of infected   float beta ;  equation evol simultaneously : [ S_agt ] {  diff(Isize, t) = (beta * first(S_agt).Ssize * Isize / N); } }     The interest is that the modeler can create several agents for each compartment, which different values. For example in the SI model, the modeler can choose to create 1 agent  S_agt  and 2 agents  I_agt . The  beta  attribute will have different values in the two agents, in order to represent 2 different strains.       global {  int number_S <- 495 ; // The number of susceptible  int number_I <- 5   ; // The number of infected  int nb_I <- 2;  float gbeta  <- 0.3  ; // The parameter Beta  int N <- number_S + nb_I * number_I ; float hKR4 <- 0.1 ;  init {  create S_agt {   Ssize <- float(number_S) ;  }  create I_agt number: nb_I {   Isize <- float(number_I) ;   self.beta <- myself.gbeta + rnd(0.5) ;  } } }        The results are computed using the RK4 method with: * number_S = 495  * number_I = 5 * nb_I = 2 * gbeta = 0.3  * hKR4 = 0.1    solve an equation The solve statement has been added in order to integrate numerically the equation system. It should be add into a reflex. At each simulation step, a step of the integration is executed, the length of the integration step is defined in the step facet. The solve statement will update the variables used in the equation system. The chosen integration method (defined in method) is Runge-Kutta 4 (which is very often a good choice of integration method in terms of accuracy).  reflex solving {  solve eqSI method:rk4 step:h; }  With a smaller integration step, the integration will be faster but less accurate.  More details  Details about the solve statement  The solve statement can have a huge set of facets (see [S_Statements#solve] for more details). The basic use of the solve statement requiers only the equation identifier. By default, the integration method is Runge-Kutta 4 with an integration step of 1, which means that at each simulation step the equation integration is made over 1 unit of time (which is implicitly defined by the system parameter value).   solve eqSI ;   2 integration methods can be used:  * method: rk4 will use the Runge-Kutta 4 integration method * method: dp853 will use the Dorman-Prince 8(5,3) integration method. The advantage of this method compared to Runge-Kutta is that it has an evaluation of the error and can use it to adapt the integration step size.  In order to synchronize the simulation step and the equation integration step, 2 facets can be used: * step: number * cycle_length: number  cycle_length (int): length of simulation cycle which will be synchronize with step of integrator (default value: 1) step (float): integration step, use with most integrator methods (default value: 1)  time_final (float): target time for the integration (can be set to a value smaller than t0 for backward integration) time_initial (float): initial time discretizing_step (int): number of discret beside 2 step of simulation (default value: 0) integrated_times (list): time interval inside integration process integrated_values (list): list of variables s value inside integration process  Some facets are specific to the DP853 integration methods: max_step, min_step, scalAbsoluteTolerance and scalRelativeTolerance.  Example of the influence of the integration step  The step and cycle_length facets of the integration method may have a huge influence on the results. step has an impact on the result accuracy. In addition, it is possible to synchronize the step of the (agent-based) simulation and the (equation) integration step in various ways (depending on the modeler purpose) using the cycle_length facet: e.g. cycle_length: 10 means that 10 simulation steps are equivalent to 1 unit of time of the integration method.   solve SIR method: rk4 step: 1.0 cycle_length: 1.0 ;   solve SIR method: rk4 step: 0.1 cycle_length: 10.0 ;   solve SIR method: rk4 step: 0.01 cycle_length: 100.0 ; List of built-in ODE systems Several built-in equations have been defined. #### equation eqBuiltInSI type: SI vars: [S,I,t] params: [N,beta];  This system is equivalent to:  equation eqSI {  diff(S,t) = -beta * S * I / N ;  diff(I,t) = beta * S * I / N ; }       The results are provided using the Runge-Kutta 4 method using following initial values: * S = 499 * I = 1 * beta = 0.4 * h = 0.1    equation eqSIS type: SIS vars: [S,I,t] params: [N,beta,gamma];  This system is equivalent to:  equation eqSIS {  diff(S,t) = -beta * S * I / N + gamma * I;  diff(I,t) = beta * S * I / N - gamma * I; }      The results are provided using the Runge-Kutta 4 method using following initial values: * S = 499 * I = 1 * beta = 0.4 * gamma = 0.1  * h = 0.1    equation eqSIR type:SIR vars:[S,I,R,t] params:[N,beta,gamma] ;  This system is equivalent to:  equation eqSIR {  diff(S,t) = (- beta * S * I / N);  diff(I,t) = (beta * S * I / N) - (gamma * I);  diff(R,t) = (gamma * I); }       The results are provided using the Runge-Kutta 4 method using following initial values: * S = 499 * I = 1 * R = 0 * beta = 0.4 * gamma = 0.1  * h = 0.1    equation eqSIRS type: SIRS vars: [S,I,R,t] params: [N,beta,gamma,omega,mu] ;  This system is equivalent to:  equation eqSIRS {   diff(S,t) = mu * N + omega * R + - beta * S * I / N - mu * S ;   diff(I,t) = beta * S * I / N - gamma * I - mu * I ;   diff(R,t) = gamma * I - omega * R - mu * R ; }       The results are provided using the Runge-Kutta 4 method using following initial values: * S = 499 * I = 1 * R = 0 * beta = 0.4 * gamma = 0.01 * omega = 0.05 * mu = 0.01  * h = 0.1    equation eqSEIR type: SEIR vars: [S,E,I,R,t] params: [N,beta,gamma,sigma,mu] ;  This system is equivalent to:  equation eqSEIR {  diff(S,t) = mu * N - beta * S * I / N - mu * S ;  diff(E,t) = beta * S * I / N - mu * E - sigma * E ;  diff(I,t) = sigma * E - mu * I - gamma * I;  diff(R,t) = gamma * I - mu * R ; }       The results are provided using the Runge-Kutta 4 method using following initial values: * S = 499 * E = 0 * I = 1 * R = 0 * beta = 0.4 * gamma = 0.01 * sigma = 0.05 * mu = 0.01  * h = 0.1    equation eqLV type: LV vars: [x,y,t] params: [alpha,beta,delta,gamma] ;  This system is equivalent to:  equation eqLV {   diff(x,t) =   x * (alpha - beta * y);  diff(y,t) = - y * (delta - gamma * x); }      The results are provided using the Runge-Kutta 4 method using following initial values: * x = 2 * y = 2 * alpha = 0.8 * beta = 0.3 * gamma = 0.2 * delta = 0.85 * h = 0.1   //: # (endConcept|equation) ","url":"wiki/Equations.md"},{"id":"wiki/OptimizingModels.md","title":" Optimizing Models","content":"# Optimizing Models  This page aims at presenting some tips to optimize the memory footprint or the execution time of a model in GAMA.  Note:  since GAMA 1.6.1, some optimizations have become obsolete because they have been included in the compiler. They have, then, been removed from this page. For instance, writing  rgb(0,0,0)  is now compiled directly as  #black .  Table of contents     machine_time   Scheduling   Grid  Optimization Facets   use_regular_agents use_individual_shapes       Operators  List operators   first_with where / count   Spatial operators   container of agents in closest_to, at_distance, overlapping, inside Accelerate  with a first spatial filtering       Displays  shape       circle vs square / sphere vs cube       OpenGL refresh facets ## machine_time  In order to optimize a model, it is important to exactly know which part of the model take times. The simplest to do that is to use the machine_time built-in global variable that gives the current time in milliseconds. Then to compute the time taken by a statement, a possible way is to write:   float t <- machine_time; // here a block of instructions that you consider as critical // ... write duration of the last instructions:  + (machine_time - t);   ## Scheduling  If you have a species of agents that, once created, are not supposed to do anything more (i.e. no behavior, no reflex, their actions triggered by other agents, their attributes being simply read and written by other agents), such as a  data  grid, or agents representing a  background  (from a shape file, etc.), consider using the schedules: [] facet on the definition of their species. This trick allows to tell GAMA to not schedule any of these agents.   grid my_grid height: 100 width: 100 schedules: []  {       ... }   The schedules: facet is dynamically computed (even if the agents are not scheduled), so, if you happen to define agents that only need to be scheduled every x cycles, or depending on a condition, you can also write schedules: to implement this. For instance, the following species will see its instances scheduled every 10 steps and only if a certain condition is met:   species my_species schedules: (every 10) ? (condition ? my_species : []) : []  {      ... }   In the same way, modelers can use the frequency facet to define when the agents of a species are going to be activated. By setting this facet to 0, the agents are never activated.  species my_species frequency: 0 {      ... }   ## Grid  Optimization Facets In this section, we present some facets that allow to optimize the use of grid (in particular in terms of memories). Note that all these facet can be combined (see the Life model from the Models library).  use_regular_agents If false, then a special class of agents is used. This special class of agents used less memories but has some limitation: the agents cannot inherit from a  normal  species, they cannot have sub-populations, their name cannot be modified, etc.  grid cell width: 50 height: 50 use_regular_agents: false ;   use_individual_shapes If false, then only one geometry is used for all agents. This facet allows to gain a lot of memory, but should not be used if the geometries of the agents are often activated (for instance, by an aspect).   grid cell width: 50 height: 50 use_individual_shapes: false ;    Operators  List operators #### first_with It is sometimes necessary to randomly select an element of a list that verifies a certain condition. Many modelers use the one_of and the where operators to do this:  bug one_big_bug <- one_of (bug where (each.size > 10));  Whereas it is often more optimized to use the shuffle operator to shuffle the list, then the first_with operator to select the first element that verifies the condition:  bug one_big_bug <- shuffle(bug) first_with (each.size > 10);  //: # (keyword|operator_where) //: # (keyword|operator_count) #### where / count It is quite common to want to count the number of elements of a list or a container that verify a condition. The obvious to do it is :  int n <- length(my_container where (each.size > 10));  This will however create an intermediary list before counting it, and this operation can be time consuming if the number of elements is important. To alleviate this problem, GAMA includes an operator called count that will count the elements that verify the condition by iterating directly on the container (no useless list created) :  int n <- my_container count (each.size > 10);  ### Spatial operators //: # (keyword|operator_closest_to) //: # (keyword|operator_at_distance) //: # (keyword|operator_overlapping) //: # (keyword|operator_inside) #### container of agents in closest_to, at_distance, overlapping, inside Several spatial query operators (such as closest_to, at_distance, overlapping or inside) allow to restrict the agents being queried to a container of agents. For instance, one can write:  agent closest_agent <- a_container_containing_agents closest_to self;  This expression is formally equivalent to :  agent closest_agent <- a_container_containing_agent with_min_of (each distance_to self);  But it is much faster if your container is large, as it will query the agents using a spatial index (instead of browsing through the whole container). Note that in some cases, when you have a small number of agents, the first syntax will be faster. The same applies for the other operators.  Now consider a very common case: you need to restrict the agents being queried, not to a container, but to a species (which, actually, acts as a container in most cases). For instance, you want to know which predator is the closest to the current agent. If we apply the pattern above, we would write:  predator closest_predator <- predator with_min_of (each distance_to self);  or  predator closest_predator <- list(predator) closest_to self;   But these two operators can be painfully slow if your species has many instances (even in the second form). In that case, always prefer using directly the species as the left member:  predator closest_ predator <- predator closest_to self;  Not only is the syntax clearer, but the speed gain can be phenomenal because, in that case, the list of instances is not used (we just check if the agent is an instance of the left species).  However, what happens if one wants to query instances belonging to 2 or more species ? If we follow our reasoning, the immediate way to write it would be (if predator 1 and predator 2 are two species):  agent closest_agent <- (list(predator1) + list(predator2)) closest_to self;   or, more simply:  agent closest_agent <- (predator1 + predator2) closest_to self;  The first syntax suffers from the same problem than the previous syntax: GAMA has to browse through the list (created by the concatenation of the species populations) to filter agents. The solution, then, is again to use directly the species, as GAMA is clever enough to create a temporary  fake  population out of the concatenation of several species, which can be used exactly like a list of agents, but provides the advantages of a species population (no iteration made during filtering).  Accelerate closest_to with a first spatial filtering The closest_to operator can sometimes be slow if numerous agents are concerned by this query. If the modeler is just interested by a small subset of agents, it is possible to apply a first spatial filtering on the agent list by using the at_distance operator. For example, if the modeler wants first to do a spatial filtering of 10m:  agent closest_agent <- (predator1 at_distance 10) closest_to self;   To be sure to find an agent, the modeler can use a test statement:  agent closest_agent <- (predator1 at_distance 10) closest_to self; if (closest_agent = nil) {closest_agent  <- predator1 closest_to self;}   ## Displays  ### shape It is quite common to want to display an agent as a circle or a square. A common mistake is to mix up the shape to draw and the geometry of the agent in the model. If the modeler just wants to display a particular shape, he/she should not modify the agent geometry (which is a point by default), but just specify the shape to draw in the agent aspect.      species bug {      int size <- rnd(100);    aspect circle {       draw circle(2) color: °blue;   } }       ### circle vs square / sphere vs cube Note that in OpenGL and Java2D (the two rendering subsystems used in GAMA), creating and drawing a circle geometry is more time consuming than creating and drawing a square (or a rectangle). In the same way, drawing a sphere is more time consuming than drawing a cube. Hence, if you want to optimize your model displays and if the rendering does not explicitly need  rounded  agents, try to use squares/cubes rather than circles/spheres.  ### OpenGL refresh facets In OpenGL display, it is possible to specify that it is not necessary to refresh a layer with the facet refresh. If a species of agents is never modified in terms of visualization (location, shape or color), you can set refresh to false. Example:  display city_display_opengl type: opengl{      species building aspect: base refresh: false;      species road aspect: base refresh: false;      species people aspect: base; }  //: # (endConcept|optimizing_tips) ","url":"wiki/OptimizingModels.md"},{"id":"wiki/RuntimeConcepts.md","title":" Runtime Concepts","content":"# Runtime Concepts  When a model is being simulated, a number of algorithms are applied, for instance to determine the order in which to run the different agents, or the order in which the initialization of agents is performed, etc. This section details some of them, which can be important when building models and understanding how they will be effectively simulated.  Table of contents     Simulation initialization   Agents Creation   Agents Step   Schedule Agents   Simulation initialization Once the user launches an experiment, GAMA starts the initialization of the simulation. First it creates a world agent.  It initializes all its attributes with their init values. This includes its shape (that will be used as environment of the simulation).  If a species of type grid exists in the model, agents of species are created.  Finally the init statement is executed. It should include the creation of all the other agents of regular species of the simulation. After their creation and initialization, they are added in the list members the world (that contains all the micro-agent of the world).  ## Agents Creation Except grid agents, other agents are created using the create statement. It is used to allocate memory for each agent and to initialize all its attributes.  If no explicit initialization exists for an attribute, it will get the default value corresponding to its type.  The initialization of an attribute can be located at several places in the code; they are executed in the following order (which means that, if several ways are used, the attribute will finally have the value of the last applied one): * using the from: facet of the create statement; * in the embedded block of the create statement; * in the attribute declaration, using the init facet; * in the init block of the species.  ## Agents Step When an agent is asked to step, it means that it is expected to update its variables, run its behaviors and then step its micro-agents (if any).      step of agent agent_a     {  species_a <- agent_a.species  architecture_a <- species_a.architecture  ask architecture_a to step agent_a {    ask agent_a to update species_a.variables    ask agent_a to run architecture_a.behaviors  }      ask each micro-population mp of agent_a to step {  list<agent> sub-agents <- mp.compute_agents_to_schedule  ask each agent_b of sub-agents to step //... recursive call...     } }        Schedule Agents  The global scheduling of agents is then simply the application of this previous step to the experiment agent, keeping in mind that this agent has only one micro-population (of simulation agents, each instance of the model species), and that the simulation(s) inside this population contain(s), in turn, all the  regular  populations of agents of the model.  To influence this schedule, then, one possible way is to change the way populations compute their lists of agents to schedule, which can be done in a model by providing custom definitions to the  schedules:  facet of one or several species.  A practical application of this facet is to reduce simulation artifacts created by the default scheduling of populations, which is sequential (i.e. their agents are executed in turn in their order of creation). To enable a pseudo-parallel scheduling based on a random scheduling recomputed at each step, one has simply to define the corresponding species like in the following example:   species A schedules: shuffle(A) {...}   Moving further, it is possible to enable a completely random scheduling that will eliminate the sequential scheduling of populations:      global schedules: [world] + shuffle(A + B + C) {…}  species A schedules: [] {…} species B schedules: [] {…} species C schedules: [] {…}      It is important to (1) explicitly invoke the scheduling of the world (although it doesn t have to be the first); (2) suppress the population-based scheduling to avoid having agent being scheduled 2 times (one time in the custom definition, one time by their population).  Other schemes are possible. For instance, the following definition will completely suppress the default scheduling mechanism to replace it with a custom scheduler that will execute the world, then all agents of species A in a random way and then all agents of species B in their order of creation:      global schedules: [world] + shuffle(A) + B {…} // explicit scheduling in the world  species A schedules [];  species B schedules: [];       Complex conditions can be used to express which agents need to be scheduled each step. For instance, in the following definition, only agents of A that return true to a particular condition are scheduled:      species A schedules: A where each.can_be_scheduled() {  bool can_be_scheduled() {      ...      returns true_or_false; } }       Be aware that enabling a custom scheduling can potentially end up in non-functional simulations. For example, the following definitions will result in a simulation that will never be executed:      global schedules: [] {}; // the world is NEVER scheduled  species my_scheduler schedules: [world] ; // so its micro-species  my_scheduler  is NOT scheduled either.       and this one will result in an infinite loop (which will trigger a stack overflow at some point):      global {} // The world is normally scheduled…  species my_scheduler schedules: [world]; // … but schedules itself again as a consequence of scheduling the micro-species  my_scheduler      //: # (endConcept|runtime_and_schedulers) ","url":"wiki/RuntimeConcepts.md"},{"id":"wiki/BasicProgrammingConceptsInGAML.md","title":" Basic programming concepts in GAML","content":"# Basic programming concepts in GAML  In this part, we will focus on the very basic structures in GAML, such as how to declare a variable, how to use loops, or how to manipulate lists.  We will overfly quickly all those basic programming concepts, admitting that you already have some basics in coding.  Index     Variables  Basic types       The point type       A word about dimensions Declare variables using facet   Operators in GAMA  Logical operators       Comparison operators       Type casting operators       Other operators Conditional structures   Loop   Manipulate containers   Random values   Variables  Variables are declared very easily in GAML, starting with the keyword for the type, following by the name you want for your variable.  NB: The declaration has to be inside the global scope, or inside the species scope.   typeName myVariableName;   Basic types  All the  basic  types are present in GAML:int, float, string, bool. The operator for the affectation in GAML is <- (the operator = is used to test the equality).   int integerVariable <- 3; float floatVariable <- 2.5; string stringVariable <- test; // you can also write simple   : <-  test  bool booleanVariable <- true; // or false   To follow the behavior of variable, we can write their value in the console. Let s go back to our basic skeleton of a model, and let s create a reflex in the global scope (to be short, a reflex is a function that is executed in each step. We will come back to this concept later). The write function works very easily, simply writing down the keyword write and the name of the variable we want to be displayed.      model firstModel  global {  int integerVariable <- 3;  float floatVariable <- 2.5;  string stringVariable <-  test ; // you can also write simple   : <-  test   bool booleanVariable <- true; // or false  reflex writeDebug {   write integerVariable;   write floatVariable;   write stringVariable;   write booleanVariable;  } }  experiment myExperiment { }      The function write is overloaded for each type of variable (even for the more complex type, such as containers).  Note that before being initialized, a variable has the value nil.   reflex update {  string my_string;  write my_string; // this will write nil.  int my_int;  write my_int; // this will write 0, which is the default value for int. }   nil is also a literal you can use to initialize your variable (you can learn more about the concept of literal in this page).   reflex update {  string my_string <- a string;  my_string <- nil;  write my_string; // this will write nil.  int my_int <- 6;  my_int <- nil;  write my_int; // this will write 0, which is the default value for int. }   ### The point type  Another variable type you should know is the point variable. This type of variable is used to describe coordinates. It is in fact a complex variable, composed of two float variables (or three if you are working in 3D). To declare it, you have to use the curly bracket {:   point p <- {0.2,2.4};   The first field is related to the x value, and the second, to the y value. You can easily get this value as following:   point p <- {0.2,2.4}; write p.x; // the output will be 0.2 write p.y; // the output will be 2.4   You can t modify directly the value. But if you want, you can do a simple operation to get what you want:   point p <- {0.2,2.4}; p <- p + {0.0,1.0}; write p.y; // the output will be 3.4   ### A world about dimensions  When manipulating float values, you can specify the dimension of your value. Dimensions are preceded by # or ° (exactly the same).   float a <- 5°m; float b <- 4#cm; float c <- a + b; // c is equal to 5.0399999 (it s not equal to 5.04 because it is a float value, not as precise as int)   ## Declare variables using facet  Facets are used to describe the behavior of a variable during its declaration, by adding the keyword facet just after the variable name, followed by the value you want for the facet (or also just after the initial value).   type variableName <- initialValue facet1:valueForFacet1 facet2:valueForFacet2; // or: type variableName facet1:valueForFacet1 facet2:valueForFacet2; variableName <- initialValue;   You can use the facet update if you want to change the value of your variable. For example, to increment your integer variable each step, you can do as follow:   int integerVariable <- 3 min:0 max:10 update:integerVariable+1; // nb: the operator ++ doesn t exist in gaml.   You can use the facet min and max to constraint the value in a specific range of values:   int integerVariable <- 3 min:0 max:10 update:integerVariable+1; // the result will be 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - 10 - 10 - ...   The facet among can also be useful (that can be seen as an enum):   string fruits <- banana among:[pear,apple,banana];   ## Operators in GAMA  In GAML language, you can use a lot of different operators. They are all listed in this page, but here are the most useful ones:  - Mathematical operators  The basic arithmetical operators, such as +(add), -(substract), *(multiply), /(divide), ^(power) are used this way:  FirstOperand Operator SecondOperand –> ex: 5 * 3; // return 15  Some other operators, such as cos(cosinus), sin(sinus), tan(tangent), sqrt(square root), round(rounding) etc… are used this way:   Operator(Operand) --> ex: sqrt(49); // return 7   Logical operators  Logical operators such as and(and), or(inclusive or) are used the same way as basic arithmetical operators. The operator !(negation) has to be placed just before the operand. They return a boolean result.   FirstOperand Operator SecondOperand --> ex: true or false; // return true NegationOperator Operand --> ex: !(true or false); // return false   ### Comparison operators  The comparison operators !=(different than), <(smaller than), <=(smaller of equal), =(equal), >(bigger than), >=(bigger or equal) are used the same way as basic arithmetical operators:   FirstOperand Operator SecondOperand --> ex: 5 < 3; // return false   ### Type casting operators  You can cast an operand to a special type using casting operator:   Operator(Operand); --> ex: int(2.1); // return 2   Other operators  A lot of other operators exist in GAML. The standard way to use those operators is as followed:   Operator(FirstOperand,SecondOperand,...) --> ex: rnd(1,8);   Some others are used in a more intuitive way:   FirstOperand Operator SecondOperand --> ex: 2[6,4,5] contains(5);   ## Conditional structures  You can write if/else if/else in GAML:   if (integerVariable<0) {  write my value is negative !! The exact value is  + integerVariable; } else if (integerVariable>0) {  write my value is positive !! The exact value is  + integerVariable; } else if (integerVariable=0) {  write my value is equal to 0 !!; } else {  write hey... This is not possible, right ?; }   GAML also accepts ternary operator:   stringVariable <- (booleanVariable) ? booleanVariable = true : booleanVariable = false;   ## Loop  Loops in GAML are designed by the keyword loop. As for variables, a loop have multiple facet to determine its behavior:     The facet times, to repeat a fixed number of times a set of statements:    loop times: 2 { write helloWorld; }  // the output will be helloWorld - helloWorld      The facet while, to repeat a set of statements while a condition is true:    loop while: (true) { } // infinity loop      The facet from / to, to repeat a set of statements while an index iterates over a range of values with a fixed step of 1:    loop i from:0 to: 5 { // or loop name:i from:0 to:5 -> the name is also a facet  write i; } // the output will be 0 - 1 - 2 - 3 - 4 - 5      The facet from / to combine with the facet step to choose the step:    loop i from:0 to: 5 step: 2 {  write i; } // the output will be 0 - 2 - 4      The facet over to browse containers, as we will see in the next part.   Nb: you can interrupt a loop at any time by using the break statement.  ## Manipulate containers  We saw in the previous parts  simple  types of variable. You also have a multiple containers types, such as list, matrix, map, pair… In this section, we will only focus on the container list (you can learn the other by reading the section about datatypes).  How to declare a list?  To declare a list, you can either or not specify the type of the data of its elements:   list<int> listOfInt <- [5,4,9,8]; list listWithoutType <- [2,4.6,oij,[hoh,0.0]];   How to know the number of elements of a list?  To know the number of element of a list, you can use the operator length that returns the number of elements (note that this operator also works with strings).   int numberOfElements <- length([12,13]); // will return 2 int numberOfElements <- length([]); // will return 0 int numberOfElements <- length(stuff); // will return 5   There is an other operator, empty, that returns you a boolean telling you if the list is empty or not.   bool isEmpty <- empty([12,13]); // will return false bool isEmpty <- empty([]); // will return true bool isEmpty <- empty(stuff); // will return false   How to get an element from a list?  To get an element from a list by its index, you have to use the operator at (nb: it is indeed an operator, and not a facet, so no  :  after the keyword).   int theFirstElementOfTheList <- [5,4,9,8] at 0; // this will return 5 int theThirdElementOfTheList <- [5,4,9,8] at 2; // this will return 9   How to know the index of an element of a list?  You can know the index of the first occurrence of a value in a list using the operator index_of. You can know the index of the last occurrence of a value in a list using the operator last_index_of.   int result <- [4,2,3,4,5,4] last_index_of 4;  // result equals 5 int result <- [4,2,3,4,5,4] index_of 4;  // result equals 0   How to know if an element exists in a list?  You can use the operator contains (return a boolean):   bool result <- [{1,2}, {3,4}, {5,6}] contains {3,4};  // result equals true   How to insert/remove an element to/from a list?  For those operation, no operator are available, but you can use a statement instead. The statements add and put are used to insert/modify an element, while the statement remove is used to remove an element. Here are some example of how to use those 3 statements with the most common facets:   list<int> list_int <- [1,5,7,6,7]; remove from:list_int index:1; // remove the 2nd element of the list write list_int; // the output is : [1,7,6,7] remove item:7 from:list_int; // remove the 1st occurrence of 7 write list_int; // the output is : [1,6,7] add item:9 to: list_int at: 2; // add 9 in the 3rd position write list_int; // the output is : [1,6,9,7] add 0 to: list_int; // add 0 in the last position write list_int; // the output is : [1,6,9,7,0] put 3 in: list_int at: 0; // put 3 in the 1st position write list_int; // the output is : [3,6,9,7,0] put 2 in: list_int key: 2; // put 2 in the 3rd position write list_int; // the output is : [3,6,2,7,0]   How to add 2 lists?  You can add 2 lists by creating a third one and browsing the 2 first one, but you can do it much easily by using the operator + :   list<int> list_int1 <- [1,5,7,6,7]; list<int> list_int2 <- [6,9]; list<int> list_int_result <- list_int1 + list_int2;   How to browse a list?  You can use the facet over of a loop:   list<int> exampleOfList <- [4,2,3,4,5,4]; loop i over:exampleOfList {  write i; } // the output will be 4 - 2 - 3 - 4 - 5 - 4   How to filter a list?  If you want to get all the elements of a list that fulfill a particular condition, you need the operator where. In the condition, you can design all the element of a particular list by using the pseudo variable each as followed:   list<int> exampleOfList <- [4,2,3,4,5,4] where (each <= 3);  // the list is now [2,3]   Other useful operators for the manipulation of lists:  Here are some other operators which can be useful to manipulate lists: sort, sort_by, shuffle, reverse, collect, accumulate, among. Please read the GAML Reference if you want to know more about those operators.  ## Random values  When you will implement your model, you will have to manipulate some random values quite often.  To get a random value in a range of value, use the operator rnd. You can use this operator in many ways:   int var0 <- rnd (2);    // var0 equals 0, 1 or 2 float var1 <- rnd (1000) / 1000;    // var1 equals a float between 0 and 1 with a precision of 0.001 point var2 <- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}, 1);    // var2 equals a point with x = 2.0, y equal to 2.0, 3.0 or 4.0 and z between 0.0 and 10.0 every 1.0 float var3 <- rnd (2.0, 4.0, 0.5);  // var3 equals a float number between 2.0 and 4.0 every 0.5 float var4 <- rnd(3.4);     // var4 equals a random float between 0.0 and 3.4 int var5 <- rnd (2, 12, 4);     // var5 equals 2, 6 or 10 point var6 <- rnd ({2.5,3, 0.0});   // var6 equals {x,y} with x in [0.0,2.0], y in [0.0,3.0], z = 0.0 int var7 <- rnd (2, 4);     // var7 equals 2, 3 or 4 point var8 <- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0});   // var8 equals a point with x = 2.0, y between 2.0 and 4.0 and z between 0.0 and 10.0 float var9 <- rnd (2.0, 4.0);   // var9 equals a float number between 2.0 and 4.0   Use the operator flip if you want to pick a boolean value with a certain probability:   bool result <- flip(0.2); // result will have 20% of chance to be true   You can use randomness in list, by using the operator shuffle, or also by using the operator among to pick randomly one (or several) element of your list:   list TwoRandomValuesFromTheList <- 2 among [5,4,9,8]; // the list will be for example [5,9].   You can use probabilistic laws, using operators such as gauss, poisson, binomial, or truncated_gauss (we invite you to read the documentation for those operators).       //: # (endConcept       programming_basis)   ","url":"wiki/BasicProgrammingConceptsInGAML.md"},{"id":"wiki/ModelOrganization.md","title":" Organization of a model","content":"# Organization of a model  As already extensively detailed in the introduction page, defining a model in GAML amounts to defining a model species, which later allows to instantiate a model agent (aka a simulation), which may or may not contain micro-species, and which can be flanked by experiment plans in order to be simulated.  This conceptual structure is respected in the definition of model files, which follows a similar pattern:     Definition of the global species, preceded by a header, in order to represent the model species   Definition of the different micro-species (either nested inside the global species or at the same level)   Definition of the different experiment plans that target this model   Table of contents     Model Header (model species)   Species declarations   Experiment declarations   Basic skeleton of a model   ## Model Header (model species)  The header of a model file begins with the declaration of the name of the model. Contrarily to other statements, this declaration does not end with a semi-colon.  model name_of_the_model  The name of the model is not necessarily the same as the name of the file. It must conform to the general rule for naming species, i.e. be a valid identifier (beginning with a letter, containing only letters, digits and dashes). This name will be used for building the name of the model species, from which simulations will be instantiated. For instance, the following declaration:  model dummy  will internally create a species called dummy_model, child of the abstract species model, from which simulations (called dummy_model0, dummy_model1, etc.) will be instantiated.  This declaration is followed by optional import statements that indicate which other models this model is importing. Import statements do not end with a semi-colon.  Importing a model can take two forms. The first one, called inheritance import, is declared as follows:  import relative_path_to_a_model_file import relative_path_to_another_model_file  The second one, called usage import, is declared as follows:  import relative_path_to_a_model_file as model_identifier  When importing models using the first form, all the declarations of the model(s) imported will be merged with those of the current model (in the order with which the import statements are declared, i.e. the latest definitions of global attributes or behaviors superseding the previous ones). The second form is reserved for using models as micro-models of the current model. This possibility is still experimental in the current version of GAMA.  The last part of the header is the definition of the global species, which is the actual definition of the model species itself.  global {     // Definition of [global attributes](GlobalSpecies#declaration), [actions and behaviors](DefiningActionsAndBehaviors) }   Note that neither the imports nor the definition of global are mandatory. Only the model statement is.  Species declarations  The header is followed by the declaration of the different species of agents that populate the model.  The special species global is the world species. You will declare here all the global attributes/actions/behaviors. The global species does not have name, and is unique in your model.  global {     // definition of global attributes, actions, behaviors }  Regular species can be declared with the keyword species. You can declare several regular species, and they all have to be named.  species nameOfSpecies {  // definition of your [species attributes](RegularSpecies#declaration), [actions and behaviors](DefiningActionsAndBehaviors) }  Note that the possibility to define the species after the global definition is actually a convenience: these species are micro-species of the model species and, hence, could be perfectly defined as nested species of global. For instance:     global {     // definition of global attributes, actions, behaviors }  species A {…}  species B {…}  is completely equivalent to:  global {     // definition of global attributes, actions, behaviors  species A {...}  species B {...} }       Experiment declarations  Experiments are usually declared at the end of the file. They start with the keyword experiment. They contains the simulation parameters, and the definition of the output (such as displays, monitors or inspectors). You can declare as much experiments as you want.      experiment first_experiment {     // definition of parameters (intputs)  // definition of output output {...} }   experiment second_experiment {     // definition of parameters (inputs)  // definition of output }       Note that you have two types of experiments: A GUI experiment allows to display a graphical interface with input parameters and outputs. It is declared with the following structure :  experiment gui_experiment type:gui {  [...] }  A Batch experiment allows to execute numerous successive simulation runs (often used for model exploration). It is declared with the following structure :  experiment batch_experiment type:batch {  [...] }   Basic skeleton of a model  Here is the basic skeleton of a model :     model name_of_the_model  global {  // definition of global attributes, actions, behaviours }  species my_specie {  // definition of attributes, actions, behaviours }  experiment my_experiment /* + specify the type :  type:gui  or  type:batch  */ {  // here the definition of your experiment, with…  // … your inputs  output {   // … and your outputs  } }     Don t forget this structure ! This will be the basis for all the models you will create from now.       //: # (endConcept       model_structure)   ","url":"wiki/ModelOrganization.md"},{"id":"wiki/DefiningAdvancedSpecies.md","title":" Defining advanced species","content":"Defining advanced species  In the previous chapter, we saw how to declare and manipulate regular species and the global species (as a reminder, the instance of the global species is the world agent).  We will now see that GAMA provides you the possibility to declare some special species, such as grids or graphs, with their own built-in attributes and their own built-in actions. We will also see how to declare mirror species, which is a  copy  of a regular species, in order to give it an other representation. Finally, we will learn how to represent several agents through one unique agent, with multi-level architecture. ","url":"wiki/DefiningAdvancedSpecies.md"},{"id":"wiki/DefiningGUIExperiment.md","title":" Defining GUI Experiment","content":"# Defining GUI Experiment  When you execute your simulation, you will often need to display some information. For each simulation, you can define some inputs and outputs: * The inputs will be composed of parameters manipulated by the user for each simulation. * The outputs will be composed of displays, monitors or output files. They will be define inside the scope output.   experiment exp_name type: gui {    [input]    output {      [display statements]      [monitor statements]      [file statements]    } }   You can define two types of experiment (through the facet type): * gui experiments (the default type) are used to play an experiment, and interpret its outputs. * batch experiments are used to play an experiment several times (usually with other input values), used for model exploration. We will come back to this notion a bit further in the tutorial.  Inside experiment scope, you can access to some built-ins which can be useful, such as minimum_cycle_duration, to force the duration of one cycle.   experiment my_experiment type: gui {  float minimum_cycle_duration <- 2.0#minute; }   Other built-ins are available, to learn more about, go to the page experiment built-in.  In this part, we will focus on the gui experiments. We will start with learning how to define input parameters, then we will study the outputs, such as displays, monitors and inspectors, and export files. We will finish this part with how to define user commands. //: # (endConcept|gui_experiments) ","url":"wiki/DefiningGUIExperiment.md"},{"id":"wiki/ExploringModels.md","title":" Exploring Models","content":"# Exploring Models  We just learnt how to launch GUI Experiments from GAMA. A GUI Experiment will start with a particular set of input, compute several outputs, and will stop at the end (if asked).  In order to explore models (by automatically running the Experiment using several configurations to analyze the outputs), a first approach is to run several simulations from the same experiment, considering each simulation as an agent. A second approach, much more efficient for larger explorations, is to run an other type of experiment : the Batch Experiment.  We will start this part by learning how to run several simulations from the same experiment. Then, we will see how batch experiments work, and we will focus on how to use those batch experiments to explore models by using exploration methods. ","url":"wiki/ExploringModels.md"},{"id":"wiki/Introduction.md","title":" Introduction","content":"Introduction  GAML is an agent-oriented language dedicated to the definition of agent-based simulations. It takes its roots in object-oriented languages like Java or Smalltalk, but extends the object-oriented programming approach with powerful concepts (like skills, declarative definitions or agent migration) to allow for a better expressivity in models.  It is of course very close to agent_based modeling languages like, e.g., NetLogo, but, in addition to enriching the traditional representation of agents with modern computing notions like inheritance, type safety or multi-level agency, and providing the possibility to use different behavioral architectures for programming agents, GAML extends the agent-based paradigm to eliminate the boundaries between the domain of a model (which, in ABM, is represented with agents) and the experimental processes surrounding its simulations (which are usually not represented with agents), including, for example, visualization processes. This paper (Drogoul A., Vanbergue D., Meurisse T., Multi-Agent Based Simulation: Where are the Agents ?, Multi-Agent Based Simulation 3, pp. 1-15, LNCS, Springer-Verlag. 2003) was in particular foundational in the definition of the concepts on which GAMA (and GAML) are based today.  This orientation has several conceptual consequences among which at least two are of immediate practical interest for modelers: * Since simulations, or experiments, are represented by agents, GAMA is bound to support high-level model compositionality, i.e. the definition of models that can use other models as inner agents, leveraging multi-modeling or multi-paradigm modeling as particular cases of composition. * The visualization of models can be expressed by models of visualization, composed of agents entirely dedicated to visually represent other agents, allowing for a clear separation of concerns between a simulation and its representation and, hence, the possibility to play with multiple representations of the same model at once.  Table of contents     Key Concepts (Under construction)  Lexical semantics of GAML       Translation into a concrete syntax       Vocabulary correspondance with the object-oriented paradigm as in Java       Vocabulary correspondance with the agent-based paradigm as in NetLogo Lexical semantics of GAML The vocabulary of GAML is described in the following sentences, in which the meaning and relationships of the important words of the language (in bold face) are summarized.     The role of GAML is to support modelers in writing models, which are specifications of simulations that can be executed and controlled during experiments, themselves specified by experiment plans.   The agent-oriented modeling paradigm means that everything  active  (entities of a model, systems, processes, activities, like simulations and experiments) can be represented in GAML as an agent (which can be thought of as a computational component owning its own data and executing its own behavior, alone or in interaction with other agents).   Like in the object-oriented paradigm, where the notion of class is used to supply a specification for objects, agents in GAML are specified by their species, which provide them with a set of attributes (what they know), actions (what they can do), behaviors (what they actually do) and also specifies properties of their population, for instance its topology (how they are connected) or schedule (in which order and when they should execute).   Any species can be nested in another species (called its macro-species), in which case the populations of its instances will imperatively be hosted by an instance of this macro-species. A species can also inherit its properties from another species (called its parent species), creating a relationship similar to specialization in object-oriented design. In addition to this, species can be constructed in a compositional way with the notion of skills, bundles of attributes and actions that can be shared between different species and inherited by their children.   Given that all agents are specified by a species, simulations and experiments are then instances of two species which are, respectively, called model and experiment plan. Think of them as  specialized  categories of species.   The relationships between species, models and experiment plans are codified in the meta-model of GAML in the form of a framework composed of three abstract species respectively called agent (direct or indirect parent of all species), model (parent of all species that define a model) and experiment (parent of all species that define an experiment plan). In this meta-model, instances of the children of agent know the instance of the child of model in which they are hosted as their world, while the instance of experiment plan identifies the same agent as one of the simulations it is in charge of. The following diagram summarizes this framework:     Putting this all together, writing a model in GAML then consists in defining a species which inherits from model, in which other species, inheriting (directly or not) from agent and representing the entities that populate this model, will be nested, and which is itself nested in one or several experiment plans among which a user will be able to choose which experiment he/she wants to execute.    At the operational level, i.e. when running an experiment in GAMA,  Translation into a concrete syntax The concepts presented above are expressed in GAML using a syntax which bears resemblances with mainstream programming languages like Java, while reusing some structures from Smalltalk (namely, the syntax of facets or the infix notation of operators). While this syntax is fully described in the subsequent sections of the documentation, we summarize here the meaning of its most prominent structures and their correspondance (when it exists) with the ones used in Java and NetLogo.     A model is composed of a header, in which it can refer to other models, and a sequence of species and experiments declarations, in the form of special declarative statements of the language.   A statement can be either a declaration or a command. It is always composed of a keyword followed by an optional expression, followed by a sequence of facets, each of them composed of a keyword (terminated by a  : ) and an expression.   facets allow to pass arguments to statements. Their value is an expression of a given type. An expression can be a literary constant, the name of an attribute, variable or pseudo-variable, the name of a unit or constant of the language, or the application of an operator.   A type can be a primitive type, a species type or a parametric type (i.e. a composition of types).   Some statements can include sub-statements in a block (sequence of statements enclosed in curly brackets).   declarative statements support the definition of special constructs of the language: for instance, species (including global and experiment species), attributes, actions, behaviors, aspects, variables, parameters and outputs of experiments.   imperative statements that execute something or control the flow of execution of actions, behaviors and aspects are called commands.   A species declaration (global, species or grid keywords) can only include 6 types of declarative statements : attributes, actions, behaviors, aspects, equations and (nested) species. In addition, experiment species allow to declare parameters, outputs and batch methods.   Vocabulary correspondance with the object-oriented paradigm as in Java | GAML | Java | |:–|:–| | species | class | | micro-species | nested class | | parent species | superclass | | child species | subclass | | model | program | | experiment | (main) class | | agent | object | | attribute | member | | action | method | | behavior | collection of methods | | aspect | collection of methods, mixed with the behavior | | skill | interface (on steroids) | | statement | statement | | type | type | | parametric type | generics |  Vocabulary correspondance with the agent-based paradigm as in NetLogo | GAML | NetLogo | |:–|:–| | species | breed   | | micro-species | -       | | parent species | -       | | child species | - (only from  turtle ) | | model | model   | | experiment | observer | | agent | turtle/observer | | attribute |  breed -own | | action | global function applied only to one breed | | behavior | collection of global functions applied to one breed | | aspect | only one, mixed with the behavior | | skill | -       | | statement | primitive | | type | type    | | parametric type | -       | ","url":"wiki/Introduction.md"},{"id":"wiki/ManipulateBasicSpecies.md","title":" Manipulate basic species","content":"Manipulate basic species  In this chapter, we will learn how to manipulate some basic species. As you already know, a species can be seen as the definition of a type of agent (we call agent the instance of a species). In OOP (Object-Oriented Programming), a species can be seen as the class. Each species is then defined by some attributes ( member  in OOP), actions ( method  in OOP) and behavior ( method  in OOP).  In this section, we will first learn how to declare the world agent, using the global species. We will then learn how to declare regular species which will populate our world. The following lesson will be dedicated to learn how to define actions and behaviors for all those species. We will then learn how agents can interact between each other, especially with the statement ask. In the next chapter then, we will see how to attach skills to our species, giving them new attributes and actions. This section will be closed with a last lesson dealing with how inheritence works in GAML. ","url":"wiki/ManipulateBasicSpecies.md"},{"id":"wiki/MultiParadigmModeling.md","title":" Multi-Paradigm Modeling","content":"# Multi-Paradigm Modeling     Multi-paradigm modeling is a research field focused on how to define a model semantically. From the beginning of this step by step tutorial, our approach is based on behavior (or reflex), for each agents. In this part, we will see that GAMA provides other ways to implement your model, using several control architectures. Sometime, it will be easier to implement your models choosing other paradigms.  In a first part, we will see how to use some control architectures which already exist in GAML, such as finite state machine architecture, task based architecture or user control architecture. In a second part, we will see an other approach, a math approach, through equations. ","url":"wiki/MultiParadigmModeling.md"},{"id":"wiki/OptimizingModelsSection.md","title":" Optimizing Models","content":"# Optimizing Models  Now you are becoming more comfortable with GAML, it is time to think about how the runtime works, to be able to run some more optimized models. Indeed, if you already tried to write some models by yourself using GAML, you could have notice that the execution time depends a lot of how you implemented your model !  We will first present you in this part some runtime concepts (and present you the species facet scheduler), and we will then show you some tips to optimize your models (how to increase performances using scheduler, grids, displays and how to choose your operators). ","url":"wiki/OptimizingModelsSection.md"},{"id":"wiki/StartWithGAML.md","title":" Start with GAML","content":"Start with GAML  In this part, we will present you some basic concepts of GAML that will help you a lot for the next pages.  You will first learn how to organize a standard model, then you will learn about some basis about GAML, such as how to declare a variable, how to use the basic operators, how to write a conditional structure or a loop, how to manipulate containers and how to generate random values. ","url":"wiki/StartWithGAML.md"},{"id":"wiki/CallingR.md","title":" Calling R","content":"# Calling R  Introduction  R language is one of powerful data mining tools, and its community is very large in the world (See the website: http://www.r-project.org/). Adding the R language into GAMA is our strong endeavors to accelerate many statistical, data mining tools into GAMA.  RCaller 2.0 package (Website: http://code.google.com/p/rcaller/) is used for GAMA 1.6.1.  Table of contents     Introduction  Configuration in GAMA       Calling R from GAML   Calling the built-in operators Example 1     Calling R codes from a text file (.txt) WITHOUT the parameters Example 2     Correlation.R file     Output Example 3     RandomForest.R file    Load the package:   Read data from iris:   Build the decision tree:   Build the random forest of 50 decision trees:   Predict the acceptance of test set:   Calculate the accuracy: * Output       * Calling R codes from a text file (.R, .txt) WITH the parameters * Example 4 * Mean.R file       * Output * Example 5 * AddParam.R file * Output   Configuration in GAMA 1) Install R language into your computer.  2) In GAMA, select menu option: Edit/Preferences.  3) In  Config RScript s path , browse to your  Rscript  file (R language installed in your system).  Notes: Ensure that install.packages( Runiversal ) is already applied in R environment.  Calling R from GAML  Calling the built-in operators  Example 1      model CallingR  global {  list X <- [2, 3, 1];  list Y <- [2, 12, 4];  list result;  init{  write corR(X, Y); // -> 0.755928946018454  write meanR(X); // -> 2.0 } }       Calling R codes from a text file (.R,.txt) WITHOUT the parameters  Using R_compute(String RFile) operator. This operator DOESN T ALLOW to add any parameters form the GAML code. All inputs is directly added into the R codes. Remarks: Don t let any white lines at the end of R codes. R_compute will return the last variable of R file, this parameter can be a basic type or a list.  Please ensure that the called packages must be installed before using.  Example 2     model CallingR  global {  list result;  init{  result <- R_compute(C:/YourPath/Correlation.R);  write result at 0; } }     Above syntax is deprecated, use following syntax with R_file instead of R_compute:       model CallingR  global {  file result;  init{  result <- R_file(C:/YourPath/Correlation.R);  write result.contents; } }     #### Correlation.R file     x <- c(1, 2, 3)   y <- c(1, 2, 4)  result <- cor(x, y, method =  pearson )      Output  result::[0.981980506061966]  Example 3     model CallingR  global {  list result;  init{  result <- R_compute(C:/YourPath/RandomForest.R);   write result at 0; } }       RandomForest.R file      # Load the package:  library(randomForest)  Read data from iris:  data(iris)  nrow<-length(iris[,1])  ncol<-length(iris[1,])  idx<-sample(nrow,replace=FALSE)  trainrow<-round(2*nrow/3)  trainset<-iris[idx[1:trainrow],]  Build the decision tree:  trainset<-iris[idx[1:trainrow],]  testset<-iris[idx[(trainrow+1):nrow],]  Build the random forest of 50 decision trees:  model<-randomForest(x= trainset[,-ncol], y= trainset[,ncol], mtry=3, ntree=50)  Predict the acceptance of test set:  pred<-predict(model, testset[,-ncol], type= class )  Calculate the accuracy:  acc<-sum(pred==testset[, ncol])/(nrow-trainrow)      Output  acc::[0.98]  Calling R codes from a text file (.R, .txt) WITH the parameters  Using R_compute_param(String RFile, List vectorParam) operator. This operator ALLOWS to add the parameters from the GAML code.  Remarks: Don t let any white lines at the end of R codes. R_compute_param will return the last variable of R file, this parameter can be a basic type or a list. Please ensure that the called packages must be installed before using.  Example 4      model CallingR  global {  list X <- [2, 3, 1];  list result;  init{  result <- R_compute_param(C:/YourPath/Mean.R, X);  write result at 0; } }       Mean.R file  result <- mean(vectorParam)  Output  result::[3.33333333333333]  Example 5      model CallingR  global {  list X <- [2, 3, 1];  list result;      init{  result <- R_compute_param(C:/YourPath/AddParam.R, X);  write result at 0; } }       AddParam.R file  v1 <- vectorParam[1]  v2<-vectorParam[2]  v3<-vectorParam[3]  result<-v1+v2+v3  Output  result::[10] //: # (endConcept|call_r) ","url":"wiki/CallingR.md"},{"id":"wiki/Comodel.md","title":" Using Comodel","content":"Using Comodel  Introduction In the trend of developing complex system of multi-disciplinary, composing and coupling models are days by days become the most attractive research objectives.  GAMA is supporting the co-modelling and co-simulation which are suppose to be the common coupling infrastructure.  Example of a Comodel  A Comodel is a model, especially an multi-agent-based, compose several sub-model, called micro-model. A comodel itself could be also a micro-model of an other comodel. From the view of a micro-model, comodel is called a macro-model.  A micro-model must be import, instantiate, and life-control by macro-model.    Why and when can we use Comodel ?  to be completed…  Use of Comodel in a GAML model  The GAML language has been evolve by extend the import section. The old importation tell the compiler to merge all imported elements into as one model, but the new one allows modellers to keep the elements come from imported models separately with the caller model.  Defining a micro-model Defining a micro-model of comodel is to import an existing model with an alias name. The syntax is:   import <path to the GAML model> as <identifier>  The identifier is then become the new name of the micro-model.  Instantiate a micro-model After the importation and giving an identifier, micro-model must be explicitly instantiated. It could be done by create statement.   create <micro-model identifier> . <experiment name> [optional parameter];  THe  is an expriment inside micro-model. This syntax will generate an experiment agent and attach an implicitly simulation.  Note: Creation of multi-instant is not create multi-simulation, but multi-experiment. Modellers could create a experiment with multi-simulation by explicitly do the init inside the experiment scope.  Control micro-model life-cycle A micro-model can be control as the normal agent by asking the correspond identifier, and also be destroy by the  o die  statement. As fact, it can be recreate any time we need.   ask (<micro-model identifier> . <experiment name>  at <number> ) . simulation {   ... }   Visualize micro-model  The micro-model species could display in comodel with the support of agent layer   agents name of layer value: (<micro-model> . <experiment name> at <number>).<get List of agents>;   More details  Example of the comodel  Urbanization model with Traffic model    Flood model with Evacuation model Reusing of  two existing models:Flood Simulation and Evacuation.  Toy Models/Evacuation/models/continuous_move.gaml    Toy Models/Flood Simulation/models/Hydrological Model.gaml    The comodel explore the effect of flood on evacuation plan:    Simulation results:   ","url":"wiki/Comodel.md"},{"id":"wiki/Diffusion.md","title":" Implementing diffusion","content":"# Implementing diffusion //: # (keyword|concept_grid) //: # (keyword|concept_math) //: # (keyword|concept_topology)  GAMA provides you the possibility to represent and simulate the diffusion of a variable through a grid topology.  Index     Diffuse statement   Diffusion with matrix  Diffusion matrix       Gradient matrix       Compute multiple propagations at the same step       Executing several diffusion matrix Diffusion with parameters   Computation methods  Convolution       Dot Product Use mask  Generalities       Tips Pseudo code   Diffuse statement  The statement to use for the diffusion is diffuse. It has to be used in a grid species. The diffuse uses the following facets:     var (an identifier), (omissible) : the variable to be diffused   on (any type in [container, species]): the list of agents (in general cells of a grid), on which the diffusion will occur   avoid_mask (boolean): if true, the value will not be diffused in the masked cells, but will be restitute to the neighboring cells, multiplied by the variation value (no signal lost). If false, the value will be diffused in the masked cells, but masked cells won t diffuse the value afterward (lost of signal). (default value : false)   cycle_length (int): the number of diffusion operation applied in one simulation step   mask (matrix): a matrix masking the diffusion (matrix created from a image for example). The cells corresponding to the values smaller than  -1  in the mask matrix will not diffuse, and the other will diffuse.   matrix (matrix): the diffusion matrix ( kernel  or  filter  in image processing). Can have any size, as long as dimensions are odd values.   method (an identifier), takes values in: {convolution, dot_product}: the diffusion method   min_value (float): if a value is smaller than this value, it will not be diffused. By default, this value is equal to 0.0. This value cannot be smaller than 0.   propagation (a label), takes values in: {diffusion, gradient}: represents both the way the signal is propagated and the way to treat multiple propagation of the same signal occurring at once from different places. If propagation equals  diffusion , the intensity of a signal is shared between its neighbors with respect to  proportion ,  variation  and the number of neighbours of the environment places (4, 6 or 8). I.e., for a given signal S propagated from place P, the value transmitted to its N neighbors is : S  = (S / N / proportion) - variation. The intensity of S is then diminished by S * proportion on P. In a diffusion, the different signals of the same name see their intensities added to each other on each place. If propagation equals  gradient , the original intensity is not modified, and each neighbors receives the intensity : S / proportion - variation. If multiple propagation occur at once, only the maximum intensity is kept on each place. If  propagation  is not defined, it is assumed that it is equal to  diffusion .   proportion (float): a diffusion rate   radius (int): a diffusion radius (in number of cells from the center)   variation (float): an absolute value to decrease at each neighbors   To write a diffusion, you first have to declare a grid, and declare a special attribute for the diffusion. You will then have to write the diffuse statement in an other scope (such as the global scope for instance), which will permit the values to be diffused at each step. There, you will specify which variable you want to diffuse (through the var facet), on which species or list of agents you want the diffusion (through the on facet), and how you want this value to be diffused (through all the other facets, we will see how it works with matrix and with special parameters just after).  Here is the template of code we will use for the next following part of this page:      global {  int size <- 64; // the size has to be a power of 2.    cells selected_cells;  // Initialize the emiter cell as the cell at the center of the word init {  selected_cells <- location as cells; } // Affecting 1 to each step reflex new_Value {  ask(selected_cells){   phero <- 1.0;  }  }  reflex diff {  // Declare a diffusion on the grid cells and on quick_cells. The diffusion declared on quick_cells will make 10 computations at each step to accelerate the process.   // The value of the diffusion will be store in the new variable phero of the cell.  diffuse var: phero on: cells /*HERE WRITE DOWN THE DIFFUSION PROPERTIES*/;    } }   grid cells height: size width: size {  //  phero  is the variable storing the value of the diffusion  float phero  <- 0.0;  // The color of the cell is linked to the value of  phero .  rgb color <- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0); }  experiment diffusion type: gui {  output {   display a type: opengl {    // Display the grid with elevation    grid cells elevation: phero * 10 triangulation: true;   }  } }      This model will simulate a diffusion through a grid at each step, affecting 1 to the center cell diffusing variable value. The diffusion will be seen during the simulation through a color code, and through the elevation of the cell.  Diffusion with matrix  A first way of specifying the behavior of your diffusion is using diffusion matrix. A diffusion matrix is a 2 dimension matrix [n][m] with float values, where both n and m have to be pair values. The most often, diffusion matrix are square matrix, but you can also declare rectangular matrix.  Example of matrix:   matrix<float> mat_diff <- matrix([   [1/9,1/9,1/9],   [1/9,1/9,1/9],   [1/9,1/9,1/9]]);   In the diffuse statement, you than have to specify the matrix of diffusion you want in the facet matrix.   diffuse var: phero on: cells matrix:mat_diff;   Using the facet propagation, you can specify if you want the value to be propagated as a diffusion or as a gratient.  Diffusion matrix  A diffusion (the default value of the facet propagation) will spread the values to the neighbors cells according to the diffusion matrix, and all those values will be added together, as it is the case in the following example :    Note that the sum of all the values diffused at the next step is equal to the sum of the values that will be diffused multiply by the sum of the values of the diffusion matrix. That means that if the sum of the values of your diffusion matrix is larger than 1, the values will increase exponentially at each step. The sum of the value of a diffusion matrix is usually equal to 1.  Here are some example of matrix you can use, played with the template model:      Gradient matrix  A gradient (use facet : propagation:gradient) is an other type of propagation. This time, only the larger value diffused will be chosen as the new one.    Note that unlike the diffusion propagation, the sum of your matrix can be greater than 1 (and it is the case, most often !).  Here are some example of matrix with gradient propagation:      Compute multiple propagations at the same step  You can compute several times the propagation you want by using the facet cycle_length. GAMA will compute for you the corresponding new matrix, and will apply it.    Writing those two thinks are exactly equivalent (for diffusion):    matrix<float> mat_diff <- matrix([    [1/81,2/81,3/81,2/81,1/81],    [2/81,4/81,6/81,4/81,2/81],    [3/81,6/81,1/9,6/81,3/81],    [2/81,4/81,6/81,4/81,2/81],    [1/81,2/81,3/81,2/81,1/81]]);  reflex diff {   diffuse var: phero on: cells matrix:mat_diff;    matrix<float> mat_diff <- matrix([    [1/9,1/9,1/9],    [1/9,1/9,1/9],    [1/9,1/9,1/9]]);  reflex diff {   diffuse var: phero on: cells matrix:mat_diff cycle_length:2;   Executing several diffusion matrix  If you execute several times the statement diffuse with different matrix on the same variable, their values will be added (and centered if their dimension is not equal).  Thus, the following 3 matrix will be combined to create one unique matrix:    Diffusion with parameters  Sometimes writing diffusion matrix is not exactly what you want, and you may prefer to just give some parameters to compute the correct diffusion matrix. You can use the following facets in order to do that : propagation, variation and radius.  Depending on which propagation you choose, and how many neighbors your grid have, the propagation matrix will be compute differently. The propagation matrix will have the size : range*2+1.  Let s note P for the propagation value, V for the variation, R for the range and N for the number of neighbors.     With diffusion propagation   For diffusion propagation, we compute following the following steps:  (1) We determine the  minimale  matrix according to N (if N = 8, the matrix will be [[P/9,P/9,P/9][P/9,1/9,P/9][P/9,P/9,P/9]]. if N = 4, the matrix will be [[0,P/5,0][P/5,1/5,P/5][0,P/5,0]]).  (2) If R != 1, we propagate the matrix R times to obtain a [2*R+1][2*R+1] matrix (same computation as for cycle_length).  (3) If V != 0, we substract each value by V*DistanceFromCenter (DistanceFromCenter depends on N).  Ex with the default values (P=1, R=1, V=0, N=8):     With gradient propagation   The value of each cell will be equal to P/POW(N,DistanceFromCenter)-DistanceFromCenter*V. (DistanceFromCenter depends on N).  Ex with R=2, other parameters default values (R=2, P=1, V=0, N=8):    Note that if you declared a diffusion matrix, you cannot use those 3 facets (it will raise a warning). Note also that if you use parameters, you will only have uniform matrix.  Computation methods  You can compute the output matrix using two computation methods by using the facet method : the dot product and the convolution. Note that the result of those two methods is exactly the same (except if you use the avoid_mask facet, the results can be slightly differents between the two computations).  Convolution  convolution is the default computation method for the diffusion. For every output cells, we will multiply the input values and the flipped kernel together, as shown in the following image :    Pseudo-code (k the kernel, x the input matrix, y the output matrix) :   for (i = 0 ; i < y.nbRows ; i++)   for (j = 0 ; j < y.nbCols ; j++)     for (m = 0 ; m < k.nbRows ; m++)       for (n = 0 ; n < k.nbCols ; n++)  y[i,j] += k[k.nbRows - m - 1, k.nbCols - n - 1]    * x[i - k.nbRows/2 + m, j - k.nbCols/2 + n]   Dot Product  dot_product method will compute the matrix using a simple dot product between the matrix. For every input cells, we multiply the cell by the kernel matrix, as shown in the following image :    Pseudo-code (k the kernel, x the input matrix, y the output matrix) :   for (i = 0 ; i < y.nbRows ; i++)   for (j = 0 ; j < y.nbCols ; j++)     for (m = 0 ; m < k.nbRows ; m++)       for (n = 0 ; n < k.nbCols ; n++)  y[i - k.nbRows/2 + m, j - k.nbCols/2 + n] += k[m, n] * x[i, j]   Using mask  Generalities  If you want to propagate some values in an heterogeneous grid, you can use some mask to forbid some cells to propagate their values.  You can pass a matrix to the facet mask. All the values smaller than -1 will not propagate, and all the values greater or equal to -1 will propagate.  A simple way to use mask is by loading an image :    Note that when you use the on facet for the diffuse statement, you can choose only some cells, and not every cells. In fact, when you restrain the values to be diffuse, it is exactly the same process as if you were defining a mask.    When your diffusion is combined with a mask, the default behavior is that the non-masked cells will diffuse their values in all existing cells (that means, even the masked cells !). To change this behavior, you can use the facet avoid_mask. In that case, the value which was supposed to be affected to the masked cell will be redistributed to the neighboring non-masked cells.  Tips  Masks can be used to simulate a lot of environments. Here are some ideas for your models:  Wall blocking the diffusion  If you want to simulate a wall blocking a uniform diffusion, you can declare a second diffusion matrix that will be applied only on the cells where your wall will be. This diffusion matrix will  push  the values outside from himself, but conserving the values (the sum of the values of the diffusion still have to be equal to 1) :      matrix mat_diff <- matrix([    [1/9,1/9,1/9],    [1/9,1/9,1/9],    [1/9,1/9,1/9]]);  matrix mat_diff_left_wall <- matrix([    [0.0,0.0,2/9],    [0.0,0.0,4/9],    [0.0,0.0,2/9]]);  reflex diff {   diffuse var: phero on: (cells where(each.grid_x>30)) matrix:mat_diff;  diffuse var: phero on: (cells where(each.grid_x=30)) matrix:mat_diff_left_wall; }        Note that almost the same result can be obtained by using the facet avoid_mask : the value of all masked cells will remain at 0, and the value which was supposed to be affected to the masked cell will be distributed to the neighboring cells. Notice that the results can be slightly different if you are using the convolution or the dot_product method : the algorithm of redistribution of the value to the neighboring cells is a bit different. We advise you to use the dot_product with the avoid_mask facet, the results are more accurates.  Wind pushing the diffusion  Let s simulate a uniform diffusion that is pushed by a wind from  north  everywhere in the grid. A wind from  west  as blowing at the top side of the grid. We will here have to build 2 matrix : one for the uniform diffusion, one for the  north  wind and one for the  west  wind. The sum of the values for the 2 matrix meant to simulate the wind will be equal to 0 (as it will be add to the diffusion matrix).      matrix mat_diff <- matrix([   [1/9,1/9,1/9],   [1/9,1/9,1/9],   [1/9,1/9,1/9]]);  matrix mat_wind_from_west <- matrix([   [-1/9,0.0,1/9],   [-1/9,0.0,1/9],   [-1/9,0.0,1/9]]);  matrix mat_wind_from_north <- matrix([   [-1/9,-1/9,-1/9],   [0.0,0.0,0.0],   [1/9,1/9,1/9]]);  reflex diff {   diffuse var: phero on: cells matrix:mat_diff;  diffuse var: phero on: cells matrix:mat_wind_from_north;  diffuse var: phero on: (cells where (each.grid_y>=32)) matrix:mat_wind_from_west; }        Endless world  Note that when your world is not a torus, it has the same effect as a mask, since all the values outside from the world cannot diffuse some values back :    You can  fake  the fact that your world is endless by adding a different diffusion for the cells with grid_x=0 to have almost the same result :        matrix mat_diff <- matrix([    [1/9,1/9,1/9],    [1/9,1/9,1/9],    [1/9,1/9,1/9]]);  matrix mat_diff_upper_edge <- matrix([    [0.0,0.0,0.0],    [1/9+7/81,2/9+1/81,1/9+7/81],    [1/9,1/9,1/9]]);  reflex diff {   diffuse var: phero on: (cells where(each.grid_y>0)) matrix:mat_diff;  diffuse var: phero on: (cells where(each.grid_y=0)) matrix:mat_diff_upper_edge; }      Pseudo code  This section is more for a better understanding of the source code.  Here is the pseudo code for the computation of diffusion :  1) : Execute the statement diffuse, store the diffusions in a map (from class DiffusionStatement to class GridDiffuser) :   - Get all the facet values - Compute the real mask, from the facet mask: and the facet on:.   - If no value for mask: and on: all the grid, the mask is equal to null. - Compute the matrix of diffusion   - If no value for matrix:, compute with nb_neighbors, is_gradient, proportion, propagation, variation, range.   - Then, compute the matrix of diffusion with cycle_length. - Store the diffusion properties in a map   - Map : [method_diffu, is_gradient, matrix, mask, min_value] is value, [var_diffu, grid_name] is key.   - If the key exists in the map, try to mix the diffusions     - If method_diffu, mask and is_gradient equal for the 2 diffusions, mix the diffusion matrix.   2) : At the end of the step, execute the diffusions (class GridDiffuser) :   - For each key of the map,   - Load the couple var_diffu / grid_name   - Build the output and input array with the dimension of the grid.    - Initialize the output array with -Double.MAX_VALUE.   - For each value of the map for that key,     - Load all the properties : method_diffu, is_gradient, matrix, mask, min_value     - Compute :       - If the cell is not masked, if the value of input is > min_value, diffuse to the neighbors.  - If the value of the cell is equal to -Double.MAX_VALUE, remplace it by input[idx] * matDiffu[i][j].  - Else, do the computation (gradient or diffusion).     - Finish the diffusion :       - If output[idx] > -Double.MAX_VALUE, write the new value in the cell.  //: # (endConcept|diffusion) ","url":"wiki/Diffusion.md"},{"id":"wiki/FAQ.md","title":" FAQ (Frequently Asked Questions)","content":"FAQ (Frequently Asked Questions)  ## Can we record a video from an experiment ?  No, we cannot directly. But you have two alternatives : - With the set of images generated with the autosave facet of an experiment, you can construct your own video file using powerful software such as ffmpeg. - You can directly record the video stream using software such as VLC Media Player or QuickTime. ","url":"wiki/FAQ.md"},{"id":"wiki/GamAnalyzer.md","title":" Using GAMAnalyzer","content":"# Using GAMAnalyzer  Install  Go to Git View -> Click on Import Projects Add the dependencies in ummisco.gama.feature.dependencies  GamAnalyzer is a tool to monitor several multi-agents simulation  The  agent_group_follower  goal is to monitor and analyze a group of agent during several simulation. This group of agent can be chosen by the user according to criteria chosen by the user. The monitoring process and analysis of these agents involves the extraction, processing and visualization of their data at every step of the simulation.  The data for each simulation are pooled and treated commonly for their graphic representation or clusters.  Built-in Variable   varmap: All variable that can be analyzed or displayed in a graph. numvarmap: Numerical variable (on this variable all the aggregator numeric are computed). qualivarmap: All non numerical variable. Could be used for BDI to analyze beliefs. metadatahistory: See updateMetaDataHistory. This matrice store all the metadata like getSimulationScope(), getClock().getCycle(), getUniqueSimName(scope), rule, scope.getAgentScope().getName(), this.getName(), this.agentsCourants.copy(scope), this.agentsCourants.size(), this.getGeometry(). lastdetailedvarvalues: store all the value (in varmap) for all the followed agent for the last iteration.      averagehistory: Average value for each of the numvar   stdevhistory: Std deviation value for each of the numvar   minhistory: Min deviation value for each of the numvar   maxhistory: Max deviation value for each of the numvar   distribhistoryparams: Gives the interval of the distribution described in distribhistory distribhistory: Distribution of numvarmap      multi_metadatahistory: Aggregate each metadatahistory for each experiment   Example  This example is based on a toy model which is only composed of wandering people. In this example we will use GamAnalyzer to follow the agent people.  ###   agent_group_follower peoplefollower;   create agentfollower  {   do analyse_cluster species_to_analyse:people;   peoplefollower<-self; }   expGlobalNone No clustering only the current agent follower is displayed  aspect base {   display_mode <-global;   clustering_mode <-none;   draw shape color: #red; }   expSimGlobalNone The agent_group_follower corresponding to the current iteration and all the already launch experiments are displayed.   aspect simglobal{   display_mode <-simglobal;   clustering_mode <-none;   draw shape color: #red;   int curColor <-0;   loop geom over: allSimShape{     draw geom color:SequentialColors[curColor] at:{location.x,location.y,curColor*10};     curColor <- curColor+1;   } }  ### expCluster The agent group follower is divided in cluster computed thanks to a dbscan algorithm. Only the current agent_group_follower is displayed  aspect cluster {   display_mode <-global;   clustering_mode <-dbscan;   draw shape color: #red; }  ### expClusterSimGlobal The agent_group_follower (made of different cluster) corresponding to the current iteration and all the already launch experiments are displayed.   aspect clusterSimGlobal {   display_mode <-simglobal;   clustering_mode <-dbscan;   draw shape color: #red;   int curColor <-0;   loop geom over: allSimShape{     draw geom color:SequentialColors[curColor] at:{location.x,location.y,curColor*10};     curColor <- curColor+1;   }  }  //: # (endConcept|run_several_models_using_gamanalyzer) ","url":"wiki/GamAnalyzer.md"},{"id":"wiki/Headless-mode-for-dummies.md","title":" Overview","content":"Overview  This tutorial presents the headless mode usage of GAMA. We will execute the Predator-Prey model, already presented in this tutorial. Headless mode is documented here, with the same model as an example. Here, we focus on the definition of an experiment plan, where the model is run several times. We only consider the shell script execution, not the java command execution.  In headless-mode, GAMA can be seen as any shell command, whose behavior is controlled by passing arguments to it. You must provide 2 arguments :     an **input experiment file **, used to describe the execution plan of your model, its inputs and the expected outputs.   an ** output directory **, where the results of the execution are stored   Headless-mode is a little bit more technical to handle than the general GAMA use-case, and the following commands and code have been solely tested on a Linux Ubuntu 15.04 machine, x86_64 architecture, with kernel 3.19.0-82-generic. Java version is 1.8.0_121 (java version  1.8.0_121 )  You may have to perform some adjustments (such as paths definition) according to your machine, OS, java and GAMA versions and so on.  Setup  GAMA version  Headless mode is frequently updated by GAMA developers, so you have to get the very latest build version of GAMA. You can download it here  https://github.com/gama-platform/gama/releases Be sure to pick the ** Continuous build **  version (The name looks like GAMA1.7_Linux_64_02.26.17_da33f5b.zip) and ** not ** the major release, e.g. GAMA1.7_Linux_64.zip.  gama-headless.sh script setup  The gama-headless.sh script can be found under the headless directory, in GAMA installation directory e.g. :  ~/GAMA/headless/  Modifying the script (a little bit)  The original script looks like this :  #! /bin/bash memory=2048m declare -i i   i=0 echo ${!i}   for ((i=1;i<=$#;i=$i+1)) do if test ${!i} = -m then     i=$i+1     memory=${!i} else     PARAM=$PARAM\\ ${!i}     i=$i+1     PARAM=$PARAM\\ ${!i} fi done   echo ****************************************************************** echo * GAMA version 1.7.0 V7     * echo * http://gama-platform.org  * echo * (c) 2007-2016 UMI 209 UMMISCO IRD/UPMC & Partners    * echo ****************************************************************** passWork=.work$RANDOM   java -cp ../plugins/org.eclipse.equinox.launcher*.jar -Xms512m -Xmx$memory  -Djava.awt.headless=true org.eclipse.core.launcher.Main  -application msi.gama.headless.id4 -data $passWork $PARAM $mfull $outputFile rm -rf $passWork   Notice the final command of the script rm -rf $passWork. It is intended to remove the temporary file used during the execution of the script. For now, we should comment this commmand, in order to check the logs if an error appears : #rm -rf $passWork  Setting the experiment file  Headless mode uses a XML file to describe the execution plan of a model. An example is given in the headless mode documentation page.  The script looks like this : ** N.B. this version of the script, given as an example, is deprecated**  <?xml version=1.0 encoding=UTF-8?> <Experiment_plan> <Simulation id=2 sourcePath=./predatorPrey/predatorPrey.gaml finalStep=1000 experiment=predPrey>  <Parameters>   <Parameter name=nb_predator_init type=INT value=53 />   <Parameter name=nb_preys_init type=INT value=621 />  </Parameters>  <Outputs>   <Output id=1 name=main_display framerate=10 />   <Output id=2 name=number_of_preys framerate=1 />   <Output id=3 name=number_of_predators framerate=1 />   <Output id=4 name=duration framerate=1 />  </Outputs> </Simulation> </Experiment_plan>   As you can see, you need to define 3 things in this minimal example : * Simulation:  its id, path to the model , finalStep (or stop condition), and name of the experiment * Parameters name, of the model for * this * simulation (i.e. Simulation of id= 2) * Outputs of the model: their id, name, type, and the rate (expressed in cycles) at which they are logged in the results file during the simulation  We now describe how to constitute your experiment file.  Experiment File : Simulation  id  For now, we only consider one single execution of the model, so the simulation id is not critical, let it unchanged. Later example will include different simulations in the same experiment file. Simulation id is a string. Don t introduce weird symbols into it.  sourcePath  sourcePath is the relative (or absolute) path to the model file you want to execute headlessly.  Here we want to execute the fourth model of the Predator Prey tutorial suite, located in ~/GAMA/plugins/msi.gama.models_1.7.0.XXXXXXXXXXXX/models/Tutorials/Predator Prey/models (with XXXXXXXXXXXX replaced by the number of the release you downloaded)  So we set sourcePath= ../plugins/msi.gama.models_1.7.0.201702260518/models/Tutorials/Predator Prey/models/Model 07.gaml   (Remember that the headless script is located in ~/GAMA/headless/)  Depending on the directory you want to run the gama-headless.sh script, sourcePath must me modified accordingly. Another workaround for shell more advanced users is to define a  $GAMA_PATH, $MODEL_PATH and $OUPUT_PATH in gama-headless.sh script. Don t forget the quotes  around your path.  finalStep  The duration, in cycles, of the simulation.  experiment  This is the name of (one of) the experiment statement at the end of the model code.  In our case there is only one, called prey_predator and  it looks like this :  experiment prey_predator type: gui {  parameter Initial number of preys:  var: nb_preys_init min: 1 max: 1000 category: Prey ;  parameter Prey max energy:  var: prey_max_energy category: Prey ;  parameter Prey max transfert:  var: prey_max_transfert  category: Prey ;  parameter Prey energy consumption:  var: prey_energy_consum  category: Prey ;  output {   display main_display {    grid vegetation_cell lines: #black ;    species prey aspect: base ;   }   monitor Number of preys value: nb_preys ;  } }     So we are now able to constitute the entire Simulation tag :  <Simulation id=2 sourcePath=~/GAMA/plugins/msi.gama.models_1.7.0.201702260518/models/Tutorials/Predator Prey/models/Model 01.gaml finalStep=1000 experiment=prey_predator>  N.B. the numbers after msi.gama.models (the number of your GAMA release actually) have to be adapted to your own release of GAMA number. The path to the GAMA installation directory has also to be adapted of course.  Experiment File : Parameters  The parameters section of the experiment file describes the parameters names, types and values to be passed to the model for its execution.  Let s say we want to fix the number of preys and their max energy  for this simulation. We look at the experiment section of the model code and use their ** title **.  The title of a parameter is the name that comes right after the parameter statement. In our case,  the strings  Initial number of preys:   and  Prey max energy:   (Mind the spaces, quotes and colon)  The parameters section of the file would look like :  <Parameters>  <Parameter name=Initial number of preys:  type=INT value=621 />  <Parameter name=Prey max energy:  type=FLOAT value=1.0 /> </Parameters>   Any declared parameter can be set this way, yet you don t have to set all of them, provided they are initialized with a default value in the model (see the global statement part of the model code).  Experiment File : Outputs  Output section of the experiment file is pretty similar to the previous one, except for the id that have to be set for each of the outputs .  We can log some of the declared outputs  : main_display and number_of_preys.  The outputs section would look like the following:  <Outputs>  <Output id=1 name=main_display framerate=10 />  <Output id=2 name=Number of preys framerate=1 /> </Outputs>   Outputs must have an id, a name, and a framerate.     id is a number that identifies the output   framerate is the rate at which the output is written in the result file. It s a number of cycle of simulation (integer). In this example the display is saved every 10 cycle   name is either the  title  of the corresponding monitor. In our case, the second output s is the title of the monitor Number of preys, i.e.  Number of preys    We also save a **display ** output, that is an image of the simulation graphical display named main_display in the code of the model. Theses images is what you would have seen if you had run the model in the traditional GUI mode.  Execution and results  Our new version of the experiment file is ready :                                      Execution  We have to launch the gama-headless.sh script and provide two arguments : the experiment file we just completed and the path of a directory where the results will be written.  ** Warning ** In this example ,we are lazy and define the source path as the absolute path to the model we want to execute. If you want to use a relative path, note that it has to be define relatively to the location of your ** ExperimentFile.xml location ** (and the location where you launched the script)  In a terminal, position yourself in the headless directory :  ~/GAMA/headless/ .  Then type the following command :  bash gama-headless.sh -v ~/a/path/to/MyExperimentFile.xml  /path/to/the/desired/output/directory     And replace paths by the location of your ExperimentFile and output directory  You should obtain the following output in the terminal :  ****************************************************************** * GAMA version 1.7.0 V7     * * http://gama-platform.org  * * (c) 2007-2016 UMI 209 UMMISCO IRD/UPMC & Partners    * ****************************************************************** >GAMA plugin loaded in 2927 ms:  msi.gama.core >GAMA plugin loaded in 67 ms:  ummisco.gama.network >GAMA plugin loaded in 56 ms:  simtools.gaml.extensions.traffic >GAMA plugin loaded in 75 ms:  simtools.gaml.extensions.physics >GAMA plugin loaded in 1 ms:  irit.gaml.extensions.test >GAMA plugin loaded in 75 ms:  ummisco.gaml.extensions.maths >GAMA plugin loaded in 47 ms:  msi.gaml.extensions.fipa >GAMA plugin loaded in 92 ms:  ummisco.gama.serialize >GAMA plugin loaded in 49 ms:  irit.gaml.extensions.database >GAMA plugin loaded in 2 ms:  msi.gama.lang.gaml >GAMA plugin loaded in 1 ms:  msi.gama.headless >GAMA plugin loaded in 103 ms:  ummisco.gama.java2d >GAMA plugin loaded in 189 ms:  msi.gaml.architecture.simplebdi >GAMA plugin loaded in 129 ms:  ummisco.gama.opengl >GAMA building GAML artefacts>GAMA total load time 4502 ms.  in 714 ms cpus :8 Simulation is running... .................................................................................................... Simulation duration: 7089ms   Results  The results are stored in the output directory you provided as the second argument of the script.  3 items have appeared :     A console_output.txt file, containing the output of the GAMA console of the model execution if any   a XML file simulation-outputXX.xml, where XX is the id number of your simulation. In our case it should be 2.   the folder snapshots containing the screenshots coming from the second declared output : main_display. image name format is main_display[id]_[cycle].png.   The values of the monitor  Number of preys  are stored in the xml file simulation-outputXX.xml  Common error messages  Exception in thread Thread-7 No parameter named prey_max_energy in experiment prey_predator Probably a typo in the name or the title of a parameter. check spaces, capital letters, symbols and so on.  java.io.IOException: Model file does not exist: /home/ubuntu/dev/tutoGamaHeadless/../plugins/msi.gama.models_1 This may be a relative path mistake; try with absolute path.  java.lang.NumberFormatException: For input string:  1.0  This may be a problem of type declaration in the parameter section.  Going further  Experiments of several simulation  You can launch several simulation by replicating the simulation declaration in your ExperimentFile.xml and varying the values of the parameters. Since you will have to edit the experiment file by hand, you should do that only for a reasonable number of simulations (e.g. <10 )  Design of experiments plans  For more systematic parameter values samples, you should turn towards a more adapted tool such as GAMAR, to generate a ExperimentFile.xml with a huge number of simulations.  ","url":"wiki/Headless-mode-for-dummies.md"},{"id":"wiki/KnownIssues.md","title":" Known issues","content":"Known issues  ## Crash when using openGL on Windows  If you are using GAMA with Windows, and your video card is a Radeon AMD, then GAMA can crash while running a simulation using OpenGL. To avoid this issue, you have to disable your video card. This will slow down a bit the performances, but at least you will be able to run GAMA without those annoying crashes.  To disable your video card, open the control panel, click on Hardware and Sound / Devices and Printers / Device manager, and then right click on your video card (as shown in the following image)    ## Grid not displayed right using openGL  When you try to display a grid with opengl, the cells have not a regular shape (as it is shown in the following image)    The reason of this problem is that we can only map a grid of 2^n2^n cells in the plan. Here are some solutions for this problem : - Choose a grid with 2^n2^n dimension (such as 16x16, or 32x32) - Display the grid in java2D - Display the grid as species, and not as grid (note that the difference in term of performance between displaying a grid as a grid and as a species is not so important for opengl displays. It has originally been done for java2D displays) ","url":"wiki/KnownIssues.md"},{"id":"wiki/ManipulateDates.md","title":" Manipulate Dates","content":"# Manipulate Dates  ## Managing Time in Models  If some models are based on a abstract time - only the number of cycles is important - others are based on a real time. In order to manage the time, GAMA provides some tools to manage time.  First, GAMA allows to define the duration of a simulation step. It provides access to different time variables. At last, since GAMA 1.7, it provides a date variable type and some global variables allowing to use a real calendar to manage time.  Definition of the step and use of temporal unity values GAMA provides three important global variables to manage time:     cycle (int - not modifiable): the current simulation step - this variable is incremented by 1 at each simulation step   step (float - can be modified): the duration of a simulation step (in seconds). By default the duration is one second.   time (float - not modifiable): the current time spent since the beginning of the simulation - this variable is computed at each simulation step by: time = cycle * step.   The value of the cycle and time variables are shown in the top left (green rectangle) of the simulation interface. Clicking on the green rectangle allows to display either the number cycles or the time variable. Concerning this variable, it is presented following a years - month - days - hours - minutes - seconds format. In this presentation, every months are considered as being composed of 30 days (the different number of days of months are not taken into account).  Concerning the step facet, the variable can be modified by the modeler. A classic way of doing it consists in reediting the variable in the global section:   global { float step <- 1 #hour; }   In this example, each simulation step will represent 1 hour. This time will be taken into account for all actions based on time (e.g. moving actions).  Note that the value of the step variable should be given in seconds. To facilitate the definition of the step value and of all expressions based on time, GAMA provides different built-in constant variables accessible with the  #  symbol:     #s : second - 1 second   #mn : minute - 60 seconds   #hour : hour - 60 minutes - 3600 seconds   #day : day - 24 hours - 86400 seconds   #month : month - 30 days - 2592000 seconds   #year : year - 12 month - 3.1104E7   The date variable type and the use of a real calendar Since GAMA 1.7, it is possible to use a real calendar to manage the time. For that, the modeler have just to define the starting date of the simulation. This variable is of type date which allow to represent a date and time.  A date variable has several attributes:     year (int): the year component of the date   month (int): the month component of the date   day (int): the day component of the date   hour (int): the hour component of the date   minute (int): the minute component of the date   second (int): the second component of the date   day_of_week (int): the day of the week   week_of_year (int): the week of the year   Several ways can be used to define a date. The simplest consists in using a list of int values: [year,month of the year,day of the month, hour of the day, minute of the hour, second of the minute]  date my_date <- date([2010,3,23,17,30,10]); // the 23th of March 2010, at 17:30:10  Another way consists in using a string with the good format:  date my_date <- date(2010-3-23T17:30:10+07:00);    Note that the current date can be access through the #now built-in variable (variable of type date).  In addition, GAMA provides different useful operators working on dates. For instance, it is possible to compute the duration in seconds between 2 dates using the  -  operator. The result is given in seconds:  float d <- starting_date - my_date;   It is also possible to add or subtract a duration (in seconds) to a date:  write my_date + 10:  + (my_date + 10); write my_date - 10:  + (my_date - 10);   At last, it is possible to add or subtract a duration (in years, months, weeks, days, hours, minutes,  seconds) to a date:     write  my_date add_years 1:   + (my_date add_years 1); write  my_date add_months 1:   + (my_date add_months 1); write  my_date add_weeks 1:   + (my_date add_weeks 1); write  my_date add_days 1:   + (my_date add_days 1); write  my_date add_hours 1:   + (my_date add_hours 1); write  my_date add_minutes 1:   + (my_date add_minutes 1); write  my_date add_seconds 1:   + (my_date add_seconds 1);  write  my_date subtract_years 1:   + (my_date subtract_years 1); write  my_date subtract_months 1:   + (my_date subtract_months 1); write  my_date subtract_weeks 1:   + (my_date subtract_weeks 1); write  my_date subtract_days 1:   + (my_date subtract_days 1); write  my_date subtract_hours 1:   + (my_date subtract_hours 1); write  my_date subtract_minutes 1:   + (my_date subtract_minutes 1); write  my_date subtract_seconds 1:   + (my_date subtract_seconds 1);     For the modelers, two global date variable are available: * starting_date: date considered as the beginning of the simulation * current_date: current date of the simulation  By default, these variables are nil. Defining a value of the starting_date allows to change the normal time management of the simulation by a more realistic one (using calendar):   global {      date starting_date <- date([1979,12,17,19,45,10]); }   When a variable is set to this variable, the current_date variable is automatically initialized with the same value. However, at each simulation step, the current_date variable is incremented by the step variable. The value of the current_date will replace the value of the time variable in the top left green panel.  Note that you have to be careful, when a real calendar is used, the built-in constants #month and #year should not be used as there are not consistent with the calendar (where month can be composed of 28, 29, 30 or 31 days). ","url":"wiki/ManipulateDates.md"},{"id":"wiki/ManipulateLight.md","title":" Implementing light","content":"# Implementing light  When using opengl display, GAMA provides you the possibility to manipulate one or several lights, making your display more realistic. Most of the following screenshots will be taken with the following short example gaml :      model test_light  grid cells {  aspect base {   draw square(1) at:{grid_x,grid_y} color:#white;  } } experiment my_experiment type:gui{  output {   display my_display type:opengl background:#darkblue {    species cells aspect:base;    graphics  my_layer  {     draw square(100) color:#white at:{50,50};     draw cube(5) color:#lightgrey at:{50,30};     draw cube(5) color:#lightgrey at:{30,35};     draw cube(5) color:#lightgrey at:{60,35};     draw sphere(5) color:#lightgrey at:{10,10,2.5};     draw sphere(5) color:#lightgrey at:{20,30,2.5};     draw sphere(5) color:#lightgrey at:{40,30,2.5};     draw sphere(5) color:#lightgrey at:{40,60,2.5};     draw cone3D(5,5) color:#lightgrey at:{55,10,0};     draw cylinder(5,5) color:#lightgrey at:{10,60,0};    }   }  } }      Index     Light generalities   Default light   Custom lights   Light generalities  Before going deep into the code, here is a quick explanation about how light works in opengl. First of all, you need to know that there are 3 types of lights you can manipulate : the ambient light, the diffuse light and the specular light. Each  light  in opengl is in fact composed of those 3 types of lights.  Ambient light  The ambient light is the light of your world without any lighting. If a face of a cube is not stricken by the light rays for instance, this face will appear totally black if there is no ambient light. To make your world more realistic, it is better to have an ambient light. An ambient light has then no position or direction. It is equally distributed to all the objects of your scene.  Here is an example of our GAML scene using only ambient light (color red) :    Diffuse light  The diffuse light can be seen as the light rays : if a face of a cube is stricken by the diffuse light, it will take the color of this diffuse light. You have to know that the more perpendicular the face of your object will be to the light ray, the more lightened the face will be.  A diffuse light has then a direction. It can have also a position. Your have 2 categories of diffuse light : the positional lights, and the directional lights.  Positional lights  Those lights have a position in your world. It is the case of point lights and spot lights.     Point lights   Points lights can be seen as a candle in your world, diffusing the light equally in all the direction.  Here is an example of our GAML scene using only diffuse light, with a point light (color red, the light source is displayed as a red sphere) :       Spot lights   Spot lights can be seen as a torch light in your world. It needs a position, and also a direction and an angle.  Here is an example of our GAML scene using only diffusion light, with a spot light (color red, the light source is displayed as a red cone) :    Positional lights, as they have a position, can also have an attenuation according to the distance between the light source and the object. The value of positional lights are computed with the following formula : diffuse_light = diffuse_light * ( 1 / (1 + constante_attenuation + linear_attenuation * d + quadratic_attenuation * d)) By changing those 3 values (constante_attenuation, linear_attenuation and quadratic_attenuation), you can control the way light is diffused over your world (if your world is  foggy  for instance, you may turn your linear and quadratic attenuation on). Note that by default, all those attenuation are equal to 0.  Here is an example of our GAML scene using only diffusion light, with a point light with linear attenuation (color red, the light source is displayed as a red sphere) :    Directional lights  Directional lights have no real  position  : they only have a direction. A directional light will strike all the objects of your world with the same direction. An example of directional light you have in the real world would be the light of the sun : the sun is so far away from us that you can consider that the rays have the same direction and the same intensity wherever they strike. Since there is no position for directional lights, there is no attenuation either.  Here is an example of our GAML scene using only diffusion light, with a directional light (color red) :    Specular light  This is a more advanced concept, giving an aspect a little bit  shinny  to the objects stricken by the specular light. It is used to simulate the interaction between the light and a special material (ex : wood, steel, rubber…). This specular light is not implemented yet in gama, only the two others are.  Default light  In your opengl display, without specifying any light, you will have only one light, with those following properties :  Those values have been chosen in order to have the same visual effect in both opengl and java2D displays, when you display 2D objects, and also to have a nice  3D effect  when using the opengl displays. We chose the following setting by default :  * The ambient light value : rgb(127,127,127,255) * diffuse light value : rgb(127,127,127,255) * type of light : direction * direction of the light : (0.5,0.5,-1);  Here is an example of our GAML scene using the default light :    Custom lights  In your opengl display, you can create up to 8 lights, giving them the properties you want.  Ambient light  In order to keep it simple, the ambient light can be set directly when you are declaring your display, through the facet ambient_light. You will have one only ambient light.   experiment my_experiment type:gui {  output {   display my_display type:opengl ambient_light:100 {   }  } }   Note for developers : Note that this ambient light is set to the GL_LIGHT0. This GL_LIGHT0 only contains an ambient light, and no either diffuse nor specular light.  Diffuse light  In order to add lights, or modifying the existing lights, you can use the statement light, inside your display scope :   experiment my_experiment type:gui {  output {   display my_display type:opengl {    light id:0;   }  } }   This statement has just one non-optional facet : the facet  id . Through this facet, you can specify which light you want. You can control 7 lights, through an integer value between 1 and 7. Once you are manipulating a light through the light statement, the light is turned on. To switch off the light, you have to add the facet active, and turn it to false. The light you are declaring through the light statement is in fact a  diffuse  light. You can specify the color of the diffuse light through the facet color (by default, the color will be turn to white). An other very important facet is the type facet. This facet accepts a value among direction, point and spot.  Declaring direction light  A direction light, as explained in the first part, is a light without any position. Instead of the facet position, you will use the facet direction, giving a 3D vector.  Example of implementation :   light id:1 type:direction direction:{1,1,1} color:rgb(255,0,0);   Declaring point light  A point light will need a facet position, in order to give the position of the light source.  Example of implementation of a basic point light :   light id:1 type:point position:{10,20,10} color:rgb(255,0,0);   You can add, if you want, a custom attenuation of the light, through the facets linear_attenuation or quadratic_attenuation.  Example of implementation of a point light with attenuation :   light id:1 type:point position:{10,20,10} color:rgb(255,0,0) linear_attenuation:0.1;   Declaring spot light  A spot light will need the facet position (a spot light is a positionnal light) and the facet direction. A spot light will also need a special facet spot_angle to determine the angle of the spot (by default, this value is set to 45 degree).  Example of implementation of a basic spot light :   light id:1 type:spot position:{0,0,10} direction:{1,1,1} color:rgb(255,0,0) spot_angle:20;   Same as for point light, you can specify an attenuation for a spot light.  Example of implementation of a spot light with attenuation :   light id:1 type:spot position:{0,0,10} direction:{1,1,1} color:rgb(255,0,0) spot_angle:20;   Note that when you are working with lights, you can display your lights through the facet draw light to help you implementing your model. The three types of lights are displayed differently : - The point light is represented by a sphere with the color of the diffuse light you specified, in the position of your light source. - The spot light is represented by a cone with the color of the diffuse light you specified, in the position of your light source, the orientation of your light source. The size of the base of the cone will depend of the angle you specified. - The direction light, as it has no real position, is represented with arrows a bit above the world, with the direction of your direction light, and the color of the diffuse light you specified.    Note for developers : Note that, since the GL_LIGHT0 is already reserved for the ambient light (only !), all the other lights (from 1 to 7) are the lights from GL_LIGHT1 to GL_LIGHT7.       //: # (endConcept       light)   ","url":"wiki/ManipulateLight.md"},{"id":"wiki/ManipulateOSMDatas.md","title":" Manipulate OSM Datas","content":"# Manipulate OSM Datas  This section will be presented as a quick tutorial, showing how to proceed to manipulate OSM (Open street map) datas, and load them into GAMA. We will use the software QGIS to change the attributes of the OSM file.  From the website openstreetmap.org, we will chose a place (in this example, we will take a neighborhood in New York City). Directly from the website, you can export the chosen area in the osm format.    We have now to manipulate the attributes for the exported osm file. Several software are possible to use, but we will focus on QGIS, which is totally free and provides a lot of possibilities in term of manipulation of data.  Once you have installed correctly QGIS, launch QGIS Desktop, and start to import the topology from the osm file.      A message indicates that the import was successful. An output file .osm.db is created. You have now to export the topology to SpatiaLite.    Specify the path for your DataBase file, then choose the export type (in your case, we will choose the type  Polygons (closed ways) ), choose an output layer name. If you want to use the open street maps attributes values, click on  Load from DB , and select the attributes you want to keep. Click OK then.    A message indicates that the export was successful, and you have now a new layer created.    We will now manipulate the attributes of your datafile. Right click on the layer, and select  Open Attribute Table .    The table of attribute appears. Select the little pencil on the top-left corner of the window to modify the table.    We will add an attribute manually. Click on the button  new column , choose a name and a type (we will choose the type  text ).    A new column appears at the end of the table. Let s fill some values (for instance blue / red). Once you finishes, click on the  save edit  button.    Our file is now ready to be exported. Right click on the layer, and click on  Save As .    Choose  shapefile  as format, choose a save path and click ok.    Copy passed all the .shp created in the include folder of your GAMA project. You are now ready to write the model.      model HowToUseOpenStreetMap  global {  // Global variables related to the Management units   file shapeFile <- file( ../includes/new_york.shp );  //definition of the environment size from the shapefile.  //Note that is possible to define it from several files by using: geometry shape <- envelope(envelope(file1) + envelope(file2) + ...); geometry shape <- envelope(shapeFile);  init {  //Creation of elementOfNewYork agents from the shapefile (and reading some of the shapefile attributes)  create elementOfNewYork from: shapeFile    with: [elementId::int(read( id )), elementHeight::int(read( height )), elementColor::string(read( attrForGama ))] ; } }   species elementOfNewYork{  int elementId;  int elementHeight;  string elementColor;  aspect basic{  draw shape color: (elementColor = blue) ? #blue : ( (elementColor = red) ? #red : #yellow ) depth: elementHeight; } }    experiment main type: gui {    output {   display HowToUseOpenStreetMap type:opengl {       species elementOfNewYork aspect: basic;    }  } }      Here is the result, with a special colorization of the different elements regarding to the value of the attribute  attrForGama , and an elevation regarding to the value of the attribute  height .   //: # (endConcept|use_osm_datas) ","url":"wiki/ManipulateOSMDatas.md"},{"id":"wiki/UsingBDI.md","title":" Using BDI","content":"# Using BDI  Install You need to run the Git version.  The plugin need to be add with Eclipse doing the following:     In ummisco.gama.feature.core open the feature.xml file.   In plug-ins click add the msi.gaml.architecture.simplebdi   Acteur Projet A website (still in construction) of the ACTEUR project can be found here http://acteur-anr.fr/  An introduction to cognitive agent  The belief-desire-intention software model (usually referred to simply, but ambiguously, as BDI) is a software model developed for programming intelligent agents.     Belief: State of the agent.   Desire: Objectives that the agent would like to accomplish.   Intention: What the agent has chosen to do.  Plan: Sequences of actions that an agent can perform to achieve one or more of its intensions. Basic Example: A fire rescue model using cognitive agent  We introduce a simple example to illustrate the use of the BDI architecture.  This simple model consists in creating  cognitive  agent whose goal is to extinguish a fire. In a first approximation we consider only one static water area and fire area. The aim is not to have a realistic model but to illustrate how to give a  cognitive  behavior to an agent using the BDI architecture.  First let s create a BDI agent using the key control simple_bdi (A description of all existing control architectures is available here.)  Species Helicopter creation   species helicopter skills:[moving] control: simple_bdi{ ... }   Attributes The species helicopter needs 2 attributes to represent the water value and its speed.  float waterValue; float speed <- 10.0;   Predicates The predicate are the structure that are used to define a belief, a desire or an intention. In this model we choose to declare 3 different predicates.   predicate patrol_desire <- new_predicate(patrol) with_priority 1; predicate water_predicate <- new_predicate(has water, true) with_priority 3; predicate no_water_predicate <- new_predicate(has water, false) ;  The new_predicate() tool creates a predicate. It needs a name (string type) and it can contain a map of values, a priority (double type) or a truth value (boolean type). The with_priority tool add a priority to a predicate. The priority is used as an argument when the agent has to choose between two predicates (to choose an intention for example).  Initialization The initialization consists in setting the attribute waterValue to 1 and to add one desire. Three optional parameters are also set. The first desire added in the desire base is the patrol_desire saying that the helicopter wants to patrol. The optional parameters are specific to the BDI plug-in. You can specify the commitment of an agent to his intentions and his plans with the variables intention_persistence and plan_persistence that are floats between 0.0 (no commitment) and 1.0. The variable probabilistic_choice is a boolean that enables the agent to use a probabilistic choice (when true) or a deterministic choice (when false) when trying to find a plan or an intention.  waterValue <-1.0; do add_desire(patrol_desire); intention_persistence <- 1.0; plan_persistence <- 1.0; probabilistic_choice <- false;    Perception At each iteration, the helicopter has two perceptions to do. The first one is about itself. The helicopter needs to perceive if it has water or not. If it has water, it adds the belief corresponding belief and removes the belief that it does not have water. And if it does not have water, that is the contrary.  perceive target:self{  if(waterValue>0){   do add_belief(water_predicate);   do remove_belief(no_water_predicate);  }  if(waterValue<=0){   do add_belief(no_water_predicate);   do remove_belief(water_predicate);  } }  The second perception is about the fires. Here, the fires are represented with the species fireArea. The helicopter has a radius of perception of 10 meters. If it perceives a fire, it will focus on the location of this fire. The focus tool create a belief with the same name as the focus (here,  fireLocation ) and will store the value of the focused variable (here, the variable location from the specie fireArea) with a priority of 10 in this example. Once the fire is perceived, the helicopter removes its intention of patrolling.  perceive target:fireArea in: 10{  focus fireLocation var:location priority:10;  ask myself{   do remove_intention(patrol_desire, true);  } }   Rules The agent can use rules to create desires from beliefs. In this example, the agent has two rules. The first rule is to have a desire corresponding to the belief of a location of a fire. It means that when the agent has the belief that there is a fire in a particular location, it will have the desire to extinguish it. This permits to have the location value in the desire base. The second rule is to create the desire to have water when the agent has the belief that it not has water.   rule belief: new_predicate(fireLocation) new_desire: get_belief_with_name(fireLocation); rule belief: no_water_predicate new_desire: water_predicate;   Plan ##### Patrolling This plan will be used when the agent has the intention to patrol.  plan patrolling intention: patrol_desire{   do wander; }  ##### stopFire This plan is executed when the agent has the intention to extinguish a fire.  plan stopFire intention: new_predicate(fireLocation) {  point target_fire <- point(get_current_intention().values[location_value] );  if(waterValue>0){   if (self distance_to target_fire <= 1) {    fireArea current_fire <- fireArea first_with (each.location = target_fire);    if (current_fire != nil) {      waterValue <- waterValue - 1.0;      current_fire.size <-  current_fire.size - 1;      if ( current_fire.size <= 0) {      ask  current_fire {do die;}      do remove_belief(get_current_intention());      do remove_intention(get_current_intention(), true);      do add_desire(patrol_desire);     }    } else {     do remove_belief(get_current_intention());     do remove_intention(get_current_intention(), true);     do add_desire(patrol_desire);    }   } else {    do goto target: target_fire;   }  } else {   do add_subintention(get_current_intention(),water_predicate,true);   do current_intention_on_hold();  } }  ##### gotoTakeWater This plan is executed when the agent has the intention to have water.  plan gotoTakeWater intention: water_predicate {      waterArea wa <- first(waterArea);  do goto target: wa);      if (self distance_to wa <= 1) {       waterValue <- waterValue + 2.0;  } }  Plans can have other options. They can have a priority (with the facet priority), a boolean condition to start (with the facet when) or a boolean condition to stop (with the facet finished_when).  Rest of the code ##### Aspect of the helicopter  aspect base {  draw circle(1) color: #black;  }   FireArea Species     species fireArea{  float size <-1.0;      aspect base {       draw circle(size) color: #red;     } }       WaterArea Species     species waterArea{  float size <-10.0;  aspect base {   draw circle(size) color: #blue;   } }      ","url":"wiki/UsingBDI.md"},{"id":"wiki/UsingDatabase.md","title":" Using Database Access","content":"# Using Database Access  Database features of GAMA provide a set of actions on Database Management Systems (DBMS) and Multi-Dimensional Database for agents in GAMA. Database features are implemented in the irit.gaml.extensions.database plug-in with these features:   * Agents can execute SQL queries (create, Insert, select, update, drop, delete) to various kinds of DBMS.   * Agents can execute MDX (Multidimensional Expressions) queries to select multidimensional objects, such as cubes, and return multidimensional cellsets that contain the cube s data . These features are implemented in two kinds of component: skills (SQLSKILL, MDXSKILL) and agent (AgentDB)  SQLSKILL and AgentDB provide almost the same features (a same set of actions on DBMS) but with certain slight differences:     An agent of species AgentDB will maintain a unique connection to the database during the whole simulation. The connection is thus initialized when the agent is created.   In contrast, an agent of a species with the SQLSKILL skill will open a connection each time he wants to execute a query. This means that each action will be composed of three running steps:  Make a database connection.       Execute SQL statement.       Close database connection. > An agent with the SQLSKILL spends lot of time to create/close the connection each time it needs to send a query; it saves the database connection (DBMS often limit the number of simultaneous connections). In contrast, an AgentDB agent only needs to establish one database connection and it can be used for any actions. Because it does not need to create and close database connection for each action: therefore, actions of AgentDB agents are executed faster than actions of SQLSKILL ones but we must pay a connection for each agent. With an inheritance agent of species AgentDB  or an agent of a species using SQLSKILL, we can query data from relational database for creating species, defining environment or analyzing or storing simulation results into RDBMS. On the other hand, an agent of species with MDXKILL supports the OLAP technology to query data from data marts (multidimensional database). The database features help us to have more flexibility in management of simulation models and analysis of simulation results.   Description     Plug-in: irit.gaml.extensions.database   Author: TRUONG Minh Thai, Frederic AMBLARD, Benoit GAUDOU, Christophe SIBERTIN-BLANC   Supported DBMS  The following DBMS are currently supported:   * SQLite   * MySQL Server   * PostgreSQL Server   * SQL Server   * Mondrian OLAP Server   * SQL Server Analysis Services  Note that, other DBMSs require a dedicated server to work while SQLite on only needs a file to be accessed. All the actions can be used independently from the chosen DBMS. Only the connection parameters are DBMS-dependent.  SQLSKILL ### Define a species that uses the SQLSKILL skill  Example of declaration:   species toto skills: [SQLSKILL] {  //insert your descriptions here }   Agents with such a skill can use additional actions (defined in the skill)  Map of connection parameters for SQL  In the actions defined in the SQLSkill, a parameter containing the connection parameters is required. It is a map with the following key::value pairs:  | Key | Optional | Description | |:——-|:——–|:——————————————————–| | dbtype | No | DBMS type value. Its value is a string. We must use  mysql  when we want to connect to a MySQL. That is the same for  postgres ,  sqlite  or  sqlserver  (ignore case sensitive) | | host  | Yes | Host name or IP address of data server. It is absent when we work with SQlite. | | port  | Yes | Port of connection. It is not required when we work with SQLite.| | database | No | Name of database. It is the file name including the path when we work with SQLite. | | user  | Yes | Username. It is not required when we work with SQLite. | | passwd | Yes | Password. It is not required when we work with SQLite. | | srid    | Yes | srid (Spatial Reference Identifier)  corresponds to a spatial reference system. This value is specified when GAMA connects to spatial database. If it is absent then GAMA uses spatial reference system defined in Preferences->External configuration. | Table 1: Connection parameter description  Example: Definitions of connection parameter      // POSTGRES connection parameter map <string, string>  POSTGRES <- [       host :: localhost ,       dbtype :: postgres ,       database :: BPH ,       port :: 5433 ,       user :: postgres ,       passwd :: abc ];  //SQLite map <string, string>  SQLITE <- [      dbtype :: sqlite ,      database :: ../includes/meteo.db ];  // SQLSERVER connection parameter map <string, string> SQLSERVER <- [      host :: localhost ,      dbtype :: sqlserver ,      database :: BPH ,      port :: 1433 ,      user :: sa ,      passwd :: abc ];  // MySQL connection parameter map <string, string>  MySQL <- [      host :: localhost ,      dbtype :: MySQL ,      database ::  , // it may be a null string      port :: 3306 ,      user :: root ,      passwd :: abc ];      Test a connection to database Syntax: > testConnection (params: connection_parameter) The action tests the connection to a given database.   * Return: boolean. It is:     * true: the agent can connect to the DBMS (to the given Database with given name and password)     * false: the agent cannot connect   * Arguments:     * params: (type = map) map of connection parameters   * Exceptions: GamaRuntimeException  Example: Check a connection to MySQL      if (self testConnection(params:MySQL)){  write  Connection is OK  ; }else{  write  Connection is false  ; }       Select data from database Syntax: > select (param: connection_parameter, select: selection_string,values: value_list) The action creates a connection to a DBMS and executes the select statement. If the connection or selection fails then it throws a GamaRuntimeException.   * Return: list < list >. If the selection succeeds, it returns a list with three elements:     * The first element is a list of column name.     * The second element is a list of column type.     * The third element is a data set.   * Arguments:     * params: (type = map) map containing the connection parameters     * select: (type = string) select string. The selection string can contain question marks.     * values: List of values that are used to replace question marks in appropriate. This is an optional parameter.   * Exceptions: GamaRuntimeException  Example: select data from table points   map <string, string>   PARAMS <- [ dbtype :: sqlite ,  database :: ../includes/meteo.db ]; list<list> t <- list<list> (self select(params:PARAMS,           select:SELECT * FROM points ;));   Example: select data from table point with question marks from table points   map <string, string>   PARAMS <- [ dbtype :: sqlite ,  database :: ../includes/meteo.db ]; list<list> t <- list<list> (self select(params: PARAMS,     select: SELECT temp_min FROM points where (day>? and day<?);    values: [10,20] ));   Insert data into database Syntax: > insert (param: connection_parameter,  into:  table_name, columns: column_list, values: value _list)_The action creates a connection to a DBMS and executes the insert statement. If the connection or insertion fails then it throws a_GamaRuntimeException.   * Return: int > If the insertion succeeds, it returns a number of records inserted by the insert.   * Arguments:     *params: (type = map) map containing the connection parameters.     *into: (type = string) table name.     *columns: (type=list)  list of column names of table. It is an optional argument. If it is not applicable then all columns of table are selected.     *values: (type=list) list of values that are used to insert into table corresponding to columns. Hence the columns and values must have same size.   * Exceptions:_GamaRuntimeException  Example: Insert data into table registration      map<string, string> PARAMS <- [ dbtype :: sqlite ,  database :: ../../includes/Student.db ];  do insert (params: PARAMS,       into:  registration ,       values: [102,  Mahnaz ,  Fatma , 25]);  do insert (params: PARAMS, into:  registration , columns: [ id ,  first ,  last ], values: [103,  Zaid tim ,  Kha ]);  int n <- insert (params: PARAMS,      into:  registration ,     columns: [ id ,  first ,  last ],     values: [104,  Bill ,  Clark ]);      Execution update commands Syntax: > executeUpdate (param: connection_parameter,  updateComm:  table_name, values: value_list) The action executeUpdate executes an update command (create/insert/delete/drop) by using the current database connection of the agent. If the database connection does not exist or the update command fails then it throws a GamaRuntimeException. Otherwise it returns an integer value.   * Return: int. If the insertion succeeds, it returns a number of records inserted by the insert.   * Arguments:     * params: (type = map) map containing the connection parameters     * updateComm: (type = string) SQL command string. It may be commands: create, update, delete and drop with or without question marks.     * columns: (type=list)  list of column names of table.     * values: (type=list) list of values that are used to replace question marks if appropriate. This is an optional parameter.   * Exceptions: GamaRuntimeException  Examples: Using action executeUpdate do sql commands (create, insert, update, delete and drop).      map<string, string> PARAMS <- [ dbtype :: sqlite ,   database :: ../../includes/Student.db ]; // Create table do executeUpdate (params: PARAMS,     updateComm:  CREATE TABLE registration        +  (id INTEGER PRIMARY KEY,         +   first TEXT NOT NULL,   +   last TEXT NOT NULL,         +   age INTEGER); );  // Insert into  do executeUpdate (params: PARAMS ,   updateComm:  INSERT INTO registration   +  VALUES(100,  Zara ,  Ali , 18); ); do insert (params: PARAMS, into:  registration ,       columns: [ id ,  first ,  last ],       values: [103,  Zaid tim ,  Kha ]);  // executeUpdate with question marks do executeUpdate (params: PARAMS,   updateComm:  INSERT INTO registration   +  VALUES(?, ?, ?, ?);  ,   values: [101,  Mr ,  Mme , 45]);  //update  int n <-  executeUpdate (params: PARAMS,    updateComm:  UPDATE registration SET age = 30 WHERE id IN (100, 101)  );  // delete int n <- executeUpdate (params: PARAMS,   updateComm:  DELETE FROM registration where id=?  ,  values: [101] );  // Drop table do executeUpdate (params: PARAMS, updateComm:  DROP TABLE registration );      MDXSKILL MDXSKILL plays the role of an OLAP tool using select to query data from OLAP server to GAMA environment and then species can use the queried data for any analysis purposes. ### Define a species that uses the MDXSKILL skill Example of declaration:        species olap skills: [MDXSKILL]   {   //insert your descriptions here   }    ...       Agents with such a skill can use additional actions (defined in the skill)  Map of connection parameters for MDX In the actions defined in the SQLSkill, a parameter containing the connection parameters is required. It is a map with following key::value pairs:       Key       Optional       Description   olaptype       No       OLAP Server type value. Its value is a string. We must use  SSAS/XMLA  when we want to connect to an SQL Server Analysis Services by using XML for Analysis. That is the same for  MONDRIAN/XML  or  MONDRIAN  (ignore case sensitive)       dbtype       No       DBMS type value. Its value is a string. We must use  mysql  when we want to connect to a MySQL. That is the same for  postgres  or  sqlserver  (ignore case sensitive)       host       No       Host name or IP address of data server.       port       No       Port of connection. It is no required when we work with SQLite.       database       No       Name of database. It is file name include path when we work with SQLite.       catalog       Yes       Name of catalog. It is an optional parameter. We do not need to use it when we connect to SSAS via XMLA and its file name includes the path when we connect a ROLAP database directly by using Mondrian API (see Example as below)       user       No       Username.       passwd       No       Password. Table 2: OLAP Connection parameter description  Example: Definitions of OLAP connection parameter      //Connect SQL Server Analysis Services via XMLA  map<string,string> SSAS <- [      olaptype :: SSAS/XMLA ,      dbtype :: sqlserver ,      host :: 172.17.88.166 ,      port :: 80 ,      database :: olap ,      user :: test ,      passwd :: abc ];  //Connect Mondriam server via XMLA  map<string,string>  MONDRIANXMLA <- [      olaptype :: MONDRIAN/XMLA ,      dbtype :: postgres ,      host :: localhost ,      port :: 8080 ,      database :: MondrianFoodMart ,      catalog :: FoodMart ,      user :: test ,      passwd :: abc ];  //Connect a ROLAP server using Mondriam API   map<string,string>  MONDRIAN <- [      olaptype :: MONDRIAN ,      dbtype :: postgres ,      host :: localhost ,      port :: 5433 ,      database :: foodmart ,      catalog :: ../includes/FoodMart.xml ,      user :: test ,    passwd :: abc ];      Test a connection to OLAP database Syntax: > testConnection (params: connection_parameter) The action tests the connection to a given OLAP database.   * Return: boolean.  It is:     * true: the agent can connect to the DBMS (to the given Database with given name and password)     * false: the agent cannot connect   * Arguments:     * params: (type = map) map of connection parameters   * Exceptions: GamaRuntimeException  Example: Check a connection to MySQL   if (self testConnection(params:MONDIRANXMLA)){  write Connection is OK; }else{  write Connection is false; }    Select data from OLAP database Syntax: > select (param: connection_parameter, onColumns: column_string, onRows: row_string from: cube_string, where: condition_string, values: value_list) The action creates a connection to an OLAP database and executes the select statement. If the connection or selection fails then it throws a GamaRuntimeException.   * Return: list < list >.  If the selection succeeds, it returns a list with three elements:     * The first element is a list of column name.     * The second element is a list of column type.     * The third element is a data set.   * Arguments:     * params: (type = map) map containing the connection parameters     * onColumns: (type = string) declare  the select string on columns. The selection string can contain question marks.     * onRows: (type = string) declare the selection string on rows. The selection string can contain question marks.     * from: (type = string) specify cube where data is selected. The cube_string can contain question marks.     * where_: (type = string) specify the selection conditions. The condiction_string can contains question marks. This is an optional parameter.     *values: List of values that are used to replace question marks if appropriate. This is an optional parameter.   * Exceptions:_GamaRuntimeException  Example: select data from SQL Server Analysis Service via XMLA   if (self testConnection[ params::SSAS]){  list l1  <- list(self select (params: SSAS ,   onColumns:  { [Measures].[Quantity], [Measures].[Price] },   onRows: { { { [Time].[Year].[All].CHILDREN } *    +  { [Product].[Product Category].[All].CHILDREN } *    +{ [Customer].[Company Name].&[Alfreds Futterkiste],     +[Customer].[Company Name].&[Ana Trujillo Emparedadosy helados],     + [Customer].[Company Name].&[Antonio Moreno Taquería] } } }  ,   from : FROM [Northwind Star] ));  write result1:+ l1; }else {  write Connect error; }   Example: select data from Mondrian via XMLA with question marks in selection   if (self testConnection(params:MONDRIANXMLA)){  list<list> l2  <- list<list> (self select(params: MONDRIANXMLA,   onColumns: {[Measures].[Unit Sales], [Measures].[Store Cost], [Measures].[Store Sales]} ,  onRows:  Hierarchize(Union(Union(Union({([Promotion Media].[All Media],   + [Product].[All Products])},   + Crossjoin([Promotion Media].[All Media].Children,   + {[Product].[All Products]})),   + Crossjoin({[Promotion Media].[Daily Paper, Radio, TV]},   + [Product].[All Products].Children)),   + Crossjoin({[Promotion Media].[Street Handout]},    + [Product].[All Products].Children)))  ,  from: from [?]  ,  where : where [Time].[?]  ,  values:[Sales,1997]));  write result2:+ l2; }else {  write Connect error; }   AgentDB  AgentBD is a built-in species, which supports behaviors that look like actions in SQLSKILL but differs slightly with SQLSKILL in that it uses  only one connection for several actions. It means that AgentDB makes a connection to DBMS and keeps that connection for its later operations with DBMS. ### Define a species that is an inheritance of agentDB Example of declaration:   species agentDB parent: AgentDB {    //insert your descriptions here }    Connect to database  Syntax:     Connect (param: connection_parameter) This action makes a connection to DBMS. If a connection is established then it will assign the connection object into a built-in attribute of species (conn) otherwise it throws a GamaRuntimeException.   * Return: connection   * Arguments:     * params: (type = map) map containing the connection parameters   * Exceptions: GamaRuntimeException Example: Connect to PostgreSQL    // POSTGRES connection parameter map <string, string>  POSTGRES <- [     host :: localhost ,     dbtype :: postgres ,     database :: BPH ,     port :: 5433 ,     user :: postgres ,     passwd :: abc ]; ask agentDB {       do connect (params: POSTGRES); }   Check agent connected a database or not  Syntax:     isConnected (param: connection_parameter) This action checks if an agent is connecting to database or not.   * Return: Boolean.   If agent is connecting to a database then isConnected returns true; otherwise it returns false.   * Arguments:     * params: (type = map) map containing the connection parameters   Example: Using action executeUpdate do sql commands (create, insert, update, delete and drop).   ask agentDB {  if (self isConnected){     write It already has a connection;  }else{     do connect (params: POSTGRES);  }  }   Close the current connection  Syntax:     close This action closes the current database connection of species. If species does not has a database connection then it throws a GamaRuntimeException.   * Return: null If the current connection of species is close then the action return null value; otherwise it throws a GamaRuntimeException.   Example:   ask agentDB {  if (self isConnected){        do close;  } }   Get connection parameter  Syntax:     getParameter This action returns the connection parameter of species.   * Return: map < string, string >   Example:   ask agentDB {  if (self isConnected){   write the connection parameter:  +(self getParameter);  } }   Set connection parameter  Syntax:     setParameter (param: connection_parameter) This action sets the new values for connection parameter and closes the current connection of species. If it can not close the current connection then it will throw GamaRuntimeException. If the species wants to make the connection to database with the new values then action connect must be called.   * Return: null   * Arguments:     * params: (type = map) map containing the connection parameters   * Exceptions: GamaRuntimeException   Example:   ask agentDB {  if (self isConnected){    do setParameter(params: MySQL);    do connect(params: (self getParameter));  } }   Retrieve data from database by using AgentDB Because of the connection to database of AgentDB is kept alive then AgentDB can execute several SQL queries with only one connection. Hence AgentDB can do actions such as select, insert, executeUpdate with the same parameters of those actions of SQLSKILL except params parameter is always absent.  Examples:   map<string, string> PARAMS <- [ dbtype :: sqlite ,  database :: ../../includes/Student.db ]; ask agentDB {    do connect (params: PARAMS);    // Create table    do executeUpdate (updateComm: CREATE TABLE registration   + (id INTEGER PRIMARY KEY, +  first TEXT NOT NULL,  +  last TEXT NOT NULL, +  age INTEGER););    // Insert into     do executeUpdate ( updateComm: INSERT INTO registration + VALUES(100,  Zara ,  Ali , 18););    do insert (into: registration,    columns: [id, first, last],    values: [103,  Zaid tim ,  Kha ]);    // executeUpdate with question marks    do executeUpdate (updateComm: INSERT INTO registration VALUES(?, ?, ?, ?);,     values: [101,  Mr ,  Mme , 45]);    //select     list<list> t <- list<list> (self select(    select:SELECT * FROM registration;));     //update      int n <-  executeUpdate (updateComm: UPDATE registration SET age = 30 WHERE id IN (100, 101));      // delete      int n <- executeUpdate ( updateComm: DELETE FROM registration where id=? ,  values: [101] );      // Drop table       do executeUpdate (updateComm: DROP TABLE registration); }   Using database features to define environment or create species  In Gama, we can use results of select action of SQLSKILL or AgentDB to create species or define boundary of environment in the same way we do with shape files. Further more, we can also save simulation data that are generated by simulation including geometry data to database.  Define the boundary of the environment from database    Step 1: specify select query by declaration a map object with keys as below: Key       Optional       Description   dbtype       No       DBMS type value. Its value is a string. We must use  mysql  when we want to connect to a MySQL. That is the same for  postgres ,  sqlite  or  sqlserver  (ignore case sensitive)       host       Yes       Host name or IP address of data server. It is absent when we work with SQlite.       port       Yes       Port of connection. It is not required when we work with SQLite.       database       No       Name of database. It is the file name including the path when we work with SQLite.       user       Yes       Username. It is  not required when we work with SQLite.       passwd       Yes       Password. It is  not required when we work with SQLite.       srid       Yes       srid (Spatial Reference Identifier)  corresponds to a spatial reference system. This value is specified when GAMA connects to spatial database. If it is absent then GAMA uses spatial reference system defined in Preferences->External configuration.       select       No       Selection string Table 3: Select boundary parameter description  Example:   map<string,string> BOUNDS <- [   // srid :: 32648 ,   host :: localhost ,           dbtype :: postgres ,   database :: spatial_DB ,   port :: 5433 ,           user :: postgres ,   passwd :: tmt ,   select :: SELECT ST_AsBinary(geom) as geom FROM bounds;  ];      Step 2: define boundary of environment by using the map object in first step.    geometry shape <- envelope(BOUNDS);   Note: We can do the same way if we work with MySQL, SQLite, or SQLServer and we must convert Geometry format in GIS database to binary format.  Create agents from the result of a select action  If we are familiar with how to create agents from a shapefile then it becomes very simple to create agents from select result. We can do as below:     Step 1: Define a species with SQLSKILL or AgentDB    species toto skills: SQLSKILL {  //insert your descriptions here  }       Step 2: Define a connection and selection parameters    global {  map<string,string>  PARAMS <- [ dbtype :: sqlite , database :: ../includes/bph.sqlite ];  string location <-  select ID_4, Name_4, ST_AsBinary(geometry) as geom from vnm_adm4   where id_2=38253 or id_2=38254; ;  ... }  Step 3: Create species by using selected results    init {    create toto {     create locations from: list(self select (params: PARAMS,        select: LOCATIONS))       with:[ id:: id_4, custom_name:: name_4, shape::geom];  }    ... }   Save Geometry data to database If we are familiar with how to create agents from a shapefile then it becomes very simple to create agents from select result. We can do as below:     Step 1: Define a species with SQLSKILL or AgentDB    species toto skills: SQLSKILL {    //insert your descriptions here }       Step 2: Define a connection and create GIS database and tables       global {  map<string,string> PARAMS <-  [ host :: localhost ,  dbtype :: Postgres ,  database ::  ,      port :: 5433 ,  user :: postgres ,  passwd :: tmt ];  init {  create toto ;  ask toto {   if (self testConnection[ params::PARAMS]){       // create GIS database          do executeUpdate(params:PARAMS,         updateComm: CREATE DATABASE spatial_db with TEMPLATE = template_postgis;);           remove key: database from: PARAMS;    put spatial_db key:database in: PARAMS;    //create table     do executeUpdate params: PARAMS       updateComm : CREATE TABLE buildings +      (   +             name character varying(255),  + type character varying(255),  + geom GEOMETRY  +   );   }else {      write Connection to MySQL can not be established ;     }   } } }          Step 3: Insert geometry data to GIS database    ask building {    ask DB_Accessor {  do insert(params: PARAMS,      into: buildings,    columns: [name, type,geom],    values: [myself.name,myself.type,myself.shape];    } }  //: # (endConcept|use_database) ","url":"wiki/UsingDatabase.md"},{"id":"wiki/UsingDrivingSkill.md","title":" Advanced Driving Skill","content":"Advanced Driving Skill  This page aims at presenting how to use the advanced driving skill in models.  The use of the advanced driving skill requires to use 3 skills:   * Advanced driving skill: dedicated to the definition of the driver species. It provides the driver agents with variables and actions allowing to move an agent on a graph network and to tune its behavior.   * Road skill: dedicated to the definition of roads. It provides the road agents with variables and actions allowing to registers agents on the road.   * RoadNode skill: dedicated to the definition of node. It provides the node agents with variables allowing to take into account the intersection of roads and the traffic signals.  Table of contents     Advanced Driving Skill  Structure of the network: road and roadNode skills       Advanced driving skill       Application example Structure of the network: road and roadNode skills The advanced driving skill is versatile enough to be usable with most of classic road GIS data, in particular OSM data. We use a classic format for the roads and nodes. Each road is a polyline composed of road sections (segments). Each road has a target node and a source node. Each node knows all its input and output roads. A road is considered as directed. For bidirectional roads, 2 roads have to be defined corresponding to both directions. Each road will be the linked_road of the other. Note that for some GIS data, only one road is defined for bidirectional roads, and the nodes are not explicitly defined. In this case, it is very easy, using the GAML language, to create the reverse roads and the corresponding nodes (it only requires few lines of GAML).  images/roads_structure.PNG  A lane can be composed of several lanes and the vehicles will be able to change at any time its lane. Another property of the road that will be taken into account is the maximal authorized speed on it. Note that even if the user of the plug-in has no information about these values for some of the roads (the OSM data are often incomplete), it is very easy using the GAML language to fill the missing value by a default value. It is also possible to change these values dynamically during the simulation (for example, to take into account that after an accident, a lane of a road is closed or that the speed of a road is decreased by the authorities).  images/roads.PNG  The road skill provides the road agents with several variables that will define the road properties:   * lanes: integer, number of lanes.   * maxspeed: float; maximal authorized speed on the road.   * linked_road: road agent; reverse road (if there is one).   * source_node: node agent; source node of the road.   * target_node: node agent; target node of the road.  It provides as well the road agents with one read only variable:   * agents_on: list of list (of driver agents); for each lane, the list of driver agents on the road.  The*roadNode skillprovides the road agents with several variables that will define the road properties:   **roads_in**: list of road agents; the list of road agents that have this node for target node.   **roads_out: list of road agents; the list of road agents that have this node for source node.   *stop: list of list of road agents; list of stop signals, and for each stop signal, the list of concerned roads.**  It provides as well the road agents with one read only variable:     block: map: key: driver agent, value: list of road agents; the list of driver agents blocking the node, and for each agent, the list of concerned roads.   Advanced driving skill Each driver agent has a planned trajectory that consists in a succession of edges. When the driver agent enters a new edge, it first chooses its lane according to the traffic density, with a bias for the rightmost lane. The movement on an edge is inspired by the Intelligent Driver Model. The drivers have the possibility to change their lane at any time (and not only when entering a new edge).  The advanced driving skill provides the driver agents with several variables that will define the car properties and the personality of the driver:   * final_target: point; final location that the agent wants to reach (its goal).   * vehicle_length: float; length of the vehicle.   * max_acceleration: float; maximal acceleration of the vehicle.   * max_speed: float; maximal speed of the vehicle.   * right_side_driving: boolean; do drivers drive on the right side of the road?   * speed_coef: float; coefficient that defines if the driver will try to drive above or below the speed limits.   * security_distance_coeff: float; coefficient for the security distance. The security distance will depend on the driver speed and on this coefficient.   * proba_lane_change_up: float; probability to change lane to a upper lane if necessary (and if possible).   * proba_lane_change_down: float; probability to change lane to a lower lane if necessary (and if possible).   * proba_use_linked_road: float; probability to take the reverse road if necessary (if there is a reverse road).   * proba_respect_priorities: float; probability to respect left/right (according to the driving side) priority at intersections.   * proba_respect_stops: list of float; probabilities to respect each type of stop signals (traffic light, stop sign…).   * proba_block_node: float; probability to accept to block the intersecting roads to enter a new road.  It provides as well the driver agents with several read only variables:     speed: float; speed expected according to the road max_value, the car properties, the personality of the driver and its real_speed.   real_speed: float; real speed of the car (that takes into account the other drivers and the traffic signals).   current_path: path (list of roads to follow); the path that the agent is currently following.   current_target: point; the next target to reach (sub-goal). It corresponds to a node.   targets: list of points; list of locations (sub-goals) to reach the final target.   current_index: integer; the index of the current goal the agent has to reach.   on_linked_road: boolean; is the agent on the linked road?   Of course, the values of these variables can be modified at any time during the simulation. For example, the probability to take a reverse road (proba_use_linked_road) can be increased if the driver is stucked for several minutes behind a slow vehicle.  In addition, the advanced driving skill provides the driver agents with several actions:   * compute_path: arguments: a graph and a target node. This action computes from a graph the shortest path to reach a given node.   * drive: no argument. This action moves the driver on its current path according to the traffic condition and the driver properties (vehicle properties and driver personality).  the drive action works as follow: while the agent has the time to move (remaining_time > 0), it first defines the speed expected. This speed is computed from the max_speed of the road, the current real_speed, the max_speed, the max_acceleration and the speed_coef of the driver (see Equation 1).      speed_driver = Min(max_speed_driver, Min(real_speed_driver + max_acceleration_driver,max_speed_road * speed_coef_driver))       Then, the agent moves toward the current target and compute the remaining time. During the movement, the agents can change lanes (see below). If the agent reaches its final target, it stops; if it reaches its current target (that is not the final target), it tests if it can cross the intersection to reach the next road of the current path. If it is possible, it defines its new target (target node of the next road) and continues to move.  images/drive_action.png  The function that defines if the agent crosses or not the intersection to continue to move works as follow: first, it tests if the road is blocked by a driver at the intersection (if the road is blocked, the agent does not cross the intersection). Then, if there is at least one stop signal at the intersection (traffic signal, stop sign…), for each of these signals, the agent tests its probability to respect or not the signal (note that the agent has a specific probability to respect each type of signals). If there is no stopping signal or if the agent does not respect it, the agent checks if there is at least one vehicle coming from a right (or left if the agent drives on the left side) road at a distance lower than its security distance. If there is one, it tests its probability to respect this priority. If there is no vehicle from the right roads or if it chooses to do not respect the right priority, it tests if it is possible to cross the intersection to its target road without blocking the intersection (i.e. if there is enough space in the target road). If it can cross the intersection, it crosses it; otherwise, it tests its probability to block the node: if the agent decides nevertheless to cross the intersection, then the perpendicular roads will be blocked at the intersection level (these roads will be unblocked when the agent is going to move).  images/stop_at_intersection.png  Concerning the movement of the driver agents on the current road, the agent moves from a section of the road (i.e. segment composing the polyline) to another section according to the maximal distance that the agent can moves (that will depend on the remaining time). For each road section, the agent first computes the maximal distance it can travel according the remaining time and its speed. Then, the agent computes its security distance according to its speed and its security_distance_coeff. While its remaining distance is not null, the agent computes the maximal distance it can travel (and the corresponding lane), then it moves according to this distance (and update its current lane if necessary). If the agent is not blocked by another vehicle and can reach the end of the road section, it updates its current road section and continues to move.  images/follow_driving.png  The computation of the maximal distance an agent can move on a road section consists in computing for each possible lane the maximal distance the agent can move. First, if there is a lower lane, the agent tests the probability to change its lane to a lower one. If it decides to test the lower lane, the agent computes the distance to the next vehicle on this lane and memorizes it. If this distance corresponds to the maximal distance it can travel, it chooses this lane; otherwise it computes the distance to the next vehicle on its current lane and memorizes it if it is higher than the current memorized maximal distance. Then if the memorized distance is lower than the maximal distance the agent can travel and if there is an upper lane, the agents tests the probability to change its lane to a upper one. If it decides to test the upper lane, the agent computes the distance to the next vehicle on this lane and memorizes it if it is higher than the current memorized maximal distance. At last, if the memorized distance is still lower than the maximal distance it can travel, if the agent is on the highest lane and if there is a reverse road, the agent tests the probability to use the reverse road (linked road). If it decides to use the reverse road, the agent computes the distance to the next vehicle on the lane 0 of this road and memorizes the distance if it is higher than the current memorized maximal distance.  images/define_max_dist.png  Application example  We propose a simple model to illustrate the driving skill. We define a driver species. When a driver agent reaches its destination, it just chooses a new random final target. In the same way, we did not define any specific behavior to avoid traffic jam for the driver agents: once they compute their path (all the driver agents use for that the same road graph with the same weights), they never re-compute it even if they are stucked in a traffic jam. Concerning the traffic signals, we just consider the traffic lights (without any pre-processing: we consider the raw OSM data). One step of the simulation represents 1 second. At last, in order to clarify the explanation of the model, we chose to do not present the parts of the GAML code that concern the simulation visualization.  images//sim_snapshot.png  The following code shows the definition of species to represent the road infrastructure:     species road skills: [skill_road] {    string oneway; }  species node skills: [skill_road_node] {   bool is_traffic_signal;   int time_to_change <- 100;   int counter <- rnd (time_to_change) ;  reflex dynamic when: is_traffic_signal {     counter <- counter + 1;     if (counter >= time_to_change) { counter <- 0;       stop[0] <-empty(stop[0])? roads_in : [];     }    } }      In order to use our driving skill, we just have to add the skill_road_node to the node species and the skill_road to the road species. In addition, we added to the road species a variable called oneway that will be initialized from the OSM data and that represents the traffic direction (see the OSM map features for more details). Concerning the node, we defined 3 new attributes:     is_traffic_signal: boolean; is the node a traffic light?   time_to_change: integer; represents for the traffic lights the time to pass from the red light to the green light (and vice versa).   counter: integer;  number of simulation steps since the last change of light color (used by the traffic light nodes).   In addition, we defined for the node species a reflex (behavior) called dynamic that will be activated only for traffic light nodes and that will increment the counter value. If this counter is higher than time_to_change, this variable is set to 0, and the node change the value of the stop variable: if the traffic light was green (i.e. there is no road concerns by this stop sign), the list of block roads is set by all the roads that enter the node; if the traffic light was red (i.e. there is at least one road concerns by this stop sign), the list of block roads is set to an empty list.  The following code shows the definition of driver species:      species driver skills: [advanced_driving] {    reflex time_to_go when: final_target = nil {     current_path <- compute_path(  graph: road_network, target: one_of(node));   }   reflex move when: final_target != nil {     do drive;   } }       In order to use our driving plug-in, we just have to add the advanced_driving to the driver species. For this species, we defined two reflexes:   * time_to_go: activated when the agent has no final target. In this reflex, the agent will randomly choose one of the nodes as its final target, and computed the path to reach this target using the   * road_network graph. Note that it will have been possible to take into account the knowledge that each agent has concerning the road network by defining a new variable of type map (dictionary) containing for each road a given weight that will reflect the driver knowledge concerning the network (for example, the known traffic jams, its favorite roads….) and to use this map for the path computation.   * move: activated when the agent has a final target. In this reflex, the agent will drive in direction of its final target.  We describe in the following code how we initialize the simulation:     init {   create node from: file( nodes.shp ) with:[     is_traffic_signal::read( type )= traffic_signals ];  create road from: file( roads.shp )      with:[lanes::int(read( lanes )),      maxspeed::float(read( maxspeed )),      oneway::string(read( oneway ))]      {       switch oneway {  match  no  { create road {   lanes <- myself.lanes;   shape <- polyline(reverse     (myself.shape.points));   maxspeed <- myself.maxspeed;   linked_road <- myself;   myself.linked_road <- self; }  }  match  -1  { shape <- polyline(reverse(shape.points));  }       }     }    }     map general_speed_map <-  road as_map     (each::(each.shape.perimeter/(each.maxspeed)));  road_network <-  (as_driving_graph(road, node))      with_weights general_speed_map;  create driver number: 10000 {      location <- one_of(node).location;     vehicle_length <- 3.0;     max_acceleration <- 0.5 + rnd(500) / 1000;     speed_coeff <- 1.2 - (rnd(400) / 1000);     right_side_driving <- true;     proba_lane_change_up <- rnd(500) / 500;     proba_lane_change_down <- 0.5+ (rnd(250) / 500);     security_distance_coeff <- 3 - rnd(2000) / 1000);     proba_respect_priorities <- 1.0 - rnd(200/1000);     proba_respect_stops <- [1.0 - rnd(2) / 1000];     proba_block_node <- rnd(3) / 1000;     proba_use_linked_road <- rnd(10) / 1000;   }  }       In this code, we create the node agents from the node shapefile (while reading the attributes contained in the shapefile), then we create in the same way the road agents. However, for the road agents, we use the oneway variable to define if we should or not reverse their geometry (oneway =  -1 ) or create a reverse road (oneway =  no ). Then, from the road and node agents, we create a graph (while taking into account the maxspeed of the road for the weights of the edges). This graph is the one that will be used by all agents to compute their path to their final target. Finally, we create 1000 driver agents. At initialization, they are randomly placed on the nodes; their vehicle has a length of 3m; the maximal acceleration of their vehicle is randomly drawn between 0.5 and 1; the speed coefficient of the driver is randomly drawn between 0.8 and 1.2; they are driving on the right side of the road; their probability of changing lane for a upper lane is randomly drawn between 0 and 1.0; their probability of changing lane for a lower lane is randomly drawn between 0.5 and 1.0; the security distance coefficient is randomly drawn between 1 and 3; their probability to respect priorities is randomly drawn between 0.8 and 1; their probability to respect light signal is randomly drawn between 0.998 and 1; their probability to block a node is randomly drawn between 0 and 0.003;  their probability to use the reverse road is randomly drawn between 0 and 0.01;  The complete code of the model with the data can be found here ","url":"wiki/UsingDrivingSkill.md"},{"id":"wiki/UsingFIPAACL.md","title":" Using FIPA ACL","content":"# Using FIPA ACL  The communicating skill offers some actions and built-in variables which enable agents to communicate with each other using the FIPA interaction protocol. This document describes the built-in variables and actions of this skill. Examples are found in the models library bundled with GAMA.  Variables     accept_proposals (list): A list of  accept_proposal  performative messages of the agent s mailbox having .   agrees (list): A list of  accept_proposal  performative messages.   cancels (list): A list of  cancel  performative messages.   cfps (list): A list of  cfp  (call for proposal) performative messages.   conversations (list): A list containing the current conversations of agent. Ended conversations are automatically removed from this list.   failures (list): A list of  failure  performative messages.   informs (list): A list of  inform  performative messages.   messages (list): The mailbox of the agent, a list of messages of all types of performatives.   proposes (list): A list of  propose  performative messages .   queries (list): A list of  query  performative messages.   refuses (list): A list of  propose  performative messages.   reject_proposals (list): A list of  reject_proposals  performative messages.   requests (list): A list of  request  performative messages.   requestWhens (list): A list of  request-when  performative messages.   subscribes (list): A list of  subscribe  performative messages.   Actions ####accept_proposal Replies a message with an  accept_proposal  performative message * returns: unknown * message (message): The message to be replied * content (list): The content of the replying message  agree Replies a message with an  agree  performative message. * returns: unknown * message (message): The message to be replied * content (list): The content of the replying message  cancel Replies a message with a  cancel  peformative message. * returns: unknown * message (message): The message to be replied * content (list): The content of the replying message  cfp Replies a message with a  cfp  performative message. * returns: unknown * message (message): The message to be replied * content (list): The content of the replying message  end_conversation Replies a message with an  end_conversation  peprformative message. This message marks the end of a conversation. In a  no-protocol  conversation, it is the responsible of the modeler to explicitly send this message to mark the end of a conversation/interaction protocol. * returns: unknown * message (message): The message to be replied * content (list): The content of the replying message  failure Replies a message with a  failure  performative message. * returns: unknown * message (message): The message to be replied * content (list): The content of the replying message  inform Replies a message with an  inform  performative message. * returns: unknown * message (message): The message to be replied * content (list): The content of the replying message  propose Replies a message with a  propose  performative message. * returns: unknown * message (message): The message to be replied * content (list): The content of the replying message  query Replies a message with a  query  performative message. * returns: unknown * message (message): The message to be replied * content (list): The content of the replying message  refuse Replies a message with a  refuse  performative message. * returns: unknown * message (message): The message to be replied * content (list): The content of the replying message  reject_proposal Replies a message with a  reject_proposal  performative message. * returns: unknown * message (message): The message to be replied * content (list): The content of the replying message  reply Replies a message. This action should be only used to reply a message in a  no-protocol  conversation and with a  user defined performative . For performatives supported by GAMA (i.e., standard FIPA performatives), please use the  action  with the same name of  performative . For example, to reply a message with a  request  performative message, the modeller should use the  request  action. * returns: unknown * message (message): The message to be replied * performative (string): The performative of the replying message * content (list): The content of the replying message  request Replies a message with a  request  performative message. * returns: unknown * message (message): The message to be replied * content (list): The content of the replying message  send Starts a conversation/interaction protocol. * returns: msi.gaml.extensions.fipa.Message * receivers (list): A list of receiver agents * content (list): The content of the message. A list of any GAML type * performative (string): A string, representing the message performative * protocol (string): A string representing the name of interaction protocol  start_conversation Starts a conversation/interaction protocol. * returns: msi.gaml.extensions.fipa.Message * receivers (list): A list of receiver agents * content (list): The content of the message. A list of any GAML type * performative (string): A string, representing the message performative * protocol (string): A string representing the name of interaction protocol  subscribe Replies a message with a  subscribe  performative message. * returns: unknown * message (message): The message to be replied * content (list): The content of the replying message       //: # (endConcept       fipa_acl)   ","url":"wiki/UsingFIPAACL.md"},{"id":"wiki/IncrementalModel_step1.md","title":" 1. Simple SI Model","content":"1. Simple SI Model This first step Illustrates how to write a model in GAMA. In particular, it describes how to structure a model and how to define species - that are the key components of GAMA models.  Formulation    Definition of the people species with a variable (is_infected) , an aspect (base) and two behaviors (move and infect)   Definition of nb_infected_init, distance_infection and proba_infection parameters   Creation of 500 people agents randomly located in the environment (size: 500x500)   Definition a display to visualize the people agents.     Model Definition  model structure A GAMA model is composed of three type of sections:   * global : this section, that is unique, defines the  world  agent, a special agent of a GAMA model. It represents all that is global to the model: dynamics, variables, actions. In addition, it allows to initialize the simulation (init block).   * species : these sections define the species of agents composing the model.   * experiment : these sections define a context of execution of the simulations. In particular, it defines the input (parameters) and output (displays, files…) of a model.  More details about the different sections of a GAMA model can be found here.  species A species represents a «prototype» of agents: it defines their common properties.  A species includes several sub-definitions:   * the internal state of its agents (attributes)   * their behavior   * how they are displayed (aspects)  GAMA provides as well the possibility to give skills to species of agents. A skillI is a module integrating variables and actions coded in Java.  Concerning our model, we will give the moving skill to the people agents: it will give to the people agents supplementary variables (speed, heading, destination) and actions (follow, goto, move, wander).   species people skills:[moving]{ }   Concerning the internal state, a attribute is defined as follows: type of the attribute (int (integer), float (floating point number), string, bool (boolean, true or false), point (coordinates), list, pair, map, file, matrix, espèce d agents, rgb (color), graph, path…) + name   * Optional facets: <- (initial value), update (value recomputed at each step of the simulation), function:{..} (value computed each time the variable is used), min, max  Note that all the species inherit from predefined built-in variables:   * A name (name)   * A shape (shape)   * A location (location) : the centroid of its shape.  We will give a variable to people agents: is_infected (bool):  species people skills:[moving]{    bool is_infected <- false; }   Concerning the display of an agent, aspects have to be defined. An aspect represents a possible way to display the agents of a species : aspect aspect_name {…} In the block of an aspect, it is possible to draw :   * A geometry :  for instance, the shape of the agent   * An image : to draw icons   * A text : to draw a text  We define an aspect for this species. In this model, we want to display for each people agent a circle of radius 5 and red or green according to the value of is_infected (if infected: red, green otherwise). We then use the keyword draw with a circle shape. To define the color that depends on is_infected, we use the tertiary operator condition ? val1 : val2. If the condition is true, this operator will return val1, otherwise val2. Note that it is possible to get a color value by using the symbol # + color name: e.g. #blue, #red, #white, #yellow, #magenta, #pink…  species people skills:[moving]{    ...  aspect circle{   draw circle(5) color:is_infected ? #red : #green;  } }  Concerning the behavior of agents, the simplest way to define it is through reflexes. A reflex is a block of statements (that can be defined in global or any species) that will be automatically executed at each simulation step if its condition is true. A reflex is defined as follows:     reflex reflex_name when: condition {...}   The when facet is optional: when it is omitted, the reflex is activated at each time step. Note that if several reflexes are defined for a species, the reflexes will be activated following their definition order.  We define a first reflex called move that allows the people agents to move using the wander action (provided by the moving skill) that allows to randomly move (with taking into account the agent speed)  species people {  ...  reflex move{   do wander;  } }   Note that an action is a capability available to the agents of a species (what they can do). It is a block of statements that can be used and reused whenever needed. Some actions, called primitives, are directly coded in Java: for instance, the wander action defined in the moving skill.   * An action can accept arguments. For instance, write takes an argument called message.   * An action can return a result.  There are two ways to call an action: using a statement or as part of an expression   * for actions that do not return a result:  do action_name arg1: v1 arg2: v2;      for actions that return a result:  my_var <- self action_name (arg1:v1, arg2:v2);    The second reflex we have to define is the infect one. This reflex will be activated only if is_infected is true. This reflex consists is asking all the people agents at a distance lower or equal to infection_distance to become infected with a probability proba_infection.   species people skills:[moving]{    ...  reflex infect when: is_infected{   ask people at_distance infection_distance {    if flip(proba_infection) {     is_infected <- true;    }   }  }  ... }   Note that we used the ask statement. This statement allows to make a remote agent executes a list of statements. We used as well the flip operator that allows to test a probability.  global section The global section represents the definition of the species of a specific agent (called world). The world agent represents everything that is global to the model: dynamics, variables… It allows to init simulations (init block): the world is always created and initialized first when a simulation is launched. The geometry (shape) of the world agent is by default a square with 100m for side size, but can be redefined if necessary. In the same way, the modeler can redefined the step variable that represent the duration of a simulation step and that is by default 1 second.  global variable For our model, we define 4 global variables: nb_people (int, init value: 500), infection distance (float value, init value: 2 meters), proba_infection (float, init value: 0.05) and nb_infected_init (int, init value: 5). In addition, we redefine the geometry of the world by a square of 500 meters size and a simulation step of 1 minute.  global{   int nb_people <- 500;  float infection_distance <- 2.0 #m;  float proba_infection <- 0.05;  int nb_infected_init <- 5;  float step <- 1 #minutes;  geometry shape<-square(500 #m); }   Model initialization The init section of the global block allows to initialize the model. The statement create allows to create agents of a specific species: create species_name + :   * number : number of agents to create (int, 1 by default)   * from : GIS file to use to create the agents (string or file)   * returns: list of created agents (list)  For our model, definition of the init block in order to create nb_people people agents. We set the init value of the speed variable (given by the moving skill) to 5km/h. > In addition we ask nb_infected_init people to become infected (use of the nb among list to randomly draw nb elements of the list).  global{   ...  init{   create people number:nb_people {    speed <- 5.0 #km/#h;   }   ask nb_infected_init among people {    is_infected <- true;   }  } }   experiment An experiment block defines how a model can be simulated (executed). Several experiments can be defined for a model. They are defined using : experiment exp_name type: gui/batch {[input] [output]}   * gui : experiment with a graphical interface, which displays its input parameters and outputs.   * batch : Allows to setup a series of simulations (w/o graphical interface).  In our model, we define a gui experiment called main_experiment :  experiment main_experiment type: gui { }   input Experiments can define (input) parameters. A parameter definition allows to make the value of a global variable definable by the user through the graphic interface.  A parameter is defined as follows: parameter title var: global_var category: cat;   * title : string to display   * var : reference to a global variable (defined in the global section)   * category : string used to «store» the operators on the UI - optional   * <- : init value - optional   * min : min value - optional   * max : min value - optional  Note that the init, min and max values can be defined in the global variable definition.  In the experiment, definition of three parameters from the the global variable infection_distance, proba_infection and nb_infected_init :  experiment main_experiment type:gui{  parameter Infection distance var: infection_distance;  parameter Proba infection var: proba_infection min: 0.0 max: 1.0;  parameter Nb people infected at init var: nb_infected_init ;  ... }   output Output blocks are defined in an experiment and define how to visualize a simulation (with one or more display blocks that define separate windows). Each display can be refreshed independently by defining the facet refresh_every: nb (int) (the display will be refreshed every nb steps of the simulation).  Each display can include different layers (like in a GIS) :   * Agents lists : agents layer_name value: agents_list aspect: my_aspect;   * Agents species : species  my_species aspect: my_aspect   * Images: image layer_name file: image_file;   * Texts : texte layer_name value: my_text;   * Charts : see later.  Note that it is possible to define a opengl display (for 3D display) by using the facet type: opengl.  In our model, we define a display to draw the people agents with their circle aspect.  experiment main_experiment type:gui{  ...  output {   display map {    species people aspect:circle;      }  } }   Complete Model      model SI_city  global{   int nb_people <- 500;  float agent_speed <- 5.0 #km/#h;  float infection_distance <- 2.0 #m;  float proba_infection <- 0.05;  int nb_infected_init <- 5;  float step <- 1 #minutes;  geometry shape<-square(500 #m);  init{  create people number:nb_people;  ask nb_infected_init among people {   is_infected <- true;  } }   }  species people skills:[moving]{    float speed <- agent_speed;  bool is_infected <- false;  reflex move{   do wander;  }  reflex infect when: is_infected{   ask people at_distance infection_distance {    if flip(proba_infection) {     is_infected <- true;    }   }  }  aspect circle{   draw circle(5) color:is_infected ? #red : #green;  } }  experiment main_experiment type:gui{  parameter  Infection distance  var: infection_distance;  parameter  Proba infection  var: proba_infection min: 0.0 max: 1.0;  parameter  Nb people infected at init  var: nb_infected_init ;  output {   display map {    species people aspect:circle;      }  } }     ","url":"wiki/IncrementalModel_step1.md"},{"id":"wiki/IncrementalModel_step2.md","title":" 2. Charts","content":"2. Charts This step Illustrates how define monitors and charts in GAMA. In addition, it illustrates how to define a stopping condition for the simulation.  Formulation    Definition of new global variables: current_hour, nb_people_infected, nb_people_not_infected, infected_rate   Definition of a monitor to follow the current hour and the nb of people infected   Definition of a series chart to follow the number of people infected and not infected   Definition of a stopping condition (when infected rate = 1)     Model Definition  global variables In order to define dynamic variable able to update itself, we use the update facet of variable definition. Indeed, at each simulation step, all the agents (and the world agent) apply for each dynamic variable (in their definition order) its update expression. We define 4 new variables:   * current hour (int) : current simulation step (cycle) / 60 mod 24   * nb_people_infected (int): nb of people with is_infected = true (use of the list count condition operator that count the number of elements of the list for which the condition is true)   * nb_people_not_infected (int): nb_people - nb of people infected   * infected_rate (float): nb of people infected / nb of people  global{  ...  int current_hour update: (cycle / 60) mod 24;  int nb_people_infected <- nb_infected_init update: people count (each.is_infected);  int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;  float infected_rate update: nb_people_infected/nb_people;  ... }  ### stopping condition  We add a new reflex that stops the simulation if the infected_rate is equal to 1. To stop the simulation, we apply the halt action.   global {    ...  reflex end_simulation when: infected_rate = 1.0 {   do halt;  } }   Note that it would have been possible to use the pause action that pauses the simulation instead of the halt action that stops the simulation.  monitor A monitor allows to follow the value of an arbitrary expression in GAML. It has to be defined in an output section. A monitor is defined as follows: monitor monitor_name value: an_expression refresh:every(nb_steps);   With:   * value: mandatory, its value will be displayed in the monitor.   * refresh: bool, optional : if the expression is true, compute (default is true).  In this model, we define 2 monitors to follow the value of the variable current_hour and infected_rate:  experiment main_experiment type:gui{  ...  output {   monitor Current hour value: current_hour;   monitor Infected people rate value: infected_rate;   ...  } }   chart  GAMA can display various chart types:   * Time series   * Pie charts   * Histograms  A chart must be defined in a display : it behaves exactly like any other layer. Definition of a chart :   chart chart_name type: chart_type  {      [data] }   The data to draw are define inside the chart block:        data data_legend value: data_value   We add a new display called chart refresh every 10 simulation steps. Inside this display, we define a chart of type series:   *  Species evolution ; background : white; size : {1, 0.5}; position : {0, 0}     * data1: susceptible; color : green     * data2: infected; color : red   experiment main_experiment type:gui{  ...  output {   ...   display chart refresh:every(10) {    chart Disease spreading type: series {     data susceptible value: nb_people_not_infected color: #green;     data infected value: nb_people_infected color: #red;    }   }  } }   Complete Model      model SI_city  global{  int nb_people <- 500;  float step <- 1 #minutes;  geometry shape<-envelope(square(500 #m));  float infection_distance <- 2.0 #m;  float proba_infection <- 0.05;  int nb_infected_init <- 5;  int current_hour update: (cycle / 60) mod 24;  int nb_people_infected <- nb_infected_init update: people count (each.is_infected);  int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;  float infected_rate update: nb_people_infected/length(people);  init{  create people number:nb_people {   speed <- 5.0 #km/#h;  }  ask nb_infected_init among people {   is_infected <- true;  } } reflex end_simulation when: infected_rate = 1.0 {  do halt; } }   species people skills:[moving]{    bool is_infected <- false;  reflex move{   do wander;  }  reflex infect when: is_infected{   ask people at_distance infection_distance {    if flip(proba_infection) {     is_infected <- true;    }   }  }  aspect circle{   draw circle(5) color:is_infected ? #red : #green;  } }  experiment main_experiment type:gui{  parameter  Infection distance  var: infection_distance;  parameter  Proba infection  var: proba_infection min: 0.0 max: 1.0;  parameter  Nb people infected at init  var: nb_infected_init ;  output {   monitor  Current hour  value: current_hour;   monitor  Infected people rate  value: infected_rate;   display map {    species people aspect:circle;      }   display chart refresh:every(10) {    chart  Disease spreading  type: series {     data  susceptible  value: nb_people_not_infected color: #green;     data  infected  value: nb_people_infected color: #red;    }   }  } }     ","url":"wiki/IncrementalModel_step2.md"},{"id":"wiki/IncrementalModel_step3.md","title":" 3. Integration of GIS Data","content":"3. Integration of GIS Data This step Illustrates how load and agentry GIS data.  Formulation    Load, agentify and display two layers of GIS data (building and road)   Modify the initialization of the people agents to put them inside buildings     Model Definition  species We have to define two species of agents: the building agents and the road ones. These agents will not have a particular behavior, they will just be displayed. We define an aspect for these species. In this model, we want to represent the geometry of the agent, we then use the keyword draw that allow to draw a given geometry. In order to draw the geometry of the agent we use the attribute shape (which is a built-in attribute of all agents).      species building {  aspect geom {   draw shape color: #gray;  } }  species road {  aspect geom {   draw shape color: #black;  } }      parameters GAMA allows to automatically read GIS data that are formatted as shapefiles. In order to let the user chooses his/her shapefiles, we define two parameters. One allowing the user to choose the road shapefile, one allowing him/her to choose the building shapefile.  Definition of the two global variables of type file concerning the GIS files:  global {    file shape_file_buildings <- file(../includes/building.shp);    file shape_file_roads <- file(../includes/road.shp); }   agentification of GIS data  In GAMA, the agentification of GIS data is very straightforward: it only requires to use the create command with the from facet to pass the shapefile. Each object of the shapefile will be directly used to instantiate an agent of the specified species.  We modify the init section of the global block in order to create road and building agents from the shape files. Then, we define the initial location of people as a point inside one of the building.  global {   ... init {   create road from: roads_shapefile;   create building from: buildings_shapefile;   create people number:nb_people {    speed <- 5.0 #km/#h;    building bd <- one_of(building);    location <- any_location_in(bd);   }   ask nb_infected_init among people {    is_infected <- true;   }  } }   We defined here a local variable called bd of type building that is a one of the building (randomly chosen). Note that the name of a species can be used to obtain all the agents of this species (here building returns the list of all the buildings). The any_location_in returns a random point inside a geometry or an agent geometry.  environment Building a GIS environment in GAMA requires nothing special, just to define the bounds of the environment, i.e. the geometry of the world agent. It is possible to use a shapefile to automatically define it by computing its envelope. In this model, we use the road shapefile to define it.   global {   ...   geometry shape <- envelope(shape_file_roads);    ... }   display We add to the map display the road and building agents.  In the experiment block:  output {    display map {  species road aspect:geom;  species building aspect:geom;  species people aspect:circle;        }     ... }   Complete Model      model model3  global {  int nb_people <- 500;  float step <- 1 #minutes;  float infection_distance <- 2.0 #m;  float proba_infection <- 0.05;  int nb_infected_init <- 5;  file roads_shapefile <- file( ../includes/road.shp );  file buildings_shapefile <- file( ../includes/building.shp );  geometry shape <- envelope(roads_shapefile);  int current_hour update: (cycle / 60) mod 24;  int nb_people_infected <- nb_infected_init update: people count (each.is_infected);  int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;  float infected_rate update: nb_people_infected/length(people); init {  create road from: roads_shapefile;  create building from: buildings_shapefile;  create people number:nb_people {   speed <- 5.0 #km/#h;   building bd <- one_of(building);   location <- any_location_in(bd);  }  ask nb_infected_init among people {   is_infected <- true;  } } reflex end_simulation when: infected_rate = 1.0 {  do halt; } }   species people skills:[moving]{    bool is_infected <- false;  reflex move{  do wander; } reflex infect when: is_infected{  ask people at_distance infection_distance {   if flip(proba_infection) {    is_infected <- true;   }  } } aspect circle{  draw circle(5) color:is_infected ? #red : #green; } }   species road {  aspect geom {   draw shape color: #black;  } }  species building {  aspect geom {   draw shape color: #gray;  } }  experiment main_experiment type:gui{  parameter  Infection distance  var: infection_distance;  parameter  Proba infection  var: proba_infection min: 0.0 max: 1.0;  parameter  Nb people infected at init  var: nb_infected_init ;  output {   monitor  Current hour  value: current_hour;   monitor  Infected people rate  value: infected_rate;   display map {    species road aspect:geom;    species building aspect:geom;    species people aspect:circle;      }   display chart refresh:every(10) {    chart  Disease spreading  type: series {     data  susceptible  value: nb_people_not_infected color: #green;     data  infected  value: nb_people_infected color: #red;    }   }  } }     ","url":"wiki/IncrementalModel_step3.md"},{"id":"wiki/IncrementalModel_step4.md","title":" 4. Movement on Graph","content":"4. Movement on Graph This step illustrates how load a graph and use it for the displacement of our species.  Formulation    definition of a global graph to represent the road network   definition of a new global variable: staying_coeff to represent the fact that people move more near 9h, 12h and 18h   definition of two new variables for the people agents: target and staying_counter   definition of a new reflex for people agents: stay   modification of the move reflex of the people agents     Model Definition  global variables We define two new global variables:   * road_network (graph) : represents the graph that will be built from the road network   * staying_coeff (float) : represents the fact that people have more chance to move from their current building near 9h (go to work), 12h (lunch time) and 18h (go home). This variable is updated at each simulation step (use of the update facet).    global{  ....  graph road_network;  float staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12),  abs(current_hour - 18)]));  .... }   initialization We need to compute from the road agents, a graph for the moving of the people agents. The operator as_edge_graph allows to do that. It automatically builds from a set of agents or geometries a graph where the agents are the edges of the graph, a node represent the extremities of the agent geometry. The weight of each edge corresponds to the length of the road.  global {    ...    init {       ...       create road from: roads_shapefile;       road_network <- as_edge_graph(road);        ...    } }   people agent First, we add two new variables for the people agents:   * target (point): the target location that the people want to reach (a point inside a building)   * staying_counter (int): the number of cycles since the agent arrived at its building  We define a new reflex called stay that is activated when the agent has no target (target = nil), i.e. when the agent is inside a building. This reflex increments the staying_counter, then it test the probability to leave that is computed from the staying_counter (longer the agent is inside the building, more it has a chance to leave) and the staying_coeff (closer to 9h, 12h and 18h, more the agent has a chance to leave). If the agents decide to leave, it computes a new target as a random point inside one of the buildings (randomly chosen).   species people skills:[moving]{    ...  reflex stay when: target = nil {   staying_counter <- staying_counter + 1;   if flip(staying_counter / staying_coeff) {    target <- any_location_in (one_of(building));   }  }  ... }   We modify the move reflex. Now, this reflex is activated only when the agent has a target (target != nil). In this case the agent moves in direction to its target using the goto action. Note that we specified a graph (road_network) to constraint the moving of the agents on the road network with the facet on. The agent uses the shortest path (according to the graph) to go to the target point. When the agent arrives at destination (location = location), the target is set to nil (the agent will stop moving) and the staying_counter is set to 0.  species people skills:[moving]{    ...  reflex move when: target != nil{   do goto target:target on: road_network;   if (location = target) {    target <- nil;    staying_counter <- 0;   }   } }   Complete Model      model model4  global {  int nb_people <- 500;  float step <- 1 #minutes;  float infection_distance <- 2.0 #m;  float proba_infection <- 0.05;  int nb_infected_init <- 5;  file roads_shapefile <- file( ../includes/road.shp );  file buildings_shapefile <- file( ../includes/building.shp );  geometry shape <- envelope(roads_shapefile);  int current_hour update: (cycle / 60) mod 24;  graph road_network;  float staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));  int nb_people_infected <- nb_infected_init update: people count (each.is_infected);  int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;  float infected_rate update: nb_people_infected/length(people); init {  create road from: roads_shapefile;  road_network <- as_edge_graph(road);  create building from: buildings_shapefile;  create people number:nb_people {   speed <- 5.0 #km/#h;   building bd <- one_of(building);   location <- any_location_in(bd);  }  ask nb_infected_init among people {   is_infected <- true;  } } reflex end_simulation when: infected_rate = 1.0 {  do halt; } }   species people skills:[moving]{    bool is_infected <- false;  point target;  int staying_counter;  reflex staying when: target = nil {   staying_counter <- staying_counter + 1;   if flip(staying_counter / staying_coeff) {    target <- any_location_in (one_of(building));   }  }  reflex move when: target != nil{  do goto target:target on: road_network;  if (location = target) {   target <- nil;   staying_counter <- 0;  }  } reflex infect when: is_infected{  ask people at_distance infection_distance {   if flip(proba_infection) {    is_infected <- true;   }  } } aspect circle{  draw circle(5) color:is_infected ? #red : #green; } }   species road {  aspect geom {   draw shape color: #black;  } }  species building {  aspect geom {   draw shape color: #gray;  } }  experiment main_experiment type:gui{  parameter  Infection distance  var: infection_distance;  parameter  Proba infection  var: proba_infection min: 0.0 max: 1.0;  parameter  Nb people infected at init  var: nb_infected_init ;  output {   monitor  Current hour  value: current_hour;   monitor  Infected people rate  value: infected_rate;   display map {    species road aspect:geom;    species building aspect:geom;    species people aspect:circle;      }   display chart refresh:every(10) {    chart  Disease spreading  type: series {     data  susceptible  value: nb_people_not_infected color: #green;     data  infected  value: nb_people_infected color: #red;    }   }  } }     ","url":"wiki/IncrementalModel_step4.md"},{"id":"wiki/IncrementalModel_step5.md","title":" 5. Visualizing in 3D","content":"5. Visualizing in 3D This step Illustrates how to define a 3D display  Formulation    add a variable (height: int from 10m to 20m) and modify the aspect of buildings to display them in 3D   add a variable (display_shape: geometry; shape with a buffer of 2m) and modify the aspect of the roads to display them with this new shape.   add a new global variable that indicate if it is night or not (bool: night before 7h and after 20h).   define a new aspect (sphere3D) for people to display them as sphere.   modify the display to use this new aspect.     Model Definition  building First, we add a new variable for buildings (height) of type float from 10m to 20m. Then we modify the aspect in order to specify a depth for the geometry (using the depth facet).  species building {  float height <- 10#m + rnd(10) #m;  aspect geom {   draw shape color: #gray depth: height;  } }   road Concerning the road,  we add a new variable (display_shape) of type geometry that correspond to the shape of the road with a buffer of 2 meters. Then we modify the aspect in order to display this geometry instead of the shape of the agent. In order to avoid  z-fighting  problems, we add a depth to the geometry (of 3 meters).  species road {  geometry display_shape <- shape + 2.0;  aspect geom {   draw display_shape color: #black depth: 3.0;  } }   global variable We define a new global variable called is_night of type bool to indicate if it is night or not. This variable will be update at each simulation step and will be true if the current_hour is lower than 7h or higher than 20h.  global{  ...  bool is_night <- true update: current_hour < 7 or current_hour > 20; ... }   people We define a new aspect for the people agent called sphere3D. This aspect draw people agent as a 3m sphere. In order to avoid to cut the sphere in half, we translate the centroid of the drawn sphere to 3m along the z axis.  species people skills:[moving]{    ...  aspect sphere3D{   draw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green;  } }   display The element that we have to modify is the display. We change its name to map_3D to better reflect its visual aspect.  In order to get a 3D aspect, we specify that this display will be an opengl one. For that, we just have to add the facet type: opengl. In addition, to get a different light between night and day :  The statement light allows us to declare a light. We can change up to 7 lights, called through the facet  id . The default light is a white light, directional, with the id=1. You can set the intensity of the light through the facet  color  (you can pass a color, or an integer between 0 and 255). To have a nice effect night / day, we will set the intensity of the light to 50 during the night, and 255 for the day. To learn more about light, please read this page.  Then, we add a new layer that consists in an image (soil.jpg) by using the image statement. In order to see the people inside the building, we add transparency to the building (0.5). The transparency of a layer is a float value between 0 (solid) and 1 (totally transparent). In order to be able to manage this transparency aspect, opengl has to draw the people agents before the building, thus we modify the order of drawing of the different layers (people agents before building agents). At last, we modify the aspect of the people agents by the new one: sphere3D.   experiment main_experiment type:gui{  ...  output {   ...   display map_3D type: opengl {    light 1 color:(is_night ? 50 : 255);    image ../includes/soil.jpg;    species road aspect:geom;    species people aspect:sphere3D;       species building aspect:geom transparency: 0.5;   }   ...  } }   Complete Model      model model5  global {  int nb_people <- 500;  float step <- 1 #minutes;  float infection_distance <- 2.0 #m;  float proba_infection <- 0.05;  int nb_infected_init <- 5;  file roads_shapefile <- file( ../includes/road.shp );  file buildings_shapefile <- file( ../includes/building.shp );  geometry shape <- envelope(roads_shapefile);  graph road_network;  int current_hour update: (cycle / 60) mod 24;  float staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));  int nb_people_infected <- nb_infected_init update: people count (each.is_infected);  int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;  bool is_night <- true update: current_hour < 7 or current_hour > 20;  float infected_rate update: nb_people_infected/length(people); init {  create road from: roads_shapefile;  road_network <- as_edge_graph(road);  create building from: buildings_shapefile;  create people number:nb_people {   speed <- 5.0 #km/#h;   building bd <- one_of(building);   location <- any_location_in(bd);  }  ask nb_infected_init among people {   is_infected <- true;  } } reflex end_simulation when: infected_rate = 1.0 {  do halt; } }   species people skills:[moving]{    bool is_infected <- false;  point target;  int staying_counter;  reflex stay when: target = nil {   staying_counter <- staying_counter + 1;   if flip(staying_counter / staying_coeff) {    target <- any_location_in (one_of(building));   }  }  reflex move when: target != nil{  do goto target:target on: road_network;  if (location = target) {   target <- nil;   staying_counter <- 0;  }  } reflex infect when: is_infected{  ask people at_distance infection_distance {   if flip(proba_infection) {    is_infected <- true;   }  } } aspect circle{  draw circle(5) color:is_infected ? #red : #green; } aspect sphere3D{  draw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green; } }   species road {  geometry display_shape <- shape + 2.0;  aspect geom {   draw display_shape color: #black depth: 3.0;  } }  species building {  float height <- 10#m + rnd(10) #m;  aspect geom {   draw shape color: #gray depth: height;  } }  experiment main_experiment type:gui{  parameter  Infection distance  var: infection_distance;  parameter  Proba infection  var: proba_infection min: 0.0 max: 1.0;  parameter  Nb people infected at init  var: nb_infected_init ;  output {   monitor  Current hour  value: current_hour;   monitor  Infected people rate  value: infected_rate;   display map_3D type: opengl {    light 1 color:(is_night ? 50 : 255);    image  ../includes/soil.jpg ;    species road aspect:geom;    species people aspect:sphere3D;       species building aspect:geom transparency: 0.5;   }   display chart refresh:every(10) {    chart  Disease spreading  type: series {     data  susceptible  value: nb_people_not_infected color: #green;     data  infected  value: nb_people_infected color: #red;    }   }  } }     ","url":"wiki/IncrementalModel_step5.md"},{"id":"wiki/IncrementalModel_step6.md","title":" 6. Multi-Level","content":"6. Multi-Level This step Illustrates how to define a multi-level model  Formulation We propose to let the buildings manage what happens when the people are inside buildings. In this context, we will use the multi-level properties of GAMA: when a people agent will be inside a building, it will be captured by it and its species will be modified. It will be not anymore the people agent that will decide when to leave the building, but the building itself.  We will need to:   * define a micro-species of people inside the building species (people_in_buildings)   * define a new variable for the building agent (people_inbuilding)   * define two new behaviors for building: let_people_leave and let_people_enter   * modify the aspect of the building   * modify some global variables for counting the number of infected people    Model Definition ### building First, we define a new species called people_in_building inside the building species. Thus, a building could have agents of this species as members and control them. The people_in_building species has for parent the people species, which means that a people_in_building agent has all the properties, aspect and behaviors of a people agent. In our case, we want the once a people agent inside a building, this people agent does nothing. Then, we use the schedules facet of the species to remove the people_in_building from the scheduler.   species building {  ...  species people_in_building parent: people schedules: [] {  }  ... }   We define a new dynamic variable for building agent: people_inside that will correspond to the list of people_in_building agents inside the building. Note that we use the syntax -> {…} to make the variable dynamic. However, instead of update that allows a variable to be recomputed at each simulation step, the syntax -> {…} allows the variable to be recomputed each time it is called (and thus avoid outdated problems). To compute this variable, we use the members built-in variable that corresponds to the list of micro-agents captured by the macro-agent.   species building {  ...  list<people_in_building> people_inside -> {members collect people_in_building(each)};  ... }   We define a first reflex for the buildings that will be activated at each simulation step and that will allow the building to capture all the people that are inside its geometry and that are not moving (target = nil). Capturing agents means putting them inside its members list and changing their species: here the people agents become people_in_building agents.  species building {  ...       reflex let_people_enter {   list<people> entering_people <- people inside self where (each.target = nil);   if not (empty (entering_people)) {    capture entering_people as: people_in_building ;    }  }  .... }   We define a second reflex for the buildings that will be activated at each simulation step and that will allow the building to release some of the people_in_building agents. First, it increments the staying counter of all the people_in_building agents. Then it builds the list of leaving people by testing the same probability as before for all the people_in_building agents. Finally, if this list is not empty, it releases them as people agents (and gives them a new target point).   species building {  ... reflex let_people_leave  {   ask members as: people_in_building{    staying_counter <- staying_counter + 1;   }   list<people_in_building> leaving_people <- list<people_in_building>(members where (flip(people_in_building(each).staying_counter / staying_coeff)));   if not (empty (leaving_people)) {    release leaving_people as: people in: world returns: released_people;    ask released_people {     target <- any_location_in (one_of(building));    }   }  }  .... }   At last, we refine the aspect of the buildings: if there is not people inside the building, we draw it with gray color. If the number of people_in_building infected is higher than the number of people_in_building not infected, we draw it in red; otherwise in green.   species building {  ...  aspect geom {    int nbI <- members count people_in_building(each).is_infected;   int nbT <- length(members);   draw shape color:nbT = 0 ? #gray : (float(nbI)/nbT > 0.5 ? #red : #green) depth: height;  } }   global variables In order to take into account the people that are inside the buildings for the computation of nb_people_infected, we first build the list of people_in_building. As people_in_building is a macro species of building, we cannot compute it directly like for the other species, we then aggregate all the list people_inside of all building in a single list (list_people_in_buildings). Then, we compute the number of infected people as the number of people infected outside the building + the number of people infected inside them.   global  {  ...  list<people_in_building> list_people_in_buildings update: (building accumulate each.people_inside) where (not dead(each));  int nb_people_infected <- nb_infected_init update: people count (each.is_infected) + (empty(list_people_in_buildings) ? 0 : list_people_in_buildings count (each.is_infected));  ... }   Complete Model       global  {  int nb_people <- 500;  float step <- 1 #minutes;  float infection_distance <- 2.0 #m;  float proba_infection <- 0.05;  int nb_infected_init <- 5;  file roads_shapefile <- file( ../includes/road.shp );  file buildings_shapefile <- file( ../includes/building.shp );  geometry shape <- envelope(roads_shapefile);  graph road_network;  int current_hour update: (cycle / 60) mod 24;  float staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));  list<people_in_building> list_people_in_buildings update: (building accumulate each.people_inside) where (not dead(each)); int nb_people_infected <- nb_infected_init update: people count (each.is_infected) + (empty(list_people_in_buildings) ? 0 : list_people_in_buildings count (each.is_infected));  int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected; bool is_night <- true update: current_hour < 7 or current_hour > 20;  float infected_rate update: nb_people_infected/nb_people; init {  create road from: roads_shapefile;  road_network <- as_edge_graph(road);  create building from: buildings_shapefile;  create people number:nb_people {   speed <- 5.0 #km/#h;   building bd <- one_of(building);   location <- any_location_in(bd);  }  ask nb_infected_init among people {   is_infected <- true;  }   } reflex end_simulation when: infected_rate = 1.0 {    do halt; } }   species people skills:[moving]{    bool is_infected <- false;  point target;  int staying_counter;  reflex move when: target != nil{  do goto target:target on: road_network;  if (location = target) {   target <- any_location_in (one_of(building));   target <- nil;   staying_counter <- 0;  }  } reflex infect when: is_infected{  ask people at_distance infection_distance {   if flip(proba_infection) {    is_infected <- true;   }  } } aspect circle{  draw circle(5) color:is_infected ? #red : #green; } aspect sphere3D{  draw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green; } }   species road {  geometry display_shape <- shape + 2.0;  aspect geom {   draw display_shape color: #black depth: 3.0;  } }  species building {  float height <- 10#m + rnd(10) #m;  list people_inside -> {members collect people_in_building(each)};  aspect geom {  int nbI <- members count people_in_building(each).is_infected;  int nbT <- length(members);  draw shape color:nbT = 0 ? #gray : (float(nbI)/nbT > 0.5 ? #red : #green) depth: height; }  species people_in_building parent: people schedules: [] {  aspect circle{}  aspect sphere3D{} }  species people_in_2 parent: people schedules: [] {  aspect circle{}  aspect sphere3D{} }  reflex let_people_leave  {  ask members as: people_in_building{   staying_counter <- staying_counter + 1;  }  list<people_in_building> leaving_people <- list<people_in_building>(members where (flip(people_in_building(each).staying_counter / staying_coeff)));  if not (empty (leaving_people)) {   release leaving_people as: people in: world returns: released_people;   ask released_people {    target <- any_location_in (one_of(building));   }  } } reflex let_people_enter {  list<people> entering_people <- people inside self where (each.target = nil);  if not (empty (entering_people)) {   capture entering_people as: people_in_building ;    } } }   experiment main_experiment type:gui{  parameter  Infection distance  var: infection_distance;  parameter  Proba infection  var: proba_infection min: 0.0 max: 1.0;  parameter  Nb people infected at init  var: nb_infected_init ;  output {   monitor  Current hour  value: current_hour;   monitor  Infected people rate  value: infected_rate;   display map_3D type: opengl {    light 1 color:(is_night ? 50 : 255);    image  ../includes/soil.jpg ;    species road aspect:geom;    species people aspect:sphere3D;       species building aspect:geom transparency: 0.5;   }   display chart refresh:every(10) {    chart  Disease spreading  type: series {     data  susceptible  value: nb_people_not_infected color: #green;     data  infected  value: nb_people_infected color: #red;    }   }  } }     ","url":"wiki/IncrementalModel_step6.md"},{"id":"wiki/IncrementalModel_step7.md","title":" 7. Differential Equations","content":"7. Differential Equations This step Illustrates how to use differential equations  Formulation We are interested by the spreading of the disease inside the buildings. In order to model it, we will use differential equations. So, we will need to:     add two global variables to define the building epidemic properties (beta and h).   add new variables for the buildings (I, S, T, t, I_to_1);   define differential equations for disease spreading inside buildings   add a behavior for buildings for the spreading of the disease.     Model Definition ### global variables We define two new global variables that will be used disease spreading dynamic inside the buildings.  global  {  ...  float beta <- 0.01;  float h<-0.1;  ... }  ### building In order to define the disease spreading dynamic, we define several variables that will be used by the differential equations:   * I : float, number of people infected in the building   * S : float, number of people not infected in the building   * T : float, total number of people in the building   * t : float, current time     * I_to1 : float, remaining number of people infected (float number lower between 0 and 1 according to the differential equations).  species building {  ....  float I;  float S;  float T;     float t;        float I_to1;   ... }   Then, we define the differential equations that will use for the disease spreading dynamic. Note that to define a differential equation system we use the block equation + name. These equations are the classic ones used by SI mathematical models.  species building {  ....  equation SI{    diff(S,t) = (- beta * S * I / T) ;   diff(I,t) = (  beta * S * I / T) ;  } ... }   At last, we define a new reflex for the building called epidemic that will be activated only when there is someone inside the building. This reflex first compute the number of people inside the building (T), then the number of not infected people (S) and finally the number of infected ones (I).  If there is at least one people infected and one people not infected, the differential equations is integrated (according to the discretisation step value h) with the method Runge-Kutta 4 to compute the new value of infected people. We then sum the old value of I_to_1 with the number of people newly infected (this value is a float and not an integer). Finally, we cast this value as an integer, ask the corresponding number of not infected people to become infected, and decrement this integer value to I_to1.  species building {  ....  reflex epidemic when: not empty(members){     T <- float(length(members));   list<people_in_building> S_members <- list<people_in_building>(members where not (people_in_building(each).is_infected));       S <- float(length(S_members));       I <- T-S;       float I0 <- I;       if (I > 0 and S > 0) {              solve SI method: rk4 step: h;              I_to1 <- I_to1 + (I - I0);              int I_int <- min([int(S),int(I_to1)]);              I_to1 <- I_to1 - I_int;              ask(I_int among S_members){             is_infected <- true;             }      }      } ... }   Complete Model      model model7  global  {  int nb_people <- 500;  float step <- 1 #minutes;  float infection_distance <- 2.0 #m;  float proba_infection <- 0.05;  int nb_infected_init <- 5;  file roads_shapefile <- file( ../includes/road.shp );  file buildings_shapefile <- file( ../includes/building.shp );  geometry shape <- envelope(roads_shapefile);  graph road_network;  int current_hour update: (cycle / 60) mod 24;  float staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));  float beta <- 0.01;  float h<-0.1;  list list_people_in_buildings update: (building accumulate each.people_inside) where (not dead(each));  int nb_people_infected <- nb_infected_init update: people count (each.is_infected) + (empty(list_people_in_buildings) ? 0 : list_people_in_buildings count (each.is_infected));  int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected; bool is_night <- true update: current_hour < 7 or current_hour > 20;  float infected_rate update: nb_people_infected/nb_people; init {  create road from: roads_shapefile;  road_network <- as_edge_graph(road);  create building from: buildings_shapefile;  create people number:nb_people {   speed <- 5.0 #km/#h;   building bd <- one_of(building);   location <- any_location_in(bd);  }  ask nb_infected_init among people {   is_infected <- true;  }   } reflex end_simulation when: infected_rate = 1.0 {    do halt; } }   species people skills:[moving]{    bool is_infected <- false;  point target;  int staying_counter;  reflex move when: target != nil{  do goto target:target on: road_network;  if (location = target) {   target <- any_location_in (one_of(building));   target <- nil;   staying_counter <- 0;  }  } reflex infect when: is_infected{  ask people at_distance infection_distance {   if flip(proba_infection) {    is_infected <- true;   }  } } aspect circle{  draw circle(5) color:is_infected ? #red : #green; } aspect sphere3D{  draw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green; } }   species road {  geometry display_shape <- shape + 2.0;  aspect geom {   draw display_shape color: #black depth: 3.0;  } }  species building {  float height <- 10#m + rnd(10) #m;  list people_inside -> {members collect people_in_building(each)};  float I;  float S;  float T;     float t;        float I_to1;  aspect geom {  int nbI <- members count people_in_building(each).is_infected;  int nbT <- length(members);  draw shape color:nbT = 0 ? #gray : (float(nbI)/nbT > 0.5 ? #red : #green) depth: height; }  species people_in_building parent: people schedules: [] { }  reflex let_people_leave  {  ask members as: people_in_building{   staying_counter <- staying_counter + 1;  }  list<people_in_building> leaving_people <- list<people_in_building>(members where (flip(people_in_building(each).staying_counter / staying_coeff)));  if not (empty (leaving_people)) {   release leaving_people as: people in: world returns: released_people;   ask released_people {    target <- any_location_in (one_of(building));   }  } } reflex let_people_enter {  list<people> entering_people <- people inside self where (each.target = nil);  if not (empty (entering_people)) {   capture entering_people as: people_in_building ;    } } equation SI{   diff(S,t) = (- beta * S * I / T) ;  diff(I,t) = (  beta * S * I / T) ; }  reflex epidemic when: not empty(members){    T <- float(length(members));  list<people_in_building> S_members <- list<people_in_building>(members where not (people_in_building(each).is_infected));  S <- float(length(S_members));  I <- T-S;  float I0 <- I;  if (I > 0 and S > 0) {   solve SI method: rk4 step: h;   I_to1 <- I_to1 + (I - I0);   int I_int <- min([int(S),int(I_to1)]);      I_to1 <- I_to1 - I_int;      ask(I_int among S_members){       is_infected <- true;      }  } }   }   experiment main_experiment type:gui{  parameter  Infection distance  var: infection_distance;  parameter  Proba infection  var: proba_infection min: 0.0 max: 1.0;  parameter  Nb people infected at init  var: nb_infected_init ;  output {   monitor  Current hour  value: current_hour;   monitor  Infected people rate  value: infected_rate;   display map_3D type: opengl {    light 1 color:(is_night ? 50 : 255);    image  ../includes/soil.jpg ;    species road aspect:geom;    species people aspect:sphere3D;       species building aspect:geom transparency: 0.5;   }   display chart refresh:every(10) {    chart  Disease spreading  type: series {     data  susceptible  value: nb_people_not_infected color: #green;     data  infected  value: nb_people_infected color: #red;    }   }  } }     ","url":"wiki/IncrementalModel_step7.md"},{"id":"wiki/LuneraysFlu_step1.md","title":" 1. Creation of a first basic disease spreading model","content":"1. Creation of a first basic disease spreading model This first step illustrates how to create simple agents and make them move in their environment.    Formulation    Set the time duration of a time step to 1 minutes   Define the people species with a moving skill   Define the move reflex that allow the people agent to move randomly and the infect reflex that allows them to infect other people agents.   Define the aspect of the people species   Add the people species to a display   Model Definition  Project and model The first step of this tutorial consists in launching GAMA and choosing a workspace, then to define a new project or to import the existing one. For people that do not want to re-write all the models but just to follow the model construction, they can just download the model project here and the follow this procedure to import it into GAMA. For the other, the project and model creation procedures are detailed here.  Note that the concepts of workspace and projects are explained here.  model structure A GAMA model is composed of three type of sections:   * global : this section, that is unique, defines the  world  agent, a special agent of a GAMA model. It represents all that is global to the model: dynamics, variables, actions. In addition, it allows to initialize the simulation (init block).   * species and grid: these sections define the species of agents composing the model. Grid are defined in the following model step  vegetation dynamic ;   * experiment : these sections define a context of execution of the simulations. In particular, it defines the input (parameters) and output (displays, files…) of a model.  More details about the different sections of a GAMA model can be found here.  species A species represents a «prototype» of agents: it defines their common properties.  Three different elements can be defined in a species:   * the internal state of its agents (attributes)   * their behavior   * how they are displayed (aspects)  In our model, we define a people species:     species people {  }      In addition, we want add a new capability to our agent: the possibility to move randomly. for that, we add a specific skill to our people agents. A skill is a built-in module that provide the modeler a self-contain and relevant set of actions and variables. The moving provides the agents with several attributes and actions related to movement.      species people skills: [moving]{ ...    }   Internal state An attribute is defined as follows: type of the attribute  and name. Numerous types of attributes are available: int (integer), float (floating point number), string, bool (boolean, true or false), point (coordinates), list, pair, map, file, matrix, espèce d agents, rgb (color), graph, path…   * Optional facets: <- (initial value), update (value recomputed at each step of the simulation), function:{..} (value computed each time the variable is used), min, max  In addition to the attributes the modeler explicitly defines, species  inherits  other attributes called  built-in  variables:   * A name (name): the identifier of the species   * A shape (shape): the default shape of the agents to be construct after the species. It can be a point, a polygon, etc.   * A location (location) : the centroid of its shape.  In our model, we define 2 new attribute to our people agents:    * speed of type float, with for initial value: a random value between 2 and 5 km/h   * is_infected of type bool, with for initial value: false   species people skills:[moving]{    float speed <- (2 + rnd(3)) #km/#h;  bool is_infected <- false; }  Note we use the rnd operator to define a random value between 2 and 5 for the speed. In addition, we precise a unit for the speed value by using the # symbol. For more details about units, see here.  Behavior GAMA proposes several ways to define the behavior of a species: dynamic variables (update facet), reflexes….  A reflex is a block of statements (that can be defined in global or any species) that will be automatically executed at each simulation step if its condition is true, it is defined as follows:     reflex reflex_name when: condition {...}   The when facet is optional: when it is omitted, the reflex is activated at each time step. Note that if several reflexes are defined for a species, the reflexes will be activated following their definition order.  We define a first reflex called move that is activated at each simulation step (no condition) and that makes the people move randomly using the wander action from the moving skill.  species people skills:[moving]{    //variable definition  reflex move{   do wander;  } }   We define a second reflex called infect that is activated only when the agent is infected (is_infected = true) and that ask all the people at a distance of 10m to test a probability to be infected.     species people skills:[moving]{    //variable definition and move reflex  reflex infect when: is_infected{  ask people at_distance 10 #m {   if flip(0.05) {    is_infected <- true;   }  } } }     The [ask](Statements#ask) allows an agent to ask another agents to do something (i.e. to execute a sequence of statements). The [at_distance](Operators#at_distance) operator allows to get the list of agents (here of people agents) that are located at a distance lower or equal to the given distance (here 10m). The [flip](Operators#flip) operator allows to test a probability.   Display An agent aspects have to be defined. An aspect is a way to display the agents of a species : aspect aspect_name {…} In the block of an aspect, it is possible to draw :   * A geometry :  for instance, the shape of the agent (but it may be a different one, for instance a disk instead of a complex polygon)   * An image : to draw icons   * A text : to draw a text  In our model, we define an aspect for the people agent called circle that draw the agents as a circle of 10m radius with a color that depends on their is_infected attribute. If the people agent is infected, it will be draw in red, in green otherwise.      species people {  …//variable and reflex definition  aspect circle {   draw circle(10) color:is_infected ? #red : #green;  } }  }     The **?** structure allows to return a different value (here red or green) according to a condition (here is_infected = true).   global section The global section represents a specific agent, called world. Defining this agent follows the same principle as any agent and is, thus, defined after a species. The world agent represents everything that is global to the model : dynamics, variables… It allows to initialize simulations (init block): the world is always created and initialized first when a simulation is launched (before any other agents). The geometry (shape) of the world agent is by default a square with 100m for side size, but can be redefined if necessary. The step attribute of the world agent allows to specify the duration of one simulation step (by default, 1 step = 1 seconde).  global variable In the current model, we define 4 global attributes:    * nb_people: the number of people that we want to create (init value: 2147)    * nb_infected_init: the number of people infected at the initialization of the simulation (init value: 5)    * step: redefine in order to set the duration of a simulation step to 1 minute.    * shape: redefine in order to set the geometry of the world to a square of 1500 meters side size.   global {  int nb_people <- 2147;  int nb_infected_init <- 5;  float step <- 1 #mn;  geometry shape<-square(1500 #m); }   Model initialization  The init section of the global block allows to initialize the define what will happen at the initialization of a simulation, for instance to create agents. We use the statement create  to create agents of a specific species: create species_name + :   * number : number of agents to create (int, 1 by default)   * from : GIS file to use to create the agents (optional, string or file)   * returns: list of created agents (list)  For our model, we define the init block in order to create nb_people people agents and ask nb_infected_init of them to be infected:  global {  // world variable definition  init{   create people number:nb_people;   ask nb_infected_init among people {    is_infected <- true;   }  } }   experiment An experiment block defines how a model can be simulated (executed). Several experiments can be defined for a given model. They are defined using : experiment exp_name type: gui/batch {[input] [output]}   * gui : experiment with a graphical interface, which displays its input parameters and outputs.   * batch : Allows to setup a series of simulations (w/o graphical interface).  In our model, we define a gui experiment called main_experiment  :  experiment main_experiment type: gui { }   input Experiments can define (input) parameters. A parameter definition allows to make the value of a global variable definable by the user through the graphic interface.  A parameter is defined as follows: parameter title var: global_var category: cat;   * title : string to display   * var : reference to a global variable (defined in the global section)   * category : string used to «store» the operators on the UI - optional   * <- : init value - optional   * min : min value - optional   * max : min value - optional  Note that the init, min and max values can be defined in the global variable definition.  In our model, we define one parameter:    *  Nb people infected at init  that will define the value of the global variable nb_infected_init with a min value of 1 and a max value of 2147 (the number of people living in Luneray).      experiment main_experiment type:gui{  parameter  Nb people infected at init  var: nb_infected_init min: 1 max: 2147;  output { } }     #### output [Output](DefiningGUIExperiment) blocks are defined in an experiment and define how to visualize a simulation (with one or more [display](DefiningDisplaysGeneralities) blocks that define separate windows). Each display can be refreshed independently by defining the facet **refresh\\_every:** nb (int) (the display will be refreshed every nb steps of the simulation).   Each display can include different layers (like in a GIS) :   * Agents lists : agents layer_name value: agents_list aspect: my_aspect;   * Agents species : species  my_species aspect: my_aspect   * Images: image layer_name file: image_file;   * Texts : texte layer_name value: my_text;   * Charts : see later.  Note that it is possible to define a opengl display (for 3D display or just to optimize the display) by using the facet type: opengl.  In our model, we define an OpenGL display to draw the people agents.   output {  display map type: opengl{   species people aspect:circle;   } }   Complete Model      model SI_city1  global{   int nb_people <- 2147;  int nb_infected_init <- 5;  float step <- 1 #mn;  geometry shape<-square(1500 #m);  init{  create people number:nb_people;  ask nb_infected_init among people {   is_infected <- true;  } }   }  species people skills:[moving]{    float speed <- (2 + rnd(3)) #km/#h;  bool is_infected <- false;  reflex move{   do wander;  }  reflex infect when: is_infected{   ask people at_distance 10 #m {    if flip(0.05) {     is_infected <- true;    }   }  }  aspect circle{   draw circle(10) color:is_infected ? #red : #green;  } }  experiment main_experiment type:gui{  parameter  Nb people infected at init  var: nb_infected_init min: 1 max: 2147;  output {   display map type: opengl{    species people aspect:circle;      }  } }     Next step: Definition of monitors and chart outputs ","url":"wiki/LuneraysFlu_step1.md"},{"id":"wiki/LuneraysFlu_step2.md","title":" 2. Definition of monitors and chart outputs","content":"2. Definition of monitors and chart outputs This second step illustrates how to create monitors and charts to follows the evolution of variables and to add an ending condition to the simulation.    Formulation    Add three new global dynamic variables to follow the evolution of the number of infected people agents, of not infected people agents and of the rate of infected people.   Define an ending condition for the simulation   Define a monitor to follow the rate of infected people agents   Define a chart to follow the rate of infected people agents   Model Definition  global section  global variables  GAMA offers the possibility to define dynamic variable that will be recomputed at each simulation step by using the update facet when defining a variable. When an agent is activated, first, it recomputes each of its variables with a update facet (in their definition order), then it activates each of its reflexes (in their definition order).  To better follow the evolution of sick people, we add three new global variables to the model:   * nb_people_infected of type int with nb_infected_init as init value and updated at each simulation step by the number of infected people   * nb_people_not_infected of type int with (nb_people - nb_infected_init) as init value and updated at each simulation step by the number of not infected people   * infected_rate of type float updated at each simulation step by the number of infected people divided by the number of people.   global{  //... other attributes  int nb_people_infected <- nb_infected_init update: people count (each.is_infected);  int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;  float infected_rate update: nb_people_infected/nb_people;  //... init }   We used the count operator that allows to count the number of elements of a list for which the left condition is true. The keyword each represents each element of the list.  ending condition  The simplest way to add an ending condition to a model is to add a global reflex that is activated at the end of the simulation that will pause the simulation (use of the pause global action).  In our model, we add a new reflex called end_simulation that will be activated when the infected rate is 1.0 (i.e. all the people agents are infected) and that will apply the pause action.      global {  //.. variable and init definition  reflex end_simulation when: infected_rate = 1.0 {  do pause; } }      ### experiment   monitor GAMA provides modelers with the possibility to define monitors. A monitor allows to follow the value of an arbitrary expression in GAML. It will appear, in the User Interface, in a small window on its own and be recomputed every time step (or according to its  refresh  facet).  Definition of a monitor:    * value: mandatory, the expression whose value will be displayed by the monitor.    * refresh: bool, optional : if the expression is true, compute (default is true).  For our model, we define a monitor to follow the value of the infected_rate variable:     experiment main_experiment type:gui{  //…parameters  output {   monitor  Infected people rate  value: infected_rate;   //...display } }       Chart  In GAMA, charts are considered as a display layer.  GAMA can display 3 main types of charts using the type facet:     histogram   pie   series/xy/scatter: both display series with lines or dots, with 3 subtypes :  series: to display the evolution of one/several variable (vs time or not).       xy: to specify both x and y value. To allow stacked plots, only one y value for each x value.       scatter: free x and y values for each serie. In our model, we define a new display called _ chart_display_ that will be refresh every 10 simulation steps. In this display, we add a series charts with 2 layers of data:    * susceptible: the number of people that are not infected (in green)    * infected: the number of people that are infected (in red)     experiment main_experiment type:gui{  //…parameters  output {   //…display and monitors   display chart_display refresh:every(10) {   chart Disease spreading type: series {    data susceptible value: nb_people_not_infected color: #green;    data infected value: nb_people_infected color: #red;   }  } } }     ## Complete Model       model SI_city2  global{   int nb_people <- 2147;  int nb_infected_init <- 5;  float step <- 1 #mn;  geometry shape<-square(1500 #m);  int nb_people_infected <- nb_infected_init update: people count (each.is_infected);  int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;  float infected_rate update: nb_people_infected/nb_people;  init{  create people number:nb_people;  ask nb_infected_init among people {   is_infected <- true;  } }  reflex end_simulation when: infected_rate = 1.0 {  do pause; } }   species people skills:[moving]{    float speed <- (2 + rnd(3)) #km/#h;  bool is_infected <- false;  reflex move{   do wander;  }  reflex infect when: is_infected{   ask people at_distance 10 #m {    if flip(0.05) {     is_infected <- true;    }   }  }  aspect circle{   draw circle(10) color:is_infected ? #red : #green;  } }  experiment main_experiment type:gui{  parameter  Nb people infected at init  var: nb_infected_init min: 1 max: 2147;  output {   monitor  Infected people rate  value: infected_rate;   display map type: opengl{   species people aspect:circle;     }    display chart refresh:every(10) {   chart Disease spreading type: series {    data susceptible value: nb_people_not_infected color: #green;    data infected value: nb_people_infected color: #red;   }  } } }       Next step: Importation of GIS data ","url":"wiki/LuneraysFlu_step2.md"},{"id":"wiki/LuneraysFlu_step3.md","title":" 3. Importation of GIS data","content":"3. Importation of GIS data This third step illustrates how load GIS data and to agentify them.    Formulation    Define 2 new species that will just be displayed: road and building.   Add a new my_building attribute to the people agents.   Define new global attributes to load GIS data (shape file).   Use the GIS data to create the road and building agents.   Add the road and building agents to the display.   Model Definition  For this step, you will need to add the shapefiles of the roads and buildings inside the includes folder of the project. The shapefiles (and all the other files) can be found here.  species In this model, we have to define two species of agents: the road agents and the building ones. These agents will not have a particular behavior, they will just be displayed. For each of this species we define an aspect called geom. As we want to represent the geometry of the agent, we then use the keyword draw that allow to draw a given geometry. In order to draw the geometry of the agent we use the attribute shape (which is a built-in attribute of all agents). The road will be displayed in black and the building in gray.      species road {  aspect geom {   draw shape color: #black;  } }  species building {  aspect geom {   draw shape color: #gray;  } }       In addition, we add an attribute to the people species called my_builing of type building. Note that agent species can be use as variable type.   species people skills:[moving]{    //other attributes  building my_house;   //reflexes and aspect  }   global section  global variables  GAMA allows to automatically read GIS data that are formatted as shape files (or as OSM file). In our model, we define 2 shapefiles: one corresponding to the roads and the other ones to the buildings. Note that GAMA is able to manage the projection of the GIS data.  In order to set the right size (and position) of the world geometry, we define its value as the envelope of the road shapefile (and no more a square of 1500 meters).      global{  //… other attributes  file roads_shapefile <- file( ../includes/routes.shp );  file buildings_shapefile <- file( ../includes/batiments.shp );  geometry shape <- envelope(roads_shapefile);   //… init }       agentification of GIS data  In GAMA, the agentification of GIS data is very straightforward: it only requires to use the create command with the from facet to pass the shapefile. Each object of the shapefile will be directly used to instantiate an agent of the specified species. The reading of an attribute in a shapefile is also very simple. It only requires to use the with facet: the argument of this facet is a dictionary of which the keys are the names of the agent attributes and the value the read command followed by the name of the shapefile attribute.  In our model, we modify the init section in order to first create the road agents from the road shapefile, and the building agents from the building shapefile. Then, when creating people agents, we choose for them one random building and a random location inside this building. Note that it is possible to execute a sequence of statements at the creation of agents by using a block ({…}) rather than a simple line (;) when using the create statement.      global {  // world variable definition  init{  create road from: roads_shapefile;  create building from: buildings_shapefile;  create people number:nb_people {   my_house <- one_of(building);   location <- any_location_in(my_house);  }    }  ask nb_infected_init among people {   is_infected <- true;  } } }       We used here the one_of operator that returns a random element from a list and the any_location_in operator that returns a random location inside a geometry.  experiment  Output  In the map display, we add the road and building species with their geom aspect just before the people species (in order to draw the people agents on the top of the roads and buildings).      experiment main_experiment type: gui {  … //parameter definition  output { ... //monitor definition   display map type: opengl{   species road aspect:geom;   species building aspect:geom;   species people aspect:circle;     }  ... //chart display definition } }       Complete Model      model SI_city3  global{   int nb_people <- 2147;  int nb_infected_init <- 5;  float step <- 1 #mn;  file roads_shapefile <- file( ../includes/roads.shp );  file buildings_shapefile <- file( ../includes/buildings.shp );  geometry shape <- envelope(roads_shapefile);  int current_hour update: (time /#h) mod 24;  int nb_people_infected <- nb_infected_init update: people count (each.is_infected);  int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;  float infected_rate update: nb_people_infected/nb_people;  init{  create road from: roads_shapefile;  create building from: buildings_shapefile;  create people number:nb_people {   my_house <- one_of(building);   location <- any_location_in(my_house);  }  ask nb_infected_init among people {   is_infected <- true;  } }  reflex end_simulation when: infected_rate = 1.0 {  do pause; } }   species people skills:[moving]{    float speed <- (2 + rnd(3)) #km/#h;  bool is_infected <- false;  building my_house;  reflex move{  do wander; } reflex infect when: is_infected{  ask people at_distance 10 #m {   if flip(0.05) {    is_infected <- true;   }  } } aspect circle{  draw circle(10) color:is_infected ? #red : #green; } }   species road {  aspect geom {   draw shape color: #black;  } }  species building {  aspect geom {   draw shape color: #gray;  } }  experiment main_experiment type:gui{  parameter  Nb people infected at init  var: nb_infected_init min: 1 max: 2147;  output {   monitor  Infected people rate  value: infected_rate;   display map type: opengl {   species road aspect:geom;   species building aspect:geom;   species people aspect:circle;     }    display chart refresh:every(10) {   chart Disease spreading type: series {    data susceptible value: nb_people_not_infected color: #green;    data infected value: nb_people_infected color: #red;   }  } } }       Next step: Use of a graph to constraint the movements of people ","url":"wiki/LuneraysFlu_step3.md"},{"id":"wiki/LuneraysFlu_step4.md","title":" 4. Use of a graph to constraint the movements of people]","content":"4. Use of a graph to constraint the movements of people] This fourth step illustrates how to use a graph to constraint the movements of agents    Formulation    Define a new global variable: the road network (graph).   Build the road network graph from the road agents   Add new attribute to the people agents (target and in_my_house)   Define a new reflex for people agents: stay.   Modify the move reflex of the people agents.   Model Definition  global section  global variables  In this model, we want that people agents move from buildings to buildings by using the shortest path in the road network. In order to compute this shortest path, we need to use a graph structure.  We thus define a new global variable called road_network of type graph that will represent the road network.      global{  //… other attributes  graph road_network;  //... init }       In order to compute the graph from the road network, we use, just after having creating the road agents, the as_edge_graph operator. This operator automatically built a graph from a set of polylines. Each extremity point of the lines will become a node in the graph, and each polyline an edge. By default, the graph is not oriented and the weights of the edges are the perimeters of the polylines. It is of course possible to change through the use of some operators.      global {  // world variable definition  init{  create road from: roads_shapefile;  road_network <- as_edge_graph(road);  create building from: buildings_shapefile;  create people number:nb_people {   my_home <- one_of(building);   location <- any_location_in(my_home);  }  ask nb_infected_init among people {   is_infected <- true;  }  } }       people species  We want to modify the behavior of the people agents in order to make them move from buildings to buildings by using the shortest path in the road network. In addition, we want to integrate the fact that people will stay in the building a certain time before moving to another building. This staying time will depend if the agent is in its house or in another house (different probabilities of moving).  variables In order to implement this behavior, we will add two variables to our people species:    * target of type point that will be the location where the agent wants to go    * in_my_house of type bool that will just say if the agent is in its house or not. At the beginning the agent will be in its house, so we initialize this variable by true.   species people skills:[moving]{  //...the other attributes  point target;  bool in_my_house <- true;  //.... }   behavior  First, we add a new reflex called stay that will be activated when the agent is in a house (i.e. its target is null) and that will define if the agent has to go or not. If the agent has to go, it will randomly choose a new target (a random location inside one of the building). We define two probabilities of moving: 0.01 if the agent is in its house, 0.1 otherwise (more chance to move if the agent is not in its house).  reflex stay when: target = nil {  if flip(in_my_house ? 0.01 : 0.1) {   building bd_target <- in_my_house ? one_of(building) : my_house;   target <- any_location_in (bd_target);   in_my_house <- not in_my_house;  } }   Then, we modify the move reflex. This one will be only activated when the agent will have to move (target not null). Instead of using the wander action of the moving skill, we use the goto one that allows to make an agent moves toward a given target. In addition, it is possible to add a facet on to precise on which topology the agent will have to move on. In our case, the topology is the road network. When the agent reach its destination (location = target), it sets its target to null.   reflex move when: target != nil{  do goto target:target on: road_network;  if (location = target) {   target <- nil;  }  }  ## Complete Model      model SI_city4  global{   int nb_people <- 2147;  int nb_infected_init <- 5;  float step <- 1 #mn;  file roads_shapefile <- file( ../includes/roads.shp );  file buildings_shapefile <- file( ../includes/buildings.shp );  geometry shape <- envelope(roads_shapefile);  int nb_people_infected <- nb_infected_init update: people count (each.is_infected);  int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;  float infected_rate update: nb_people_infected/nb_people;  graph road_network;  init{  create road from: roads_shapefile;  road_network <- as_edge_graph(road);  create building from: buildings_shapefile;  create people number:nb_people {   my_house <- one_of(building);   location <- any_location_in(my_house);  }  ask nb_infected_init among people {   is_infected <- true;  } }  reflex end_simulation when: infected_rate = 1.0 {  do pause; } }   species people skills:[moving]{    float speed <- (2 + rnd(3)) #km/#h;  bool is_infected <- false;  building my_house;  point target;  bool in_my_house <- true;  reflex stay when: target = nil {  if flip(in_my_house ? 0.01 : 0.1) {   building bd_target <- in_my_house ? one_of(building) : my_house;   target <- any_location_in (bd_target);   in_my_house <- not in_my_house;  } }   reflex move when: target != nil{  do goto target:target on: road_network;  if (location = target) {   target <- nil;  }  } reflex infect when: is_infected{  ask people at_distance 10 #m {   if flip(0.05) {    is_infected <- true;   }  } } aspect circle{  draw circle(10) color:is_infected ? #red : #green; } }   species road {  aspect geom {   draw shape color: #black;  } }  species building {  aspect geom {   draw shape color: #gray;  } }  experiment main_experiment type:gui{  parameter  Nb people infected at init  var: nb_infected_init min: 1 max: 2147;  output {   monitor  Infected people rate  value: infected_rate;   display map type: opengl{   species road aspect:geom;   species building aspect:geom;   species people aspect:circle;     }    display chart refresh:every(10) {   chart Disease spreading type: series {    data susceptible value: nb_people_not_infected color: #green;    data infected value: nb_people_infected color: #red;   }  } } }       Next step: Definition of 3D displays ","url":"wiki/LuneraysFlu_step4.md"},{"id":"wiki/LuneraysFlu_step5.md","title":" 5. Definition of 3D displays","content":"5. Definition of 3D displays This fifth step illustrates how to define 3D displays    Formulation    Define a new 3D aspect for roads.   Define a new 3D aspect for buildings   Define a new 3D aspect for people   Define a new 3D display   Model Definition  species  First, we add a new variable called display_shape of type geometry for road agent that is a tube of 2m radius built from its geometry. Note that it is possible to get the list of points composing a geometry by using the points variable of the geometry. We define then an aspect called geom3D that draws the previous geometry in black.        species road {  geometry display_shape <- line(shape.points, 2.0);  //.... aspect geom3D {  draw display_shape color: #black; } }       Concerning the building species, we add a new variable called height of type float that is initialized by a random value between 20 and 40 meters. We define then an aspect called geom3D that draws the shape of the building with a depth of height and with using a texture ( texture.jpg  that is located inside the includes folder).     species building {  float height <- 20#m + rnd(20) #m;  //....  aspect geom3D {   draw shape depth: height texture:[../includes/texture.jpg];  } }  At last, we define a new aspect called geom3D for the people species that draws first a pyramid of 5 meters size, then a sphere of radius 2 meters at a height of 5m (z = 5). Note that it is possible to access the coordinates of a point by using the x, y and z variables. In GAMA, a point can be defined by using the format {x_value,y_value,z_value}.     species people skills:[moving]{    //....  aspect geom3D{   draw pyramid(5) color: is_infected ? #red : #green;   draw sphere(2) at: {location.x,location.y,5} color: is_infected ? #red : #green;   } }   output  We define a new display called map_3D of type opengl with an ambient_light of 120 that displays first a image ( soil.jpg ), then the road with the geom3D aspect, then the building with the geom3D aspect, and finally the people with the geom3D aspect. All layers except the people s one will not be refreshed (refresh set to false).   experiment main_experiment type: gui {  output {  // monitor and other displays    display map_3D type: opengl ambient_light: 120 {    image ../includes/soil.jpg refresh: false;    species road aspect:geom3D refresh: false;    species building aspect:geom3D refresh: false;    species people aspect:geom3D;      }  } }  ## Complete Model      model SI_city5  global{   int nb_people <- 2147;  int nb_infected_init <- 5;  float step <- 1 #mn;  file roads_shapefile <- file( ../includes/roads.shp );  file buildings_shapefile <- file( ../includes/buildings.shp );  geometry shape <- envelope(roads_shapefile);  int nb_people_infected <- nb_infected_init update: people count (each.is_infected);  int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;  float infected_rate update: nb_people_infected/nb_people;  graph road_network;  init{  create road from: roads_shapefile;  road_network <- as_edge_graph(road);  create building from: buildings_shapefile;  create people number:nb_people {   my_house <- one_of(building);   location <- any_location_in(my_house);  }  ask nb_infected_init among people {   is_infected <- true;  } }  reflex end_simulation when: infected_rate = 1.0 {  do pause; } }   species people skills:[moving]{    float speed <- (2 + rnd(3)) #km/#h;  bool is_infected <- false;  building my_house;  point target;  bool in_my_house <- true;  reflex stay when: target = nil {  if flip(in_my_house ? 0.01 : 0.1) {   building bd_target <- in_my_house ? one_of(building) : my_house;   target <- any_location_in (bd_target);   in_my_house <- not in_my_house;  } }   reflex move when: target != nil{  do goto target:target on: road_network;  if (location = target) {   target <- nil;  }  } reflex infect when: is_infected{  ask people at_distance 10 #m {   if flip(0.05) {    is_infected <- true;   }  } } aspect circle{  draw circle(10) color:is_infected ? #red : #green; } aspect geom3D{  draw pyramid(5) color: is_infected ? #red : #green;  draw sphere(2) at: {location.x,location.y,5} color: is_infected ? #red : #green;  }   }  species road {  geometry display_shape <- line(shape.points, 2.0);  aspect geom {  draw shape color: #black; } aspect geom3D {  draw display_shape color: #black; } }   species building {  float height <- 20#m + rnd(20) #m;  aspect geom {  draw shape color: #gray; } aspect geom3D {  draw shape depth: height texture:[../includes/texture.jpg]; }   }  experiment main_experiment type:gui{  parameter  Nb people infected at init  var: nb_infected_init min: 1 max: 2147;  output {   monitor  Infected people rate  value: infected_rate;   display map type: opengl{   species road aspect:geom;   species building aspect:geom;   species people aspect:circle;     }    display map_3D type: opengl ambient_light: 120 {   image ../includes/soil.jpg refresh: false;   species road aspect:geom3D refresh: false;   species building aspect:geom3D refresh: false;   species people aspect:geom3D;     }   display chart refresh:every(10) {   chart Disease spreading type: series {    data susceptible value: nb_people_not_infected color: #green;    data infected value: nb_people_infected color: #red;   }  } } }      ","url":"wiki/LuneraysFlu_step5.md"},{"id":"wiki/PredatorPrey_step1.md","title":" 1. Basic Model","content":"1. Basic Model This first step Illustrates how to write a model in GAMA. In particular, it describes how to structure a model and how to define species - that are the key components of GAMA models. ## Content  Formulation    Definition of the prey species   Definition of a nb_prey_init parameter   Creation of nb_prey_init prey agents randomly located in the environment (size: 100x100)   Model Definition  model structure A GAMA model is composed of three type of sections:   * global : this section, that is unique, defines the  world  agent, a special agent of a GAMA model. It represents all that is global to the model: dynamics, variables, actions. In addition, it allows to initialize the simulation (init block).   * species and grid: these sections define the species of agents composing the model. Grid are defined in the following model step  vegetation dynamic ;   * experiment : these sections define a context of execution of the simulations. In particular, it defines the input (parameters) and output (displays, files…) of a model.  More details about the different sections of a GAMA model can be found here.  species A species represents a «prototype» of agents: it defines their common properties.  A species definition requires the definition of three different elements :   * the internal state of its agents (attributes)   * their behavior   * how they are displayed (aspects)  Internal state An attribute is defined as follows: type of the attribute  and name. Numerous types of attributes are available: int (integer), float (floating point number), string, bool (boolean, true or false), point (coordinates), list, pair, map, file, matrix, espèce d agents, rgb (color), graph, path…   * Optional facets: <- (initial value), update (value recomputed at each step of the simulation), function:{..} (value computed each time the variable is used), min, max  In addition to the attributes the modeler explicitly defines, species  inherits  other attributes called  built-in  variables:   * A name (name): the identifier of the species   * A shape (shape): the default shape of the agents to be construct after the species. It can be a point, a polygon, etc.   * A location (location) : the centroid of its shape.  Behavior In this first model, we define one species of agents: the prey agents. For the moment, these agents will not have a particular behavior, they will just exist and be displayed.  Display An agent aspects have to be defined. An aspect is a way to display the agents of a species : aspect aspect_name {…} In the block of an aspect, it is possible to draw :   * A geometry :  for instance, the shape of the agent (but it may be a different one, for instance a disk instead of a complex polygon)   * An image : to draw icons   * A text : to draw a text  In order to display our prey agents we define two attributes:   * size of type float, with for initial value: 1.0   * color of type rgb, with for initial value:  blue . It is possible to get a color value by using the symbol # + color name: e.g. #blue, #red, #white, #yellow, #magenta, #pink…  Prey species code For the moment, we only define an aspect for this species. We want to display for each prey agent a circle of radius size and color color. We then use the keyword draw with a circle shape.      species prey {  float size <- 1.0 ;  rgb color <- #blue;  aspect base {  draw circle(size) color: color ; } }        global section The global section represents a specific agent, called world. Defining this agent follows the same principle as any agent and is, thus, defined after a species. The world agent represents everything that is global to the model : dynamics, variables… It allows to initialize simulations (init block): the world is always created and initialized first when a simulation is launched (before any other agents). The geometry (shape) of the world agent is by default a square with 100m for side size, but can be redefined if necessary (see the Road traffic tutorial).  global variable In the current model, we will only have a certain numbers of preys thus we need to hold this number in a global or world s variable of type integer (int) which can be done as follows:  global {    int nb_preys_init <- 200; }   Model initialization  The init section of the global block allows to initialize the model which is executing certain commands, here we will create nb_preys_init number of prey agents. We use the statement create  to create agents of a specific species: create species_name + :   * number : number of agents to create (int, 1 by default)   * from : GIS file to use to create the agents (optional, string or file)   * returns: list of created agents (list)  Definition of the init block in order to create nb_preys_init prey agents:     init {       create prey number: nb_preys_init ;    }   experiment An experiment block defines how a model can be simulated (executed). Several experiments can be defined for a given model. They are defined using : experiment exp_name type: gui/batch {[input] [output]}   * gui : experiment with a graphical interface, which displays its input parameters and outputs.   * batch : Allows to setup a series of simulations (w/o graphical interface).  In our model, we define a gui experiment called prey_predator  :  experiment prey_predator type: gui { }   input Experiments can define (input) parameters. A parameter definition allows to make the value of a global variable definable by the user through the graphic interface.  A parameter is defined as follows: parameter title var: global_var category: cat;   * title : string to display   * var : reference to a global variable (defined in the global section)   * category : string used to «store» the operators on the UI - optional   * <- : init value - optional   * min : min value - optional   * max : min value - optional  Note that the init, min and max values can be defined in the global variable definition.  In the experiment, definition of a parameter from the the global variable nb_preys_init :  experiment prey_predator type: gui {    parameter Initial number of preys:  var: nb_preys_init min: 1 max: 1000 category: Prey ; }   output Output blocks are defined in an experiment and define how to visualize a simulation (with one or more display blocks that define separate windows). Each display can be refreshed independently by defining the facet refresh_every: nb (int) (the display will be refreshed every nb steps of the simulation).  Each display can include different layers (like in a GIS) :   * Agents lists : agents layer_name value: agents_list aspect: my_aspect;   * Agents species : species  my_species aspect: my_aspect   * Images: image layer_name file: image_file;   * Texts : texte layer_name value: my_text;   * Charts : see later.  Note that it is possible to define a opengl display (for 3D display) by using the facet type: opengl.  In our model, we define a display to draw the prey agents.   output {       display main_display {   species prey aspect: base ;       }    }   Complete Model      model prey_predator  global {  int nb_preys_init <- 200;  init {   create prey number: nb_preys_init ;  } }  species prey {  float size <- 1.0 ;  rgb color <- #blue;  aspect base {  draw circle(size) color: color ; } }    experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init min: 1 max: 1000 category:  Prey  ;  output {   display main_display {    species prey aspect: base ;   }  } }     ","url":"wiki/PredatorPrey_step1.md"},{"id":"wiki/PredatorPrey_step10.md","title":" 10. Charts","content":"10. Charts This 10th step Illustrates how to define charts.  Formulation    Adding a new display to visualize:  One chart representing the evolution of the quantity of prey and predator agents over the time       Two histograms representing the energy distribution of the prey and predator agents Model Definition  output  GAMA can display various chart types:   * Time series   * Pie charts   * Histograms  A chart must be defined in a display : it behaves exactly like any other layer. Definition of a chart :   chart chart_name type: chart_type  {      [data] }   The data to draw are define inside the chart block as follow:        data data_legend value: data_value   We add a new display called Population_information that refreshes every 5 simulation steps. Inside this display, we define 3 charts: one of type series (i.e. time series chart), two of type histogram :   *  Species evolution ; background : white; size : {1, 0.5}; position : {0, 0}     * data1: number_of_preys; color : blue     * data2: number_of_predator; color : red      Prey Energy Distribution ; background : lightGray; size : {0.5, 0.5}; position : {0, 0.5}  data  ]0;0.25]  : number of preys with (each.energy <= 0.25) ;       data  ]0.25;0.5]  number of preys with ((each.energy > 0.25) and (each.energy <= 0.5)) ;       data  ]0.5;0.75]  number of preys with ((each.energy > 0.5) and (each.energy <= 0.75)) ;       data  ]0.75;1]  number of preys with  (each.energy > 0.75) ;  Predator Energy Distribution ; background : lightGray; size : {0.5, 0.5}; position : {0.5, 0.5}  data  ]0;0.25]  : number of predators with (each.energy <= 0.25) ;       data  ]0.25;0.5]  number of predators with ((each.energy > 0.25) and (each.energy <= 0.5)) ;       data  ]0.5;0.75]  number of predators with ((each.energy > 0.5) and (each.energy <= 0.75)) ;       data  ]0.75;1]  number of predators with  (each.energy > 0.75) ; To evaluate the value of the data of the two histogram, we use the operator list count condition  that returns the number of elements oflistfor which the condition is true.   display Population_information refresh:every(5) {  chart Species evolution type: series size: {1,0.5} position: {0, 0} {   data number_of_preys value: nb_preys color: #blue ;   data number_of_predator value: nb_predators color: #red ;  }  chart Prey Energy Distribution type: histogram background: rgb(white) size: {0.5,0.5} position: {0, 0.5} {   data ]0;0.25] value: prey count (each.energy <= 0.25) color:#blue;   data ]0.25;0.5] value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;   data ]0.5;0.75] value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;   data ]0.75;1] value: prey count (each.energy > 0.75) color:#blue;  }  chart Predator Energy Distribution type: histogram background: rgb(white) size: {0.5,0.5} position: {0.5, 0.5} {   data ]0;0.25] value: predator count (each.energy <= 0.25) color: #red ;   data ]0.25;0.5] value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red ;   data ]0.5;0.75] value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red ;   data ]0.75;1] value: predator count (each.energy > 0.75) color: #red;  } }   Complete Model      model prey_predator  global {  int nb_preys_init <- 200;  int nb_predators_init <- 20;  float prey_max_energy <- 1.0;  float prey_max_transfert <- 0.1 ;  float prey_energy_consum <- 0.05;  float predator_max_energy <- 1.0;  float predator_energy_transfert <- 0.5;  float predator_energy_consum <- 0.02;  float prey_proba_reproduce <- 0.01;  int prey_nb_max_offsprings <- 5;   float prey_energy_reproduce <- 0.5;   float predator_proba_reproduce <- 0.01;  int predator_nb_max_offsprings <- 3;  float predator_energy_reproduce <- 0.5;  int nb_preys -> {length (prey)}; int nb_predators -> {length (predator)};  init {  create prey number: nb_preys_init ;   create predator number: nb_predators_init ; }  reflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {  do halt ; }  }   species generic_species {  float size <- 1.0;  rgb color  ;  float max_energy;  float max_transfert;  float energy_consum;  float proba_reproduce ;  float nb_max_offsprings;  float energy_reproduce;  file my_icon;  vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;  init {  location <- myCell.location; }   reflex basic_move {  myCell <- choose_cell();  location <- myCell.location;  }   vegetation_cell choose_cell {  return nil; }   reflex die when: energy <= 0 {  do die ; }  reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {  int nb_offsprings <- 1 + rnd(nb_max_offsprings -1);  create species(self) number: nb_offsprings {   myCell <- myself.myCell ;   location <- myCell.location ;   energy <- myself.energy / nb_offsprings ;  }  energy <- energy / nb_offsprings ; }  aspect base {  draw circle(size) color: color ; } aspect icon {  draw my_icon size: 2 * size ; } aspect info {  draw square(size) color: color ;  draw string(energy with_precision 2) size: 3 color: #black ; } }   species prey parent: generic_species {  rgb color <- #blue;  float max_energy <- prey_max_energy ;  float max_transfert <- prey_max_transfert ;  float energy_consum <- prey_energy_consum ;  float proba_reproduce <- prey_proba_reproduce ;  int nb_max_offsprings <- prey_nb_max_offsprings ;  float energy_reproduce <- prey_energy_reproduce ;  file my_icon <- file( ../images/predator_prey_sheep.png ) ;  reflex eat when: myCell.food > 0 {  float energy_transfert <- min([max_transfert, myCell.food]) ;  myCell.food <- myCell.food - energy_transfert ;  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  return (myCell.neighbours) with_max_of (each.food); } }   species predator parent: generic_species {  rgb color <- #red ;  float max_energy <- predator_max_energy ;  float energy_transfert <- predator_energy_transfert ;  float energy_consum <- predator_energy_consum ;  list reachable_preys update: prey inside (myCell);  float proba_reproduce <- predator_proba_reproduce ;  int nb_max_offsprings <- predator_nb_max_offsprings ;  float energy_reproduce <- predator_energy_reproduce ;  file my_icon <- file(../images/predator_prey_wolf.png) ;  reflex eat when: ! empty(reachable_preys) {  ask one_of (reachable_preys) {   do die ;  }  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  vegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));  if myCell_tmp != nil {   return myCell_tmp;  } else {   return one_of (myCell.neighbours);  }  } }   grid vegetation_cell width: 50 height: 50 neighbours: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;  list neighbours  <- (self neighbours_at 2);  }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init  min: 0 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfert:   var: prey_max_transfert  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  parameter  Initial number of predators:   var: nb_predators_init  min: 0 max: 200 category:  Predator  ;  parameter  Predator max energy:   var: predator_max_energy category:  Predator  ;  parameter  Predator energy transfert:   var: predator_energy_transfert  category:  Predator  ;  parameter  Predator energy consumption:   var: predator_energy_consum  category:  Predator  ;  parameter  Prey probability reproduce:   var: prey_proba_reproduce category:  Prey  ;  parameter  Prey nb max offsprings:   var: prey_nb_max_offsprings category:  Prey  ;  parameter  Prey energy reproduce:   var: prey_energy_reproduce category:  Prey  ;  parameter  Predator probability reproduce:   var: predator_proba_reproduce category:  Predator  ;  parameter  Predator nb max offsprings:   var: predator_nb_max_offsprings category:  Predator  ;  parameter  Predator energy reproduce:   var: predator_energy_reproduce category:  Predator  ;  output {  display main_display {   grid vegetation_cell lines: #black ;   species prey aspect: icon ;   species predator aspect: icon ;  }  display info_display {   grid vegetation_cell lines: #black ;   species prey aspect: info ;   species predator aspect: info ;  }  display Population_information refresh:every(5) {   chart Species evolution type: series size: {1,0.5} position: {0, 0} {    data number_of_preys value: nb_preys color: #blue ;    data number_of_predator value: nb_predators color: #red ;   }   chart Prey Energy Distribution type: histogram background: rgb(lightGray) size: {0.5,0.5} position: {0, 0.5} {    data ]0;0.25] value: prey count (each.energy <= 0.25) color:#blue;    data ]0.25;0.5] value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;    data ]0.5;0.75] value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;    data ]0.75;1] value: prey count (each.energy > 0.75) color:#blue;   }   chart Predator Energy Distribution type: histogram background: rgb(lightGray) size: {0.5,0.5} position: {0.5, 0.5} {    data ]0;0.25] value: predator count (each.energy <= 0.25) color: #red ;    data ]0.25;0.5] value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red ;    data ]0.5;0.75] value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red ;    data ]0.75;1] value: predator count (each.energy > 0.75) color: #red;   }  }  monitor Number of preys value: nb_preys;  monitor Number of predators value: nb_predators; } }      ","url":"wiki/PredatorPrey_step10.md"},{"id":"wiki/PredatorPrey_step11.md","title":" 11. Writing Files","content":"11. Writing Files This 11th step Illustrates how to save data in a text file.  Formulation    At each simulation step, write in a text file:  The time step       The number of prey and predator agents       The min and max energy of the prey and predator agents Model Definition  global section GAMA provides several ways to write file.  A first ways consist in using the statement file in the output section: at each simulation step, the expression given is written in the given file.     file file_name type: file_type data: data_to_write;     With:   * file_name: string (by default the file in saved in the /models/ of your project directory)   * file_type: string  There are 2 possible types :   *  txt  (text) : in that case, my_data is treated as a string, which is written directly in the file   *  csv  : in that case, my_data is treated as a list of variables to write : [ var1 ,  var2 ,  var3 ].  A second way to write file consists in using the save statement:     save my_data type: file_type to: file_name;    With:   * file_type : string   * file_name : string  There are 3 possible types :   *  shp  (shapefile - GIS data) : in that case, my_data is treated as a list of agents : all their geometries are saved in the file (with some variables as attributes)   *  txt  (text) : in that case, my_data is treated as a string, which is written directly in the file   *  csv  : in that case, my_data is treated as a list of values : [val1, val2, val3].  We use this statement (in a global reflex called save_result) to write:   * The cycle step: use of the cycle keyword that returns the current simulation step.   * The number of prey and predator agents: use of nb_preys and nb_predators variables   * The min and max energy of the prey and predator agents: use of list min_of expression and list max_of expression keywords. In addition, we verify with the tertiary operator (condition ? val_if : val_else).  reflex save_result when: (nb_preys > 0) and (nb_predators > 0){  save (cycle: + cycle + ; nbPreys:  + nb_preys   + ; minEnergyPreys:  + ((prey as list) min_of each.energy)   + ; maxSizePreys:  + ((prey as list) max_of each.energy)       + ; nbPredators:  + nb_predators       + ; minEnergyPredators:  + ((predator as list) min_of each.energy)      + ; maxSizePredators:  + ((predator as list) max_of each.energy))       to: results.txt type: text ; }   Complete Model      model prey_predator  global {  int nb_preys_init <- 200;  int nb_predators_init <- 20;  float prey_max_energy <- 1.0;  float prey_max_transfert <- 0.1 ;  float prey_energy_consum <- 0.05;  float predator_max_energy <- 1.0;  float predator_energy_transfert <- 0.5;  float predator_energy_consum <- 0.02;  float prey_proba_reproduce <- 0.01;  int prey_nb_max_offsprings <- 5;   float prey_energy_reproduce <- 0.5;   float predator_proba_reproduce <- 0.01;  int predator_nb_max_offsprings <- 3;  float predator_energy_reproduce <- 0.5;  int nb_preys -> {length (prey)}; int nb_predators -> {length (predator)};  init {  create prey number: nb_preys_init ;   create predator number: nb_predators_init ; }  reflex save_result when: (nb_preys > 0) and (nb_predators > 0){  save (cycle: + cycle + ; nbPreys:  + nb_preys   + ; minEnergyPreys:  + ((prey as list) min_of each.energy)   + ; maxSizePreys:  + ((prey as list) max_of each.energy)       + ; nbPredators:  + nb_predators       + ; minEnergyPredators:  + ((predator as list) min_of each.energy)      + ; maxSizePredators:  + ((predator as list) max_of each.energy))       to: results.txt type: text ; }  reflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {  do halt ; }  }   species generic_species {  float size <- 1.0;  rgb color  ;  float max_energy;  float max_transfert;  float energy_consum;  float proba_reproduce ;  float nb_max_offsprings;  float energy_reproduce;  file my_icon;  vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;  init {  location <- myCell.location; }   reflex basic_move {  myCell <- choose_cell();  location <- myCell.location;  }   vegetation_cell choose_cell {  return nil; }   reflex die when: energy <= 0 {  do die ; }  reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {  int nb_offsprings <- 1 + rnd(nb_max_offsprings -1);  create species(self) number: nb_offsprings {   myCell <- myself.myCell ;   location <- myCell.location ;   energy <- myself.energy / nb_offsprings ;  }  energy <- energy / nb_offsprings ; }  aspect base {  draw circle(size) color: color ; } aspect icon {  draw my_icon size: 2 * size ; } aspect info {  draw square(size) color: color ;  draw string(energy with_precision 2) size: 3 color: #black ; } }   species prey parent: generic_species {  rgb color <- #blue;  float max_energy <- prey_max_energy ;  float max_transfert <- prey_max_transfert ;  float energy_consum <- prey_energy_consum ;  float proba_reproduce <- prey_proba_reproduce ;  int nb_max_offsprings <- prey_nb_max_offsprings ;  float energy_reproduce <- prey_energy_reproduce ;  file my_icon <- file( ../images/predator_prey_sheep.png ) ;  reflex eat when: myCell.food > 0 {  float energy_transfert <- min([max_transfert, myCell.food]) ;  myCell.food <- myCell.food - energy_transfert ;  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  return (myCell.neighbours) with_max_of (each.food); } }   species predator parent: generic_species {  rgb color <- #red ;  float max_energy <- predator_max_energy ;  float energy_transfert <- predator_energy_transfert ;  float energy_consum <- predator_energy_consum ;  list reachable_preys update: prey inside (myCell);  float proba_reproduce <- predator_proba_reproduce ;  int nb_max_offsprings <- predator_nb_max_offsprings ;  float energy_reproduce <- predator_energy_reproduce ;  file my_icon <- file(../images/predator_prey_wolf.png) ;  reflex eat when: ! empty(reachable_preys) {  ask one_of (reachable_preys) {   do die ;  }  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  vegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));  if myCell_tmp != nil {   return myCell_tmp;  } else {   return one_of (myCell.neighbours);  }  } }   grid vegetation_cell width: 50 height: 50 neighbours: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;  list neighbours  <- (self neighbours_at 2);  }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init  min: 0 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfert:   var: prey_max_transfert  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  parameter  Initial number of predators:   var: nb_predators_init  min: 0 max: 200 category:  Predator  ;  parameter  Predator max energy:   var: predator_max_energy category:  Predator  ;  parameter  Predator energy transfert:   var: predator_energy_transfert  category:  Predator  ;  parameter  Predator energy consumption:   var: predator_energy_consum  category:  Predator  ;  parameter  Prey probability reproduce:   var: prey_proba_reproduce category:  Prey  ;  parameter  Prey nb max offsprings:   var: prey_nb_max_offsprings category:  Prey  ;  parameter  Prey energy reproduce:   var: prey_energy_reproduce category:  Prey  ;  parameter  Predator probability reproduce:   var: predator_proba_reproduce category:  Predator  ;  parameter  Predator nb max offsprings:   var: predator_nb_max_offsprings category:  Predator  ;  parameter  Predator energy reproduce:   var: predator_energy_reproduce category:  Predator  ;  output {  display main_display {   grid vegetation_cell lines: #black ;   species prey aspect: icon ;   species predator aspect: icon ;  }  display info_display {   grid vegetation_cell lines: #black ;   species prey aspect: info ;   species predator aspect: info ;  }  display Population_information refresh:every(5) {   chart Species evolution type: series size: {1,0.5} position: {0, 0} {    data number_of_preys value: nb_preys color: #blue ;    data number_of_predator value: nb_predators color: #red ;   }   chart Prey Energy Distribution type: histogram background: rgb(lightGray) size: {0.5,0.5} position: {0, 0.5} {    data ]0;0.25] value: prey count (each.energy <= 0.25) color:#blue;    data ]0.25;0.5] value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;    data ]0.5;0.75] value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;    data ]0.75;1] value: prey count (each.energy > 0.75) color:#blue;   }   chart Predator Energy Distribution type: histogram background: rgb(lightGray) size: {0.5,0.5} position: {0.5, 0.5} {    data ]0;0.25] value: predator count (each.energy <= 0.25) color: #red ;    data ]0.25;0.5] value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red ;    data ]0.5;0.75] value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red ;    data ]0.75;1] value: predator count (each.energy > 0.75) color: #red;   }  }  monitor Number of preys value: nb_preys;  monitor Number of predators value: nb_predators; } }      ","url":"wiki/PredatorPrey_step11.md"},{"id":"wiki/PredatorPrey_step12.md","title":" 12. Image loading","content":"12. Image loading This 12th step illustrates how to load an image file and to use it to initialize a grid.  Formulation    Building of the initial environment (food and foodProd of the cells) from a image file   Model Definition ### global variable  We add a new global variable: the image file:   file map_init <- image_file(../images/predator_prey_raster_map.png);   The image file is here:   You have to copy it in your project folder: images/  model initialization In order to have a more complex environment, we want to use this image as the initialization of the environment. The food level available in a vegetation_cell will be based on the green level of the corresponding pixel in the image. You will be able to use such process to represent existing real environment in your model. We modify the global init of the model in order to cast the image file in a matrix. We use for that the file as_matrix  {nb_cols, nb_lines} operator that allows to convert a file (image, csv) to a matrix composed of nb_cols columns and nb_lines lines.  Concerning the manipulation of matrix, it is possible to obtain the element [i,j] of a matrix by using my_matrix [i,j].  A  grid can be view as spatial matrix: each cell of a grid has two built-in variables grid_x and grid_y that represent the column and line indexes of the cell.     init {       create prey number: nb_preys_init ;       create predator number: nb_predators_init ;       matrix init_data <- map_init as_matrix {50,50};       ask vegetation_cell {   color <- rgb (init_data[grid_x,grid_y]) ;   food <- 1 - ((color as list)[0] / 255) ;   foodProd <- food / 100 ;       }    }   Conclusion Congratulations, you have complete your first GAMA models! Now, you know have enough knowledge to create many models that includes: dynamic grid-based environment, moving and interacting agents and the needed viusalization to make good use of your simulation. Feel free to use this knowledge to create your very own models! Or perhaps you want to continue your study with the more advanced tutorials?  Complete Model      model prey_predator  global {  int nb_preys_init <- 200;  int nb_predators_init <- 20;  float prey_max_energy <- 1.0;  float prey_max_transfert <- 0.1 ;  float prey_energy_consum <- 0.05;  float predator_max_energy <- 1.0;  float predator_energy_transfert <- 0.5;  float predator_energy_consum <- 0.02;  float prey_proba_reproduce <- 0.01;  int prey_nb_max_offsprings <- 5;   float prey_energy_reproduce <- 0.5;   float predator_proba_reproduce <- 0.01;  int predator_nb_max_offsprings <- 3;  float predator_energy_reproduce <- 0.5;  file map_init <- image_file( ../images/predator_prey_raster_map.png );  int nb_preys -> {length (prey)}; int nb_predators -> {length (predator)};  init {  create prey number: nb_preys_init ;   create predator number: nb_predators_init ;  ask vegetation_cell {   color <- rgb (map_init at {grid_x,grid_y}) ;   food <- 1 - (((color as list)[0]) / 255) ;   foodProd <- food / 100 ;   } }  reflex save_result when: (nb_preys > 0) and (nb_predators > 0){  save (cycle: + cycle + ; nbPreys:  + nb_preys   + ; minEnergyPreys:  + ((prey as list) min_of each.energy)   + ; maxSizePreys:  + ((prey as list) max_of each.energy)       + ; nbPredators:  + nb_predators       + ; minEnergyPredators:  + ((predator as list) min_of each.energy)      + ; maxSizePredators:  + ((predator as list) max_of each.energy))       to: results.txt type: text ; }  reflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {  do halt ; }  }   species generic_species {  float size <- 1.0;  rgb color  ;  float max_energy;  float max_transfert;  float energy_consum;  float proba_reproduce ;  float nb_max_offsprings;  float energy_reproduce;  file my_icon;  vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;  init {  location <- myCell.location; }   reflex basic_move {  myCell <- choose_cell();  location <- myCell.location;  }   vegetation_cell choose_cell {  return nil; }   reflex die when: energy <= 0 {  do die ; }  reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {  int nb_offsprings <- 1 + rnd(nb_max_offsprings -1);  create species(self) number: nb_offsprings {   myCell <- myself.myCell ;   location <- myCell.location ;   energy <- myself.energy / nb_offsprings ;  }  energy <- energy / nb_offsprings ; }  aspect base {  draw circle(size) color: color ; } aspect icon {  draw my_icon size: 2 * size ; } aspect info {  draw square(size) color: color ;  draw string(energy with_precision 2) size: 3 color: #black ; } }   species prey parent: generic_species {  rgb color <- #blue;  float max_energy <- prey_max_energy ;  float max_transfert <- prey_max_transfert ;  float energy_consum <- prey_energy_consum ;  float proba_reproduce <- prey_proba_reproduce ;  int nb_max_offsprings <- prey_nb_max_offsprings ;  float energy_reproduce <- prey_energy_reproduce ;  file my_icon <- file( ../images/predator_prey_sheep.png ) ;  reflex eat when: myCell.food > 0 {  float energy_transfert <- min([max_transfert, myCell.food]) ;  myCell.food <- myCell.food - energy_transfert ;  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  return (myCell.neighbours) with_max_of (each.food); } }   species predator parent: generic_species {  rgb color <- #red ;  float max_energy <- predator_max_energy ;  float energy_transfert <- predator_energy_transfert ;  float energy_consum <- predator_energy_consum ;  list reachable_preys update: prey inside (myCell);  float proba_reproduce <- predator_proba_reproduce ;  int nb_max_offsprings <- predator_nb_max_offsprings ;  float energy_reproduce <- predator_energy_reproduce ;  file my_icon <- file(../images/predator_prey_wolf.png) ;  reflex eat when: ! empty(reachable_preys) {  ask one_of (reachable_preys) {   do die ;  }  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  vegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));  if myCell_tmp != nil {   return myCell_tmp;  } else {   return one_of (myCell.neighbours);  }  } }   grid vegetation_cell width: 50 height: 50 neighbours: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;  list neighbours  <- (self neighbours_at 2);  }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init  min: 0 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfert:   var: prey_max_transfert  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  parameter  Initial number of predators:   var: nb_predators_init  min: 0 max: 200 category:  Predator  ;  parameter  Predator max energy:   var: predator_max_energy category:  Predator  ;  parameter  Predator energy transfert:   var: predator_energy_transfert  category:  Predator  ;  parameter  Predator energy consumption:   var: predator_energy_consum  category:  Predator  ;  parameter  Prey probability reproduce:   var: prey_proba_reproduce category:  Prey  ;  parameter  Prey nb max offsprings:   var: prey_nb_max_offsprings category:  Prey  ;  parameter  Prey energy reproduce:   var: prey_energy_reproduce category:  Prey  ;  parameter  Predator probability reproduce:   var: predator_proba_reproduce category:  Predator  ;  parameter  Predator nb max offsprings:   var: predator_nb_max_offsprings category:  Predator  ;  parameter  Predator energy reproduce:   var: predator_energy_reproduce category:  Predator  ;  output {  display main_display {   grid vegetation_cell lines: #black ;   species prey aspect: icon ;   species predator aspect: icon ;  }  display info_display {   grid vegetation_cell lines: #black ;   species prey aspect: info ;   species predator aspect: info ;  }  display Population_information refresh:every(5) {   chart Species evolution type: series size: {1,0.5} position: {0, 0} {    data number_of_preys value: nb_preys color: #blue ;    data number_of_predator value: nb_predators color: #red ;   }   chart Prey Energy Distribution type: histogram background: rgb(lightGray) size: {0.5,0.5} position: {0, 0.5} {    data ]0;0.25] value: prey count (each.energy <= 0.25) color:#blue;    data ]0.25;0.5] value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;    data ]0.5;0.75] value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;    data ]0.75;1] value: prey count (each.energy > 0.75) color:#blue;   }   chart Predator Energy Distribution type: histogram background: rgb(lightGray) size: {0.5,0.5} position: {0.5, 0.5} {    data ]0;0.25] value: predator count (each.energy <= 0.25) color: #red ;    data ]0.25;0.5] value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red ;    data ]0.5;0.75] value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red ;    data ]0.75;1] value: predator count (each.energy > 0.75) color: #red;   }  }  monitor Number of preys value: nb_preys;  monitor Number of predators value: nb_predators; } }      ","url":"wiki/PredatorPrey_step12.md"},{"id":"wiki/PredatorPrey_step2.md","title":" 2. Vegetation Dynamic","content":"[IN PROGRESS] # 2. Vegetation Dynamic This second steps present the idea of environment or topological space. Defining a  vegetation  environment allows to define the movement of the preys through dynamic variables (use of the update facet). We will also discover more about displays.  Formulation    Definition of a grid (for the vegetation)   Definition of a dynamic for each cell (food production)   Display of the cell color according to the quantity of food   Localization of the prey agents on the cells (at its center)   Model Definition  grid  In GAMA, grids are specific agent species with a particular topology. First, a grid allow yet constrains the movement of other (moving) agents but they can have variables and behaviors.  A grid is defined as follows:     grid grid_name width: nb_cols height: nb_lines neighbors: 4/6/8 {       ...    }   With:   * width : number of cells along x-axis   * height : number of cells along y-axis   * neighbours : neighborhood type (4 - Von Neumann, 6 - hexagon or 8 - Moore)  In our model, we define a grid species, called vegetation_cell composed of 50x50 cells and with a Von Neumann neighborhood. In order for each grid agents (or cell of the grid) to represent the vegetation, we provide them with four variables:   * maxFood : maximum food that a cell can contain -> type: float ; init value: 1.0   * foodProd : food produced at each simulation step -> type: float ; init value: random number between 0 and 0.01   * food : current quantity of food -> type: float ; init value: random number between 0 and 1.0; at each simulation step : food <- food + foodProd   * color : color of the cell -> type: rgb ; init value: color computed according to the food value: more the food value is close to 1.0, greener the color is, more the food value is close to 0,  whiter the color is; update : computation of the new color depending on the current level of food (at each simulation step).  The update facet allows to give a behavior to the agents. Indeed, at each simulation step, each agent is activated (by default, in a random order) and first applies for each dynamic variable (in their definition order) its update expression. In the present case, it allows us to link the displayed color of the cell to its food level.     grid vegetation_cell width: 50 height: 50 neighbours: 4 {       float maxFood <- 1.0 ;       float foodProd <- (rnd(1000) / 1000) * 0.01 ;       float food <- (rnd(1000) / 1000) update: food + foodProd max: maxFood;       rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) ;    }   There are several ways to define colors in GAML:   * the simplest way consists in using the symbol # + the color name (for a limited set of  colors):     #blue    #red    * Another way consists in defining the 3 rgb integer values: rgb(red, green, blue) with red, green and blue between 0 and 255 (as we used in the current model.     rgb(0,0,0) : black ; rgb(255,255,255) : white    rgb(255,0,0) : red ;  rgb(0,255,0) : green ;  rgb(0,0,255) : blue   prey agents In order to relate our prey agents to the vegetation cell grid, we add them with one new variable : my_cell of type vegetation_cell and for init value one of the vegetation_cell (chosen randomly).      species prey {       ...       vegetation_cell myCell <- one_of (vegetation_cell) ;    }    It is possible to obtain the list of all agents of a given species by using the name of the species while one_of to pick one element randomly from this list.  We linked each prey agent to a vegetation_cell but we need to locate them onto the cell. To do so, we set the prey location as equals to the location of the vegetation cell (i.e. its centroid location), we use in the init block the <- statement that allows to modify the value of a variable :  species prey {      ...      init {   location <- myCell.location;      } }   display In order to visualize the vegetation , we need to add it to the display. We use for that the statement grid with the optional facet lines to draw the border of the cells. Note that grid agents have built-in aspect thus it is not necessary to define one.     output {       display main_display {   grid vegetation_cell lines: #black;   species prey aspect: base ;       }    }   Note that the layers in a display work like layers in a GIS; the drawing order will be respected. In our model, the prey agents will be drawn above the vegetation_cell grid thus they need to be declared afterward.  Complete Model      model prey_predator  global {  int nb_preys_init <- 200;  init {   create prey number: nb_preys_init ;  } }  species prey {  float size <- 1.0 ;  rgb color <- #blue;  vegetation_cell myCell <- one_of (vegetation_cell) ;  init {  location <- myCell.location; }   aspect base {  draw circle(size) color: color ; } }   grid vegetation_cell width: 50 height: 50 neighbours: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ; }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init min: 1 max: 1000 category:  Prey  ;  output {   display main_display {    grid vegetation_cell lines: #black ;    species prey aspect: base ;   }  } }     ","url":"wiki/PredatorPrey_step2.md"},{"id":"wiki/PredatorPrey_step3.md","title":" 3. Prey Agent Behavior","content":"3. Prey Agent Behavior This third step Illustrates how to define the behaviors of prey agents and the concept of spatial topology.  Formulation    Random movement of the prey agents to a distance of 2 cells (Von Neumann neighborhood)   At each step, the prey agents loss energy   At each step, the prey agents eat food if there is food on the cell on which they are localized (with a max of max_transfer) and gain energy   If a prey agent has no more energy, it dies   Model Definition  parameters To define a behavior for the prey agents we add them three new parameters:   * The max energy of the prey agents   * The maximum energy that can a prey agent consume from vegetation per tick   * The energy used by a prey agent at each time step  As we consider these parameters to be global to all prey, we define them in the  global section as follows:         float prey_max_energy <- 1.0;    float prey_max_transfer <- 0.1;    float prey_energy_consum <- 0.05;       Yet we may allow the user to change it from an experiment to another through the user interface. To do so we add the following definition of parameters within the experiment section :     parameter Prey max energy:  var: prey_max_energy category: Prey ;    parameter Prey max transfer:  var: prey_max_transfer  category: Prey ;    parameter Prey energy consumption:  var: prey_energy_consum  category: Prey ;   vegetation_cell grid We add a new variable for the vegetation_cell grid called neighbours, that contains for each vegetation cell the list of the neighbor vegetation cells (distance of 2 - Von Neumann neighborhood). We will use these neighbors list for the movement of the prey.     grid vegetation_cell width: 50 height: 50 neighbours: 4 {       ...       list<vegetation_cell> neighbours <- self neighbours_at 2;    }   Note that the result of the operator neighbours_at dist depends on the type of topology of the agent applying this operator:   * For a grid topology (grid species), the operator returns the neighbor cells (with a Von Neumann or Moore neighborhood).   * For a continuous topology, the operator returns the list of agents of which the shape is located at a distance equals or inferior dist meters to the agent shape.  Also note the use of the self pseudo variable which is a reference to the agent currently executing the statement  Prey agents  We copy the values of the three global parameters into the prey species in order for it to be available for each agent and possibly modified locally.  species prey {    ...    float max_energy <- prey_max_energy ;    float max_transfer <- prey_max_transfer ;    float energy_consum <- prey_energy_consum ;    ... }     The energy used by each prey at each timestep is randomly computed initially (within ]0;max_energy]).  species prey {    ...    float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;    ... }       In order to define the movement behaviour of a prey we will add a reflex. A reflex is a block of statements (that can be defined in global or any species) that will be automatically executed at each simulation step if its condition is true, it is defined as follows:     reflex reflex_name when: condition {...}   The when facet is optional: when it is omitted, the reflex is activated at each time step. Note that if several reflexes are defined for a species, the reflexes will be activated following their definition order.  We define a first reflex called basic_move that allows the prey agents to choose (randomly) a new vegetation_cell in the neighborhood of my_cell and to move to this cell.  species prey {    ...    reflex basic_move {  myCell <- one_of (myCell.neighbours) ; location <- myCell.location ;    } }   We define a second reflex called eat that will only be activated when there is food in my_cell and that will allows the prey agents to eat food and gain energy. In order to store the energy gain by the eating (that is equals to the minimum between the max_transfer value and the quantity of food available in myCell), we define a local variable called energy_transfer.  A local variable is a variable that will only exist within this block: once it has been executed, the variable is forgotten. To define it, we have to use the following statement:  var_type var_name <- value;    Thus, the reflex eat is defined by:  species prey {    ...    reflex eat when: myCell.food > 0 { float energy_transfer <- min([max_transfer, myCell.food]) ;       myCell.food <- myCell.food - energy_transfer ;       energy <- energy + energy_transfer ;    } }   We define a third reflex for the prey agent: when the agent has no more energy, it dies (application of the built-in die action):  species prey {    ...    reflex die when: energy <= 0 {       do die ;    } }   Note that an action is a capability available to the agents of a species (what they can do). It is a block of statements that can be used and reused whenever needed. Some actions, called primitives, are directly coded in Java: for instance, the die action defined for all the agents.   * An action can accept arguments. For instance, write takes an argument called message.   * An action can return a result.  There are two ways to call an action: using a statement or as part of an expression   * for actions that do not return a result:  do action_name arg1: v1 arg2: v2;      for actions that return a result:  my_var <- self action_name (arg1:v1, arg2:v2);    Complete Model      model prey_predator  global {  int nb_preys_init <- 200;  float prey_max_energy <- 1.0;  float prey_max_transfer <- 0.1;  float prey_energy_consum <- 0.05;  init {  create prey number: nb_preys_init ; } }   species prey {  float size <- 1.0 ;  rgb color <- #blue;  float max_energy <- prey_max_energy ;  float max_transfer <- prey_max_transfer ;  float energy_consum <- prey_energy_consum ;  vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;   init {   location <- myCell.location; }   reflex basic_move {   myCell <- one_of (myCell.neighbours) ;  location <- myCell.location ; } reflex eat when: myCell.food > 0 {   float energy_transfer <- min([max_transfer, myCell.food]) ;  myCell.food <- myCell.food - energy_transfer ;  energy <- energy + energy_transfer ; } reflex die when: energy <= 0 {  do die ; }  aspect base {  draw circle(size) color: color ; } }   grid vegetation_cell width: 50 height: 50 neighbours: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;  list neighbours  <- (self neighbours_at 2); }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init min: 1 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfer:   var: prey_max_transfer  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  output {   display main_display {    grid vegetation_cell lines: #black ;    species prey aspect: base ;   }  } }     ","url":"wiki/PredatorPrey_step3.md"},{"id":"wiki/PredatorPrey_step4.md","title":" 4. Inspectors and Monitors","content":"4. Inspectors and Monitors This fourth step Illustrates how to monitor more precisely the simulation. Practically, we will define monitors to follow the evolution of specific variables (or expression) whereas inspector allows to follow the state of a given agent (or a species).  Formulation    Adding of a monitor to follow the evolution of the number of prey agents   Model Definition  global variable We add a new global variable:   * nb_preys : returns, each time it is called, the current number of (live) prey agents  To do so we use the ->{expression} facet which returns the value of expression, each time it is called.. We use as well the operator length that returns the number of elements in a list.  Thus, In the global section, we add the nb_preys global variable:     int nb_preys -> {length (prey)};   monitor A monitor allows to follow the value of an arbitrary expression in GAML. It has to be defined in an output section. A monitor is defined as follows: monitor monitor_name value: an_expression refresh:every(nb_steps);   With:   * value: mandatory, its that value will be displayed in the monitor.   * refresh: bool, optional : if the expression is true, compute (default is true).  In this model, we define a monitor to follow the value of the variable nb_preys: monitor number of preys value: nb_preys;   inspector  Inspectors allow to obtain informations about a species or an agent. There are two kinds of agent information features:   * Species browser: provides informations about all the agents of a species. Available in the Agents menu.       Agent inspector: provides information about one specific agent. Also allows to change the values of its variables during the simulation. Available from the Agents menu, by right_clicking on a display, in the species inspector or when inspecting another agent. It provides also the possibility to «highlight» the inspected agent.     Complete Model      model prey_predator  global {  int nb_preys_init <- 200 ;  float prey_max_energy <- 1.0;  float prey_max_transfert <- 0.1;  float prey_energy_consum <- 0.05;  int nb_preys -> {length (prey)};  init {  create prey number: nb_preys_init ; } } species prey { float size <- 1.0 ; rgb color <- #blue; float max_energy <- prey_max_energy ; float max_transfert <- prey_max_transfert ; float energy_consum <- prey_energy_consum ;   vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;   init {   location <- myCell.location; }   reflex basic_move {   myCell <- one_of (myCell.neighbours) ;  location <- myCell.location ; } reflex eat when: myCell.food > 0 {   float energy_transfert <- min([max_transfert, myCell.food]) ;  myCell.food <- myCell.food - energy_transfert ;  energy <- energy + energy_transfert ; } reflex die when: energy <= 0 {  do die ; }  aspect base {  draw circle(size) color: color ; } }   grid vegetation_cell width: 50 height: 50 neighbours: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;  list neighbours  <- (self neighbours_at 2); }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init min: 1 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfert:   var: prey_max_transfert  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  output {   display main_display {    grid vegetation_cell lines: #black ;    species prey aspect: base ;   }   monitor  Number of preys  value: nb_preys ;  } }     ","url":"wiki/PredatorPrey_step4.md"},{"id":"wiki/PredatorPrey_step5.md","title":" 5. Predator Agent","content":"5. Predator Agent This fifth step Illustrates how to use parent species. Indeed,prey and predators share a few common features thus we will define a generic species that will regroup all the common elements (variables, behaviors and aspects) between the prey and the predator species.  Formulation    Definition of a new generic species: generic_species   Definition of a new species: predator   predator agents move randomly   At each simulation step, a predator agent can eat a prey that is localized at its grid cell   Model Definition  parameters  We add four new parameters related to predator agents:   * The init number of predator agents   * The max energy of the predator agents   * The energy gained by a predator agent while eating a prey agent   * The energy consumed by a predator agent at each time step  We define four new global variables in the global section:  global {    ...    int nb_predators_init <- 20;    float predator_max_energy <- 1.0;    float predator_energy_transfer <- 0.5;    float predator_energy_consum <- 0.02; }   We define then the four corresponding parameters in the experiment:     parameter Initial number of predators:  var: nb_predators_init min: 0 max: 200 category: Predator ;    parameter Predator max energy:  var: predator_max_energy category: Predator ;    parameter Predator energy transfer:  var: predator_energy_transfer  category: Predator ;    parameter Predator energy consumption:  var: predator_energy_consum  category: Predator ;   parent species  A species can have a parent species: it automatically get all the variables, skill and actions/reflex of the parent species  We define a species called generic_species that is the parent of the species prey and predator:    This species integrates all of the common feature between the prey and predotor species:   * the variables:     * size     * color     * max_energy     * max_transfer     * energy_consum     * myCell     * energy     the behaviors:  basic_move reflex       die reflex the aspect:  base aspect     species generic_species {  float size <- 1.0;  rgb color  ;  float max_energy;  float max_transfer;  float energy_consum;  vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;  init {  location <- myCell.location; }   reflex basic_move {  myCell <- one_of (myCell.neighbours) ;  location <- myCell.location ; }   reflex die when: energy <= 0 {  do die ; }  aspect base {  draw circle(size) color: color ; } }       prey species We specialize the prey species from the generic_species species:   * definition of the initial value of the agent variables   * definition of the eat reflex      species prey parent: generic_species {  rgb color <- #blue;  float max_energy <- prey_max_energy ;  float max_transfer <- prey_max_transfer ;  float energy_consum <- prey_energy_consum ;  reflex eat when: myCell.food > 0 {  float energy_transfer <- min([max_transfer, myCell.food]) ;  myCell.food <- myCell.food - energy_transfer ;  energy <- energy + energy_transfer ; } }       predator species As done for the prey species, we specialize the predator species from the generic_species species:   * definition of the initial value of the agent variables   * definition of a new variable reachable_preys consisting in the list of prey agents contains in myCell; compute at each simulation step (when the agent is activated).   * definition of the eat reflex: activated when reachable_preys is not empty; choose one of the element of this list, ask it to die; and update the predator energy.      species predator parent: generic_species {  rgb color <- #red ;  float max_energy <- predator_max_energy ;  float energy_transfer <- predator_energy_transfer ;  float energy_consum <- predator_energy_consum ;  list reachable_preys update: prey inside (myCell);  reflex eat when: ! empty(reachable_preys) {  ask one_of (reachable_preys) {   do die ;  }  energy <- energy + energy_transfer ; } }       Note that we used the ask statement. This statement allows to make a remote agent executes a list of statements. Use of the ask statement as follows:  ask one_agent or ask agents_list   We used as well the species/agent list inside geometry/agent operator. This operator returns all the agents of the specified species (or from the specified agent list) that are inside the given geometry or agent geometry.  global init block Like in the previous model, in the init block of the model, we create nb_predators_init.   global {    ...    init {       create prey number: nb_preys_init ;       create predator number: nb_predators_init ;    } }   monitor Like in the previous model, we define a monitor to display the number of predator agents.  Definition of a global variable nb_predator that returns the current number of predator agents:  global {    ...    int nb_predators -> {length (predator)};    ... }   Definition of the corresponding monitor:  monitor number of predators value: nb_predators ;   Complete Model      model prey_predator  global {  int nb_preys_init <- 200;  int nb_predators_init <- 20;  float prey_max_energy <- 1.0;  float prey_max_transfer <- 0.1 ;  float prey_energy_consum <- 0.05;  float predator_max_energy <- 1.0;  float predator_energy_transfer <- 0.5;  float predator_energy_consum <- 0.02;  int nb_preys -> {length (prey)};  int nb_predators -> {length (predator)};  init {  create prey number: nb_preys_init ;   create predator number: nb_predators_init ; } }   species generic_species {  float size <- 1.0;  rgb color  ;  float max_energy;  float max_transfer;  float energy_consum;  vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;  init {  location <- myCell.location; }   reflex basic_move {  myCell <- one_of (myCell.neighbours) ;  location <- myCell.location ; }   reflex die when: energy <= 0 {  do die ; }  aspect base {  draw circle(size) color: color ; } }   species prey parent: generic_species {  rgb color <- #blue;  float max_energy <- prey_max_energy ;  float max_transfer <- prey_max_transfer ;  float energy_consum <- prey_energy_consum ;  reflex eat when: myCell.food > 0 {  float energy_transfer <- min([max_transfer, myCell.food]) ;  myCell.food <- myCell.food - energy_transfer ;  energy <- energy + energy_transfer ; } }   species predator parent: generic_species {  rgb color <- #red ;  float max_energy <- predator_max_energy ;  float energy_transfer <- predator_energy_transfer ;  float energy_consum <- predator_energy_consum ;  list reachable_preys update: prey inside (myCell);  reflex eat when: ! empty(reachable_preys) {  ask one_of (reachable_preys) {   do die ;  }  energy <- energy + energy_transfer ; } }   grid vegetation_cell width: 50 height: 50 neighbours: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food)));  list neighbours  <- (self neighbours_at 2);  }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init  min: 0 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfer:   var: prey_max_transfer  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  parameter  Initial number of predators:   var: nb_predators_init  min: 0 max: 200 category:  Predator  ;  parameter  Predator max energy:   var: predator_max_energy category:  Predator  ;  parameter  Predator energy transfer:   var: predator_energy_transfer  category:  Predator  ;  parameter  Predator energy consumption:   var: predator_energy_consum  category:  Predator  ;  output {  display main_display {   grid vegetation_cell lines: #black ;   species prey aspect: base ;   species predator aspect: base ;  }  monitor Number of preys value: nb_preys;  monitor Number of predators value: nb_predators; } }      ","url":"wiki/PredatorPrey_step5.md"},{"id":"wiki/PredatorPrey_step6.md","title":" 6. Breeding","content":"6. Breeding So far we created agents only during the initialisation of the simulation. In this sixth step we Illustrate how to create new agents during a simulation of a dynamic species.  Formulation    Adding of a reproduce action of the prey and predator agents:  When a agent has energy enough, it has a certain probability to have a certain number of offspring       The energy of the offspring is equal to the parent energy divided by the number of offspring       The parent get the same energy as its offspring Model Definition  parameters  We add six new parameters related to breeding:   * The reproduction probability for prey agents   * The max number of offspring for prey agents   * The minimum energy to reproduce for prey agents   * The reproduction probability for predator agents   * The max number of offspring for predator agents   * The minimum energy to reproduce for predator agents  We define six new global variables in the global section:  global {    ...    float prey_proba_reproduce <- 0.01;    int prey_nb_max_offsprings <- 5;     float prey_energy_reproduce <- 0.5;     float predator_proba_reproduce <- 0.01;    int predator_nb_max_offsprings <- 3;    float predator_energy_reproduce <- 0.5; }   We define then the six corresponding parameters in the experiment:     parameter Prey probability reproduce:  var: prey_proba_reproduce category: Prey ;    parameter Prey nb max offsprings:  var: prey_nb_max_offsprings category: Prey ;    parameter Prey energy reproduce:  var: prey_energy_reproduce category: Prey ;    parameter Predator probability reproduce:  var: predator_proba_reproduce category: Predator ;    parameter Predator nb max offsprings:  var: predator_nb_max_offsprings category: Predator ;    parameter Predator energy reproduce:  var: predator_energy_reproduce category: Predator ;   parent species We add three new variables for the generic_species:   * proba_reproduce   * nb_max_offsprings   * energy_reproduce  We add as well a new reflex called reproduce:   * this reflex is activated only when:     * the energy of the agent is greater or equals to energy_reproduce     * AND according to the probability proba_reproduce: for this second condition, we use the flip(proba) operator that returns true according to the probability proba (false otherwise).     this reflex creates nb_offsprings (random number between 1 and nb_max_offsprings) new agent of species the species of the agent using the create statement: we use a species casting operator on the current agent.  the created agents are initialized as follows:   myCell: myCell of the agent creating the agents location: location of myCell energy: energy of the agent creating the agents (use of keyword myself) divided by the number of offsprings.       after the agent creation, the reflex updates the energy value of the current agent with the value: energy / nb_offsprings       species generic_species {       ...       float proba_reproduce ;       int nb_max_offsprings;       float energy_reproduce;       ... reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {   int nb_offsprings <- 1 + rnd(nb_max_offsprings -1);   create species(self) number: nb_offsprings {   myCell <- myself.myCell ;   location <- myCell.location ;   energy <- myself.energy / nb_offsprings ;   }   energy <- energy / nb_offsprings ;       }    }   Note that two keywords can be used to make explicit references to some agents :   * The agent that is currently executing the statements inside the block (for example a newly created agent): self   * The agent that is executing the statement that contains this block (for instance, the agent that has called the create statement): myself  prey species We specialize the prey species from the generic_species species:   * definition of the initial value of the agent variables      species prey parent: generic_species {       ...       float proba_reproduce <- prey_proba_reproduce ;       int nb_max_offsprings <- prey_nb_max_offsprings ;       float energy_reproduce <- prey_energy_reproduce ;       ...    }   predator species As done for the prey species, we specialize the predator species from the generic_species species:   * definition of the initial value of the agent variables      species predator parent: generic_species {       ...       float proba_reproduce <- predator_proba_reproduce ;       int nb_max_offsprings <- predator_nb_max_offsprings ;       float energy_reproduce <- predator_energy_reproduce ;       ...    }   Complete Model      model prey_predator  global {  int nb_preys_init <- 200;  int nb_predators_init <- 20;  float prey_max_energy <- 1.0;  float prey_max_transfert <- 0.1 ;  float prey_energy_consum <- 0.05;  float predator_max_energy <- 1.0;  float predator_energy_transfert <- 0.5;  float predator_energy_consum <- 0.02;  float prey_proba_reproduce <- 0.01;  int prey_nb_max_offsprings <- 5;   float prey_energy_reproduce <- 0.5;   float predator_proba_reproduce <- 0.01;  int predator_nb_max_offsprings <- 3;  float predator_energy_reproduce <- 0.5;  int nb_preys -> {length (prey)}; int nb_predators -> {length (predator)};  init {  create prey number: nb_preys_init ;   create predator number: nb_predators_init ; } }   species generic_species {  float size <- 1.0;  rgb color  ;  float max_energy;  float max_transfert;  float energy_consum;  float proba_reproduce ;  int nb_max_offsprings;  float energy_reproduce;  vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;  init {  location <- myCell.location; }   reflex basic_move {  myCell <- one_of (myCell.neighbours) ;  location <- myCell.location ; }   reflex die when: energy <= 0 {  do die ; }  reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {  int nb_offsprings <- 1 + rnd(nb_max_offsprings -1);  create species(self) number: nb_offsprings {   myCell <- myself.myCell ;   location <- myCell.location ;   energy <- myself.energy / nb_offsprings ;  }  energy <- energy / nb_offsprings ; }  aspect base {  draw circle(size) color: color ; } }   species prey parent: generic_species {  rgb color <- #blue;  float max_energy <- prey_max_energy ;  float max_transfert <- prey_max_transfert ;  float energy_consum <- prey_energy_consum ;  float proba_reproduce <- prey_proba_reproduce ;  int nb_max_offsprings <- prey_nb_max_offsprings ;  float energy_reproduce <- prey_energy_reproduce ;  reflex eat when: myCell.food > 0 {  float energy_transfert <- min([max_transfert, myCell.food]) ;  myCell.food <- myCell.food - energy_transfert ;  energy <- energy + energy_transfert ; } }   species predator parent: generic_species {  rgb color <- #red ;  float max_energy <- predator_max_energy ;  float energy_transfert <- predator_energy_transfert ;  float energy_consum <- predator_energy_consum ;  list reachable_preys update: prey inside (myCell);  float proba_reproduce <- predator_proba_reproduce ;  int nb_max_offsprings <- predator_nb_max_offsprings ;  float energy_reproduce <- predator_energy_reproduce ;  reflex eat when: ! empty(reachable_preys) {  ask one_of (reachable_preys) {   do die ;  }  energy <- energy + energy_transfert ; } }   grid vegetation_cell width: 50 height: 50 neighbours: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food)));  list neighbours  <- (self neighbours_at 2);  }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init  min: 0 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfert:   var: prey_max_transfert  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  parameter  Initial number of predators:   var: nb_predators_init  min: 0 max: 200 category:  Predator  ;  parameter  Predator max energy:   var: predator_max_energy category:  Predator  ;  parameter  Predator energy transfert:   var: predator_energy_transfert  category:  Predator  ;  parameter  Predator energy consumption:   var: predator_energy_consum  category:  Predator  ;  parameter  Prey probability reproduce:   var: prey_proba_reproduce category:  Prey  ;  parameter  Prey nb max offsprings:   var: prey_nb_max_offsprings category:  Prey  ;  parameter  Prey energy reproduce:   var: prey_energy_reproduce category:  Prey  ;  parameter  Predator probability reproduce:   var: predator_proba_reproduce category:  Predator  ;  parameter  Predator nb max offsprings:   var: predator_nb_max_offsprings category:  Predator  ;  parameter  Predator energy reproduce:   var: predator_energy_reproduce category:  Predator  ;  output {  display main_display {   grid vegetation_cell lines: #black ;   species prey aspect: base ;   species predator aspect: base ;  }  monitor Number of preys value: nb_preys;  monitor Number of predators value: nb_predators; } }      ","url":"wiki/PredatorPrey_step6.md"},{"id":"wiki/PredatorPrey_step7.md","title":" 7. Agent Aspect","content":"7. Agent Aspect In this seventh step we will focus on the display and more specifically the aspects of the agents: how they are represented. It can be a simple shape (circle, square, etc.), an icon, a polygon (see later GIS support).  Formulation    Definition of two new aspects for the prey and predator agents:  A icon       A square with information about the agent energy Use of the icon aspect as default aspect for the prey and predator agents.   Model Definition  parent species  We add a new variable of type file called my_icon to the generic_species. We define as well two new aspects:   * icon : draw the image given by the variable icon   * info : draw a square of side size size and color color; draw as a text the energy of the agent (with a precision of 2)      species generic_species {       ...       file my_icon;       ...       aspect base {   draw circle(size) color: color ;       }       aspect icon {   draw my_icon size: 2 * size ;       }       aspect info {   draw square(size) color: color ;   draw string(energy with_precision 2) size: 3 color: #black ;       }    }   prey species We specialize the prey species from the generic_species species:   * definition of the initial value of the agent variables     species prey parent: generic_species {       ...  file my_icon <- file(../images/predator_prey_sheep.png) ;       ...    }   The image file is here:   You have to copy it in your project folder: images/  predator species As done for the prey species, we specialize the predator species from the generic_species species:   * definition of the initial value of the agent variables      species predator parent: generic_species {       ...       file my_icon <- file(../images/predator_prey_wolf.png) ;       ...    }   The image file is here:   You have to copy it in your project folder: images  display We change the default aspect of the prey and predator agents to icon aspect.     output {       display main_display {   grid vegetation_cell lines: #black ;   species prey aspect: icon ;   species predator aspect: icon ;       }    }   We define a new display called info_display that displays the prey and predator agents with the info aspect.     output {       display info_display {   species prey aspect: info;   species predator aspect: info;       }    }   Complete Model      model prey_predator  global {  int nb_preys_init <- 200;  int nb_predators_init <- 20;  float prey_max_energy <- 1.0;  float prey_max_transfert <- 0.1 ;  float prey_energy_consum <- 0.05;  float predator_max_energy <- 1.0;  float predator_energy_transfert <- 0.5;  float predator_energy_consum <- 0.02;  float prey_proba_reproduce <- 0.01;  int prey_nb_max_offsprings <- 5;   float prey_energy_reproduce <- 0.5;   float predator_proba_reproduce <- 0.01;  int predator_nb_max_offsprings <- 3;  float predator_energy_reproduce <- 0.5;  int nb_preys -> {length (prey)}; int nb_predators -> {length (predator)};  init {  create prey number: nb_preys_init ;   create predator number: nb_predators_init ; } }   species generic_species {  float size <- 1.0;  rgb color  ;  float max_energy;  float max_transfert;  float energy_consum;  float proba_reproduce ;  float nb_max_offsprings;  float energy_reproduce;  file my_icon;  vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;  init {  location <- myCell.location; }   reflex basic_move {  myCell <- one_of (myCell.neighbours) ;  location <- myCell.location ; }   reflex die when: energy <= 0 {  do die ; }  reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {  int nb_offsprings <- 1 + rnd(nb_max_offsprings -1);  create species(self) number: nb_offsprings {   myCell <- myself.myCell ;   location <- myCell.location ;   energy <- myself.energy / nb_offsprings ;  }  energy <- energy / nb_offsprings ; }  aspect base {  draw circle(size) color: color ; } aspect icon {  draw my_icon size: 2 * size ; } aspect info {  draw square(size) color: color ;  draw string(energy with_precision 2) size: 3 color: #black ; } }   species prey parent: generic_species {  rgb color <- #blue;  float max_energy <- prey_max_energy ;  float max_transfert <- prey_max_transfert ;  float energy_consum <- prey_energy_consum ;  float proba_reproduce <- prey_proba_reproduce ;  int nb_max_offsprings <- prey_nb_max_offsprings ;  float energy_reproduce <- prey_energy_reproduce ;  file my_icon <- file( ../images/predator_prey_sheep.png ) ;  reflex eat when: myCell.food > 0 {  float energy_transfert <- min([max_transfert, myCell.food]) ;  myCell.food <- myCell.food - energy_transfert ;  energy <- energy + energy_transfert ; } }   species predator parent: generic_species {  rgb color <- #red ;  float max_energy <- predator_max_energy ;  float energy_transfert <- predator_energy_transfert ;  float energy_consum <- predator_energy_consum ;  list reachable_preys update: prey inside (myCell);  float proba_reproduce <- predator_proba_reproduce ;  int nb_max_offsprings <- predator_nb_max_offsprings ;  float energy_reproduce <- predator_energy_reproduce ;  file my_icon <- file(../images/predator_prey_wolf.png) ;  reflex eat when: ! empty(reachable_preys) {  ask one_of (reachable_preys) {   do die ;  }  energy <- energy + energy_transfert ; } }   grid vegetation_cell width: 50 height: 50 neighbours: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;  list neighbours  <- (self neighbours_at 2);  }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init  min: 0 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfert:   var: prey_max_transfert  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  parameter  Initial number of predators:   var: nb_predators_init  min: 0 max: 200 category:  Predator  ;  parameter  Predator max energy:   var: predator_max_energy category:  Predator  ;  parameter  Predator energy transfert:   var: predator_energy_transfert  category:  Predator  ;  parameter  Predator energy consumption:   var: predator_energy_consum  category:  Predator  ;  parameter  Prey probability reproduce:   var: prey_proba_reproduce category:  Prey  ;  parameter  Prey nb max offsprings:   var: prey_nb_max_offsprings category:  Prey  ;  parameter  Prey energy reproduce:   var: prey_energy_reproduce category:  Prey  ;  parameter  Predator probability reproduce:   var: predator_proba_reproduce category:  Predator  ;  parameter  Predator nb max offsprings:   var: predator_nb_max_offsprings category:  Predator  ;  parameter  Predator energy reproduce:   var: predator_energy_reproduce category:  Predator  ;  output {  display main_display {   grid vegetation_cell lines: #black ;   species prey aspect: icon ;   species predator aspect: icon ;  }  display info_display {   grid vegetation_cell lines: #black ;   species prey aspect: info ;   species predator aspect: info ;  }  monitor Number of preys value: nb_preys;  monitor Number of predators value: nb_predators; } }      ","url":"wiki/PredatorPrey_step7.md"},{"id":"wiki/PredatorPrey_step8.md","title":" 8. Complex Behavior","content":"8. Complex Behavior This eighth step Illustrates how to define and call actions and how to use conditional statements.  Formulation    Definition of more complex behaviors for prey and predator agents:  The preys agents are moving to the cell containing the highest quantity of food       The predator agents are moving if possible to a cell that contains preys; otherwise random cell Model Definition  parent species We modify the basic_move reflex of the generic_species in order to give the prey and predator a more complex behaviors: instead of choose a random vegetation cell in the neighborhood, the agent will choose a vegetation cell (still in the neighborhood) thanks to a choose_cell action. This action will be specialized for each species.         species generic_species {  …  reflex basic_move {   myCell <- choose_cell();   location <- myCell.location;   }  vegetation_cell choose_cell {  return nil; }     ...    }       We remind that an action is a capability available to the agents of a species (what they can do). It is a block of statements that can be used and reused whenever needed.   * An action can accept arguments.   * An action can return a result (statement return)  There are two ways to call an action: using a statement or as part of an expression   * for actions that do not return a result:  do action_name (arg1: v1 arg2: v2); do action_name (v1, v2);      for actions that return a result (which is stored in my_var):  my_var <- action_name (arg1:v1, arg2:v2); my_var <- action_name (v1, v2);    prey species We specialize the choose_cell species for the prey species: the agent will choose the vegetation cell of the neighborhood (list myCell.neighbours) that maximizes the quantity of food.  Note that GAMA offers numerous operators to manipulate lists and containers:   * Unary operators : min, max, sum…   * Binary operators :     * where : returns a sub-list where all the elements verify the condition defined in the right operand.     * first_with : returns the first element of the list that verifies the condition defined in the right operand.     * … In the case of binary operators, each element (of the first operand list) can be accessed with the keyword each  Thus the choose_cell action of the prey species is defined by:     species prey parent: generic_species {       ...  vegetation_cell choose_cell {    return (myCell.neighbours) with_max_of (each.food);       }       ...    }   predator species We specialize the choose_cell species for the predator species: the agent will choose, if possible, a vegetation cell of the neighborhood (list myCell.neighbours) that contains at least a prey agent; otherwise it will choose a random cell.  We use for this action the first_with operator on the list neighbor vegetation cells (myCell.neighbours) with the following condition: the list of prey agents contained in the cell is not empty. Note that we use the shuffle operator to randomize the order of the list of neighbor cell.  If all the neighbor cells are empty (myCell_tmp = nil, nil is the null value), then the agent choosse a random cell in the neighborhood (one_of (myCell.neighbours)).  GAMA contains statements that allow to execute blocks depending on some conditions:     if condition1 {...}     else if condition2{...}     ...     else {...}    This statement means that if condition1 = true then the first block is executed; otherwise if condition2 = true, then it is the second block, etc. When no conditions are satisfied and an else block is defined (it is optional), this latter is executed.  We then write the choose_cell action as follows:     species predator parent: generic_species {       ...       vegetation_cell choose_cell {    vegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));    if myCell_tmp != nil {   return myCell_tmp;    } else {   return one_of (myCell.neighbours);    } }       ...    }   Note there is ternary operator allowing to directly use a condition structure to evaluate a variable:     condition ? value1 : value2  if condition is true, then returns value1; otherwise, returns value2.  Complete Model      model prey_predator  global {  int nb_preys_init <- 200;  int nb_predators_init <- 20;  float prey_max_energy <- 1.0;  float prey_max_transfert <- 0.1 ;  float prey_energy_consum <- 0.05;  float predator_max_energy <- 1.0;  float predator_energy_transfert <- 0.5;  float predator_energy_consum <- 0.02;  float prey_proba_reproduce <- 0.01;  int prey_nb_max_offsprings <- 5;   float prey_energy_reproduce <- 0.5;   float predator_proba_reproduce <- 0.01;  int predator_nb_max_offsprings <- 3;  float predator_energy_reproduce <- 0.5;  int nb_preys -> {length (prey)}; int nb_predators -> {length (predator)};  init {  create prey number: nb_preys_init ;   create predator number: nb_predators_init ; } }   species generic_species {  float size <- 1.0;  rgb color  ;  float max_energy;  float max_transfert;  float energy_consum;  float proba_reproduce ;  float nb_max_offsprings;  float energy_reproduce;  file my_icon;  vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;  init {  location <- myCell.location; }   reflex basic_move {  myCell <- choose_cell();  location <- myCell.location;  }   vegetation_cell choose_cell {  return nil; }   reflex die when: energy <= 0 {  do die ; }  reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {  int nb_offsprings <- 1 + rnd(nb_max_offsprings -1);  create species(self) number: nb_offsprings {   myCell <- myself.myCell ;   location <- myCell.location ;   energy <- myself.energy / nb_offsprings ;  }  energy <- energy / nb_offsprings ; }  aspect base {  draw circle(size) color: color ; } aspect icon {  draw my_icon size: 2 * size ; } aspect info {  draw square(size) color: color ;  draw string(energy with_precision 2) size: 3 color: #black ; } }   species prey parent: generic_species {  rgb color <- #blue;  float max_energy <- prey_max_energy ;  float max_transfert <- prey_max_transfert ;  float energy_consum <- prey_energy_consum ;  float proba_reproduce <- prey_proba_reproduce ;  int nb_max_offsprings <- prey_nb_max_offsprings ;  float energy_reproduce <- prey_energy_reproduce ;  file my_icon <- file( ../images/predator_prey_sheep.png ) ;  reflex eat when: myCell.food > 0 {  float energy_transfert <- min([max_transfert, myCell.food]) ;  myCell.food <- myCell.food - energy_transfert ;  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  return (myCell.neighbours) with_max_of (each.food); } }   species predator parent: generic_species {  rgb color <- #red ;  float max_energy <- predator_max_energy ;  float energy_transfert <- predator_energy_transfert ;  float energy_consum <- predator_energy_consum ;  list reachable_preys update: prey inside (myCell);  float proba_reproduce <- predator_proba_reproduce ;  int nb_max_offsprings <- predator_nb_max_offsprings ;  float energy_reproduce <- predator_energy_reproduce ;  file my_icon <- file(../images/predator_prey_wolf.png) ;  reflex eat when: ! empty(reachable_preys) {  ask one_of (reachable_preys) {   do die ;  }  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  vegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));  if myCell_tmp != nil {   return myCell_tmp;  } else {   return one_of (myCell.neighbours);  }  } }   grid vegetation_cell width: 50 height: 50 neighbours: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;  list neighbours  <- (self neighbours_at 2);  }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init  min: 0 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfert:   var: prey_max_transfert  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  parameter  Initial number of predators:   var: nb_predators_init  min: 0 max: 200 category:  Predator  ;  parameter  Predator max energy:   var: predator_max_energy category:  Predator  ;  parameter  Predator energy transfert:   var: predator_energy_transfert  category:  Predator  ;  parameter  Predator energy consumption:   var: predator_energy_consum  category:  Predator  ;  parameter  Prey probability reproduce:   var: prey_proba_reproduce category:  Prey  ;  parameter  Prey nb max offsprings:   var: prey_nb_max_offsprings category:  Prey  ;  parameter  Prey energy reproduce:   var: prey_energy_reproduce category:  Prey  ;  parameter  Predator probability reproduce:   var: predator_proba_reproduce category:  Predator  ;  parameter  Predator nb max offsprings:   var: predator_nb_max_offsprings category:  Predator  ;  parameter  Predator energy reproduce:   var: predator_energy_reproduce category:  Predator  ;  output {  display main_display {   grid vegetation_cell lines: #black ;   species prey aspect: icon ;   species predator aspect: icon ;  }  display info_display {   grid vegetation_cell lines: #black ;   species prey aspect: info ;   species predator aspect: info ;  }  monitor Number of preys value: nb_preys;  monitor Number of predators value: nb_predators; } }      ","url":"wiki/PredatorPrey_step8.md"},{"id":"wiki/PredatorPrey_step9.md","title":" 9. Stopping condition","content":"9. Stopping condition This 9th step Illustrates how to use the halt action to stop a simulation  Formulation    Adding of a stopping condition for the simulation: when there is no more prey or predator agents, the simulation stops   Model Definition  We add a new reflex that stops the simulation if the number of preys or the number of predator is null.   global {    ...    reflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {       do halt ;    }  }   Note that it would have been possible to use the pause action that pauses the simulation instead of the halt action that stops the simulation.  Complete Model      model prey_predator  global {  int nb_preys_init <- 200;  int nb_predators_init <- 20;  float prey_max_energy <- 1.0;  float prey_max_transfert <- 0.1 ;  float prey_energy_consum <- 0.05;  float predator_max_energy <- 1.0;  float predator_energy_transfert <- 0.5;  float predator_energy_consum <- 0.02;  float prey_proba_reproduce <- 0.01;  int prey_nb_max_offsprings <- 5;   float prey_energy_reproduce <- 0.5;   float predator_proba_reproduce <- 0.01;  int predator_nb_max_offsprings <- 3;  float predator_energy_reproduce <- 0.5;  int nb_preys -> {length (prey)}; int nb_predators -> {length (predator)};  init {  create prey number: nb_preys_init ;   create predator number: nb_predators_init ; }  reflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {  do halt ; }  }   species generic_species {  float size <- 1.0;  rgb color  ;  float max_energy;  float max_transfert;  float energy_consum;  float proba_reproduce ;  float nb_max_offsprings;  float energy_reproduce;  file my_icon;  vegetation_cell myCell <- one_of (vegetation_cell) ;  float energy <- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;  init {  location <- myCell.location; }   reflex basic_move {  myCell <- choose_cell();  location <- myCell.location;  }   vegetation_cell choose_cell {  return nil; }   reflex die when: energy <= 0 {  do die ; }  reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {  int nb_offsprings <- 1 + rnd(nb_max_offsprings -1);  create species(self) number: nb_offsprings {   myCell <- myself.myCell ;   location <- myCell.location ;   energy <- myself.energy / nb_offsprings ;  }  energy <- energy / nb_offsprings ; }  aspect base {  draw circle(size) color: color ; } aspect icon {  draw my_icon size: 2 * size ; } aspect info {  draw square(size) color: color ;  draw string(energy with_precision 2) size: 3 color: #black ; } }   species prey parent: generic_species {  rgb color <- #blue;  float max_energy <- prey_max_energy ;  float max_transfert <- prey_max_transfert ;  float energy_consum <- prey_energy_consum ;  float proba_reproduce <- prey_proba_reproduce ;  int nb_max_offsprings <- prey_nb_max_offsprings ;  float energy_reproduce <- prey_energy_reproduce ;  file my_icon <- file( ../images/predator_prey_sheep.png ) ;  reflex eat when: myCell.food > 0 {  float energy_transfert <- min([max_transfert, myCell.food]) ;  myCell.food <- myCell.food - energy_transfert ;  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  return (myCell.neighbours) with_max_of (each.food); } }   species predator parent: generic_species {  rgb color <- #red ;  float max_energy <- predator_max_energy ;  float energy_transfert <- predator_energy_transfert ;  float energy_consum <- predator_energy_consum ;  list reachable_preys update: prey inside (myCell);  float proba_reproduce <- predator_proba_reproduce ;  int nb_max_offsprings <- predator_nb_max_offsprings ;  float energy_reproduce <- predator_energy_reproduce ;  file my_icon <- file(../images/predator_prey_wolf.png) ;  reflex eat when: ! empty(reachable_preys) {  ask one_of (reachable_preys) {   do die ;  }  energy <- energy + energy_transfert ; }  vegetation_cell choose_cell {  vegetation_cell myCell_tmp <- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));  if myCell_tmp != nil {   return myCell_tmp;  } else {   return one_of (myCell.neighbours);  }  } }   grid vegetation_cell width: 50 height: 50 neighbours: 4 {  float maxFood <- 1.0 ;  float foodProd <- (rnd(1000) / 1000) * 0.01 ;  float food <- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;  rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;  list neighbours  <- (self neighbours_at 2);  }  experiment prey_predator type: gui {  parameter  Initial number of preys:   var: nb_preys_init  min: 0 max: 1000 category:  Prey  ;  parameter  Prey max energy:   var: prey_max_energy category:  Prey  ;  parameter  Prey max transfert:   var: prey_max_transfert  category:  Prey  ;  parameter  Prey energy consumption:   var: prey_energy_consum  category:  Prey  ;  parameter  Initial number of predators:   var: nb_predators_init  min: 0 max: 200 category:  Predator  ;  parameter  Predator max energy:   var: predator_max_energy category:  Predator  ;  parameter  Predator energy transfert:   var: predator_energy_transfert  category:  Predator  ;  parameter  Predator energy consumption:   var: predator_energy_consum  category:  Predator  ;  parameter  Prey probability reproduce:   var: prey_proba_reproduce category:  Prey  ;  parameter  Prey nb max offsprings:   var: prey_nb_max_offsprings category:  Prey  ;  parameter  Prey energy reproduce:   var: prey_energy_reproduce category:  Prey  ;  parameter  Predator probability reproduce:   var: predator_proba_reproduce category:  Predator  ;  parameter  Predator nb max offsprings:   var: predator_nb_max_offsprings category:  Predator  ;  parameter  Predator energy reproduce:   var: predator_energy_reproduce category:  Predator  ;  output {  display main_display {   grid vegetation_cell lines: #black ;   species prey aspect: icon ;   species predator aspect: icon ;  }  display info_display {   grid vegetation_cell lines: #black ;   species prey aspect: info ;   species predator aspect: info ;  }  monitor Number of preys value: nb_preys;  monitor Number of predators value: nb_predators; } }      ","url":"wiki/PredatorPrey_step9.md"},{"id":"wiki/RoadTrafficModel_step1.md","title":" 1. Loading of GIS Data","content":"1. Loading of GIS Data This first step Illustrates how to load GIS data (shapefiles) and to read attributes from GIS data.  Formulation    Set the time duration of a time step to 10 minutes   Load, agentify and display two layers of GIS data (building and road). Agentifying a GIS element will allow us to give it a behavior later on (thus not being simply a static/passive object).   Read the  NATURE  attribute of the building data: the buildings of  Residential  type will be colored in gray, the buildings of  Industrial  type will be color in blue.   Model Definition  species In this first model, we have to define two species of agents: the building agents and the road ones. These agents will not have a particular behavior, they will just be displayed. For each of these species, we define a new attribute: color of type rgb, with for initial value:  black  for the road agent and  gray  (by default) for the building agent. Concerning the building agent, we define a second attribute named type representing the type of the building ( Residential  or  Industrial ). At last, we define an aspect for these species. In this model, we want to represent the geometry of the agent, we then use the keyword draw that allow to draw a given geometry. In order to draw the geometry of the agent we use the attribute shape (which is a built-in attribute of all agents).      species building {  string type;   rgb color <- #gray  ;  aspect base {  draw shape color: color ; } }   species road  {  rgb color <- #black ;      aspect base {  draw shape color: color ; } }       parameters GAMA allows to automatically read GIS data that are formatted as shapefiles. In order to let the user chooses his/her shapefiles, we define three parameters. One allowing the user to choose the road shapefile, one allowing him/her to choose the building shapefile, and, at last, one allowing him/her to choose the bounds shapefile. We will come back later on the notion of  bounds  in GAMA.  Definition of the three global variables of type file concerning the GIS files:  global {    file shape_file_buildings <- file(../includes/building.shp);    file shape_file_roads <- file(../includes/road.shp);    file shape_file_bounds <- file(../includes/bounds.shp); }   In the experiment section, we add three parameters to allow the user to change the shapefile used directly through the UI:  experiment road_traffic type: gui {    parameter Shapefile for the buildings: var: shape_file_buildings category: GIS ;    parameter Shapefile for the roads: var: shape_file_roads category: GIS ;    parameter Shapefile for the bounds: var: shape_file_bounds category: GIS ; }   agentification of GIS data  In GAMA, the agentification of GIS data is very straightforward: it only requires to use the create command with the from facet to pass the shapefile. Each object of the shapefile will be directly used to instantiate an agent of the specified species. The reading of an attribute in a shapefile is also very simple. It only requires to use the with facet: the argument of this facet is a dictionary of which the keys are the names of the agent attributes and the value the read command followed by the name of the shapefile attribute ( NATURE  in our case).  Init section of the global block: creation of the road and building agents from the shape files. Concerning the building agents, reading of the  NATURE  attribute of the shapefile to initiate the value of the type attribute. If the type attribute is equal to  Industrial  set the color attribute to  blue .  global {   ...   init {    create building from: shape_file_buildings with: [type::read (NATURE)] {       if type=Industrial {   color <- #blue ;       }    }    create road from: shape_file_roads ;   }    time step In GAMA, by default, a time step represents 1 second. It is possible to redefine this value by overriding the step global variable. This value of the time step is used by the moving primitives of GAMA.  In our model, we define that a step represent 10 minutes. Note that it is possible to define the unit of a value by using # + unit name. For instance, #mn or #km for kilometers.   global {   ...   float step <- 10 #mn;   ... }  ### environment Building a GIS environment in GAMA requires nothing special, just to define the bounds of the environment, i.e. the geometry of the world agent. It is possible to use a shapefile to automatically define it by computing its envelope. In this model, we use a specific shapefile to define it. However, it would been possible to use the road shapefile to define it and let GAMA computes it enveloppe automatically.   global {   ...   geometry shape <- envelope(shape_file_bounds);    ... }   display We define a display to visualize the road and building agents. We use for that the classic species keyword. In order to optimize the display we use an opengl display (facet type: opengl).  In the experiment block:  output {    display city_display type:opengl {       species building aspect: base ;       species road aspect: base ;    } }   Complete Model      model tutorial_gis_city_traffic  global {  file shape_file_buildings <- file( ../includes/building.shp );  file shape_file_roads <- file( ../includes/road.shp );  file shape_file_bounds <- file( ../includes/bounds.shp );  geometry shape <- envelope(shape_file_bounds);  float step <- 10 #mn;  init {  create building from: shape_file_buildings with: [type::string(read (NATURE))] {   if type=Industrial {    color <- #blue ;   }  }  create road from: shape_file_roads ; } }   species building {  string type;   rgb color <- #gray  ;  aspect base {  draw shape color: color ; } }   species road  {  rgb color <- #black ;  aspect base {   draw shape color: color ;  } }  experiment road_traffic type: gui {  parameter  Shapefile for the buildings:  var: shape_file_buildings category:  GIS  ;  parameter  Shapefile for the roads:  var: shape_file_roads category:  GIS  ;  parameter  Shapefile for the bounds:  var: shape_file_bounds category:  GIS  ;  output {  display city_display type:opengl {   species building aspect: base ;   species road aspect: base ;  } } }      ","url":"wiki/RoadTrafficModel_step1.md"},{"id":"wiki/RoadTrafficModel_step2.md","title":" 2. People Agents","content":"2. People Agents This second step Illustrates how to obtain a random point inside a geometry. We will also define some moving agent called people.  Formulation    Define a new species of agents: the people agents. The people agents have a point for geometry and are represented by a yellow circle of radius 10m.   At initialization, 100 people agents are created. Each people agent is placed inside a building of type  Residential  (randomly selected).   Model Definition  species We define a new species of agents: the people agents. In this model, these agents will not have a specific behavior yet. They will be just displayed. Thus, we just have to define an aspect for the agents. We want to represent the people agents by a yellow circle of radius 10m. We then use the circle value for the shape facet of the draw command, with the expected color and radius size (defined by the facet size).      species people {  rgb color <- #yellow ;  aspect base {  draw circle(10) color: color; } }       parameter We have to add a new parameter: the number of people agents created  In the global section, definition of the nb_people variable:     int nb_people <- 100;   In the experiment section, definition of the parameter:     parameter Number of people agents var: nb_people category: People ;   creation and placement of the people agents  We have to create nb_people people agents. Each people is placed in a buildings of type  Residential  randomly selected. In order to simplify the GAML code, we defined a local variable residential_buildings that represent the list of buildings of type  Residential . To filter the list of building agents (obtained by building), we use the where operator. We use the operator one_of to randomly select one agent of this list. There are several ways to place a people agent inside this building. In this tutorial, we choose to use the any_location_in operator. This operator returns a random point situated inside the operand geometry.   global {  ...  init {   create building from: shape_file_buildings with: [type::string(read (NATURE))] {    if type=Industrial {     color <- #blue ;    }   }   create road from: shape_file_roads ;   list<building> residential_buildings <- building where (each.type=Residential);   create people number: nb_people {    location <- any_location_in (one_of (residential_buildings));   }  } }   display We add the people agent in the defined display.      output {       display city_display {   species building aspect: base ;   species road aspect: base ;   species people aspect: base ;       }    }   Complete Model      model tutorial_gis_city_traffic  global {  file shape_file_buildings <- file( ../includes/building.shp );  file shape_file_roads <- file( ../includes/road.shp );  file shape_file_bounds <- file( ../includes/bounds.shp );  geometry shape <- envelope(shape_file_bounds);  float step <- 10 #mn;  int nb_people <- 100;  init {  create building from: shape_file_buildings with: [type::string(read (NATURE))] {   if type=Industrial {    color <- #blue ;   }  }  create road from: shape_file_roads ;  list<building> residential_buildings <- building where (each.type=Residential);  create people number: nb_people {   location <- any_location_in (one_of (residential_buildings));  } } }   species building {  string type;   rgb color <- #gray  ;  aspect base {  draw shape color: color ; } }   species road  {  rgb color <- #black ;  aspect base {   draw shape color: color ;  } }  species people {  rgb color <- #yellow ;  aspect base {  draw circle(10) color: color; } }   experiment road_traffic type: gui {  parameter  Shapefile for the buildings:  var: shape_file_buildings category:  GIS  ;  parameter  Shapefile for the roads:  var: shape_file_roads category:  GIS  ;  parameter  Shapefile for the bounds:  var: shape_file_bounds category:  GIS  ;  parameter  Number of people agents  var: nb_people category:  People  ;  output {  display city_display type:opengl {   species building aspect: base ;   species road aspect: base ;   species people aspect: base ;  } } }      ","url":"wiki/RoadTrafficModel_step2.md"},{"id":"wiki/RoadTrafficModel_step3.md","title":" 3. Movement of People","content":"3. Movement of People  This third step presents how to create a road system from GIS data. More precisely, it shows how to build a graph from a list of polylines and to constrain the movement of an agent according to this graph.  Formulation    Definition of day_time global variable that will indicate, according to the simulation step, the time of the day: each simulation step will represent 10 minutes, then the day_time variable will be ranged between 0 and 144.   For each people agent: define a living_place(building of type  Residential ) and working place (building of type  Industrial ).   For each people agent: define start_work and end_work hours that respectively represent when the agent leaves its house to go to work and when it leaves its working_place to go back home. These hours will be randomly define between 36 (6 a.m;) and 60 (10 a.m.) for the start_work and 84 (2p.m.) and 132 (10p.m.) for the end_work.   For each people agent: define a objective variable: this one can  go home  or  working .   For each people agent: define a speed. The speed will be randomly define between 50 and 100.   The people agents move along the road, taking the shortest path.   Model Definition  people agents First, we have to change the skill of the people agents: as we want to use an action of the moving skill (goto), we will provide the people agents with this skill. A skill is a built-in module that provide the modeler a self-contain and relevant set of actions and variables.      species people skills: [moving]{ ...    }   Then, we have to add new variables to the people agents: living_place, working_place, start_work, end_work, objective. In addition, we will add a  the_target  variable that will represents the point toward which the agent will be currently moving.         species people skills: [moving]{  rgb color <- #yellow ;  building living_place <- nil ;  building working_place <- nil ;  int start_work ;  int end_work  ;  string objective ;   point the_target <- nil ;     ...    }       We define two reflex methods that allow to change the objective (and the_target) of the agent at the start_work and en_work hours. Concerning the target value, we choose a random point in the objective building (working_place or living_place) by using the any_location_in operator.         species people skills: [moving]{       …       reflex time_to_work when: current_hour = start_work and objective =  resting {  objective <-  working  ;     the_target <- any_location_in (working_place);       }    reflex time_to_go_home when: current_hour = end_work and objective = working{    objective <- resting ;    the_target <- any_location_in (living_place);    }    ...   }       At last, we define a reflex method that allows the agent to move. If a target point is defined (the_target != nil), the agent moves in direction to its target using the goto action (provided by the moving skill). Note that we specified a graph to constraint the movement of the agents on the road network with the facet on. We will see later how this graph is built. The agent uses the shortest path (according to the graph) to go to the target point. When the agent arrives at destination (the_target = location), the target is set to nil (the agent will stop moving).     species people skills: [moving]{       ...       reflex move when: the_target != nil {    do goto target: the_target on: the_graph ;     if the_target = location {   the_target <- nil ;    }      }   }   parameters We add several parameters (min_work_start, max_work_start, min_work_end, max_work_end, min_speed and max_speed) and two global variables: the_graph (graph computed from the road network) and current_hour (current hour of the day). The value of the current_hour variable is automatically computed at each simulation step and is equals to  (time(the simulation step step) / 1 hour) modulo 24 .  In the global section:  global {  ...  int current_hour update: (time / #hour) mod 24;  int min_work_start <- 6;  int max_work_start <- 8;  int min_work_end <- 16;   int max_work_end <- 20;   float min_speed <- 1.0 #km / #h;  float max_speed <- 5.0 #km / #h;   graph the_graph;  ... }   In the experiment section:  experiment road_traffic type: gui {  ...   parameter Earliest hour to start work var: min_work_start category: People min: 2 max: 8;  parameter Latest hour to start work var: max_work_start category: People min: 8 max: 12;  parameter Earliest hour to end work var: min_work_end category: People min: 12 max: 16;  parameter Latest hour to end work var: max_work_end category: People min: 16 max: 23;  parameter minimal speed var: min_speed category: People min: 0.1 #km/#h ;  parameter maximal speed var: max_speed category: People max: 10 #km/#h;  ... }  ### initialization First, we need to compute from the road agents, a graph for the moving of the people agents. The operator as_edge_graph allows to do that. It automatically builds from a set of agents or geometries a graph where the agents are the edges of the graph, a node represent the extremities of the agent geometry.     init {       ...       create road from: shape_file_roads ;       the_graph <- as_edge_graph(road);       ...    }   We randomly assign one working place and one house to each people agent. To simplify the GAML code, we define two temporary variables: the list of buildings of type  Residential  and the list of buildings of type  Industrial  (by using the where command). At the creation of each people agent, we define a speed, a start_work and end_work to each people agent (according to the min and max define in the parameters). We define as well an initial objective ( resting ). Concerning the definition of the living_place and working_place, these ones are randomly chosen in the residential_buildings and industrial_buildings lists.     init {       ...       list<building> residential_buildings <- building where (each.type=Residential);       list<building>  industrial_buildings <- building  where (each.type=Industrial) ;       create people number: nb_people { speed <- min_speed + rnd (max_speed - min_speed) ; start_work <- min_work_start + rnd (max_work_start - min_work_start) ; end_work <- min_work_end + rnd (max_work_end - min_work_end) ; living_place <- one_of(residential_buildings) ; working_place <- one_of(industrial_buildings) ; objective <- resting; location <- any_location_in (living_place); }       ...   }   Complete Model      model tutorial_gis_city_traffic  global {  file shape_file_buildings <- file( ../includes/building.shp );  file shape_file_roads <- file( ../includes/road.shp );  file shape_file_bounds <- file( ../includes/bounds.shp );  geometry shape <- envelope(shape_file_bounds);  float step <- 10 #mn;  int nb_people <- 100;  int current_hour update: (time / #hour) mod 24;  int min_work_start <- 6;  int max_work_start <- 8;  int min_work_end <- 16;   int max_work_end <- 20;   float min_speed <- 1.0 #km / #h;  float max_speed <- 5.0 #km / #h;   graph the_graph;  init {  create building from: shape_file_buildings with: [type::string(read (NATURE))] {   if type=Industrial {    color <- #blue ;   }  }  create road from: shape_file_roads ;  the_graph <- as_edge_graph(road);    list<building> residential_buildings <- building where (each.type=Residential);  list<building>  industrial_buildings <- building  where (each.type=Industrial) ;  create people number: nb_people {   speed <- min_speed + rnd (max_speed - min_speed) ;   start_work <- min_work_start + rnd (max_work_start - min_work_start) ;   end_work <- min_work_end + rnd (max_work_end - min_work_end) ;   living_place <- one_of(residential_buildings) ;   working_place <- one_of(industrial_buildings) ;   objective <- resting;   location <- any_location_in (living_place);   } } }   species building {  string type;   rgb color <- #gray  ;  aspect base {  draw shape color: color ; } }   species road  {  rgb color <- #black ;  aspect base {   draw shape color: color ;  } }  species people skills:[moving] {  rgb color <- #yellow ;  building living_place <- nil ;  building working_place <- nil ;  int start_work ;  int end_work  ;  string objective ;   point the_target <- nil ;  reflex time_to_work when: current_hour = start_work and objective = resting{  objective <- working ;  the_target <- any_location_in (working_place); }   reflex time_to_go_home when: current_hour = end_work and objective = working{  objective <- resting ;  the_target <- any_location_in (living_place);  }    reflex move when: the_target != nil {  do goto target: the_target on: the_graph ;   if the_target = location {   the_target <- nil ;  } }  aspect base {  draw circle(10) color: color; } }   experiment road_traffic type: gui {  parameter  Shapefile for the buildings:  var: shape_file_buildings category:  GIS  ;  parameter  Shapefile for the roads:  var: shape_file_roads category:  GIS  ;  parameter  Shapefile for the bounds:  var: shape_file_bounds category:  GIS  ;  parameter  Number of people agents  var: nb_people category:  People  ;  parameter  Earliest hour to start work  var: min_work_start category:  People  min: 2 max: 8;  parameter  Latest hour to start work  var: max_work_start category:  People  min: 8 max: 12;  parameter  Earliest hour to end work  var: min_work_end category:  People  min: 12 max: 16;  parameter  Latest hour to end work  var: max_work_end category:  People  min: 16 max: 23;  parameter  minimal speed  var: min_speed category:  People  min: 0.1 #km/#h ;  parameter  maximal speed  var: max_speed category:  People  max: 10 #km/#h;  output {  display city_display type:opengl {   species building aspect: base ;   species road aspect: base ;   species people aspect: base ;  } } }      ","url":"wiki/RoadTrafficModel_step3.md"},{"id":"wiki/RoadTrafficModel_step4.md","title":" 4. Weight for Road Network","content":"4. Weight for Road Network The present model will introduce how to design a road system, or graph, based on the road GIS data and provide each edge a weightrepresenting the destruction level of the road.  Formulation    Add a destruction_coeff variable to the road agent. The value of this variable is higher or equal to 1 or lower or equal to 2. At initialization, the value of this variable is randomly defined between 1 and 2.   In the road network graph, more a road is worn out (destruction_coeff high), more a people agent takes time to go all over it. Then the value of the arc representing the road in the graph is equal to  length of the road * destruction_coeff .   The color of the road depends of the destruction_coeff. If  destruction_coeff = 1 , the road is green, if  destruction_coeff = 2 , the road is red.   Model Definition  road agent We add a destruction_coeff variable which initial value is randomly defined between 1 and 2 and that have a max of 2. The color of the agent will depend of this variable. In order to simplify the GAML code, we define a new variable  colorValue that represents the value of red color and that will be defined between 0 and 255.         species road  {  float destruction_coeff <- 1 + ((rnd(100))/ 100.0) max: 2.0;  int colorValue <- int(255(destruction_coeff - 1)) update: int(255(destruction_coeff - 1));  rgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;      ...    }       weigthed road network In GAMA, adding a weight for a graph is very simple, we use the as_edge_graph operator with the graph for left-operand and a weight map for the right-operand. A weight contains the weight of each edge: [edge1::weight1, edge2:: weight2,…]. In this model, the weight will be equal to the length of the road (perimeter of the polyline) its destruction coefficient.      init {       ...       create road from: shape_file_roads ;       map<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));       the_graph <- as_edge_graph(road) with_weights weights_map;       ...    }   Complete Model      model tutorial_gis_city_traffic  global {  file shape_file_buildings <- file( ../includes/building.shp );  file shape_file_roads <- file( ../includes/road.shp );  file shape_file_bounds <- file( ../includes/bounds.shp );  geometry shape <- envelope(shape_file_bounds);  float step <- 10 #mn;  int nb_people <- 100;  int current_hour update: (time / #hour) mod 24;  int min_work_start <- 6;  int max_work_start <- 8;  int min_work_end <- 16;   int max_work_end <- 20;   float min_speed <- 1.0 #km / #h;  float max_speed <- 5.0 #km / #h;   graph the_graph;  init {  create building from: shape_file_buildings with: [type::string(read (NATURE))] {   if type=Industrial {    color <- #blue ;   }  }  create road from: shape_file_roads ;  map<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));  the_graph <- as_edge_graph(road) with_weights weights_map;      list<building> residential_buildings <- building where (each.type=Residential);  list<building>  industrial_buildings <- building  where (each.type=Industrial) ;  create people number: nb_people {   speed <- min_speed + rnd (max_speed - min_speed) ;   start_work <- min_work_start + rnd (max_work_start - min_work_start) ;   end_work <- min_work_end + rnd (max_work_end - min_work_end) ;   living_place <- one_of(residential_buildings) ;   working_place <- one_of(industrial_buildings) ;   objective <- resting;   location <- any_location_in (living_place);   } } }   species building {  string type;   rgb color <- #gray  ;  aspect base {  draw shape color: color ; } }   species road  {  float destruction_coeff <- 1 + ((rnd(100))/ 100.0) max: 2.0;  int colorValue <- int(255(destruction_coeff - 1)) update: int(255(destruction_coeff - 1));  rgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;  aspect base {  draw shape color: color ; } }   species people skills:[moving] {  rgb color <- #yellow ;  building living_place <- nil ;  building working_place <- nil ;  int start_work ;  int end_work  ;  string objective ;   point the_target <- nil ;  reflex time_to_work when: current_hour = start_work and objective = resting{  objective <- working ;  the_target <- any_location_in (working_place); }   reflex time_to_go_home when: current_hour = end_work and objective = working{  objective <- resting ;  the_target <- any_location_in (living_place);  }    reflex move when: the_target != nil {  do goto target: the_target on: the_graph ;   if the_target = location {   the_target <- nil ;  } }  aspect base {  draw circle(10) color: color; } }   experiment road_traffic type: gui {  parameter  Shapefile for the buildings:  var: shape_file_buildings category:  GIS  ;  parameter  Shapefile for the roads:  var: shape_file_roads category:  GIS  ;  parameter  Shapefile for the bounds:  var: shape_file_bounds category:  GIS  ;  parameter  Number of people agents  var: nb_people category:  People  ;  parameter  Earliest hour to start work  var: min_work_start category:  People  min: 2 max: 8;  parameter  Latest hour to start work  var: max_work_start category:  People  min: 8 max: 12;  parameter  Earliest hour to end work  var: min_work_end category:  People  min: 12 max: 16;  parameter  Latest hour to end work  var: max_work_end category:  People  min: 16 max: 23;  parameter  minimal speed  var: min_speed category:  People  min: 0.1 #km/#h ;  parameter  maximal speed  var: max_speed category:  People  max: 10 #km/#h;  output {  display city_display type:opengl {   species building aspect: base ;   species road aspect: base ;   species people aspect: base ;  } } }      ","url":"wiki/RoadTrafficModel_step4.md"},{"id":"wiki/RoadTrafficModel_step5.md","title":" 5. Dynamic weights","content":"5. Dynamic weights This 5th step illustrates how to obtain a shortest path from a point to another and to update the weights of an existing graph.  Formulation    At initialization, the value of the destruction_coeff of the road agents will be equal to 1.   Add a new parameter: the destroy parameter that represents the value of destruction when a people agent takes a road. By default, it is equal to 0.02.   When an people arrive at its destination (home or work), it updates the destruction_coeff of the road agents it took to reach its destination:   destruction_coeff = destruction_coeff - destroy . Then, the graph is updated.   Model Definition ### global section We add the destroy parameter.  In the global section, definition of the destroy and update_roads variables:     float destroy <- 0.02;   In the experiment section, definition of the parameter:     parameter Value of destruction when a people agent takes a road var: destroy category: Road ;   We define a new reflex that updates the graph at each simulation step. For that, we use the with_weights operator. This operator allows to update the weights of an existing graph.      global {       ...       reflex update_graph{   map<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));   the_graph <- the_graph with_weights weights_map;       }    }   people agents  At each time-step, after a people agent have moved over one or multiple segments, it updates the value of the destruction coefficient of road agents crossed (i.e. roads belonging to the path followed). We have for that to set the argument return_path to true in the goto action to obtain the path followed, then to compute the list of agents concerned by this path with the operator agent_from_geometry.     species people skills: [moving]{       ...       reflex move when: the_target != nil {   path path_followed <- self goto [target::the_target, on::the_graph, return_path:: true];   list<geometry> segments <- path_followed.segments;   loop line over: segments {    float dist <- line.perimeter;    ask road(path_followed agent_from_geometry line) {      destruction_coeff <- destruction_coeff + (destroy * dist / shape.perimeter);    }   }   if the_target = location {    the_target <- nil ;   }  }    ...    }    Complete Model      model tutorial_gis_city_traffic  global {  file shape_file_buildings <- file( ../includes/building.shp );  file shape_file_roads <- file( ../includes/road.shp );  file shape_file_bounds <- file( ../includes/bounds.shp );  geometry shape <- envelope(shape_file_bounds);  float step <- 10 #mn;  int nb_people <- 100;  int current_hour update: (time / #hour) mod 24;  int min_work_start <- 6;  int max_work_start <- 8;  int min_work_end <- 16;   int max_work_end <- 20;   float min_speed <- 1.0 #km / #h;  float max_speed <- 5.0 #km / #h;   float destroy <- 0.02;  graph the_graph;  init {  create building from: shape_file_buildings with: [type::string(read (NATURE))] {   if type=Industrial {    color <- #blue ;   }  }  create road from: shape_file_roads ;  map<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));  the_graph <- as_edge_graph(road) with_weights weights_map;      list<building> residential_buildings <- building where (each.type=Residential);  list<building>  industrial_buildings <- building  where (each.type=Industrial) ;  create people number: nb_people {   speed <- min_speed + rnd (max_speed - min_speed) ;   start_work <- min_work_start + rnd (max_work_start - min_work_start) ;   end_work <- min_work_end + rnd (max_work_end - min_work_end) ;   living_place <- one_of(residential_buildings) ;   working_place <- one_of(industrial_buildings) ;   objective <- resting;   location <- any_location_in (living_place);   } }  reflex update_graph{  map<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));  the_graph <- the_graph with_weights weights_map; } }   species building {  string type;   rgb color <- #gray  ;  aspect base {  draw shape color: color ; } }   species road  {  float destruction_coeff <- 1 + ((rnd(100))/ 100.0) max: 2.0;  int colorValue <- int(255(destruction_coeff - 1)) update: int(255(destruction_coeff - 1));  rgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;  aspect base {  draw shape color: color ; } }   species people skills:[moving] {  rgb color <- #yellow ;  building living_place <- nil ;  building working_place <- nil ;  int start_work ;  int end_work  ;  string objective ;   point the_target <- nil ;  reflex time_to_work when: current_hour = start_work and objective = resting{  objective <- working ;  the_target <- any_location_in (working_place); }   reflex time_to_go_home when: current_hour = end_work and objective = working{  objective <- resting ;  the_target <- any_location_in (living_place);  }    reflex move when: the_target != nil {  path path_followed <- self goto [target::the_target, on::the_graph, return_path:: true];  list<geometry> segments <- path_followed.segments;  loop line over: segments {   float dist <- line.perimeter;   ask road(path_followed agent_from_geometry line) {     destruction_coeff <- destruction_coeff + (destroy * dist / shape.perimeter);   }  }  if the_target = location {   the_target <- nil ;  } }  aspect base {  draw circle(10) color: color; } }   experiment road_traffic type: gui {  parameter  Shapefile for the buildings:  var: shape_file_buildings category:  GIS  ;  parameter  Shapefile for the roads:  var: shape_file_roads category:  GIS  ;  parameter  Shapefile for the bounds:  var: shape_file_bounds category:  GIS  ;  parameter  Number of people agents  var: nb_people category:  People  ;  parameter  Earliest hour to start work  var: min_work_start category:  People  min: 2 max: 8;  parameter  Latest hour to start work  var: max_work_start category:  People  min: 8 max: 12;  parameter  Earliest hour to end work  var: min_work_end category:  People  min: 12 max: 16;  parameter  Latest hour to end work  var: max_work_end category:  People  min: 16 max: 23;  parameter  minimal speed  var: min_speed category:  People  min: 0.1 #km/#h ;  parameter  maximal speed  var: max_speed category:  People  max: 10 #km/#h;  parameter  Value of destruction when a people agent takes a road  var: destroy category:  Road  ;  output {   display city_display type:opengl {    species building aspect: base ;    species road aspect: base ;    species people aspect: base ;   }  } }     ","url":"wiki/RoadTrafficModel_step5.md"},{"id":"wiki/RoadTrafficModel_step6.md","title":" 6. Charts","content":"6. Charts This 6th step illustrates how to display charts.  Formulation    Add a chart to display the evolution of the road destruction: the mean value of the destruction_coeff of the road agents, and its max value (refreshed every 10 simulation steps).   Add a chart to display the activity of the people agent (working or staying home, refreshed every 10 simulation steps).   Model Definition ### chart display First we add a chart of type series to display the road destruction evolution. To compute the mean of the destruction_coeff, we use the mean operator. For the max, we use the max_of operator. output { display chart_display refresh:every(10) {    chart Road Status type: series size: {1, 0.5} position: {0, 0} {  data Mean road destruction value: mean (road collect each.destruction_coeff) style: line color: #green ;     data Max road destruction value: road max_of each.destruction_coeff style: line color: #red ;      }   ...       }    }   Second, we add a chart of type pie to display the activity of the people agents. We use for that the objective variable of the people agents and the count operator that allows to compute the number of elements of a list that verify a condition.       output {       ...       display chart_display refresh:every(10) { ... chart People Objectif type: pie style: exploded size: {1, 0.5} position: {0, 0.5}{         data Working value: people count (each.objective=working) color: #magenta ;         data Resting value: people count (each.objective=resting) color: #blue ;    }      }    }   Complete Model      model tutorial_gis_city_traffic  global {  file shape_file_buildings <- file( ../includes/building.shp );  file shape_file_roads <- file( ../includes/road.shp );  file shape_file_bounds <- file( ../includes/bounds.shp );  geometry shape <- envelope(shape_file_bounds);  float step <- 10 #mn;  int nb_people <- 100;  int current_hour update: (time / #hour) mod 24;  int min_work_start <- 6;  int max_work_start <- 8;  int min_work_end <- 16;   int max_work_end <- 20;   float min_speed <- 1.0 #km / #h;  float max_speed <- 5.0 #km / #h;   float destroy <- 0.02;  graph the_graph;  init {  create building from: shape_file_buildings with: [type::string(read (NATURE))] {   if type=Industrial {    color <- #blue ;   }  }  create road from: shape_file_roads ;  map<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));  the_graph <- as_edge_graph(road) with_weights weights_map;      list<building> residential_buildings <- building where (each.type=Residential);  list<building>  industrial_buildings <- building  where (each.type=Industrial) ;  create people number: nb_people {   speed <- min_speed + rnd (max_speed - min_speed) ;   start_work <- min_work_start + rnd (max_work_start - min_work_start) ;   end_work <- min_work_end + rnd (max_work_end - min_work_end) ;   living_place <- one_of(residential_buildings) ;   working_place <- one_of(industrial_buildings) ;   objective <- resting;   location <- any_location_in (living_place);   } }  reflex update_graph{  map<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));  the_graph <- the_graph with_weights weights_map; } }   species building {  string type;   rgb color <- #gray  ;  aspect base {  draw shape color: color ; } }   species road  {  float destruction_coeff <- 1 + ((rnd(100))/ 100.0) max: 2.0;  int colorValue <- int(255(destruction_coeff - 1)) update: int(255(destruction_coeff - 1));  rgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;  aspect base {  draw shape color: color ; } }   species people skills:[moving] {  rgb color <- #yellow ;  building living_place <- nil ;  building working_place <- nil ;  int start_work ;  int end_work  ;  string objective ;   point the_target <- nil ;  reflex time_to_work when: current_hour = start_work and objective = resting{  objective <- working ;  the_target <- any_location_in (working_place); }   reflex time_to_go_home when: current_hour = end_work and objective = working{  objective <- resting ;  the_target <- any_location_in (living_place);  }    reflex move when: the_target != nil {  path path_followed <- self goto [target::the_target, on::the_graph, return_path:: true];  list<geometry> segments <- path_followed.segments;  loop line over: segments {   float dist <- line.perimeter;   ask road(path_followed agent_from_geometry line) {     destruction_coeff <- destruction_coeff + (destroy * dist / shape.perimeter);   }  }  if the_target = location {   the_target <- nil ;  } }  aspect base {  draw circle(10) color: color; } }   experiment road_traffic type: gui {  parameter  Shapefile for the buildings:  var: shape_file_buildings category:  GIS  ;  parameter  Shapefile for the roads:  var: shape_file_roads category:  GIS  ;  parameter  Shapefile for the bounds:  var: shape_file_bounds category:  GIS  ;  parameter  Number of people agents  var: nb_people category:  People  ;  parameter  Earliest hour to start work  var: min_work_start category:  People  min: 2 max: 8;  parameter  Latest hour to start work  var: max_work_start category:  People  min: 8 max: 12;  parameter  Earliest hour to end work  var: min_work_end category:  People  min: 12 max: 16;  parameter  Latest hour to end work  var: max_work_end category:  People  min: 16 max: 23;  parameter  minimal speed  var: min_speed category:  People  min: 0.1 #km/#h ;  parameter  maximal speed  var: max_speed category:  People  max: 10 #km/#h;  parameter  Value of destruction when a people agent takes a road  var: destroy category:  Road  ;  output {   display city_display type:opengl {    species building aspect: base ;    species road aspect: base ;    species people aspect: base ;   }   display chart_display refresh:every(10) {     chart  Road Status  type: series size: {1, 0.5} position: {0, 0} {     data  Mean road destruction  value: mean (road collect each.destruction_coeff) style: line color: #green ;     data  Max road destruction  value: road max_of each.destruction_coeff style: line color: #red ;    }    chart  People Objectif  type: pie style: exploded size: {1, 0.5} position: {0, 0.5}{     data  Working  value: people count (each.objective= working ) color: #magenta ;     data  Resting  value: people count (each.objective= resting ) color: #blue ;    }   }  } }     ","url":"wiki/RoadTrafficModel_step6.md"},{"id":"wiki/RoadTrafficModel_step7.md","title":" 7. Automatic Road Repair","content":"7. Automatic Road Repair This 7th step illustrates how how to select in a list an element that optimize a given function.  Formulation    Add a new parameter, repair_time, that is equal to 2.   Every repair_time, the road with the highest destruction_coeff value is repaired (set its destruction_coeff to 1).   Model Definition  parameters We add a new parameter: the repair_time.  In the global section, definition of the repair_time variable:     int repair_time <- 2 ;   In the experiment section, definition of the parameter:     parameter Number of steps between two road repairs var: repair_time category: Road ;   road repairing We have to add a reflex method in the global section that is triggered every repair_time hours / step. This method selects, thanks to the with_max_of operation the road agent with the highest destruction_coeff value, then sets this value at 1.   global {    ...    reflex repair_road when: every(repair_time #hour / step) {  road the_road_to_repair <- road with_max_of (each.destruction_coeff) ;  ask the_road_to_repair {   destruction_coeff <- 1.0 ;  }    } }   Complete Model      model tutorial_gis_city_traffic  global {  file shape_file_buildings <- file( ../includes/building.shp );  file shape_file_roads <- file( ../includes/road.shp );  file shape_file_bounds <- file( ../includes/bounds.shp );  geometry shape <- envelope(shape_file_bounds);  float step <- 10 #mn;  int nb_people <- 100;  int current_hour update: (time / #hour) mod 24;  int min_work_start <- 6;  int max_work_start <- 8;  int min_work_end <- 16;   int max_work_end <- 20;   float min_speed <- 1.0 #km / #h;  float max_speed <- 5.0 #km / #h;   float destroy <- 0.02;  int repair_time <- 2 ;  graph the_graph;  init {  create building from: shape_file_buildings with: [type::string(read (NATURE))] {   if type=Industrial {    color <- #blue ;   }  }  create road from: shape_file_roads ;  map<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));  the_graph <- as_edge_graph(road) with_weights weights_map;      list<building> residential_buildings <- building where (each.type=Residential);  list<building>  industrial_buildings <- building  where (each.type=Industrial) ;  create people number: nb_people {   speed <- min_speed + rnd (max_speed - min_speed) ;   start_work <- min_work_start + rnd (max_work_start - min_work_start) ;   end_work <- min_work_end + rnd (max_work_end - min_work_end) ;   living_place <- one_of(residential_buildings) ;   working_place <- one_of(industrial_buildings) ;   objective <- resting;   location <- any_location_in (living_place);   } }  reflex update_graph{  map<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));  the_graph <- the_graph with_weights weights_map; } reflex repair_road when: every(repair_time #hour / step) {  road the_road_to_repair <- road with_max_of (each.destruction_coeff) ;  ask the_road_to_repair {   destruction_coeff <- 1.0 ;  } } }   species building {  string type;   rgb color <- #gray  ;  aspect base {  draw shape color: color ; } }   species road  {  float destruction_coeff <- 1 + ((rnd(100))/ 100.0) max: 2.0;  int colorValue <- int(255(destruction_coeff - 1)) update: int(255(destruction_coeff - 1));  rgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;  aspect base {  draw shape color: color ; } }   species people skills:[moving] {  rgb color <- #yellow ;  building living_place <- nil ;  building working_place <- nil ;  int start_work ;  int end_work  ;  string objective ;   point the_target <- nil ;  reflex time_to_work when: current_hour = start_work and objective = resting{  objective <- working ;  the_target <- any_location_in (working_place); }   reflex time_to_go_home when: current_hour = end_work and objective = working{  objective <- resting ;  the_target <- any_location_in (living_place);  }    reflex move when: the_target != nil {  path path_followed <- self goto [target::the_target, on::the_graph, return_path:: true];  list<geometry> segments <- path_followed.segments;  loop line over: segments {   float dist <- line.perimeter;   ask road(path_followed agent_from_geometry line) {     destruction_coeff <- destruction_coeff + (destroy * dist / shape.perimeter);   }  }  if the_target = location {   the_target <- nil ;  } }  aspect base {  draw circle(10) color: color; } }   experiment road_traffic type: gui {  parameter  Shapefile for the buildings:  var: shape_file_buildings category:  GIS  ;  parameter  Shapefile for the roads:  var: shape_file_roads category:  GIS  ;  parameter  Shapefile for the bounds:  var: shape_file_bounds category:  GIS  ;  parameter  Number of people agents  var: nb_people category:  People  ;  parameter  Earliest hour to start work  var: min_work_start category:  People  min: 2 max: 8;  parameter  Latest hour to start work  var: max_work_start category:  People  min: 8 max: 12;  parameter  Earliest hour to end work  var: min_work_end category:  People  min: 12 max: 16;  parameter  Latest hour to end work  var: max_work_end category:  People  min: 16 max: 23;  parameter  minimal speed  var: min_speed category:  People  min: 0.1 #km/#h ;  parameter  maximal speed  var: max_speed category:  People  max: 10 #km/#h;  parameter  Value of destruction when a people agent takes a road  var: destroy category:  Road  ;  parameter  Number of hours between two road repairs  var: repair_time category:  Road  ;  output {  display city_display type:opengl {   species building aspect: base ;   species road aspect: base ;   species people aspect: base ;  }  display chart_display refresh:every(10) {    chart Road Status type: series size: {1, 0.5} position: {0, 0} {    data Mean road destruction value: mean (road collect each.destruction_coeff) style: line color: #green ;    data Max road destruction value: road max_of each.destruction_coeff style: line color: #red ;   }   chart People Objectif type: pie style: exploded size: {1, 0.5} position: {0, 0.5}{    data Working value: people count (each.objective=working) color: #magenta ;    data Resting value: people count (each.objective=resting) color: #blue ;   }  } } }      ","url":"wiki/RoadTrafficModel_step7.md"},{"id":"wiki/ThreeD_step1.md","title":" 1. Basic Model","content":"1. Basic Model  In this first step, we will see how to define a 3D environment and populate it.  Formulation Initialize a 3D world with a population of cells placed randomly in a 3D 100x100x100 cube.   * Definition of the cells species   * Definition of the nb_cells parameter   * Creation of nb_cells cells agents randomly located in the 3D environment size: 100x100x100.    Model Definition  In this model we define one species of agent: the cells agents. The agents will be just displayed as a blue sphere of radius 1.   species cells{     aspect default {     draw sphere(1) color:#blue;      } }   Global Section  Global variable  Definition of a global variable nb_cells of type int representing the number of cells agents.   global {    int nb_cells <-100; }   Model initialization  Definition of the init block in order to create nb_cells cells agents. By default an agent is created with a random location in x and y, and a z value equal to 0. In our case we want to place the cells randomly in the 3D environment so we set a random value for x, y and z.   create cells number: nb_cells {   location <- {rnd(100), rnd(100), rnd(100)}; }   Experiment  In our model, we define a basic gui experiment called Tuto3D :  experiment Tuto3D type: gui { }   Input Definition of a parameter from the the global variable nb_cells :  experiment Tuto3D type: gui {    parameter Initial number of cells:  var: nb_cells min: 1 max: 1000 category: Cells;  }   Output  In our model, we define a display to draw the cells agents in a 3D environment.  output {   display View1 type:opengl {     species cells;   } }   Complete Model  This model is available in the model library (under Tutorials > 3D) and the GIT version of the model can be found here Model 01.gaml      model Tuto3D  global {   int nb_cells <-100;    init {      create cells number: nb_cells { location <- {rnd(100), rnd(100), rnd(100)};   }    } }  species cells{   aspect default {     draw sphere(1) color:#blue;    } }  experiment Tuto3D  type: gui {   parameter  Initial number of cells:   var: nb_cells min: 1 max: 1000 category:  Cells  ;    output {     display View1 type:opengl {       species cells;     }   } }     ","url":"wiki/ThreeD_step1.md"},{"id":"wiki/ThreeD_step2.md","title":" 2. Moving Cells","content":"2. Moving Cells  This second step model adds the moving3D skills to the cell agents and simply makes move the cells agent by defining a reflex that will call the action move. We will also add additional visual information to the display.  Formulation    Redefining the shape of the world with a 3D Shape.   Attaching new skills (moving3D) to cells agent.   Modify cells aspect   Add a graphics layer   <img src= http://img.youtube.com/vi/_QqUbC0MWRU/0.jpg  width= 425  height=344 />  Model Definition  Global Section  Global variable We use a new global variable called _environmentSize_that to define the size of our 3D environment. In the global section we define the new variable  int environmentSize <-100;   Then we redefine the shape of the world (by default the shape of the world is a 100x100 square) as cube that will have the size defined by the environment_size variable. To do so we change the shape of the world in the global section:   geometry shape <- cube(environmentSize);    Model initialization  When we create the cells agent we want to place them randomly in the 3D environement. To do so we set the location with a random value for x, y and z between 0 and environmentSize.   create cells number: nb_cells {    location <- {rnd(environmentSize), rnd(environmentSize), rnd(environmentSize)}; }   Moving3D skills In the previous example, we only created cells agent that did not have any behavior. In this step we want to make move the cells agent. To do so we add a moving3D skills to the cells.  More information on built-in skills proposed by Gama can be found here   species cells skills:[moving3D]{ ...    }   Then we define a new reflex for the species cells that consists in calling the action move bundled in moving3D skills.  reflex move{   do move; }    Finally we modify a bit the aspect of the sphere to set its size according to the environmentSize global variable previously defined.  aspect default {   draw sphere(environmentSize*0.01) color:#blue;    }   Experiment The experiment is the same as the previous one except that we will display the bounds of the environment by using the graphics layer.   graphics env{   draw cube(environmentSize) color: #black empty:true;  }   Output  output {   display View1 type:opengl{     graphics env{       draw cube(environmentSize) color: #black empty:true;      }     species cells;     } }   Complete Model  The GIT version of the model can be found here Model 02.gaml      model Tuto3D  global {   int nb_cells <-100;   int environmentSize <-100;   geometry shape <- cube(environmentSize);    init {      create cells number: nb_cells { location <- {rnd(environmentSize), rnd(environmentSize), rnd(environmentSize)};   }    } }  species cells skills:[moving3D]{  reflex move{    do move;   }     aspect default {     draw sphere(environmentSize*0.01) color:#blue;    } }  experiment Tuto3D  type: gui {   parameter  Initial number of cells:   var: nb_cells min: 1 max: 1000 category:  Cells  ;   output {     display View1 type:opengl{       graphics  env {        draw cube(environmentSize) color: #black empty:true;        }       species cells;     }   } }         ","url":"wiki/ThreeD_step2.md"},{"id":"wiki/ThreeD_step3.md","title":" 3. Connections","content":"3. Connections  Formulation    Mapping the network of connection   <img src= http://img.youtube.com/vi/6ZlBU6xTcfw/0.jpg  width= 425  height=344 />  Model Definition In this final step we will display edges between cells that are within a given distance.  Cells update  We add a new reflex to collect the neighbours of the cell that are within a certain distance :   species cells skills:[moving3D]{ ... reflex computeNeighbours {       neighbours <- cells select ((each distance_to self) < 10);  }    }   Then we update the cell aspect as follows. For each elements (cells) of the neighbours list we draw a line between this neighbour s location and the current cell s location.  aspect default {   draw sphere(environmentSize*0.01) color:#orange;   loop pp over: neighbors {     draw line([self.location,pp.location]);   }  }   Complete Model  The GIT version of the model can be found here Model 03.gaml      model Tuto3D  global {   int nb_cells <-100;   int environmentSize <-100;   geometry shape <- cube(environmentSize);    init {      create cells number: nb_cells { location <- {rnd(environmentSize), rnd(environmentSize), rnd(environmentSize)};   }    } }  species cells skills: [moving3D] {  rgb color;  list neighbors;  int offset;  reflex move {   do wander;  }   reflex computeNeighbors {   neighbors <- cells select ((each distance_to self) < 10); }   aspect default {  draw sphere(environmentSize*0.01) color:#orange;  loop pp over: neighbors {   draw line([self.location,pp.location]);  }  } }   experiment Tuto3D  type: gui {   parameter  Initial number of cells:   var: nb_cells min: 1 max: 1000 category:  Cells  ;   output {     display View1 type:opengl background:rgb(10,40,55){       graphics  env {        draw cube(environmentSize) color: #black empty:true;        }       species cells;     }   } }     ","url":"wiki/ThreeD_step3.md"},{"id":"wiki/IncrementalModel.md","title":" Incremental Model","content":"Incremental Model  This tutorial has for goal to give an overview all most of the capabilities of GAMA. In particular, it presents how to build a simple model and the use of GIS data, graphs, 3D visualization, multi-level modeling and differential equations. All the files related to this tutorial (images and models) are available in the Models Library (project Tutorials/Incremental Model).  Model Overview The model built in this tutorial concerns the study of the spreading of a disease in a small city. Three type of entities are taken into account: the people, the buildings and the roads.  We made the following modeling choice:   * Simulation step: 1 minute   * People are moving on the roads from building to building   * People use the shortest path to move between buildings   * All people have the same speed and move at constant speed   * Each time, people arrived at a building they are staying a certain time   * The staying time depends on the current hour (lower at 9h - go to work - at 12h go to lunch - at 18h - go back home)   * Infected people are never cured    Step List  This tutorial is composed of 7 steps corresponding to 7 models. For each step we present its purpose, an explicit formulation and the corresponding GAML code.     Simple SI Model   Charts   Integration of GIS Data   Movement on Graph   Visualizing in 3D   Multi-Level   Differential Equations  ","url":"wiki/IncrementalModel.md"},{"id":"wiki/LuneraysFlu.md","title":" Luneray's flu","content":"Luneray s flu  This tutorial has for goal to introduce how to build a model with GAMA and to use GIS data and graphs. In particular, this tutorial shows how to write a simple GAMA model (the structure of a model, the notion of species…) load gis data, to agentify them and to use a network of polylines to constraint the movement of agents. The pdf of the presentation corresponding to this tutorial is available here. All the files related to this tutorial (shapefiles and models) are available here.  The importation of models is described [here] (https://github.com/gama-platform/gama/wiki/G__ImportingModels)  Model Overview The model built in this tutorial concerns the spreading of a flu in the city of Luneray (Normandie, France).    Two layers of GIS data are used: a road layer (polylines) and a building layer (polygons). In this model, people agents are moving from building to building using the road network. Each infected people can infect the neighbor people.  Some data collected concerning Luneray and the disease: * Number of inhabitants: 2147 (source : wikipedia) * Mean speed of the inhabitants (while moving on the road) : 2-5 km/h * The disease - non lethal - is spreading (by air) from people to people * Time to cure the disease: more than 100 days * Infection distance: 10 meters * Infection probability (when two people are at infection distance) : 0.05/minute  From the data collected, we made some modeling choice: * Simulation step: 1 minute * People are moving on the roads from building to building  * Most of time people are moving to meet their friend then go back home * People use the shortest path to move between buildings * All people move at constant speed * Each time, people arrived at a building they are staying a certain time : they are staying longer in their home than in their friend houses * Infected people are never cured    Step List  This tutorial is composed of 5 steps corresponding to 5 models. For each step we present its purpose, an explicit formulation and the corresponding GAML code.     Creation of a first basic disease spreading model   Definition of monitors and chart outputs   Importation of GIS data   Use of a graph to constraint the movements of people   Definition of 3D displays  ","url":"wiki/LuneraysFlu.md"},{"id":"wiki/PredatorPrey.md","title":" Predator Prey","content":"Predator Prey  This tutorial presents the structure of a GAMA model as well as the use of a grid topology. In particular, this tutorial shows how to define a basic model, to define  grid agents  which are able to move within the constraints. It also introduce the displays and agents  aspect.  All the files related to this tutorial (images and models) are available in the Models Library (project Tutorials/Predator Prey). ## Content  Model Overview In this model, three types of entities are considered: preys, predators and vegetation cells. Preys eat grass on the vegetation cells and predators eat preys. At each simulation step, grass grows on the vegetation cells. Concerning the predators and preys, at each simulation step, they move (to a neighbor cell), eat, die if they do not have enough energy, and eventually reproduce.    Step List  This tutorial is composed of 12 incremental steps corresponding to 12 models. For each step we present its purpose, an explicit formulation and the corresponding GAML code of the model.     Basic model (prey agents)   Dynamic of the vegetation (grid)   Behavior of the prey agent   Use of Inspectors/monitors   predator agents (parent species)   Breeding of prey and predator agents   Agent display (aspect)   Complex behaviors for the preys and predators   Adding of a stopping condition   Definition of charts   Writing files   Image loading (raster data)  ","url":"wiki/PredatorPrey.md"},{"id":"wiki/RoadTrafficModel.md","title":" Road Traffic","content":"Road Traffic  This tutorial has for goal to present the use of GIS data and complex geometries. In particular, this tutorial shows how to load gis data, to agentify them and to use a network of polylines to constraint the movement of agents. All the files related to this tutorial (shapefiles and models) are available in the Models Library (project road_traffic_tutorial).  If you are not familiar with agent-based models or GAMA we advice you to have a look at the prey-predator model first.  Model Overview The model built in this tutorial concerns the study of the road traffic in a small city. Two layers of GIS data are used: a road layer (polylines) and a building layer (polygons). The building GIS data contain an attribute: the  NATURE  of each building: a building can be either  Residential  or  Industrial . In this model, people agents are moving along the road network. Each morning, they are going to an industrial building to work, and each night they are coming back home. Each time a people agent takes a road, it wears it out. More a road is worn out, more a people agent takes time to go all over it. The town council is able to repair some roads.    Step List  This tutorial is composed of 7 steps corresponding to 7 models. For each step we present its purpose, an explicit formulation and the corresponding GAML code.     Loading of GIS data (buildings and roads)   Definition of people agents   Movement of the people agents   Definition of weight for the road network   Dynamic update of the road network   Definition of a chart display   Automatic repair of roads  ","url":"wiki/RoadTrafficModel.md"},{"id":"wiki/ThreeD.md","title":" 3D Tutorial","content":"3D Tutorial  This tutorial introduces the 3D features offered by GAMA.  Model Overview  <img src= http://img.youtube.com/vi/6ZlBU6xTcfw/0.jpg  width= 425  height=344 />  Step List  This tutorial is composed of 3 steps corresponding to 3 models. For each step we present its purpose, an explicit formulation and the corresponding GAML code.     Basic model   Moving cells   Moving cells with neighbours  ","url":"wiki/ThreeD.md"},{"id":"wiki/LearnGAMLStepByStep.md","title":" Learn GAML Step by Step","content":"Learn GAML Step by Step  This large progressive tutorial has been designed to help you to learn GAML (GAma Modeling Language). It will cover the main part of the possibilities provided by GAML, and guide you to learn some more.  How to proceed to learn better ?  As you will progress in the tutorial, you will see several links (written in blue) to makes you jump to another part. You can click on them if you want to learn directly about a specific topic, but we do not encourage to do this, because you can get easily lost by reading this tutorial this way. As it is named, we encourage you to follow this tutorial  step by step . For each chapter, some links are available in the  search  tab, if you want to learn more about this subject.  Although, if you really want to learn about a specific topic, our advise is to use the  learning graph  interface, in the website, so that you can choose your area of interest, and a learning path will be automatically design for you to assimilate the specific concept better.  Good luck with your reading, and please do not hesitate to contact us through the mailing list if you have a question/suggestion ! ","url":"wiki/LearnGAMLStepByStep.md"},{"id":"wiki/Recipes.md","title":" Recipes","content":"Recipes  Understanding the structure of models in GAML and gaining some insight of the language is required, but is usually not sufficient to build correct models or models that need to deal with specific approaches (like equation-based modeling). This section is intended to provide readers with practical  how to s on various subjects, ranging from the use of database access to the design of agent communication languages. It is by no means exhaustive, and will progressively be extended with more  recipes  in the future, depending on the concrete questions asked by users. ","url":"wiki/Recipes.md"},{"id":"wiki/Tutorials.md","title":" Tutorials","content":"Tutorials  We propose some tutorials that are designed to allow modelers to become progressively autonomous with the GAMA platform. These tutorials cover different aspects of GAMA (Grid environment, GIS integration, 3D, multi-level modeling, equation-based models…). It is a good idea to keep a copy of the reference of the GAML language around when undertaking one of these tutorials.     Predator Prey   Road Traffic   3D Tutorial   Luneray s flu   Incremental Model   Predator Prey tutorial    This tutorial introduces the basic concepts of GAMA and the use of grids. It is based on the classic predator prey model (see for instance a formal definition here). It is particularly adapted to beginners that want to quickly learn how to build a simple model in GAMA.  Road Traffic    This tutorial introduces the use of GIS data. It is based on a mobility and daily activity model. It is particularly adapted to modelers that want to quickly learn how to integrate GIS data in their model and to use a road shapefile for the movement of their agents.  3D Tutorial  This tutorial introduces the use of 3D in GAMA. In particular, it offers a quick overview of the 3D capabilities of the platform and how to integrate 3D features in models.  Luneray s flu tutorial    This tutorial dedicated to beginners introduces the basic concepts of GAMA and proposes a brief overview of many features.  It concerns a model of disease spreading in the small city of Luneray. In particular, it presents how to integrate GIS data and use GIS, to use a road shapefile for the movement of agents, and to define a 3D display.  Incremental Model    This tutorial proposes is an advance version of the Luneray s tutorial. It concerns a model of disease spreading in a small city. In particular, it presents how to integrate GIS data and use GIS, to use a road shapefile for the movement of agents, to define a 3D display, to define a multi-level model and use differential equations. ","url":"wiki/Tutorials.md"},{"id":"wiki/WhatsNext.md","title":" What's next ?","content":"What s next ?  Now you have a runnable GAMA on your computer, and you know a bit more about how to use the platform, you are ready to navigate through the website. Use the new powerful functionnalities of the website :     Try the search engine of the website to find quickly the notion you want to learn.   Navigate through the website by 3 different ways :  !images/general/icon_default_navigation.png The classic navigation : to have a classic top-down navigation.       !images/general/icon_learning_graph_navigation.png The learning path navigation : select the concept you want to learn, and a learning path will be build just for you, in order to assimilate this concept more quickly !       !images/general/icon_search_navigation.png The search related navigation : for each page, some suggestions of related pages (dealing with the same concepts, or presenting the same GAML world) allows you to have a more transversal navigation.  ","url":"wiki/WhatsNext.md"},{"id":"wiki/CreatingAReleaseOfGama.md","title":" Product a release of GAMA","content":"Product a release of GAMA ## From the product Locate the file named gama.product (in plugin ummisco.gama.product) and open it. On the first page, select the link Eclipse Product export wizard and follow the instructions in it. You can specify a root directory (under which the plugins will be copied) and an export directory on your hard drive where to export the whole application. Then click Finish and wait for a few minutes while Eclipse exports and packages your application. Once it is done, you can safely delete the Repository folder and the logs.zip file. ## Specific to MacOS X Use Gama.app as the name of the root directory. Failing to do so will leave you with a non-working application.  [[/resources/images/Export_Mac.png]]  This should result in a self-contained Gama.app application. However, the enclosed Info.plist lacks several key definitions. Open it (in a text editor) and paste the following items under the first  (replace existing double entries if necessary):      NSHighResolutionCapable  True  CFBundleExecutable  Gama  CFBundleGetInfoString  Gama 1.7.0b, Copyright UMMISCO IRD/UPMC and partners 2006-2016 http://gama-platform.org  CFBundleShortVersionString  1.7.0b  CFBundleSignature  GAMA  CFBundleVersion  1.7.0b       If you also want the .gaml documents to be decorated with an icon and recognized when double-clicking on them, you can add:   <key>CFBundleDocumentTypes</key>  <array>   <dict>    <key>CFBundleTypeExtensions</key>    <array>     <string>gaml</string>    </array>    <key>CFBundleTypeIconFile</key>    <string>Model.icns</string>    <key>CFBundleTypeName</key>    <string>Gama Model</string>    <key>CFBundleTypeRole</key>    <string>Editor</string>    <key>CFBundleTypeOSTypes</key>    <array>     <string>TEXT</string>    </array>   </dict>  </array>   You can additionally create an icon (Model.icns) for these files, which needs to reside in Gama.app/Contents/Resources next to icon.icns. An example of icon is available in the plugin msi.gama.application/macosx.  On Windows OS No specific step to do. After select the link Eclipse Product export wizard, choose the directory for the export by click on Browse button, in Destination section. Then, click on Finish.  Configure your IDE in order to allow multi-platform builds     Open Eclipse Preferences   Navigate to Plugin Development Environment/Target Platform   Select your (active) target platform   Click Edit   Click Add   Select  Software Site    Click Next   In  Work With  type: http://download.eclipse.org/eclipse/updates/4.5 (replace 4.5 with your current version)   Check  Eclipse RCP Target Components    Check  Equinox Target Components    Uncheck  Include required software  (IMPORTANT)   Check  Include all environments  (IMPORTANT)   Press Finish   Wait for the plugins to be downloaded and provisioned   Press Finish   Press OK   Open your product file and select the  Export  option. You will see that the  Export for multiple platforms  checkbox is available. The next page allows you to choose for which platform you d like to export GAMA. ","url":"wiki/CreatingAReleaseOfGama.md"},{"id":"wiki/DevelopingControlArchitectures.md","title":" Developing architecture","content":"Developing architecture  In addition to existing control architectures, developers can add new ones.  Defining a new control architecture needs to create new statements of type behavior and included in species statements and to define how to manage their execution.  Implementation  A control architecture is a Java class, that:   * is annotated by the @skill annotation,   * extends the AbstractArchitecture class (to get benefits of everything from the reflex-based control architecture, the ReflexArchitecture class can be extended instead).  The AbstractArchitecture extends the ISkill and IStatement interfaces and add the 2 following methods:   * public abstract boolean init(IScope scope) throws GamaRuntimeException;   * public abstract void verifyBehaviors(ISpecies context);  The three main methods to implement are thus:   * public void setChildren(final List<? extends ISymbol> children): this method will be called at the compilation of the model. It allows to manage all the embeded statements (in children) and for example separate the statements that should be executed at the initialization only from the ones that should be executed at each simulation step. Following example allows to test the name of the all the embedded statements:  for ( final ISymbol c : children ) {    if( IKeyword.INIT.equals(c.getFacet(IKeyword.KEYWORD).literalValue()) ) {    * public abstract boolean init(IScope scope) throws GamaRuntimeException: this method is called only once, at the initialization of the agent.   * public Object executeOn(final IScope scope) throws GamaRuntimeException: this method is executed at each simulation step. It should manage the execution of the various embedded behaviors (e.g. their order or choose which one will be executed…) ","url":"wiki/DevelopingControlArchitectures.md"},{"id":"wiki/DevelopingIScope.md","title":" IScope interface","content":"IScope interface  An object of type IScope represents the context of execution of an agent (including experiments, simulations, and  regular  agents). Everywhere it is accessible (either passed as a parameter or available as an instance variable in some objects), it provides an easy access to a number of features: the current active agent, the shared random number generator, the global clock, the current simulation and experiment agents, the local variables declared in the current block, etc.  It also allows modifying this context, like changing values of local variables, adding new variables, although these functions should be reserved to very specific usages. Ordinarily, the scope is simply passed to core methods that allow to evaluate expressions, cast values, and so on.  Use of an IScope  A variable scope of type IScope can be used to:   * get the current agent with: scope.getAgentScope()  IAgent agent = scope.getAgentScope();    * evaluate an expression in the current scope:  String mes = Cast.asString(scope, message.value(scope));    * know whether the scope has been interrupted:  boolean b = scope.interrupted();  ","url":"wiki/DevelopingIScope.md"},{"id":"wiki/DevelopingIndexAnnotations.md","title":" Index of annotations","content":"Index of annotations  Annotations are used to link Java methods and classes to GAML language.  @action This annotations is used to tag a method that will be considered as an action (or primitive) in GAML. The method must have the following signature:  Object methodName(IScope) throws GamaRuntimeException and be contained in a class annotated with @species or @skill (or a related class, like a subclass or an interface).  This annotation contains:   * name (String): the name of the variable as it can be used in GAML.   * virtual (boolean, false by default): if true the action is virtual, i.e. equivalent to abstract method in java.   * args (set of @arg, empty by default): the list of arguments passed to this action. Each argument is an instance of arg.   * doc (set of @doc, empty by default): the documentation associated to the action.  @arg This annotations describes an argument passed to an action.  This annotation contains:   * name (String,    by default): the name of the argument as it can be used in GAML.   * type (set of ints, empty by default): An array containing the textual representation of the types that can be taken by the argument (see IType).   * optional (boolean, true by default): whether this argument is optional or not.   * doc (set of @doc, empty by default): the documentation associated to the argument.  @constant This annotation is used to annotate fields that are used as constants in GAML.  This annotation contains:   * category (set of Strings, empty by default): an array of strings, each representing a category in which this constant can be classified (for documentation indexes).   * value (String): a string representing the basic keyword for the constant. Does not need to be unique throughout GAML.   * altNames (set of Strings, empty by default): an Array of strings, each representing a possible alternative name for the constant. Does not need to be unique throughout GAML.   * doc (set of @doc, empty by default): the documentation attached to this constant.  @doc It provides a unified way of attaching documentation to the various GAML elements tagged by the other annotations. The documentation is automatically assembled at compile time and also used at runtime in GAML editors.  This annotation contains:   * value (String,    by default): a String representing the documentation of a GAML element.   * masterDoc (boolean, false by default): a boolean representing the fact that this instance of the operator is the master one, that is whether its value will subsume the value of all other instances of it.   * deprecated (String,    by default): a String indicating (if it is not empty) that the element is deprecated and defining, if possible, what to use instead.   * returns (String,    by default): the documentation concerning the value(s) returned by this element (if any)..   * comment (String,    by default): an optional comment that will appear differently from the documentation itself.   * special_cases (set of Strings, empty by default): an array of String representing the documentation of the  special cases  in which the documented element takes part.   * examples (set of @example, empty by default): an array of String representing some examples or use-cases about how to use this element.   * usages (set of @usage, empty by default): An array of usages representing possible usage of the element in GAML.   * see (set of Strings, empty by default): an array of String representing cross-references to other elements in GAML.  @example This facet describes an example, that can be used either in the documentation, as unit test or as pattern.  This annotation contains:   * value (String,    by default): a String representing the expression as example.   * var (String,    by default): The variable that will be tested in the equals, if it is omitted a default variable will be used.   * equals (String,    by default): The value to which the value will be compared.   * returnType (String,    by default): The type of the value that should be tested.   * isNot (String,    by default): The value to which the value will be compared.   * raises (String,    by default): The exception or warning that the expression could raise.   * isTestOnly (boolean, false by default): specifies that the example should not be included into the documentation.   * isExecutable (boolean, true by default): specifies that the example is correct GAML code that can be executed.   * test (boolean, true by default): specifies that the example is will be tested with the equals.   * isPattern (boolean, false by default): whether or not this example should be treated as part of a pattern (see @usage). If true, the developers might want to consider writing the example line (and its associated lines) using template variables (e.g. ${my_agent}).  @facet This facet describes a facet in a list of facets.  This annotation contains:   * name (String): the name of the facet. Must be unique within a symbol.   * type (set of int): the string values of the different types that can be taken by this facet.   * values (set of Strings, empty by default): the values that can be taken by this facet. The value of the facet expression will be chosen among the values described here.   * optional (boolean, false by default): whether or not this facet is optional or mandatory.   * doc (set of @doc, empty by default): the documentation associated to the facet.  @facets This annotation describes a list of facets used by a statement in GAML.  This annotation contains:   * value (set of @facet): array of @facet, each representing a facet name, type..   * ommissible (string): the facet that can be safely omitted by the modeler (provided its value is the first following the keyword of the statement).  @file This annotation is used to define a type of file.  This annotation contains:   * name (String): a (human-understandable) string describing this type of files, suitable for use in composed operator names (e.g.  shape ,  image …). This name will be used to generate two operators: name+ _file  and  is +name. The first operator may have variants taking one or several arguments, depending on the @builder annotations present on the class_.   * extensions (set of Strings): an array of extensions (without the  .  delimiter) or an empty array if no specific extensions are associated to this type of files (e.g. [ png , jpg , jpeg …]). The list of file extensions allowed for this type of files. These extensions will be used to check the validity of the file path, but also to generate the correct type of file when a path is passed to the generic  file  operator.   * buffer_content (int, ITypeProvider.NONE by default): the type of the content of the buffer. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the content type is searched using this provider).   * buffer_index (int, ITypeProvider.NONE by default): the type of the index of the buffer. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the index type is searched using this provider).   * buffer_type (int, ITypeProvider.NONE by default): the type of the buffer. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the type is searched using this provider).   * doc (set of @doc, empty by default): the documentation attached to this operator.  @getter This annotations is used to indicate that a method is to be used as a getter for a variable defined in the class. The variable must be defined on its own (in vars).  This annotation contains:   * value (String): the name of the variable for which the annotated method is to be considered as a getter.   * initializer (boolean, false by default): returns whether or not this getter shoud also be used as an initializer  @inside This annotation is used in conjunction with symbol. Provides a way to tell where this symbol should be located in a model (i.e. what its parents should be). Either direct symbol names (in symbols) or generic symbol kinds can be used.  This annotation contains:   * symbols (set of Strings, empty by default): symbol names of the parents.   * kinds (set of int, empty by default): generic symbol kinds of the parents (see ISymbolKind.java for more details).  @operator This annotation represents an  operator  in GAML, and is used to define its name(s) as well as some meta-data that will be used during the validation process.  This annotation contains:   * value (set of Strings, empty by default): names of the operator.   * category (set of string, empty by default): categories to which the operator belong (for documentation purpose).   * iterator (boolean, false by default): true if this operator should be treated as an iterator (i.e.requires initializing the special variable  each  of WorldSkill within the method).   * can_be_const (boolean, false by default): if true: if the operands are constant, returns a constant value.   * content_type (int, ITypeProvider.NONE by default): the type of the content if the returned value is a container. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the content type is searched using this provider).   * index_type (int, ITypeProvider.NONE by default): the type of the index if the returned value is a container. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the index type is searched using this provider).   * expected_content_type (set of int, empty by default): if the argument is a container, returns the types expected for its contents. Should be an array of IType.XXX.   * type (int, ITypeProvider.NONE by default): the type of the expression if it cannot be determined at compile time (i.e. when the return type is  Object ). Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the type is searched using this provider)..   * internal (boolean, false by default): returns whether this operator is for internal use only.    * doc (set of @doc, empty by default): the documentation attached to this operator.  @serializer It allows to declare a custom serializer for Symbols (statements, var declarations, species ,experiments, etc.). This serializer will be called instead of the standard serializer, superseding this last one. Serializers must be subclasses of the SymbolSerializer class.   * value (Class): the serializer class.  @setter This annotations is used to indicate that a method is to be used as a setter for a variable defined in the class. The variable must be defined on its own (in vars).  This annotation contains:   * value (String): the name of the variable for which the annotated method is to be considered as a setter.  @skill This annotations Allows to define a new skill (class grouping variables and actions that can be used by agents).  This annotation contains:   * name (String): a String representing the skill name in GAML (must be unique throughout GAML).   * attach_to (set of strings): an array of species names to which the skill will be automatically added (complements the  skills  parameter of species).   * internal (boolean, false by default): return whether this skill is for internal use only.   * doc (set of @doc, empty by default): the documentation associated to the skill.  @species This annotation represents a  species  in GAML. The class annotated with this annotation will be the support of a species of agents.  This annotation contains:   * name (string): the name of the species that will be created with this class as base. Must be unique throughout GAML.   * skills (set of strings, empty by default): An array of skill names that will be automatically attached to this species. Example:   @species(value=animal skills={moving})   * internal (boolean, false by default): whether this species is for internal use only.   * doc (set of @doc, empty by default): the documentation attached to this operator.  @symbol This annotation represents a  statement  in GAML, and is used to define its name(s) as well as some meta-data that will be used during the validation process.  This annotation contains:   * name (set of string, empty by default): names of the statement.   * kind (int): the kind of the annotated symbol (see ISymbolKind.java for more details).   * with_scope (boolean, true by default): indicates if the statement (usually a sequence) defines its own scope. Otherwise, all the temporary variables defined in it are actually defined in the super-scope.   * with_sequence (boolean): indicates wether or not a sequence can or should follow the symbol denoted by this class.   * with_args (boolean, false by default): indicates wether or not the symbol denoted by this class will accept arguments.   * remote_context (boolean, false by default): indicates that the context of this statement is actually an hybrid context: although it will be executed in a remote context, any temporary variables declared in the enclosing scopes should be passed on as if the statement was executed in the current context.   * doc (set of @doc, empty by default): the documentation attached to this symbol.   * internal (boolean, false by default): returns whether this symbol is for internal use only.   * unique_in_context (boolean, false by default): Indicates that this statement must be unique in its super context (for example, only one return is allowed in the body of an action)..   * unique_name (boolean, false by default): Indicates that only one statement with the same name should be allowed in the same super context.  @type It provides information necessary to the processor to identify a type.  This annotation contains:   * name (String,    by default): a String representing the type name in GAML.   * id (int, 0 by default): the unique identifier for this type. User-added types can be chosen between IType.AVAILABLE_TYPE and IType.SPECIES_TYPE (exclusive) (cf. IType.java).   * wraps (tab of Class, null by default): the list of Java Classes this type is  wrapping  (i.e. representing). The first one is the one that will be used preferentially throughout GAMA. The other ones are to ensure compatibility, in operators, with compatible Java classes (for instance, List and GamaList).   * kind (int, ISymbolKind.Variable.REGULAR by default): the kind of Variable used to store this type. See ISymbolKind.Variable.   * internal (boolean, false by default): whether this type is for internal use only.   * doc (set of @doc, empty by default): the documentation associated to the facet.  @usage This replaces @special_cases and @examples, and unifies the doc for operators, statements and others. An @usage can also be used for defining a template for a GAML structure, and in that case requires the following to be defined:   * A name (attribute  name ), optional, but better   * A description (attribute  value ), optional   * A menu name (attribute  menu ), optional   * A hierarchical path within this menu (attribute  path ), optional   * A pattern (attribute  pattern  or concatenation of the @example present in  examples  that define  isPattern  as true)  This annotation contains:   * value (String): a String representing one usage of the keyword. Note that for usages aiming at defining templates, the description is displayed on a tooltip in the editor. The use of the path allows to remove unecessary explanations. For instance, instead of writing : description= This template illustrates the use of a complex form of the  create  statement, which reads agents from a shape file and uses the tabular data of the file to initialize their attributes , choose: name= Create agents from shapefile  menu=STATEMENT; path={ Create ,  Complex forms } description= Read agents from a shape file and initialze their attributes . If no description is provided, GAMA will try to grab it from the context where the template is defined (in the documentation, for example).   * menu (String,    by default): Define the top-level menu where this template should appear. Users are free to use other names than the provided constants if necessary (i.e.  My templates ). When no menu is defined, GAMA tries to guess it from the context where the template is defined.   * path (set of Strings, empty be default): The path indicates where to put this template in the menu. For instance, the following annotation:   menu = STATEMENT; path = { Control ,  If } will put the template in a menu called  If , within  Control , within the top menu  Statement . When no path is defined, GAMA will try to guess it from the context where the template is defined (i.e. keyword of the statement, etc.)   * name (String,    by default): The name of the template should be both concise (as it will appear in a menu) and precise (to remove ambiguities between templates).   * examples (set of @example, empty by default): An array of String representing some examples or use-cases about how to use this element, related to the particular usage above.   * pattern (String,    by default): Alternatively, the contents of the usage can be descried using a @pattern (rather than an array of @example). The formatting of this string depends entirely on the user (e.g. including \\n and   for indentation, for instance).  @validator It allows to declare a custom validator for Symbols (statements, var declarations, species ,experiments, etc.). This validator, if declared on subclasses of Symbol, will be called after the standard validation is done. The validator must be subclass of IDescriptionValidator.   * value (Class): the validator class.  @var This annotation is used to describe a single variable or field.  This annotation contains:   * name (String): the name of the variable as it can be used in GAML.   * type (int): The textual representation of the type of the variable (see IType).   * of (int, 0 by default): The textual representation of the content type of the variable (see IType#defaultContentType()).   * index (int, 0 by default): The textual representation of the index type of the variable (see IType#defaultKeyType()).   * constant (boolean, false by default): returns whether or not this variable should be considered as non modifiable.   * init (String,    by default): the initial value of this variable as a String that will be interpreted by GAML.   * depend_on (set of Strings, empty by default): an array of String representing the names of the variables on which this variable depends (so that they are computed before).   * internal (boolean, false by default): return whether this var is for internal use only.   * doc (set of @doc, empty by default): the documentation associated to the variable.  @vars This annotation is used to describe a set of variables or fields.  This annotation contains:   * value (set of @var): an Array of var instances, each representing a variable. ","url":"wiki/DevelopingIndexAnnotations.md"},{"id":"wiki/DevelopingOperators.md","title":" Developing Operators","content":"Developing Operators  Operators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function. Developing a new operator allows, then, to add a new function to GAML.  Implementation  A new operator can be any Java method that:   * begins by the @operator (other fields can be added to the annotation): @operator(value = name_of_the_operator_gaml),  @operator(value = rgb) public static GamaColor rgb(final int r, final int g, final int b, final double alpha) {    The method:   * must return a value (that has to be one of the GAMA Type: Integer, Double, Boolean, String, IShape, IList, IGraph, IAgent…),   * can define any number of parameters, defined using Java type,   * can be either static or non-static:     * in the case it is static, the number of parameters (except an IScope attribute) of the method is equal to the number of operands of the GAML operator.     * in the case it is not static, a first operand is added to the operator with the type of the current class.   * can have a IScope parameter, that will be taken into account as operand of the operator.  Annotations ### @operator This annotation represents an  operator  in GAML, and is used to define its name(s) as well as some meta-data that will be used during the validation process.  This annotation contains:   * value (set of string, empty by default): names of the operator.   * content_type (integer) : if the operator returns a container, type of elements contained in the container   * can_be_const (boolean, false by default): if true: if the operands are constant, returns a constant value.   * category (set of string, empty by default): categories to which the operator belong (for documentation purpose).   * doc (set of @doc, empty by default): the documentation attached to this operator.  @doc It provides a unified way of attaching documentation to the various GAML elements tagged by the other annotations. The documentation is automatically assembled at compile time and also used at runtime in GAML editors.   * value (String,    by default): a String representing the documentation of a GAML element.   * deprecated (String,    by default): a String indicating (if it is not empty) that the element is deprecated and defining, if possible, what to use instead.   * returns (String,    by default): the documentation concerning the value(s) returned by this element (if any)..   * comment (String,    by default): an optional comment that will appear differently from the documentation itself.   * special_cases (set of Strings, empty by default): an array of String representing the documentation of the  special cases  in which the documented element takes part.   * examples (set of Strings, empty by default): an array of String representing some examples or use-cases about how to use this element.   * see (set of Strings, empty by default): an array of String representing cross-references to other elements in GAML.  All these annotations are defined in the GamlAnnotations.java file of the msi.gama.processor plug-in. ","url":"wiki/DevelopingOperators.md"},{"id":"wiki/DevelopingPlugins.md","title":" Developing Plugins","content":"Developing Plugins  This page details how to create a new plug-in in order to extend the GAML language with new skills, species, displays or operators. It also details how to create a plug-in that can be  uploaded on an update site and can be installed into the GAMA release. We consider here that the developer version of GAMA has been installed (as detailled in this page).  Creation of a plug-in  Here are detailled steps to create and configure a new GAMA plug-in.     File > New > Project > plug-in project   In the  New plug-in Project  /  Plug-in project  window:  Choose as name « name_of_the_plugin » (or anything else)       Check  Use défaut location        Check  Create a Java Project        The project should be targeted to run with Eclipse       working set is unchecked       Click on  Next  In the  New plug-in Project  /  Content  window:  Id : could contain the name of your institution and/or your project, e.g. « irit.maelia.gaml.additions »       version 1.0.0.qualifier (this latter mention is important if you plan on distributing the plugin on GAMA update site)       Name « Additions to GAML from Maelia project »       Uncheck  Generate an activator, a Java class that controls the plug-in s life cycle  ,       Uncheck  This plug-in will make contributions to the UI        Check  No  when its asks  Would you like to create a rich client application ?        Click on  Next  In the  New plug-in Project  /  Templates  window:  Uncheck  Create a plug-in using one of the templates        Click on  Finish  Your plug-in has been created.     Edit the file  Manifest.MF :  Overview pane:   check « This plug-in is a singleton »   Dependencies pane:   add (at least minimum) the three plug-ins  msi.gama.core ,  msi.gama.ext  and  msi.gama.processor  in the  Required Plug-ins . When you click on  Add , a new window will appear without any plug-in. Just write the beginning of the plug-in name in the text field under  Select a plug-in .   Runtime pane:   In exported Packages: nothing (but when you will have implemented new packages in the plug-in you should add them there) Add in the classpath all the additional libraries (.jar files) used in the project.   Extensions pane:    Add   gaml.extension    Save the file. This should create a  plugin.xml  file. Select the project and in menu Project > Properties:  Java Compiler  > Annotation Processing: check  Enable project specific settings , then in  Generated Source Directory , change  .apt_generated  in  gaml ,       Java Compiler  > Annotation Processing > Factory path: check  Enable project specific settings , then  Add Jars  and choose  msi.gama.processor/processor/plugins/msi.gama.processor.1.4.0.jar        Close the menu. It should compile the project and create the gaml directory.       Return in the Project > Properties Menu.       In Java Buildpath  > Source, check that the gaml directory has been added. Otherwise click on Add Folder and select the gaml directory The plug-in is ready to accept any addition to the GAML language, e.g. skills, actions, operators.  Do not forget to export the created packages that could be used by  clients , especially the packages containing the code of the additions (in the plugin.xml of the new project, tab  Runtime ).  To test the plug-in and use it into GAMA, developers have to define a new feature project containing your plugin and its dependencies, and adds this feature to the existing product (or a new .product file of your own). The use of feature is also mandatory to define a plug-in that can be uploaded on the update site and can be installed in the release of GAMA.  Creation of a feature  A feature is an Eclipse project dedicated to gather one or several plug-ins to integrate them into a product or to deploy them on the update site and install them from the GAMA release (a feature is mandatory in this case).  Here are detailled steps to create and configure a new feature.     File > New > Feature project (or File > New > Project… then  Plug-in Development > Feature Project)   In Feature properties  Choose a project name (e.g.  institution.gama.feature.pluginsName )       Click on  Next  In Referenced Plug-ins and fragments  Check  Initialize from the plug-ins list:        Choose the plug-ins that have to be gathered in the feature       Click on  Finish  A new project has been created. The  feature.xml  file will configure the feature.  In  Information pane :   You can add description of the various plug-ins of the feature, define the copyright notice and the licence.   In  Plug-ins and Fragments    In the Plug-ins and Fragments, additional plug-ins can be added.       Addition of a feature to the product  In the product, e.g. gama.product in the ummisco.gama.product project:   * Contents pane     * Click on Add button     * In the window select the feature     * Click on OK.  Remark: To check whether the new plug-in has been taken into account by GAMA, after GAMA launch, it should appear in the Eclipse console in a line beginning by  » GAMA bundle loaded in  .  How to make a plug-in available at GAMA update site for the GAMA release  Considering a working GAMA plugin named institution.gama.pluginsName  Configure plugin to be available for Maven  a/ Add pom.xml for plugin institution.gama.pluginsName : * Right click -> Configure -> Convert to maven project to add pom.xml: * Set:   * Group id: institution.gama.pluginsName   * Artifact id: institution.gama.pluginsName   * Version: 1.0.0-SNAPSHOT // must have -SNAPSHOT if the plugin version is x.x.x.qualifier   * Packaging: eclipse-plugin * Finish  b/ Configure pom.xml to recognize the parent pom.xml for Maven builds * Open pom.xml in institution.gama.pluginsName * Tab overview, Parent section, type in:   * Group id: msi.gama   * Artifact id: msi.gama.experimental.parent   * Version: 1.7.0-SNAPSHOT   * Relative path: ../msi.gama.experimental.parent * Save  c/ Update maven cache in eclipse (optional) It will fix this compilation error  Project configuration is not up-to-date with pom.xml. Select: Maven->Update Project… from the project context menu or use Quick Fix.  * Right click -> Maven -> Update project  Create a feature for the plugin  a/ Create new feature * New -> Project -> type in : feature -> Select  Feature Project  * Set:   * Project name: institution.gama.feature.pluginsName   * Uncheck use default location, type in: {current git repository}\\aaa.bbb.feature.ccc    * Feature Version: 1.0.0.qualifier   * Update Site URL: http://updates.gama-platform.org/experimental   * Update Site Name: GAMA 1.7.x Experimental Plugins Update Site * Click Next   * Initialize from the plugin list -> check all plugins needed:     institution.gama.pluginsName (1.0.0.qualifier) * Finish  b/  Add pom.xml for feature institution.gama.feature.pluginsName :     Right click -> Configure -> Convert to maven project (to add pom.xml)   Set:  Group id: institution.gama.feature.pluginsName       Artifact id: institution.gama.feature.pluginsName       Version: 1.0.0-SNAPSHOT       Packaging: eclipse-feature Finish   c/ Configure pom.xml to recognize the parent pom.xml for Maven builds * Open pom.xml in institution.gama.pluginsName * Tab overview, Parent section, type in:   * Group id: msi.gama   * Artifact id: msi.gama.experimental.parent   * Version: 1.7.0-SNAPSHOT   * Relative path: ../msi.gama.experimental.parent * Save  d/ Update maven cache in eclipse (optional) It will fix this compilation error  Project configuration is not up-to-date with pom.xml. Select: Maven->Update Project… from the project context menu or use Quick Fix.  * Right click -> Maven -> Update project  Update p2updatesite category.xml (this step will be done automatically by travis, soon) Open msi.gama.experimental.p2updatesite * Tab Managing the Categories -> Add feature -> institution.gama.feature.pluginsName  How to make a plug-in available as an extension for the GAMA release (obsolete)  Once the plug-in has been tested in the GAMA SVN version, it can be made available for GAMA release users.  First, the update_site should be checked out from the SVN repository:   * File > New > Other… > SVN > Project from SVN   * In Checkout Project from SVN repository     * Use existing repository location (it is the same location as for the GAMA code)     * Next   * In Select resource:     * Browse       * choose svn > update_site     * Finish   * Finish  Now the update_site project is available in the project list (in Package Explorer). The sequel describes how to add a new feature to the update site.   * Open the site.xml file   * In update site Map:     * Click on Extensions     * click on the Add Feature… button       * Choose the feature to be added       * It should appear in Extensions     * Select the added feature and click on the Synchronize… button       * Check Synchronize selected features only       * Finish     * Select the added feature and click on the Build button   * All the files and folder of the update_site project have been modified.   * Commit all the modifications on the SVN repository     * Richt-click on the project, Team > Update     * Richt-click on the project, Team > Commit…  The plug-in is now available as an extension from the GAMA release. More details about the update of the GAMA realease are available on the dedicated page. ","url":"wiki/DevelopingPlugins.md"},{"id":"wiki/DevelopingSkills.md","title":" Developing a New Skill","content":"Developing a New Skill  A skill adds new features (attributes) and new capabilities (actions) to the instances of the species that use it.  Defining the class  A Skill is basically a singleton and stateless Java class that:   * extends the abstract class Skill,   * begins by the annotation @skill: @skill(name = name_of_the_skill_in_gaml).  Note: GAMA annotations are classes defined into the msi.gama.precompiler.GamlAnnotations class.  Defining new attributes  To add new attributes to the species that declares this skill, developers have to define them before the class using the @vars and @var annotations. The @vars annotation contains a set of @var elements.  In a @var element, one has to define the name, the type and the default value of the attribute. For example in MovingSkill:  @vars({   @var(name = IKeyword.SPEED, type = IType.FLOAT, init = 1.0),   @var(name = IKeyword.HEADING, type = IType.INT, init = rnd(359)) })   In order to detail how to access these new attributes (if needed), developers have to define a getter (using @getter) and a setter (using @setter) methods. If no getter (and setter) is defined, the attribute can nevertheless be set and get, using implicit by default getter and setter. But as soon as a getter and/or a setter is defined, they replace the implicit default ones. For example:     @getter(var = IKeyword.SPEED) public double getSpeed(final IAgent agent) {     return (Double) agent.getAttribute(IKeyword.SPEED); }  @setter(IKeyword.SPEED) public void setSpeed(final IAgent agent, final double s) {     agent.setAttribute(IKeyword.SPEED, s); }      Defining new actions An action (also called primitive) is basically a Java method that can be called from the GAML language using the same syntax as the one used for calling actions defined in a model. The method should be annotated with @action, supplying the name of the action as it will be available in GAML.  The developer can also define parameters for this action using the annotation @arg will a set of parameters names. For example, the action goto of the MovingSkill is defined as follows:     @action(name= goto , args={      @arg(name =  target , type = { IType.AGENT, IType.POINT,IType.GEOMETRY }, optional = false),     @arg(name = IKeyword.SPEED, type = IType.FLOAT, optional = true),     @arg(name =  on , type = { IType.GRAPH }, optional = true)     } )  public IPath primGoto(final IScope scope) throws GamaRuntimeException { … }  It is called in GAMA models with:  do goto (target: the_target, on: the_graph);  or  path path_followed <- self goto (target: the_target, on: the_graph, return_path: true);      Access to parameters in actions To get the value of the arguments passed in GAML to the Java code, two methods can be useful:   * scope.hasArg(name_of_argument) returns a boolean value testing whether the argument  name_of_argument  has been defined by the modeler, since all the arguments to actions should be considered as optional.   * getArg(name_arg,IType), getFloatArg(name_param_of_float), getIntArg(name_param_of_int) and their variants return the value of the given parameter using a given (or predefined) type to cast it.  Warnings Developers should notice that:   * the method associated with an action has to return a non-void object.   * the method should have only one parameter: the scope (type IScope).   * the method can only throw GamaRuntimeExceptions. Other exceptions should be caught in the method and wrapped in a GamaRuntimeException before being thrown.  Annotations ### @skill This annotations Allows to define a new skill (class grouping variables and actions that can be used by agents).  This annotation contains:   * name (String): a String representing the skill name in GAML (must be unique throughout GAML).   * attach_to (set of strings): an array of species names to which the skill will be automatically added (complements the  skills  parameter of species).   * internal (boolean, false by default): return whether this skill is for internal use only.   * doc (set of @doc, empty by default): the documentation associated to the skill.  @var This annotations is used to describe a single variable or field.  This annotation contains:   * name (String): the name of the variable as it can be used in GAML.   * type (int): The textual representation of the type of the variable (see IType).   * of (int, 0 by default): The textual representation of the content type of the variable (see IType#defaultContentType()).   * index (int, 0 by default): The textual representation of the index type of the variable (see IType#defaultKeyType()).   * constant (int, false by default): returns whether or not this variable should be considered as non modifiable.   * init (String,    by default): the initial value of this variable as a String that will be interpreted by GAML.   * depend_on (set of Strings, empty by default): an array of String representing the names of the variables on which this variable depends (so that they are computed before).   * internal (boolean, false by default): return whether this var is for internal use only.   * doc (set of @doc, empty by default): the documentation associated to the variable.  @doc It provides a unified way of attaching documentation to the various GAML elements tagged by the other annotations. The documentation is automatically assembled at compile time and also used at runtime in GAML editors.   * value (String,    by default): a String representing the documentation of a GAML element.   * deprecated (String,    by default): a String indicating (if it is not empty) that the element is deprecated and defining, if possible, what to use instead.   * returns (String,    by default): the documentation concerning the value(s) returned by this element (if any)..   * comment (String,    by default): an optional comment that will appear differently from the documentation itself.   * special_cases (set of Strings, empty by default): an array of String representing the documentation of the  special cases  in which the documented element takes part.   * examples (set of Strings, empty by default): an array of String representing some examples or use-cases about how to use this element.   * see (set of Strings, empty by default): an array of String representing cross-references to other elements in GAML.  @getter This annotations is used to indicate that a method is to be used as a getter for a variable defined in the class. The variable must be defined on its own (in vars).  This annotation contains:   * value (String): the name of the variable for which the annotated method is to be considered as a getter.   * initializer (boolean, false by default): returns whether or not this getter should also be used as an initializer  @setter This annotations is used to indicate that a method is to be used as a setter for a variable defined in the class. The variable must be defined on its own (in vars).  This annotation contains:   * value (String): the name of the variable for which the annotated method is to be considered as a setter.  @action This annotations is used to tag a method that will be considered as an action (or primitive) in GAML. The method must have the following signature:  Object methodName(IScope) throws GamaRuntimeException and be contained in a class annotated with @species or @skill (or a related class, like a subclass or an interface).  This annotation contains:   * name (String): the name of the variable as it can be used in GAML.   * virtual (boolean, false by default): if true the action is virtual, i.e. equivalent to abstract method in java.   * args (set of arg, empty by default): the list of arguments passed to this action. Each argument is an instance of arg.   * doc (set of @doc, empty by default): the documentation associated to the action.  @arg This annotations describes an argument passed to an action.  This annotation contains:   * name (String,    by default): the name of the argument as it can be used in GAML.   * type (set of ints, empty by default): An array containing the textual representation of the types that can be taken by the argument (see IType).   * optional (boolean, true by default): whether this argument is optional or not.   * doc (set of @doc, empty by default): the documentation associated to the argument.  All these annotations are defined in the GamlAnnotations.java file of the msi.gama.processor plug-in. ","url":"wiki/DevelopingSkills.md"},{"id":"wiki/DevelopingSpecies.md","title":" Developing Species","content":"Developing Species  Additional built-in species can be defined in Java in order to be used in GAML models. Additional attributes and actions can be defined. It could be very useful in order to define its behavior thanks to external libraries (e.g. mulit-criteria decision-making, database connection…).  A new built-in species extends the GamlAgent class, which defines the basic GAML agents. As a consequence, new built-in species have all the attributes (name, shape, …) and actions (die…) of regular species.  Implementation  A new species can be any Java class that:   * extends the GamlAgent class,   * begins by the @species: @species(name = name_of_the_species_gaml),  @species(name = multicriteria_analyzer) public class MulticriteriaAnalyzer extends GamlAgent {   Similarly to skills, a species can define additional attributes and actions.  Additional attributes  Defining new attributes needs:   * to add @vars (and one embedded @var per additional attribute) annotation on top of the class,   * to define @setter and @getter annotations to the accessors methods.  For example, regular species are defined with the following annotation:  @vars({ @var(name = IKeyword.NAME, type = IType.STRING), @var(name = IKeyword.PEERS, type = IType.LIST),  @var(name = IKeyword.HOST, type = IType.AGENT),  @var(name = IKeyword.LOCATION, type = IType.POINT, depends_on = IKeyword.SHAPE),  @var(name = IKeyword.SHAPE, type = IType.GEOMETRY) })   And accessors are defined using:     @getter(IKeyword.NAME) public abstract String getName();  @setter(IKeyword.NAME) public abstract void setName(String name);      Additional actions  An additional action is a method annotated by the @action annotation.  @action(name = ISpecies.stepActionName) public Object _step_(final IScope scope) {   Annotations ### @species This annotation represents a  species  in GAML. The class annotated with this annotation will be the support of a species of agents.  This annotation contains:   * name (string): the name of the species that will be created with this class as base. Must be unique throughout GAML.   * skills (set of strings, empty by default): An array of skill names that will be automatically attached to this species. Example:   @species(value=animal skills={moving})   * internal (boolean, false by default): whether this species is for internal use only.   * doc (set of @doc, empty by default): the documentation attached to this operator.  All these annotations are defined in the GamlAnnotations.java file of the msi.gama.processor plug-in. ","url":"wiki/DevelopingSpecies.md"},{"id":"wiki/DevelopingStatements.md","title":" Developing Statements","content":"Developing Statements  Statements are a fundamental part of GAML, as they represent both commands (imperative programming style) or declarations (declarative programming style). Developing a new statement allows, then, to add a new instruction to GAML.  Defining the class  A new statement must be a Java class that:   * either implements the interface IStatement or extends an existing implementation of this interface (like AbstractStatement or AbstractSequenceStatement).   * begins by the 2 following mandatory annotations:     * @symbol: @symbol(name = name_of_the_statement_gaml, kind = kind_of_statement, with_sequence = true/false),     * @inside: @symbol(kinds = {kind_of_statement_1,kind_of_statement_2,...}  In addition the 4 following optional annotations can be added:   * @facets: to describe the set of @facet annotations,   * @doc: to document the statement.   * @serializer: in addition, statements can benefit from a custom serializer, by declaring @serializer(CustomSerializer.class), with a class extending SymbolSerializer.   * @validator: in addition, statements can benefit from a custom validation during the validation process, by declaring @validator(CustomValidator.class) with a class implementing IDescriptionValidator as value. This class will receive the IDescription of the statement and be able to execute further validations on the type of expressions, etc. or even to change the IDescription  (by adding new information, changing the value of facets, etc.).  Note: GAMA annotations are classes defined into the msi.gama.precompiler.GamlAnnotations class.  Examples  The write statement  The write statement is an example of a SINGLE_STATEMENT (i.e. statement that does not embed a sequence of statements). It can used inside a BEHAVIOR statement (i.e. reflex, init…), a SEQUENCE_STATEMENT (e.g. loop, ask, if…) or a LAYER statement. It defines a single facet ( message ) mandatory and omissible.  @symbol(name = IKeyword.WRITE, kind = ISymbolKind.SINGLE_STATEMENT, with_sequence = false) @inside(kinds = { ISymbolKind.BEHAVIOR, ISymbolKind.SEQUENCE_STATEMENT, ISymbolKind.LAYER }) @facets(value = {   @facet(name = IKeyword.MESSAGE, type = IType.NONE, optional = false)     }, omissible = IKeyword.MESSAGE) public class WriteStatement extends AbstractStatement {   The aspect statement  The aspect statement defines an example of BEHAVIOR statement (i.e. a statement that can written at the same level as init, reflex…), containing a sequence of embedded statements. It can only be used inside a species statement (i.e. the definition of a new species) and the global block. It defines a single facet name mandatory and omissible.  @symbol(name = { IKeyword.ASPECT }, kind = ISymbolKind.BEHAVIOR, with_sequence = true, unique_name = true) @inside(kinds = { ISymbolKind.SPECIES, ISymbolKind.MODEL }) @facets(value = { @facet(name = IKeyword.NAME, type = IType.ID, optional = true)     }, omissible = IKeyword.NAME) public class AspectStatement extends AbstractStatementSequence {   The action statement  The action statement defines an example of ACTION statement containing a sequence of embedded statements and that can have arguments. It can be used (to define an action) in any species, experiment or global statement. It defines several facets and uses a custom validator and a custom serializer.  @symbol(name = IKeyword.ACTION, kind = ISymbolKind.ACTION, with_sequence = true, with_args = true, unique_name = true) @inside(kinds = { ISymbolKind.SPECIES, ISymbolKind.EXPERIMENT, ISymbolKind.MODEL }) @facets(value = {  @facet(name = IKeyword.NAME, type = IType.ID, optional = false),  @facet(name = IKeyword.TYPE, type = IType.TYPE_ID, optional = true, internal = true),  @facet(name = IKeyword.OF, type = IType.TYPE_ID, optional = true, internal = true),  @facet(name = IKeyword.INDEX, type = IType.TYPE_ID, optional = true, internal = true),  @facet(name = IKeyword.VIRTUAL, type = IType.BOOL, optional = true)      }, omissible = IKeyword.NAME) @validator(ActionValidator.class) @serializer(ActionSerializer.class) public class ActionStatement extends AbstractStatementSequenceWithArgs {   Implementation  All the statements inherits from the abstract class AbstractStatement. Statements with a sequence of embedded statements inherit from the class AbstractStatementSequence (which extends AbstractStatement).  The main methods of a statement class are:   * its constructor, that is executed at the compilation of the model.   * executeOn(final IScope scope), it executes the statement on a given scope. This method is executed at each call of the statement in the model,   * privateExecuteIn(IScope scope): the executeOn(final IScope scope) method implemented in AbstractStatement does some verification and call the privateExecuteIn(IScope scope) method to perform the statement. The execution of any statement should be redefined in this method.  Define a SINGLE_STATEMENT statement  To define a SINGLE_STATEMENT statement that can be executed in any behavior and sequence of statements and with 2 facets, we first define a new Java class that extends AbstractStatement such as:  @symbol(name = testStatement, kind = ISymbolKind.SINGLE_STATEMENT, with_sequence = false) @inside(kinds = { ISymbolKind.BEHAVIOR, ISymbolKind.SEQUENCE_STATEMENT}) @facets(value = {   @facet(name = IKeyword.NAME, type = IType.NONE, optional = false),  @facet(name = test_facet, type = IType.NONE, optional = true)  }, omissible = IKeyword.NAME) public class SingleStatementExample extends AbstractStatement {   The class should at least implement:   * a constructor: the constructor is called at the compilation. It is usually used to get the expressions given to the facets (using the getFacet(String) method) and to store it into an attribute of the class.     final IExpression name;  public SingleStatementExample(final IDescription desc) {  super(desc);  name = getFacet(IKeyword.NAME); }    * the **method privateExecuteIn**: this method is executed each time the statement is called in the model.  protected Object privateExecuteIn(IScope scope) throws GamaRuntimeException {   IAgent agent = stack.getAgentScope();  String nameStr = null;  if ( agent != null && !agent.dead() ) {   nameStr = Cast.asString(stack, name.value(stack));   if ( nameStr == null ) {    nameStr =  nil ;   }   GuiUtils.informConsole(nameStr);  }  return nameStr; }     The variable scope of type IScope can be used to:   * get the current agent with: scope.getAgentScope()   * evaluate an expression in the current scope: Cast.asString(scope, message.value(scope))  Define a statement with sequence  This kind of statements includes SEQUENCE_STATEMENT (e.g. if, loop,…), BEHAVIOR (e.g. reflex,…)…  Such a statement is defined in a class extending the AbstractStatementSequence class, e.g.:     @symbol(name = { IKeyword.REFLEX, IKeyword.INIT }, kind = ISymbolKind.BEHAVIOR, with_sequence = true, unique_name = true) @inside(kinds = { ISymbolKind.SPECIES, ISymbolKind.EXPERIMENT, ISymbolKind.MODEL }) @facets(value = { @facet(name = IKeyword.WHEN, type = IType.BOOL, optional = true),  @facet(name = IKeyword.NAME, type = IType.ID, optional = true) }, omissible = IKeyword.NAME) @validator(ValidNameValidator.class)  public class ReflexStatement extends AbstractStatementSequence {      This class should only implement a constructor. The class AbstractStatementSequence provides a generic implementation for:   * privateExecuteIn(IScope scope): it executes each embedded statement with the scope.   * executeOn(final IScope scope): it executes the statement with a given scope.  Additional methods that can implemented  The following methods have a default implementation, but can be overridden if necessary:   * the String getTrace(final IScope scope) method is called to trace the execution of statements using trace statement.  public String getTrace(final IScope scope) {  // We dont trace write statements  return ; }     * the setChildren(final List<? extends ISymbol> commands) is used to define which are the statement children to the sequence statement. By default, all the embedded statements are taken as children  Annotations ### @symbol This annotation represents a  statement  in GAML, and is used to define its name(s) as well as some meta-data that will be used during the validation process.  This annotation contains:   * name (set of string, empty by default): names of the statement.   * kind (int): the kind of the annotated symbol (see ISymbolKind.java for more details).   * with_scope (boolean, true by default): indicates if the statement (usually a sequence) defines its own scope. Otherwise, all the temporary variables defined in it are actually defined in the super-scope.   * with_sequence (boolean): indicates wether or not a sequence can or should follow the symbol denoted by this class.   * with_args (boolean, false by default): indicates wether or not the symbol denoted by this class will accept arguments.   * remote_context (boolean, false by default): indicates that the context of this statement is actually an hybrid context: although it will be executed in a remote context, any temporary variables declared in the enclosing scopes should be passed on as if the statement was executed in the current context.   * doc (set of @doc, empty by default): the documentation attached to this symbol.  @inside This annotation is used in conjunction with symbol. Provides a way to tell where this symbol should be located in a model (i.e. what its parents should be). Either direct symbol names (in symbols) or generic symbol kinds can be used.  This annotation contains:   * symbols (set of Strings, empty by default): symbol names of the parents.   * kinds (set of int, empty by default): generic symbol kinds of the parents (see ISymbolKind.java for more details).  @facets This annotation describes a list of facets used by a statement in GAML.  This annotation contains:   * value (set of @facet): array of @facet, each representing a facet name, type..   * ommissible (string): the facet that can be safely omitted by the modeler (provided its value is the first following the keyword of the statement).  @facet This facet describes a facet in a list of facets.  This annotation contains:   * name (String): the name of the facet. Must be unique within a symbol.   * type (set of Strings): the string values of the different types that can be taken by this facet.   * values (set of Strings): the values that can be taken by this facet. The value of the facet expression will be chosen among the values described here.   * optional (boolean, false by default): whether or not this facet is optional or mandatory.   * doc (set of @doc, empty by default): the documentation associated to the facet.  @doc It provides a unified way of attaching documentation to the various GAML elements tagged by the other annotations. The documentation is automatically assembled at compile time and also used at runtime in GAML editors.   * value (String,    by default): a String representing the documentation of a GAML element.   * deprecated (String,    by default): a String indicating (if it is not empty) that the element is deprecated and defining, if possible, what to use instead.   * returns (String,    by default): the documentation concerning the value(s) returned by this element (if any)..   * comment (String,    by default): an optional comment that will appear differently from the documentation itself.   * special_cases (set of Strings, empty by default): an array of String representing the documentation of the  special cases  in which the documented element takes part.   * examples (set of Strings, empty by default): an array of String representing some examples or use-cases about how to use this element.   * see (set of Strings, empty by default): an array of String representing cross-references to other elements in GAML.  @serializer It allows to declare a custom serializer for Symbols (statements, var declarations, species ,experiments, etc.). This serializer will be called instead of the standard serializer, superseding this last one. Serializers must be sublasses of the SymbolSerializer class.   * value (Class): the serializer class.  @validator It allows to declare a custom validator for Symbols (statements, var declarations, species ,experiments, etc.). This validator, if declared on subclasses of Symbol, will be called after the standard validation is done. The validator must be subclass of IDescriptionValidator.   * value (Class): the validator class.  All these annotations are defined in the GamlAnnotations.java file of the msi.gama.processor plug-in. ","url":"wiki/DevelopingStatements.md"},{"id":"wiki/DevelopingTypes.md","title":" Developing Types","content":"Developing Types  GAML provides a given number of built-in simple types (int, bool…) and more complex ones (path, graph…). Developing a new type allows, then, to add a new data structure to GAML.  Implementation Developing a new type requiers the implementation of 2 Java files:   * the first one that describes the data structure (e.g.: GamaColor.java to define a type color)   * the second one that implements the type itself, wrapping the data structure file (e.g.: GamaColorType.java), and providing accessors to data structure attributes.  The data structure file  The class representing the data structure is a Java class annotated by:   * a @vars annotation to describe the attributes of a complex type. The @vars annotation contains a set of @var elements.  @vars({ @var(name = IKeyword.COLOR_RED, type = IType.INT), @var(name = IKeyword.COLOR_GREEN, type = IType.INT),  @var(name = IKeyword.COLOR_BLUE, type = IType.INT), @var(name = IKeyword.ALPHA, type = IType.INT),  @var(name = IKeyword.BRIGHTER, type = IType.COLOR), @var(name = IKeyword.DARKER, type = IType.COLOR) }) public class GamaColor extends Color implements IValue {   It can contain setter and/or getter for each of its attributes. Setters and getters are methods annotated by the @getter or @setter annotations.  @getter(IKeyword.COLOR_RED) public Integer red() {  return super.getRed(); }   In addition it is recommended that this class implements the IValue interface. It provides a clean way to give a string representation of the type and thus eases good serialization of the object. To this purpose the following method needs to be implemented:  public abstract String stringValue(IScope scope) throws GamaRuntimeException;   The type file  The class representing the type is a Java class such that:   * the class should be annotated by the @type annotation,   * the class should extend the class GamaType<DataStructureFile> (and thus implement its 3 methods),  Example (from GamaFloatType.java):  @type(name = IKeyword.FLOAT, id = IType.FLOAT, wraps = { Double.class, double.class }, kind = ISymbolKind.Variable.NUMBER)   Inheritance from the GamaType<T> class Each java class aiming at implement a type should inherit from the GamaType abstract class. Example (from GamaColorType.java):  public class GamaColorType extends GamaType<GamaColor>   This class imposes to implement the three following methods (with the example of the GamaColorType):   * public boolean canCastToConst()   * public GamaColor cast(IScope scope, Object obj, Object param): the way to cast any object in the type,   * public GamaColor getDefault(): to define the default value of a variable of the current type.  Remark: for each type, an unary operator is created with the exact name of the type. It can be used to cast any expression in the given type. This operator calls the previous cast method.  Annotations  @type It provides information necessary to the processor to identify a type.  This annotation contains:   * name (String,    by default): a String representing the type name in GAML.   * id (int, 0 by default): the unique identifier for this type. User-added types can be chosen between IType.AVAILABLE_TYPE and IType.SPECIES_TYPE (exclusive) (cf. IType.java).   * wraps (tab of Class, null by default): the list of Java Classes this type is  wrapping  (i.e. representing). The first one is the one that will be used preferentially throughout GAMA. The other ones are to ensure compatibility, in operators, with compatible Java classes (for instance, List and GamaList).   * kind (int, ISymbolKind.Variable.REGULAR by default): the kind of Variable used to store this type. See ISymbolKind.Variable.   * internal (boolean, false by default): whether this type is for internal use only.   * doc (set of @doc, empty by default): the documentation associated to the facet.  All these annotations are defined in the file GamlAnnotations.java. ","url":"wiki/DevelopingTypes.md"},{"id":"wiki/Documentation.md","title":" Table of contents ","content":"Table of contents     Requirements  Configuration       Generated files location Workflow to generate wiki files   Workflow to generate PDF files   Workflow to generate unit tests   Main internal steps  Generate wiki files       Generate pdf files       Generate unit test files How to document  The @doc annotation       the @example annotation       How to document operators       How to document statements       How to document skills How to change the processor   General workflow of file generation   Documentation  The GAMA documentation comes in 2 formats: a set of wiki files availaible from the wiki section of the GitHub website and a PDF file. The PDF file is produced from the wiki files.  In the wiki files, some are hand-written by the GAMA community and some others are generated automatically from the Java code and the associated java annotations.  The section summarizes: * how to generate this wiki files, * how to generate the PDF documentation, * how to generate the unit tests from the java annotations,  * how to add documentation in the java code.  Requirements  To generate automatically the documentation, the GAMA Git version is required. See Install Git version for more details.  Among all the GAMA plugins, the following ones are related to documentation generation: * msi.gama.processor: the java preprocessor is called during java compilation of the various plugins and extract information from the java code and the java annotations. For each plugin it produces the docGAMA.xml file in the gaml directory. * msi.gama.documentation: it contains all the java classes needed to gather all the docGAMA.xml files and generate wiki, pdf or unit test files.  In addition, the folder containing the wiki files is required. In the GitHub architecture, the wiki documentation is stored in a separate Git repository https://github.com/gama-platform/gama.wiki.git. A local clone of this repository should thus be created: 1. Open the Git perspective:   * Windows > Open Perspective > Other…   * Choose Git 2. Click on  Clone a Git repository    * In Source Git repository window:      * Fill in the URI label with: https://github.com/gama-platform/gama.wiki.git     * Other fields will be automatically filled in.   * In Branch Selection windows,      * check the master branch      * Next   * In Local Destination windows,     * Choose the directory in which the gama Git repository has been cloned     * Everything else should be unchecked      * Finish 3. In the Git perspective and the Git Repositories view, Right-Click on  Working Directory  inside the gama.wiki repository, and choose  Import projects    * In the Select a wizard to use for importing projects window:     *  Import existing projects  should be checked     *  Working Directory  should be selected   * In Import Projects window:     * Uncheck « Search for nested project »     * Check the project gama.wiki     * Finish 2. Go back to the Java perspective: a gama.wiki plugin should have been added.  In order to generate the PDF file from the wiki files, we use an external application named Pandoc. Follow the Pandoc installation instructions to install it. Specify the path to the pandoc folder in the file  Constants.java , in the static constant CMD_PANDOC :  yourAbsolutePathToPandoc/pandoc .  Note that Latex should be installed in order to be able to generate PDF files. Make sure you have already installed Miktex (for OS Windows and Mac). Specify the path to the miktex folder in the file  Constants.java , in the static constant CMD_PDFLATEX :  yourAbsolutePathToMiktex/pdflatex .  Configuration  The location where the files are generated (and other constants used by the generator) are defined in the file msi.gama.documentation/src/msi/gama/doc/util/Constants.java.  The use of Pandoc (path to the application and so on) is defined in the file msi.gama.documentation/src/msi/gama/doc/util/ConvertToPDF.java. This should be changed in the future…  Generated files location The generated files are (by default) generated in various locations depending on their type: * wiki files: they are generated in the plugin gama.wiki. * pdf file: they are generated in the plugin msi.gama.documentation, in the folder files/gen/pdf. * unit test files: they are generated in the plugin msi.gama.models, in the folder models/Tests.  Workflow to generate wiki files  The typical workflow to generate the wiki files is as follow: * Clean and Build all the GAMA projects, * Run the MainGenerateWiki.java file in the msi.gama.documentation, * The wiki files are generated in the gama.wiki plugin.  Workflow to generate PDF files  The typical workflow to generate the wiki files is as follow: * Clean and Build all the GAMA projects, * In the file mytemplate.tex, specify the absolute path to your  gama_style.tex  (it should be just next to this file) * Run the MainGeneratePDF.java file in the msi.gama.documentation, accepting all the packages install of latex, * The wiki files are generated in the msi.gama.documentation plugin.  Note that generating the PDF takes a lot of time. Please be patient !  If you want to update the file  gama_style.sty  (for syntax coloration), you have to turn the flag  generateGamaStyle  to  true  (and make sure the file  keywords.xml  is already generated).  Workflow to generate unit tests  The typical workflow to generate the wiki files is as follow: * Clean and Build all the GAMA projects, * Run the MainGenerateUnitTest.java file in the msi.gama.documentation, * The wiki files are generated in the msi.gama.models plugin.  Main internal steps     Clean and Build all the GAMA projects will create a docGAMA.xml file in the gaml directory of each plugin,   The MainGenerateXXX.java files then perform the following preparatory tasks:  they prepare the gen folder by deleting the existing folders and create all the folders that may contain intermediary generated folders       they merge all the docGAMA.xml files in a docGAMAglobal.xml file, created in the files/gen/java2xml folder. Only the plugins that are referred in the product files are merged. After these common main first steps, each generator (wiki, pdf or unit test) performs specific tasks.  Generate wiki files     The docGamaglobal.xml is parsed in order to generate 1 wiki file per kind of keyword:  operators,       statements,       skills,       architectures,       built-in species,       constants and units.       in addition an index wiki file containing all the GAML keywords is generated. One wiki file is generated for each extension plugin, i.e. plugin existing in the Eclipse workspace but not refered in the product.   Generate pdf files  The pdf generator uses the table of content (toc) file located in the files/input/toc folder (msi.gama.documetation plugin) to organize the wiki files in a pdf file.     MainGeneratePDF.java file parsers the toc file and create the associated PDF file using the wiki files associated to each element of the toc. The generation is tuned using files located in the files/input/pandocPDF folder.   Generate unit test files     MainGenerateUnitTest.java creates GAMA model files for each kind of keyword from the docGAMAglobal.xml file.   How to document  The documentation is generate from the Java code thanks to the Java additional processor, using mainly information from Java classes or methods and from the Java annotations. (see the list of all annotations for more details about annotations).  The @doc annotation  Most of the annotations can contain a @doc annotation, that can contain the main part of the documentation.  For example, the inter (inter) operator is commented using:   @doc(   value = the intersection of the two operands,   comment = both containers are transformed into sets (so without duplicated element, cf. remove_deplicates operator) before the set intersection is computed.,   usages = {     @usage(value = if an operand is a graph, it will be transformed into the set of its nodes),     @usage(value = if an operand is a map, it will be transformed into the set of its values, examples = {       @example(value = [1::2, 3::4, 5::6] inter [2,4], equals = [2,4]),       @example(value = [1::2, 3::4, 5::6] inter [1,3], equals = []) }),     @usage(value = if an operand is a matrix, it will be transformed into the set of the lines, examples =       @example(value = matrix([[1,2,3],[4,5,4]]) inter [3,4], equals = [3,4])) },   examples = {      @example(value = [1,2,3,4,5,6] inter [2,4], equals = [2,4]),     @example(value = [1,2,3,4,5,6] inter [0,8], equals = []) },   see = { remove_duplicates })  This @docannotation contains 5 parts:  * value: describes the documented element, * comment: a general comment about the documented element, * usages: a set of ways to use the documented element, each of them being in a @usage annotation. The usage contains mainly a description and and set of examples, * examples: a set of examples that are not related to a particular usage,  * see: other related keywords.  the @example annotation  This annotation contains a particular use example of the documented element. It is also used to generate unit test and patterns.  The simplest way to use it:  @example(value = [1::2, 3::4, 5::6] inter [2,4], equals = [2,4])   In this example: * value contains an example of use of the operator, * equals contains the expected results of expression in value.  This will become in the documentation:  list var3 <- [1::2, 3::4, 5::6] inter [2,4];    // var3 equals [2,4]  When no variable is given in the annotation, an automatic name is generated. The type of the variable is determined thanks to the return type of the operator with these parameters.  This example can also generate a unit test model. In this case, the value in the variable will be compared to the equals part.  By default, the @example annotation has the following default values: * isTestOnly = false, meaning that the example will be added to the documentation too, * isExecutable = true, meaning that content of value can be added in a model and can be compiled (it can be useful to switch it to false, in a documentation example containing name of species that have not been defined), * test = true, meaning that the content of value will be tested to the content of equals, * isPattern = false.  How to document operators  A GAML operator is defined by a Java method annoted by the @operator annotation (see the list of all annotations for more details about annotations). In the core of GAMA, most of the operators are defined in the plugin msi.gama.core and in the package msi.gaml.operators.  The documentation generator will use information from: * the @operator annotation:   * value: it provides the name(s) of the operator (if an operator has several names, the other names will be considered as alternative names)   * category: it is used to classified the operators in categories * the @doc annotation, * the method definition:   * the return value type   * parameters and their type (if the method is static, the IScope attribute is not taken into account)  How to document statements  A GAML statement is defined by a Java class annoted by the @symbol annotation (see the list of all annotations for more details about annotations). In the core of GAMA, most of the statements are defined in the plugin msi.gama.core and in the package msi.gaml.statements.  The documentation generator will use information from: * @symbol annotation, * @facets annotation (each facet can contain a documentation in a @doc annotation), * @inside annotation (where the statement can be used), * @doc annotation  How to document skills  A GAML skill is defined by a Java class annoted by the @skill annotation (see the list of all annotations for more details about annotations). In the core of GAMA, most of the skills are defined in the plugin msi.gama.core and in the package msi.gaml.skills.  The documentation generator will use information from: * @skill annotation, * @vars annotation (each var can contain a documentation in a @doc annotation), * @doc annotation  How to change the processor  If you make some modifications in the plugin processor, you have to rebuild the .jar file associated to the processor to take in account the changes. Here are the several steps you have to do : - In the  processor  plugin, open the plugin.xml. - In exporting (from the Overview tab), click on Export Wizard. - In the tab  Destination , choose processor/plugins for the directory. In the tab  Options , delete the field Qualifier replacement. Click  finish . - Right click on the folder  processor  to refresh. –> It s ok !  General workflow of file generation  This following diagram explains roughly the workflow for the generation of the different files :   ","url":"wiki/Documentation.md"},{"id":"wiki/GamaArchitecture.md","title":" Architecture of GAMA","content":"Architecture of GAMA  GAMA is made of a number of Eclipse Java projects, some representing the core projects without which the platform cannot be run, others additional plugins adding functionalities or concepts to the platform.  Vocabulary: Each project is either designed as a plugin (containing an xml file  plugin.xml ) or as a feature (containing an xml file  feature.xml ).   * A plugin can be seen as a module (or bundle in the OSGI architecture), which can be necessary (the GAMA platform can t run without it) or optional (providing new functionalities to the platform). This decomposition between several plugins ensure the cohesion between functional blocks, each plugin has to be as independent as he can.   * A feature is a group of one or several modules (or plugin), which can be loaded. NB : Unlike a plugin, a feature does not include source code, but only two files : a build.properties and a feature.xml.  To see how to create a plugin and a feature, please read this page.  Table of contents     Architecture of GAMA  The minimal configuration       Optional Plugins   Plugins present in the release version Plugins not present by default in the release version Plugins not designated to be in the release version   Unmaintained projects       Features       Models       Plugins overview The minimal configuration  Here is the list of projects which have to be imported in order to run the GAMA platform, and to execute a simple model in gaml language:     msi.gama.core : Encapsulates the core of the modeling and simulation facilities offered by the platform : runtime, simulation, meta-model, data structures, simulation kernel, scheduling, etc. It contains 2 main packages :  msi.gama       msi.gaml, wich defines the GAML modeling language: keywords, operators, statements, species, skills� msi.gama.application : Describes the graphical user interface (msi.gama.gui package). This project also contains the file gama1.7.Eclipse3_8_2.product, when you can configure the application (and also launch the application). It contains the following sub-packages :  msi.gama.gui.displays       msi.gama.gui.navigator       msi.gama.gui.parameters       msi.gama.gui.swt       msi.gama.gui.views       msi.gama.gui.wizards       msi.gama.gui.viewers msi.gama.ext : Gathers all the external libraries upon which GAMA relies upon  msi.gama.lang.gaml : Contains the gaml.xtext file which defines the GAML grammar       msi.gama.lang.gaml.ui : Contains the GAML Editor (syntax highlighting, code completion�) msi.gama.processor : Is responsible for processing the annotations made in the Java source code and producing additions to GAML (Java, properties and documentation files), which are added into a source package called  gaml.additions  (containing two main generated files: GamlAdditions.java and GamlDocumentation.java). These additions are loaded automatically when GAMA launches, allowing extensions made by developers in other plugins to be recognized when their plugin is added to the platform.   ummisco.gaml.editbox : Project used to define the edit boxes in the gaml ui.   Minimal configuration projects dependencies:    Optional Plugins  Plugins present in the release version From this minimal configuration, it is possible to add some features. Here is the list of the features installed by default in the release version:   * idees.gama.mapcomparison : Contains some useful tools to do map comparaison   * msi.gaml.extensions.fipa : Provides some operators for communication between agents, using the FIPA standards   * msi.gama.headless : Enables to run simulations in console mode   * simtools.gaml.extensions.traffic : Provides operators and skills for traffic simulation   * simtools.gaml.extensions.physics : Physics engine, collision modelling, using the library JBullet   * ummisco.gaml.extensions.maths : Solving differential equation, using Euler methods and Runge Kutta.   * irit.gaml.extensions.database : Provides database manipulation tools, using SQL requests   * irit.gaml.extensions.test : Add unitary test statements   * ummisco.gama.opengl : Provide a 3D visualization using OpenGL.   * simtools.gamanalyzer.fr : Adding tools for the analysis of several execution result of a simulation (in order to find some correlations).   * dream.gama.opengis : Used to load some geographic information datas from online GIS server.   * simtools.graphanalysis.fr : Advanced graph operators  Plugins not present by default in the release version Some other plugins are not present by default in the release version (because their use is very specific), but it s possible to install them through features. Here is the list of those plugins:   * idees.gama.weka : Data-mining operators, using the library Weka.   * msi.gaml.architecture.simplebdi : Architecture for using the Belief-Desire-Intention software model.   * ummisco.gaml.extensions.sound : Use of sound in simulations   * ummisco.gaml.extensions.stats : Advanced statistics operators   * ummisco.gama.communicator : Communication between several instances of GAMA   * ummisco.gaml.extensions.rjava : Adding the R language into GAMA for data mining  Plugins not designated to be in the release version Other plugins will never be on the released version, and will never be loaded during the gama execution. They are just used in the  developer  version:   * msi.gama.documentation : Generate automatically the documentation in the wiki form (and also a pdf file)  Unmaintained projects  Some other projects are still in the git repository in case we need to work on it one day, but they are either unfinished, obsolete, or used in very rare situations (They are not delivered in release versions, of course). Here is the list :   * cenres.gaml.extensions.hydro : Provide some tools in order to create hydrology models   * msi.gaml.extensions.traffic2d : Provide some tools for traffic in 2 dimensions (depreciated, now replace by msi.gaml.extensions.traffic)   * msi.gaml.extensions.humainmoving : Provide a skill to represent human movement   * ummisco.gama.gpu : Computation directly on the GPU for more efficiency. Results or not concluant, slower than using CPU.   * msi.gama.hpc :  High Power Computing  to execute gama simulation in several computer.   * msi.gaml.extensions.cplex : Originaly designed to be able to run CPLEX function in GAMA. The CPLEX is a proprietary library, we can t deliver it in the project. Instead, we use a stub,  cplex.jar , that you can replace by the real cplex.jar file.   * irit.maelia.gaml.additions : Used for the project  Maelia . Provide the possibility to represent the computing time in a simulation.   * msi.gama.display.web : Originaly designed to run some GAMA simulation in a browser, inside gama application, using WebGL. Does not work for the moment   * ummisco.miro.extension : Once used for the  miro  project, no longer used.   * ummisco.miro.extension.traffic : Once used for the  miro  project, no longer used.  Features     ummisco.gama.feature.audio : sound plugin   ummisco.feature.stats : stats plugin   ummisco.gama.feature.opengl.jogl2 : gathers physics and opengl plugins   simtools.graphlayout.feature : gathers core, ext, processor and graphanalysis plugins   ummisco.gama.feature.core : gathers mapcomparison, database, test, application, core, ext, headless, gaml, gaml.ui, processor, fipa, traffic and maths plugins   ummisco.gama.feature.dependencies : a bunch of libraries and plugins   other.gama.feature.plugins gathers hydro, opengis, addition, web, hpc, cplex, traffic2d, communicator, gpu, stats, extensions and traffic plugins   ummisco.gama.feature.models : model plugin   idees.gama.features.weka : weka plugin   ummisco.gama.feature.jogl2.product : gathering of the following features : core, dependencies, models, jogl2   ummisco.gama.feature.product : gathering of the following features : core, dependencies, models, jogl1   Models  Beside those plugins and features, a project dedicated to gather a bunch of examples is also in the git repository. It contains gaml code:   * msi.gama.models  Plugins overview  Global architecture of GAMA (nb : the features graphlayout, core, dependencies, plugins, jogl2.product and product are not represented here)   ","url":"wiki/GamaArchitecture.md"},{"id":"wiki/InstallingGitVersion.md","title":" Installing the GIT version","content":"Installing the GIT version  Tested on MacOS X (10.9 to 10.11), Windows (8 to 10) and Ubuntu 15.04 (Vivid)  Important note: the current Git version is not compatible with the GAMA 1.6.1 release: if you plan to create plugins for this release, please download the source at revision r11988 (on Google Code) and Eclipse following this procedure  Install Eclipse Mars SR2  Download the  Eclipse IDE for Java and DSL Developers  version (If Java is not installed on your computer you can download it here).  Unpack it and launch it. Please refer to this link for more information on running Eclipse.  One important step required for GAMA to correctly produce its supporting files once it will have been installed is to set the default encoding of the workspace to UTF-8. It can be done by selecting, in the Preferences,  General , then  Workspace , then  Text file encoding  and choosing  UTF-8  in the drop-down menu available in  Other: .  Install GAMA source code  The source is to be downloaded from GitHub in two steps: by creating a local clone of the GitHub repository and then importing the different projects that constitute GAMA into the Eclipse workspace.     Open the Git perspective:   * Windows > Perspective > Open Perspective > Other…   * Choose Git    Click on  Clone a Git repository     * In Source Git repository window:  Fill in the URI label with: https://github.com/gama-platform/gama.git       Other fields will be automatically filled in.   * In Branch Selection windows,       check the master branch       Next       Note: If you are using Ubuntu 16 and you did not find any branch in this windows, may be your eclipse has a bug related with the OS. The workaround should be:   Close eclipse Open eclipse.ini Add these 2 lines before –launcher.appendVmargs:  –launcher.GTK_version    2   * Change required version of java from : -Dosgi.requiredJavaVersion=1.7 into -Dosgi.requiredJavaVersion=1.8   * Remove this line: -XX:MaxPermSize=256m   * Save and close eclipse.ini   * Start eclipse and redo from step 1    * In Local Destination windows,     * Choose a Directory (where the source files will be downloaded).     * Everything else should be unchecked      * Finish  This can take a while…  Import projects into workspace You have now to import projects into the workspace (notice that the folders downloaded during the clone will neither be copied nor moved).     In the Git perspective and the Git Repositories view, Right-Click on  Working Tree  inside the gama repository, and choose  Import projects     * In the Select a wizard to use for importing projects window:   Import existing projects  should be checked        Working Tree  should be selected   * In Import Projects window:       Uncheck « Search for nested project »       Check the projects you want to import       Finish  Go back to the Java perspective   Clean project (Project menu > Clean …)   If you have errors… If errors continue to show on in the different projects, be sure to correctly set the JDK used in the Eclipse preferences. GAMA is targeting JDK 1.8, and Eclipse will produce errors if it not found in your environment. So, either you set the compatibility to 1.8 by default (in Preferences > Java > Compiler > Compiler Compliance Level) or you change the error produced by Eclipse to a warning only (in Preferences > Java > Compiler > Building >  No strictly compatible JRE for execution environment available).  Run GAMA    In the ummisco.gama.product plugin, open the gama.runtime.product file (gama.product is used to produce the release).   Go to  Contents  tab and click on  Add required    Go to  Overview  tab and click on Synchronize   Click on Launch an Eclipse Application   GIT Tutorials For those who want learn more about Git and Egit, please consult the following tutorials/papers     EGIT/User Guide http://wiki.eclipse.org/EGit/User_Guide   Git version control with Eclipse (EGIT) - Tutorial http://www.vogella.com/tutorials/EclipseGit/article.html   10 things I hate about Git http://stevebennett.me/2012/02/24/10-things-i-hate-about-git/   Learn Git and GitHub Tutorial https://www.youtube.com/playlist?list=PL1F56EA413018EEE1  ","url":"wiki/InstallingGitVersion.md"},{"id":"wiki/InstallingSvnOldVersions.md","title":" Installing the SVN version","content":"Installing the SVN version  These installation procedures have been tested on MacOS X 10.6 to 10.9, and Windows 8. On Mac OS X 10.10 (Yosemite), please have a look here: install Java on Yosemite for details about the Java version to use. Eclipse 3.8.2 is the recommended Eclipse version to install GAMA. Kepler install is still experimental.  Important note: the current SVN version is no more compatible with the GAMA 1.6.1 release.   * If you plan to create plugin that should be compatible with the release, please download the GAMA code source at revision r11988 (on Google Code).   * If you want to have the last GAMA version (new GUI and APIs), you can download the head revision. The eclipse install should also be updated:     * EMF should be updated to the latest release available (2.10.2 in Apr. 2015)     * Xtext should be updated to the latest release (2.8.2 in April 2015)     * SWT 4.4     * ummisco.gaml.editbox plugin is now mandatory.  Detailed Instructions for Eclipse 4.4.2 (Luna SR2) ### Get and configure Eclipse Luna   1. Download the Eclipse Modeling Tools version of Luna SR2     * https://eclipse.org/downloads/packages/eclipse-modeling-tools/lunasr2   1. Unpack it anywhere and run it   1. Choose a new workspace     * A workspace is a folder in which Eclipse stores all your projects.   1. Install the required plugins. � Help � -> � Install new software �     * In  work with , write  http://download.eclipse.org/modeling/tmf/xtext/updates/composite/releases/ , click on  Add  and choose a name (e.g. Xtext)       * In  Xtext , install the following one:  * Xtext Complete SDK 2.8.2.v201504100559  Get code source from GitHub In Eclipse:   1. Windows > Open Perspective > Other�     * Git   1. Click on  Clone a Git repository      * First window:       * URI: https://github.com/gama-platform/gama.git     * Branch Selection:       * Check master       * Next     * Local Destination       * Choose a Directory       * Finish  You have then to import projects:   1. Right-Click on Working Directory > Import projects     * Select a wizard to use for importing projects:       *  Import existing projects  should be  checked       *  Working Directory  should be selected       * Next     * In Import Projects:       * Uncheck ��Search for nested project��       * Check the projects you want to import       * Finish  Go back to the Java perspective  Detailed Instructions for Eclipse 3.7.2 (Indigo) PLEASE NOTE THAT SUPPORT FOR THIS INSTALLATION HAS BEEN STOPPED. IF YOU CANNOT RUN A NEWER VERSION OF ECLIPSE, THEN YOU HAVE TO CHECKOUT THE LATEST VERSION OF GAMA WORKING IN INDIGO (r11438 (on Google Code)).   1. Download the Eclipse Modeling Tools version of Indigo     * http://www.eclipse.org/downloads/packages/eclipse-modeling-tools/indigosr2   1. Unpack it anywhere and run it   1. Choose a new workspace     * A workspace is a folder in which Eclipse stores all your projects.   1. Install the required plugins. � Help � -> � Install new software �     * In  Work with , type  http://download.eclipse.org/technology/subversive/0.7/update-site/  and install:       * In  Subversive SVN Team Provider Plugin (Incubation)   * Subversive SVN Team Provider (Incubation) 0.7.9.I20120520-1700     * In  work with , write  http://download.eclipse.org/modeling/tmf/xtext/updates/composite/releases/ , click on  Add  and choose a name (e.g. Xtext)       * In  Xtext-2.4.1    (to see it, you have to uncheck the  Show only the latest versions of available software )  * Xtext SDK 2.4.1.v201304180855     * If you plan to build a release version, in  work with , write  http://download.eclipse.org/tools/orbit/downloads/drops/R20110523182458/repository/ , click on  Add  and choose a name (e.g. ICU)       * Type  icu  in the text filter.       * The site should propose you a list of plugins. Choose (if this version is not available, untick ( Show only the latest versions ).  * International Components for Unicode for Java (ICU4J) Replacement plug-in 4.4.2.v20110208   1. Eclipse proposes to restart -> Restart now   1. Add SVN repository exploring perspective     * To activate this perspective, choose Window / Open Perspective / Other… and select  SVN Repository Exploring      * A popup appears (Discovery of SVN connector)     * Choose: SVN Kit 1.7.x       * Popup Unsigned content -> ok     * Popup -> restart now   1. Configure a new repository location:     * File > New > Other… > SVN > Repository Location     * URL: https://gama-platform.googlecode.com/svn     * Finish (& wait)   1. Checkout of the GAMA code source     * In the SVN repository view, navigate to the directory  branches/GAMA_CURRENT  and select  Find/Checkout As…  from the contectual menu.     * Choose  Find projects in the children of the selected resource  and follow the indications.     * Pop-up  Check Out projects , all projects should be selected. Finish.     * Once the checkout is finished, switch to Java Perspective.  To compile and run GAMA properly, you will need to configure your Eclipse IDE and the GAMA .product file.   1. By default, Eclipse uses Java 7 when it is installed whereas GAMA only needs Java 6. On MacOS X in particular, we may have to change the version of the JDK to ensure that GAMA will run smoothly.     * Window->Preferences     * In: Java / Compiler: set  Compiler compliance level  to 1.6     * In: Java / Installed JREs -> Add -> Standard VM -> JRE home -> Directory and choose the directory of a Java 6 JDK (preferable) or a Java 7 JDK (except for MacOS X, see Installation).       * Download the JDK 6 (for Windows & Linux) here       * Download the JDK 7 (for Windows & Linux) here.       * Download the JDK 6 (for Mac OS X) here. To switch between 1.7 and 1.6 (if both are installed), look at the use of java-home on this page.     * In: Java / Installed JREs -> select Java 1.6 (for Mac) or 1.7 (on Windows & Linux).   1. You should configure the GAMA .product file depending on your OS.     * In the msi.gama.application project, open the gama1.6.1.feature_based_release.product file.     * In: the  Launching  tab: check whether the launching options are correct       * In particular, for a 32bits OS, you have to change in  VM Arguments   -Xmx1536m  into  -Xmx1024m        * For 64bits OS, check that the option  -d32  is not in the  VM Arguments  (otherwise delete it) in the  macosx  specific tab.   1. Compile and Run GAMA     * Do a  Project -> Clean… (clean all projects)      * In the .product file, in  Overview  tab:       * click on the � Synchronize � link. This will ensure your product has updated the inclusion of the plugins (from both Eclipse and the new XText). Do not forget to save it.       * The product, or some of the included features, may complain about missing plugins (identified by an error icon on the plugin icon in the dependencies view). It is normal for  fragments  that apply to another OS than yours and it is harmless in this case. If you are, however, concerned about this, you can install the  delta-pack  for Eclipse 3.7.2 or Eclipse 3.8.2 (follow these steps: http://ugosan.org/eclipse-rcp-delta-pack/. The delta pack itself can be downloaded from here).       * If one of the missing plugins happens to be  com.ibm.icu.base  (and you did not want to install it as told above), you can replace it by  com.ibm.icu  without worries.       * As of GAMA 1.6.1, we use a version of the SWT binary fragments that is not the one shipped with Eclipse Indigo nor Juno. Although it is not mandatory to use it, it is required if you plan to produce release versions of GAMA from your product. To install it, simply download this file and install it like the delta pack above.       * click on the � Launch an Eclipse application � link. Note that a run configuration will be automatically created allowing to only click on the run button for future runs.  If the GAMA launch crashes:   * Open Run configurations….   * In Eclipse Application / gama1.6.1.feature_based_release.product configuration, open the plug-ins pane   * After Launch with: , choose  all workspace and enable plug-ins .  Detailed Instructions for Eclipse 3.8.2  First note that GAMA will not work with the packaged Juno version (in fact version 4.2 of Eclipse). Instead, you will need to download the core Eclipse package (Eclipse SDK) from http://archive.eclipse.org/eclipse/downloads/drops/R-3.8.2-201301310800/ , and to install additional plugins using this repository: http://download.eclipse.org/releases/juno/ . Among these additional plugins, only the EMF (Eclipse Modeling Framework) components should be necessary. In  Modeling :   * EMF - Eclipse Modeling Framework SDK   * EMF Validation Frameworkd SDK  The same instructions (than for Eclipse 3.7.2) can then be applied to this installation, with three differences :   * The delta-pack for Juno is available here.   * The name of the product to use is  gama1.6.1.feature_based_Eclipse3_8_2_updatable_release.product   * The version of XText to use is 2.8.2 and it should be obtained from here, as this site will also provide updates for EMF and other components necessary for XText to work (you may need to install these components first, notably EMF ones, if the installation of XText does not work).  Detailed Instructions for Eclipse 4.3.2 (Kepler)    Download the Eclipse Modeling Tools version   * http://www.eclipse.org/downloads/packages/eclipse-modeling-tools/keplersr2     1. Unpack it anywhere and run it     1. Choose a new workspace  A workspace is a folder in which Eclipse stores all your projects.   Install the required plugins. � Help � -> � Install new software �   In  Work with , type  http://download.eclipse.org/technology/subversive/0.7/update-site/  and install:   In  Subversive SVN Team Provider Plugin (Incubation)  Subversive SVN Team Provider (Incubation) 0.7.9.I20120520-1700       In  work with , write  http://download.itemis.de/updates/ , click on  Add  and choose a name (e.g. Xtext)   In  Xtext-2.5.3  Xtext SDK 2.5.3.v20140220820     In  Xtext Antlr-2.1.0  Xtext Antlr SDK 2.1.0.v201308291703       If you plan to build a release version, in  work with , write  http://download.eclipse.org/tools/orbit/downloads/drops/R20110523182458/repository/ , click on  Add  and choose a name (e.g. ICU)   Type  icu  in the text filter. The site should propose you a list of plugins. Choose (if this version is not available, untick ( Show only the latest versions ). International Components for Unicode for Java (ICU4J) Replacement plug-in 4.4.2.v20110208      1. Eclipse proposes to restart -> Restart now      1. Add SVN repository exploring perspective       To activate this perspective, choose Window / Open Perspective / Other… and select  SVN Repository Exploring        A popup appears (Discovery of SVN connector)       Choose: SVN Kit 1.7.x   Popup Unsigned content -> ok   Popup -> restart now   New > repository location   https://gama-platform.googlecode.com/svn       Finish (& wait)   Checkout of the GAMA code source   In the SVN repository view, navigate to the directory  branches/GAMA_CURRENT  and select  Find/Checkout As…  from the contectual menu.       Choose  Find projects in the children of the selected resource  and follow the indications.       Pop-up  Check Out projects , all projects should be selected. Select  Check out as a folders into workspace . Click  Next  and then  Finish .       Once the checkout is finished, switch to Java Perspective.   Configure Build path of all projects :   In the Properties of project, Java build path category, Libraries tab, click on JRE System Libray to change Excution environment from Java 1.6 to Java 1.7   Configure the GAMA .product file (gama1.6.1.feature_based_release.jogl2.product) :   In the msi.gama.application project, open the gama1.6.1.feature_based_release.jogl2.product file       In the  Dependencies  tab:   Choose all org.eclipse.equinox.* plugins and remove them.   Click Add button, type in org.eclipse.equinox and add all displayed packages.       Click Add button, type in org.eclipse.e4, then select all and click OK.       Click Add Required button, this will add two more: org.eclipse.emf.ecore and org.eclipse.emf.common   Configure ummisco.gama.feature.dependencies project:   In the ummisco.gama.feature.dependencies project, open the feature.xml file       In: the  Plugin  tab:   Click Add and type in org.w3c.dom, choose org.w3c.dom.events and org.w3c.dom.smil, click OK.  1. Compile and Run GAMA   Do a  Project -> Clean… (clean all projects)        In gama1.6.1.feature_based_release.jogl2.product file, in  Overview  tab.   click on the � Synchronize � link. This will ensure your product has updated the inclusion of the plugins (from both Eclipse 3.7 and the new XText). Do not forget to save it. click on the � Launch an Eclipse application � link. Note that a run configuration will be automatically created allowing to only click on the run button for future runs. Have fun!       Install additional plug-ins  Install the Graphical Modeling Framework  This installation procedure has been tested on a macbook pro with macosx 10.6 64 bits.  Important note: for the moment, the plug-in works only with Eclipse Indigo and graphiti 0.8. Some modifications will be made later to make it works with the latest version of Eclipse and graphiti.  Details  The graphical modeling framework is based on the Graphiti plug-in.     The first step consists in installing the graphiti plug-ins : � Help � -> � Install new software � In  Work with , choose  Indigo - http://download.eclipse.org/releases/indigo  and install: Graphiti, Graphiti Export, Graphiti SDK and Graphiti SDK Plus.   Eclipse proposes to restart -> Restart now   � Help � -> � Check of Updates �   Install the proposed updates   Eclipse proposes to restart -> Restart now   From the GAMA SVN, checkout the idees.gama.graphicalmodeling, idees.gama.emf.metamodel and idees.gama.feature.graphical_modeling projects.     * In the SVN repository view, navigate to the directory  branches/GAMA_CURRENT  and select the three mentioned projects and select  Find/Checkout As…  from the contectual menu.     * Choose  Find projects in the children of the selected resource  and follow the indications.     * Pop-up  Check Out projects , all projects should be selected. Finish.     * Once the checkout is finished, switch to Java Perspective.   You have to add the plugin to the GAMA .product file .     * In the msi.gama.application project, open the gama1.6.1.feature_based_release.product file     * In: the  Dependencies  tab: click on  Add …  and select the idees.gama.feature.graphical_modeling plugin     * In: the  Dependencies  tab: click on  Add Required plug-ins  then save the file   Compile and Run GAMA     * Do a  Project -> Clean… (clean all projects)      * In gama1.6.1.feature_based_release.product file, in  Overview  tab.  click on the � Synchronize � link. This will ensure your product has updated the inclusion of the plugins. Do not forget to save it.       click on the � Launch an Eclipse application � link. Note that, a run configuration will be automatically created allowing to only click on the run button for future runs. Note If you have some errors on the META-INF/MANIFEST.MF file (in particular on the line  org.eclipse.draw2d;bundle-version=3.8.3), you can follow next steps.     Fix the MANIFEST.MF error (if any)     * In the plug-in idees.gama.graphicalmodeling, open the file : META-INF/MANIFEST.MF     * In the  Dependencies  pane,  Select org.eclipse.draw2d (3.8.1) and click on the  Properties  button       In  Available version to match , select the one you have (mine is the v 3.7.2), and click on  Match  and  OK    Save the file Repeat Step 8 (clean, synchronize…)       Install additional plug-ins to generate the documentation    A plug-in to use Python should be installed as additional plug-ins: � Help � -> � Install new software � In  Work with , choose  http://pydev.org/updates  and install: PyDev for Eclipse.   Configure the Python Interpreters: Eclipse -> Preferences -> PyDev -> Interpreters -> Python Interpreter: Quick auto-config.  ","url":"wiki/InstallingSvnOldVersions.md"},{"id":"wiki/SerializeAgents.md","title":" Syntax in GAML","content":"Using SavedAgent kind of GamlAgent, it is now possible to serialize and unserialize agents and simulations as a string. It can be done using the operators: serializeSimulation, unserializeSimulation, saveSimulation of ummisco.gama.serialize.  Need to be improved: * serialization of random generator * serialization of shapes * to allow any agent to be serialized  Example of use of the two operators:     experiment toto {  list history <- [];  reflex store when: (cycle < 6){  add serializeSimulation(cycle) to: history; }  reflex restore when: (cycle = 6){  int i <- unSerializeSimulation(string(history[0])); }   reflex store22 when: cycle=2{  write Sauvegarde de la simulation  + saveSimulation(file.xml); } }       Syntax in GAML  How to make it as simple as possible for the modeler to save and restore simulation states, or come back in time ? (like the creation of new simulations, for instance, which reuses exactly the same syntax than the creation of agents) ?  Statements  store (to differentiate it from save) ? * to:  a file  restore with facets that could allow to precise: * at: a cycle number (to come back at a certain point in time) * at:  a negative number (to come back relatively in time) * at:  a date ?  * from: a file *   ","url":"wiki/SerializeAgents.md"},{"id":"wiki/WebsiteGeneration.md","title":" How to write the Website Content","content":"How to write the Website Content  In this page, we will explain all about the convention we use to write and generate the website content and the wiki content. Since the release of GAMA 1.7, with the new GAMA website, we have two contents: * The wiki content is hosted in github, witch directly interpret the markdown format of the files to display them in a proper way. This wiki, since it is a wiki, can be edited by any user. It is then, in constant changes. * The website content is the content of the real GAMA website. It is a verified and fixed version of the documentation (usually a re-generation of the website content is done when there is a new release of the software)  Index     Requirements   gama.wiki tree structure   Good practices when writing markdown files  Title       Hypertext Links       Images Links       Insert Metadatas Website Generation Workflow  Website Database       Loading the Database Manage concepts keywords   Requirements  To generate automatically the documentation, the GAMA Git version is required. See Install Git version for more details.  Among all the GAMA plugins, only one is related to documentation generation: * msi.gama.documentation: it contains some useful java scripts to help you to write a correct documentation.  In addition, the folder containing the wiki files is required. In the GitHub architecture, the wiki documentation is stored in a separate Git repository https://github.com/gama-platform/gama.wiki.git. A local clone of this repository should thus be created: 1. Open the Git perspective:   * Windows > Open Perspective > Other…   * Choose Git 2. Click on  Clone a Git repository    * In Source Git repository window:      * Fill in the URI label with: https://github.com/gama-platform/gama.wiki.git     * Other fields will be automatically filled in.   * In Branch Selection windows,      * check the master branch      * Next   * In Local Destination windows,     * Choose the directory in which the gama Git repository has been cloned     * Everything else should be unchecked      * Finish 3. In the Git perspective and the Git Repositories view, Right-Click on  Working Directory  inside the gama.wiki repository, and choose  Import projects    * In the Select a wizard to use for importing projects window:     *  Import existing projects  should be checked     *  Working Directory  should be selected   * In Import Projects window:     * Uncheck « Search for nested project »     * Check the project gama.wiki     * Finish 2. Go back to the Java perspective: a gama.wiki plugin should have been added.  gama.wiki tree structure  The  gama.wiki  plugin contains all the wiki content, and almost all the website content. It contains a folder content which contains the following folders: * Tutorials   * LearnGAMLStepByStep: contains the linear documentation to learn about the concepts of GAML   * Recipes: contains short pieces of documentation answering a specific problematic   * Tutorials: contains applicative tutorials  * References   * ModelLibrary: contains the model library (only present in the website)    * PlatformDocumentation: contains the documentation dealing with how to use the platform   * GAMLReferences: contains GAML references   * PluginDocumentation: contains the documentation of the additional plugins * Community   * Projects: contains a presentation of the projects where GAMA is involved (only present in the website)   * Training: contains a presentation of the training sessions organized by the GAMA team (only present in the website) * WikiOnly: contains the content only present in the wiki, and not in the website   * DevelopingExtensions: contains explanations about how to extend the platform * resources: contains all the additional resources needed (images, pdf…)  For the rest of this document, the highest level of tree structure ( Tutorials / References / Community / WikiOnly ) will be named as tabs. The level just under will be named as sections, and the level under will be named as sub-section. All this content is written using the markdown format. All the images resources are included in the resources/images folder. They are actually under different sub-folders. From the markdown page, you can call the resource with the relative path resource/images/sub_folder/image_name.png. If a section/sub-section contains one of several sub-division, then those sub-divisions will be stored in a folder with the name of the corresponding section/sub-section, and this section/sub-section folder will be associated with a markdown file with the same name (indeed, a section/sub-section has its own page). If a section/sub-section has no sub-division, then this section/sub-section is simply defined with a markdown file containing the content wanted.    Notice that there is some content which is present only in the wiki (the  WikiOnly  content), some content present only in the website (the model library, most of the community content…). In fact, the wiki tree structure is determined by the file Sidebar, while the website tree structure is determined by the file _WebsiteTreeStructure.  Good practices when writing markdown files  Title  Each markdown files has to start with a title in the markdown format (like # title). This is this title which will be displayed in the tree structure of the website.  Hypertext Links  Even if the repository how have a more complexe tree structure, you don t have to (and you must not !) speficy the relative or absolute path to the target page, just naming the page will work : [text_displayed](the_name_of_the_md_file)  Images Links  As already said in the previous paragraph, images have to be in an  resources/images/folder_name  folder next to your md file, so that you can write the relative path more easily.  Insert Metadatas  Metadatas in content files are written as comments, with the following syntax:   [//]: # (name_of_the_medatada|value_of_the_metadata)   Medatadas are not displayed in the wiki and the website content. For the website generation, metadatas are used in order to build the database, most of all to manage the search engine, and the learning graph.  Here is the list of metadata we use in the content files:   keyword : will write an invisible anchor in this exact place in the website. When the user will do a research about this word, he can access directly to this anchor. startConcept/endConcept : used to delimit a concept. The value of those two metadatas is the name of the concept. All the concepts are listed in the file  DependencyGraph , in the content folder in your wiki repository.      keyword  The value of the keyword has to have this structure : keyword_category_keyword_name (indeed, several keywords can have the same name ! The type of the keyword has to be specified). Here is the list of the several keyword categories : concept, operator, statement, species, architecture, type, constant and skill. Example of metadata : [//]: # (keyword|concept_3D), or [//]: # (keyword|operator_int).  startConcept/endConcept  The value of the keyword have to be one of the values defined in the file learningConcept.xml.  Notice that a concept in the meaning of keyword is not the same as a concept (or learning concept) in the learning graph !  Please read the part concerning the database to learn more about it.  Website generation workflow  This part is not implemented yet, it is under construction.    The gama.documentation plugin  This plugin is used to generate GAML documentation automatically in the markdown format, and copy paste the content to the wiki folder. The plugin is also used to generate the model library in the markdown format, with the source code, a quick description, and an image (screenshot). In the same time, the plugin generates a html page (an  abstract ) and put it directly in the model folder (in order to be loaded directly from GAMA).  The documentation plugin contains also 2 other scripts which helps to create content:  learningGraphDatabaseGenerator  The learningGraphDatabaseGenerator script is used to generate the  nodesDatabase.js  file, which is read to visualize the learning graph. This script needs the  learningGraph.xml  file as input. Each learning concepts has an id, a name, a very short description, a position (position in x and y in %, between 0 and 1. This value is then multiplied by the coeff in the learningGraphDatabaseGenerator), and a list of prerequisite learning concepts. A category of learning concept (also defined in the learningGraph.xml file) has an id, a position (position in x and y), a position for the hallow (position in x and y of the big circle displayed when a category is selected), a size for the hallow, a color, a name, and the list of learningConcept associated.  modelLibraryGenerator  The modelLibraryGenerator script is used to generate all the markdown files of the model library. This script     Parse all the models of the model library, and build an  input  xml file for a headless execution (this file is deleted at the end of the execution).  By default, this will ask to execute all the experiments for each model, and take a screenshot of the 10th cycle for each display.       You can change this default behavior by changing the file  modelScreenshot.xml , in the wiki repo (see description below) Execute the headless   Copy-paste all the generated images in the write folder, with the write names.   Browse a second time all the models, build the md file, including the screenshot computed from the headless execution, and analyzing the header of each model to extract the title, author and tags. Each md files respects the following format : path_from_model_with_underscore_instead_of_slash_without_strange_char +  .md . (ex :  Features/3D/3D Visualization/models/3D camera and trajectories.gaml  becomes  Features_3D_Visualization_models_3D_camera_and_trajectories.md .)   Format of the xml file to  tune up  the screenshot generation :        <experiment id=name_of_the_file_without_extention+ +model_name+ +experiment_name>   </experiment>       TODO  The gama.wiki repository  This repository contains in on hand the content auto generated by the documentation plugin, and in the other hand a handmade content. All the content is in the markdown format, organized through a specific tree structure, sometime containing metadatas.  The website repository  This repository contains: * A copy of the content of the wiki repo (copy/pasted manually to freeze a specific commit of the wiki) * A Database management system * A script used to interpret the metadatas from the content, in order to load the database * Some pages which are not in the wiki repo, and some heavy resources (such as videos)  Website database    Keyword  A keyword is a keyword that can be used for search, either manually (the user enters the wanted keyword in the searchbar of the website) or automatically (through the search tab in the navigation panel) A keyword in attached with a category (among the following names : concept, type, operator, statement, species, architecture, constant, action, attribute, skill, facet).     A keyword that is a concept can be linked with other keywords (ex : the keyword  BDI  will be linked with the keywords  eval_when ,  get_priority …)   A keyword that is a facet is linked to a statement or a species keyword (ex : the keyword  torus  will be linked with the keyword  global ).   A keyword that is an action or an attribute is linked either to a skill keyword (if it is actually an action or an attribute of a skill), an architecture keyword (if it is an action or a behavior of an architecture), or a species keyword (if it is a built-in action or attribute).   A keyword that is a statement can be linked to an architecture.   A keyword is composed of: * id (unique id) * name (the word which is searched by the user) * idCategory (id of the category)  A cagegory is composed of: * id (unique id) * name (the name of the category)    Alias  An other database is used to join an alias to an existing keyword. Ex : the word  alias  will be changed as  die .  An alias is composed of: * id (unique id) * name (name of the alias. ex :  kill ) * attachedKeywordName (name of the keyword attached. ex :  die )  Note that an alias does not know the id of the keyword, but only the name of the attached keyword(s). Indeed, the alias  integer  will give the keyword name  int , but several keywords correspond to the keyword name  int  (it can be the type  int , or the cast operator  int )    Webpage  A webpage can be either a page of the model library, a page of the gaml reference, or an other page of the documentation.  A webpage is composed of: * id (unique id) * name (name of the webpage) * webpageCategory (the name of the category of the webpage, a value among modelPage, docPage, gamlRefPage_).  The tables webpage and keyword are linked through an association table. This association table contains also an anchor (an anchor has an unique value) to the wanted paged.    Note that only the keywords which have the category concept, species, type, operator, skill and constant can be attached to a webpage.  The keywords which have the category action, attribute and facet forward to the attached keyword.  The keywords which have the category statement are attached to a webpage only if they are not attached to another keyword. If they are attached to another keyword (an architecture keyword), then the statement keyword forward to the attached keyword.  LearningConcept  LearningConcept is used to build the learning graph (notice that a  learning concept  and a  keyword concept  is not the same thing !)  A LearningConcept is composed with:     id (unique id)   name (name of the learning concept)   A LearningConcept is linked to a webpage through an association table. This table is composed also with two anchors that are used to delimit the position of the learning concept in a page (the beginning position and the ending position).  A LearningConcept can be associated to other LearningConcepts through an association table, used to spefify the  prerequisite concepts .    Loading the Database  The database is loaded from a gathering of independent files. Some of those files are handmade written, other are generated automatically.  Role of the documentation generation script in the construction of the database  As explained in the explication of the documentation generation pages, the documentation generation script is used to generate the gaml references and the model library pages (in the markdown format with metadatas), but also to build two files category.txt and keyword.xml.  The file category.txt is a very simple file, listing the different keyword categories. This file will be used to build the Category table.  Format of the file:  concept, type, statement, species, architecture, operator, skill, constant, action, attribute, facet   The file keyword.xml is an xml file that contains all the possible keywords (all except some keywords written manually directly in the documentation pages). The GAML words can be found directly using the code of GAMA. The concept words can be found using the code of GAMA (thanks to the tag  category ) and also by using the tags in the header of the model files. This xml file will be used to build the Keyword and the AssociationKeywordCategory tables.  Format of the file:        keywordname   keywordcategory keywordId1     keywordId2          Note that: * The list associatedKeywordList contains only one element for the facet keywords, one of no element for the action or attribute keywords (none when the action/attribute is a built-in), several or no elements for the concept keywords, and none for the other type of keywords.     The id is build with the value of the attribute  name  and with the value of the attribute  category  for every keywords except the statement, facet, action and attribute keywords, which need also the value of the associatedKeyword linked. Ex : the id of the facet  torus  will be  facet_torus_statement_global .   Preparation of the repository before the generation of the database  After the generation of the markdown content in the wiki repository, two other files have to be built manually : the files alias.txt and learningConcept.xml.  The alias.txt file contains all the connexions between alias and keyword name. It will be used to build the Alias table.  Format of the file :  aliasName1:remplacedWord1 aliasName2:remplacedWord2 kill:die   The learningConcept.xml file is used to list the learning concepts, and to connect them to their prerequisite concepts. It will be used to build the LearningConcept and the AssociationLearningConcept tables.  Format of the file :        learningConceptName learningConcept1     learningConcept2...         Note that the value of the attribute  name  can be used as an unique id.  Role of the website content generation script in the construction of the database  After copy-paste the content to the website folder, a script is used to build the database and to generate website content.  The Category, Alias, LearningConcept and AssociationLearningConcept tables are loaded easily from the files category.txt, alias.txt, and learningConcept.xml.  The Keyword and AssociationKeywordCategory tables are loaded from the keyword.xml file. Note that those two tables are not entirely loaded yet, because other keywords can be presents in the header of other files.  The markdown files are converted one by one into html format.       When a metadata startConcept/endConcept is found (syntax : [//]: # (beginAnchor name_of_learning_concept)), the metadata is replaced with an anchor in the page (with an unique id), and the AssociationWebpageConcept table is updated.  When a metadata keyword is found (syntax :  [//]: # (keyword name_of_keyword_category_name_of_keyword)), the metadata is replaced with an anchor in the page (with an unique id), and the AssociationWebpageKeyword table is updated (the Keyword and AssociationKeywordCategory are updated if the keyword does not exist yet in the table).       Manage concepts keywords  ALL the concepts must be declared in the  IConcept  java class. If you want to add a new concept, please check before if your the concept you want to add cannot be remplaced by one of the existing concept. If it is the case, you can add your word as if it was an alias, pointing to the existing concept. Note that all the alias are listed in the alias.txt file. If you realy think that the concept has to be added, please add it to the IConcept file, and also to (one or several) of the lists CONCEPTS_NOT_FOR_GAML_REF, CONCEPTS_NOT_FOR_MODEL_LIBRARY, CONCEPTS_DEDICATED_TO_SYNTAX in the ConceptManager class if needed.  Most of the keywords of the website (used for the search) are managed automatically. But the  concepts  keywords have to be (partially) hand-made managed. You can add the concepts with 3 differents methods :  In the Documentation  Documentation  here designs all the content manually written in the wiki. All those pages can contain  concepts  through the metadata format :  [//]: # (keyword|concept_name_of_concept)  You can either : - place those metadatas anywhere in the page if you want to point directly in this part of the page if the user makes a search - place those metadatas above the title : doing this, the  automatic search  (left navigation panel) will be made with this concept. You have to be really sure this concept is the main concept of the page to place it there.  In the Model library Directly from the gaml files of the model library, you can add the concept you want through the  Tags  in the header of the model.  Exemple :   /** * Name: 3D Display model of differents shapes and a special Object * Author:  * Description: Model presenting a 3D display of differents shapes (pyramid, cone, cylinder, sphere and a teapot object) to represent the same agents but with *       different aspects. Five experiments are possible, one for each of the shapes presented previously. In each experiment, the agents move to create a big circle but flee *       from their closest neighbour.  * Tags: 3d, shape, neighbors */   Note that if you don t want this model to have a page in the website, you can name it starting with the character _.  In the GAML References You can add a concept to a gaml word by using the syntax concept = { IConcept.MY_CONCEPT }.  Exemple :   @operator(value = flip,  concept = { IConcept.RANDOM }     The following text has been automatically generated from  mainCheckConcepts   ______ last update : 2017/02/28 14:21:42  List of concepts to use for model library (except Syntax):  3d, agent_location, agent_movement, algorithm, architecture, asc, batch, bdi, camera, chart, clustering, color, communication, comodel, comparison, csv, database, date, dem, dgs, diffusion, dxf, edge, elevation, equation, fipa, fsm, geometry, gis, graph, graph_weight, graphic, grid, gui, headless, hydrology, image, inheritance, inspector, light, load_file, math, mirror, monitor, multi_criteria, multi_level, multi_simulation, neighbors, network, nil, node, obj, obstacle, osm, overlay, physics_engine, r, raster, regression, save_file, scheduler, serialize, shape, shapefile, shortest_path, skill, sound, spatial_computation, spatial_relation, spatial_transformation, sport, statistic, svg, system, task_based, test, text, texture, tif, topology, transport, txt, xml  List of concepts to use exclusively in Syntax models:  arithmetic, attribute, cast, condition, container, filter, list, logical, loop, map, matrix, string, ternary  List of concepts to use for GAML worlds:  3d, action, agent_location, agent_movement, algorithm, architecture, arithmetic, asc, attribute, batch, bdi, behavior, camera, cast, chart, clustering, color, communication, comodel, comparison, condition, constant, container, csv, cycle, database, date, dem, dgs, diffusion, dimension, display, dxf, edge, elevation, equation, experiment, file, filter, fipa, fsm, geometry, gis, graph, graph_weight, graphic, graphic_unit, grid, gui, headless, hydrology, image, inspector, length_unit, light, list, load_file, logical, loop, map, math, matrix, mirror, monitor, multi_criteria, multi_level, multi_simulation, neighbors, network, nil, node, obj, obstacle, optimization, osm, overlay, parameter, physics_engine, point, r, random, random_operator, raster, regression, save_file, scheduler, serialize, shape, shapefile, shortest_path, skill, sound, spatial_computation, spatial_relation, spatial_transformation, species, statistic, string, surface_unit, svg, system, task_based, ternary, test, text, texture, tif, time, time_unit, topology, transport, txt, type, volume_unit, weight_unit, xml       Concept name       in Doc       in GAML Ref       in Model Lib       TOTAL   3d       2       17       39       58       action       3       5       _       9       agent_location       1       21       0       22       agent_movement       0       2       23       25       algorithm       1       8       2       11       architecture       2       11       1       14       arithmetic       0       33       0       33       asc       0       2       2       4       attribute       2       6       _       9       autosave       2       _       _       2       background       1       _       _       1       batch       3       8       4       15       bdi       1       51       0       52       behavior       3       7       _       10       camera       1       1       2       4       cast       1       17       1       19       chart       0       5       5       10       clustering       0       5       3       8       color       1       17       4       22       communication       0       3       0       3       comodel       0       0       8       8       comparison       0       6       2       8       condition       1       7       0       8       constant       0       13       _       13       container       1       60       1       62       csv       2       4       3       9       cycle       2       2       _       4       database       1       3       17       21       date       1       48       2       51       dem       0       0       1       1       dgs       0       0       1       1       diffusion       1       1       14       16       dimension       2       35       _       37       display       2       25       _       29       distribution       1       _       _       1       dxf       0       2       1       3       edge       1       15       1       17       elevation       0       0       7       7       enumeration       1       _       _       1       equation       2       7       15       24       experiment       2       3       _       5       facet       1       _       _       1       file       1       44       _       47       filter       1       12       0       13       fipa       1       4       11       16       fsm       1       0       0       1       geometry       2       96       0       98       gis       0       5       24       29       global       1       _       _       1       graph       1       55       32       88       graph_weight       1       3       0       4       graphic       1       10       1       12       graphic_unit       1       6       _       7       grid       4       10       33       47       gui       3       9       24       36       halt       1       _       _       1       headless       0       1       0       1       hydrology       0       0       1       1       image       0       4       0       4       import       1       _       _       1       inheritance       1       _       1       2       init       3       _       _       3       inspector       1       2       1       4       layer       1       _       _       1       length_unit       0       9       _       9       light       2       1       4       7       list       0       9       2       11       load_file       4       1       18       23       logical       1       7       0       8       loop       1       2       2       5       map       0       15       1       16       math       1       41       20       62       matrix       2       22       8       32       mirror       1       0       2       3       model       1       _       _       1       monitor       1       1       1       3       multi_criteria       0       4       1       5       multi_level       1       3       9       13       multi_simulation       1       0       2       3       neighbors       1       5       1       7       network       0       1       0       1       nil       1       0       0       1       node       1       20       1       22       obj       0       0       2       2       obstacle       0       1       3       4       opengl       3       _       _       3       operator       1       _       _       1       optimization       3       1       _       4       osm       1       2       2       5       output       2       _       _       7       overlay       0       0       1       1       parameter       2       1       _       3       pause       1       _       _       1       permanent       1       _       _       1       physics_engine       0       0       4       4       point       0       29       _       29       probability       1       _       _       1       pseudo_variable       1       _       _       1       r       1       2       0       3       random       3       10       _       13       random_operator       0       0       _       0       raster       0       0       4       4       reflex       1       _       _       1       refresh       2       _       _       2       regression       0       2       1       3       save_file       0       2       8       10       scheduler       2       2       0       4       serialize       0       0       0       0       shape       3       21       1       25       shapefile       2       2       34       38       shortest_path       1       6       4       11       skill       2       17       42       61       sound       0       4       0       4       spatial_computation       0       73       7       80       spatial_relation       0       32       0       32       spatial_transformation       0       24       2       26       species       1       20       _       21       sport       0       _       2       2       statistic       0       66       5       71       string       0       27       0       27       surface_unit       0       4       _       4       svg       0       2       0       2       system       1       11       0       12       task_based       1       4       0       5       ternary       1       2       1       4       test       0       4       2       6       text       2       10       0       12       texture       0       1       3       4       tif       0       2       1       3       time       2       20       _       22       time_unit       0       13       _       13       topology       3       9       4       16       torus       1       _       _       1       transport       1       5       6       12       txt       0       0       1       1       type       0       53       _       53       update       1       _       _       1       volume_unit       0       5       _       5       weight_unit       0       8       _       8       world       1       _       _       1       write       1       _       _       1       xml       0       4       0       4   ","url":"wiki/WebsiteGeneration.md"},{"id":"wiki/Event__CC15_Reorganization.md","title":" Introduction","content":"Introduction  Le but est de proposer une réorganisation des plug-ins de Gama  Cf. page Google Doc: https://docs.google.com/document/d/1gd4nlJH8ns4_iKqiIdw3LSa__Sk9yUccX9TEbzr2PW0/edit?usp=sharing ","url":"wiki/Event__CC15_Reorganization.md"},{"id":"wiki/Event__CP12Archi.md","title":" GAMA Architecture","content":"GAMA Architecture ","url":"wiki/Event__CP12Archi.md"},{"id":"wiki/Event__CP12Batch.md","title":" Batch Experiments","content":"Batch Experiments  By the Batch People  Philippe Caillou, Thomas Louail, Nicolas Marilleau, Huynh Quang Nghi, Serge Stinckwich, Patrick Taillandier, Jean-Daniel Zucker  What do we have?  Define an experiment, batch mode (but same capabilities as GUI mode)  ·  Parameter exploration:  Param element  o   Explicit  o   List with step  ·  Method Element  o   Exhaustive  o   Hill climbing  o   Simulated annealing  o   Tabu Search  o   Reactive Tabu Search  o   Genetic Algorithm  ·  File export  o   File  How does it work?  ·  The experiment (the plan) creates the simulation (future: Headless mode)  What would be great in Gama 12.4?  ·  Export agent/simulation data in the file  o   =>Define code in the experiment (loop over agents)  ·  Put rules for variable exploration  o   Ex: explore b={1,2,3}. if a=2 explore b={2,3} only  o   How? Put code in the exploring loop => put real GAML code in the agent  o   => reflex  method  or  explore   o   Some existing exploration actions can be used with a ParameterSet (Map?) parameter  ·  Show plots in batch  o   Define output with the code/variable of the experiment agent  o   Require a getVariable() operator that gets the last simulation variables values  ·  Compare agent trajectories  o   Stats a posteriori  o   (not possible inside a simulation because there is no end)  o   => action « aftersimulation » défined by the user  o   Require a getVariable() operator that gets the last simulation variables values (to be able to loop on agents)  ·  Define more parameters/variables in the file (CSV)  o   => use of the Save already working  ·  Launch parallel simulation on multicore/clusters  o   => special action  runSimulation  parameter to launch 4 in parallel?  ·   Generate  agents  o   Define agent parameters by using global/previous variables/files  o   Use of an  initSimulation  action before the  runSimulation  to  be able to change manually the simulation parameters  ·  Définition graphique de l espace de valeur, éventuellement en 2D et disjoint  o   Specific OutPut  The Solution  Define a new Experimenter agent and put real code/reflexes/actions… GAML code inside the Experimenter.  One simple example of what would be great:     experiment InteliExplore type: batch repeat: 2 keep_seed: true until: ( time > 200 ) {       int nbprey init:0;       int nbpredator init:0;    init   {  //for example read experiment plan from file }      reflex method   {  loop prm over:prey_max  {      do: createsimulation      setParameter(nb_preys_init,pr)       do: initsimulation       if (prey_max<100)      setParameter(nb_predators_init,200)      if (prey_max>100)      setParameter(nb_predators_init,200)       do: runsimulation;       do: aftersimulation;    }   }    action aftersimulation   {  loop over getVariable(agents)  {      log(everything dans file);      //with the save function?  } }    chart name:  Species evolution  type: series background: rgb( white ) size: {1,0.4} position: {0, 0.05}   {   data initial_number_of_preys value: getValue(nb_preys_init) color: rgb( blue ) ;     data final_number_of_predator value: getValue(nb_predators) color: rgb( red ) ;   } file name:  logsimple  type: text data:  simulation:  + step    + ; allparams  + getAllParamters // PROBLEME comment sauver tous les parametres?     +  ; nbPreys:   + getValue(nb_preys_init)   +  ; finalPredators:   + getValue(nb_preys) ; }        TODO  And Alexis did almost all this in less than a day……. But how does he do that??   A new type of Custom Experiment In this experiment block, an ExperimenterAgent manages the simulations Init() may have to create a Simulation to get a Scheduler (?) and/or a World(?) He must have a Scheduler to be able to stop/wait in a loop for the end of a Simulation (contradiction with previous point…) Its most important function is to be able to call Simulation.step()      =>Create a Simulation Type which has a Step() operator   Create a ExperimentatorSkill with a lot of usefull actions (Step(int), …) Check that it is possible to define plots, logs, …     ","url":"wiki/Event__CP12Batch.md"},{"id":"wiki/Event__CP12Development.md","title":" GAMA Development","content":"GAMA Development ","url":"wiki/Event__CP12Development.md"},{"id":"wiki/Event__CP12Doc.md","title":" Online & Local Documentation","content":"Online & Local Documentation ","url":"wiki/Event__CP12Doc.md"},{"id":"wiki/Event__CP12FIPA.md","title":" FIPA-ACL Skill","content":"FIPA-ACL Skill ","url":"wiki/Event__CP12FIPA.md"},{"id":"wiki/Event__CP12Git.md","title":" Gama on Git","content":"Gama on Git  http://eclipselabs.org/p/gama  Details ","url":"wiki/Event__CP12Git.md"},{"id":"wiki/Event__CP12Graph.md","title":" Graph operators and indicators","content":"Graph operators and indicators  goals  load graphs from files generate graphs using generators operators for graph manipulation (including stats) graphs display  done  load graphs from file  For parsing network files, we use the graphstream library which supports the top- 10 file formats. All these formats are supported by GAMA now.  Till now, the GAML langage does not enables an easy way to create primitives that both take more than 3 args as an input and return an object. Thus loading a graph is defined as an action of a skill; one has to create an instance of agent with this skill for loading the network.      global {  var mongraphe type:graph;  graph_manager graph_util;  init {   create graph_manager returns: graph_util;  ask graph_util {      set mongraphe value:load_graph_from_dgs_old(self, [edge_species::edgeSpecy, vertex_species::nodeSpecy,file::../includes/BarabasiGenerated.dgs]);    } }   }        graph manipulators  The structure for the manipulation of graphs is based on the existing GAMA graph type. As a consequence, novel algorithms, operators and visualizations will be usable for both spatial graphs (loading from GIS for instance, like roads) and more abstract graphs (not spatialized).  Patrick did some interesting work for searching shortest pathes and so on.  Novel operators should still be defined.  graph visualization  First of all, we had to disturb many GAMA-gurus for undertanding how to create a novel View (that is, another tab in the simulation perspective) from GAML. A novel display is defined for displaying a network.   output {  graphdisplay nameOfMyDisplay graph: mongraphe {    } }   This line indicates that we would like to display a graph defined in the variable  mongraphe . This simple line will open the display.  Roadmap  provide another (simpler !) syntax for loading networks visu:   * implement prefuse instead of graphstream for the visualisation   * map GAML aspects to the view of the network implement operators for graph manipulation add generators for simple graphs generation (with a simple syntax as well) ","url":"wiki/Event__CP12Graph.md"},{"id":"wiki/Event__CP12Headless.md","title":" Headless operation","content":"Headless operation  Be able to launch a simulation without any interface.  Basic example:  $gama.jar test.gaml input.xml  ","url":"wiki/Event__CP12Headless.md"},{"id":"wiki/Event__CP12IDE.md","title":" Enhancement of the IDE","content":"Enhancement of the IDE ","url":"wiki/Event__CP12IDE.md"},{"id":"wiki/Event__CP12Library.md","title":" Library of models","content":"Library of models ","url":"wiki/Event__CP12Library.md"},{"id":"wiki/Event__CP12MultiScale.md","title":" Improvement of the Multi-scale framework","content":"Improvement of the Multi-scale framework ","url":"wiki/Event__CP12MultiScale.md"},{"id":"wiki/Event__CP12OpenGL.md","title":" OpenGL Display","content":"OpenGL Display  Integrate OpenGL (jogl) view in Gama.  Have a display using OpenGL (Jogl: http://jogamp.org/jogl/www/) libraries implement as a gama plug-ins.  plugin name:   msi.gama.jogl   msi.gama.jogl will depend on msi.gama.application and msi.gama.core  Current work:   * A new output symbol has been defined in order to call a new display in gaml  Definition of the symbol in msi.gama.core/src/msi/gama/opengl/GLOutput.java  @symbol(name = IKeyword.DISPLAY_GL, kind = ISymbolKind.OUTPUT) @facets(value = {  //@facet(name = IKeyword.DISPLAY_GRAPH, type = IType.STRING_STR, optional = false),  @facet(name = IKeyword.NAME, type = IType.STRING_STR, optional = true)  }, omissible = IKeyword.NAME) @with_sequence @inside(symbols = IKeyword.OUTPUT)   Use of the symbol in msi.gama.models/models/graph/model/testSIG.gaml :  output {  graphdisplaygl {    }    * A new view in msi.gama.jogl plugin.xml       <extension point=org.eclipse.ui.views>  <view allowMultiple=true   category=msi.gama.gui.category.gama   class=msi.gama.jogl.GLView   icon=icons/view_console.png   id=msi.gama.jogl.GLView   name=GL   restorable=true> </view>     </extension>   This view is implemented in /Users/macbookpro/Projects/GamaDev/msi.gama.jogl/src/msi/gama/jogl/GLView.java  The view ID must also be defined src/msi/gama/common/util/GuiUtils.java  public static final String GL_VIEW_ID = msi.gama.jogl.GLView;    ","url":"wiki/Event__CP12OpenGL.md"},{"id":"wiki/Event__CP12SLD.md","title":" SLD-based aspects","content":"SLD-based aspects  Not chosen as a work theme for the coding camp… ","url":"wiki/Event__CP12SLD.md"},{"id":"wiki/Event__CP12Stats.md","title":" Statistical Tools in GAMA","content":"Statistical Tools in GAMA ","url":"wiki/Event__CP12Stats.md"},{"id":"wiki/Event__CP12Test.md","title":" Test Models & Language","content":"Test Models & Language   A Coding Dojo (5 people) was organized in order to sensibilize developpers about unit tests. The produced code is available here: https://github.com/SergeStinckwich/TennisKataTamCoc The usual retrospective done after a Dojo is here: https://github.com/SergeStinckwich/TennisKataTamCoc/tree/master/README Some very simple models has been done in the  multi-scale  group with An. At that occasion, we didn t define real tests, but the idea was the same: define models as simple as possible that illustrate some basic concepts. The same work should be done for all aspects (skills, operators, actions, GAML architecture, …). Difficult and boring to introduce tests in the GAMA platform at the moment. It is easier to introduce tests in ongoing developments. For example, Serge and Samuel do some unit tests for the new GraphSkill based on GraphStream.     ","url":"wiki/Event__CP12Test.md"},{"id":"wiki/Event__CP12Water.md","title":" Water-management tutorial","content":"Water-management tutorial  We did not work on this theme, but we made some decisions : - Plenary talk 1h10 : 1h : introduction to agent-based modeling; 20 minutes : MAELIA - a meeting will be organized just after the WAT-GAME training (the 26th of April at Toulouse).  Deadlines : - 30 march: Biographies - 13 april: short synopsis of the plenary talk (5 to 10 lines) - 13 april: short synopsis of the workshop (5 to 10 lines) - 25 may: final synopsis of the plenary talk - 25 may: presentation (ppt) of the plenary talk - 25 may (if translated) (optional) : paper concerning the plenary talk (max 10 pages, text longer in English - not translated into vietnamese) - 25 may (if translated) (optional) : paper concerning the workshop (max 10 pages, text longer in English - not translated into vietnamese) - 8 june: final synopsis of the workshop - 8 june: presentation (ppt) of the workshop ","url":"wiki/Event__CP12Water.md"},{"id":"wiki/Event__CP12traffic.md","title":" Traffic simulation and Physics constraints operators","content":"Traffic simulation and Physics constraints operators  Traffic simulation  A first task that we done was to define a new plug-in in order to take into account the fact that a road has a limited number of lanes.  We propose a plug-in that contains the driving plug-in. This plug-in extends the moving skill. In particular, it proposes a new primitive  gotoTraffic  that integrates a collision avoiding algorithm. 2 models (in  models/experimental models ) were proposed to illustrate the use of our plug-in.  DrivingSkill.java implements a new skill in package msi.gaml.extensions.traffic  @skill(driving) public class DrivingSkill extends MovingSkill{ ... }   New model in msi.gama.models/experimental_models/traffic  Physics constraints operators  A second plugin is under development concerning physic computation. In particular, it allows to handle collisions between two convex polygons. A first toy model concerning pool game was developed. Library used: http://www.jbox2d.org/  src/msi/gaml/extensions/physics/PhysicsSkill.java implements a new skill in package msi.gaml.extensions.physics     @skill( physical ) public class PhysicsSkill extends Skill{  @setter( physical_world )  public void setWorldAgent(final IAgent _agent, final IAgent _world){       if(_world == null)     return;    PhysicalWorldAgent pwa = (PhysicalWorldAgent)_world;   pwa.registerAgent(_agent);     }       ","url":"wiki/Event__CP12traffic.md"},{"id":"wiki/Event__CodingCamp2012.md","title":" Coding Activities Summary","content":"March 19-24th 2012  Coding Activities Summary       Physics constraints operators       Water-management tutorial       Test Models & Language   Library of models       FIPA-ACL Skill       Git repository       SLD-based aspects       Headless operation       Batch Experiments       OpenGL Display       Enhancement of the IDE       GAMA Architecture       Improvement of the Multi-scale framework       GAMA Development       Online & Local Documentation       Statistical Tools in GAMA       Graph operators and indicators         and some  working  images…   ","url":"wiki/Event__CodingCamp2012.md"},{"id":"wiki/Event__CodingCampFall2012.md","title":" Introduction","content":"Introduction  The Fall GAMA Coding Camp 2012 will take place from the 17th to the 19th of November in the hotel called  Hon Trem Resort & Spa  . You can find more information about it here : http://www.hontremresort-spa.com.  Departure will take place from Ninh Kieu 3 hotel in Can Tho at 3:30 PM, Friday the 16th of November, and we expect to arrive in Hon Trem resort at around 9:00 PM (dinner will be taken on the road).  A summary of the Spring GAMA Coding Camp 2012 can be found here.  Work  The use of the last version of GAMA will be necessary, the development version should thus be installed. See the documentation for the Installation procedure.  Some ideas of tasks that could be investigated during the camp (feel free to add anything you think about)  COUPLING GAMA WITH OTHER TOOLS    Coupling GAMA with hydrodynamics simulators (for water flows, etc.)  Participants: Thanh, Tuu, Benoit, Nghi, Quang, M.Thai Integration of EDP solver into GAMA  Participants: Benoit       Plug-in needed: maps.gama.extensions Calling statistical libraries of R in GAMA: Basic statistics, geostatistics (maptools, gstat), Gaussian process (tgp, gptk)  Participants: M.Thai, Viet Integration of SimAnalyzer  Participants: Philippe, Javier Improving SQL features in GAMA  Participants: M.Thai Improving the physics engine  Participants: Javier, Philippe, Arnaud, Patrick       Plug-in needed: simtools.gaml.extensions.physics ## IMPROVEMENTS / ENHANCEMENTS Improving and simplifying the syntax of GAML  Participants: Nicolas, Alexis, Nghi Documenting and enhancing the command line version  Participants: Nicolas, Nghi       Plug-in needed: msi.gama.headless Improving the user interaction possibilities  Participants: Nghi, Nicolas, Arnaud Torus environment (at least, grid)  Participants: Patrick, Viet Enhancement of the IDE  Participants: Nghi (implement first-step of GUI-GAML) Communication Skill  Participants: Benoit, An, Philippe       Plugin-needed: msi.gaml.extensions.fipa Update of the Trust Skill to Gama 1.5  Participants: Quang Anh Multicore runner in Headless Mode to Gama 1.5  Participants: Nicolas, Nhan, Nghi Driving skill in 2D (skill: driving2d)  Participants: Minh ## BUG FIXES Eliminating bugs found in the 1.5 version  Participants: Benoit, Patrick (for spatial/geometry related bugs). Arnaud for Opengl bug ## MODELS Adding 3D to the models  Participants: Arnaud, Patrick, Nghi ## OTHER Documentation  Participants: (Benoit)       Plug-in needed: msi.gama.documentation       Requirements: Python (CPython) and PyDev Eclipse plugin: see this page for details about the installation   ","url":"wiki/Event__CodingCampFall2012.md"},{"id":"wiki/Event__CodingCampFall2012_bug.md","title":" Eliminating bugs found in the 1.5 version","content":"Eliminating bugs found in the 1.5 version    Arnaud: Opengl is now working with Java2D (possibility to define n opengl display and n java2D display in the same output) http://code.google.com/p/gama-platform/issues/detail?id=190   no more seg fault when running a simulation with opengl while the update is done on the all model http://code.google.com/p/gama-platform/issues/detail?id=233     Communication Skills http://code.google.com/p/gama-platform/issues/detail?id=271  ","url":"wiki/Event__CodingCampFall2012_bug.md"},{"id":"wiki/Event__CodingCampFall2012_coupling.md","title":" Coupling GAMA with hydrodynamics simulators","content":"Coupling GAMA with hydrodynamics simulators  Integration of EDP solver into GAMA  The maps.gaml.extensions has been extended in order to allow modeler to write its own equation systems (as simple strings), specify parameters with their values and variables and  solve /integrate them either step by step or N steps by N steps.  An example has been implemented on the Lokta-Voltera equation system.  Possible extension:   * parse the equations to detect errors   * rename the skill has EDO, because we consider only variables depending on time   * extends to solve EDP   * add some methods/algorithms in order to  resolve  the system, in a sense of finding some equilibria (asymptots or oscillation equilibrium…)  R in GAMA Results: Verifying the old operators (A simple example  CallingR  is uploaded in the model list); Applying these statistical operators on the data loaded from RDBMS.  SQL features in GAMA Results:   * 1.Added PostgresSQL driver into SQSKILL and AgentDB.   * 2.Wrote example models for testing.   * Now,GAMA supported query features for MySQL, MSSQL, PostgresSQL and SQLite.  Physics engine  Integration of a 3D Physics Engine Library (http://jbullet.advel.cz/) in simtools.gaml.extensions.physics This has been implemented as a new skill.   species myPhysicsAgent skills: [physical3D]   More details: 3D Physics Engine ","url":"wiki/Event__CodingCampFall2012_coupling.md"},{"id":"wiki/Event__CodingCampFall2012_improvements.md","title":" Possibility to directly create agents from a CSV file","content":"Improvements and Enhancements  Possibility to directly create agents from a CSV file The create statement has been extended in order to let the possibility to create agents of specified species directly from a CSV file. An agent is created by line of the CSV file. It is also possible to read the different column of the file using the read operator: read (column_index) (start at 0)   read(1)   For example:  create people from: data_file.csv with: [speed::read(0), age:: read(1)];   It is also possible to specify that the CSV file has a header that can give the name of the different column using the header facet (boolean). It this case, it is possible to directly use this name to read the column value: read( attribute1 ).  For example:  create people from: data_file.csv with: [speed::read(SPEED), age:: read(AGE)] header: true;   Improving and simplifying the syntax of GAML New features:   * Possibility to define 3D points with the {x,y,z} syntax:  let pt type: point <- {2, 5, 3};  # Documenting and enhancing the command line version  summary One-sentence summary of this page.  The aim of this feature is to run models and experiments on a grid or a cluster without GUI and to take advantages of High Performance Computing. It promises efficient running by accelerating each simulation and experiment plan computing. The GUI is not loaded and managed. Several simulations could be run in parallel, at same time.  There is two ways to run a GAMA experiment in headless mode: using command-line launcher or Java command line. These commands take 2 arguments: an experiment file and an output directory.  For the command-line :   sh gamaHeadless.sh $1 $2    * with:     * $1 input parameter file : an xml file determining experiment parameters and attended outputs     * $2 output directory path : a directory which contains simulation results (numerical data and simulation snapshot)  go to headless documentation  Torus environment It is now possible to use toroidal environment for grid and continuous environments (even with complex GIS geometries).  The only thing to do is to use the torus facet.  For a grid:  grid cell width: 5 height: 5 neighbours: 8 torus: true    For the continuous environment:  environment bounds: {50,50} torus: true;   Be careful concerning toroidal continuous environment: the computation required by these environment is high, thus they should be used only when they are really necessary.  A demonstration of a continuous toroidal environment is given in the experimental model: testTorus-> continuous_torus.    Communication Skill Plugin-needed: msi.gaml.extensions.fipa  The communicating skill now re-works on GAMA 1.5. Sample toy models are found in  models/fipa .  Update of the Trust Skill to Gama 1.5  Hexgonal geometry and grid It is now possible to create a hexagon of with the given width and height (point) thanks to the operator hexagon({width, height})   hexagon({3,4})   In the same way, an operator has been defined in order to decomposed a geometry into a set of hexagons of a given a number of columns and rows. This operator returns a set of hexagons: geometry as_hexagonal_grid({nb_cols, nb_rows})   shape as_hexagonal_grid({50, 40})   At last, it is now possible to define a hexagonal grid. To do so, the neighbors should is set to 6. It is possible to use torus environment with hexagonal grid.   grid cell width: 20 height: 20 neighbours: 6 torus: true;     Using HSB color  Add HSB color to be able to iterate through colors and use it to represent qualitative data.  Example:  The association of the orientation of agents is enhanced by mapping the orientation of the agent to a hue.   color hsb_to_rgb ([heading/360,1.0,1.0]);   In the following example boids are represented by a triangle with the colors depending on their heading.   Multicore runner in Headless Mode Results: distribution of command-line version on multicore machine, integration with GAMA interface, visualisation of outputs.  Defining interaction in a model  One statement have been added to facilitate the proposal of serious game on which user could interact through a map. It is now possible to catch event done on 2D display in order to do an action and to modify clicked agent attributes.  Attributes    name (omissible)   [mouse_down , mouse_up]     action name of the action to be run   Definition Allows to interact with the simulation by capturing mouse event and do an action. This action could apply a change on environment or on agents, according to the goal.  Events are determine for a display. Thus, they can be play a different behavior   event [event_type] action: myAction    * event_type (mouse_down or mouse_up   * myAction is an action written in the global block. This action have to follow the specification below.       global  {    …    action myAction     {      arg location type: point; // contains le location of the click in the environment      arg selected_agents type: list; // contains agents clicked by the event  ... //code written by the authors ...    }   }   experiment Simple type:gui {  parameter  Evaporation Rate:  var: evaporation_rate;  parameter  Diffusion Rate:  var: diffusion_rate;  output {    display Ants refresh_every: 2 {     grid ant_grid;    species ant aspect: default;    text tt value: string ( food_remaining ) size: 24.0 position: { 20 , 20 } color: rgb (  white  );    event mouse_up action: myAction;   }  …       Driving skill in 2D (skill: driving2d)  A skill (inherited from moving skill) permits agent to move to the target and avoid the others.  Attributes    heading initial heading of agent   obstacle_species list of species to avoid   background_species list of species on which agent move   Action The action inherits the  goto  action of moving skill.   do vehicle_goto target: target on: the_graph speed: speed target_type: true returns: moving_status;      target the goal (in type of location) for agent to go   speed maximum of moving distance for each step   on the topology on which agent moves. By default, the topology is the graph and agent uses the shortest path algorithm to move   target_type if  true , agent goes to the exact location of the target. Otherwise (in the case of false target), agent go to an point on the topology that is nearest to the target.   returns the action returns an integer with the meaning: -1: failed to move; 0: success to move closer and closer to the target; 1: arrive the false target; 2: arrive the target        reflex move_with_vehicle_goto when: target != nil{    let moving_status type: int <- -1;    do vehicle_goto target: target on: the_graph speed: speed target_type: true returns: moving_status;    if (int(moving_status) > 0){     let temp_targets <- list(targetpoint) - target;     set target <- one_of(temp_targets);    }   }      ","url":"wiki/Event__CodingCampFall2012_improvements.md"},{"id":"wiki/Event__CodingCampFall2012_models.md","title":" 3D River morphology display","content":"3D River morphology display  Display the channel bed of a river in 3D from synthetic data and can be applied directly to real data.  Models using the 3D Physics Engine  Integration of a 3D Physics Engine Library (http://jbullet.advel.cz/) in simtools.gaml.extensions.physics  This has been implemented as a new skill.   species myPhysicsAgent skills: [physical3D]   Some toy model has been added in   msi.gama.models/models/3D/3D_Engine   hello_World_falling > Ball falling (due to the gravity) on a floor.  pool3D.gaml   ","url":"wiki/Event__CodingCampFall2012_models.md"},{"id":"wiki/Event__Events.md","title":" Coding Camps","content":"Coding Camps List of GAMA Coding Camps :   * Coding Camp March 2012   * Fall Coding Camp 2012   * Programme doctoral internationale 2012 ","url":"wiki/Event__Events.md"},{"id":"wiki/Event__MIMSCOP2012.md","title":" Introduction","content":"Introduction  The MIMSCOP Summer school 2012 (Modélisation Informatique et Mathématique des Systèmes Complexes de Pêcherie took place from the 16th to the 21th of July in the AIMS-IRD Campus at Mbour (Senegal).    Developed models     Baye Cheikh MBAYE and Fatou Nene DIOP Modélisation de l impat de l environnement sur la migration de sardinella aurita le long de la côte sénégalo-mauritanienne : outil de suivi et de prévision du stock pour la pêche (Slidehow)   Macire Thieba TOURE and ￼Harouna DIOUF Impact de la gestion sur la biomasse de la thonine pêchée au Sénégal (Slideshow)   Mansour NDOUR and Thierno DIOP Modélisation Impacts des AMP sur la biomasse et les captures en fonction du site et du mode de gestion (Slideshow)   Sidy DIOP and Papa Baba FALL L impact de la pollution sur les espèces halieutiques (slideshow)   Sana KEITA and  Serigne Mbacke GUEYE Comparaison de la pêche sélective et non sélective sur la petite côte (Slideshow   Siny NDOYE and Erick FARGEAS  Une alternative à la baisse de la biomasse : « l aquaculture, solution de développement durable » (Slideshow)   Abdoulaye THIAM and Mouhamadou Baidy DIA Evolution de poissons dans les AMP et dans l aquaculture (Slideshow)   Trainers     Auger Pierre - UMMISCO, IRD-UCAD   Bah Alassane - UMMISCO, ESP, UCAD   Diouf Niokhor - IUPA, UCAD   Guy Gohier - CRAMS   Marilleau Nicolas - UMMISCO, IRD-UPMC   Ndiaye  Samba - UMMISCO, FST, UCAD   Seck Diaraf - UMMISCO, FAESG, UCAD   Learners     Badji Insa - AIMS   Dia Mouhamadou Baidy - AIMS   Diop Sidy -  AIMS   Diop Thierno -  AIMS   Diouf Harouna - IUPA, UCAD   Fall Papa Baba - LTI, FST, UCAD   Fargeas Eric - LTI, FST, UCAD   Gueye Serigne Mbacké - LID, FST, UCAD   Keita Sana - AIMS   Ly Sidy - LGA, FST, UCAD   Mansal Fulgurence - LGA, FST, UCAD   Mbaye Baye Cheikh - LPAO-SF, ESP, UCAD   Ndour Mansour - IUPA, UCAD   Ndoye Siny - LPAO-SF, ESP, UCAD   Thiam Abdoulaye - AIMS   Touré Macire Thieba - AIMS   The participants   ","url":"wiki/Event__MIMSCOP2012.md"},{"id":"wiki/Event__PDI2012.md","title":" Introduction","content":"Introduction  During the PDI2012 nearly 50 PhD students were working together on different topic related to complex system modeling. At the end of the formation, each student (by groups of 2 or 3) had to present a model in a mini-projet. The purpose of this mii-project was to use a platform and to create a model related to their respective research topics. Here is an overview of the model that has been implemented with Gama. Some of those projects has been presenting in COMMISCO 2012  Projects  First year (promo2012) Siny  Ndoye - Quang Truong Chi Modelisation of the land use applied to the commune of My An-Ben Tre in the Delta Mekong.  Since 1999, Vietnam has transformed 380 000 ha of rice agriculture into aquaculture. It has different impact like the fall of the rice agriculture, forest destruction and demographic increase near aqua farm. The shrimp culture is responsible of the destruction of the mangrove swamp since the 90 s. The aim of this model was to study the impact of a government aid for rice producer on this problem.  Cedrigue Djiongo - Abdelkarim Ed-Darraz Modelisation of the different  land use in the forest.  The model study the dynamic of forest parcel over the time according to the activity of nomad paysans. The parcel can have different state such as primary forest, chromolaena forest, bush fallow, forest crop field or secondary forest).  Souleymane Sy - Nghi Huynh Quang Impact of the dynamic of the vegetation of the rain in west africa  West africa is one of the part of the world that faced the most climate variability during the second half of the 20th century. To understand the origin on the variability on the amount of rain Gama is used to study the impact of the vegetation dynamic on the rain using a retroactivity between vegetation and atmosphere  Hédia Zardi - Tran Thi Cam Giang Modelisation of the SEIR model by GAMA  Until today, many infectious diseases in the world such as measles, tuberculosis, dengue … still exist. These diseases are one of the main causes of infant mortality in most countries of Asis, Africa, etc. Therefore, we want to present these infectious diseases in the computer models, after we want to find the periods of diseases to provide positive solutions that allow us to turn them off.  Second year (promo2011)  Ahmed Tidjane Cisse - Arnaud Grignard Vector disease modélisation- Multi point of view approach and visualization.  Propose a meta-model applied to vector disease. Gama has been used to study the rift valley fever disease according to a meta-model previously defined. The idea is to define basic or macro behavior for host, environment and  infectious agent on which a vector is moving and then to implement those meta-agent for a specific vector disease (in this case the rift valey fever).  Third year (promo2010)  Moussa Gueye - Inès Hassoumi - Zineb Belarbi Impact of the dispersion of air pollutants: applied to the city of Tunis  This project study the impact of pollutants on the environment on the health. The goal is to identify where new urban zone can be created by taking in account the concentration of each pollutants in the city. The main interest of the model is the coupling of the data coming from numerical equation of the advection-diffusion process using finite element method and then include those results on a grid created in Gama on which the value of each pollutants is extrapolated. ","url":"wiki/Event__PDI2012.md"},{"id":"wiki/Event__TraininSessionPDI2011.md","title":" <font color='blue'>Context</font>","content":"Context Training session on GAMA 1.4 at IRD Bondy (France) the 5th of December, 2011.  List of presentations Here, the list of the different presentations (in French) given during the training session:     Introduction to GAMA   GAMA and GIS   Multi-scale Modeling   Models the models used during the training session are all provided with the last version of GAMA (1.4) ","url":"wiki/Event__TraininSessionPDI2011.md"},{"id":"wiki/Event__TrainingSessionHanoi2009.md","title":" <font color='blue'>Context</font>","content":"Context Training session on agent-based modeling and a tutorial on GAMA 1.1 organized at the IFI from the 26th to the 28th of October, 2009  List of presentations Here the list of the different presentations given during the training session:     Introduction to Agent Based Modeling   An introduction to GAMA   Tutorial: Forest fires   Tutorial: Segregation   GIS in GAMA: part1   GIS in GAMA: part2   Exploring Models  ","url":"wiki/Event__TrainingSessionHanoi2009.md"},{"id":"wiki/DevelopingExtensions.md","title":" Developing Extensions","content":"Developing Extensions  GAMA accepts extensions to the GAML language, defined by external programmers and dynamically loaded by the platform each time it is run. Extensions can represent new built-in species, types, file-types, skills, operators, statements, new control architectures or even types of displays. Other internal structures of GAML will be progressively  opened  to this mechanism in the future: display layers (hardwired for the moment), new types of outputs (hardwired for the moment), scheduling policies (hardwired for the moment), random number generators (hardwired for the moment). The extension mechanism relies on two complementary techniques:   * the first one consists in defining the GAML extensions in a plug-in (in the OSGI sense, see here) that will be loaded by GAMA at runtime and must  declare  that it is contributing to the platform.   * the second one is to indicate to GAMA where to look for extensions, using Java annotations that are gathered at compile time (some being also used at runtime) and directly compiled into GAML structures.  The following sections describe this extension process.       Installing the GIT version   Architecture of GAMA   Developing a Plugin   Developing a Skill   Developing a Statement   Developing an Operator   Developing a Type   Developing a Species   Developing a Control Architecture   Index of annotations   IScope   ","url":"wiki/DevelopingExtensions.md"},{"id":"wiki/Download.md","title":" Download GAMA","content":"Download GAMA  GAMA 1.7 Continuous Release  GAMA 1.6.1 (Archived)    GAMA for Windows 64 bits Download   GAMA for Windows 32 bits Download   GAMA for OSX 64 bits  Download   GAMA for OSX 32 bits Download   GAMA for Linux 64 bits Download   GAMA for Linux 32 bits Download  ","url":"wiki/Download.md"},{"id":"wiki/Events.md","title":" References","content":"References  This page references the events that are linked to GAMA.  If you happen to participate to an event linked to GAMA, please let us know, so that we can include it in this list.  Events linked to GAMA  List of GAMA Coding Camps :   * Coding Camp March 2014 (photos)   * Coding Camp March 2012   * Fall Coding Camp 2012   * Programme doctoral internationale 2012 ","url":"wiki/Events.md"},{"id":"wiki/GamlLanguage.md","title":" GAML","content":"GAML  Models that users want to simulate in GAMA have to be written in a special language, called GAML (short for GAma Modeling Language)  GAML is born from the necessity to have a high-level declarative way of defining and reusing structures found in almost all agent-based models. See here for more information about its background.  Although this choice requires users to learn a new programming (or better, modeling) language, everything has been made in GAMA to support a short learning curve, so that they can become almost autonomous in a limited time (informal measures taken at the different events centered on GAMA have shown that one day is enough to acquire sufficient skills in writing complete models in GAML).  The documentation on GAML is organized in 5 main points:     Description of the general structure of a model: see this page   Description of the declaration of species (and all their components): see this page and all its subpages   Description of the declaration of experiments: see this page for regular experiments and this one for batch experiments.   Reference of the language regarding all the structures provided to modelers   Recipes of how to use special or advanced features offered in GAML: see this page.   In addition, some of the fundamental concepts behind GAML are also described in detail, both on the modeling infrastructure and the runtime infrastructure on which GAML is relying to run experiments on models. ","url":"wiki/GamlLanguage.md"},{"id":"wiki/Index.md","title":" Exhaustive list of GAMA Keywords","content":"Exhaustive list of GAMA Keywords    This file is automatically generated from java files. Do Not Edit It.    Operators -, :, ::, !, !=, ?, /, ., [^](OperatorsAC#^), @, [](OperatorsAC#), +, <, <=, <>, =, >, >=, abs, accumulate, acos, action, add_days, add_edge, add_hours, add_minutes, add_months, add_ms, add_node, add_point, add_seconds, add_weeks, add_years, adjacency, after, agent, agent_closest_to, agent_farthest_to, agent_from_geometry, agents_at_distance, agents_inside, agents_overlapping, all_pairs_shortest_path, alpha_index, among, and, and, angle_between, any, any_location_in, any_point_in, append_horizontally, append_vertically, arc, around, as, as_4_grid, as_distance_graph, as_driving_graph, as_edge_graph, as_grid, as_hexagonal_grid, as_int, as_intersection_graph, as_map, as_matrix, as_path, asin, at, at_distance, at_location, atan, atan2, attributes, BDIPlan, before, beta_index, between, betweenness_centrality, biggest_cliques_of, binomial, blend, bool, box, brewer_colors, brewer_palettes, buffer, build, ceil, centroid, char, circle, clean, closest_points_with, closest_to, collect, column_at, columns_list, command, cone, cone3D, connected_components_of, connectivity_index, container, contains, contains_all, contains_any, contains_edge, contains_vertex, conversation, convex_hull, copy, copy_between, corR, cos, cos_rad, count, covers, cross, crosses, crs, CRS_transform, csv_file, cube, curve, cylinder, date, dbscan, dead, degree_of, dem, det, determinant, diff, diff2, directed, direction_between, direction_to, disjoint_from, distance_between, distance_to, distinct, distribution_of, distribution2d_of, div, dxf_file, edge, edge_between, edge_betweenness, edges, eigenvalues, electre_DM, ellipse, emotion, empty, enlarged_by, envelope, eval_gaml, eval_when, even, every, every_cycle, evidence_theory_DM, exp, fact, farthest_point_to, farthest_to, file, file_exists, first, first_of, first_with, flip, float, floor, folder, font, frequency_of, from, fuzzy_kappa, fuzzy_kappa_sim, gaml_file, gamma_index, gamma_rnd, gauss, generate_barabasi_albert, generate_complete_graph, generate_watts_strogatz, geojson_file, geometric_mean, geometry, geometry_collection, get, get_about, get_agent, get_agent_cause, get_decay, get_dominance, get_familiarity, get_intensity, get_lifetime, get_liking, get_praiseworthiness, get_priority, get_solidarity, get_super_intention, gif_file, gini, graph, grayscale, grid_at, grid_cells_to_graph, grid_file, group_by, harmonic_mean, hexagon, hierarchical_clustering, hsb, hypot, IDW, image_file, in, in_degree_of, in_edges_of, indented_by, index_by, index_of, inside, int, inter, interleave, internal_at, internal_integrated_value, internal_zero_order_equation, intersection, intersects, inverse, inverse_distance_weighting, is, is_csv, is_dxf, is_finite, is_gaml, is_geojson, is_gif, is_grid, is_image, is_json, is_number, is_obj, is_osm, is_pgm, is_property, is_R, is_shape, is_skill, is_svg, is_text, is_threeds, is_URL, is_xml, json_file, kappa, kappa_sim, kmeans, kurtosis, last, last_index_of, last_of, last_with, layout, length, line, link, list, list_with, ln, load_graph_from_file, load_shortest_paths, log, lower_case, map, masked_by, material, matrix, matrix_with, max, max_of, maximal_cliques_of, mean, mean_deviation, mean_of, meanR, median, message, milliseconds_between, min, min_of, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_seconds, minus_weeks, minus_years, mod, months_between, moran, mul, nb_cycles, neighbors_at, neighbors_of, new_emotion, new_folder, new_predicate, new_social_link, node, nodes, norm, not, obj_file, of, of_generic_species, of_species, one_of, or, or, osm_file, out_degree_of, out_edges_of, overlapping, overlaps, pair, partially_overlaps, path, path_between, path_to, paths_between, percent_absolute_deviation, pgm_file, plan, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_seconds, plus_weeks, plus_years, point, points_along, points_at, points_on, poisson, polygon, polyhedron, polyline, polyplan, predecessors_of, predicate, predict, product, product_of, promethee_DM, property_file, pyramid, R_correlation, R_file, R_mean, range, read, rectangle, reduced_by, regression, remove_duplicates, remove_node_from, replace, replace_regex, reverse, rewire_n, rgb, rgb_to_xyz, rnd, rnd_choice, rnd_color, rotated_by, round, row_at, rows_list, sample, scaled_by, scaled_to, select, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_liking, set_solidarity, set_truth, set_z, shape_file, shuffle, signum, simple_clustering_by_distance, simple_clustering_by_envelope_distance, simplification, sin, sin_rad, since, skeletonize, skew_gauss, skewness, skill, smooth, social_link, solid, sort, sort_by, source_of, spatial_graph, species, species_of, sphere, split_at, split_geometry, split_lines, split_with, sqrt, square, squircle, standard_deviation, string, subtract_days, subtract_hours, subtract_minutes, subtract_months, subtract_ms, subtract_seconds, subtract_weeks, subtract_years, successors_of, sum, sum_of, svg_file, tan, tan_rad, tanh, target_of, teapot, text_file, TGauss, threeds_file, to, to_GAMA_CRS, to_gaml, to_rectangles, to_squares, to_triangles, tokenize, topology, touches, towards, trace, transformed_by, translated_by, translated_to, transpose, triangle, triangulate, truncated_gauss, undirected, union, unknown, until, upper_case, URL_file, use_cache, user_input, using, variance, variance_of, voronoi, weight_of, weighted_means_DM, where, with_lifetime, with_max_of, with_min_of, with_optimizer_type, with_praiseworthiness, with_precision, with_priority, with_values, with_weights, without_holes, writable, xml_file, years_between,    Statements =, action, add, agents, annealing, ask, aspect, assert, benchmark, break, camera, capture, chart, conscious_contagion, create, data, datalist, default, diffuse, display, display_grid, display_population, do, draw, else, emotional_contagion, enter, equation, error, event, exhaustive, exit, experiment, export, focus, focus_on, genetic, graphics, highlight, hill_climbing, if, image, inspect, let, light, loop, match, migrate, monitor, output, output_file, overlay, parameter, perceive, permanent, plan, put, reactive_tabu, reflex, release, remove, return, rule, run, save, save_batch, set, setup, simulate, socialize, solve, species, state, status, switch, tabu, task, test, trace, transition, unconscious_contagion, user_command, user_init, user_input, user_panel, using, Variable_container, Variable_number, Variable_regular, warn, write,    Architectures fsm, parallel_bdi, probabilistic_tasks, reflex, simple_bdi, sorted_tasks, user_first, user_last, user_only, weighted_tasks,    Constants and colors #aliceblue, #antiquewhite, #aqua, #aquamarine, #azure, #beige, #bisque, #black, #blanchedalmond, #blue, #blueviolet, #bold, #brown, #burlywood, #cadetblue, #camera_location, #camera_orientation, #camera_target, #chartreuse, #chocolate, #cl (#centiliter,#centiliters), #cm (#centimeter,#centimeters), #coral, #cornflowerblue, #cornsilk, #crimson, #custom, #cyan, #cycle (#cycles), #darkblue, #darkcyan, #darkgoldenrod, #darkgray, #darkgreen, #darkgrey, #darkkhaki, #darkmagenta, #darkolivegreen, #darkorange, #darkorchid, #darkred, #darksalmon, #darkseagreen, #darkslateblue, #darkslategray, #darkslategrey, #darkturquoise, #darkviolet, #day (#days), #deeppink, #deepskyblue, #dimgray, #dimgrey, #display_height, #display_width, #dl (#deciliter,#deciliters), #dm (#decimeter,#decimeters), #dodgerblue, #e, #epoch, #firebrick, #flat, #floralwhite, #foot (#feet,#ft), #forestgreen, #fuchsia, #gainsboro, #ghostwhite, #gold, #goldenrod, #gram (#grams), #gray, #green, #greenyellow, #grey, #h (#hour,#hours), #hl (#hectoliter,#hectoliters), #honeydew, #horizontal, #hotpink, #inch (#inches), #indianred, #indigo, #infinity, #iso_local, #iso_offset, #iso_zoned, #italic, #ivory, #kg (#kilo,#kilogram,#kilos), #khaki, #km (#kilometer,#kilometers), #l (#liter,#liters,#dm3), #lavender, #lavenderblush, #lawngreen, #lemonchiffon, #lightblue, #lightcoral, #lightcyan, #lightgoldenrodyellow, #lightgray, #lightgreen, #lightgrey, #lightpink, #lightsalmon, #lightseagreen, #lightskyblue, #lightslategray, #lightslategrey, #lightsteelblue, #lightyellow, #lime, #limegreen, #linen, #longton (#lton), #m (#meter,#meters), #m2, #m3, #magenta, #maroon, #max_float, #max_int, #mediumaquamarine, #mediumblue, #mediumorchid, #mediumpurple, #mediumseagreen, #mediumslateblue, #mediumspringgreen, #mediumturquoise, #mediumvioletred, #midnightblue, #mile (#miles), #min_float, #min_int, #mintcream, #minute (#minutes,#mn), #mistyrose, #mm (#milimeter,#milimeters), #moccasin, #month (#months), #msec (#millisecond,#milliseconds,#ms), #nan, #navajowhite, #navy, #none, #now, #oldlace, #olive, #olivedrab, #orange, #orangered, #orchid, #ounce (#oz,#ounces), #palegoldenrod, #palegreen, #paleturquoise, #palevioletred, #papayawhip, #peachpuff, #peru, #pi, #pink, #pixels (#px), #plain, #plum, #pound (#lb,#pounds,#lbm), #powderblue, #purple, #red, #rosybrown, #round, #royalblue, #saddlebrown, #salmon, #sandybrown, #seagreen, #seashell, #sec (#second,#seconds,#s), #shortton (#ston), #sienna, #silver, #skyblue, #slateblue, #slategray, #slategrey, #snow, #split, #springgreen, #sqft (#square_foot,#square_feet), #sqin (#square_inch,#square_inches), #sqmi (#square_mile,#square_miles), #square, #stack, #steelblue, #stone (#st), #tan, #teal, #thistle, #to_deg, #to_rad, #tomato, #ton (#tons), #transparent, #turquoise, #user_location, #vertical, #violet, #week (#weeks), #wheat, #white, #whitesmoke, #yard (#yards), #year (#years,#y), #yellow, #yellowgreen, #zoom,    Skills advanced_driving, driving, fipa, GAMASQL, grid, MDXSKILL, messaging, moving, moving3D, network, physics, skill_road, skill_road_node, SQLSKILL,    Species agent, AgentDB, base_edge, experiment, graph_edge, graph_node, model, physical_world,      world    Actions init, step, isConnected, close, timeStamp, connect, testConnection, select, executeUpdate, getParameter, setParameter, insert, update_outputs, related_to, pause, halt, compute_forces, advanced_follow_driving, is_ready_next_road, test_next_road, compute_path, path_from_nodes, drive_random, drive, external_factor_impact, speed_choice, lane_choice, follow_driving, goto_driving, start_conversation, send, reply, accept_proposal, agree, cancel, cfp, end_conversation, failure, inform, propose, query, refuse, reject_proposal, request, subscribe, testConnection, read, SqlObject, timeStamp, testConnection, select, send, wander, move, follow, goto, move, execute, connect, fetch_message, has_more_message, leave_the_group, register, unregister, timeStamp, getCurrentDateTime, getDateOffset, testConnection, executeUpdate, insert, select, list2Matrix,    Variables speed, real_speed, current_path, final_target, current_target, current_index, targets, security_distance_coeff, current_lane, vehicle_length, speed_coeff, max_acceleration, current_road, on_linked_road, proba_lane_change_up, proba_lane_change_down, proba_respect_priorities, proba_respect_stops, proba_block_node, proba_use_linked_road, right_side_driving, max_speed, distance_to_goal, segment_index_on_road, living_space, lanes_attribute, tolerance, obstacle_species, speed, conversations, accept_proposals, agrees, cancels, cfps, failures, informs, proposes, queries, refuses, reject_proposals, requests, requestWhens, subscribes, color, neighbors, grid_value, bands, grid_x, grid_y, mailbox, location, speed, heading, current_path, current_edge, real_speed, destination, speed, heading, pitch, roll, destination, network_name, network_groups, network_server, space, density, mass, velocity, collisionBound, motor, agents_on, all_agents, source_node, target_node, lanes, linked_road, maxspeed, roads_in, priority_roads, roads_out, stop, block,    Pseudo-Variables  self, myself, each    Types bool, float, int, string, agent, container , file, geometry, graph, list, map, matrix , pair, path, point, rgb, color, species, topology    the world torus, Environment Size, world, time cycle, step, time, duration, total_duration average_duration, machine_time, agents, stop, halt, pause, scheduling    Grid grid_x, grid_y, agents, color, grid_value    Other concepts scheduling, step, Key concepts, [KeyConcepts#Vocabulary_correspondance_with_the_agent-based_paradigm_as_in_Ne correspondance GAMA Netlogo], operators statements type species  ","url":"wiki/Index.md"},{"id":"wiki/NewVersionChanges.md","title":" Java version","content":"Java version  Due to changes in the libraries used by GAMA 1.7, this version now requires JDK/JVM 1.8 to run.  Changes between 1.6.1 and 1.7 that can influence the dynamics of models     Initialization order between the initialization of variables and the execution of the init block in grids init -> vars in 1.6.1 / vars -> init in 1.7   Initialization order of agents -> now, the init block of the agents are not executed at the end of the global init, but during it. put a sample model to explain the order of creation and its differences   Initialization of vars to their default value map ? list ?   Systematic casting and verification of types give examples   header of CSV files: be careful, in GAMA 1.7, if the first line is detected as a header, it is not read when the file is casted as a matrix (so the first row of the matrix is not the header, but the first line of data) gives examples   the step of batch experiments is now executed after all repetitions of simulations are done (not after each one). They can however be still accessed using the attributes simulations (see Batch.gaml in Models Library)   signal and diffuse have been merged into a single statement   facets do not accept a space between their identifier and the : anymore.   simplification of equation/solve statements and deprecation of old facets   in FIPA skill, contentis replaced everywhere with contents   in FIPA skill, receivers is replaced everywhere with to   in FIPA skill, messages is replaced by mailbox   The pseudo-attribute user_location has been removed (not deprecated, unfortunately) and replaced by the  unit  #user_location.   The actions called by an event layer do not need anymore to define point and list<agent> arguments to receive the mouse location and the list of agents selected. Instead, they can now use #user_location and they have to compute the selected agents by themselves (using an arbitrary function).   The random number generators now better handle seeding (larger range), but it can change the series of values previously obtained from a given seed in 1.6.1   all models now have a starting_date and a current_date. They then dont begin at an hypothetical  zero  date, but at the epoch date defined by ISO 8601 (1970/1/1). It should not change models that dont rely on dates, except that: year (and its nicknames #y, #years) and #month (and its nickname #month) do not longer have a default value (of resp. 30 days and 360 days). Instead, they are always evaluated against the current_date of the model. If no starting_date is defined, the values of #month and #year will then depend on the sequence of months and year since epoch day.      as_time, as_system_time, as_date and as_system_date have been removed   Enhancements in 1.7     Simulations   simulations can now be run in parallel withing an experiment (with their outputs, displays, etc.)   batch experiments inherit from this possibility and can now run their repetitions in parallel too. concurrency between agents is now possible and can be controlled on a species/grid/ask basis (from multi-threaded concurrency to complete parallelism within a species/grid or between the targets of an ask statement)      Language   gama : a new immutable agent that can be invoked to change preferences or access to platform-only properties (like machine-time)   date : new data type that offers the possibility to use a real calendar, to define a starting_date and to query a current_date from a simulation, to parse dates from date files or to output them in custom formats. Dates can be added, subtracted, compared. Various new operators (minus_months, etc.) allow for a fine manipulation of their data. Time units (#sec, #s, #mn, #minute, #h, #hour, #day, etc.) can be used in conjunction with them. Interval of dates (date1 to date2) can be created and used as a basis for loops, etc. Various simple operators allow for defining conditions based on the current_date (after(date1), before(date2), since(date1), etc.).   font in draw   BDI control architecture for agents   file management, new operators, new statements, new skills(?), new built-in variables, files can now download their contents from the web by using standard http: https: addresses instead of file paths.   The save can now directly manipulate files and … save them. So something like save shape_file(bb.shp, my_agents collect each.shape); is possible.   status statement (to manipulate the status line from GAML)   new operators (sum_of, product_of, etc.)   casting of files works   co-modeling (importation of micro-models that can be managed within a macro-model)   populations of agents can now be easily exported to CSV files using the save statement   Simple messaging skill between agents   Terminal commands can now be issued from within GAMA using the console operator   New status statement allows to change the text of the status.   light statement in 3D display provides the possibility to custom your lights (point lights, direction lights, spot lights) on_change: facet for attributes/parameters allows to define a sequence of statements to run whenever the value changes.      Data importation   draw of complex shapes through obj file   new types fo files are taken into account: geotiff and dxf   viewers for common files navigator: better overview of model files and their support files, addition of plugin models      Editor   doc on built-in elements, templates, shortcuts to common tasks, hyperlinks to files used   improvement in time, gathering of infos/todos warnings can be removed from model files      Models library: New models (make a list)      Preferences   For performances and bug fixes in displays OpenGL displays should be up to 3 times faster in rendering      Simulation displays   fullscreen mode for displays (ESC key)   CTRL+O for overlay and CTRL+L for layers side controls   cleaner OpenGL displays (less garbage, better drawing of lines, rotation helper, sticky ROI, etc.)   possibility to use a new OpenGl pipeline and to define keystoning parameters (for projections)   faster java2D displays (esp. on zoom)   better user interaction (mouse move, hover, key listener)   a whole new set of charts   getting values when moving the mouse on charts   possibility to declare permanent layout:  + #splitted, #horizontal, #vertical, #stacked in the output section to automatically layout the display view.   Changing simulation names is reflected in their display titles (and it can be dynamic) OpenGL displays now handle rotations of 2D and 3D shapes, combinations of textures and colours, and keystoning      Error view   Much faster (up to 100x !) display of errors Contextual menu to copy the text of errors to clipboard or open the editor on it      Validation   Faster validation of multi-file models (x2 approx.)   Much less memory used compared to 1.6.1 (/10 approx.) No more  false positive  errors      Console   Interactive console allows to directly interact with agents (experiments, simulations and any agent) and get a direct feedback on the impact of code execution using a new interpreter integrated with the console. Available in the modeling perspective (to interact with the new gama agent) as well as the simulation perspective (to interact with the current experiment agent). Console now accepts colored text output      Monitor view monitors can have colors      GAMA-wide online help on the language A global search engine is now available in the top-right corner of the GAMA window to look for GAML idioms      Serialization   Serialize simulations and replay them (to come) Serialization and deserialization of agents between simulations (to come)      Allow TCP, UDP and MQQT communications between agents in different simulations (to come)  ","url":"wiki/NewVersionChanges.md"},{"id":"wiki/OlderVersions.md","title":" Versions of GAMA","content":"Versions of GAMA  GAMA exists since 2007 and has undergone a number of changes since its first release, materialized by different versions of the platform. Although we do not maintain these versions anymore, some are still used in lectures or specific projects. This page provides a list of these versions and, for each of them, a summary of its features and a link to its documentation in PDF format.  GAMA 1.6.1 (June 2014)  Version 1.6.1 is the current version of GAMA. It improves many features over version 1.6 :     OpenGL displays improvements   Various enhancements for displays (overlay, focus, light, trace, DEM, colors with alpha, addition of CSS colors..)   Compilation of models (errors tracked, memory, report of errors, etc.)   Validation of stochastic models (random now extended to every areas of a model, incl. the operations on HashSets)   GIS file handling (esp. with the possibility to pass a custom CRS)   Handling of OSM data   Comparison of raster and vectorial maps   Traffic moving skill improvement   Handling of various other file types (uniform constructors, …)   Documentation itself (both online and on the website)   Testing framework and debugging tools (trace, sample)   Speed of computation of several spatial operators   Experiments (permanent output, access to the duration of cycles)   Type system (complete parametric definitions of types)   Addition of several 3D operations   Auto-update mechanism of plugins   Automatic importation of files/projects when double-clicked in the OS (or transmitted by command line arguments)   Definition of charts (dynamic data lists, marker type, range, etc.)   Documentation:   * Available online    GAMA 1.6 (July 2013) This version introduced many features over 1.5.1 :     correction of bugs (in particular, freeze, memory consumption)   performance improvement (in particular for  big  models)   further simplification of the GAML language (assignments, manipulation of containers)   integration of an agent browser   improvement of the 3D integration (new operators, new display facet bug corrections…)   removing of the environment block   more user/simulation interaction (event statement)   Documentation:   * Documentation in PDF    GAMA 1.5 / 1.5.1 (July & November 2012) Key points :   * Improvement of the performance and stability   * Simplification of the modeling language (omissible facets, types as declarations, etc.)   * Integration of non-spatial graphs   * Introduction of OpenGL displays   * Improvement of the user interaction in the simulation perspective   * Generalization of the notion of experiment  Version 1.5.1 improved some features of 1.5 :     correction of bugs (in particular, no more freezes when reloading an experiment)   performance improvement (in particular for  big  models)   improvement of the 3D integration (new operators to add a  z  to geometries, bug corrections…)   new models (driving_traffic, Vote, 3D models)   Documentation:   * Documentation in PDF    GAMA 1.4 (December 2011) This versions introduced the new integrated development environment based on XText, as well as a completely revamped modeling language, not based on XML anymore, and much easier to read and write. It also introduced new important types such as geometry, graph, path and topology in order to ease the spatial manipulation of agents.  Key points :   * Deep refactoring of the source code   * New programming language (based on XText)   * Integration of a true IDE based on Eclipse/Xtext   * Deep refactoring of the meta-model   * Better integration of multi-level species   * New important notion: topology   * New variable types: geometry, graph, path, topology   * Many more novelties/improvements/enrichments…  Documentation:   * Documentation in PDF    GAMA 1.3 (August 2010) Version 1.3 added numerous operators to manipulate GIS data. Moreover, it integrated new features like the possibility to define custom displays and to define multi-level models. It allowed to use clustering and decision-making methods. And it greatly improved the performances of the platform.  Key points :   * Important improvement of the performance of the platform   * Improvement of the simulation display   * Enrichment of the spatial operators/actions   * Integration of multi-level models   * Integration of clustering algorithms   * Integration of decision-making algorithms  Documentation:   * Documentation in PDF    GAMA 1.1 (October 2009) The first  real  release of GAMA, which incorporated several changes, including an XML editor coupled with the simulator, the possibility to take snapshots of every graphical window, save parameters and monitors for future reuse, save charts as CSV files, and definitely fixed the memory leaks observed in previous internal versions.  Key points :   * Transformation into a more complete and versatile platform   * Addition of batch controllers   * Integration of a true modeling language (based on XML)   * First release as an open-source project  Documentation:   * Guidebook of GAMA 1.1   * Training session on GAMA 1.1 (Hanoi)   ","url":"wiki/OlderVersions.md"},{"id":"wiki/OperatorsAC.md","title":" Operators (A to C)","content":"Operators (A to C)    This file is automatically generated from java files. Do Not Edit It.    Definition  Operators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function.  Most of them use a classical prefixed functional syntax (i.e. operator_name(operand1, operand2, operand3), see below), with the exception of arithmetic (e.g. +, /), logical (and, or), comparison (e.g. >, <), access (., [..]) and pair (::) operators, which require an infixed notation (i.e. operand1 operator_symbol operand1).  The ternary functional if-else operator, ? :, uses a special infixed syntax composed with two symbols (e.g. operand1 ? operand2 : operand3). Two unary operators (- and !) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g.   - 10, ! (operand1 or operand2) ).  Finally, special constructor operators ({...} for constructing points, [...] for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. {1,2,3}, [operand1, operand2, ..., operandn] or [key1::value1, key2::value2... keyn::valuen]).  With the exception of these special cases above, the following rules apply to the syntax of operators: * if they only have one operand, the functional prefixed syntax is mandatory (e.g. operator_name(operand1)) * if they have two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2)) or the infixed syntax (e.g. operand1 operator_name operand2) can be used. * if they have more than two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2, ..., operand)) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. operand1 operator_name(operand2, ..., operand)) can be used.  All of these alternative syntaxes are completely equivalent.  Operators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.    Priority between operators  The priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.  GAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely: * the constructor operators, like ::, used to compose pairs of operands, have the lowest priority of all operators (e.g. a > b :: b > c will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, [a > 10, b > 5] will return a list of boolean values. * it is followed by the ?: operator, the functional if-else (e.g.   a > b ? a + 10 : a - 10 will return the result of the if-else). * next are the logical operators, and and or (e.g. a > b or b > c will return the value of the test) * next are the comparison operators (i.e. >, <, <=, >=, =, !=) * next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators) * next the unary operators - and ! * next the access operators . and [] (e.g. {1,2,3}.x > 20 + {4,5,6}.y  will return the result of the comparison between the x and y ordinates of the two points) * and finally the functional operators, which have the highest priority of all.    Using actions as operators  Actions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.  For instance, if the following species is defined:   species spec1 {  int min(int x, int y) {       return x > y ? x : y;  } }   Any agent instance of spec1 can use min as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:   global {  init {       create spec1;       spec1 my_agent <- spec1[0];       int the_min <- my_agent min(10,20); // or min(my_agent, 10, 20);  } }   If the action doesn t have any operands, the syntax to use is my_agent the_action(). Finally, if it does not return a value, it might still be used but is considering as returning a value of type unknown (e.g. unknown result <- my_agent the_action(op1, op2);).  Note that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).    Table of Contents    Operators by categories    3D box, cone3D, cube, cylinder, dem, hexagon, pyramid, rgb_to_xyz, set_z, sphere, teapot,    Arithmetic operators -, /, [^](OperatorsAC#^), [](OperatorsAC#), +, abs, acos, asin, atan, atan2, ceil, cos, cos_rad, div, even, exp, fact, floor, hypot, is_finite, is_number, ln, log, mod, round, signum, sin, sin_rad, sqrt, tan, tan_rad, tanh, with_precision,    BDI and, eval_when, get_about, get_agent, get_agent_cause, get_decay, get_dominance, get_familiarity, get_intensity, get_lifetime, get_liking, get_praiseworthiness, get_priority, get_solidarity, get_super_intention, new_emotion, new_predicate, new_social_link, or, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_liking, set_solidarity, set_truth, with_lifetime, with_praiseworthiness, with_priority, with_values,    Casting operators as, as_int, as_matrix, font, is, is_skill, list_with, matrix_with, species, to_gaml, topology,    Color-related operators -, /, [](OperatorsAC#), +, blend, brewer_colors, brewer_palettes, grayscale, hsb, mean, median, rgb, rnd_color, sum,    Comparison operators !=, <, <=, =, >, >=, between,    Containers-related operators -, ::, +, accumulate, among, at, collect, contains, contains_all, contains_any, count, distinct, empty, every, first, first_with, get, group_by, in, index_by, inter, interleave, internal_at, internal_integrated_value, last, last_with, length, max, max_of, mean, mean_of, median, min, min_of, mul, one_of, product_of, range, reverse, shuffle, sort_by, sum, sum_of, union, variance_of, where, with_max_of, with_min_of,    Date-related operators -, !=, +, <, <=, =, >, >=, after, before, between, every, milliseconds_between, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_weeks, minus_years, months_between, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_weeks, plus_years, since, to, until, years_between,    Dates    Driving operators as_driving_graph,    edge edge_between,    EDP-related operators diff, diff2, internal_zero_order_equation,    Files-related operators crs, file, file_exists, folder, get, new_folder, osm_file, read, writable,    FIPA-related operators conversation, message,    Graphs-related operators add_edge, add_node, adjacency, agent_from_geometry, all_pairs_shortest_path, alpha_index, as_distance_graph, as_edge_graph, as_intersection_graph, as_path, beta_index, betweenness_centrality, biggest_cliques_of, connected_components_of, connectivity_index, contains_edge, contains_vertex, degree_of, directed, edge, edge_between, edge_betweenness, edges, gamma_index, generate_barabasi_albert, generate_complete_graph, generate_watts_strogatz, grid_cells_to_graph, in_degree_of, in_edges_of, layout, load_graph_from_file, load_shortest_paths, maximal_cliques_of, nb_cycles, neighbors_of, node, nodes, out_degree_of, out_edges_of, path_between, paths_between, predecessors_of, remove_node_from, rewire_n, source_of, spatial_graph, successors_of, sum, target_of, undirected, use_cache, weight_of, with_optimizer_type, with_weights,    Grid-related operators as_4_grid, as_grid, as_hexagonal_grid, grid_at, path_between,    Iterator operators accumulate, as_map, collect, count, distribution_of, distribution_of, distribution_of, distribution2d_of, distribution2d_of, distribution2d_of, first_with, frequency_of, group_by, index_by, last_with, max_of, mean_of, min_of, product_of, sort_by, sum_of, variance_of, where, with_max_of, with_min_of,    List-related operators copy_between, index_of, last_index_of,    Logical operators :, !, ?, and, or,    Map comparaison operators fuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,    Map-related operators as_map, index_of, last_index_of,    Material material,    Matrix-related operators -, /, ., [](OperatorsAC#), +, append_horizontally, append_vertically, column_at, columns_list, determinant, eigenvalues, index_of, inverse, last_index_of, row_at, rows_list, shuffle, trace, transpose,    multicriteria operators electre_DM, evidence_theory_DM, promethee_DM, weighted_means_DM,    Path-related operators agent_from_geometry, all_pairs_shortest_path, as_path, load_shortest_paths, path_between, path_to, paths_between, use_cache,    Points-related operators -, /, [](OperatorsAC#), +, <, <=, >, >=, add_point, angle_between, any_location_in, centroid, closest_points_with, farthest_point_to, grid_at, norm, point, points_along, points_at, points_on,    Random operators binomial, flip, gauss, poisson, rnd, rnd_choice, sample, shuffle, skew_gauss, truncated_gauss,    ReverseOperators    Shape arc, box, circle, cone, cone3D, cross, cube, curve, cylinder, ellipse, envelope, geometry_collection, hexagon, line, link, plan, polygon, polyhedron, pyramid, rectangle, sphere, square, squircle, teapot, triangle,    Spatial operators -, [](OperatorsAC#), +, add_point, agent_closest_to, agent_farthest_to, agents_at_distance, agents_inside, agents_overlapping, angle_between, any_location_in, arc, around, as_4_grid, as_grid, as_hexagonal_grid, at_distance, at_location, box, centroid, circle, clean, closest_points_with, closest_to, cone, cone3D, convex_hull, covers, cross, crosses, crs, CRS_transform, cube, curve, cylinder, dem, direction_between, disjoint_from, distance_between, distance_to, ellipse, envelope, farthest_point_to, farthest_to, geometry_collection, gini, hexagon, hierarchical_clustering, IDW, inside, inter, intersects, line, link, masked_by, moran, neighbors_at, neighbors_of, overlapping, overlaps, partially_overlaps, path_between, path_to, plan, points_along, points_at, points_on, polygon, polyhedron, pyramid, rectangle, rgb_to_xyz, rotated_by, round, scaled_to, set_z, simple_clustering_by_distance, simplification, skeletonize, smooth, sphere, split_at, split_geometry, split_lines, square, squircle, teapot, to_GAMA_CRS, to_rectangles, to_squares, touches, towards, transformed_by, translated_by, triangle, triangulate, union, using, voronoi, with_precision, without_holes,    Spatial properties operators covers, crosses, intersects, partially_overlaps, touches,    Spatial queries operators agent_closest_to, agent_farthest_to, agents_at_distance, agents_inside, agents_overlapping, at_distance, closest_to, farthest_to, inside, neighbors_at, neighbors_of, overlapping,    Spatial relations operators direction_between, distance_between, distance_to, path_between, path_to, towards,    Spatial statistical operators hierarchical_clustering, simple_clustering_by_distance,    Spatial transformations operators -, [](OperatorsAC#), +, as_4_grid, as_grid, as_hexagonal_grid, at_location, clean, convex_hull, CRS_transform, rotated_by, scaled_to, simplification, skeletonize, smooth, split_geometry, split_lines, to_GAMA_CRS, to_rectangles, to_squares, transformed_by, translated_by, triangulate, voronoi, without_holes,    Species-related operators index_of, last_index_of, of_generic_species, of_species,    Statistical operators build, corR, dbscan, distribution_of, distribution2d_of, frequency_of, gamma_rnd, geometric_mean, gini, harmonic_mean, hierarchical_clustering, kmeans, kurtosis, max, mean, mean_deviation, meanR, median, min, moran, mul, predict, simple_clustering_by_distance, skewness, standard_deviation, sum, variance,    Strings-related operators +, <, <=, >, >=, at, char, contains, contains_all, contains_any, copy_between, date, empty, first, in, indented_by, index_of, is_number, last, last_index_of, length, lower_case, replace, replace_regex, reverse, sample, shuffle, split_with, string, upper_case,    System ., command, copy, dead, eval_gaml, every, user_input,    Time-related operators date, string,    Types-related operators    User control operators user_input,    Operators    ### -  Possible use:    - (int) —>  int   - (point) —>  point   - (float) —>  float   int - float —>  float   - (int , float) —>  float   int - int —>  int   - (int , int) —>  int   matrix - float —>  matrix   - (matrix , float) —>  matrix   float - matrix —>  matrix   - (float , matrix) —>  matrix   date - float —>  date   - (date , float) —>  date   species - agent —>  container   - (species , agent) —>  container   date - date —>  float   - (date , date) —>  float   matrix - matrix —>  matrix   - (matrix , matrix) —>  matrix   point - int —>  point   - (point , int) —>  point   date - int —>  date   - (date , int) —>  date   point - float —>  point   - (point , float) —>  point   float - float —>  float   - (float , float) —>  float   rgb - rgb —>  rgb   - (rgb , rgb) —>  rgb   int - matrix —>  matrix   - (int , matrix) —>  matrix   container - container —>  container   - (container , container) —>  container   rgb - int —>  rgb   - (rgb , int) —>  rgb   container - unknown —>  container   - (container , unknown) —>  container   point - point —>  point   - (point , point) —>  point   float - int —>  float   - (float , int) —>  float   geometry - geometry —>  geometry   - (geometry , geometry) —>  geometry   matrix - int —>  matrix   - (matrix , int) —>  matrix   geometry - float —>  geometry   - (geometry , float) —>  geometry   map - map —>  map   - (map , map) —>  map   map - pair —>  map   - (map , pair) —>  map   geometry - container<geometry> —>  geometry   - (geometry , container<geometry>) —>  geometry   Result: Returns the difference of the two operands. If it is used as an unary operator, it returns the opposite of the operand.  Comment: The behavior of the operator depends on the type of the operands.  Special cases:    if the left operand is a species and the right operand is an agent of the species, - returns a list containing all the agents of the species minus this agent   if both operands are containers and the right operand is empty, - returns the left operand   if both operands are numbers, performs a normal arithmetic difference and returns a float if one of them is a float.       int var7 <- 1 - 1;  // var7 equals 0 int var8 <- 1.0 - 1;  // var8 equals 0.0 int var9 <- 3.7 - 1.2;  // var9 equals 2.5 int var10 <- 3 - 1.2;  // var10 equals 1.8          if both operands are dates, returns the duration in seconds between  date2 and date1. To obtain a more precise duration, in milliseconds, use milliseconds_between(date1, date2)       float var11 <- date1 - date2;  // var11 equals 598          if one of the operands is a date and the other a number, returns a date corresponding to the date minus the given number as duration (in seconds)       date1 - 200          if left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the difference of the operand coordinate with this number.       point var13 <- {1, 2} - 4.5;  // var13 equals {-3.5, -2.5, -4.5} point var14 <- {1, 2} - 4;  // var14 equals {-3.0,-2.0,-4.0}          if both operands are colors, returns a new color resulting from the subtraction of the two operands, component by component       rgb var15 <- rgb([255, 128, 32]) - rgb( red );  // var15 equals rgb([0,128,32])          if one operand is a matrix and the other a number (float or int), performs a normal arithmetic difference of the number with each element of the matrix (results are float if the number is a float.       matrix var16 <- 3.5 - matrix([[2,5],[3,4]]);  // var16 equals matrix([[1.5,-1.5],[0.5,-0.5]])          if both operands are containers, returns a new list in which all the elements of the right operand have been removed from the left one       list var17 <- [1,2,3,4,5,6] - [2,4,9];  // var17 equals [1,3,5,6] list var18 <- [1,2,3,4,5,6] - [0,8];  // var18 equals [1,2,3,4,5,6]          if one operand is a color and the other an integer, returns a new color resulting from the subtraction of each component of the color with the right operand       rgb var19 <- rgb([255, 128, 32]) - 3;  // var19 equals rgb([252,125,29])          if the left operand is a list and the right operand is an object of any type (except list), - returns a list containing the elements of the left operand minus all the occurrences of this object       list var20 <- [1,2,3,4,5,6] - 2;  // var20 equals [1,3,4,5,6] list var21 <- [1,2,3,4,5,6] - 0;  // var21 equals [1,2,3,4,5,6]          if both operands are points, returns their difference (coordinates per coordinates).       point var22 <- {1, 2} - {4, 5};  // var22 equals {-3.0, -3.0}          if both operands are a point, a geometry or an agent, returns the geometry resulting from the difference between both geometries       geometry var23 <- geom1 - geom2;  // var23 equals a geometry corresponding to difference between geom1 and geom2          if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) reduced by the right-hand operand distance       geometry var24 <- shape - 5;  // var24 equals a geometry corresponding to the geometry of the agent applying the operator reduced by a distance of 5          if the right-operand is a list of points, geometries or agents, returns the geometry resulting from the difference between the left-geometry and all of the right-geometries       geometry var25 <- rectangle(10,10) - [circle(2), square(2)];  // var25 equals rectangle(10,10) - (circle(2) + square(2))       Examples:  int var0 <- - (-56);  // var0 equals 56 point var1 <- -{3.0,5.0};  // var1 equals {-3.0,-5.0} point var2 <- -{1.0,6.0,7.0};  // var2 equals {-1.0,-6.0,-7.0} map var3 <- [ a ::1, b ::2] - [ b ::2];  // var3 equals [ a ::1] map var4 <- [ a ::1, b ::2] - [ b ::2, c ::3];  // var4 equals [ a ::1] map var5 <- [ a ::1, b ::2] - ( b ::2);  // var5 equals [ a ::1] map var6 <- [ a ::1, b ::2] - ( c ::3);  // var6 equals [ a ::1, b ::2]   See also: +, [](OperatorsAC#), /, milliseconds_between, -,    ### :  Possible use:    unknown : unknown —>  unknown   : (unknown , unknown) —>  unknown   See also: ?,    ### ::  Possible use:    any expression :: any expression —>  pair   :: (any expression , any expression) —>  pair   Result: produces a new pair combining the left and the right operands  Special cases:    nil is not acceptable as a key (although it is as a value). If such a case happens, :: will throw an appropriate error     ### !  Possible use:    ! (bool) —>  bool   Result: opposite boolean value.  Special cases:    if the parameter is not boolean, it is casted to a boolean value.   Examples:  bool var0 <- ! (true);  // var0 equals false   See also: bool, and, or,    ### !=  Possible use:    float != float —>  bool   != (float , float) —>  bool   unknown != unknown —>  bool   != (unknown , unknown) —>  bool   date != date —>  bool   != (date , date) —>  bool   float != int —>  bool   != (float , int) —>  bool   int != float —>  bool   != (int , float) —>  bool   Result: true if both operands are different, false otherwise  Examples:  bool var0 <- 3.0 != 3.0;  // var0 equals false bool var1 <- 4.0 != 4.7;  // var1 equals true bool var2 <- [2,3] != [2,3];  // var2 equals false bool var3 <- [2,4] != [2,3];  // var3 equals true #now != #now minus_hours 1 :- true bool var5 <- 3.0 != 3;  // var5 equals false bool var6 <- 4.7 != 4;  // var6 equals true bool var7 <- 3 != 3.0;  // var7 equals false bool var8 <- 4 != 4.7;  // var8 equals true   See also: =, >, <, >=, <=,    ### ?  Possible use:    bool ? any expression —>  unknown   ? (bool , any expression) —>  unknown   Result: It is used in combination with the : operator: if the left-hand operand evaluates to true, returns the value of the left-hand operand of the :, otherwise that of the right-hand operand of the :  Comment: These functional tests can be combined together.  Examples:  list<string> var0 <- [10, 19, 43, 12, 7, 22] collect ((each > 20) ?  above  :  below );  // var0 equals [ below ,  below ,  above ,  below ,  below ,  above ] rgb color <- (flip(0.3) ? #red : (flip(0.9) ? #blue : #green));   See also: :,    ### /  Possible use:    rgb / float —>  rgb   / (rgb , float) —>  rgb   float / int —>  float   / (float , int) —>  float   point / float —>  point   / (point , float) —>  point   int / int —>  float   / (int , int) —>  float   int / float —>  float   / (int , float) —>  float   matrix / float —>  matrix   / (matrix , float) —>  matrix   point / int —>  point   / (point , int) —>  point   matrix / matrix —>  matrix   / (matrix , matrix) —>  matrix   matrix / int —>  matrix   / (matrix , int) —>  matrix   float / float —>  float   / (float , float) —>  float   rgb / int —>  rgb   / (rgb , int) —>  rgb   Result: Returns the division of the two operands.  Special cases:    if the right-hand operand is equal to zero, raises a  Division by zero  exception   if one operand is a color and the other a double, returns a new color resulting from the division of each component of the color by the right operand. The result on each component is then truncated.       rgb var0 <- rgb([255, 128, 32]) / 2.5;  // var0 equals rgb([102,51,13])          if the left operand is a point, returns a new point with coordinates divided by the right operand       point var1 <- {5, 7.5} / 2.5;  // var1 equals {2, 3} point var2 <- {2,5} / 4;  // var2 equals {0.5,1.25}          if both operands are numbers (float or int), performs a normal arithmetic division and returns a float.       float var3 <- 3 / 5.0;  // var3 equals 0.6          if one operand is a color and the other an integer, returns a new color resulting from the division of each component of the color by the right operand       rgb var4 <- rgb([255, 128, 32]) / 2;  // var4 equals rgb([127,64,16])       See also: [](OperatorsAC#), +, -,    ### .  Possible use:    matrix . matrix —>  matrix   . (matrix , matrix) —>  matrix   agent . any expression —>  unknown   . (agent , any expression) —>  unknown   Result: It has two different uses: it can be the dot product between 2 matrices or return an evaluation of the expression (right-hand operand) in the scope the given agent.  Special cases:    if the agent is nil or dead, throws an exception   if both operands are matrix, returns the dot product of them       matrix var0 <- matrix([[1,1],[1,2]]) . matrix([[1,1],[1,2]]);  // var0 equals matrix([[2,3],[3,5]])          if the left operand is an agent, it evaluates of the expression (right-hand operand) in the scope the given agent       unknown var1 <- agent1.location;  // var1 equals the location of the agent agent1 map(nil).keys         ### ^  Possible use:    int ^ float —>  float   ^ (int , float) —>  float   float ^ float —>  float   ^ (float , float) —>  float   int ^ int —>  float   ^ (int , int) —>  float   float ^ int —>  float   ^ (float , int) —>  float   Result: Returns the value (always a float) of the left operand raised to the power of the right operand.  Special cases:    if the right-hand operand is equal to 0, returns 1   if it is equal to 1, returns the left-hand operand.   Various examples of power       float var1 <- 2 ^ 3;  // var1 equals 8.0       Examples:  float var0 <- 4.84 ^ 0.5;  // var0 equals 2.2   See also: [](OperatorsAC#), sqrt,    ### @ Same signification as at    ### *  Possible use:    int * int —>  int   * (int , int) —>  int   matrix * int —>  matrix   * (matrix , int) —>  matrix   point * point —>  float   * (point , point) —>  float   int * float —>  float   * (int , float) —>  float   float * float —>  float   * (float , float) —>  float   matrix * matrix —>  matrix   * (matrix , matrix) —>  matrix   point * int —>  point   * (point , int) —>  point   float * matrix —>  matrix   * (float , matrix) —>  matrix   geometry * point —>  geometry   * (geometry , point) —>  geometry   point * float —>  point   * (point , float) —>  point   int * matrix —>  matrix   * (int , matrix) —>  matrix   float * int —>  float   * (float , int) —>  float   rgb * int —>  rgb   * (rgb , int) —>  rgb   matrix * float —>  matrix   * (matrix , float) —>  matrix   geometry * float —>  geometry   * (geometry , float) —>  geometry   Result: Returns the product of the two operands.  Special cases:    if both operands are numbers (float or int), performs a normal arithmetic product and returns a float if one of them is a float.       int var1 <- 1 * 1;  // var1 equals 1          if both operands are points, returns their scalar product       float var2 <- {2,5} * {4.5, 5};  // var2 equals 34.0          if the left-hand operator is a point and the right-hand a number, returns a point with coordinates multiplied by the number       point var3 <- {2,5} * 4;  // var3 equals {8.0, 20.0} point var4 <- {2, 4} * 2.5;  // var4 equals {5.0, 10.0}          if the left-hand operand is a geometry and the right-hand operand a point, returns a geometry corresponding to the left-hand operand (geometry, agent, point) scaled by the right-hand operand coefficients in the 3 dimensions       geometry var5 <- shape * {0.5,0.5,2};  // var5 equals a geometry corresponding to the geometry of the agent applying the operator scaled by a coefficient of 0.5 in x, 0.5 in y and 2 in z          if one operand is a matrix and the other a number (float or int), performs a normal arithmetic product of the number with each element of the matrix (results are float if the number is a float.       matrix m <- (3.5 * matrix([[2,5],[3,4]])); //m equals matrix([[7.0,17.5],[10.5,14]])          if one operand is a color and the other an integer, returns a new color resulting from the product of each component of the color with the right operand (with a maximum value at 255)       rgb var7 <- rgb([255, 128, 32]) * 2;  // var7 equals rgb([255,255,64])          if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) scaled by the right-hand operand coefficient       geometry var8 <- circle(10) * 2;  // var8 equals circle(20)       Examples:  float var0 <- 2.5 * 2;  // var0 equals 5.0   See also: +, -, /,    ### +  Possible use:    string + string —>  string   + (string , string) —>  string   date + float —>  date   + (date , float) —>  date   map + pair —>  map   + (map , pair) —>  map   int + matrix —>  matrix   + (int , matrix) —>  matrix   point + int —>  point   + (point , int) —>  point   rgb + rgb —>  rgb   + (rgb , rgb) —>  rgb   geometry + float —>  geometry   + (geometry , float) —>  geometry   matrix + float —>  matrix   + (matrix , float) —>  matrix   geometry + geometry —>  geometry   + (geometry , geometry) —>  geometry   map + map —>  map   + (map , map) —>  map   float + float —>  float   + (float , float) —>  float   float + int —>  float   + (float , int) —>  float   matrix + matrix —>  matrix   + (matrix , matrix) —>  matrix   date + string —>  string   + (date , string) —>  string   matrix + int —>  matrix   + (matrix , int) —>  matrix   int + int —>  int   + (int , int) —>  int   string + unknown —>  string   + (string , unknown) —>  string   point + point —>  point   + (point , point) —>  point   float + matrix —>  matrix   + (float , matrix) —>  matrix   int + float —>  float   + (int , float) —>  float   point + float —>  point   + (point , float) —>  point   rgb + int —>  rgb   + (rgb , int) —>  rgb   date + int —>  date   + (date , int) —>  date   container + container —>  container   + (container , container) —>  container   container + unknown —>  container   + (container , unknown) —>  container   + (geometry, float, int) —>  geometry   + (geometry, float, int, int) —>  geometry   Result: Returns the sum, union or concatenation of the two operands.  Special cases:    if one of the operands is nil, + throws an error   if both operands are species, returns a special type of list called meta-population   if the left-hand operand is a geometry and the right-hand operands a float and an integer, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the first right-hand operand (distance), using a number of segments equal to the second right-hand operand       geometry var4 <- circle(5) + (5,32);  // var4 equals circle(10)          if one operand is a matrix and the other a number (float or int), performs a normal arithmetic sum of the number with each element of the matrix (results are float if the number is a float.       matrix var5 <- 3.5 + matrix([[2,5],[3,4]]);  // var5 equals matrix([[5.5,8.5],[6.5,7.5]])          if both operands are colors, returns a new color resulting from the sum of the two operands, component by component       rgb var6 <- rgb([255, 128, 32]) + rgb( red );  // var6 equals rgb([255,128,32])          if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the right-hand operand distance. The number of segments used by default is 8 and the end cap style is #round       geometry var7 <- circle(5) + 5;  // var7 equals circle(10)          if the right-operand is a point, a geometry or an agent, returns the geometry resulting from the union between both geometries       geometry var8 <- geom1 + geom2;  // var8 equals a geometry corresponding to union between geom1 and geom2          if both operands are numbers (float or int), performs a normal arithmetic sum and returns a float if one of them is a float.       int var9 <- 1 + 1;  // var9 equals 2 int var10 <- 1.0 + 1;  // var10 equals 2.0 int var11 <- 1.0 + 2.5;  // var11 equals 3.5          if the left-hand operand is a string, returns the concatenation of the two operands (the left-hand one beind casted into a string)       string var12 <-  hello   + 12;  // var12 equals  hello 12           if both operands are points, returns their sum.       point var13 <- {1, 2} + {4, 5};  // var13 equals {5.0, 7.0}          if the left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the sum of the operand coordinate with this number.       point var14 <- {1, 2} + 4;  // var14 equals {5.0, 6.0,4.0} point var15 <- {1, 2} + 4.5;  // var15 equals {5.5, 6.5,4.5}          if one operand is a color and the other an integer, returns a new color resulting from the sum of each component of the color with the right operand       rgb var16 <- rgb([255, 128, 32]) + 3;  // var16 equals rgb([255,131,35])          if the left-hand operand is a geometry and the right-hand operands a float, an integer and one of #round, #square or #flat, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the first right-hand operand (distance), using a number of segments equal to the second right-hand operand and a flat, square or round end cap style       geometry var17 <- circle(5) + (5,32,#round);  // var17 equals circle(10)          if one of the operands is a date and the other a number, returns a date corresponding to the date plus the given number as duration (in seconds)       date1 + 200          if both operands are list, +returns the concatenation of both lists.       list var19 <- [1,2,3,4,5,6] + [2,4,9];  // var19 equals [1,2,3,4,5,6,2,4,9] list var20 <- [1,2,3,4,5,6] + [0,8];  // var20 equals [1,2,3,4,5,6,0,8]          if the right operand is an object of any type (except a container), + returns a list of the elements of the left operand, to which this object has been added       list var21 <- [1,2,3,4,5,6] + 2;  // var21 equals [1,2,3,4,5,6,2] list var22 <- [1,2,3,4,5,6] + 0;  // var22 equals [1,2,3,4,5,6,0]       Examples:  map var0 <- [ a ::1, b ::2] + ( c ::3);  // var0 equals [ a ::1, b ::2, c ::3] map var1 <- [ a ::1, b ::2] + ( c ::3);  // var1 equals [ a ::1, b ::2, c ::3] map var2 <- [ a ::1, b ::2] + [ c ::3];  // var2 equals [ a ::1, b ::2, c ::3] map var3 <- [ a ::1, b ::2] + [5::3.0];  // var3 equals [ a ::1.0, b ::2.0,5::3.0]   See also: -, [](OperatorsAC#), /,    ### <  Possible use:    float < int —>  bool   < (float , int) —>  bool   int < int —>  bool   < (int , int) —>  bool   point < point —>  bool   < (point , point) —>  bool   int < float —>  bool   < (int , float) —>  bool   date < date —>  bool   < (date , date) —>  bool   float < float —>  bool   < (float , float) —>  bool   string < string —>  bool   < (string , string) —>  bool   Result: true if the left-hand operand is less than the right-hand operand, false otherwise.  Special cases:    if one of the operands is nil, returns false   if both operands are points, returns true if and only if the left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.       bool var5 <- {5,7} < {4,6};  // var5 equals false bool var6 <- {5,7} < {4,8};  // var6 equals false          if both operands are String, uses a lexicographic comparison of two strings       bool var7 <-  abc  <  aeb ;  // var7 equals true       Examples:  bool var0 <- 3.5 < 7;  // var0 equals true bool var1 <- 3 < 7;  // var1 equals true bool var2 <- 3 < 2.5;  // var2 equals false #now < #now minus_hours 1 :- false bool var4 <- 3.5 < 7.6;  // var4 equals true   See also: >, >=, <=, =, !=,    ### <=  Possible use:    string <= string —>  bool   <= (string , string) —>  bool   date <= date —>  bool   <= (date , date) —>  bool   float <= float —>  bool   <= (float , float) —>  bool   int <= int —>  bool   <= (int , int) —>  bool   int <= float —>  bool   <= (int , float) —>  bool   float <= int —>  bool   <= (float , int) —>  bool   point <= point —>  bool   <= (point , point) —>  bool   Result: true if the left-hand operand is less or equal than the right-hand operand, false otherwise.  Special cases:    if one of the operands is nil, returns false   if both operands are String, uses a lexicographic comparison of two strings       bool var5 <-  abc  <=  aeb ;  // var5 equals true          if both operands are points, returns true if and only if the left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.       bool var6 <- {5,7} <= {4,6};  // var6 equals false bool var7 <- {5,7} <= {4,8};  // var7 equals false       Examples:  #now <= #now minus_hours 1 :- false bool var1 <- 3.5 <= 3.5;  // var1 equals true bool var2 <- 3 <= 7;  // var2 equals true bool var3 <- 3 <= 2.5;  // var3 equals false bool var4 <- 7.0 <= 7;  // var4 equals true   See also: >, <, >=, =, !=,    ### <> Same signification as !=    ### =  Possible use:    date = date —>  bool   = (date , date) —>  bool   int = float —>  bool   = (int , float) —>  bool   unknown = unknown —>  bool   = (unknown , unknown) —>  bool   float = float —>  bool   = (float , float) —>  bool   float = int —>  bool   = (float , int) —>  bool   int = int —>  bool   = (int , int) —>  bool   Result: returns true if both operands are equal, false otherwise returns true if both operands are equal, false otherwise  Special cases:    if both operands are any kind of objects, returns true if they are identical (i.e., the same object) or equal (comparisons between nil values are permitted)       bool var0 <- [2,3] = [2,3];  // var0 equals true       Examples:  #now = #now minus_hours 1 :- false bool var2 <- 3 = 3.0;  // var2 equals true bool var3 <- 4 = 4.7;  // var3 equals false bool var4 <- 4.5 = 4.7;  // var4 equals false bool var5 <- 4.7 = 4;  // var5 equals false bool var6 <- 4 = 5;  // var6 equals false   See also: !=, >, <, >=, <=,    ### >  Possible use:    int > float —>  bool   > (int , float) —>  bool   float > float —>  bool   > (float , float) —>  bool   string > string —>  bool   > (string , string) —>  bool   int > int —>  bool   > (int , int) —>  bool   date > date —>  bool   > (date , date) —>  bool   point > point —>  bool   > (point , point) —>  bool   float > int —>  bool   > (float , int) —>  bool   Result: true if the left-hand operand is greater than the right-hand operand, false otherwise.  Special cases:    if one of the operands is nil, returns false   if both operands are String, uses a lexicographic comparison of two strings       bool var0 <-  abc  >  aeb ;  // var0 equals false          if both operands are points, returns true if and only if the left component (x) of the left operand if greater than x of the right one and if the right component (y) of the left operand is greater than y of the right one.       bool var1 <- {5,7} > {4,6};  // var1 equals true bool var2 <- {5,7} > {4,8};  // var2 equals false       Examples:  bool var3 <- 3 > 2.5;  // var3 equals true bool var4 <- 3.5 > 7.6;  // var4 equals false bool var5 <- 3 > 7;  // var5 equals false #now > #now minus_hours 1 :- true bool var7 <- 3.5 > 7;  // var7 equals false   See also: <, >=, <=, =, !=,    ### >=  Possible use:    float >= int —>  bool   >= (float , int) —>  bool   int >= int —>  bool   >= (int , int) —>  bool   int >= float —>  bool   >= (int , float) —>  bool   string >= string —>  bool   >= (string , string) —>  bool   date >= date —>  bool   >= (date , date) —>  bool   float >= float —>  bool   >= (float , float) —>  bool   point >= point —>  bool   >= (point , point) —>  bool   Result: true if the left-hand operand is greater or equal than the right-hand operand, false otherwise.  Special cases:    if one of the operands is nil, returns false   if both operands are string, uses a lexicographic comparison of the two strings       bool var5 <-  abc  >=  aeb ;  // var5 equals false bool var6 <-  abc  >=  abc ;  // var6 equals true          if both operands are points, returns true if and only if the left component (x) of the left operand if greater or equal than x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.       bool var7 <- {5,7} >= {4,6};  // var7 equals true bool var8 <- {5,7} >= {4,8};  // var8 equals false       Examples:  bool var0 <- 3.5 >= 7;  // var0 equals false bool var1 <- 3 >= 7;  // var1 equals false bool var2 <- 3 >= 2.5;  // var2 equals true #now >= #now minus_hours 1 :- true bool var4 <- 3.5 >= 3.5;  // var4 equals true   See also: >, <, <=, =, !=,    ### abs  Possible use:    abs (int) —>  int   abs (float) —>  float   Result: Returns the absolute value of the operand (so a positive int or float depending on the type of the operand).  Examples:  int var0 <- abs (-10);  // var0 equals 10 int var1 <- abs (10);  // var1 equals 10 float var3 <- abs (200 * -1 + 0.5);  // var3 equals 199.5     ### accumulate  Possible use:    container accumulate any expression —>  container   accumulate (container , any expression) —>  container   Result: returns a new flat list, in which each element is the evaluation of the right-hand operand. If this evaluation returns a list, the elements of this result are added directly to the list returned  Comment: accumulate is dedicated to the application of a same computation on each element of a container (and returns a list). In the right-hand operand, the keyword each can be used to represent, in turn, each of the left-hand operand elements.  Examples:  container var0 <- [a1,a2,a3] accumulate (each neighbors_at 10);  // var0 equals a flat list of all the neighbors of these three agents list<int> var1 <- [1,2,4] accumulate ([2,4]);  // var1 equals [2,4,2,4,2,4] list<int> var2 <- [1,2,4] accumulate (each * 2);  // var2 equals [2,4,8]   See also: collect,    ### acos  Possible use:    acos (float) —>  float   acos (int) —>  float   Result: Returns the value (in the interval [0,180], in decimal degrees) of the arccos of the operand (which should be in [-1,1]).  Special cases:    if the right-hand operand is outside of the [-1,1] interval, returns NaN   Examples:  float var0 <- acos (0);  // var0 equals 90.0   See also: asin, atan, cos,    ### action  Possible use:    action (any) —>  action   Result: Casts the operand into the type action    ### add_days Same signification as plus_days    ### add_edge  Possible use:    graph add_edge pair —>  graph   add_edge (graph , pair) —>  graph   Result: add an edge between a source vertex and a target vertex (resp. the left and the right element of the pair operand)  Comment: if the edge already exists, the graph is unchanged  Examples:  graph <- graph add_edge (source::target);   See also: add_node, graph,    ### add_hours Same signification as plus_hours    ### add_minutes Same signification as plus_minutes    ### add_months Same signification as plus_months    ### add_ms Same signification as plus_ms    ### add_node  Possible use:    graph add_node geometry —>  graph   add_node (graph , geometry) —>  graph   Result: adds a node in a graph.  Examples:  graph var0 <- graph add_node node(0) ;  // var0 equals the graph with node(0)   See also: add_edge, graph,    ### add_point  Possible use:    geometry add_point point —>  geometry   add_point (geometry , point) —>  geometry   Result: A new geometry resulting from the addition of the right point (coordinate) to the left-hand geometry. Note that adding a point to a line or polyline will always return a closed contour. Also note that the position at which the added point will appear in the geometry is not necessarily the last one, as points are always ordered in a clockwise fashion in geometries  Examples:  geometry var0 <- polygon([{10,10},{10,20},{20,20}]) add_point {20,10};  // var0 equals polygon([{10,10},{10,20},{20,20},{20,10}])     ### add_seconds Same signification as +    ### add_weeks Same signification as plus_weeks    ### add_years Same signification as plus_years    ### adjacency  Possible use:    adjacency (graph) —>  matrix<float>   Result: adjacency matrix of the given graph.    ### after  Possible use:    after (date) —>  bool   any expression after date —>  bool   after (any expression , date) —>  bool   Result: Returns true if the current_date of the model is strictly after the date passed in argument. Synonym of  current_date > argument . Can be used in its composed form with 2 arguments to express the lower boundary for the computation of a frequency. Note that only dates strictly after this one will be tested against the frequency  Examples:  reflex when: after(starting_date) {} -: will always be run after the first step reflex when: false after(starting date + #10days) {} -: will not be run after this date. Better to use  until  or  before  in that case every(2#days) after (starting_date + 1#day) // the computation will return true every two days (using the starting_date of the model as the starting point) only for the dates strictly after this starting_date + 1#day     ### agent  Possible use:    agent (any) —>  agent   Result: Casts the operand into the type agent    ### agent_closest_to  Possible use:    agent_closest_to (unknown) —>  agent   Result: An agent, the closest to the operand (casted as a geometry).  Comment: the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.  Examples:  agent var0 <- agent_closest_to(self);  // var0 equals the closest agent to the agent applying the operator.   See also: neighbors_at, neighbors_of, agents_inside, agents_overlapping, closest_to, inside, overlapping,    ### agent_farthest_to  Possible use:    agent_farthest_to (unknown) —>  agent   Result: An agent, the farthest to the operand (casted as a geometry).  Comment: the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.  Examples:  agent var0 <- agent_farthest_to(self);  // var0 equals the farthest agent to the agent applying the operator.   See also: neighbors_at, neighbors_of, agents_inside, agents_overlapping, closest_to, inside, overlapping, agent_closest_to, farthest_to,    ### agent_from_geometry  Possible use:    path agent_from_geometry geometry —>  agent   agent_from_geometry (path , geometry) —>  agent   Result: returns the agent corresponding to given geometry (right-hand operand) in the given path (left-hand operand).  Special cases:    if the left-hand operand is nil, returns nil   Examples:  geometry line <- one_of(path_followed.segments); road ag <- road(path_followed agent_from_geometry line);   See also: path,    ### agents_at_distance  Possible use:    agents_at_distance (float) —>  container   Result: A list of agents situated at a distance lower than the right argument.  Examples:  container var0 <- agents_at_distance(20);  // var0 equals all the agents (excluding the caller) which distance to the caller is lower than 20   See also: neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, overlapping, at_distance,    ### agents_inside  Possible use:    agents_inside (unknown) —>  list<agent>   Result: A list of agents covered by the operand (casted as a geometry).  Examples:  list<agent> var0 <- agents_inside(self);  // var0 equals the agents that are covered by the shape of the agent applying the operator.   See also: agent_closest_to, agents_overlapping, closest_to, inside, overlapping,    ### agents_overlapping  Possible use:    agents_overlapping (unknown) —>  list<agent>   Result: A list of agents overlapping the operand (casted as a geometry).  Examples:  list<agent> var0 <- agents_overlapping(self);  // var0 equals the agents that overlap the shape of the agent applying the operator.   See also: neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, overlapping, at_distance,    ### all_pairs_shortest_path  Possible use:    all_pairs_shortest_path (graph) —>  matrix<int>   Result: returns the successor matrix of shortest paths between all node pairs (rows: source, columns: target): a cell (i,j) will thus contains the next node in the shortest path between i and j.  Examples:  matrix<int> var0 <- all_pairs_shortest_paths(my_graph);  // var0 equals shortest_paths_matrix will contain all pairs of shortest paths     ### alpha_index  Possible use:    alpha_index (graph) —>  float   Result: returns the alpha index of the graph (measure of connectivity which evaluates the number of cycles in a graph in comparison with the maximum number of cycles. The higher the alpha index, the more a network is connected: alpha = nb_cycles / (2*S-5) - planar graph)  Examples:  float var1 <- alpha_index(graphEpidemio);  // var1 equals the alpha index of the graph   See also: beta_index, gamma_index, nb_cycles, connectivity_index,    ### among  Possible use:    int among container —>  container   among (int , container) —>  container   Result: Returns a list of length the value of the left-hand operand, containing random elements from the right-hand operand. As of GAMA 1.6, the order in which the elements are returned can be different than the order in which they appear in the right-hand container  Special cases:    if the right-hand operand is empty, among returns a new empty list. If it is nil, it throws an error.   if the left-hand operand is greater than the length of the right-hand operand, among returns the right-hand operand (converted as a list). If it is smaller or equal to zero, it returns an empty list   Examples:  list<int> var0 <- 3 among [1,2,4,3,5,7,6,8];  // var0 equals [1,2,8] (for example) container var1 <- 3 among g2;  // var1 equals [node6,node11,node7] container var2 <- 3 among list(node);  // var2 equals [node1,node11,node4] list<int> var3 <- 1 among [1::2,3::4];  // var3 equals 2 or 4     ### and  Possible use:    bool and any expression —>  bool   and (bool , any expression) —>  bool   Result: a bool value, equal to the logical and between the left-hand operand and the right-hand operand.  Comment: both operands are always casted to bool before applying the operator. Thus, an expression like (1 and 0) is accepted and returns false.  See also: bool, or, !,    ### and  Possible use:    predicate and predicate —>  predicate   and (predicate , predicate) —>  predicate   Result: create a new predicate from two others by including them as subintentions  Examples:  predicate1 and predicate2     ### angle_between  Possible use:    angle_between (point, point, point) —>  int   Result: the angle between vectors P0P1 and P0P2 (P0, P1, P2 being the three point operands)  Examples:  int var0 <- angle_between({5,5},{10,5},{5,10});  // var0 equals 90     ### any Same signification as one_of    ### any_location_in  Possible use:    any_location_in (geometry) —>  point   Result: A point inside (or touching) the operand-geometry.  Examples:  point var0 <- any_location_in(square(5));  // var0 equals a point in the square, for example : {3,4.6}.   See also: closest_points_with, farthest_point_to, points_at,    ### any_point_in Same signification as any_location_in    ### append_horizontally  Possible use:    matrix append_horizontally matrix —>  matrix   append_horizontally (matrix , matrix) —>  matrix   matrix append_horizontally matrix —>  matrix   append_horizontally (matrix , matrix) —>  matrix   Result: A matrix resulting from the concatenation of the rows of the two given matrices. If not both numerical or both object matrices, returns the first matrix.  Examples:  matrix var0 <- matrix([[1.0,2.0],[3.0,4.0]]) append_horizontally matrix([[1,2],[3,4]]);  // var0 equals matrix([[1.0,2.0],[3.0,4.0],[1.0,2.0],[3.0,4.0]])     ### append_vertically  Possible use:    matrix append_vertically matrix —>  matrix   append_vertically (matrix , matrix) —>  matrix   matrix append_vertically matrix —>  matrix   append_vertically (matrix , matrix) —>  matrix   Result: A matrix resulting from the concatenation of the columns  of the two given matrices. If not both numerical or both object matrices, returns the first matrix.  Examples:  matrix var0 <- matrix([[1,2],[3,4]]) append_vertically matrix([[1,2],[3,4]]);  // var0 equals matrix([[1,2,1,2],[3,4,3,4]])     ### arc  Possible use:    arc (float, float, float) —>  geometry   arc (float, float, float, bool) —>  geometry   Result: An arc, which radius is equal to the first operand, heading to the second and amplitude the third An arc, which radius is equal to the first operand, heading to the second, amplitude to the third and a boolean indicating whether to return a linestring or a polygon to the fourth  Comment: the center of the arc is by default the location of the current agent in which has been called this operator. This operator returns a polygon by default.the center of the arc is by default the location of the current agent in which has been called this operator.  Special cases:    returns a point if the radius operand is lower or equal to 0.   returns a point if the radius operand is lower or equal to 0.   Examples:  geometry var0 <- arc(4,45,90);  // var0 equals a geometry as an arc of radius 4, in a direction of 45Â° and an amplitude of 90Â° geometry var1 <- arc(4,45,90, false);  // var1 equals a geometry as an arc of radius 4, in a direction of 45Â° and an amplitude of 90Â°, which only contains the points on the arc   See also: around, cone, line, link, norm, point, polygon, polyline, super_ellipse, rectangle, square, circle, ellipse, triangle,    ### around  Possible use:    float around unknown —>  geometry   around (float , unknown) —>  geometry   Result: A geometry resulting from the difference between a buffer around the right-operand casted in geometry at a distance left-operand (right-operand buffer left-operand) and the right-operand casted as geometry.  Special cases:    returns a circle geometry of radius right-operand if the left-operand is nil   Examples:  geometry var0 <- 10 around circle(5);  // var0 equals the ring geometry between 5 and 10.   See also: circle, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,    ### as  Possible use:    unknown as any expression —>  unknown   as (unknown , any expression) —>  unknown   Result: casting of the first argument into a given type  Comment: It is equivalent to the application of the type operator on the left operand.  Examples:  int var0 <- 3.5 as int;  // var0 equals int(3.5)     ### as_4_grid  Possible use:    geometry as_4_grid point —>  matrix   as_4_grid (geometry , point) —>  matrix   Result: A matrix of square geometries (grid with 4-neighborhood) with dimension given by the right-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)  Examples:  matrix var0 <- self as_4_grid {10, 5};  // var0 equals the matrix of square geometries (grid with 4-neighborhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.   See also: as_grid, as_hexagonal_grid,    ### as_distance_graph  Possible use:    container as_distance_graph map —>  graph   as_distance_graph (container , map) —>  graph   container as_distance_graph float —>  graph   as_distance_graph (container , float) —>  graph   as_distance_graph (container, float, species) —>  graph   Result: creates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices close enough (less than a distance, right-hand operand).  Comment: as_distance_graph is more efficient for a list of points than as_intersection_graph.  Examples:  list(ant) as_distance_graph 3.0   See also: as_intersection_graph, as_edge_graph,    ### as_driving_graph  Possible use:    container as_driving_graph container —>  graph   as_driving_graph (container , container) —>  graph   Result: creates a graph from the list/map of edges given as operand and connect the node to the edge  Examples:  as_driving_graph(road,node)  --:  build a graph while using the road agents as edges and the node agents as nodes   See also: as_intersection_graph, as_distance_graph, as_edge_graph,    ### as_edge_graph  Possible use:    as_edge_graph (map) —>  graph   as_edge_graph (container) —>  graph   container as_edge_graph float —>  graph   as_edge_graph (container , float) —>  graph   Result: creates a graph from the list/map of edges given as operand  Special cases:    if the operand is a map, the graph will be built by creating edges from pairs of the map       graph var0 <- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);  // var0 equals a graph with these three vertices and two edges          if the operand is a list and a tolerance (max distance in meters to consider that 2 points are the same node) is given, the graph will be built with elements of the list as edges and two edges will be connected by a node if the distance between their extremity (first or last points) are at distance lower or equal to the tolerance       graph var1 <- as_edge_graph([line([{1,5},{12,45}]),line([{13,45},{34,56}])],1);;  // var1 equals a graph with two edges and three vertices          if the operand is a list, the graph will be built with elements of the list as edges       graph var2 <- as_edge_graph([line([{1,5},{12,45}]),line([{12,45},{34,56}])]);  // var2 equals a graph with two edges and three vertices       See also: as_intersection_graph, as_distance_graph,    ### as_grid  Possible use:    geometry as_grid point —>  matrix   as_grid (geometry , point) —>  matrix   Result: A matrix of square geometries (grid with 8-neighborhood) with dimension given by the right-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)  Examples:  matrix var0 <- self as_grid {10, 5};  // var0 equals a matrix of square geometries (grid with 8-neighborhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.   See also: as_4_grid, as_hexagonal_grid,    ### as_hexagonal_grid  Possible use:    geometry as_hexagonal_grid point —>  list<geometry>   as_hexagonal_grid (geometry , point) —>  list<geometry>   Result: A list of geometries (hexagonal) corresponding to the hexagonal tesselation of the first operand geometry  Examples:  list<geometry> var0 <- self as_hexagonal_grid {10, 5};  // var0 equals list of geometries (hexagonal) corresponding to the hexagonal tesselation of the first operand geometry   See also: as_4_grid, as_grid,    ### as_int  Possible use:    string as_int int —>  int   as_int (string , int) —>  int   Result: parses the string argument as a signed integer in the radix specified by the second argument.  Special cases:    if the left operand is nil or empty, as_int returns 0   if the left operand does not represent an integer in the specified radix, as_int throws an exception   Examples:  int var0 <-  20  as_int 10;  // var0 equals 20 int var1 <-  20  as_int 8;  // var1 equals 16 int var2 <-  20  as_int 16;  // var2 equals 32 int var3 <-  1F  as_int 16;  // var3 equals 31 int var4 <-  hello  as_int 32;  // var4 equals 18306744   See also: int,    ### as_intersection_graph  Possible use:    container as_intersection_graph float —>  graph   as_intersection_graph (container , float) —>  graph   Result: creates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices with an intersection (with a given tolerance).  Comment: as_intersection_graph is more efficient for a list of geometries (but less accurate) than as_distance_graph.  Examples:  list(ant) as_intersection_graph 0.5   See also: as_distance_graph, as_edge_graph,    ### as_map  Possible use:    container as_map any expression —>  map   as_map (container , any expression) —>  map   Result: produces a new map from the evaluation of the right-hand operand for each element of the left-hand operand  Comment: the right-hand operand should be a pair  Special cases:    if the left-hand operand is nil, as_map throws an error.   Examples:  map<int,int> var0 <- [1,2,3,4,5,6,7,8] as_map (each::(each * 2));  // var0 equals [1::2, 2::4, 3::6, 4::8, 5::10, 6::12, 7::14, 8::16] map<int,int> var1 <- [1::2,3::4,5::6] as_map (each::(each * 2));  // var1 equals [2::4, 4::8, 6::12]      ### as_matrix  Possible use:    unknown as_matrix point —>  matrix   as_matrix (unknown , point) —>  matrix   Result: casts the left operand into a matrix with right operand as preferred size  Comment: This operator is very useful to cast a file containing raster data into a matrix.Note that both components of the right operand point should be positive, otherwise an exception is raised.The operator as_matrix creates a matrix of preferred size. It fills in it with elements of the left operand until the matrix is full If the size is to short, some elements will be omitted. Matrix remaining elements will be filled in by nil.  Special cases:    if the right operand is nil, as_matrix is equivalent to the matrix operator   See also: matrix,    ### as_path  Possible use:    list<geometry> as_path graph —>  path   as_path (list<geometry> , graph) —>  path   Result: create a graph path from the list of shape  Examples:  path var0 <- [road1,road2,road3] as_path my_graph;  // var0 equals a path road1->road2->road3 of my_graph     ### asin  Possible use:    asin (float) —>  float   asin (int) —>  float   Result: the arcsin of the operand  Special cases:    if the right-hand operand is outside of the [-1,1] interval, returns NaN   Examples:  float var0 <- asin (0);  // var0 equals 0.0 float var1 <- asin (90);  // var1 equals #nan   See also: acos, atan, sin,    ### at  Possible use:    string at int —>  string   at (string , int) —>  string   container<KeyType,ValueType> at KeyType —>  ValueType   at (container<KeyType,ValueType> , KeyType) —>  ValueType   Result: the element at the right operand index of the container  Comment: The first element of the container is located at the index 0. In addition, if the user tries to get the element at an index higher or equals than the length of the container, he will get an IndexOutOfBoundException.The at operator behavior depends on the nature of the operand  Special cases:    if it is a file, at returns the element of the file content at the index specified by the right operand   if it is a population, at returns the agent at the index specified by the right operand   if it is a graph and if the right operand is a node, at returns the in and out edges corresponding to that node   if it is a graph and if the right operand is an edge, at returns the pair node_out::node_in of the edge   if it is a graph and if the right operand is a pair node1::node2, at returns the edge from node1 to node2 in the graph   if it is a list or a matrix, at returns the element at the index specified by the right operand       int var1 <- [1, 2, 3] at 2;  // var1 equals 3 point var2 <- [{1,2}, {3,4}, {5,6}] at 0;  // var2 equals {1.0,2.0}       Examples:  string var0 <-  abcdef  at 0;  // var0 equals  a    See also: contains_all, contains_any,    ### at_distance  Possible use:    container<agent> at_distance float —>  list<geometry>   at_distance (container<agent> , float) —>  list<geometry>   Result: A list of agents or geometries among the left-operand list that are located at a distance <= the right operand from the caller agent (in its topology)  Examples:  list<geometry> var0 <- [ag1, ag2, ag3] at_distance 20;  // var0 equals the agents of the list located at a distance <= 20 from the caller agent (in the same order).   See also: neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, overlapping,    ### at_location  Possible use:    geometry at_location point —>  geometry   at_location (geometry , point) —>  geometry   Result: A geometry resulting from the tran of a translation to the right-hand operand point of the left-hand operand (geometry, agent, point)  Examples:  geometry var0 <- self at_location {10, 20};  // var0 equals the geometry resulting from a translation to the location {10, 20} of the left-hand geometry (or agent).     ### atan  Possible use:    atan (float) —>  float   atan (int) —>  float   Result: Returns the value (in the interval [-90,90], in decimal degrees) of the arctan of the operand (which can be any real number).  Examples:  float var0 <- atan (1);  // var0 equals 45.0   See also: acos, asin, tan,    ### atan2  Possible use:    float atan2 float —>  float   atan2 (float , float) —>  float   Result: the atan2 value of the two operands.  Comment: The function atan2 is the arctangent function with two arguments. The purpose of using two arguments instead of one is to gather information on the signs of the inputs in order to return the appropriate quadrant of the computed angle, which is not possible for the single-argument arctangent function.  Examples:  float var0 <- atan2 (0,0);  // var0 equals 0.0   See also: atan, acos, asin,    ### attributes  Possible use:    attributes (any) —>  attributes   Result: Casts the operand into the type attributes    ### BDIPlan  Possible use:    BDIPlan (any) —>  BDIPlan   Result: Casts the operand into the type BDIPlan    ### before  Possible use:    before (date) —>  bool   any expression before date —>  bool   before (any expression , date) —>  bool   Result: Returns true if the current_date of the model is strictly before the date passed in argument. Synonym of  current_date < argument   Examples:  reflex when: before(starting_date) {} -: will never be run     ### beta_index  Possible use:    beta_index (graph) —>  float   Result: returns the beta index of the graph (Measures the level of connectivity in a graph and is expressed by the relationship between the number of links (e) over the number of nodes (v) : beta = e/v.  Examples:  graph graphEpidemio <- graph([]); float var1 <- beta_index(graphEpidemio);  // var1 equals the beta index of the graph   See also: alpha_index, gamma_index, nb_cycles, connectivity_index,    ### between  Possible use:    date between date —>  bool   between (date , date) —>  bool   between (int, int, int) —>  bool   between (any expression, date, date) —>  bool   between (float, float, float) —>  bool   between (date, date, date) —>  bool   Result: returns true the first integer operand is bigger than the second integer operand and smaller than the third integer operand returns true if the first float operand is bigger than the second float operand and smaller than the third float operand  Special cases:    returns true if the first operand is between the two dates passed in arguments (both exclusive). Can be combined with  every  to express a frequency between two dates       (date( 2016-01-01 ) between(date( 2000-01-01 ), date( 2020-02-02 ) -: true every #day between(date( 2000-01-01 ), date( 2020-02-02 ) // will return true every new day between these two dates, taking the first one as the starting point          returns true if the first operand is between the two dates passed in arguments (both exclusive). The version with 2 arguments compares the current_date with the 2 others       (date( 2016-01-01 ) between(date( 2000-01-01 ), date( 2020-02-02 ) -: true between(date( 2000-01-01 ), date( 2020-02-02 ) // will return true if the current_date of the model is in_between the 2       Examples:  bool var0 <- between(5, 1, 10);  // var0 equals true bool var1 <- between(5.0, 1.0, 10.0);  // var1 equals true     ### betweenness_centrality  Possible use:    betweenness_centrality (graph) —>  map   Result: returns a map containing for each vertex (key), its betweenness centrality (value): number of shortest paths passing through each vertex  Examples:  graph graphEpidemio <- graph([]); map var1 <- betweenness_centrality(graphEpidemio);  // var1 equals the betweenness centrality index of the graph     ### biggest_cliques_of  Possible use:    biggest_cliques_of (graph) —>  list<list>   Result: returns the biggest cliques of a graph using the Bron-Kerbosch clique detection algorithm  Examples:  graph my_graph <- graph([]); list<list> var1 <- biggest_cliques_of (my_graph);  // var1 equals the list of the biggest cliques as list   See also: maximal_cliques_of,    ### binomial  Possible use:    int binomial float —>  int   binomial (int , float) —>  int   Result: A value from a random variable following a binomial distribution. The operands represent the number of experiments n and the success probability p.  Comment: The binomial distribution is the discrete probability distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields success with probability p, cf. Binomial distribution on Wikipedia.  Examples:  int var0 <- binomial(15,0.6);  // var0 equals a random positive integer   See also: poisson, gauss,    ### blend  Possible use:    rgb blend rgb —>  rgb   blend (rgb , rgb) —>  rgb   blend (rgb, rgb, float) —>  rgb   Result: Blend two colors with an optional ratio (c1 * r + c2 * (1 - r)) between 0 and 1  Special cases:    If the ratio is omitted, an even blend is done       rgb var3 <- blend(#red, #blue);  // var3 equals to a color very close to the purple       Examples:  rgb var1 <- blend(#red, #blue, 0.3);  // var1 equals to a color between the purple and the blue   See also: rgb, hsb,    ### bool  Possible use:    bool (any) —>  bool   Result: Casts the operand into the type bool    ### box  Possible use:    box (point) —>  geometry   box (float, float, float) —>  geometry   Result: A box geometry which side sizes are given by the operands.  Comment: the center of the box is by default the location of the current agent in which has been called this operator.the center of the box is by default the location of the current agent in which has been called this operator.  Special cases:    returns nil if the operand is nil.   returns nil if the operand is nil.   Examples:  geometry var0 <- box(10, 5 , 5);  // var0 equals a geometry as a rectangle with width = 10, height = 5 depth= 5. geometry var1 <- box({10, 5 , 5});  // var1 equals a geometry as a rectangle with width = 10, height = 5 depth= 5.   See also: around, circle, sphere, cone, line, link, norm, point, polygon, polyline, square, cube, triangle,    ### brewer_colors  Possible use:    brewer_colors (string) —>  list<rgb>   string brewer_colors int —>  list<rgb>   brewer_colors (string , int) —>  list<rgb>   Result: Build a list of colors of a given type (see website http://colorbrewer2.org/) Build a list of colors of a given type (see website http://colorbrewer2.org/) with a given number of classes  Examples:  list<rgb> var0 <- list<rgb> colors <- brewer_colors(OrRd);;  // var0 equals a list of 6 blue colors list<rgb> var1 <- list<rgb> colors <- brewer_colors(Pastel1, 10);;  // var1 equals a list of 10 sequential colors   See also: brewer_palettes,    ### brewer_palettes  Possible use:    brewer_palettes (int) —>  list<string>   int brewer_palettes int —>  list<string>   brewer_palettes (int , int) —>  list<string>   Result: returns the list a palette with a given min number of classes and max number of classes) returns the list a palette with a given min number of classes and max number of classes)  Examples:  list<string> var0 <- list<rgb> colors <- brewer_palettes(5,10);;  // var0 equals a list of palettes that are composed of a min of 5 colors and a max of 10 colors list<string> var1 <- list<rgb> colors <- brewer_palettes();;  // var1 equals a list of palettes that are composed of a min of 5 colors   See also: brewer_colors,    ### buffer Same signification as +    ### build  Possible use:    build (matrix<float>) —>  regression   matrix<float> build string —>  regression   build (matrix<float> , string) —>  regression   Result: returns the regression build from the matrix data (a row = an instance, the last value of each line is the y value) while using the given ordinary least squares method. Usage: build(data) returns the regression build from the matrix data (a row = an instance, the last value of each line is the y value) while using the given method ( GLS  or  OLS ). Usage: build(data,method)  Examples:  matrix([[1,2,3,4],[2,3,4,2]]) build(matrix([[1,2,3,4],[2,3,4,2]]),GLS)     ### ceil  Possible use:    ceil (float) —>  float   Result: Maps the operand to the smallest following integer, i.e. the smallest integer not less than x.  Examples:  float var0 <- ceil(3);  // var0 equals 3.0 float var1 <- ceil(3.5);  // var1 equals 4.0 float var2 <- ceil(-4.7);  // var2 equals -4.0   See also: floor, round,    ### centroid  Possible use:    centroid (geometry) —>  point   Result: Centroid (weighted sum of the centroids of a decomposition of the area into triangles) of the operand-geometry. Can be different to the location of the geometry  Examples:  point var0 <- centroid(world);  // var0 equals the centroid of the square, for example : {50.0,50.0}.   See also: any_location_in, closest_points_with, farthest_point_to, points_at,    ### char  Possible use:    char (int) —>  string   Special cases:    converts ACSII integer value to character       string var0 <- char (34);  // var0 equals             ### circle  Possible use:    circle (float) —>  geometry   float circle point —>  geometry   circle (float , point) —>  geometry   Result: A circle geometry which radius is equal to the first operand, and the center has the location equal to the second operand. A circle geometry which radius is equal to the operand.  Comment: the center of the circle is by default the location of the current agent in which has been called this operator.  Special cases:    returns a point if the operand is lower or equal to 0.   returns a point if the operand is lower or equal to 0.   Examples:  geometry var0 <- circle(10,{80,30});  // var0 equals a geometry as a circle of radius 10, the center will be in the location {80,30}. geometry var1 <- circle(10);  // var1 equals a geometry as a circle of radius 10.   See also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,    ### clean  Possible use:    clean (geometry) —>  geometry   Result: A geometry corresponding to the cleaning of the operand (geometry, agent, point)  Comment: The cleaning corresponds to a buffer with a distance of 0.0  Examples:  geometry var0 <- clean(self);  // var0 equals returns the geometry resulting from the cleaning of the geometry of the agent applying the operator.     ### closest_points_with  Possible use:    geometry closest_points_with geometry —>  list<point>   closest_points_with (geometry , geometry) —>  list<point>   Result: A list of two closest points between the two geometries.  Examples:  list<point> var0 <- geom1 closest_points_with(geom2);  // var0 equals [pt1, pt2] with pt1 the closest point of geom1 to geom2 and pt1 the closest point of geom2 to geom1   See also: any_location_in, any_point_in, farthest_point_to, points_at,    ### closest_to  Possible use:    container<agent> closest_to geometry —>  geometry   closest_to (container<agent> , geometry) —>  geometry   Result: An agent or a geometry among the left-operand list of agents, species or meta-population (addition of species), the closest to the operand (casted as a geometry).  Comment: the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.  Examples:  geometry var0 <- [ag1, ag2, ag3] closest_to(self);  // var0 equals return the closest agent among ag1, ag2 and ag3 to the agent applying the operator. (species1 + species2) closest_to self   See also: neighbors_at, neighbors_of, inside, overlapping, agents_overlapping, agents_inside, agent_closest_to,    ### collect  Possible use:    container collect any expression —>  container   collect (container , any expression) —>  container   Result: returns a new list, in which each element is the evaluation of the right-hand operand.  Comment: collect is similar to accumulate except that accumulate always produces flat lists if the right-hand operand returns a list.In addition, collect can be applied to any container.  Special cases:    if the left-hand operand is nil, collect throws an error   Examples:  container var0 <- [1,2,4] collect (each *2);  // var0 equals [2,4,8] container var1 <- [1,2,4] collect ([2,4]);  // var1 equals [[2,4],[2,4],[2,4]] container var2 <- [1::2, 3::4, 5::6] collect (each + 2);  // var2 equals [4,6,8] container var3 <- (list(node) collect (node(each).location.x * 2);  // var3 equals the list of nodes with their x multiplied by 2   See also: accumulate,    ### column_at  Possible use:    matrix column_at int —>  list   column_at (matrix , int) —>  list   Result: returns the column at a num_col (right-hand operand)  Examples:  list var0 <- matrix([[el11,el12,el13],[el21,el22,el23],[el31,el32,el33]]) column_at 2;  // var0 equals [el31,el32,el33]   See also: row_at, rows_list,    ### columns_list  Possible use:    columns_list (matrix) —>  list<list>   Result: returns a list of the columns of the matrix, with each column as a list of elements  Examples:  list<list> var0 <- columns_list(matrix([[el11,el12,el13],[el21,el22,el23],[el31,el32,el33]]));  // var0 equals [[el11,el12,el13],[el21,el22,el23],[el31,el32,el33]]   See also: rows_list,    ### command  Possible use:    command (string) —>  string   Result: command allows GAMA to issue a system command using the system terminal or shell and to receive a string containing the outcome of the command or script executed. By default, commands are blocking the agent calling them, unless the sequence   &  is used at the end. In this case, the result of the operator is an empty string    ### cone  Possible use:    cone (point) —>  geometry   int cone int —>  geometry   cone (int , int) —>  geometry   Result: A cone geometry which min and max angles are given by the operands. A cone geometry which min and max angles are given by the operands.  Comment: the center of the cone is by default the location of the current agent in which has been called this operator.the center of the cone is by default the location of the current agent in which has been called this operator.  Special cases:    returns nil if the operand is nil.   returns nil if the operand is nil.   Examples:  geometry var0 <- cone({0, 45});  // var0 equals a geometry as a cone with min angle is 0 and max angle is 45. geometry var1 <- cone(0, 45);  // var1 equals a geometry as a cone with min angle is 0 and max angle is 45.   See also: around, circle, line, link, norm, point, polygon, polyline, rectangle, square, triangle,    ### cone3D  Possible use:    float cone3D float —>  geometry   cone3D (float , float) —>  geometry   Result: A cone geometry which base radius size is equal to the first operand, and which the height is equal to the second operand.  Comment: the center of the cone is by default the location of the current agent in which has been called this operator.  Special cases:    returns a point if the operand is lower or equal to 0.   Examples:  geometry var0 <- cone3D(10.0,5.0);  // var0 equals a geometry as a cone with a base circle of radius 10 and a height of 5.   See also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,    ### connected_components_of  Possible use:    connected_components_of (graph) —>  list<list>   Result: returns the connected components of of a graph, i.e. the list of all vertices that are in the maximally connected component together with the specified vertex.  Examples:  graph my_graph <- graph([]); list<list> var1 <- connected_components_of (my_graph);  // var1 equals the list of all the components as list   See also: alpha_index, connectivity_index, nb_cycles,    ### connectivity_index  Possible use:    connectivity_index (graph) —>  float   Result: returns a simple connectivity index. This number is estimated through the number of nodes (v) and of sub-graphs (p) : IC = (v - p) /(v - 1).  Examples:  graph graphEpidemio <- graph([]); float var1 <- connectivity_index(graphEpidemio);  // var1 equals the connectivity index of the graph   See also: alpha_index, beta_index, gamma_index, nb_cycles,    ### container  Possible use:    container (any) —>  container   Result: Casts the operand into the type container    ### contains  Possible use:    container<KeyType,ValueType> contains unknown —>  bool   contains (container<KeyType,ValueType> , unknown) —>  bool   string contains string —>  bool   contains (string , string) —>  bool   Result: true, if the container contains the right operand, false otherwise  Comment: the contains operator behavior depends on the nature of the operand  Special cases:    if it is a map, contains returns true if the operand is a key of the map   if it is a file, contains returns true it the operand is contained in the file content   if it is a population, contains returns true if the operand is an agent of the population, false otherwise   if it is a graph, contains returns true if the operand is a node or an edge of the graph, false otherwise   if both operands are strings, returns true if the right-hand operand contains the right-hand pattern;   if it is a list or a matrix, contains returns true if the list or matrix contains the right operand       bool var0 <- [1, 2, 3] contains 2;  // var0 equals true bool var1 <- [{1,2}, {3,4}, {5,6}] contains {3,4};  // var1 equals true       Examples:  bool var2 <-  abcded  contains  bc ;  // var2 equals true   See also: contains_all, contains_any,    ### contains_all  Possible use:    container contains_all container —>  bool   contains_all (container , container) —>  bool   string contains_all list —>  bool   contains_all (string , list) —>  bool   Result: true if the left operand contains all the elements of the right operand, false otherwise  Comment: the definition of contains depends on the container  Special cases:    if the right operand is nil or empty, contains_all returns true   if the left-operand is a string, test whether the string contains all the element of the list;       bool var4 <-  abcabcabc  contains_all [ ca , xy ];  // var4 equals false       Examples:  bool var0 <- [1,2,3,4,5,6] contains_all [2,4];  // var0 equals true  bool var1 <- [1,2,3,4,5,6] contains_all [2,8];  // var1 equals false bool var2 <- [1::2, 3::4, 5::6] contains_all [1,3];  // var2 equals false  bool var3 <- [1::2, 3::4, 5::6] contains_all [2,4];  // var3 equals true   See also: contains, contains_any,    ### contains_any  Possible use:    container contains_any container —>  bool   contains_any (container , container) —>  bool   string contains_any list —>  bool   contains_any (string , list) —>  bool   Result: true if the left operand contains one of the elements of the right operand, false otherwise  Comment: the definition of contains depends on the container  Special cases:    if the right operand is nil or empty, contains_any returns false   Examples:  bool var0 <- [1,2,3,4,5,6] contains_any [2,4];  // var0 equals true  bool var1 <- [1,2,3,4,5,6] contains_any [2,8];  // var1 equals true bool var2 <- [1::2, 3::4, 5::6] contains_any [1,3];  // var2 equals false bool var3 <- [1::2, 3::4, 5::6] contains_any [2,4];  // var3 equals true bool var4 <- abcabcabc contains_any [ca,xy];  // var4 equals true   See also: contains, contains_all,    ### contains_edge  Possible use:    graph contains_edge unknown —>  bool   contains_edge (graph , unknown) —>  bool   graph contains_edge pair —>  bool   contains_edge (graph , pair) —>  bool   Result: returns true if the graph(left-hand operand) contains the given edge (righ-hand operand), false otherwise  Special cases:    if the left-hand operand is nil, returns false   if the right-hand operand is a pair, returns true if it exists an edge between the two elements of the pair in the graph       bool var2 <- graphEpidemio contains_edge (node(0)::node(3));  // var2 equals true       Examples:  graph graphFromMap <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); bool var1 <- graphFromMap contains_edge link({1,5}::{12,45});  // var1 equals true   See also: contains_vertex,    ### contains_vertex  Possible use:    graph contains_vertex unknown —>  bool   contains_vertex (graph , unknown) —>  bool   Result: returns true if the graph(left-hand operand) contains the given vertex (righ-hand operand), false otherwise  Special cases:    if the left-hand operand is nil, returns false   Examples:  graph graphFromMap<-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); bool var1 <- graphFromMap contains_vertex {1,5};  // var1 equals true   See also: contains_edge,    ### conversation  Possible use:    conversation (unknown) —>  conversation     ### convex_hull  Possible use:    convex_hull (geometry) —>  geometry   Result: A geometry corresponding to the convex hull of the operand.  Examples:  geometry var0 <- convex_hull(self);  // var0 equals the convex hull of the geometry of the agent applying the operator     ### copy  Possible use:    copy (unknown) —>  unknown   Result: returns a copy of the operand.    ### copy_between  Possible use:    copy_between (string, int, int) —>  string   copy_between (container, int, int) —>  container   Result: Returns a copy of the first operand between the indexes determined by the second (inclusive) and third operands (exclusive)  Special cases:    If the first operand is empty, returns an empty object of the same type   If the second operand is greater than or equal to the third operand, return an empty object of the same type   If the first operand is nil, raises an error   Examples:  string var0 <- copy_between(abcabcabc, 2,6);  // var0 equals cabc container var1 <-  copy_between ([4, 1, 6, 9 ,7], 1, 3);  // var1 equals [1, 6]     ### corR  Possible use:    container corR container —>  unknown   corR (container , container) —>  unknown   Result: returns the Pearson correlation coefficient of two given vectors (right-hand operands) in given variable  (left-hand operand).  Special cases:    if the lengths of two vectors in the right-hand aren t equal, returns 0   Examples:  list X <- [1, 2, 3]; list Y <- [1, 2, 4]; unknown var2 <- corR(X, Y);  // var2 equals 0.981980506061966     ### cos  Possible use:    cos (int) —>  float   cos (float) —>  float   Result: Returns the value (in [-1,1]) of the cosinus of the operand (in decimal degrees).  The argument is casted to an int before being evaluated.  Special cases:    Operand values out of the range [0-359] are normalized.   Examples:  float var0 <- cos (0);  // var0 equals 1.0 float var1 <- cos(360);  // var1 equals 1.0 float var2 <- cos(-720);  // var2 equals 1.0   See also: sin, tan,    ### cos_rad  Possible use:    cos_rad (float) —>  float   Result: Returns the value (in [-1,1]) of the cosinus of the operand (in decimal degrees).  The argument is casted to an int before being evaluated.  Special cases:    Operand values out of the range [0-359] are normalized.   See also: sin, tan,    ### count  Possible use:    container count any expression —>  int   count (container , any expression) —>  int   Result: returns an int, equal to the number of elements of the left-hand operand that make the right-hand operand evaluate to true.  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.  Special cases:    if the left-hand operand is nil, count throws an error   Examples:  int var0 <- [1,2,3,4,5,6,7,8] count (each > 3);  // var0 equals 5 // Number of nodes of graph g2 without any out edge graph g2 <- graph([]); int var3 <- g2 count (length(g2 out_edges_of each) = 0  ) ;  // var3 equals the total number of out edges // Number of agents node with x > 32 int n <- (list(node) count (round(node(each).location.x) > 32); int var6 <- [1::2, 3::4, 5::6] count (each > 4);  // var6 equals 1   See also: group_by,    ### covers  Possible use:    geometry covers geometry —>  bool   covers (geometry , geometry) —>  bool   Result: A boolean, equal to true if the left-geometry (or agent/point) covers the right-geometry (or agent/point).  Special cases:    if one of the operand is null, returns false.   Examples:  bool var0 <- square(5) covers square(2);  // var0 equals true   See also: disjoint_from, crosses, overlaps, partially_overlaps, touches,    ### cross  Possible use:    cross (float) —>  geometry   float cross float —>  geometry   cross (float , float) —>  geometry   Result: A cross, which radius is equal to the first operand A cross, which radius is equal to the first operand and the width of the lines for the second  Examples:  geometry var0 <- cross(10);  // var0 equals a geometry as a cross of radius 10 geometry var1 <- cross(10,2);  // var1 equals a geometry as a cross of radius 10, and with a width of 2 for the lines    See also: around, cone, line, link, norm, point, polygon, polyline, super_ellipse, rectangle, square, circle, ellipse, triangle,    ### crosses  Possible use:    geometry crosses geometry —>  bool   crosses (geometry , geometry) —>  bool   Result: A boolean, equal to true if the left-geometry (or agent/point) crosses the right-geometry (or agent/point).  Special cases:    if one of the operand is null, returns false.   if one operand is a point, returns false.   Examples:  bool var0 <- polyline([{10,10},{20,20}]) crosses polyline([{10,20},{20,10}]);  // var0 equals true bool var1 <- polyline([{10,10},{20,20}]) crosses {15,15};  // var1 equals true bool var2 <- polyline([{0,0},{25,25}]) crosses polygon([{10,10},{10,20},{20,20},{20,10}]);  // var2 equals true   See also: disjoint_from, intersects, overlaps, partially_overlaps, touches,    ### crs  Possible use:    crs (file) —>  string   Result: the Coordinate Reference System (CRS) of the GIS file  Examples:  string var0 <- crs(my_shapefile);  // var0 equals the crs of the shapefile     ### CRS_transform  Possible use:    CRS_transform (geometry) —>  geometry   geometry CRS_transform string —>  geometry   CRS_transform (geometry , string) —>  geometry   Special cases:    returns the geometry corresponding to the transformation of the given geometry by the left operand CRS (Coordinate Reference System)       geometry var0 <- shape CRS_transform( EPSG:4326 );  // var0 equals a geometry corresponding to the agent geometry transformed into the EPSG:4326 CRS          returns the geometry corresponding to the transformation of the given geometry by the current CRS (Coordinate Reference System), the one corresponding to the world s agent one       geometry var1 <- CRS_transform(shape);  // var1 equals a geometry corresponding to the agent geometry transformed into the current CRS         ### csv_file  Possible use:    csv_file (string) —>  file   Result: Constructs a file of type csv. Allowed extensions are limited to csv, tsv    ### cube  Possible use:    cube (float) —>  geometry   Result: A cube geometry which side size is equal to the operand.  Comment: the center of the cube is by default the location of the current agent in which has been called this operator.  Special cases:    returns nil if the operand is nil.   Examples:  geometry var0 <- cube(10);  // var0 equals a geometry as a square of side size 10.   See also: around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, triangle,    ### curve  Possible use:    curve (point, point, point) —>  geometry   curve (point, point, point, int) —>  geometry   curve (point, point, point, point) —>  geometry   curve (point, point, point, point, int) —>  geometry   Result: A quadratic Bezier curve geometry built from the three given points composed of a given numnber of points. A quadratic Bezier curve geometry built from the three given points composed of 10 points. A cubic Bezier curve geometry built from the four given points composed of a given number of points. A cubic Bezier curve geometry built from the four given points composed of 10 points.  Special cases:    if the operand is nil, returns nil   if the last operand (number of points) is inferior to 2, returns nil   if the operand is nil, returns nil   if the operand is nil, returns nil   if the last operand (number of points) is inferior to 2, returns nil   if the operand is nil, returns nil   Examples:  geometry var0 <- curve({0,0}, {0,10}, {10,10}, 20);  // var0 equals a quadratic Bezier curve geometry composed of 20 points from p0 to p2. geometry var1 <- curve({0,0}, {0,10}, {10,10});  // var1 equals a quadratic Bezier curve geometry composed of 10 points from p0 to p2. geometry var2 <- curve({0,0}, {0,10}, {10,10});  // var2 equals a cubic Bezier curve geometry composed of 10 points from p0 to p3. geometry var3 <- curve({0,0}, {0,10}, {10,10});  // var3 equals a cubic Bezier curve geometry composed of 10 points from p0 to p3.   See also: around, circle, cone, link, norm, point, polygone, rectangle, square, triangle, line,    ### cylinder  Possible use:    float cylinder float —>  geometry   cylinder (float , float) —>  geometry   Result: A cylinder geometry which radius is equal to the operand.  Comment: the center of the cylinder is by default the location of the current agent in which has been called this operator.  Special cases:    returns a point if the operand is lower or equal to 0.   Examples:  geometry var0 <- cylinder(10,10);  // var0 equals a geometry as a circle of radius 10.   See also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,    ### IDW  Possible use:    IDW (container<agent>, map<point,float>, int) —>  map<agent,float>   Result: Inverse Distance Weighting (IDW) is a type of deterministic method for multivariate interpolation with a known scattered set of points. The assigned values to each geometry are calculated with a weighted average of the values available at the known points. See: http://en.wikipedia.org/wiki/Inverse_distance_weighting Usage: IDW (list of geometries, map of points (key: point, value: value), power parameter)  Examples:  map<agent,float> var0 <- IDW([ag1, ag2, ag3, ag4, ag5],[{10,10}::25.0, {10,80}::10.0, {100,10}::15.0], 2);  // var0 equals for example, can return [ag1::12.0, ag2::23.0,ag3::12.0,ag4::14.0,ag5::17.0]     ### R_correlation Same signification as corR    ### R_file  Possible use:    R_file (string) —>  file   Result: Constructs a file of type R. Allowed extensions are limited to r    ### R_mean Same signification as meanR    ### TGauss Same signification as truncated_gauss    ### URL_file  Possible use:    URL_file (string) —>  file   Result: Constructs a file of type URL. Allowed extensions are limited to url ","url":"wiki/OperatorsAC.md"},{"id":"wiki/OperatorsDM.md","title":" Operators (D to M)","content":"Operators (D to M)    This file is automatically generated from java files. Do Not Edit It.    Definition  Operators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function.  Most of them use a classical prefixed functional syntax (i.e. operator_name(operand1, operand2, operand3), see below), with the exception of arithmetic (e.g. +, /), logical (and, or), comparison (e.g. >, <), access (., [..]) and pair (::) operators, which require an infixed notation (i.e. operand1 operator_symbol operand1).  The ternary functional if-else operator, ? :, uses a special infixed syntax composed with two symbols (e.g. operand1 ? operand2 : operand3). Two unary operators (- and !) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g.   - 10, ! (operand1 or operand2) ).  Finally, special constructor operators ({...} for constructing points, [...] for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. {1,2,3}, [operand1, operand2, ..., operandn] or [key1::value1, key2::value2... keyn::valuen]).  With the exception of these special cases above, the following rules apply to the syntax of operators: * if they only have one operand, the functional prefixed syntax is mandatory (e.g. operator_name(operand1)) * if they have two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2)) or the infixed syntax (e.g. operand1 operator_name operand2) can be used. * if they have more than two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2, ..., operand)) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. operand1 operator_name(operand2, ..., operand)) can be used.  All of these alternative syntaxes are completely equivalent.  Operators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.    Priority between operators  The priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.  GAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely: * the constructor operators, like ::, used to compose pairs of operands, have the lowest priority of all operators (e.g. a > b :: b > c will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, [a > 10, b > 5] will return a list of boolean values. * it is followed by the ?: operator, the functional if-else (e.g.   a > b ? a + 10 : a - 10 will return the result of the if-else). * next are the logical operators, and and or (e.g. a > b or b > c will return the value of the test) * next are the comparison operators (i.e. >, <, <=, >=, =, !=) * next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators) * next the unary operators - and ! * next the access operators . and [] (e.g. {1,2,3}.x > 20 + {4,5,6}.y  will return the result of the comparison between the x and y ordinates of the two points) * and finally the functional operators, which have the highest priority of all.    Using actions as operators  Actions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.  For instance, if the following species is defined:   species spec1 {  int min(int x, int y) {       return x > y ? x : y;  } }   Any agent instance of spec1 can use min as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:   global {  init {       create spec1;       spec1 my_agent <- spec1[0];       int the_min <- my_agent min(10,20); // or min(my_agent, 10, 20);  } }   If the action doesn t have any operands, the syntax to use is my_agent the_action(). Finally, if it does not return a value, it might still be used but is considering as returning a value of type unknown (e.g. unknown result <- my_agent the_action(op1, op2);).  Note that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).    Table of Contents    Operators by categories    3D box, cone3D, cube, cylinder, dem, hexagon, pyramid, rgb_to_xyz, set_z, sphere, teapot,    Arithmetic operators -, /, [^](OperatorsAC#^), [](OperatorsAC#), +, abs, acos, asin, atan, atan2, ceil, cos, cos_rad, div, even, exp, fact, floor, hypot, is_finite, is_number, ln, log, mod, round, signum, sin, sin_rad, sqrt, tan, tan_rad, tanh, with_precision,    BDI and, eval_when, get_about, get_agent, get_agent_cause, get_decay, get_dominance, get_familiarity, get_intensity, get_lifetime, get_liking, get_praiseworthiness, get_priority, get_solidarity, get_super_intention, new_emotion, new_predicate, new_social_link, or, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_liking, set_solidarity, set_truth, with_lifetime, with_praiseworthiness, with_priority, with_values,    Casting operators as, as_int, as_matrix, font, is, is_skill, list_with, matrix_with, species, to_gaml, topology,    Color-related operators -, /, [](OperatorsAC#), +, blend, brewer_colors, brewer_palettes, grayscale, hsb, mean, median, rgb, rnd_color, sum,    Comparison operators !=, <, <=, =, >, >=, between,    Containers-related operators -, ::, +, accumulate, among, at, collect, contains, contains_all, contains_any, count, distinct, empty, every, first, first_with, get, group_by, in, index_by, inter, interleave, internal_at, internal_integrated_value, last, last_with, length, max, max_of, mean, mean_of, median, min, min_of, mul, one_of, product_of, range, reverse, shuffle, sort_by, sum, sum_of, union, variance_of, where, with_max_of, with_min_of,    Date-related operators -, !=, +, <, <=, =, >, >=, after, before, between, every, milliseconds_between, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_weeks, minus_years, months_between, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_weeks, plus_years, since, to, until, years_between,    Dates    Driving operators as_driving_graph,    edge edge_between,    EDP-related operators diff, diff2, internal_zero_order_equation,    Files-related operators crs, file, file_exists, folder, get, new_folder, osm_file, read, writable,    FIPA-related operators conversation, message,    Graphs-related operators add_edge, add_node, adjacency, agent_from_geometry, all_pairs_shortest_path, alpha_index, as_distance_graph, as_edge_graph, as_intersection_graph, as_path, beta_index, betweenness_centrality, biggest_cliques_of, connected_components_of, connectivity_index, contains_edge, contains_vertex, degree_of, directed, edge, edge_between, edge_betweenness, edges, gamma_index, generate_barabasi_albert, generate_complete_graph, generate_watts_strogatz, grid_cells_to_graph, in_degree_of, in_edges_of, layout, load_graph_from_file, load_shortest_paths, maximal_cliques_of, nb_cycles, neighbors_of, node, nodes, out_degree_of, out_edges_of, path_between, paths_between, predecessors_of, remove_node_from, rewire_n, source_of, spatial_graph, successors_of, sum, target_of, undirected, use_cache, weight_of, with_optimizer_type, with_weights,    Grid-related operators as_4_grid, as_grid, as_hexagonal_grid, grid_at, path_between,    Iterator operators accumulate, as_map, collect, count, distribution_of, distribution_of, distribution_of, distribution2d_of, distribution2d_of, distribution2d_of, first_with, frequency_of, group_by, index_by, last_with, max_of, mean_of, min_of, product_of, sort_by, sum_of, variance_of, where, with_max_of, with_min_of,    List-related operators copy_between, index_of, last_index_of,    Logical operators :, !, ?, and, or,    Map comparaison operators fuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,    Map-related operators as_map, index_of, last_index_of,    Material material,    Matrix-related operators -, /, ., [](OperatorsAC#), +, append_horizontally, append_vertically, column_at, columns_list, determinant, eigenvalues, index_of, inverse, last_index_of, row_at, rows_list, shuffle, trace, transpose,    multicriteria operators electre_DM, evidence_theory_DM, promethee_DM, weighted_means_DM,    Path-related operators agent_from_geometry, all_pairs_shortest_path, as_path, load_shortest_paths, path_between, path_to, paths_between, use_cache,    Points-related operators -, /, [](OperatorsAC#), +, <, <=, >, >=, add_point, angle_between, any_location_in, centroid, closest_points_with, farthest_point_to, grid_at, norm, point, points_along, points_at, points_on,    Random operators binomial, flip, gauss, poisson, rnd, rnd_choice, sample, shuffle, skew_gauss, truncated_gauss,    ReverseOperators    Shape arc, box, circle, cone, cone3D, cross, cube, curve, cylinder, ellipse, envelope, geometry_collection, hexagon, line, link, plan, polygon, polyhedron, pyramid, rectangle, sphere, square, squircle, teapot, triangle,    Spatial operators -, [](OperatorsAC#), +, add_point, agent_closest_to, agent_farthest_to, agents_at_distance, agents_inside, agents_overlapping, angle_between, any_location_in, arc, around, as_4_grid, as_grid, as_hexagonal_grid, at_distance, at_location, box, centroid, circle, clean, closest_points_with, closest_to, cone, cone3D, convex_hull, covers, cross, crosses, crs, CRS_transform, cube, curve, cylinder, dem, direction_between, disjoint_from, distance_between, distance_to, ellipse, envelope, farthest_point_to, farthest_to, geometry_collection, gini, hexagon, hierarchical_clustering, IDW, inside, inter, intersects, line, link, masked_by, moran, neighbors_at, neighbors_of, overlapping, overlaps, partially_overlaps, path_between, path_to, plan, points_along, points_at, points_on, polygon, polyhedron, pyramid, rectangle, rgb_to_xyz, rotated_by, round, scaled_to, set_z, simple_clustering_by_distance, simplification, skeletonize, smooth, sphere, split_at, split_geometry, split_lines, square, squircle, teapot, to_GAMA_CRS, to_rectangles, to_squares, touches, towards, transformed_by, translated_by, triangle, triangulate, union, using, voronoi, with_precision, without_holes,    Spatial properties operators covers, crosses, intersects, partially_overlaps, touches,    Spatial queries operators agent_closest_to, agent_farthest_to, agents_at_distance, agents_inside, agents_overlapping, at_distance, closest_to, farthest_to, inside, neighbors_at, neighbors_of, overlapping,    Spatial relations operators direction_between, distance_between, distance_to, path_between, path_to, towards,    Spatial statistical operators hierarchical_clustering, simple_clustering_by_distance,    Spatial transformations operators -, [](OperatorsAC#), +, as_4_grid, as_grid, as_hexagonal_grid, at_location, clean, convex_hull, CRS_transform, rotated_by, scaled_to, simplification, skeletonize, smooth, split_geometry, split_lines, to_GAMA_CRS, to_rectangles, to_squares, transformed_by, translated_by, triangulate, voronoi, without_holes,    Species-related operators index_of, last_index_of, of_generic_species, of_species,    Statistical operators build, corR, dbscan, distribution_of, distribution2d_of, frequency_of, gamma_rnd, geometric_mean, gini, harmonic_mean, hierarchical_clustering, kmeans, kurtosis, max, mean, mean_deviation, meanR, median, min, moran, mul, predict, simple_clustering_by_distance, skewness, standard_deviation, sum, variance,    Strings-related operators +, <, <=, >, >=, at, char, contains, contains_all, contains_any, copy_between, date, empty, first, in, indented_by, index_of, is_number, last, last_index_of, length, lower_case, replace, replace_regex, reverse, sample, shuffle, split_with, string, upper_case,    System ., command, copy, dead, eval_gaml, every, user_input,    Time-related operators date, string,    Types-related operators    User control operators user_input,    Operators    ### date  Possible use:    string date string —>  date   date (string , string) —>  date   Result: converts a string to a date following a custom pattern. The pattern can use  %Y %M %N %D %E %h %m %s %z  for outputting years, months, name of month, days, name of days, hours, minutes, seconds and the time-zone. A null or empty pattern will parse the date using one of the ISO date & time formats (similar to date( … ) in that case). The pattern can also follow the pattern definition found here, which gives much more control over what will be parsed: https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns. Different patterns are available by default as constant: #iso_local, #iso_simple, #iso_offset, #iso_zoned and #custom, which can be changed in the preferences  Examples:  date(1999-12-30,  yyyy-MM-dd )     ### dbscan  Possible use:    dbscan (list, float, int) —>  list<list>   Result: returns the list of clusters (list of instance indices) computed with the dbscan (density-based spatial clustering of applications with noise) algorithm from the first operand data according to the maximum radius of the neighborhood to be considered (eps) and the minimum number of points needed for a cluster (minPts). Usage: dbscan(data,eps,minPoints)  Special cases:    if the lengths of two vectors in the right-hand aren t equal, returns 0   Examples:  dbscan ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],10,2)     ### dead  Possible use:    dead (agent) —>  bool   Result: true if the agent is dead (or null), false otherwise.  Examples:  bool var0 <- dead(agent_A);  // var0 equals true or false     ### degree_of  Possible use:    graph degree_of unknown —>  int   degree_of (graph , unknown) —>  int   Result: returns the degree (in+out) of a vertex (right-hand operand) in the graph given as left-hand operand.  Examples:  int var1 <- graphFromMap degree_of (node(3));  // var1 equals 3   See also: in_degree_of, out_degree_of,    ### dem  Possible use:    dem (file) —>  geometry   file dem file —>  geometry   dem (file , file) —>  geometry   file dem float —>  geometry   dem (file , float) —>  geometry   dem (file, file, float) —>  geometry   Result: A polygon that is equivalent to the surface of the texture  Examples:  geometry var0 <- dem(dem,texture,z_factor);  // var0 equals a geometry as a rectangle of width and height equal to the texture. geometry var1 <- dem(dem,texture);  // var1 equals a geometry as a rectangle of weight and height equal to the texture. geometry var2 <- dem(dem,z_factor);  // var2 equals a geometry as a rectangle of weight and height equal to the texture. geometry var3 <- dem(dem);  // var3 equals returns a geometry as a rectangle of width and height equal to the texture.     ### det Same signification as determinant    ### determinant  Possible use:    determinant (matrix) —>  float   Result: The determinant of the given matrix  Examples:  float var0 <- determinant(matrix([[1,2],[3,4]]));  // var0 equals -2     ### diff  Possible use:    float diff float —>  float   diff (float , float) —>  float     ### diff2  Possible use:    float diff2 float —>  float   diff2 (float , float) —>  float     ### directed  Possible use:    directed (graph) —>  graph   Result: the operand graph becomes a directed graph.  Comment: the operator alters the operand graph, it does not create a new one.  See also: undirected,    ### direction_between  Possible use:    topology direction_between container<geometry> —>  int   direction_between (topology , container<geometry>) —>  int   Result: A direction (in degree) between a list of two geometries (geometries, agents, points) considering a topology.  Examples:  int var0 <- my_topology direction_between [ag1, ag2];  // var0 equals the direction between ag1 and ag2 considering the topology my_topology   See also: towards, direction_to, distance_to, distance_between, path_between, path_to,    ### direction_to Same signification as towards    ### disjoint_from  Possible use:    geometry disjoint_from geometry —>  bool   disjoint_from (geometry , geometry) —>  bool   Result: A boolean, equal to true if the left-geometry (or agent/point) is disjoints from the right-geometry (or agent/point).  Special cases:    if one of the operand is null, returns true.   if one operand is a point, returns false if the point is included in the geometry.   Examples:  bool var0 <- polyline([{10,10},{20,20}]) disjoint_from polyline([{15,15},{25,25}]);  // var0 equals false bool var1 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{15,15},{15,25},{25,25},{25,15}]);  // var1 equals false bool var2 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from {15,15};  // var2 equals false bool var3 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from {25,25};  // var3 equals true bool var4 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{35,35},{35,45},{45,45},{45,35}]);  // var4 equals true   See also: intersects, crosses, overlaps, partially_overlaps, touches,    ### distance_between  Possible use:    topology distance_between container<geometry> —>  float   distance_between (topology , container<geometry>) —>  float   Result: A distance between a list of geometries (geometries, agents, points) considering a topology.  Examples:  float var0 <- my_topology distance_between [ag1, ag2, ag3];  // var0 equals the distance between ag1, ag2 and ag3 considering the topology my_topology   See also: towards, direction_to, distance_to, direction_between, path_between, path_to,    ### distance_to  Possible use:    geometry distance_to geometry —>  float   distance_to (geometry , geometry) —>  float   point distance_to point —>  float   distance_to (point , point) —>  float   Result: A distance between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.  Examples:  float var0 <- ag1 distance_to ag2;  // var0 equals the distance between ag1 and ag2 considering the topology of the agent applying the operator   See also: towards, direction_to, distance_between, direction_between, path_between, path_to,    ### distinct  Possible use:    distinct (container) —>  container   Result: produces a set from the elements of the operand (i.e. a list without duplicated elements)  Special cases:    if the operand is nil, remove_duplicates returns nil   if the operand is a graph, remove_duplicates returns the set of nodes   if the operand is a matrix, remove_duplicates returns a matrix without duplicated row   if the operand is a map, remove_duplicates returns the set of values without duplicate       container var1 <- remove_duplicates([1::3,2::4,3::3,5::7]);  // var1 equals [3,4,7]       Examples:  container var0 <- remove_duplicates([3,2,5,1,2,3,5,5,5]);  // var0 equals [3,2,5,1]     ### distribution_of  Possible use:    distribution_of (container) —>  map   container distribution_of int —>  map   distribution_of (container , int) —>  map   distribution_of (container, int, float, float) —>  map   Result: Discretize a list of values into n bins (computes the bins from a numerical variable into n (default 10) bins. Returns a distribution map with the values (values key), the interval legends (legend key), the distribution parameters (params keys, for cumulative charts). Parameters can be (list), (list, nbbins) or (list,nbbins,valmin,valmax)  Examples:  map var0 <- distribution_of([1,1,2,12.5]);  // var0 equals map([ values ::[2,1,0,0,0,0,1,0,0,0], legend ::[ [0.0:2.0] , [2.0:4.0] , [4.0:6.0] , [6.0:8.0] , [8.0:10.0] , [10.0:12.0] , [12.0:14.0] , [14.0:16.0] , [16.0:18.0] , [18.0:20.0] ], parlist ::[1,0]]) map var1 <- distribution_of([1,1,2,12.5],10);  // var1 equals map([ values ::[2,1,0,0,0,0,1,0,0,0], legend ::[ [0.0:2.0] , [2.0:4.0] , [4.0:6.0] , [6.0:8.0] , [8.0:10.0] , [10.0:12.0] , [12.0:14.0] , [14.0:16.0] , [16.0:18.0] , [18.0:20.0] ], parlist ::[1,0]]) map var2 <- distribution_of([1,1,2,12.5]);  // var2 equals map([ values ::[2,1,0,0,0,0,1,0,0,0], legend ::[ [0.0:2.0] , [2.0:4.0] , [4.0:6.0] , [6.0:8.0] , [8.0:10.0] , [10.0:12.0] , [12.0:14.0] , [14.0:16.0] , [16.0:18.0] , [18.0:20.0] ], parlist ::[1,0]])   See also: as_map,    ### distribution2d_of  Possible use:    container distribution2d_of container —>  map   distribution2d_of (container , container) —>  map   distribution2d_of (container, container, int, int) —>  map   distribution2d_of (container, container, int, float, float, int, float, float) —>  map   Result: Discretize two lists of values into n bins (computes the bins from a numerical variable into n (default 10) bins. Returns a distribution map with the values (values key), the interval legends (legend key), the distribution parameters (params keys, for cumulative charts). Parameters can be (list), (list, nbbins) or (list,nbbins,valmin,valmax)  Examples:  map var0 <- distribution_of([1,1,2,12.5],10);  // var0 equals map([ values ::[2,1,0,0,0,0,1,0,0,0], legend ::[ [0.0:2.0] , [2.0:4.0] , [4.0:6.0] , [6.0:8.0] , [8.0:10.0] , [10.0:12.0] , [12.0:14.0] , [14.0:16.0] , [16.0:18.0] , [18.0:20.0] ], parlist ::[1,0]]) map var1 <- distribution2d_of([1,1,2,12.5]);  // var1 equals map([ values ::[2,1,0,0,0,0,1,0,0,0], legend ::[ [0.0:2.0] , [2.0:4.0] , [4.0:6.0] , [6.0:8.0] , [8.0:10.0] , [10.0:12.0] , [12.0:14.0] , [14.0:16.0] , [16.0:18.0] , [18.0:20.0] ], parlist ::[1,0]]) map var2 <- distribution_of([1,1,2,12.5],10);  // var2 equals map([ values ::[2,1,0,0,0,0,1,0,0,0], legend ::[ [0.0:2.0] , [2.0:4.0] , [4.0:6.0] , [6.0:8.0] , [8.0:10.0] , [10.0:12.0] , [12.0:14.0] , [14.0:16.0] , [16.0:18.0] , [18.0:20.0] ], parlist ::[1,0]])   See also: as_map,    ### div  Possible use:    float div float —>  int   div (float , float) —>  int   int div int —>  int   div (int , int) —>  int   float div int —>  int   div (float , int) —>  int   int div float —>  int   div (int , float) —>  int   Result: Returns the truncation of the division of the left-hand operand by the right-hand operand.  Special cases:    if the right-hand operand is equal to zero, raises an exception.   if the right-hand operand is equal to zero, raises an exception.   if the right-hand operand is equal to zero, raises an exception.   Examples:  int var0 <- 40.1 div 4.5;  // var0 equals 8 int var1 <- 40 div 3;  // var1 equals 13 int var2 <- 40.5 div 3;  // var2 equals 13 int var3 <- 40 div 4.1;  // var3 equals 9   See also: mod,    ### dxf_file  Possible use:    dxf_file (string) —>  file   Result: Constructs a file of type dxf. Allowed extensions are limited to dxf    ### edge  Possible use:    edge (pair) —>  unknown   edge (unknown) —>  unknown   unknown edge unknown —>  unknown   edge (unknown , unknown) —>  unknown   pair edge float —>  unknown   edge (pair , float) —>  unknown   unknown edge float —>  unknown   edge (unknown , float) —>  unknown   edge (unknown, unknown, unknown) —>  unknown   edge (unknown, unknown, float) —>  unknown   edge (pair, unknown, float) —>  unknown   edge (unknown, unknown, unknown, float) —>  unknown     ### edge_between  Possible use:    graph edge_between pair —>  unknown   edge_between (graph , pair) —>  unknown   Result: returns the edge linking two nodes  Examples:  unknown var0 <- graphFromMap edge_between node1::node2;  // var0 equals edge1   See also: out_edges_of, in_edges_of,    ### edge_betweenness  Possible use:    edge_betweenness (graph) —>  map   Result: returns a map containing for each edge (key), its betweenness centrality (value): number of shortest paths passing through each edge  Examples:  graph graphEpidemio <- graph([]); map var1 <- edge_betweenness(graphEpidemio);  // var1 equals the edge betweenness index of the graph     ### edges  Possible use:    edges (container) —>  container     ### eigenvalues  Possible use:    eigenvalues (matrix) —>  list<float>   Result: The eigen values (matrix) of the given matrix  Examples:  list<float> var0 <- eigenvalues(matrix([[5,-3],[6,-4]]));  // var0 equals [2.0000000000000004,-0.9999999999999998]     ### electre_DM  Possible use:    electre_DM (list<list>, list<map<string,object>>, float) —>  int   Result: The index of the best candidate according to a method based on the ELECTRE methods. The principle of the ELECTRE methods is to compare the possible candidates by pair. These methods analyses the possible outranking relation existing between two candidates. An candidate outranks another if this one is at least as good as the other one. The ELECTRE methods are based on two concepts: the concordance and the discordance. The concordance characterizes the fact that, for an outranking relation to be validated, a sufficient majority of criteria should be in favor of this assertion. The discordance characterizes the fact that, for an outranking relation to be validated, none of the criteria in the minority should oppose too strongly this assertion. These two conditions must be true for validating the outranking assertion. More information about the ELECTRE methods can be found in [http://www.springerlink.com/content/g367r44322876223/ Figueira,  J., Mousseau, V., Roy, B.: ELECTRE Methods. In: Figueira, J., Greco, S., and Ehrgott, M., (Eds.), Multiple Criteria Decision Analysis: State of the Art Surveys, Springer, New York, 133–162 (2005)]. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains fives elements: a name, a weight, a preference value (p), an indifference value (q) and a veto value (v). The preference value represents the threshold from which the difference between two criterion values allows to prefer one vector of values over another. The indifference value represents the threshold from which the difference between two criterion values is considered significant. The veto value represents the threshold from which the difference between two criterion values disqualifies the candidate that obtained the smaller value; the last operand is the fuzzy cut.  Special cases:    returns -1 is the list of candidates is nil or empty   Examples:  int var0 <- electre_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[name::utility, weight :: 2.0,p::0.5, q::0.0, s::1.0, maximize :: true],[name::price, weight :: 1.0,p::0.5, q::0.0, s::1.0, maximize :: false]]);  // var0 equals 0   See also: weighted_means_DM, promethee_DM, evidence_theory_DM,    ### ellipse  Possible use:    float ellipse float —>  geometry   ellipse (float , float) —>  geometry   Result: An ellipse geometry which x-radius is equal to the first operand and y-radius is equal to the second operand  Comment: the center of the ellipse is by default the location of the current agent in which has been called this operator.  Special cases:    returns a point if both operands are lower or equal to 0, a line if only one is.   Examples:  geometry var0 <- ellipse(10, 10);  // var0 equals a geometry as an ellipse of width 10 and height 10.   See also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, circle, squircle, triangle,    ### emotion  Possible use:    emotion (any) —>  emotion   Result: Casts the operand into the type emotion    ### empty  Possible use:    empty (container<KeyType,ValueType>) —>  bool   empty (string) —>  bool   Result: true if the operand is empty, false otherwise.  Comment: the empty operator behavior depends on the nature of the operand  Special cases:    if it is a map, empty returns true if the map contains no key-value mappings, and false otherwise   if it is a file, empty returns true if the content of the file (that is also a container) is empty, and false otherwise   if it is a population, empty returns true if there is no agent in the population, and false otherwise   if it is a graph, empty returns true if it contains no vertex and no edge, and false otherwise   if it is a matrix of int, float or object, it will return true if all elements are respectively 0, 0.0 or null, and false otherwise   if it is a matrix of geometry, it will return true if the matrix contains no cell, and false otherwise   if it is a list, empty returns true if there is no element in the list, and false otherwise       bool var0 <- empty([]);  // var0 equals true          if it is a string, empty returns true if the string does not contain any character, and false otherwise       bool var1 <- empty ( abced );  // var1 equals false         ### enlarged_by Same signification as +    ### envelope  Possible use:    envelope (unknown) —>  geometry   Result: A 3D geometry that represents the box that surrounds the geometries or the surface described by the arguments. More general than geometry(arguments).envelope, as it allows to pass int, double, point, image files, shape files, asc files, or any list combining these arguments, in which case the envelope will be correctly expanded. If an envelope cannot be determined from the arguments, a default one of dimensions (0,100, 0, 100, 0, 100) is returned    ### eval_gaml  Possible use:    eval_gaml (string) —>  unknown   Result: evaluates the given GAML string.  Examples:  unknown var0 <- eval_gaml(2+3);  // var0 equals 5     ### eval_when  Possible use:    eval_when (BDIPlan) —>  bool   Result: evaluate the facet when of a given plan  Examples:  eval_when(plan1)     ### even  Possible use:    even (int) —>  bool   Result: Returns true if the operand is even and false if it is odd.  Special cases:    if the operand is equal to 0, it returns true.   if the operand is a float, it is truncated before   Examples:  bool var0 <- even (3);  // var0 equals false bool var1 <- even(-12);  // var1 equals true     ### every  Possible use:    every (int) —>  bool   every (any expression) —>  bool   msi.gama.util.GamaDateInterval every any expression —>  msi.gama.util.IList<msi.gama.util.GamaDate>   every (msi.gama.util.GamaDateInterval , any expression) —>  msi.gama.util.IList<msi.gama.util.GamaDate>   container every int —>  container   every (container , int) —>  container   Result: true every operand * cycle, false otherwise applies a step to an interval of dates defined by  date1 to date2  expects a frequency (expressed in seconds of simulated time) as argument. Will return true every time the current_date matches with this frequency Retrieves elements from the first argument every step (second argument) elements. Raises an error if the step is negative or equal to zero  Comment: the value of the every operator depends on the cycle. It can be used to do something every x cycle.Used to do something at regular intervals of time. Can be used in conjunction with  since ,  after ,  before ,  until  or  between , so that this computation only takes place in the temporal segment defined by these operators. In all cases, the starting_date of the model is used as a reference starting point  Examples:  if every(2) {write the cycle number is even;}       else {write the cycle number is odd;} (date( 2000-01-01 ) to date( 2010-01-01 )) every (#month) // builds an interval between these two dates which contains all the monthly dates starting from the beginning of the interval reflex when: every(2#days) since date( 2000-01-01 ) { .. } state a { transition to: b when: every(2#mn);} state b { transition to: a when: every(30#s);} // This oscillatory behavior will use the starting_date of the model as its starting point in time   See also: to, since, after,    ### every_cycle Same signification as every    ### evidence_theory_DM  Possible use:    list<list> evidence_theory_DM list<map<string,object>> —>  int   evidence_theory_DM (list<list> , list<map<string,object>>) —>  int   evidence_theory_DM (list<list>, list<map<string,object>>, bool) —>  int   Result: The index of the best candidate according to a method based on the Evidence theory. This theory, which was proposed by Shafer ([http://www.glennshafer.com/books/amte.html Shafer G (1976) A mathematical theory of evidence, Princeton University Press]), is based on the work of Dempster ([http://projecteuclid.org/DPubS?service=UI&version=1.0&verb=Display&handle=euclid.aoms/1177698950 Dempster A (1967) Upper and lower probabilities induced by multivalued mapping. Annals of Mathematical Statistics, vol.  38, pp. 325–339]) on lower and upper probability distributions. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains seven elements: a name, a first threshold s1, a second threshold s2, a value for the assertion  this candidate is the best  at threshold s1 (v1p), a value for the assertion  this candidate is the best  at threshold s2 (v2p), a value for the assertion  this candidate is not the best  at threshold s1 (v1c), a value for the assertion  this candidate is not the best  at threshold s2 (v2c). v1p, v2p, v1c and v2c have to been defined in order that: v1p + v1c <= 1.0; v2p + v2c <= 1.0.; the last operand allows to use a simple version of this multi-criteria decision making method (simple if true)  Special cases:    if the operator is used with only 2 operands (the candidates and the criteria), the last parameter (use simple method) is set to true   returns -1 is the list of candidates is nil or empty   Examples:  int var0 <- evidence_theory_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[name::utility, s1 :: 0.0,s2::1.0, v1p::0.0, v2p::1.0, v1c::0.0, v2c::0.0, maximize :: true],[name::price,  s1 :: 0.0,s2::1.0, v1p::0.0, v2p::1.0, v1c::0.0, v2c::0.0, maximize :: true]], true);  // var0 equals 0   See also: weighted_means_DM, electre_DM,    ### exp  Possible use:    exp (float) —>  float   exp (int) —>  float   Result: Returns Euler s number e raised to the power of the operand.  Special cases:    the operand is casted to a float before being evaluated.   the operand is casted to a float before being evaluated.   Examples:  float var0 <- exp (0);  // var0 equals 1.0   See also: ln,    ### fact  Possible use:    fact (int) —>  float   Result: Returns the factorial of the operand.  Special cases:    if the operand is less than 0, fact returns 0.   Examples:  float var0 <- fact(4);  // var0 equals 24     ### farthest_point_to  Possible use:    geometry farthest_point_to point —>  point   farthest_point_to (geometry , point) —>  point   Result: the farthest point of the left-operand to the left-point.  Examples:  point var0 <- geom farthest_point_to(pt);  // var0 equals the farthest point of geom to pt   See also: any_location_in, any_point_in, closest_points_with, points_at,    ### farthest_to  Possible use:    container<agent> farthest_to geometry —>  geometry   farthest_to (container<agent> , geometry) —>  geometry   Result: An agent or a geometry among the left-operand list of agents, species or meta-population (addition of species), the farthest to the operand (casted as a geometry).  Comment: the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.  Examples:  geometry var0 <- [ag1, ag2, ag3] closest_to(self);  // var0 equals return the farthest agent among ag1, ag2 and ag3 to the agent applying the operator. (species1 + species2) closest_to self   See also: neighbors_at, neighbors_of, inside, overlapping, agents_overlapping, agents_inside, agent_closest_to, closest_to, agent_farthest_to,    ### file  Possible use:    file (string) —>  file   string file container —>  file   file (string , container) —>  file   Result: opens a file in read only mode, creates a GAML file object, and tries to determine and store the file content in the contents attribute. Creates a file in read/write mode, setting its contents to the container passed in parameter  Comment: The file should have a supported extension, see file type definition for supported file extensions.The type of container to pass will depend on the type of file (see the management of files in the documentation). Can be used to copy files since files are considered as containers. For example: save file( image_copy.png , file( image.png )); will copy image.png to image_copy.png  Special cases:    If the specified string does not refer to an existing file, an exception is risen when the variable is used.   Examples:  let fileT type: file value: file(../includes/Stupid_Cell.Data);     // fileT represents the file ../includes/Stupid_Cell.Data    // fileT.contents here contains a matrix storing all the data of the text file   See also: folder, new_folder,    ### file_exists  Possible use:    file_exists (string) —>  bool   Result: Test whether the parameter is the path to an existing file.    ### first  Possible use:    first (string) —>  string   first (container<KeyType,ValueType>) —>  ValueType   int first container —>  container   first (int , container) —>  container   Result: the first value of the operand  Comment: the first operator behavior depends on the nature of the operand  Special cases:    if it is a map, first returns the first value of the first pair (in insertion order)   if it is a file, first returns the first element of the content of the file (that is also a container)   if it is a population, first returns the first agent of the population   if it is a graph, first returns the first edge (in creation order)   if it is a matrix, first returns the element at {0,0} in the matrix   for a matrix of int or float, it will return 0 if the matrix is empty   for a matrix of object or geometry, it will return nil if the matrix is empty   if it is a string, first returns a string composed of its first character       string var0 <- first ( abce );  // var0 equals  a           if it is a list, first returns the first element of the list, or nil if the list is empty       int var1 <- first ([1, 2, 3]);  // var1 equals 1       See also: last,    ### first_of Same signification as first    ### first_with  Possible use:    container first_with any expression —>  unknown   first_with (container , any expression) —>  unknown   Result: the first element of the left-hand operand that makes the right-hand operand evaluate to true.  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    if the left-hand operand is nil, first_with throws an error. If there is no element that satisfies the condition, it returns nil   if the left-operand is a map, the keyword each will contain each value       unknown var4 <- [1::2, 3::4, 5::6] first_with (each >= 4);  // var4 equals 4 unknown var5 <- [1::2, 3::4, 5::6].pairs first_with (each.value >= 4);  // var5 equals 3::4       Examples:  unknown var0 <- [1,2,3,4,5,6,7,8] first_with (each > 3);  // var0 equals 4 unknown var2 <- g2 first_with (length(g2 out_edges_of each) = 0);  // var2 equals node9 unknown var3 <- (list(node) first_with (round(node(each).location.x) > 32);  // var3 equals node2   See also: group_by, last_with, where,    ### flip  Possible use:    flip (float) —>  bool   Result: true or false given the probability represented by the operand  Special cases:    flip 0 always returns false, flip 1 true   Examples:  bool var0 <- flip (0.66666);  // var0 equals 2/3 chances to return true.   See also: rnd,    ### float  Possible use:    float (any) —>  float   Result: Casts the operand into the type float    ### floor  Possible use:    floor (float) —>  float   Result: Maps the operand to the largest previous following integer, i.e. the largest integer not greater than x.  Examples:  float var0 <- floor(3);  // var0 equals 3.0 float var1 <- floor(3.5);  // var1 equals 3.0 float var2 <- floor(-4.7);  // var2 equals -5.0   See also: ceil, round,    ### folder  Possible use:    folder (string) —>  file   Result: opens an existing repository  Special cases:    If the specified string does not refer to an existing repository, an exception is risen.   Examples:  folder(../includes/) file dirT <- folder(../includes/);     // dirT represents the repository ../includes/     // dirT.contents here contains the list of the names of included files   See also: file, new_folder,    ### font  Possible use:    font (string, int, int) —>  font   Result: Creates a new font, by specifying its name (either a font face name like  Lucida Grande Bold  or  Helvetica , or a logical name like  Dialog ,  SansSerif ,  Serif , etc.), a size in points and a style, either #bold, #italic or #plain or a combination (addition) of them.  Examples:  font var0 <- font ( Helvetica Neue ,12, #bold + #italic);  // var0 equals a bold and italic face of the Helvetica Neue family     ### frequency_of  Possible use:    container frequency_of any expression —>  map   frequency_of (container , any expression) —>  map   Result: Returns a map with keys equal to the application of the right-hand argument (like collect) and values equal to the frequency of this key (i.e. how many times it has been obtained)  Examples:  map var0 <- [ag1, ag2, ag3, ag4] frequency_of each.size;  // var0 equals the different sizes as keys and the number of agents of this size as values   See also: as_map,    ### from Same signification as since    ### fuzzy_kappa  Possible use:    fuzzy_kappa (list<agent>, list, list, list<float>, list, matrix<float>, float) —>  float   fuzzy_kappa (list<agent>, list, list, list<float>, list, matrix<float>, float, list) —>  float   Result: fuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance, weights). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling & Software, 21 fuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling & Software, 21  Examples:  fuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2, [1.0,3.0,2.0,2.0,4.0]) fuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2)     ### fuzzy_kappa_sim  Possible use:    fuzzy_kappa_sim (list<agent>, list, list, list, list<float>, list, matrix<float>, float) —>  float   fuzzy_kappa_sim (list<agent>, list, list, list, list<float>, list, matrix<float>, float, list) —>  float   Result: fuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800,  fuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance, weights). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800,  Examples:  fuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2) fuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2,[1.0,3.0,2.0,2.0,4.0])     ### gaml_file  Possible use:    gaml_file (string) —>  file   Result: Constructs a file of type gaml. Allowed extensions are limited to gaml, experiment    ### gamma_index  Possible use:    gamma_index (graph) —>  float   Result: returns the gamma index of the graph (A measure of connectivity that considers the relationship between the number of observed links and the number of possible links: gamma = e/(3 * (v - 2)) - for planar graph.  Examples:  graph graphEpidemio <- graph([]); float var1 <- gamma_index(graphEpidemio);  // var1 equals the gamma index of the graph   See also: alpha_index, beta_index, nb_cycles, connectivity_index,    ### gamma_rnd  Possible use:    float gamma_rnd float —>  float   gamma_rnd (float , float) —>  float   Result: returns a random value from a gamma distribution with specified values of the shape and scale parameters  Examples:  gamma_rnd(10.0,5.0)     ### gauss  Possible use:    gauss (point) —>  float   float gauss float —>  float   gauss (float , float) —>  float   Result: A value from a normally distributed random variable with expected value (mean) and variance (standardDeviation). The probability density function of such a variable is a Gaussian. A value from a normally distributed random variable with expected value (mean) and variance (standardDeviation). The probability density function of such a variable is a Gaussian.  Special cases:    when the operand is a point, it is read as {mean, standardDeviation}   when standardDeviation value is 0.0, it always returns the mean value   when the operand is a point, it is read as {mean, standardDeviation}   when standardDeviation value is 0.0, it always returns the mean value   Examples:  float var0 <- gauss(0,0.3);  // var0 equals 0.22354 float var1 <- gauss(0,0.3);  // var1 equals -0.1357 float var2 <- gauss({0,0.3});  // var2 equals 0.22354 float var3 <- gauss({0,0.3});  // var3 equals -0.1357   See also: skew_gauss, truncated_gauss, poisson,    ### generate_barabasi_albert  Possible use:    generate_barabasi_albert (container<agent>, species, int, bool) —>  graph   generate_barabasi_albert (species, species, int, int, bool) —>  graph   Result: returns a random scale-free network (following Barabasi-Albert (BA) model). returns a random scale-free network (following Barabasi-Albert (BA) model).  Comment: The Barabasi-Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:The Barabasi-Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:  Special cases:     vertices_specy : the species of vertices    edges_species : the species of edges    size : the graph will contain (size + 1) nodes    m : the number of edges added per novel node    synchronized : is the graph and the species of vertices and edges synchronized?    agents : list of existing node agents    edges_species : the species of edges    size : the graph will contain (size + 1) nodes    m : the number of edges added per novel node    synchronized : is the graph and the species of vertices and edges synchronized?   Examples:  graph<yourNodeSpecy,yourEdgeSpecy> graphEpidemio <- generate_barabasi_albert(   yourNodeSpecy,   yourEdgeSpecy,   3,   5,   true); graph<yourNodeSpecy,yourEdgeSpecy> graphEpidemio <- generate_barabasi_albert(   yourListOfNodes,   yourEdgeSpecy,   3,   5,   true);   See also: generate_watts_strogatz,    ### generate_complete_graph  Possible use:    generate_complete_graph (container<agent>, species, bool) —>  graph   generate_complete_graph (container<agent>, species, float, bool) —>  graph   generate_complete_graph (species, species, int, bool) —>  graph   generate_complete_graph (species, species, int, float, bool) —>  graph   Result: returns a fully connected graph. returns a fully connected graph. returns a fully connected graph. returns a fully connected graph.  Comment: Arguments should include following elements:Arguments should include following elements:Arguments should include following elements:Arguments should include following elements:  Special cases:     agents : list of existing node agents    edges_species : the species of edges    layoutRadius : nodes of the graph will be located on a circle with radius layoutRadius and centered in the environment.    synchronized : is the graph and the species of vertices and edges synchronized?    vertices_specy : the species of vertices    edges_species : the species of edges    size : the graph will contain size nodes.    layoutRadius : nodes of the graph will be located on a circle with radius layoutRadius and centered in the environment.    synchronized : is the graph and the species of vertices and edges synchronized?    vertices_specy : the species of vertices    edges_species : the species of edges    size : the graph will contain size nodes.    synchronized : is the graph and the species of vertices and edges synchronized?    agents : list of existing node agents    edges_species : the species of edges    synchronized : is the graph and the species of vertices and edges synchronized?   Examples:  graph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_complete_graph(    myListOfNodes,    myEdgeSpecy,    25,   true); graph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_complete_graph(    myVertexSpecy,    myEdgeSpecy,    10, 25,   true); graph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_complete_graph(    myVertexSpecy,    myEdgeSpecy,    10,   true); graph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_complete_graph(    myListOfNodes,    myEdgeSpecy,   true);   See also: generate_barabasi_albert, generate_watts_strogatz,    ### generate_watts_strogatz  Possible use:    generate_watts_strogatz (container<agent>, species, float, int, bool) —>  graph   generate_watts_strogatz (species, species, int, float, int, bool) —>  graph   Result: returns a random small-world network (following Watts-Strogatz model). returns a random small-world network (following Watts-Strogatz model).  Comment: The Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:The Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:  Special cases:     vertices_specy : the species of vertices    edges_species : the species of edges    size : the graph will contain (size + 1) nodes. Size must be greater than k.    p : probability to  rewire  an edge. So it must be between 0 and 1. The parameter is often called beta in the literature.    k : the base degree of each node. k must be greater than 2 and even.    synchronized : is the graph and the species of vertices and edges synchronized?    agents : list of existing node agents    edges_species : the species of edges    p : probability to  rewire  an edge. So it must be between 0 and 1. The parameter is often called beta in the literature.    k : the base degree of each node. k must be greater than 2 and even.    synchronized : is the graph and the species of vertices and edges synchronized?   Examples:  graph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_watts_strogatz(    myVertexSpecy,    myEdgeSpecy,    2,    0.3,    2,   true); graph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_watts_strogatz(    myListOfNodes,    myEdgeSpecy,    0.3,    2,   true);   See also: generate_barabasi_albert,    ### geojson_file  Possible use:    geojson_file (string) —>  file   Result: Constructs a file of type geojson. Allowed extensions are limited to json, geojson, geo.json    ### geometric_mean  Possible use:    geometric_mean (container) —>  float   Result: the geometric mean of the elements of the operand. See Geometric_mean for more details.  Comment: The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.  Examples:  float var0 <- geometric_mean ([4.5, 3.5, 5.5, 7.0]);  // var0 equals 4.962326343467649   See also: mean, median, harmonic_mean,    ### geometry  Possible use:    geometry (any) —>  geometry   Result: Casts the operand into the type geometry    ### geometry_collection  Possible use:    geometry_collection (container<geometry>) —>  geometry   Result: A geometry collection (multi-geometry) composed of the given list of geometries.  Special cases:    if the operand is nil, returns the point geometry {0,0}   if the operand is composed of a single geometry, returns a copy of the geometry.   Examples:  geometry var0 <- geometry_collection([{0,0}, {0,10}, {10,10}, {10,0}]);  // var0 equals a geometry composed of the 4 points (multi-point).   See also: around, circle, cone, link, norm, point, polygone, rectangle, square, triangle, line,    ### get  Possible use:    geometry get string —>  unknown   get (geometry , string) —>  unknown   agent get string —>  unknown   get (agent , string) —>  unknown   Result: Reads an attribute of the specified geometry (left operand). The attribute name is specified by the right operand. Reads an attribute of the specified agent (left operand). The attribute name is specified by the right operand.  Special cases:    Reading the attribute of a geometry       string geom_area <- a_geometry get( area );     // reads then  area  attribute of  a_geometry  variable then assigns the returned value to the geom_area variable          Reading the attribute of another agent       string agent_name <- an_agent get( name );     // reads then  name  attribute of an_agent then assigns the returned value to the agent_name variable         ### get_about  Possible use:    get_about (emotion) —>  predicate   Result: get the about value of the given emotion  Examples:  get_about(emotion)     ### get_agent  Possible use:    get_agent (msi.gaml.architecture.simplebdi.SocialLink) —>  agent   Result: get the agent value of the given social link  Examples:  get_agent(social_link1)     ### get_agent_cause  Possible use:    get_agent_cause (emotion) —>  agent   get_agent_cause (predicate) —>  agent   Result: get the agent cause value of the given emotion  Examples:  get_agent_cause(emotion)     ### get_decay  Possible use:    get_decay (emotion) —>  float   Result: get the decay value of the given emotion  Examples:  get_decay(emotion)     ### get_dominance  Possible use:    get_dominance (msi.gaml.architecture.simplebdi.SocialLink) —>  float   Result: get the dominance value of the given social link  Examples:  get_dominance(social_link1)     ### get_familiarity  Possible use:    get_familiarity (msi.gaml.architecture.simplebdi.SocialLink) —>  float   Result: get the familiarity value of the given social link  Examples:  get_familiarity(social_link1)     ### get_intensity  Possible use:    get_intensity (emotion) —>  float   Result: get the intensity value of the given emotion  Examples:  emotion set_intensity 12     ### get_lifetime  Possible use:    get_lifetime (predicate) —>  int     ### get_liking  Possible use:    get_liking (msi.gaml.architecture.simplebdi.SocialLink) —>  float   Result: get the liking value of the given social link  Examples:  get_liking(social_link1)     ### get_praiseworthiness  Possible use:    get_praiseworthiness (predicate) —>  float     ### get_priority  Possible use:    get_priority (predicate) —>  float     ### get_solidarity  Possible use:    get_solidarity (msi.gaml.architecture.simplebdi.SocialLink) —>  float   Result: get the solidarity value of the given social link  Examples:  get_solidarity(social_link1)     ### get_super_intention  Possible use:    get_super_intention (predicate) —>  predicate     ### gif_file  Possible use:    gif_file (string) —>  file   Result: Constructs a file of type gif. Allowed extensions are limited to gif    ### gini  Possible use:    gini (list<float>) —>  float   Special cases:    return the Gini Index of the given list of values (list of floats)       float var0 <- gini([1.0, 0.5, 2.0]);  // var0 equals the gini index computed         ### graph  Possible use:    graph (any) —>  graph   Result: Casts the operand into the type graph    ### grayscale  Possible use:    grayscale (rgb) —>  rgb   Result: Converts rgb color to grayscale value  Comment: r=red, g=green, b=blue. Between 0 and 255 and gray = 0.299 * red + 0.587 * green + 0.114 * blue (Photoshop value)  Examples:  rgb var0 <- grayscale (rgb(255,0,0));  // var0 equals to a dark grey   See also: rgb, hsb,    ### grid_at  Possible use:    species grid_at point —>  agent   grid_at (species , point) —>  agent   Result: returns the cell of the grid (right-hand operand) at the position given by the right-hand operand  Comment: If the left-hand operand is a point of floats, it is used as a point of ints.  Special cases:    if the left-hand operand is not a grid cell species, returns nil   Examples:  agent var0 <- grid_cell grid_at {1,2};  // var0 equals the agent grid_cell with grid_x=1 and grid_y = 2     ### grid_cells_to_graph  Possible use:    grid_cells_to_graph (container) —>  graph   Result: creates a graph from a list of cells (operand). An edge is created between neighbors.  Examples:  my_cell_graph<-grid_cells_to_graph(cells_list)     ### grid_file  Possible use:    grid_file (string) —>  file   Result: Constructs a file of type grid. Allowed extensions are limited to asc, tif    ### group_by  Possible use:    container group_by any expression —>  map   group_by (container , any expression) —>  map   Result: Returns a map, where the keys take the possible values of the right-hand operand and the map values are the list of elements of the left-hand operand associated to the key value  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    if the left-hand operand is nil, group_by throws an error   Examples:  map var0 <- [1,2,3,4,5,6,7,8] group_by (each > 3);  // var0 equals [false::[1, 2, 3], true::[4, 5, 6, 7, 8]] map var1 <- g2 group_by (length(g2 out_edges_of each) );  // var1 equals [ 0::[node9, node7, node10, node8, node11], 1::[node6], 2::[node5], 3::[node4]] map var2 <- (list(node) group_by (round(node(each).location.x));  // var2 equals [32::[node5], 21::[node1], 4::[node0], 66::[node2], 96::[node3]] map var3 <- [1::2, 3::4, 5::6] group_by (each > 4);  // var3 equals [false::[2, 4], true::[6]]   See also: first_with, last_with, where,    ### harmonic_mean  Possible use:    harmonic_mean (container) —>  float   Result: the harmonic mean of the elements of the operand. See Harmonic_mean for more details.  Comment: The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.  Examples:  float var0 <- harmonic_mean ([4.5, 3.5, 5.5, 7.0]);  // var0 equals 4.804159445407279   See also: mean, median, geometric_mean,    ### hexagon  Possible use:    hexagon (point) —>  geometry   hexagon (float) —>  geometry   Result: A hexagon geometry which the given with and height  Comment: the center of the hexagon is by default the location of the current agent in which has been called this operator.the center of the hexagon is by default the location of the current agent in which has been called this operator.  Special cases:    returns nil if the operand is nil.   returns nil if the operand is nil.   Examples:  geometry var0 <- hexagon({10,5});  // var0 equals a geometry as a hexagon of width of 10 and height of 5. geometry var1 <- hexagon(10);  // var1 equals a geometry as a hexagon of width of 10 and height of 10.   See also: around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, triangle,    ### hierarchical_clustering  Possible use:    container<agent> hierarchical_clustering float —>  container   hierarchical_clustering (container<agent> , float) —>  container   Result: A tree (list of list) contained groups of agents clustered by distance considering a distance min between two groups.  Comment: use of hierarchical clustering with Minimum for linkage criterion between two groups of agents.  Examples:  container var0 <- [ag1, ag2, ag3, ag4, ag5] hierarchical_clustering 20.0;  // var0 equals for example, can return [[[ag1],[ag3]], [ag2], [[[ag4],[ag5]],[ag6]]   See also: simple_clustering_by_distance,    ### hsb  Possible use:    hsb (float, float, float) —>  rgb   hsb (float, float, float, int) —>  rgb   hsb (float, float, float, float) —>  rgb   Result: Converts hsb (h=hue, s=saturation, b=brightness) value to Gama color  Comment: h,s and b components should be floating-point values between 0.0 and 1.0 and when used alpha should be an integer (between 0 and 255) or a float (between 0 and 1) . Examples: Red=(0.0,1.0,1.0), Yellow=(0.16,1.0,1.0), Green=(0.33,1.0,1.0), Cyan=(0.5,1.0,1.0), Blue=(0.66,1.0,1.0), Magenta=(0.83,1.0,1.0)  Examples:  rgb var0 <- hsb (0.5,1.0,1.0,0.0);  // var0 equals rgb(cyan,0) rgb var1 <- hsb (0.0,1.0,1.0);  // var1 equals rgb(red)   See also: rgb,    ### hypot  Possible use:    hypot (float, float, float, float) —>  float   Result: Returns sqrt(x2 +y2) without intermediate overflow or underflow.  Special cases:    If either argument is infinite, then the result is positive infinity. If either argument is NaN and neither argument is infinite, then the result is NaN.   Examples:  float var0 <- hypot(0,1,0,1);  // var0 equals sqrt(2)     ### image_file  Possible use:    image_file (string) —>  file   Result: Constructs a file of type image. Allowed extensions are limited to tiff, jpg, jpeg, png, pict, bmp    ### in  Possible use:    unknown in container —>  bool   in (unknown , container) —>  bool   string in string —>  bool   in (string , string) —>  bool   Result: true if the right operand contains the left operand, false otherwise  Comment: the definition of in depends on the container  Special cases:    if the right operand is nil or empty, in returns false   if both operands are strings, returns true if the left-hand operand patterns is included in to the right-hand string;   Examples:  bool var0 <- 2 in [1,2,3,4,5,6];  // var0 equals true bool var1 <- 7 in [1,2,3,4,5,6];  // var1 equals false bool var2 <- 3 in [1::2, 3::4, 5::6];  // var2 equals false bool var3 <- 6 in [1::2, 3::4, 5::6];  // var3 equals true bool var4 <-   bc  in  abcded ;  // var4 equals true   See also: contains,    ### in_degree_of  Possible use:    graph in_degree_of unknown —>  int   in_degree_of (graph , unknown) —>  int   Result: returns the in degree of a vertex (right-hand operand) in the graph given as left-hand operand.  Examples:  int var1 <- graphFromMap in_degree_of (node(3));  // var1 equals 2   See also: out_degree_of, degree_of,    ### in_edges_of  Possible use:    graph in_edges_of unknown —>  container   in_edges_of (graph , unknown) —>  container   Result: returns the list of the in-edges of a vertex (right-hand operand) in the graph given as left-hand operand.  Examples:  container var1 <- graphFromMap in_edges_of node({12,45});  // var1 equals [LineString]   See also: out_edges_of,    ### indented_by  Possible use:    string indented_by int —>  string   indented_by (string , int) —>  string   Result: Converts a (possibly multiline) string by indenting it by a number – specified by the second operand – of tabulations to the right    ### index_by  Possible use:    container index_by any expression —>  map   index_by (container , any expression) —>  map   Result: produces a new map from the evaluation of the right-hand operand for each element of the left-hand operand  Special cases:    if the left-hand operand is nil, index_by throws an error. If the operation results in duplicate keys, only the first value corresponding to the key is kept   Examples:  map var0 <- [1,2,3,4,5,6,7,8] index_by (each - 1);  // var0 equals [0::1, 1::2, 2::3, 3::4, 4::5, 5::6, 6::7, 7::8]     ### index_of  Possible use:    container index_of unknown —>  int   index_of (container , unknown) —>  int   map index_of unknown —>  unknown   index_of (map , unknown) —>  unknown   matrix index_of unknown —>  point   index_of (matrix , unknown) —>  point   string index_of string —>  int   index_of (string , string) —>  int   species index_of unknown —>  int   index_of (species , unknown) —>  int   Result: the index of the first occurence of the right operand in the left operand container the index of the first occurence of the right operand in the left operand container  Comment: The definition of index_of and the type of the index depend on the container  Special cases:    if the left operand is a map, index_of returns the index of a value or nil if the value is not mapped   if the left operator is a species, returns the index of an agent in a species. If the argument is not an agent of this species, returns -1. Use int(agent) instead   if the left operand is a list, index_of returns the index as an integer       int var1 <- [1,2,3,4,5,6] index_of 4;  // var1 equals 3 int var2 <- [4,2,3,4,5,4] index_of 4;  // var2 equals 0          if the left operand is a matrix, index_of returns the index as a point       point var3 <- matrix([[1,2,3],[4,5,6]]) index_of 4;  // var3 equals {1.0,0.0}          if both operands are strings, returns the index within the left-hand string of the first occurrence of the given right-hand string       int var4 <-   abcabcabc  index_of  ca ;  // var4 equals 2       Examples:  unknown var0 <- [1::2, 3::4, 5::6] index_of 4;  // var0 equals 3   See also: at, last_index_of,    ### inside  Possible use:    container<agent> inside geometry —>  list<geometry>   inside (container<agent> , geometry) —>  list<geometry>   Result: A list of agents or geometries among the left-operand list, species or meta-population (addition of species), covered by the operand (casted as a geometry).  Examples:  list<geometry> var0 <- [ag1, ag2, ag3] inside(self);  // var0 equals the agents among ag1, ag2 and ag3 that are covered by the shape of the right-hand argument. list<geometry> var1 <- (species1 + species2) inside (self);  // var1 equals the agents among species species1 and species2 that are covered by the shape of the right-hand argument.   See also: neighbors_at, neighbors_of, closest_to, overlapping, agents_overlapping, agents_inside, agent_closest_to,    ### int  Possible use:    int (any) —>  int   Result: Casts the operand into the type int    ### inter  Possible use:    container inter container —>  container   inter (container , container) —>  container   geometry inter geometry —>  geometry   inter (geometry , geometry) —>  geometry   Result: the intersection of the two operands A geometry resulting from the intersection between the two geometries  Comment: both containers are transformed into sets (so without duplicated element, cf. remove_deplicates operator) before the set intersection is computed.  Special cases:    if an operand is a graph, it will be transformed into the set of its nodes   returns nil if one of the operands is nil   if an operand is a map, it will be transformed into the set of its values       container var0 <- [1::2, 3::4, 5::6] inter [2,4];  // var0 equals [2,4] container var1 <- [1::2, 3::4, 5::6] inter [1,3];  // var1 equals []          if an operand is a matrix, it will be transformed into the set of the lines       container var2 <- matrix([[1,2,3],[4,5,4]]) inter [3,4];  // var2 equals [3,4]       Examples:  container var3 <- [1,2,3,4,5,6] inter [2,4];  // var3 equals [2,4] container var4 <- [1,2,3,4,5,6] inter [0,8];  // var4 equals [] geometry var5 <- square(10) inter circle(5);  // var5 equals circle(5)   See also: remove_duplicates, union, +, -,    ### interleave  Possible use:    interleave (container) —>  container   Result: a new list containing the interleaved elements of the containers contained in the operand  Comment: the operand should be a list of lists of elements. The result is a list of elements.  Examples:  container var0 <- interleave([1,2,4,3,5,7,6,8]);  // var0 equals [1,2,4,3,5,7,6,8] container var1 <- interleave([[ e11 , e12 , e13 ],[ e21 , e22 , e23 ],[ e31 , e32 , e33 ]]);  // var1 equals [ e11 , e21 , e31 , e12 , e22 , e32 , e13 , e23 , e33 ]     ### internal_at  Possible use:    agent internal_at container —>  unknown   internal_at (agent , container) —>  unknown   geometry internal_at container —>  unknown   internal_at (geometry , container) —>  unknown   container<KeyType,ValueType> internal_at list<KeyType> —>  ValueType   internal_at (container<KeyType,ValueType> , list<KeyType>) —>  ValueType   Result: For internal use only. Corresponds to the implementation, for agents, of the access to containers with [index] For internal use only. Corresponds to the implementation, for geometries, of the access to containers with [index] For internal use only. Corresponds to the implementation of the access to containers with [index]  See also: at,    ### internal_integrated_value  Possible use:    any expression internal_integrated_value any expression —>  container   internal_integrated_value (any expression , any expression) —>  container   Result: For internal use only. Corresponds to the implementation, for agents, of the access to containers with [index]    ### internal_zero_order_equation  Possible use:    internal_zero_order_equation (any expression) —>  float     ### intersection Same signification as inter    ### intersects  Possible use:    geometry intersects geometry —>  bool   intersects (geometry , geometry) —>  bool   Result: A boolean, equal to true if the left-geometry (or agent/point) intersects the right-geometry (or agent/point).  Special cases:    if one of the operand is null, returns false.   Examples:  bool var0 <- square(5) intersects {10,10};  // var0 equals false   See also: disjoint_from, crosses, overlaps, partially_overlaps, touches,    ### inverse  Possible use:    inverse (matrix) —>  matrix<float>   Result: The inverse matrix of the given matrix. If no inverse exists, returns a matrix that has properties that resemble that of an inverse.  Examples:  matrix<float> var0 <- inverse(matrix([[5,-3],[6,-4]]));  // var0 equals [2.0000000000000004,-0.9999999999999998]     ### inverse_distance_weighting Same signification as IDW    ### is  Possible use:    unknown is any expression —>  bool   is (unknown , any expression) —>  bool   Result: returns true if the left operand is of the right operand type, false otherwise  Examples:  bool var0 <- 0 is int;  // var0 equals true bool var1 <- an_agent is node;  // var1 equals true bool var2 <- 1 is float;  // var2 equals false     ### is_csv  Possible use:    is_csv (any) —>  bool   Result: Tests whether the operand is a csv file.    ### is_dxf  Possible use:    is_dxf (any) —>  bool   Result: Tests whether the operand is a dxf file.    ### is_finite  Possible use:    is_finite (float) —>  bool   Result: Returns whether the argument is a finite number or not  Examples:  bool var0 <- is_finite(4.66);  // var0 equals true bool var1 <- is_finite(#infinity);  // var1 equals false     ### is_gaml  Possible use:    is_gaml (any) —>  bool   Result: Tests whether the operand is a gaml file.    ### is_geojson  Possible use:    is_geojson (any) —>  bool   Result: Tests whether the operand is a geojson file.    ### is_gif  Possible use:    is_gif (any) —>  bool   Result: Tests whether the operand is a gif file.    ### is_grid  Possible use:    is_grid (any) —>  bool   Result: Tests whether the operand is a grid file.    ### is_image  Possible use:    is_image (any) —>  bool   Result: Tests whether the operand is a image file.    ### is_json  Possible use:    is_json (any) —>  bool   Result: Tests whether the operand is a json file.    ### is_number  Possible use:    is_number (string) —>  bool   is_number (float) —>  bool   Result: tests whether the operand represents a numerical value Returns whether the argument is a real number or not  Comment: Note that the symbol . should be used for a float value (a string with , will not be considered as a numeric value). Symbols e and E are also accepted. A hexadecimal value should begin with #.  Examples:  bool var0 <- is_number(test);  // var0 equals false bool var1 <- is_number(123.56);  // var1 equals true bool var2 <- is_number(-1.2e5);  // var2 equals true bool var3 <- is_number(1,2);  // var3 equals false bool var4 <- is_number(#12FA);  // var4 equals true bool var5 <- is_number(4.66);  // var5 equals true bool var6 <- is_number(#infinity);  // var6 equals true bool var7 <- is_number(#nan);  // var7 equals false     ### is_obj  Possible use:    is_obj (any) —>  bool   Result: Tests whether the operand is a obj file.    ### is_osm  Possible use:    is_osm (any) —>  bool   Result: Tests whether the operand is a osm file.    ### is_pgm  Possible use:    is_pgm (any) —>  bool   Result: Tests whether the operand is a pgm file.    ### is_property  Possible use:    is_property (any) —>  bool   Result: Tests whether the operand is a property file.    ### is_R  Possible use:    is_R (any) —>  bool   Result: Tests whether the operand is a R file.    ### is_shape  Possible use:    is_shape (any) —>  bool   Result: Tests whether the operand is a shape file.    ### is_skill  Possible use:    unknown is_skill string —>  bool   is_skill (unknown , string) —>  bool   Result: returns true if the left operand is an agent whose species implements the right-hand skill name  Examples:  bool var0 <- agentA is_skill  moving ;  // var0 equals true     ### is_svg  Possible use:    is_svg (any) —>  bool   Result: Tests whether the operand is a svg file.    ### is_text  Possible use:    is_text (any) —>  bool   Result: Tests whether the operand is a text file.    ### is_threeds  Possible use:    is_threeds (any) —>  bool   Result: Tests whether the operand is a threeds file.    ### is_URL  Possible use:    is_URL (any) —>  bool   Result: Tests whether the operand is a URL file.    ### is_xml  Possible use:    is_xml (any) —>  bool   Result: Tests whether the operand is a xml file.    ### json_file  Possible use:    json_file (string) —>  file   Result: Constructs a file of type json. Allowed extensions are limited to json    ### kappa  Possible use:    kappa (list, list, list) —>  float   kappa (list, list, list, list) —>  float   Result: kappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20. kappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories, weights). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20.  Examples:  kappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3]) float var1 <- kappa([1,3,5,1,5],[1,1,1,1,5],[1,3,5]);  // var1 equals the similarity between 0 and 1 float var2 <- kappa([1,1,1,1,5],[1,1,1,1,5],[1,3,5]);  // var2 equals 1.0 kappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3], [1.0, 2.0, 3.0, 1.0, 5.0])     ### kappa_sim  Possible use:    kappa_sim (list, list, list, list) —>  float   kappa_sim (list, list, list, list, list) —>  float   Result: kappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories). Reference: van Vliet, J., Bregt, A.K. & Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8). kappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories, weights). Reference: van Vliet, J., Bregt, A.K. & Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8)  Examples:  kappa([cat1,cat1,cat2,cat2,cat2],[cat2,cat1,cat2,cat1,cat3],[cat2,cat1,cat2,cat3,cat3], [cat1,cat2,cat3]) kappa([cat1,cat1,cat2,cat2,cat2],[cat2,cat1,cat2,cat1,cat3],[cat2,cat1,cat2,cat3,cat3], [cat1,cat2,cat3],[1.0, 2.0, 3.0, 1.0, 5.0])     ### kmeans  Possible use:    list kmeans int —>  list<list>   kmeans (list , int) —>  list<list>   kmeans (list, int, int) —>  list<list>   Result: returns the list of clusters (list of instance indices) computed with the kmeans++ algorithm from the first operand data according to the number of clusters to split the data into (k) and the maximum number of iterations to run the algorithm for (If negative, no maximum will be used) (maxIt). Usage: kmeans(data,k,maxit) returns the list of clusters (list of instance indices) computed with the kmeans++ algorithm from the first operand data according to the number of clusters to split the data into (k). Usage: kmeans(data,k)  Special cases:    if the lengths of two vectors in the right-hand aren t equal, returns 0   if the lengths of two vectors in the right-hand aren t equal, returns 0   Examples:  kmeans ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],2,10) kmeans ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],2)     ### kurtosis  Possible use:    kurtosis (list) —>  float   Result: returns kurtosis value computed from the operand list of values  Special cases:    if the length of the list is lower than 3, returns NaN   Examples:  kurtosis ([1,2,3,4,5])     ### last  Possible use:    last (string) —>  string   last (container<KeyType,ValueType>) —>  ValueType   int last container —>  container   last (int , container) —>  container   Result: the last element of the operand  Comment: the last operator behavior depends on the nature of the operand  Special cases:    if it is a map, last returns the value of the last pair (in insertion order)   if it is a file, last returns the last element of the content of the file (that is also a container)   if it is a population, last returns the last agent of the population   if it is a graph, last returns a list containing the last edge created   if it is a matrix, last returns the element at {length-1,length-1} in the matrix   for a matrix of int or float, it will return 0 if the matrix is empty   for a matrix of object or geometry, it will return nil if the matrix is empty   if it is a string, last returns a string composed of its last character, or an empty string if the operand is empty       string var0 <- last ( abce );  // var0 equals  e           if it is a list, last returns the last element of the list, or nil if the list is empty       int var1 <- last ([1, 2, 3]);  // var1 equals 3       See also: first,    ### last_index_of  Possible use:    map last_index_of unknown —>  unknown   last_index_of (map , unknown) —>  unknown   string last_index_of string —>  int   last_index_of (string , string) —>  int   species last_index_of unknown —>  int   last_index_of (species , unknown) —>  int   container last_index_of unknown —>  int   last_index_of (container , unknown) —>  int   matrix last_index_of unknown —>  point   last_index_of (matrix , unknown) —>  point   Result: the index of the last occurence of the right operand in the left operand container  Comment: The definition of last_index_of and the type of the index depend on the container  Special cases:    if the left operand is a species, the last index of an agent is the same as its index   if the left operand is a map, last_index_of returns the index as an int (the key of the pair)       unknown var0 <- [1::2, 3::4, 5::4] last_index_of 4;  // var0 equals 5          if both operands are strings, returns the index within the left-hand string of the rightmost occurrence of the given right-hand string       int var1 <-  abcabcabc  last_index_of  ca ;  // var1 equals 5          if the left operand is a list, last_index_of returns the index as an integer       int var2 <- [1,2,3,4,5,6] last_index_of 4;  // var2 equals 3 int var3 <- [4,2,3,4,5,4] last_index_of 4;  // var3 equals 5          if the left operand is a matrix, last_index_of returns the index as a point       point var4 <- matrix([[1,2,3],[4,5,4]]) last_index_of 4;  // var4 equals {1.0,2.0}       See also: at, index_of, last_index_of,    ### last_of Same signification as last    ### last_with  Possible use:    container last_with any expression —>  unknown   last_with (container , any expression) —>  unknown   Result: the last element of the left-hand operand that makes the right-hand operand evaluate to true.  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    if the left-hand operand is nil, last_with throws an error.   If there is no element that satisfies the condition, it returns nil   if the left-operand is a map, the keyword each will contain each value       unknown var4 <- [1::2, 3::4, 5::6] last_with (each >= 4);  // var4 equals 6 unknown var5 <- [1::2, 3::4, 5::6].pairs last_with (each.value >= 4);  // var5 equals 5::6       Examples:  unknown var0 <- [1,2,3,4,5,6,7,8] last_with (each > 3);  // var0 equals 8 unknown var2 <- g2 last_with (length(g2 out_edges_of each) = 0 );  // var2 equals node11 unknown var3 <- (list(node) last_with (round(node(each).location.x) > 32);  // var3 equals node3   See also: group_by, first_with, where,    ### layout  Possible use:    graph layout string —>  graph   layout (graph , string) —>  graph   layout (graph, string, int) —>  graph   layout (graph, string, int, map<string,unknown>) —>  graph   Result: layouts a GAMA graph.    ### length  Possible use:    length (string) —>  int   length (container<KeyType,ValueType>) —>  int   Result: the number of elements contained in the operand  Comment: the length operator behavior depends on the nature of the operand  Special cases:    if it is a population, length returns number of agents of the population   if it is a graph, length returns the number of vertexes or of edges (depending on the way it was created)   if it is a string, length returns the number of characters       int var0 <- length ( I am an agent );  // var0 equals 13          if it is a list or a map, length returns the number of elements in the list or map       int var1 <- length([12,13]);  // var1 equals 2 int var2 <- length([]);  // var2 equals 0          if it is a matrix, length returns the number of cells       int var3 <- length(matrix([[ c11 , c12 , c13 ],[ c21 , c22 , c23 ]]));  // var3 equals 6         ### line  Possible use:    line (container<geometry>) —>  geometry   container<geometry> line float —>  geometry   line (container<geometry> , float) —>  geometry   Result: A polyline geometry from the given list of points represented as a cylinder of radius r. A polyline geometry from the given list of points.  Special cases:    if the operand is nil, returns the point geometry {0,0}   if the operand is composed of a single point, returns a point geometry.   if the operand is nil, returns the point geometry {0,0}   if the operand is composed of a single point, returns a point geometry.   if a radius is added, the given list of points represented as a cylinder of radius r       geometry var0 <- polyline([{0,0}, {0,10}, {10,10}, {10,0}],0.2);  // var0 equals a polyline geometry composed of the 4 points.       Examples:  geometry var1 <- polyline([{0,0}, {0,10}, {10,10}, {10,0}]);  // var1 equals a polyline geometry composed of the 4 points.   See also: around, circle, cone, link, norm, point, polygone, rectangle, square, triangle,    ### link  Possible use:    geometry link geometry —>  geometry   link (geometry , geometry) —>  geometry   Result: A dynamic line geometry between the location of the two operands  Comment: The geometry of the link is a line between the locations of the two operands, which is built and maintained dynamically  Special cases:    if one of the operands is nil, link returns a point geometry at the location of the other. If both are null, it returns a point geometry at {0,0}   Examples:  geometry var0 <- link (geom1,geom2);  // var0 equals a link geometry between geom1 and geom2.   See also: around, circle, cone, line, norm, point, polygon, polyline, rectangle, square, triangle,    ### list  Possible use:    list (any) —>  list   Result: Casts the operand into the type list    ### list_with  Possible use:    int list_with any expression —>  container   list_with (int , any expression) —>  container   Result: creates a list with a size provided by the first operand, and filled with the second operand  Comment: Note that the right operand  should be positive, and that the second one is evaluated for each position  in the list.  See also: list,    ### ln  Possible use:    ln (int) —>  float   ln (float) —>  float   Result: Returns the natural logarithm (base e) of the operand.  Special cases:    an exception is raised if the operand is less than zero.   Examples:  float var0 <- ln(1);  // var0 equals 0.0 float var1 <- ln(exp(1));  // var1 equals 1.0   See also: exp,    ### load_graph_from_file  Possible use:    load_graph_from_file (string) —>  graph   string load_graph_from_file file —>  graph   load_graph_from_file (string , file) —>  graph   string load_graph_from_file string —>  graph   load_graph_from_file (string , string) —>  graph   load_graph_from_file (string, species, species) —>  graph   load_graph_from_file (string, file, species, species) —>  graph   load_graph_from_file (string, string, species, species) —>  graph   load_graph_from_file (string, string, species, species, bool) —>  graph   Result: loads a graph from a file returns a graph loaded from a given file encoded into a given format. The last boolean parameter indicates whether the resulting graph will be considered as spatial or not by GAMA  Comment: Available formats:  pajek : Pajek (Slovene word for Spider) is a program, for Windows, for analysis and visualization of large networks. See: http://pajek.imfm.si/doku.php?id=pajek for more details. lgl : LGL is a compendium of applications for making the visualization of large networks and trees tractable. See: http://lgl.sourceforge.net/ for more details. dot : DOT is a plain text graph description language. It is a simple way of describing graphs that both humans and computer programs can use. See: http://en.wikipedia.org/wiki/DOT_language for more details. edge : This format is a simple text file with numeric vertex ids defining the edges. gexf : GEXF (Graph Exchange XML Format) is a language for describing complex networks structures, their associated data and dynamics. Started in 2007 at Gephi project by different actors, deeply involved in graph exchange issues, the gexf specifications are mature enough to claim being both extensible and open, and suitable for real specific applications. See: http://gexf.net/format/ for more details. graphml : GraphML is a comprehensive and easy-to-use file format for graphs based on XML. See: http://graphml.graphdrawing.org/ for more details. tlp  or  tulip : TLP is the Tulip software graph format. See: http://tulip.labri.fr/TulipDrupal/?q=tlp-file-format for more details.  ncol : This format is used by the Large Graph Layout progra. It is simply a symbolic weighted edge list. It is a simple text file with one edge per line. An edge is defined by two symbolic vertex names separated by whitespace. (The symbolic vertex names themselves cannot contain whitespace.) They might followed by an optional number, this will be the weight of the edge. See: http://bioinformatics.icmb.utexas.edu/lgl for more details.The map operand should includes following elements:Available formats:  pajek : Pajek (Slovene word for Spider) is a program, for Windows, for analysis and visualization of large networks. See: http://pajek.imfm.si/doku.php?id=pajek for more details. lgl : LGL is a compendium of applications for making the visualization of large networks and trees tractable. See: http://lgl.sourceforge.net/ for more details. dot : DOT is a plain text graph description language. It is a simple way of describing graphs that both humans and computer programs can use. See: http://en.wikipedia.org/wiki/DOT_language for more details. edge : This format is a simple text file with numeric vertex ids defining the edges. gexf : GEXF (Graph Exchange XML Format) is a language for describing complex networks structures, their associated data and dynamics. Started in 2007 at Gephi project by different actors, deeply involved in graph exchange issues, the gexf specifications are mature enough to claim being both extensible and open, and suitable for real specific applications. See: http://gexf.net/format/ for more details. graphml : GraphML is a comprehensive and easy-to-use file format for graphs based on XML. See: http://graphml.graphdrawing.org/ for more details. tlp  or  tulip : TLP is the Tulip software graph format. See: http://tulip.labri.fr/TulipDrupal/?q=tlp-file-format for more details.  ncol : This format is used by the Large Graph Layout progra. It is simply a symbolic weighted edge list. It is a simple text file with one edge per line. An edge is defined by two symbolic vertex names separated by whitespace. (The symbolic vertex names themselves cannot contain whitespace.) They might followed by an optional number, this will be the weight of the edge. See: http://bioinformatics.icmb.utexas.edu/lgl for more details.The map operand should includes following elements:  Special cases:     format : the format of the file    filename : the filename of the file containing the network    edges_species : the species of edges    vertices_specy : the species of vertices    format : the format of the file    filename : the filename of the file containing the network    edges_species : the species of edges    vertices_specy : the species of vertices    format : the format of the file,  file : the file containing the network,  edges_species : the species of edges,  vertices_specy : the species of vertices       graph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(     pajek ,     example_of_Pajek_file ,    myVertexSpecy,    myEdgeSpecy );           filename : the filename of the file containing the network,  edges_species : the species of edges,  vertices_specy : the species of vertices       graph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(     pajek ,     ./example_of_Pajek_file ,    myVertexSpecy,    myEdgeSpecy );           file : the file containing the network       graph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(     pajek ,     example_of_Pajek_file );           format : the format of the file,  file : the file containing the network       graph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(     pajek ,     example_of_Pajek_file );           format : the format of the file,  filename : the filename of the file containing the network       graph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(     pajek ,     example_of_Pajek_file );       Examples:  graph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(    pajek,    ./example_of_Pajek_file,    myVertexSpecy,    myEdgeSpecy); graph<myVertexSpecy,myEdgeSpecy> myGraph <- load_graph_from_file(    pajek,    ./example_of_Pajek_file,    myVertexSpecy,    myEdgeSpecy , true);     ### load_shortest_paths  Possible use:    graph load_shortest_paths matrix —>  graph   load_shortest_paths (graph , matrix) —>  graph   Result: put in the graph cache the computed shortest paths contained in the matrix (rows: source, columns: target)  Examples:  graph var0 <- load_shortest_paths(shortest_paths_matrix);  // var0 equals return my_graph with all the shortest paths computed     ### log  Possible use:    log (float) —>  float   log (int) —>  float   Result: Returns the logarithm (base 10) of the operand.  Special cases:    an exception is raised if the operand is equals or less than zero.   Examples:  float var0 <- log(10);  // var0 equals 1.0 float var1 <- log(1);  // var1 equals 0.0   See also: ln,    ### lower_case  Possible use:    lower_case (string) —>  string   Result: Converts all of the characters in the string operand to lower case  Examples:  string var0 <- lower_case(Abc);  // var0 equals  abc    See also: upper_case,    ### map  Possible use:    map (any) —>  map   Result: Casts the operand into the type map    ### masked_by  Possible use:    geometry masked_by container<geometry> —>  geometry   masked_by (geometry , container<geometry>) —>  geometry   masked_by (geometry, container<geometry>, int) —>  geometry   Examples:  geometry var0 <- perception_geom masked_by obstacle_list;  // var0 equals the geometry representing the part of perception_geom visible from the agent position considering the list of obstacles obstacle_list. geometry var1 <- perception_geom masked_by obstacle_list;  // var1 equals the geometry representing the part of perception_geom visible from the agent position considering the list of obstacles obstacle_list.     ### material  Possible use:    float material float —>  msi.gama.util.GamaMaterial   material (float , float) —>  msi.gama.util.GamaMaterial   Result: Returns  Examples:           See also: ,    ### matrix  Possible use:    matrix (any) —>  matrix   Result: Casts the operand into the type matrix    ### matrix_with  Possible use:    point matrix_with any expression —>  matrix   matrix_with (point , any expression) —>  matrix   Result: creates a matrix with a size provided by the first operand, and filled with the second operand  Comment: Note that both components of the right operand point should be positive, otherwise an exception is raised.  See also: matrix, as_matrix,    ### max  Possible use:    max (container) —>  unknown   Result: the maximum element found in the operand  Comment: the max operator behavior depends on the nature of the operand  Special cases:    if it is a population of a list of other type: max transforms all elements into integer and returns the maximum of them   if it is a map, max returns the maximum among the list of all elements value   if it is a file, max returns the maximum of the content of the file (that is also a container)   if it is a graph, max returns the maximum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)   if it is a matrix of int, float or object, max returns the maximum of all the numerical elements (thus all elements for integer and float matrices)   if it is a matrix of geometry, max returns the maximum of the list of the geometries   if it is a matrix of another type, max returns the maximum of the elements transformed into float   if it is a list of int of float, max returns the maximum of all the elements       unknown var0 <- max ([100, 23.2, 34.5]);  // var0 equals 100.0          if it is a list of points: max returns the maximum of all points as a point (i.e. the point with the greatest coordinate on the x-axis, in case of equality the point with the greatest coordinate on the y-axis is chosen. If all the points are equal, the first one is returned. )       unknown var1 <- max([{1.0,3.0},{3.0,5.0},{9.0,1.0},{7.0,8.0}]);  // var1 equals {9.0,1.0}       See also: min,    ### max_of  Possible use:    container max_of any expression —>  unknown   max_of (container , any expression) —>  unknown   Result: the maximum value of the right-hand expression evaluated on each of the elements of the left-hand operand  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    As of GAMA 1.6, if the left-hand operand is nil or empty, max_of throws an error   if the left-operand is a map, the keyword each will contain each value       unknown var5 <- [1::2, 3::4, 5::6] max_of (each + 3);  // var5 equals 6       Examples:  unknown var1 <- [1,2,4,3,5,7,6,8] max_of (each * 100 );  // var1 equals 800 graph g2 <- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); unknown var3 <- g2.vertices max_of (g2 degree_of( each ));  // var3 equals 2 unknown var4 <- (list(node) max_of (round(node(each).location.x));  // var4 equals 96   See also: min_of,    ### maximal_cliques_of  Possible use:    maximal_cliques_of (graph) —>  list<list>   Result: returns the maximal cliques of a graph using the Bron-Kerbosch clique detection algorithm: A clique is maximal if it is impossible to enlarge it by adding another vertex from the graph. Note that a maximal clique is not necessarily the biggest clique in the graph.  Examples:  graph my_graph <- graph([]); list<list> var1 <- maximal_cliques_of (my_graph);  // var1 equals the list of all the maximal cliques as list   See also: biggest_cliques_of,    ### mean  Possible use:    mean (container) —>  unknown   Result: the mean of all the elements of the operand  Comment: the elements of the operand are summed (see sum for more details about the sum of container elements ) and then the sum value is divided by the number of elements.  Special cases:    if the container contains points, the result will be a point. If the container contains rgb values, the result will be a rgb color   Examples:  unknown var0 <- mean ([4.5, 3.5, 5.5, 7.0]);  // var0 equals 5.125    See also: sum,    ### mean_deviation  Possible use:    mean_deviation (container) —>  float   Result: the deviation from the mean of all the elements of the operand. See Mean_deviation for more details.  Comment: The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.  Examples:  float var0 <- mean_deviation ([4.5, 3.5, 5.5, 7.0]);  // var0 equals 1.125   See also: mean, standard_deviation,    ### mean_of  Possible use:    container mean_of any expression —>  unknown   mean_of (container , any expression) —>  unknown   Result: the mean of the right-hand expression evaluated on each of the elements of the left-hand operand  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    if the left-operand is a map, the keyword each will contain each value       unknown var2 <- [1::2, 3::4, 5::6] mean_of (each);  // var2 equals 4       Examples:  unknown var1 <- [1,2] mean_of (each * 10 );  // var1 equals 15   See also: min_of, max_of, sum_of, product_of,    ### meanR  Possible use:    meanR (container) —>  unknown   Result: returns the mean value of given vector (right-hand operand) in given variable  (left-hand operand).  Examples:  list<int> X <- [2, 3, 1]; int var1 <- meanR(X);  // var1 equals 2     ### median  Possible use:    median (container) —>  unknown   Result: the median of all the elements of the operand.  Special cases:    if the container contains points, the result will be a point. If the container contains rgb values, the result will be a rgb color   Examples:  unknown var0 <- median ([4.5, 3.5, 5.5, 3.4, 7.0]);  // var0 equals 5.0   See also: mean,    ### message  Possible use:    message (unknown) —>  msi.gama.extensions.messaging.GamaMessage   Result: to be added    ### milliseconds_between  Possible use:    date milliseconds_between date —>  float   milliseconds_between (date , date) —>  float   Result: Provide the exact number of milliseconds between two dates. This number can be positive or negative (if the second operand is smaller than the first one)  Examples:  milliseconds_between(d1, d2) -: 10      ### min  Possible use:    min (container) —>  unknown   Result: the minimum element found in the operand.  Comment: the min operator behavior depends on the nature of the operand  Special cases:    if it is a list of points: min returns the minimum of all points as a point (i.e. the point with the smallest coordinate on the x-axis, in case of equality the point with the smallest coordinate on the y-axis is chosen. If all the points are equal, the first one is returned. )   if it is a population of a list of other types: min transforms all elements into integer and returns the minimum of them   if it is a map, min returns the minimum among the list of all elements value   if it is a file, min returns the minimum of the content of the file (that is also a container)   if it is a graph, min returns the minimum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)   if it is a matrix of int, float or object, min returns the minimum of all the numerical elements (thus all elements for integer and float matrices)   if it is a matrix of geometry, min returns the minimum of the list of the geometries   if it is a matrix of another type, min returns the minimum of the elements transformed into float   if it is a list of int or float: min returns the minimum of all the elements       unknown var0 <- min ([100, 23.2, 34.5]);  // var0 equals 23.2       See also: max,    ### min_of  Possible use:    container min_of any expression —>  unknown   min_of (container , any expression) —>  unknown   Result: the minimum value of the right-hand expression evaluated on each of the elements of the left-hand operand  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    if the left-hand operand is nil or empty, min_of throws an error   if the left-operand is a map, the keyword each will contain each value       unknown var5 <- [1::2, 3::4, 5::6] min_of (each + 3);  // var5 equals 5       Examples:  unknown var1 <- [1,2,4,3,5,7,6,8] min_of (each * 100 );  // var1 equals 100 graph g2 <- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); unknown var3 <- g2 min_of (length(g2 out_edges_of each) );  // var3 equals 0 unknown var4 <- (list(node) min_of (round(node(each).location.x));  // var4 equals 4   See also: max_of,    ### minus_days  Possible use:    date minus_days int —>  date   minus_days (date , int) —>  date   Result: Subtract a given number of days from a date  Examples:  date1 minus_days 20     ### minus_hours  Possible use:    date minus_hours int —>  date   minus_hours (date , int) —>  date   Result: Remove a given number of hours from a date  Examples:  date1 minus_hours 15 // equivalent to date1 - 15 #h     ### minus_minutes  Possible use:    date minus_minutes int —>  date   minus_minutes (date , int) —>  date   Result: Subtract a given number of minutes from a date  Examples:  date1 minus_minutes 5 // equivalent to date1 - 5#mn     ### minus_months  Possible use:    date minus_months int —>  date   minus_months (date , int) —>  date   Result: Subtract a given number of months from a date  Examples:  date1 minus_months 5     ### minus_ms  Possible use:    date minus_ms int —>  date   minus_ms (date , int) —>  date   Result: Remove a given number of milliseconds from a date  Examples:  date1 minus_ms 15 // equivalent to date1 - 15 #ms     ### minus_seconds Same signification as -    ### minus_weeks  Possible use:    date minus_weeks int —>  date   minus_weeks (date , int) —>  date   Result: Subtract a given number of weeks from a date  Examples:  date1 minus_weeks 15     ### minus_years  Possible use:    date minus_years int —>  date   minus_years (date , int) —>  date   Result: Subtract a given number of year from a date  Examples:  date1 minus_years 3     ### mod  Possible use:    int mod int —>  int   mod (int , int) —>  int   Result: Returns the remainder of the integer division of the left-hand operand by the right-hand operand.  Special cases:    if operands are float, they are truncated   if the right-hand operand is equal to zero, raises an exception.   Examples:  int var0 <- 40 mod 3;  // var0 equals 1   See also: div,    ### months_between  Possible use:    date months_between date —>  int   months_between (date , date) —>  int   Result: Provide the exact number of months between two dates. This number can be positive or negative (if the second operand is smaller than the first one)  Examples:  months_between(d1, d2) -: 10      ### moran  Possible use:    list<float> moran matrix<float> —>  float   moran (list<float> , matrix<float>) —>  float   Special cases:    return the Moran Index of the given list of interest points (list of floats) and the weight matrix (matrix of float)       float var0 <- moran([1.0, 0.5, 2.0], weight_matrix);  // var0 equals the Moran index computed         ### mul  Possible use:    mul (container) —>  unknown   Result: the product of all the elements of the operand  Comment: the mul operator behavior depends on the nature of the operand  Special cases:    if it is a list of points: mul returns the product of all points as a point (each coordinate is the product of the corresponding coordinate of each element)   if it is a list of other types: mul transforms all elements into integer and multiplies them   if it is a map, mul returns the product of the value of all elements   if it is a file, mul returns the product of the content of the file (that is also a container)   if it is a graph, mul returns the product of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)   if it is a matrix of int, float or object, mul returns the product of all the numerical elements (thus all elements for integer and float matrices)   if it is a matrix of geometry, mul returns the product of the list of the geometries   if it is a matrix of other types: mul transforms all elements into float and multiplies them   if it is a list of int or float: mul returns the product of all the elements       unknown var0 <- mul ([100, 23.2, 34.5]);  // var0 equals 80040.0       See also: sum, ","url":"wiki/OperatorsDM.md"},{"id":"wiki/OperatorsNZ.md","title":" Operators (N to Z)","content":"Operators (N to Z)    This file is automatically generated from java files. Do Not Edit It.    Definition  Operators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function.  Most of them use a classical prefixed functional syntax (i.e. operator_name(operand1, operand2, operand3), see below), with the exception of arithmetic (e.g. +, /), logical (and, or), comparison (e.g. >, <), access (., [..]) and pair (::) operators, which require an infixed notation (i.e. operand1 operator_symbol operand1).  The ternary functional if-else operator, ? :, uses a special infixed syntax composed with two symbols (e.g. operand1 ? operand2 : operand3). Two unary operators (- and !) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g.   - 10, ! (operand1 or operand2) ).  Finally, special constructor operators ({...} for constructing points, [...] for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. {1,2,3}, [operand1, operand2, ..., operandn] or [key1::value1, key2::value2... keyn::valuen]).  With the exception of these special cases above, the following rules apply to the syntax of operators: * if they only have one operand, the functional prefixed syntax is mandatory (e.g. operator_name(operand1)) * if they have two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2)) or the infixed syntax (e.g. operand1 operator_name operand2) can be used. * if they have more than two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2, ..., operand)) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. operand1 operator_name(operand2, ..., operand)) can be used.  All of these alternative syntaxes are completely equivalent.  Operators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.    Priority between operators  The priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.  GAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely: * the constructor operators, like ::, used to compose pairs of operands, have the lowest priority of all operators (e.g. a > b :: b > c will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, [a > 10, b > 5] will return a list of boolean values. * it is followed by the ?: operator, the functional if-else (e.g.   a > b ? a + 10 : a - 10 will return the result of the if-else). * next are the logical operators, and and or (e.g. a > b or b > c will return the value of the test) * next are the comparison operators (i.e. >, <, <=, >=, =, !=) * next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators) * next the unary operators - and ! * next the access operators . and [] (e.g. {1,2,3}.x > 20 + {4,5,6}.y  will return the result of the comparison between the x and y ordinates of the two points) * and finally the functional operators, which have the highest priority of all.    Using actions as operators  Actions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.  For instance, if the following species is defined:   species spec1 {  int min(int x, int y) {       return x > y ? x : y;  } }   Any agent instance of spec1 can use min as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:   global {  init {       create spec1;       spec1 my_agent <- spec1[0];       int the_min <- my_agent min(10,20); // or min(my_agent, 10, 20);  } }   If the action doesn t have any operands, the syntax to use is my_agent the_action(). Finally, if it does not return a value, it might still be used but is considering as returning a value of type unknown (e.g. unknown result <- my_agent the_action(op1, op2);).  Note that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).    Table of Contents    Operators by categories    3D box, cone3D, cube, cylinder, dem, hexagon, pyramid, rgb_to_xyz, set_z, sphere, teapot,    Arithmetic operators -, /, [^](OperatorsAC#^), [](OperatorsAC#), +, abs, acos, asin, atan, atan2, ceil, cos, cos_rad, div, even, exp, fact, floor, hypot, is_finite, is_number, ln, log, mod, round, signum, sin, sin_rad, sqrt, tan, tan_rad, tanh, with_precision,    BDI and, eval_when, get_about, get_agent, get_agent_cause, get_decay, get_dominance, get_familiarity, get_intensity, get_lifetime, get_liking, get_praiseworthiness, get_priority, get_solidarity, get_super_intention, new_emotion, new_predicate, new_social_link, or, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_liking, set_solidarity, set_truth, with_lifetime, with_praiseworthiness, with_priority, with_values,    Casting operators as, as_int, as_matrix, font, is, is_skill, list_with, matrix_with, species, to_gaml, topology,    Color-related operators -, /, [](OperatorsAC#), +, blend, brewer_colors, brewer_palettes, grayscale, hsb, mean, median, rgb, rnd_color, sum,    Comparison operators !=, <, <=, =, >, >=, between,    Containers-related operators -, ::, +, accumulate, among, at, collect, contains, contains_all, contains_any, count, distinct, empty, every, first, first_with, get, group_by, in, index_by, inter, interleave, internal_at, internal_integrated_value, last, last_with, length, max, max_of, mean, mean_of, median, min, min_of, mul, one_of, product_of, range, reverse, shuffle, sort_by, sum, sum_of, union, variance_of, where, with_max_of, with_min_of,    Date-related operators -, !=, +, <, <=, =, >, >=, after, before, between, every, milliseconds_between, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_weeks, minus_years, months_between, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_weeks, plus_years, since, to, until, years_between,    Dates    Driving operators as_driving_graph,    edge edge_between,    EDP-related operators diff, diff2, internal_zero_order_equation,    Files-related operators crs, file, file_exists, folder, get, new_folder, osm_file, read, writable,    FIPA-related operators conversation, message,    Graphs-related operators add_edge, add_node, adjacency, agent_from_geometry, all_pairs_shortest_path, alpha_index, as_distance_graph, as_edge_graph, as_intersection_graph, as_path, beta_index, betweenness_centrality, biggest_cliques_of, connected_components_of, connectivity_index, contains_edge, contains_vertex, degree_of, directed, edge, edge_between, edge_betweenness, edges, gamma_index, generate_barabasi_albert, generate_complete_graph, generate_watts_strogatz, grid_cells_to_graph, in_degree_of, in_edges_of, layout, load_graph_from_file, load_shortest_paths, maximal_cliques_of, nb_cycles, neighbors_of, node, nodes, out_degree_of, out_edges_of, path_between, paths_between, predecessors_of, remove_node_from, rewire_n, source_of, spatial_graph, successors_of, sum, target_of, undirected, use_cache, weight_of, with_optimizer_type, with_weights,    Grid-related operators as_4_grid, as_grid, as_hexagonal_grid, grid_at, path_between,    Iterator operators accumulate, as_map, collect, count, distribution_of, distribution_of, distribution_of, distribution2d_of, distribution2d_of, distribution2d_of, first_with, frequency_of, group_by, index_by, last_with, max_of, mean_of, min_of, product_of, sort_by, sum_of, variance_of, where, with_max_of, with_min_of,    List-related operators copy_between, index_of, last_index_of,    Logical operators :, !, ?, and, or,    Map comparaison operators fuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,    Map-related operators as_map, index_of, last_index_of,    Material material,    Matrix-related operators -, /, ., [](OperatorsAC#), +, append_horizontally, append_vertically, column_at, columns_list, determinant, eigenvalues, index_of, inverse, last_index_of, row_at, rows_list, shuffle, trace, transpose,    multicriteria operators electre_DM, evidence_theory_DM, promethee_DM, weighted_means_DM,    Path-related operators agent_from_geometry, all_pairs_shortest_path, as_path, load_shortest_paths, path_between, path_to, paths_between, use_cache,    Points-related operators -, /, [](OperatorsAC#), +, <, <=, >, >=, add_point, angle_between, any_location_in, centroid, closest_points_with, farthest_point_to, grid_at, norm, point, points_along, points_at, points_on,    Random operators binomial, flip, gauss, poisson, rnd, rnd_choice, sample, shuffle, skew_gauss, truncated_gauss,    ReverseOperators    Shape arc, box, circle, cone, cone3D, cross, cube, curve, cylinder, ellipse, envelope, geometry_collection, hexagon, line, link, plan, polygon, polyhedron, pyramid, rectangle, sphere, square, squircle, teapot, triangle,    Spatial operators -, [](OperatorsAC#), +, add_point, agent_closest_to, agent_farthest_to, agents_at_distance, agents_inside, agents_overlapping, angle_between, any_location_in, arc, around, as_4_grid, as_grid, as_hexagonal_grid, at_distance, at_location, box, centroid, circle, clean, closest_points_with, closest_to, cone, cone3D, convex_hull, covers, cross, crosses, crs, CRS_transform, cube, curve, cylinder, dem, direction_between, disjoint_from, distance_between, distance_to, ellipse, envelope, farthest_point_to, farthest_to, geometry_collection, gini, hexagon, hierarchical_clustering, IDW, inside, inter, intersects, line, link, masked_by, moran, neighbors_at, neighbors_of, overlapping, overlaps, partially_overlaps, path_between, path_to, plan, points_along, points_at, points_on, polygon, polyhedron, pyramid, rectangle, rgb_to_xyz, rotated_by, round, scaled_to, set_z, simple_clustering_by_distance, simplification, skeletonize, smooth, sphere, split_at, split_geometry, split_lines, square, squircle, teapot, to_GAMA_CRS, to_rectangles, to_squares, touches, towards, transformed_by, translated_by, triangle, triangulate, union, using, voronoi, with_precision, without_holes,    Spatial properties operators covers, crosses, intersects, partially_overlaps, touches,    Spatial queries operators agent_closest_to, agent_farthest_to, agents_at_distance, agents_inside, agents_overlapping, at_distance, closest_to, farthest_to, inside, neighbors_at, neighbors_of, overlapping,    Spatial relations operators direction_between, distance_between, distance_to, path_between, path_to, towards,    Spatial statistical operators hierarchical_clustering, simple_clustering_by_distance,    Spatial transformations operators -, [](OperatorsAC#), +, as_4_grid, as_grid, as_hexagonal_grid, at_location, clean, convex_hull, CRS_transform, rotated_by, scaled_to, simplification, skeletonize, smooth, split_geometry, split_lines, to_GAMA_CRS, to_rectangles, to_squares, transformed_by, translated_by, triangulate, voronoi, without_holes,    Species-related operators index_of, last_index_of, of_generic_species, of_species,    Statistical operators build, corR, dbscan, distribution_of, distribution2d_of, frequency_of, gamma_rnd, geometric_mean, gini, harmonic_mean, hierarchical_clustering, kmeans, kurtosis, max, mean, mean_deviation, meanR, median, min, moran, mul, predict, simple_clustering_by_distance, skewness, standard_deviation, sum, variance,    Strings-related operators +, <, <=, >, >=, at, char, contains, contains_all, contains_any, copy_between, date, empty, first, in, indented_by, index_of, is_number, last, last_index_of, length, lower_case, replace, replace_regex, reverse, sample, shuffle, split_with, string, upper_case,    System ., command, copy, dead, eval_gaml, every, user_input,    Time-related operators date, string,    Types-related operators    User control operators user_input,    Operators    ### nb_cycles  Possible use:    nb_cycles (graph) —>  int   Result: returns the maximum number of independent cycles in a graph. This number (u) is estimated through the number of nodes (v), links (e) and of sub-graphs (p): u = e - v + p.  Examples:  graph graphEpidemio <- graph([]); int var1 <- nb_cycles(graphEpidemio);  // var1 equals the number of cycles in the graph   See also: alpha_index, beta_index, gamma_index, connectivity_index,    ### neighbors_at  Possible use:    geometry neighbors_at float —>  container   neighbors_at (geometry , float) —>  container   Result: a list, containing all the agents of the same species than the left argument (if it is an agent) located at a distance inferior or equal to the right-hand operand to the left-hand operand (geometry, agent, point).  Comment: The topology used to compute the neighborhood  is the one of the left-operand if this one is an agent; otherwise the one of the agent applying the operator.  Examples:  container var0 <- (self neighbors_at (10));  // var0 equals all the agents located at a distance lower or equal to 10 to the agent applying the operator.   See also: neighbors_of, closest_to, overlapping, agents_overlapping, agents_inside, agent_closest_to, at_distance,    ### neighbors_of  Possible use:    graph neighbors_of unknown —>  container   neighbors_of (graph , unknown) —>  container   topology neighbors_of agent —>  container   neighbors_of (topology , agent) —>  container   neighbors_of (topology, geometry, float) —>  container   Result: a list, containing all the agents of the same species than the argument (if it is an agent) located at a distance inferior or equal to 1 to the right-hand operand agent considering the left-hand operand topology.  Special cases:    a list, containing all the agents of the same species than the left argument (if it is an agent) located at a distance inferior or equal to the third argument to the second argument (agent, geometry or point) considering the first operand topology.       container var3 <- neighbors_of (topology(self), self,10);  // var3 equals all the agents located at a distance lower or equal to 10 to the agent applying the operator considering its topology.       Examples:  container var0 <- graphEpidemio neighbors_of (node(3));  // var0 equals [node0,node2] container var1 <- graphFromMap neighbors_of node({12,45});  // var1 equals [{1.0,5.0},{34.0,56.0}] container var2 <- topology(self) neighbors_of self;  // var2 equals returns all the agents located at a distance lower or equal to 1 to the agent applying the operator considering its topology.   See also: predecessors_of, successors_of, neighbors_at, closest_to, overlapping, agents_overlapping, agents_inside, agent_closest_to,    ### new_emotion  Possible use:    new_emotion (string) —>  emotion   string new_emotion agent —>  emotion   new_emotion (string , agent) —>  emotion   string new_emotion float —>  emotion   new_emotion (string , float) —>  emotion   string new_emotion predicate —>  emotion   new_emotion (string , predicate) —>  emotion   new_emotion (string, float, predicate) —>  emotion   new_emotion (string, float, float) —>  emotion   new_emotion (string, predicate, agent) —>  emotion   new_emotion (string, float, agent) —>  emotion   new_emotion (string, float, float, agent) —>  emotion   new_emotion (string, float, predicate, float) —>  emotion   new_emotion (string, float, predicate, agent) —>  emotion   new_emotion (string, float, predicate, float, agent) —>  emotion   Result: a new emotion with the given properties (name) a new emotion with the given properties (name) a new emotion with the given properties (name,intensity,about) a new emotion with the given properties (name,intensity,decay) a new emotion with the given properties (name) a new emotion with the given properties (name, intensity) a new emotion with the given properties (name,about) a new emotion with the given properties (name) a new emotion with the given properties (name) a new emotion with the given properties (name) a new emotion with the given properties (name) a new emotion with the given properties (name)  Examples:  emotion(joy,12.3,eatFood,4) emotion(joy,12.3,eatFood,4) emotion(joy,12.3,eatFood) emotion(joy,12.3,4) emotion(joy,12.3,eatFood,4) emotion(joy,12.3) emotion(joy,eatFood) emotion(joy) emotion(joy,12.3,eatFood,4) emotion(joy,12.3,eatFood,4) emotion(joy,12.3,eatFood,4) emotion(joy,12.3,eatFood,4)     ### new_folder  Possible use:    new_folder (string) —>  file   Result: opens an existing repository or create a new folder if it does not exist.  Special cases:    If the specified string does not refer to an existing repository, the repository is created.   If the string refers to an existing file, an exception is risen.   Examples:  file dirNewT <- new_folder(incl/);    // dirNewT represents the repository ../incl/                // eventually creates the directory ../incl   See also: folder, file,    ### new_predicate  Possible use:    new_predicate (string) —>  predicate   string new_predicate agent —>  predicate   new_predicate (string , agent) —>  predicate   string new_predicate float —>  predicate   new_predicate (string , float) —>  predicate   string new_predicate int —>  predicate   new_predicate (string , int) —>  predicate   string new_predicate map —>  predicate   new_predicate (string , map) —>  predicate   string new_predicate bool —>  predicate   new_predicate (string , bool) —>  predicate   new_predicate (string, map, float) —>  predicate   new_predicate (string, map, int) —>  predicate   new_predicate (string, map, agent) —>  predicate   new_predicate (string, map, bool) —>  predicate   new_predicate (string, map, int, bool) —>  predicate   new_predicate (string, map, bool, agent) —>  predicate   new_predicate (string, map, float, int) —>  predicate   new_predicate (string, map, int, agent) —>  predicate   new_predicate (string, map, float, agent) —>  predicate   new_predicate (string, map, float, bool) —>  predicate   new_predicate (string, map, float, int, bool) —>  predicate   new_predicate (string, map, int, bool, agent) —>  predicate   new_predicate (string, map, float, bool, agent) —>  predicate   new_predicate (string, map, float, int, agent) —>  predicate   new_predicate (string, map, float, int, bool, agent) —>  predicate   Result: a new predicate with the given properties (name, values, lifetime, is_true) a new predicate with the given properties (name, values, priority) a new predicate with the given properties (name, values, priority, lifetime, is_true, agentCause) a new predicate with the given properties (name, values, is_true, agentCause) a new predicate with the given properties (name, values, lifetime) a new predicate with the given properties (name, values, priority, lifetime, is_true) a new predicate with the given properties (name, values, lifetime, is_true, agentCause) a new predicate with the given is_true (name, priority) a new predicate with the given is_true (name, lifetime) a new predicate with the given properties (name, values) a new predicate with the given properties (name, values, lifetime) a new predicate with the given is_true (name, is_true) a new predicate with the given properties (name, values, priority,lifetime) a new predicate with the given properties (name, values, priority, is_true, agentCause) a new predicate with the given properties (name, values,  agentCause) a new predicate with the given properties (name, values, lifetime, agentCause) a new predicate with the given properties (name) a new predicate with the given properties (name, values, priority, agentCause) a new predicate with the given properties (name, values, priority, is_true) a new predicate with the given properties (name, values, priority, lifetime, agentCause) a new predicate with the given properties (name, values, is_true)  Examples:  predicate(people to meet, [time::10], 10,true) predicate(people to meet, people1, [time::10]) predicate(people to meet, [time::10],2.0,10, true, agentA) predicate(people to meet, [time::10], true, agentA) predicate(people to meet, [time::10], true) predicate(people to meet, [time::10],2.0,10, true) predicate(people to meet, [time::10], 10, true, agentA) predicate(hasWater, 2.0 ) predicate(hasWater, 10  predicate(people to meet, people1 ) predicate(people to meet, [time::10], true) predicate(hasWater, true) predicate(people to meet, [time::10], 2.0,10) predicate(people to meet, [time::10], 2.0, true, agentA) predicate(people to meet, [time::10], agentA) predicate(people to meet, [time::10], 10, agentA) predicate(people to meet) predicate(people to meet, [time::10], 2.0,agentA) predicate(people to meet, [time::10],2.0, true) predicate(people to meet, [time::10], 2.0,10,agentA) predicate(people to meet, [time::10], true)     ### new_social_link  Possible use:    new_social_link (agent) —>  msi.gaml.architecture.simplebdi.SocialLink   new_social_link (agent, float, float, float, float) —>  msi.gaml.architecture.simplebdi.SocialLink   Result: a new social link a new social link  Examples:  new_social_link(agentA) new_social_link(agentA,0.0,-0.1,0.2,0.1)     ### node  Possible use:    node (unknown) —>  unknown   unknown node float —>  unknown   node (unknown , float) —>  unknown     ### nodes  Possible use:    nodes (container) —>  container     ### norm  Possible use:    norm (point) —>  float   Result: the norm of the vector with the coordinates of the point operand.  Examples:  float var0 <- norm({3,4});  // var0 equals 5.0     ### not Same signification as !    ### obj_file  Possible use:    obj_file (string) —>  file   Result: Constructs a file of type obj. Allowed extensions are limited to obj, OBJ    ### of Same signification as .    ### of_generic_species  Possible use:    container of_generic_species species —>  container   of_generic_species (container , species) —>  container   Result: a list, containing the agents of the left-hand operand whose species is that denoted by the right-hand operand and whose species extends the right-hand operand species  Examples:  // species test {} // species sous_test parent: test {} container var2 <- [sous_test(0),sous_test(1),test(2),test(3)] of_generic_species test;  // var2 equals [sous_test0,sous_test1,test2,test3] container var3 <- [sous_test(0),sous_test(1),test(2),test(3)] of_generic_species sous_test;  // var3 equals [sous_test0,sous_test1] container var4 <- [sous_test(0),sous_test(1),test(2),test(3)] of_species test;  // var4 equals [test2,test3] container var5 <- [sous_test(0),sous_test(1),test(2),test(3)] of_species sous_test;  // var5 equals [sous_test0,sous_test1]   See also: of_species,    ### of_species  Possible use:    container of_species species —>  container   of_species (container , species) —>  container   Result: a list, containing the agents of the left-hand operand whose species is the one denoted by the right-hand operand.The expression agents of_species (species self) is equivalent to agents where (species each = species self); however, the advantage of using the first syntax is that the resulting list is correctly typed with the right species, whereas, in the second syntax, the parser cannot determine the species of the agents within the list (resulting in the need to cast it explicitly if it is to be used in an ask statement, for instance).  Special cases:    if the right operand is nil, of_species returns the right operand   Examples:  container var0 <- (self neighbors_at 10) of_species (species (self));  // var0 equals all the neighboring agents of the same species. container var1 <- [test(0),test(1),node(1),node(2)] of_species test;  // var1 equals [test0,test1]   See also: of_generic_species,    ### one_of  Possible use:    one_of (container<KeyType,ValueType>) —>  ValueType   Result: one of the values stored in this container  at a random key  Comment: the one_of operator behavior depends on the nature of the operand  Special cases:    if it is a graph, one_of returns one of the lists of edges   if it is a file, one_of returns one of the elements of the content of the file (that is also a container)   if the operand is empty, one_of returns nil                if it is a list or a matrix, one_of returns one of the values of the list or of the matrix       int i <- any ([1,2,3]);  // i equals 1, 2 or 3 string sMat <- one_of(matrix([[ c11 , c12 , c13 ],[ c21 , c22 , c23 ]]));  // sMat equals  c11 , c12 , c13 ,  c21 , c22  or  c23           if it is a map, one_of returns one the value of a random pair of the map       int im <- one_of ([2::3, 4::5, 6::7]); // im equals 3, 5 or 7 bool var6 <- [2::3, 4::5, 6::7].values contains im;  // var6 equals true          if it is a population, one_of returns one of the agents of the population       bug b <- one_of(bug);   // Given a previously defined species bug, b is one of the created bugs, e.g. bug3       See also: contains,    ### or  Possible use:    bool or any expression —>  bool   or (bool , any expression) —>  bool   Result: a bool value, equal to the logical or between the left-hand operand and the right-hand operand.  Comment: both operands are always casted to bool before applying the operator. Thus, an expression like 1 or 0 is accepted and returns true.  See also: bool, and, !,    ### or  Possible use:    predicate or predicate —>  predicate   or (predicate , predicate) —>  predicate   Result: create a new predicate from two others by including them as subintentions. It s an exclusive  or   Examples:  predicate1 or predicate2     ### osm_file  Possible use:    string osm_file map<string,list> —>  file   osm_file (string , map<string,list>) —>  file   osm_file (string, map<string,list>, int) —>  file   Result: opens a file that a is a kind of OSM file with some filtering. opens a file that a is a kind of OSM file with some filtering, forcing the initial CRS to be the one indicated by the second int parameter (see http://spatialreference.org/ref/epsg/). If this int parameter is equal to 0, the data is considered as already projected.  Comment: The file should have a OSM file extension, cf. file type definition for supported file extensions.The file should have a OSM file extension, cf. file type definition for supported file extensions.  Special cases:    If the specified string does not refer to an existing OSM file, an exception is risen.   If the specified string does not refer to an existing OSM file, an exception is risen.   Examples:  file myOSMfile <- osm_file(../includes/rouen.osm, [highway::[primary,motorway]]); file myOSMfile2 <- osm_file(../includes/rouen.osm,[highway::[primary,motorway]], 0);   See also: file,    ### out_degree_of  Possible use:    graph out_degree_of unknown —>  int   out_degree_of (graph , unknown) —>  int   Result: returns the out degree of a vertex (right-hand operand) in the graph given as left-hand operand.  Examples:  int var1 <- graphFromMap out_degree_of (node(3));  // var1 equals 4   See also: in_degree_of, degree_of,    ### out_edges_of  Possible use:    graph out_edges_of unknown —>  container   out_edges_of (graph , unknown) —>  container   Result: returns the list of the out-edges of a vertex (right-hand operand) in the graph given as left-hand operand.  Examples:  container var1 <- graphFromMap out_edges_of (node(3));  // var1 equals 3   See also: in_edges_of,    ### overlapping  Possible use:    container<agent> overlapping geometry —>  list<geometry>   overlapping (container<agent> , geometry) —>  list<geometry>   Result: A list of agents or geometries among the left-operand list, species or meta-population (addition of species), overlapping the operand (casted as a geometry).  Examples:  list<geometry> var0 <- [ag1, ag2, ag3] overlapping(self);  // var0 equals return the agents among ag1, ag2 and ag3 that overlap the shape of the agent applying the operator. (species1 + species2) overlapping self   See also: neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, agents_overlapping,    ### overlaps  Possible use:    geometry overlaps geometry —>  bool   overlaps (geometry , geometry) —>  bool   Result: A boolean, equal to true if the left-geometry (or agent/point) overlaps the right-geometry (or agent/point).  Special cases:    if one of the operand is null, returns false.   if one operand is a point, returns true if the point is included in the geometry   Examples:  bool var0 <- polyline([{10,10},{20,20}]) overlaps polyline([{15,15},{25,25}]);  // var0 equals true bool var1 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{15,15},{15,25},{25,25},{25,15}]);  // var1 equals true bool var2 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps {25,25};  // var2 equals false bool var3 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{35,35},{35,45},{45,45},{45,35}]);  // var3 equals false bool var4 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polyline([{10,10},{20,20}]);  // var4 equals true bool var5 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps {15,15};  // var5 equals true bool var6 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{0,0},{0,30},{30,30}, {30,0}]);  // var6 equals true bool var7 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{15,15},{15,25},{25,25},{25,15}]);  // var7 equals true bool var8 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{10,20},{20,20},{20,30},{10,30}]);  // var8 equals true   See also: disjoint_from, crosses, intersects, partially_overlaps, touches,    ### pair  Possible use:    pair (any) —>  pair   Result: Casts the operand into the type pair    ### partially_overlaps  Possible use:    geometry partially_overlaps geometry —>  bool   partially_overlaps (geometry , geometry) —>  bool   Result: A boolean, equal to true if the left-geometry (or agent/point) partially overlaps the right-geometry (or agent/point).  Comment: if one geometry operand fully covers the other geometry operand, returns false (contrarily to the overlaps operator).  Special cases:    if one of the operand is null, returns false.   Examples:  bool var0 <- polyline([{10,10},{20,20}]) partially_overlaps polyline([{15,15},{25,25}]);  // var0 equals true bool var1 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{15,15},{15,25},{25,25},{25,15}]);  // var1 equals true bool var2 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps {25,25};  // var2 equals false bool var3 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{35,35},{35,45},{45,45},{45,35}]);  // var3 equals false bool var4 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polyline([{10,10},{20,20}]);  // var4 equals false bool var5 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps {15,15};  // var5 equals false bool var6 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{0,0},{0,30},{30,30}, {30,0}]);  // var6 equals false bool var7 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{15,15},{15,25},{25,25},{25,15}]);  // var7 equals true bool var8 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{10,20},{20,20},{20,30},{10,30}]);  // var8 equals false   See also: disjoint_from, crosses, overlaps, intersects, touches,    ### path  Possible use:    path (any) —>  path   Result: Casts the operand into the type path    ### path_between  Possible use:    topology path_between container<geometry> —>  path   path_between (topology , container<geometry>) —>  path   list<agent> path_between container<geometry> —>  path   path_between (list<agent> , container<geometry>) —>  path   path_between (graph, geometry, geometry) —>  path   path_between (list<agent>, geometry, geometry) —>  path   path_between (topology, geometry, geometry) —>  path   Result: The shortest path between a list of two objects in a graph The shortest path between two objects according to set of cells The shortest path between several objects according to set of cells  Examples:  path var0 <- path_between (my_graph, ag1, ag2);  // var0 equals A path between ag1 and ag2 path var1 <- my_topology path_between [ag1, ag2];  // var1 equals A path between ag1 and ag2 path var2 <- path_between (cell_grid where each.is_free, ag1, ag2);  // var2 equals A path between ag1 and ag2 passing through the given cell_grid agents path var3 <- my_topology path_between (ag1, ag2);  // var3 equals A path between ag1 and ag2 path var4 <- path_between (cell_grid where each.is_free, [ag1, ag2, ag3]);  // var4 equals A path between ag1 and ag2 and ag3 passing through the given cell_grid agents   See also: towards, direction_to, distance_between, direction_between, path_to, distance_to,    ### path_to  Possible use:    geometry path_to geometry —>  path   path_to (geometry , geometry) —>  path   point path_to point —>  path   path_to (point , point) —>  path   Result: A path between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.  Examples:  path var0 <- ag1 path_to ag2;  // var0 equals the path between ag1 and ag2 considering the topology of the agent applying the operator   See also: towards, direction_to, distance_between, direction_between, path_between, distance_to,    ### paths_between  Possible use:    paths_between (graph, pair, int) —>  list<path>   Result: The K shortest paths between a list of two objects in a graph  Examples:  list<path> var0 <- paths_between(my_graph, ag1:: ag2, 2);  // var0 equals the 2 shortest paths (ordered by length) between ag1 and ag2     ### percent_absolute_deviation  Possible use:    list<float> percent_absolute_deviation list<float> —>  float   percent_absolute_deviation (list<float> , list<float>) —>  float   Result: percent absolute deviation indicator for 2 series of values: percent_absolute_deviation(list_vals_observe,list_vals_sim)  Examples:  percent_absolute_deviation([200,300,150,150,200],[250,250,100,200,200])     ### pgm_file  Possible use:    pgm_file (string) —>  file   Result: Constructs a file of type pgm. Allowed extensions are limited to pgm    ### plan  Possible use:    container<geometry> plan float —>  geometry   plan (container<geometry> , float) —>  geometry   Result: A polyline geometry from the given list of points.  Special cases:    if the operand is nil, returns the point geometry {0,0}   if the operand is composed of a single point, returns a point geometry.   Examples:  geometry var0 <- polyplan([{0,0}, {0,10}, {10,10}, {10,0}],10);  // var0 equals a polyline geometry composed of the 4 points with a depth of 10.   See also: around, circle, cone, link, norm, point, polygone, rectangle, square, triangle,    ### plus_days  Possible use:    date plus_days int —>  date   plus_days (date , int) —>  date   Result: Add a given number of days to a date  Examples:  date1 plus_days 20     ### plus_hours  Possible use:    date plus_hours int —>  date   plus_hours (date , int) —>  date   Result: Add a given number of hours to a date  Examples:  date1 plus_hours 15 // equivalent to date1 + 15 #h     ### plus_minutes  Possible use:    date plus_minutes int —>  date   plus_minutes (date , int) —>  date   Result: Add a given number of minutes to a date  Examples:  date1 plus_minutes 5 // equivalent to date1 + 5 #mn     ### plus_months  Possible use:    date plus_months int —>  date   plus_months (date , int) —>  date   Result: Add a given number of months to a date  Examples:  date1 plus_months 5     ### plus_ms  Possible use:    date plus_ms int —>  date   plus_ms (date , int) —>  date   Result: Add a given number of milliseconds to a date  Examples:  date1 plus_ms 15 // equivalent to date1 + 15 #ms     ### plus_seconds Same signification as +    ### plus_weeks  Possible use:    date plus_weeks int —>  date   plus_weeks (date , int) —>  date   Result: Add a given number of weeks to a date  Examples:  date1 plus_weeks 15     ### plus_years  Possible use:    date plus_years int —>  date   plus_years (date , int) —>  date   Result: Add a given number of years to a date  Examples:  date1 plus_years 3     ### point  Possible use:    float point int —>  point   point (float , int) —>  point   int point float —>  point   point (int , float) —>  point   int point int —>  point   point (int , int) —>  point   float point float —>  point   point (float , float) —>  point   point (float, int, int) —>  point   point (int, int, int) —>  point   point (float, int, float) —>  point   point (int, int, float) —>  point   point (int, float, float) —>  point   point (float, float, float) —>  point   point (float, float, int) —>  point   Result: internal use only. Use the standard construction {x,y} instead. internal use only. Use the standard construction {x,y} instead. internal use only. Use the standard construction {x,y, z} instead. internal use only. Use the standard construction {x,y, z} instead. internal use only. Use the standard construction {x,y, z} instead. internal use only. Use the standard construction {x,y, z} instead. internal use only. Use the standard construction {x,y, z} instead. internal use only. Use the standard construction {x,y} instead. internal use only. Use the standard construction {x,y} instead. internal use only. Use the standard construction {x,y, z} instead. internal use only. Use the standard construction {x,y, z} instead.    ### points_along  Possible use:    geometry points_along list<float> —>  container   points_along (geometry , list<float>) —>  container   Result: A list of points along the operand-geometry given its location in terms of rate of distance from the starting points of the geometry.  Examples:  container var0 <-  line([{10,10},{80,80}]) points_along ([0.3, 0.5, 0.9]);  // var0 equals the list of following points: [{31.0,31.0,0.0},{45.0,45.0,0.0},{73.0,73.0,0.0}]   See also: closest_points_with, farthest_point_to, points_at, points_on,    ### points_at  Possible use:    int points_at float —>  list<point>   points_at (int , float) —>  list<point>   Result: A list of left-operand number of points located at a the right-operand distance to the agent location.  Examples:  list<point> var0 <- 3 points_at(20.0);  // var0 equals returns [pt1, pt2, pt3] with pt1, pt2 and pt3 located at a distance of 20.0 to the agent location   See also: any_location_in, any_point_in, closest_points_with, farthest_point_to,    ### points_on  Possible use:    geometry points_on float —>  container   points_on (geometry , float) —>  container   Result: A list of points of the operand-geometry distant from each other to the float right-operand .  Examples:  container var0 <-  square(5) points_on(2);  // var0 equals a list of points belonging to the exterior ring of the square distant from each other of 2.   See also: closest_points_with, farthest_point_to, points_at,    ### poisson  Possible use:    poisson (float) —>  int   Result: A value from a random variable following a Poisson distribution (with the positive expected number of occurence lambda as operand).  Comment: The Poisson distribution is a discrete probability distribution that expresses the probability of a given number of events occurring in a fixed interval of time and/or space if these events occur with a known average rate and independently of the time since the last event, cf. Poisson distribution on Wikipedia.  Examples:  int var0 <- poisson(3.5);  // var0 equals a random positive integer   See also: binomial, gauss,    ### polygon  Possible use:    polygon (container<agent>) —>  geometry   Result: A polygon geometry from the given list of points.  Special cases:    if the operand is nil, returns the point geometry {0,0}   if the operand is composed of a single point, returns a point geometry   if the operand is composed of 2 points, returns a polyline geometry.   Examples:  geometry var0 <- polygon([{0,0}, {0,10}, {10,10}, {10,0}]);  // var0 equals a polygon geometry composed of the 4 points.   See also: around, circle, cone, line, link, norm, point, polyline, rectangle, square, triangle,    ### polyhedron  Possible use:    container<geometry> polyhedron float —>  geometry   polyhedron (container<geometry> , float) —>  geometry   Result: A polyhedron geometry from the given list of points.  Special cases:    if the operand is nil, returns the point geometry {0,0}   if the operand is composed of a single point, returns a point geometry   if the operand is composed of 2 points, returns a polyline geometry.   Examples:  geometry var0 <- polyhedron([{0,0}, {0,10}, {10,10}, {10,0}],10);  // var0 equals a polygon geometry composed of the 4 points and of depth 10.   See also: around, circle, cone, line, link, norm, point, polyline, rectangle, square, triangle,    ### polyline Same signification as line    ### polyplan Same signification as plan    ### predecessors_of  Possible use:    graph predecessors_of unknown —>  container   predecessors_of (graph , unknown) —>  container   Result: returns the list of predecessors (i.e. sources of in edges) of the given vertex (right-hand operand) in the given graph (left-hand operand)  Examples:  container var1 <- graphEpidemio predecessors_of ({1,5});  // var1 equals [] container var2 <- graphEpidemio predecessors_of node({34,56});  // var2 equals [{12;45}]   See also: neighbors_of, successors_of,    ### predicate  Possible use:    predicate (any) —>  predicate   Result: Casts the operand into the type predicate    ### predict  Possible use:    regression predict list<float> —>  float   predict (regression , list<float>) —>  float   Result: returns the value predict by the regression parameters for a given instance. Usage: predict(regression, instance)  Examples:  predict(my_regression, [1,2,3]     ### product Same signification as mul    ### product_of  Possible use:    container product_of any expression —>  unknown   product_of (container , any expression) —>  unknown   Result: the product of the right-hand expression evaluated on each of the elements of the left-hand operand  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    if the left-operand is a map, the keyword each will contain each value       unknown var2 <- [1::2, 3::4, 5::6] product_of (each);  // var2 equals 48       Examples:  unknown var1 <- [1,2] product_of (each * 10 );  // var1 equals 200   See also: min_of, max_of, sum_of, mean_of,    ### promethee_DM  Possible use:    list<list> promethee_DM list<map<string,object>> —>  int   promethee_DM (list<list> , list<map<string,object>>) —>  int   Result: The index of the best candidate according to the Promethee II method. This method is based on a comparison per pair of possible candidates along each criterion: all candidates are compared to each other by pair and ranked. More information about this method can be found in [http://www.sciencedirect.com/science?_ob=ArticleURL&_udi=B6VCT-4VF56TV-1&_user=10&_coverDate=01%2F01%2F2010&_rdoc=1&_fmt=high&_orig=search&_sort=d&_docanchor=&view=c&_searchStrId=1389284642&_rerunOrigin=google&_acct=C000050221&_version=1&_urlVersion=0&_userid=10&md5=d334de2a4e0d6281199a39857648cd36 Behzadian, M., Kazemzadeh, R., Albadvi, A., M., A.: PROMETHEE: A comprehensive literature review on methodologies and applications. European Journal of Operational Research(2009)]. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains fours elements: a name, a weight, a preference value (p) and an indifference value (q). The preference value represents the threshold from which the difference between two criterion values allows to prefer one vector of values over another. The indifference value represents the threshold from which the difference between two criterion values is considered significant.  Special cases:    returns -1 is the list of candidates is nil or empty   Examples:  int var0 <- promethee_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[name::utility, weight :: 2.0,p::0.5, q::0.0, s::1.0, maximize :: true],[name::price, weight :: 1.0,p::0.5, q::0.0, s::1.0, maximize :: false]]);  // var0 equals 1   See also: weighted_means_DM, electre_DM, evidence_theory_DM,    ### property_file  Possible use:    property_file (string) —>  file   Result: Constructs a file of type property. Allowed extensions are limited to properties    ### pyramid  Possible use:    pyramid (float) —>  geometry   Result: A square geometry which side size is given by the operand.  Comment: the center of the pyramid is by default the location of the current agent in which has been called this operator.  Special cases:    returns nil if the operand is nil.   Examples:  geometry var0 <- pyramid(5);  // var0 equals a geometry as a square with side_size = 5.   See also: around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, square,    ### range  Possible use:    range (int) —>  container   int range int —>  container   range (int , int) —>  container   range (int, int, int) —>  container   Result: Allows to build a list of int representing all contiguous values from zero to the argument. The range can be increasing or decreasing. Passing 0 will return a singleton list with 0 Allows to build a list of int representing all contiguous values from the first to the second argument, using the step represented by the third argument. The range can be increasing or decreasing. Passing the same value for both will return a singleton list with this value. Passing a step of 0 will result in an exception. Attempting to build infinite ranges (e.g. end > start with a negative step) will similarly not be accepted and yield an exception Allows to build a list of int representing all contiguous values from the first to the second argument. The range can be increasing or decreasing. Passing the same value for both will return a singleton list with this value    ### read  Possible use:    read (string) —>  unknown   Result: Reads an attribute of the agent. The attribute s name is specified by the operand.  Examples:  unknown agent_name <- read ( name );  // agent_name equals reads the  name  variable of agent then assigns the returned value to the  agent_name  variable.      ### rectangle  Possible use:    rectangle (point) —>  geometry   float rectangle float —>  geometry   rectangle (float , float) —>  geometry   point rectangle point —>  geometry   rectangle (point , point) —>  geometry   Result: A rectangle geometry which side sizes are given by the operands.  Comment: the center of the rectangle is by default the location of the current agent in which has been called this operator.the center of the rectangle is by default the location of the current agent in which has been called this operator.  Special cases:    returns nil if the operand is nil.   returns nil if the operand is nil.   returns nil if the operand is nil.   Examples:  geometry var0 <- rectangle(10, 5);  // var0 equals a geometry as a rectangle with width = 10 and height = 5. geometry var1 <- rectangle({2.0,6.0}, {6.0,20.0});  // var1 equals a geometry as a rectangle with {2.0,6.0} as the upper-left corner, {6.0,20.0} as the lower-right corner. geometry var2 <- rectangle({10, 5});  // var2 equals a geometry as a rectangle with width = 10 and height = 5.   See also: around, circle, cone, line, link, norm, point, polygon, polyline, square, triangle,    ### reduced_by Same signification as -    ### regression  Possible use:    regression (any) —>  regression   Result: Casts the operand into the type regression    ### remove_duplicates Same signification as distinct    ### remove_node_from  Possible use:    geometry remove_node_from graph —>  graph   remove_node_from (geometry , graph) —>  graph   Result: removes a node from a graph.  Comment: all the edges containing this node are also removed.  Examples:  graph var0 <- node(0) remove_node_from graphEpidemio;  // var0 equals the graph without node(0)     ### replace  Possible use:    replace (string, string, string) —>  string   Result: Returns the String resulting by replacing for the first operand all the sub-strings corresponding the second operand by the third operand  Examples:  string var0 <- replace( to be or not to be,that is the question , to ,  do );  // var0 equals  do be or not do be,that is the question    See also: replace_regex,    ### replace_regex  Possible use:    replace_regex (string, string, string) —>  string   Result: Returns the String resulting by replacing for the first operand all the sub-strings corresponding to the regular expression given in the second operand by the third operand  Examples:  string var0 <- replace_regex(colour, color, colou?r, col);  // var0 equals  col, col    See also: replace,    ### reverse  Possible use:    reverse (string) —>  string   reverse (container<KeyType,ValueType>) —>  msi.gama.util.IContainer<?,?>   Result: the operand elements in the reversed order in a copy of the operand.  Comment: the reverse operator behavior depends on the nature of the operand  Special cases:    if it is a file, reverse returns a copy of the file with a reversed content   if it is a population, reverse returns a copy of the population with elements in the reversed order   if it is a graph, reverse returns a copy of the graph (with all edges and vertexes), with all of the edges reversed   if it is a string, reverse returns a new string with characters in the reversed order       string var0 <- reverse ( abcd );  // var0 equals  dcba           if it is a list, reverse returns a copy of the operand list with elements in the reversed order       msi.gama.util.IContainer,?> var1 <- reverse ([10,12,14]);  // var1 equals [14, 12, 10]          if it is a map, reverse returns a copy of the operand map with each pair in the reversed order (i.e. all keys become values and values become keys)       msi.gama.util.IContainer,?> var2 <- reverse ([ k1 ::44,  k2 ::32,  k3 ::12]);  // var2 equals [12:: k3 ,  32:: k2 , 44:: k1 ]          if it is a matrix, reverse returns a new matrix containing the transpose of the operand.       msi.gama.util.IContainer,?> var3 <- reverse(matrix([[ c11 , c12 , c13 ],[ c21 , c22 , c23 ]]));  // var3 equals matrix([[ c11 , c21 ],[ c12 , c22 ],[ c13 , c23 ]])         ### rewire_n  Possible use:    graph rewire_n int —>  graph   rewire_n (graph , int) —>  graph   Result: rewires the given count of edges.  Comment: If there are too many edges, all the edges will be rewired.  Examples:  graph var1 <- graphEpidemio rewire_n 10;  // var1 equals the graph with 3 edges rewired     ### rgb  Possible use:    rgb rgb float —>  rgb   rgb (rgb , float) —>  rgb   rgb rgb int —>  rgb   rgb (rgb , int) —>  rgb   string rgb int —>  rgb   rgb (string , int) —>  rgb   rgb (int, int, int) —>  rgb   rgb (int, int, int, float) —>  rgb   rgb (int, int, int, int) —>  rgb   Result: Returns a color defined by red, green, blue components and an alpha blending value.  Special cases:    It can be used with r=red, g=green, b=blue (each between 0 and 255), a=alpha (between 0.0 and 1.0)   It can be used with a color and an alpha between 0 and 1   It can be used with a color and an alpha between 0 and 255   It can be used with r=red, g=green, b=blue, each between 0 and 255   It can be used with a name of color and alpha (between 0 and 255)   It can be used with r=red, g=green, b=blue (each between 0 and 255), a=alpha (between 0 and 255)   Examples:  rgb var0 <- rgb (255,0,0,0.5);  // var0 equals a light red color rgb var1 <- rgb(rgb(255,0,0),0.5);  // var1 equals a light red color rgb var2 <- rgb(rgb(255,0,0),125);  // var2 equals a light red color rgb var3 <- rgb (255,0,0);  // var3 equals #red rgb var4 <- rgb (red);  // var4 equals rgb(255,0,0) rgb var5 <- rgb (255,0,0,125);  // var5 equals a light red color   See also: hsb,    ### rgb_to_xyz  Possible use:    rgb_to_xyz (file) —>  list<point>   Result: A list of point corresponding to RGB value of an image (r:x , g:y, b:z)  Examples:  list<point> var0 <- rgb_to_xyz(texture);  // var0 equals a list of points     ### rnd  Possible use:    rnd (float) —>  float   rnd (int) —>  int   rnd (point) —>  point   point rnd point —>  point   rnd (point , point) —>  point   int rnd int —>  int   rnd (int , int) —>  int   float rnd float —>  float   rnd (float , float) —>  float   rnd (point, point, float) —>  point   rnd (float, float, float) —>  float   rnd (int, int, int) —>  int   Result: a random integer in the interval [0, operand]  Comment: to obtain a probability between 0 and 1, use the expression (rnd n) / n, where n is used to indicate the precision  Special cases:    if the operand is a float, returns an uniformly distributed float random number in [0.0, to]   if the operand is a point, returns a point with three random float ordinates, each in the interval [0, ordinate of argument]   Examples:  float var0 <- rnd(3.4);  // var0 equals a random float between 0.0 and 3.4 point var1 <- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}, 1);  // var1 equals a point with x = 2.0, y equal to 2.0, 3.0 or 4.0 and z between 0.0 and 10.0 every 1.0 point var2 <- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0});  // var2 equals a point with x = 2.0, y between 2.0 and 4.0 and z between 0.0 and 10.0 int var3 <- rnd (2, 4);  // var3 equals 2, 3 or 4 float var4 <- rnd (2.0, 4.0);  // var4 equals a float number between 2.0 and 4.0 float var5 <- rnd (2.0, 4.0, 0.5);  // var5 equals a float number between 2.0 and 4.0 every 0.5 int var6 <- rnd (2);  // var6 equals 0, 1 or 2 float var7 <- rnd (1000) / 1000;  // var7 equals a float between 0 and 1 with a precision of 0.001 point var8 <- rnd ({2.5,3, 0.0});  // var8 equals {x,y} with x in [0.0,2.0], y in [0.0,3.0], z = 0.0 int var9 <- rnd (2, 12, 4);  // var9 equals 2, 6 or 10   See also: flip,    ### rnd_choice  Possible use:    rnd_choice (container) —>  int   Result: returns an index of the given list with a probability following the (normalized) distribution described in the list (a form of lottery)  Examples:  int var0 <- rnd_choice([0.2,0.5,0.3]);  // var0 equals 2/10 chances to return 0, 5/10 chances to return 1, 3/10 chances to return 2   See also: rnd,    ### rnd_color  Possible use:    rnd_color (int) —>  rgb   Result: rgb color  Comment: Return a random color equivalent to rgb(rnd(operand),rnd(operand),rnd(operand))  Examples:  rgb var0 <- rnd_color(255);  // var0 equals a random color, equivalent to rgb(rnd(255),rnd(255),rnd(255))   See also: rgb, hsb,    ### rotated_by  Possible use:    geometry rotated_by float —>  geometry   rotated_by (geometry , float) —>  geometry   geometry rotated_by int —>  geometry   rotated_by (geometry , int) —>  geometry   rotated_by (geometry, float, point) —>  geometry   Result: A geometry resulting from the application of a rotation by the right-hand operand angle (degree) to the left-hand operand (geometry, agent, point) A geometry resulting from the application of a rotation by the right-hand operand angles (degree) along the three axis (x,y,z) to the left-hand operand (geometry, agent, point)  Comment: the right-hand operand can be a float or a int  Examples:  geometry var0 <- self rotated_by 45;  // var0 equals the geometry resulting from a 45 degrees rotation to the geometry of the agent applying the operator. geometry var1 <- rotated_by(pyramid(10),45, {1,0,0});  // var1 equals the geometry resulting from a 45 degrees rotation along the {1,0,0} vector to the geometry of the agent applying the operator.   See also: transformed_by, translated_by,    ### round  Possible use:    round (int) —>  int   round (point) —>  point   round (float) —>  int   Result: Returns the rounded value of the operand.  Special cases:    if the operand is an int, round returns it   Examples:  point var0 <- {12345.78943,  12345.78943, 12345.78943} with_precision 2;  // var0 equals {12345.79,12345.79,12345.79} int var1 <- round (0.51);  // var1 equals 1 int var2 <- round (100.2);  // var2 equals 100 int var3 <- round(-0.51);  // var3 equals -1   See also: round, int, with_precision,    ### row_at  Possible use:    matrix row_at int —>  list   row_at (matrix , int) —>  list   Result: returns the row at a num_line (right-hand operand)  Examples:  list var0 <- matrix([[el11,el12,el13],[el21,el22,el23],[el31,el32,el33]]) row_at 2;  // var0 equals [el13,el23,el33]   See also: column_at, columns_list,    ### rows_list  Possible use:    rows_list (matrix) —>  list<list>   Result: returns a list of the rows of the matrix, with each row as a list of elements  Examples:  list<list> var0 <- rows_list(matrix([[el11,el12,el13],[el21,el22,el23],[el31,el32,el33]]));  // var0 equals [[el11,el21,el31],[el12,el22,el32],[el13,el23,el33]]   See also: columns_list,    ### sample  Possible use:    sample (any expression) —>  string   string sample any expression —>  string   sample (string , any expression) —>  string   sample (container, int, bool) —>  container   sample (container, int, bool, container) —>  container   Result: takes a sample of the specified size from the elements of x using either with or without replacement takes a sample of the specified size from the elements of x using either with or without replacement with given weights  Examples:  container var0 <- sample([2,10,1],2,false);  // var0 equals [1,2] container var1 <- sample([2,10,1],2,false,[0.1,0.7,0.2]);  // var1 equals [10,2]     ### scaled_by Same signification as [](OperatorsAC#)    ### scaled_to  Possible use:    geometry scaled_to point —>  geometry   scaled_to (geometry , point) —>  geometry   Result: allows to restrict the size of a geometry so that it fits in the envelope {width, height, depth} defined by the second operand  Examples:  geometry var0 <- shape scaled_to {10,10};  // var0 equals a geometry corresponding to the geometry of the agent applying the operator scaled so that it fits a square of 10x10     ### select Same signification as where    ### set_about  Possible use:    emotion set_about predicate —>  emotion   set_about (emotion , predicate) —>  emotion   Result: change the about value of the given emotion  Examples:  emotion set_about predicate1     ### set_agent  Possible use:    msi.gaml.architecture.simplebdi.SocialLink set_agent agent —>  msi.gaml.architecture.simplebdi.SocialLink   set_agent (msi.gaml.architecture.simplebdi.SocialLink , agent) —>  msi.gaml.architecture.simplebdi.SocialLink   Result: change the agent value of the given social link  Examples:  social_link set_agent agentA     ### set_agent_cause  Possible use:    emotion set_agent_cause agent —>  emotion   set_agent_cause (emotion , agent) —>  emotion   predicate set_agent_cause agent —>  predicate   set_agent_cause (predicate , agent) —>  predicate   Result: change the agentCause value of the given emotion change the agentCause value of the given predicate  Examples:  emotion set_agent_cause agentA predicate set_agent_cause agentA     ### set_decay  Possible use:    emotion set_decay float —>  emotion   set_decay (emotion , float) —>  emotion   Result: change the decay value of the given emotion  Examples:  emotion set_decay 12     ### set_dominance  Possible use:    msi.gaml.architecture.simplebdi.SocialLink set_dominance float —>  msi.gaml.architecture.simplebdi.SocialLink   set_dominance (msi.gaml.architecture.simplebdi.SocialLink , float) —>  msi.gaml.architecture.simplebdi.SocialLink   Result: change the dominance value of the given social link  Examples:  social_link set_dominance 0.4     ### set_familiarity  Possible use:    msi.gaml.architecture.simplebdi.SocialLink set_familiarity float —>  msi.gaml.architecture.simplebdi.SocialLink   set_familiarity (msi.gaml.architecture.simplebdi.SocialLink , float) —>  msi.gaml.architecture.simplebdi.SocialLink   Result: change the familiarity value of the given social link  Examples:  social_link set_familiarity 0.4     ### set_intensity  Possible use:    emotion set_intensity float —>  emotion   set_intensity (emotion , float) —>  emotion   Result: change the intensity value of the given emotion  Examples:  emotion set_intensity 12     ### set_liking  Possible use:    msi.gaml.architecture.simplebdi.SocialLink set_liking float —>  msi.gaml.architecture.simplebdi.SocialLink   set_liking (msi.gaml.architecture.simplebdi.SocialLink , float) —>  msi.gaml.architecture.simplebdi.SocialLink   Result: change the liking value of the given social link  Examples:  social_link set_liking 0.4     ### set_solidarity  Possible use:    msi.gaml.architecture.simplebdi.SocialLink set_solidarity float —>  msi.gaml.architecture.simplebdi.SocialLink   set_solidarity (msi.gaml.architecture.simplebdi.SocialLink , float) —>  msi.gaml.architecture.simplebdi.SocialLink   Result: change the solidarity value of the given social link  Examples:  social_link set_solidarity 0.4     ### set_truth  Possible use:    predicate set_truth bool —>  predicate   set_truth (predicate , bool) —>  predicate   Result: change the is_true value of the given predicate  Examples:  predicate set_truth false     ### set_z  Possible use:    geometry set_z container<float> —>  geometry   set_z (geometry , container<float>) —>  geometry   set_z (geometry, int, float) —>  geometry   Result: Sets the z ordinate of the n-th point of a geometry to the value provided by the third argument  Examples:  loop i from: 0 to: length(shape.points) - 1{set shape <-  set_z (shape, i, 3.0);} shape <- triangle(3) set_z [5,10,14];     ### shape_file  Possible use:    shape_file (string) —>  file   Result: Constructs a file of type shape. Allowed extensions are limited to shp    ### shuffle  Possible use:    shuffle (matrix) —>  matrix   shuffle (string) —>  string   shuffle (container) —>  container   Result: The elements of the operand in random order.  Special cases:    if the operand is empty, returns an empty list (or string, matrix)   Examples:  matrix var0 <- shuffle (matrix([[c11,c12,c13],[c21,c22,c23]]));  // var0 equals matrix([[c12,c21,c11],[c13,c22,c23]]) (for example) string var1 <- shuffle ( abc );  // var1 equals  bac  (for example) container var2 <- shuffle ([12, 13, 14]);  // var2 equals [14,12,13] (for example)   See also: reverse,    ### signum  Possible use:    signum (float) —>  int   Result: Returns -1 if the argument is negative, +1 if it is positive, 0 if it is equal to zero or not a number  Examples:  int var0 <- signum(-12);  // var0 equals -1 int var1 <- signum(14);  // var1 equals 1 int var2 <- signum(0);  // var2 equals 0     ### simple_clustering_by_distance  Possible use:    container<agent> simple_clustering_by_distance float —>  list<list<agent>>   simple_clustering_by_distance (container<agent> , float) —>  list<list<agent>>   Result: A list of agent groups clustered by distance considering a distance min between two groups.  Examples:  list<list<agent>> var0 <- [ag1, ag2, ag3, ag4, ag5] simpleClusteringByDistance 20.0;  // var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]   See also: hierarchical_clustering,    ### simple_clustering_by_envelope_distance Same signification as simple_clustering_by_distance    ### simplification  Possible use:    geometry simplification float —>  geometry   simplification (geometry , float) —>  geometry   Result: A geometry corresponding to the simplification of the operand (geometry, agent, point) considering a tolerance distance.  Comment: The algorithm used for the simplification is Douglas-Peucker  Examples:  geometry var0 <- self simplification 0.1;  // var0 equals the geometry resulting from the application of the Douglas-Peuker algorithm on the geometry of the agent applying the operator with a tolerance distance of 0.1.     ### sin  Possible use:    sin (float) —>  float   sin (int) —>  float   Result: Returns the value (in [-1,1]) of the sinus of the operand (in decimal degrees). The argument is casted to an int before being evaluated.  Special cases:    Operand values out of the range [0-359] are normalized.   Examples:  float var0 <- sin(360);  // var0 equals 0.0 float var1 <- sin (0);  // var1 equals 0.0   See also: cos, tan,    ### sin_rad  Possible use:    sin_rad (float) —>  float   Result: Returns the value (in [-1,1]) of the sinus of the operand (in decimal degrees). The argument is casted to an int before being evaluated.  Special cases:    Operand values out of the range [0-359] are normalized.   Examples:  float var0 <- sin(360);  // var0 equals 0.0   See also: cos, tan,    ### since  Possible use:    since (date) —>  bool   any expression since date —>  bool   since (any expression , date) —>  bool   Result: Returns true if the current_date of the model is after (or equal to) the date passed in argument. Synonym of  current_date >= argument . Can be used, like  after , in its composed form with 2 arguments to express the lowest boundary of the computation of a frequency. However, contrary to  after , there is a subtle difference: the lowest boundary will be tested against the frequency as well  Examples:  reflex when: since(starting_date) {} -: will always be run every(2#days) since (starting_date + 1#day) // the computation will return true 1 day after the starting date and every two days after this reference date     ### skeletonize  Possible use:    skeletonize (geometry) —>  list<geometry>   Result: A list of geometries (polylines) corresponding to the skeleton of the operand geometry (geometry, agent)  Examples:  list<geometry> var0 <- skeletonize(self);  // var0 equals the list of geometries corresponding to the skeleton of the geometry of the agent applying the operator.     ### skew_gauss  Possible use:    skew_gauss (float, float, float, float) —>  float   Result: A value from a skew normally distributed random variable with min value (the minimum skewed value possible), max value (the maximum skewed value possible), skew (the degree to which the values cluster around the mode of the distribution; higher values mean tighter clustering) and bias (the tendency of the mode to approach the min, max or midpoint value; positive values bias toward max, negative values toward min).The algorithm was taken from http://stackoverflow.com/questions/5853187/skewing-java-random-number-generation-toward-a-certain-number  Examples:  float var0 <- skew_gauss(0.0, 1.0, 0.7,0.1);  // var0 equals 0.1729218460343077   See also: gauss, truncated_gauss, poisson,    ### skewness  Possible use:    skewness (list) —>  float   Result: returns skewness value computed from the operand list of values  Special cases:    if the length of the list is lower than 3, returns NaN   Examples:  skewness ([1,2,3,4,5])     ### skill  Possible use:    skill (any) —>  skill   Result: Casts the operand into the type skill    ### smooth  Possible use:    geometry smooth float —>  geometry   smooth (geometry , float) —>  geometry   Result: Returns a  smoothed  geometry, where straight lines are replaces by polynomial (bicubic) curves. The first parameter is the original geometry, the second is the  fit  parameter which can be in the range 0 (loose fit) to 1 (tightest fit).  Examples:  geometry var0 <- smooth(square(10), 0.0);  // var0 equals a  rounded  square     ### social_link  Possible use:    social_link (any) —>  social_link   Result: Casts the operand into the type social_link    ### solid Same signification as without_holes    ### sort Same signification as sort_by    ### sort_by  Possible use:    container sort_by any expression —>  container   sort_by (container , any expression) —>  container   Result: Returns a list, containing the elements of the left-hand operand sorted in ascending order by the value of the right-hand operand when it is evaluated on them.  Comment: the left-hand operand is casted to a list before applying the operator. In the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.  Special cases:    if the left-hand operand is nil, sort_by throws an error   Examples:  container var0 <- [1,2,4,3,5,7,6,8] sort_by (each);  // var0 equals [1,2,3,4,5,6,7,8] container var2 <- g2 sort_by (length(g2 out_edges_of each) );  // var2 equals [node9, node7, node10, node8, node11, node6, node5, node4] container var3 <- (list(node) sort_by (round(node(each).location.x));  // var3 equals [node5, node1, node0, node2, node3] container var4 <- [1::2, 5::6, 3::4] sort_by (each);  // var4 equals [2, 4, 6]   See also: group_by,    ### source_of  Possible use:    graph source_of unknown —>  unknown   source_of (graph , unknown) —>  unknown   Result: returns the source of the edge (right-hand operand) contained in the graph given in left-hand operand.  Special cases:    if the lef-hand operand (the graph) is nil, throws an Exception   Examples:  graph graphEpidemio <- generate_barabasi_albert( [edges_species::edge,vertices_specy::node,size::3,m::5] ); unknown var1 <- graphEpidemio source_of(edge(3));  // var1 equals node1 graph graphFromMap <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); point var3 <- graphFromMap source_of(link({1,5}::{12,45}));  // var3 equals {1,5}   See also: target_of,    ### spatial_graph  Possible use:    spatial_graph (container) —>  graph   Result: allows to create a spatial graph from a container of vertices, without trying to wire them. The container can be empty. Emits an error if the contents of the container are not geometries, points or agents  See also: graph,    ### species  Possible use:    species (unknown) —>  species   Result: casting of the operand to a species.  Special cases:    if the operand is nil, returns nil;   if the operand is an agent, returns its species;   if the operand is a string, returns the species with this name (nil if not found);   otherwise, returns nil   Examples:  species var0 <- species(self);  // var0 equals the species of the current agent species var1 <- species( node );  // var1 equals node species var2 <- species([1,5,9,3]);  // var2 equals nil species var3 <- species(node1);  // var3 equals node     ### species_of Same signification as species    ### sphere  Possible use:    sphere (float) —>  geometry   Result: A sphere geometry which radius is equal to the operand.  Comment: the centre of the sphere is by default the location of the current agent in which has been called this operator.  Special cases:    returns a point if the operand is lower or equal to 0.   Examples:  geometry var0 <- sphere(10);  // var0 equals a geometry as a circle of radius 10 but displays a sphere.   See also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,    ### split_at  Possible use:    geometry split_at point —>  list<geometry>   split_at (geometry , point) —>  list<geometry>   Result: The two part of the left-operand lines split at the given right-operand point  Special cases:    if the left-operand is a point or a polygon, returns an empty list   Examples:  list<geometry> var0 <- polyline([{1,2},{4,6}]) split_at {7,6};  // var0 equals [polyline([{1.0,2.0},{7.0,6.0}]), polyline([{7.0,6.0},{4.0,6.0}])]     ### split_geometry  Possible use:    geometry split_geometry float —>  list<geometry>   split_geometry (geometry , float) —>  list<geometry>   geometry split_geometry point —>  list<geometry>   split_geometry (geometry , point) —>  list<geometry>   split_geometry (geometry, int, int) —>  list<geometry>   Result: A list of geometries that result from the decomposition of the geometry by square cells of the given side size (geometry, size) A list of geometries that result from the decomposition of the geometry by rectangle cells of the given dimension (geometry, {size_x, size_y}) A list of geometries that result from the decomposition of the geometry according to a grid with the given number of rows and columns (geometry, nb_cols, nb_rows)  Examples:  list<geometry> var0 <- to_squares(self, 10.0);  // var0 equals the list of the geometries corresponding to the decomposition of the geometry by squares of side size 10.0 list<geometry> var1 <- to_rectangles(self, {10.0, 15.0});  // var1 equals the list of the geometries corresponding to the decomposition of the geometry by rectangles of size 10.0, 15.0 list<geometry> var2 <- to_rectangles(self, 10,20);  // var2 equals the list of the geometries corresponding to the decomposition of the geometry of the agent applying the operator     ### split_lines  Possible use:    split_lines (container<geometry>) —>  list<geometry>   Result: A list of geometries resulting after cutting the lines at their intersections.  Examples:  list<geometry> var0 <- split_lines([line([{0,10}, {20,10}]), line([{0,10}, {20,10}])]);  // var0 equals a list of four polylines: line([{0,10}, {10,10}]), line([{10,10}, {20,10}]), line([{10,0}, {10,10}]) and line([{10,10}, {10,20}])     ### split_with  Possible use:    string split_with string —>  container   split_with (string , string) —>  container   Result: Returns a list containing the sub-strings (tokens) of the left-hand operand delimited by each of the characters of the right-hand operand.  Comment: Delimiters themselves are excluded from the resulting list.  Examples:  container var0 <-  to be or not to be,that is the question  split_with   , ;  // var0 equals [ to , be , or , not , to , be , that , is , the , question ]     ### sqrt  Possible use:    sqrt (int) —>  float   sqrt (float) —>  float   Result: Returns the square root of the operand.  Special cases:    if the operand is negative, an exception is raised   Examples:  float var0 <- sqrt(4);  // var0 equals 2.0 float var1 <- sqrt(4);  // var1 equals 2.0     ### square  Possible use:    square (float) —>  geometry   Result: A square geometry which side size is equal to the operand.  Comment: the centre of the square is by default the location of the current agent in which has been called this operator.  Special cases:    returns nil if the operand is nil.   Examples:  geometry var0 <- square(10);  // var0 equals a geometry as a square of side size 10.   See also: around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, triangle,    ### squircle  Possible use:    float squircle float —>  geometry   squircle (float , float) —>  geometry   Result: A mix of square and circle geometry (see : http://en.wikipedia.org/wiki/Squircle), which side size is equal to the first operand and power is equal to the second operand  Comment: the center of the ellipse is by default the location of the current agent in which has been called this operator.  Special cases:    returns a point if the side operand is lower or equal to 0.   Examples:  geometry var0 <- squircle(4,4);  // var0 equals a geometry as a squircle of side 4 with a power of 4.   See also: around, cone, line, link, norm, point, polygon, polyline, super_ellipse, rectangle, square, circle, ellipse, triangle,    ### standard_deviation  Possible use:    standard_deviation (container) —>  float   Result: the standard deviation on the elements of the operand. See Standard_deviation for more details.  Comment: The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.  Examples:  float var0 <- standard_deviation ([4.5, 3.5, 5.5, 7.0]);  // var0 equals 1.2930100540985752   See also: mean, mean_deviation,    ### string  Possible use:    date string string —>  string   string (date , string) —>  string   Result: converts a date to astring following a custom pattern. The pattern can use  %Y %M %N %D %E %h %m %s %z  for outputting years, months, name of month, days, name of days, hours, minutes, seconds and the time-zone. A null or empty pattern will return the complete date as defined by the ISO date & time format. The pattern can also follow the pattern definition found here, which gives much more control over the format of the date: https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns. Different patterns are available by default as constants: #iso_local, #iso_simple, #iso_offset, #iso_zoned and #custom, which can be changed in the preferences  Examples:  format(#now,  yyyy-MM-dd )     ### subtract_days Same signification as minus_days    ### subtract_hours Same signification as minus_hours    ### subtract_minutes Same signification as minus_minutes    ### subtract_months Same signification as minus_months    ### subtract_ms Same signification as minus_ms    ### subtract_seconds Same signification as -    ### subtract_weeks Same signification as minus_weeks    ### subtract_years Same signification as minus_years    ### successors_of  Possible use:    graph successors_of unknown —>  container   successors_of (graph , unknown) —>  container   Result: returns the list of successors (i.e. targets of out edges) of the given vertex (right-hand operand) in the given graph (left-hand operand)  Examples:  container var1 <- graphEpidemio successors_of ({1,5});  // var1 equals [{12,45}] container var2 <- graphEpidemio successors_of node({34,56});  // var2 equals []   See also: predecessors_of, neighbors_of,    ### sum  Possible use:    sum (graph) —>  float   sum (container) —>  unknown   Result: the sum of all the elements of the operand  Comment: the behavior depends on the nature of the operand  Special cases:    if it is a population or a list of other types: sum transforms all elements into float and sums them   if it is a map, sum returns the sum of the value of all elements   if it is a file, sum returns the sum of the content of the file (that is also a container)   if it is a graph, sum returns the total weight of the graph   if it is a matrix of int, float or object, sum returns the sum of all the numerical elements (i.e. all elements for integer and float matrices)   if it is a matrix of other types: sum transforms all elements into float and sums them   if it is a list of colors: sum will sum them and return the blended resulting color   if it is a list of int or float: sum returns the sum of all the elements       int var0 <- sum ([12,10,3]);  // var0 equals 25          if it is a list of points: sum returns the sum of all points as a point (each coordinate is the sum of the corresponding coordinate of each element)       unknown var1 <- sum([{1.0,3.0},{3.0,5.0},{9.0,1.0},{7.0,8.0}]);  // var1 equals {20.0,17.0}       See also: mul,    ### sum_of  Possible use:    container sum_of any expression —>  unknown   sum_of (container , any expression) —>  unknown   Result: the sum of the right-hand expression evaluated on each of the elements of the left-hand operand  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    if the left-operand is a map, the keyword each will contain each value       unknown var2 <- [1::2, 3::4, 5::6] sum_of (each + 3);  // var2 equals 21       Examples:  unknown var1 <- [1,2] sum_of (each * 100 );  // var1 equals 300   See also: min_of, max_of, product_of, mean_of,    ### svg_file  Possible use:    svg_file (string) —>  file   Result: Constructs a file of type svg. Allowed extensions are limited to svg    ### tan  Possible use:    tan (int) —>  float   tan (float) —>  float   Result: Returns the value (in [-1,1]) of the trigonometric tangent of the operand (in decimal degrees). The argument is casted to an int before being evaluated.  Special cases:    Operand values out of the range [0-359] are normalized. Notice that tan(360) does not return 0.0 but -2.4492935982947064E-16   The tangent is only defined for any real number except 90 + k * 180 (k an positive or negative integer). Nevertheless notice that tan(90) returns 1.633123935319537E16 (whereas we could except infinity).   Examples:  float var0 <- tan (0);  // var0 equals 0.0 float var1 <- tan(90);  // var1 equals 1.633123935319537E16   See also: cos, sin,    ### tan_rad  Possible use:    tan_rad (float) —>  float   Result: Returns the value (in [-1,1]) of the trigonometric tangent of the operand (in decimal degrees). The argument is casted to an int before being evaluated.  Special cases:    Operand values out of the range [0-359] are normalized. Notice that tan(360) does not return 0.0 but -2.4492935982947064E-16   The tangent is only defined for any real number except 90 + k * 180 (k an positive or negative integer). Nevertheless notice that tan(90) returns 1.633123935319537E16 (whereas we could except infinity).   See also: cos, sin,    ### tanh  Possible use:    tanh (float) —>  float   tanh (int) —>  float   Result: Returns the value (in the interval [-1,1]) of the hyperbolic tangent of the operand (which can be any real number, expressed in decimal degrees).  Examples:  float var0 <- tanh(0);  // var0 equals 0.0 float var1 <- tanh(100);  // var1 equals 1.0     ### target_of  Possible use:    graph target_of unknown —>  unknown   target_of (graph , unknown) —>  unknown   Result: returns the target of the edge (right-hand operand) contained in the graph given in left-hand operand.  Special cases:    if the lef-hand operand (the graph) is nil, returns nil   Examples:  graph graphEpidemio <- generate_barabasi_albert( [edges_species::edge,vertices_specy::node,size::3,m::5] ); unknown var1 <- graphEpidemio source_of(edge(3));  // var1 equals node1 graph graphFromMap <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); unknown var3 <- graphFromMap target_of(link({1,5}::{12,45}));  // var3 equals {12,45}   See also: source_of,    ### teapot  Possible use:    teapot (float) —>  geometry   Result: A teapot geometry which radius is equal to the operand.  Comment: the centre of the teapot is by default the location of the current agent in which has been called this operator.  Special cases:    returns a point if the operand is lower or equal to 0.   Examples:  geometry var0 <- teapot(10);  // var0 equals a geometry as a circle of radius 10 but displays a teapot.   See also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,    ### text_file  Possible use:    text_file (string) —>  file   Result: Constructs a file of type text. Allowed extensions are limited to txt, data, text    ### threeds_file  Possible use:    threeds_file (string) —>  file   Result: Constructs a file of type threeds. Allowed extensions are limited to 3ds, max    ### to  Possible use:    date to date —>  msi.gama.util.IList<msi.gama.util.GamaDate>   to (date , date) —>  msi.gama.util.IList<msi.gama.util.GamaDate>   Result: builds an interval between two dates (the first inclusive and the second exclusive, which behaves like a read-only list of dates. The default step between two dates is the step of the model  Comment: The default step can be overruled by using the every operator applied to this interval  Examples:  date( 2000-01-01 ) to date( 2010-01-01 ) // builds an interval between these two dates (date( 2000-01-01 ) to date( 2010-01-01 )) every (#month) // builds an interval between these two dates which contains all the monthly dates starting from the beginning of the interval   See also: every,    ### to_GAMA_CRS  Possible use:    to_GAMA_CRS (geometry) —>  geometry   geometry to_GAMA_CRS string —>  geometry   to_GAMA_CRS (geometry , string) —>  geometry   Special cases:    returns the geometry corresponding to the transformation of the given geometry to the GAMA CRS (Coordinate Reference System) assuming the given geometry is referenced by given CRS       geometry var0 <- to_GAMA_CRS({121,14},  EPSG:4326 );  // var0 equals a geometry corresponding to the agent geometry transformed into the GAMA CRS          returns the geometry corresponding to the transformation of the given geometry to the GAMA CRS (Coordinate Reference System) assuming the given geometry is referenced by the current CRS, the one corresponding to the world s agent one       geometry var1 <- to_GAMA_CRS({121,14});  // var1 equals a geometry corresponding to the agent geometry transformed into the GAMA CRS         ### to_gaml  Possible use:    to_gaml (unknown) —>  string   Result: returns the literal description of an expression or description – action, behavior, species, aspect, even model – in gaml  Examples:  string var0 <- to_gaml(0);  // var0 equals  0  string var1 <- to_gaml(3.78);  // var1 equals  3.78  string var2 <- to_gaml(true);  // var2 equals  true  string var3 <- to_gaml({23, 4.0});  // var3 equals  {23.0,4.0,0.0}  string var4 <- to_gaml(5::34);  // var4 equals  5::34  string var5 <- to_gaml(rgb(255,0,125));  // var5 equals  rgb (255, 0, 125,255)  string var6 <- to_gaml( hello );  // var6 equals  hello  string var7 <- to_gaml([1,5,9,3]);  // var7 equals  [1,5,9,3]  string var8 <- to_gaml([ a ::345,  b ::13,  c ::12]);  // var8 equals ([ a ::345, b ::13, c ::12] as map ) string var9 <- to_gaml([[3,5,7,9],[2,4,6,8]]);  // var9 equals  [[3,5,7,9],[2,4,6,8]]  string var10 <- to_gaml(a_graph);  // var10 equals ([((1 as node)::(3 as node))::(5 as edge),((0 as node)::(3 as node))::(3 as edge),((1 as node)::(2 as node))::(1 as edge),((0 as node)::(2 as node))::(2 as edge),((0 as node)::(1 as node))::(0 as edge),((2 as node)::(3 as node))::(4 as edge)] as map ) as graph string var11 <- to_gaml(node1);  // var11 equals  1 as node     ### to_rectangles  Possible use:    to_rectangles (geometry, point, bool) —>  list<geometry>   to_rectangles (geometry, int, int, bool) —>  list<geometry>   Result: A list of rectangles of the size corresponding to the given dimension that result from the decomposition of the geometry into rectangles (geometry, dimension, overlaps), if overlaps = true, add the rectangles that overlap the border of the geometry A list of rectangles corresponding to the given dimension that result from the decomposition of the geometry into rectangles (geometry, nb_cols, nb_rows, overlaps) by a grid composed of the given number of columns and rows, if overlaps = true, add the rectangles that overlap the border of the geometry  Examples:  list<geometry> var0 <- to_rectangles(self, {10.0, 15.0}, true);  // var0 equals the list of rectangles of size {10.0, 15.0} corresponding to the discretization into rectangles of the geometry of the agent applying the operator. The rectangles overlapping the border of the geometry are kept list<geometry> var1 <- to_rectangles(self, 5, 20, true);  // var1 equals the list of rectangles corresponding to the discretization by a grid of 5 columns and 20 rows into rectangles of the geometry of the agent applying the operator. The rectangles overlapping the border of the geometry are kept     ### to_squares Same signification as split_geometry  Possible use:    to_squares (geometry, int, bool) —>  list<geometry>   to_squares (geometry, float, bool) —>  list<geometry>   to_squares (geometry, int, bool, float) —>  list<geometry>   Result: A list of a given number of squares from the decomposition of the geometry into squares (geometry, nb_square, overlaps), if overlaps = true, add the squares that overlap the border of the geometry A list of squares of the size corresponding to the given size that result from the decomposition of the geometry into squares (geometry, size, overlaps), if overlaps = true, add the squares that overlap the border of the geometry A list of a given number of squares from the decomposition of the geometry into squares (geometry, nb_square, overlaps, precision_coefficient), if overlaps = true, add the squares that overlap the border of the geometry, coefficient_precision should be close to 1.0  Examples:  list<geometry> var0 <- to_squares(self, 10, true);  // var0 equals the list of 10 squares corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept list<geometry> var1 <- to_squares(self, 10.0, true);  // var1 equals the list of squares of side size 10.0 corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept list<geometry> var2 <- to_squares(self, 10, true, 0.99);  // var2 equals the list of 10 squares corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept     ### to_triangles Same signification as triangulate    ### tokenize Same signification as split_with    ### topology  Possible use:    topology (unknown) —>  topology   Result: casting of the operand to a topology.  Special cases:    if the operand is a topology, returns the topology itself;   if the operand is a spatial graph, returns the graph topology associated;   if the operand is a population, returns the topology of the population;   if the operand is a shape or a geometry, returns the continuous topology bounded by the geometry;   if the operand is a matrix, returns the grid topology associated   if the operand is another kind of container, returns the multiple topology associated to the container   otherwise, casts the operand to a geometry and build a topology from it.   Examples:  topology var0 <- topology(0);  // var0 equals nil topology(a_graph) --: Multiple topology in POLYGON ((24.712119771887785 7.867357373616512, 24.712119771887785 61.283226839310565, 82.4013676510046  7.867357373616512)) at location[53.556743711446195;34.57529210646354]   See also: geometry,    ### touches  Possible use:    geometry touches geometry —>  bool   touches (geometry , geometry) —>  bool   Result: A boolean, equal to true if the left-geometry (or agent/point) touches the right-geometry (or agent/point).  Comment: returns true when the left-operand only touches the right-operand. When one geometry covers partially (or fully) the other one, it returns false.  Special cases:    if one of the operand is null, returns false.   Examples:  bool var0 <- polyline([{10,10},{20,20}]) touches {15,15};  // var0 equals false bool var1 <- polyline([{10,10},{20,20}]) touches {10,10};  // var1 equals true bool var2 <- {15,15} touches {15,15};  // var2 equals false bool var3 <- polyline([{10,10},{20,20}]) touches polyline([{10,10},{5,5}]);  // var3 equals true bool var4 <- polyline([{10,10},{20,20}]) touches polyline([{5,5},{15,15}]);  // var4 equals false bool var5 <- polyline([{10,10},{20,20}]) touches polyline([{15,15},{25,25}]);  // var5 equals false bool var6 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{15,15},{15,25},{25,25},{25,15}]);  // var6 equals false bool var7 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{10,20},{20,20},{20,30},{10,30}]);  // var7 equals true bool var8 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{10,10},{0,10},{0,0},{10,0}]);  // var8 equals true bool var9 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches {15,15};  // var9 equals false bool var10 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches {10,15};  // var10 equals true   See also: disjoint_from, crosses, overlaps, partially_overlaps, intersects,    ### towards  Possible use:    geometry towards geometry —>  int   towards (geometry , geometry) —>  int   Result: The direction (in degree) between the two geometries (geometries, agents, points) considering the topology of the agent applying the operator.  Examples:  int var0 <- ag1 towards ag2;  // var0 equals the direction between ag1 and ag2 and ag3 considering the topology of the agent applying the operator   See also: distance_between, distance_to, direction_between, path_between, path_to,    ### trace  Possible use:    trace (matrix) —>  float   Result: The trace of the given matrix (the sum of the elements on the main diagonal).  Examples:  float var0 <- trace(matrix([[1,2],[3,4]]));  // var0 equals 5     ### transformed_by  Possible use:    geometry transformed_by point —>  geometry   transformed_by (geometry , point) —>  geometry   Result: A geometry resulting from the application of a rotation and a scaling (right-operand : point {angle(degree), scale factor} of the left-hand operand (geometry, agent, point)  Examples:  geometry var0 <- self transformed_by {45, 0.5};  // var0 equals the geometry resulting from 45 degrees rotation and 50% scaling of the geometry of the agent applying the operator.   See also: rotated_by, translated_by,    ### translated_by  Possible use:    geometry translated_by point —>  geometry   translated_by (geometry , point) —>  geometry   Result: A geometry resulting from the application of a translation by the right-hand operand distance to the left-hand operand (geometry, agent, point)  Examples:  geometry var0 <- self translated_by {10,10,10};  // var0 equals the geometry resulting from applying the translation to the left-hand geometry (or agent).   See also: rotated_by, transformed_by,    ### translated_to Same signification as at_location    ### transpose  Possible use:    transpose (matrix) —>  matrix   Result: The transposition of the given matrix  Examples:  matrix var0 <- transpose(matrix([[5,-3],[6,-4]]));  // var0 equals [[5,6],[-3,-4]]     ### triangle  Possible use:    triangle (float) —>  geometry   Result: A triangle geometry which side size is given by the operand.  Comment: the center of the triangle is by default the location of the current agent in which has been called this operator.  Special cases:    returns nil if the operand is nil.   Examples:  geometry var0 <- triangle(5);  // var0 equals a geometry as a triangle with side_size = 5.   See also: around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, square,    ### triangulate  Possible use:    triangulate (list<geometry>) —>  list<geometry>   triangulate (geometry) —>  list<geometry>   Result: A list of geometries (triangles) corresponding to the Delaunay triangulation of the operand geometry (geometry, agent, point)  Examples:  list<geometry> var0 <- triangulate(self);  // var0 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator. list<geometry> var1 <- triangulate(self);  // var1 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator.     ### truncated_gauss  Possible use:    truncated_gauss (container) —>  float   truncated_gauss (point) —>  float   Result: A random value from a normally distributed random variable in the interval ]mean - standardDeviation; mean + standardDeviation[.  Special cases:    if the operand is a list, only the two first elements are taken into account as [mean, standardDeviation]   when truncated_gauss is called with a list of only one element mean, it will always return 0.0   when the operand is a point, it is read as {mean, standardDeviation}   Examples:  float var0 <- truncated_gauss ([0.5, 0.0]);  // var0 equals 0.5 float var1 <- truncated_gauss ({0, 0.3});  // var1 equals a float between -0.3 and 0.3   See also: gauss,    ### undirected  Possible use:    undirected (graph) —>  graph   Result: the operand graph becomes an undirected graph.  Comment: the operator alters the operand graph, it does not create a new one.  See also: directed,    ### union  Possible use:    union (container<geometry>) —>  geometry   container union container —>  container   union (container , container) —>  container   Result: returns a new list containing all the elements of both containers without duplicated elements.  Special cases:    if the left or right operand is nil, union throws an error   if the right-operand is a container of points, geometries or agents, returns the geometry resulting from the union all the geometries   Examples:  container var0 <- [1,2,3,4,5,6] union [2,4,9];  // var0 equals [1,2,3,4,5,6,9] container var1 <- [1,2,3,4,5,6] union [0,8];  // var1 equals [1,2,3,4,5,6,0,8] container var2 <- [1,3,2,4,5,6,8,5,6] union [0,8];  // var2 equals [1,3,2,4,5,6,8,0] geometry var3 <- union([geom1, geom2, geom3]);  // var3 equals a geometry corresponding to union between geom1, geom2 and geom3   See also: inter, +,    ### unknown  Possible use:    unknown (any) —>  unknown   Result: Casts the operand into the type unknown    ### until  Possible use:    until (date) —>  bool   any expression until date —>  bool   until (any expression , date) —>  bool   Result: Returns true if the current_date of the model is before (or equel to) the date passed in argument. Synonym of  current_date <= argument   Examples:  reflex when: until(starting_date) {} -: will be run only once at the beginning of the simulation     ### upper_case  Possible use:    upper_case (string) —>  string   Result: Converts all of the characters in the string operand to upper case  Examples:  string var0 <- upper_case(Abc);  // var0 equals  ABC    See also: lower_case,    ### use_cache  Possible use:    graph use_cache bool —>  graph   use_cache (graph , bool) —>  graph   Result: if the second operand is true, the operand graph will store in a cache all the previously computed shortest path (the cache be cleared if the graph is modified).  Comment: the operator alters the operand graph, it does not create a new one.  See also: path_between,    ### user_input  Possible use:    user_input (any expression) —>  map<string,unknown>   string user_input any expression —>  map<string,unknown>   user_input (string , any expression) —>  map<string,unknown>   Result: asks the user for some values (not defined as parameters). Takes a string (optional) and a map as arguments. The string is used to specify the message of the dialog box. The map is to specify the parameters you want the user to change before the simulation starts, with the name of the parameter in string key, and the default value as value.  Comment: This operator takes a map [string::value] as argument, displays a dialog asking the user for these values, and returns the same map with the modified values (if any). The dialog is modal and will interrupt the execution of the simulation until the user has either dismissed or accepted it. It can be used, for instance, in an init section to force the user to input new values instead of relying on the initial values of parameters :  Examples:  map<string,unknown> values2 <- user_input(Enter numer of agents and locations,[Number :: 100, Location :: {10, 10}]); create bug number: int(values2 at Number) with: [location:: (point(values2 at Location))]; map<string,unknown> values <- user_input([Number :: 100, Location :: {10, 10}]); create bug number: int(values at Number) with: [location:: (point(values at Location))];     ### using  Possible use:    any expression using topology —>  unknown   using (any expression , topology) —>  unknown   Result: Allows to specify in which topology a spatial computation should take place.  Special cases:    has no effect if the topology passed as a parameter is nil   Examples:  unknown var0 <- (agents closest_to self) using topology(world);  // var0 equals the closest agent to self (the caller) in the continuous topology of the world     ### variance  Possible use:    variance (container) —>  float   Result: the variance of the elements of the operand. See Variance for more details.  Comment: The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.  Examples:  float var0 <- variance ([4.5, 3.5, 5.5, 7.0]);  // var0 equals 1.671875   See also: mean, median,    ### variance_of  Possible use:    container variance_of any expression —>  unknown   variance_of (container , any expression) —>  unknown   Result: the variance of the right-hand expression evaluated on each of the elements of the left-hand operand  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  See also: min_of, max_of, sum_of, product_of,    ### voronoi  Possible use:    voronoi (list<point>) —>  list<geometry>   list<point> voronoi geometry —>  list<geometry>   voronoi (list<point> , geometry) —>  list<geometry>   Result: A list of geometries corresponding to the Voronoi diagram built from the list of points according to the given clip A list of geometries corresponding to the Voronoi diagram built from the list of points  Examples:  list<geometry> var0 <- voronoi([{10,10},{50,50},{90,90},{10,90},{90,10}], square(300));  // var0 equals the list of geometries corresponding to the Voronoi Diagram built from the list of points with a square of 300m side size as clip. list<geometry> var1 <- voronoi([{10,10},{50,50},{90,90},{10,90},{90,10}]);  // var1 equals the list of geometries corresponding to the Voronoi Diagram built from the list of points.     ### weight_of  Possible use:    graph weight_of unknown —>  float   weight_of (graph , unknown) —>  float   Result: returns the weight of the given edge (right-hand operand) contained in the graph given in right-hand operand.  Comment: In a localized graph, an edge has a weight by default (the distance between both vertices).  Special cases:    if the left-operand (the graph) is nil, returns nil   if the right-hand operand is not an edge of the given graph, weight_of checks whether it is a node of the graph and tries to return its weight   if the right-hand operand is neither a node, nor an edge, returns 1.   Examples:  graph graphFromMap <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); float var1 <- graphFromMap weight_of(link({1,5}::{12,45}));  // var1 equals 1.0     ### weighted_means_DM  Possible use:    list<list> weighted_means_DM list<map<string,object>> —>  int   weighted_means_DM (list<list> , list<map<string,object>>) —>  int   Result: The index of the candidate that maximizes the weighted mean of its criterion values. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion (list of map)  Special cases:    returns -1 is the list of candidates is nil or empty   Examples:  int var0 <- weighted_means_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[name::utility, weight :: 2.0],[name::price, weight :: 1.0]]);  // var0 equals 1   See also: promethee_DM, electre_DM, evidence_theory_DM,    ### where  Possible use:    container where any expression —>  container   where (container , any expression) —>  container   Result: a list containing all the elements of the left-hand operand that make the right-hand operand evaluate to true.  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    if the left-hand operand is a list nil, where returns a new empty list   if the left-operand is a map, the keyword each will contain each value       container var4 <- [1::2, 3::4, 5::6] where (each >= 4);  // var4 equals [4, 6]       Examples:  container var0 <- [1,2,3,4,5,6,7,8] where (each > 3);  // var0 equals [4, 5, 6, 7, 8]  container var2 <- g2 where (length(g2 out_edges_of each) = 0 );  // var2 equals [node9, node7, node10, node8, node11] container var3 <- (list(node) where (round(node(each).location.x) > 32);  // var3 equals [node2, node3]   See also: first_with, last_with, where,    ### with_lifetime  Possible use:    predicate with_lifetime int —>  predicate   with_lifetime (predicate , int) —>  predicate   Result: change the parameters of the given predicate  Examples:  predicate with_lifetime 10     ### with_max_of  Possible use:    container with_max_of any expression —>  unknown   with_max_of (container , any expression) —>  unknown   Result: one of elements of the left-hand operand that maximizes the value of the right-hand operand  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    if the left-hand operand is nil, with_max_of returns the default value of the right-hand operand   Examples:  unknown var0 <- [1,2,3,4,5,6,7,8] with_max_of (each );  // var0 equals 8 unknown var2 <- g2 with_max_of (length(g2 out_edges_of each)  ) ;  // var2 equals node4 unknown var3 <- (list(node) with_max_of (round(node(each).location.x));  // var3 equals node3 unknown var4 <- [1::2, 3::4, 5::6] with_max_of (each);  // var4 equals 6   See also: where, with_min_of,    ### with_min_of  Possible use:    container with_min_of any expression —>  unknown   with_min_of (container , any expression) —>  unknown   Result: one of elements of the left-hand operand that minimizes the value of the right-hand operand  Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.  Special cases:    if the left-hand operand is nil, with_max_of returns the default value of the right-hand operand   Examples:  unknown var0 <- [1,2,3,4,5,6,7,8] with_min_of (each );  // var0 equals 1 unknown var2 <- g2 with_min_of (length(g2 out_edges_of each)  );  // var2 equals node11 unknown var3 <- (list(node) with_min_of (round(node(each).location.x));  // var3 equals node0 unknown var4 <- [1::2, 3::4, 5::6] with_min_of (each);  // var4 equals 2   See also: where, with_max_of,    ### with_optimizer_type  Possible use:    graph with_optimizer_type string —>  graph   with_optimizer_type (graph , string) —>  graph   Result: changes the shortest path computation method of the given graph  Comment: the right-hand operand can be  Djikstra ,  Bellmann ,  Astar  to use the associated algorithm. Note that these methods are dynamic: the path is computed when needed. In contrarily, if the operand is another string, a static method will be used, i.e. all the shortest are previously computed.  Examples:  graphEpidemio <- graphEpidemio with_optimizer_type static;   See also: set_verbose,    ### with_praiseworthiness  Possible use:    predicate with_praiseworthiness float —>  predicate   with_praiseworthiness (predicate , float) —>  predicate   Result: change the praiseworthiness value of the given predicate  Examples:  predicate set_truth false     ### with_precision  Possible use:    float with_precision int —>  float   with_precision (float , int) —>  float   point with_precision int —>  point   with_precision (point , int) —>  point   Result: Rounds off the value of left-hand operand to the precision given by the value of right-hand operand Rounds off the ordinates of the left-hand point to the precision given by the value of right-hand operand  Examples:  float var0 <- 12345.78943 with_precision 2;  // var0 equals 12345.79 float var1 <- 123 with_precision 2;  // var1 equals 123.00 point var2 <- {12345.78943, 12345.78943, 12345.78943} with_precision 2 ;  // var2 equals {12345.79, 12345.79, 12345.79}   See also: round,    ### with_priority  Possible use:    predicate with_priority float —>  predicate   with_priority (predicate , float) —>  predicate   Result: change the priority of the given predicate  Examples:  predicate with_priority 2     ### with_values  Possible use:    predicate with_values map —>  predicate   with_values (predicate , map) —>  predicate   Result: change the parameters of the given predicate  Examples:  predicate with_values [time::10]     ### with_weights  Possible use:    graph with_weights map —>  graph   with_weights (graph , map) —>  graph   graph with_weights container —>  graph   with_weights (graph , container) —>  graph   Result: returns the graph (left-hand operand) with weight given in the map (right-hand operand).  Comment: this operand re-initializes the path finder  Special cases:    if the right-hand operand is a list, affects the n elements of the list to the n first edges. Note that the ordering of edges may change overtime, which can create some problems…   if the left-hand operand is a map, the map should contains pairs such as: vertex/edge::double       graph_from_edges (list(ant) as_map each::one_of (list(ant))) with_weights (list(ant) as_map each::each.food)         ### without_holes  Possible use:    without_holes (geometry) —>  geometry   Result: A geometry corresponding to the operand geometry (geometry, agent, point) without its holes  Examples:  geometry var0 <- solid(self);  // var0 equals the geometry corresponding to the geometry of the agent applying the operator without its holes.     ### writable  Possible use:    file writable bool —>  file   writable (file , bool) —>  file   Result: Marks the file as read-only or not, depending on the second boolean argument, and returns the first argument  Comment: A file is created using its native flags. This operator can change them. Beware that this change is system-wide (and not only restrained to GAMA): changing a file to read-only mode (e.g.  writable(f, false) )  Examples:  file var0 <- shape_file(../images/point_eau.shp) writable false;  // var0 equals returns a file in read-only mode   See also: file,    ### xml_file  Possible use:    xml_file (string) —>  file   Result: Constructs a file of type xml. Allowed extensions are limited to xml    ### years_between  Possible use:    date years_between date —>  int   years_between (date , date) —>  int   Result: Provide the exact number of years between two dates. This number can be positive or negative (if the second operand is smaller than the first one)  Examples:  years_between(d1, d2) -: 10    ","url":"wiki/OperatorsNZ.md"},{"id":"wiki/Overview.md","title":" Introduction","content":"Introduction  | <img src= http://img.youtube.com/vi/6m_-UY8UBuk/0.jpg  width= 425  height=344 /> | <img src= http://img.youtube.com/vi/ycbeYxV2B7M/0.jpg  width= 425  height=344 /> | |—|—|  GAMA is a simulation platform, which aims at providing field experts, modellers, and computer scientists with a complete modelling and simulation development environment for building spatially explicit multi-agent simulations. It has been first developed by the Vietnamese-French research team MSI (located at IFI, Hanoi, and part of the IRD/UPMC International Research Unit UMMISCO) from 2007 to 2010, and is now developed by a consortium of academic and industrial partners led by UMMISCO, among which the University of Rouen, France, the University of Toulouse 1, France, the University of Orsay, France, the University of Can Tho, Vietnam, the National University of Hanoi, EDF R&D, France, and CEA LISC, France.  Some of the features of GAMA are illustrated in the videos above (more can be found in our Youtube channel).  Beyond these features, GAMA also offers:     A complete modeling language, GAML, for modeling agents and environments   A large and extensible library of primitives (agent s movement, communication, mathematical functions, graphical features, …)   A cross-platform reproducibility of experiments and simulations   A powerful declarative drawing and plotting subsystem   A flexible user interface based on the Eclipse platform   A complete set of batch tools, allowing for a systematic or  intelligent  exploration of models parameters spaces   Documentation The documentation of GAMA is available online on the wiki of the project. It is organized around a few central activities (installing GAMA, writing models, running experiments, developing new extensions to the platform) and provides complete references on both the GAML language, the platform itself, and the scientific aspects of our work (with a complete bibliography). Several tutorials are also provided in the documentation in order to minimize the learning curve, allowing users to build, step by step, the models corresponding to these tutorials, which are of course shipped with the platform.  The documentation can be accessed from the side bar of this page. A good starting point for new users is the installation page.  A standalone version of the documentation, in PDF format, can be directly downloaded from here  Source Code GAMA can be downloaded as a regular application or built from source, which is necessary if you want to contribute to the platform. The source code is available from this GITHub repository:   https://github.com/gama-platform/gama   Which you can also browse from the web here. It is, in any case, recommended to follow the instructions on this page in order to build GAMA from source.  Copyright Information This is a free software (distributed under the GNU GPL v3 license), so you can have access to the code, edit it and redistribute it under the same terms. Independently of the licensing issues, if you plan on reusing part of our code, we would be glad to know it !  Developers GAMA is being designed, developed and maintained by an active group of researchers coming from different institutions in France and Vietnam. Please find below a short introduction to each of them and a summary of their contributions to the platform:     Alexis Drogoul, Senior Researcher at the IRD, member of the UMMISCO International Research Unit. Mostly working on agent-based modeling and simulation. Has contributed and still contributes to the original design of the platform, including the GAML language (from the meta-model to the editor) and simulation facilities like Java2D displays.   Patrick Taillandier, Associate Professor at the University of Rouen, member of the IDEES CNRS Mixed Research Unit. Contributes since 2008 to the spatial and graph features (GIS integration, spatial operators) and to parameter space search algorithms. Currently working on new features related to graphical modeling and traffic simulation.   Benoit Gaudou, Associate Professor at the University Toulouse 1 Capitole, member of the IRIT CNRS Mixed Research Unit. Contributes since 2010 to documentation and unit test generation and coupling mathematical (ODE and PDE) and agent paradigms.   Arnaud Grignard, software engineer and PhD fellow (PDI-MSC) at UPMC. Contributes since 2011 to the development of new features related to visualization (3D Display), online analysis and interaction.   Huynh Quang Nghi, software engineering lecturer at CTU and PhD fellow (PDI-MSC) at UPMC. Contributes since 2012 to the development of new features related to GAML parser, coupling formalisms in EBM-ABM and ABM-ABM.   Truong Minh Thai, software engineering lecturer at CTU and PhD fellow (PRJ322-MOET) at IRIT-UT1. Contributes since 2012 to the development of new features related to data management and analysis.   Nicolas Marilleau, Researcher at the IRD, member of the UMMISCO International Research Unit and associate researcher at DISC team of FEMTO-ST institute. Contributes since 2010 to the development of headless mode and the high performance computing module.   Philippe Caillou, Associate professor at the University Paris Sud 11, member of the LRI and INRIA project-team TAO. Contributes since 2012 and actually working on charts, simulation analysis and BDI agents.   Vo Duc An, Post-doctoral Researcher, working on synthetic population generation in agent-based modelling, at the UMMISCO International Research Unit of the IRD. Has contributed to bringing the platform to the Eclipse RCP environment and to the development of several features (e.g., the FIPA-compliant agent communication capability, the multi-level architecture).   Truong Xuan Viet, software engineering lecturer at CTU and PhD fellow (PDI-MSC) at UPMC. Contributes since 2011 to the development of new features related to R caller, online GIS (OPENGIS: Web Map Service - WMS, Web Feature Services - WMS, Google map, etc).  Samuel Thiriot Citing GAMA If you use GAMA in your research and want to cite it (in a paper, presentation, whatever), please use this reference:     A. Grignard, P. Taillandier, B. Gaudou, D-A. Vo, N-Q. Huynh, A. Drogoul (2013), GAMA 1.6: Advancing the Art of Complex Agent-Based Modeling and Simulation. In  PRIMA 2013: Principles and Practice of Multi-Agent Systems , Lecture Notes in Computer Science, Vol. 8291, Springer, pp. 117-131.   or you can choose to cite the website instead:     GAMA Platform website, http://gama-platform.org   A complete list of references (papers and PhD theses on or using GAMA) is available on the references page.  Contact Us The best way to get in touch with the developers of GAMA is to sign in for the gama-platform@googlegroups.com mailing list. If you wish to contribute to the platform, you might want, instead or in addition, to sign in for the gama-dev@googlegroups.com mailing list. On both lists, we generally answer quite quickly to requests.  Finally, if you think you have found a bug in GAMA, or if you absolutely need a feature that does not exist yet, it is much more efficient and time-saving for everyone (including current and future users) to create a new issue report. Please refer to these instructions to do so. ","url":"wiki/Overview.md"},{"id":"wiki/PedagogicalMaterials.md","title":" Initiation to algorithms with Scratch","content":"Initiation to algorithms with Scratch A set of exercices for your first step to algorithms using the graphical tool Scratch: PDF.  Memo GAML A summary of the organization of a GAML model, its main parts and the main keywords, statements: PDF.  Exercice (*): Firefly synchronization From UML diagram, implement a GAMA model. * Keywords: grid, displays, plot, synchronization. * Subject: PDF, Keynote, PPTX * UML diagrams: asta version * A model: gaml file  Exercice (*): Firefighter model Implement the model given in the model description file. The guide file helps you to separate the implementation of the structure of the model, its initialization, its dynamics and ways to visualize it. * Keywords: grid, inheritance, displays, plot, 3D. * Model description: PDF * Guide: PDF, Keynote, PPTX * UML diagrams: asta version * A model: gaml file  Exercice (**): Wolves, Goats, Cabbages model Implement the model given in the model description file. The detailed subject divides the model in 3 steps and contains helps and advices to implement the model. * Keywords: grid, inheritance, displays, plot, prey-predator model. * Model description: PDF * Detailed subject: PDF, Word * Guide: PDF, PPTX * A model: gaml file  Exercice (**): Schelling model    Keywords: grid, GIS data, displays, plot, Graphical modeling, Schelling model.   Subject: PDF, Keynote, PPTX   A model: gaml file   Exercice (**): Traffic model    Keywords: GIS data, graph, skills, moving skill, displays, plot, mobillity model.   Subject: PDF, Keynote, PPTX   A model: gaml file   Exercice (***): Shortest path on grid by distance diffusion    Keywords: grid, move, displays, diffusion model, algorithm.   Subject: PDF, Word   A model: gaml file  ","url":"wiki/PedagogicalMaterials.md"},{"id":"wiki/References.md","title":" References","content":"References  This page contains a subset of the scientific papers that have been written either about GAMA or using the platform as an experimental/modeling support.  If you happen to publish a paper that uses or discusses GAMA, please let us know, so that we can include it in this list.  As stated in the first page, if you need to cite GAMA in a paper, we kindly ask you to use this reference:   * A. Grignard, P. Taillandier, B. Gaudou, D-A. Vo, N-Q. Huynh, A. Drogoul (2013), GAMA 1.6: Advancing the Art of Complex Agent-Based Modeling and Simulation. In  PRIMA 2013: Principles and Practice of Multi-Agent Systems , Lecture Notes in Computer Science, Vol. 8291, Springer, pp. 117-131.  Papers about GAMA  Taillandier, Patrick, Arnaud Grignard, Benoit Gaudou, and Alexis Drogoul.  Des données géographiques à la simulation à base d agents: application de la plate-forme GAMA.  Cybergeo: European Journal of Geography (2014). A. Grignard, P. Taillandier, B. Gaudou, D-A. Vo, N-Q. Huynh, A. Drogoul (2013), GAMA 1.6: Advancing the Art of Complex Agent-Based Modeling and Simulation. In  PRIMA 2013: Principles and Practice of Multi-Agent Systems , Lecture Notes in Computer Science, Vol. 8291, Springer, pp. 117-131. Grignard, Arnaud, Alexis Drogoul, and Jean-Daniel Zucker.  Online analysis and visualization of agent based models.  Computational Science and Its Applications–ICCSA 2013. Springer Berlin Heidelberg, 2013. 662-672. Taillandier, P., Drogoul, A., Vo, D.A. and Amouroux, E. (2012), GAMA: a simulation platform that integrates geographical information data, agent-based modeling and multi-scale control. In  The 13th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA) , India, Volume 7057/2012, pp 242-258. Taillandier, P. & Drogoul, A. (2011), From Grid Environment to Geographic Vector Agents, Modeling with the GAMA simulation platform. In  25th Conference of the International Cartographic Association , Paris, France. Taillandier, P. ; Drogoul A. ; Vo D.A. & Amouroux, E. (2010), GAMA : bringing GIS and multi-level capabilities to multi-agent simulation, in  the 8th European Workshop on Multi-Agent Systems , Paris, France. Amouroux, E., Taillandier, P. &  Drogoul, A. (2010), Complex environment representation in epidemiology ABM: application on H5N1 propagation. In  the 3rd International Conference on Theories and Applications of Computer Science  (ICTACS 10). Amouroux, E., Chu, T.Q., Boucher, A. and Drogoul, A. (2007), GAMA: an environment for implementing and running spatially explicit multi-agent simulations. In  Pacific Rim International Workshop on Multi-Agents , Bangkoku, Thailand, pp. 359–371.      PhD theses  Truong Xuan Viet,  Optimization by Simulation of an Environmental Surveillance Network: Application to the Fight against Rice Pests in the Mekong Delta (Vietnam) , University of Paris 6 & Ho Chi Minh University of Technology, defended June 24th, 2014. Nguyen Nhi Gia Vinh,  Designing multi-scale models to support environmental decision: application to the control of Brown Plant Hopper invasions in the Mekong Delta (Vietnam) , University of Paris 6, defended Oct. 31st, 2013. Vo Duc An,  An operational architecture to handle multiple levels of representation in agent-based models , University of Paris 6, defended Nov. 30th 2012. Amouroux Edouard,  KIMONO: a descriptive agent-based modeling methodology for the exploration of complex systems: an application to epidemiology , University of Paris 6, defended Sept. 30th, 2011. Chu Thanh Quang,  Using agent-based models and machine learning to enhance spatial decision support systems: Application to resource allocation in situations of urban catastrophes , University of Paris 6, defended July 1st, 2011. Nguyen Ngoc Doanh,  Coupling Equation-Based and Individual-Based Models in the Study of Complex Systems: A Case Study in Theoretical Population Ecology , University of Paris 6, defended Dec. 14th, 2010.      Research papers that use GAMA as modeling/simulation support  2016     Bhamidipati, S., van der Lei, T., & Herder, P. (2016). A layered approach to model interconnected infrastructure and its significance for asset management. EJTIR, 16(1), 254-272.   2014   E. G. Macatulad , A. C. Blanco (2014) 3DGIS-BASED MULTI-AGENT GEOSIMULATION AND VISUALIZATION OF BUILDING EVACUATION USING GAMA PLATFORM. The International Archives of the Photogrammetry, Remote Sensing and Spatial Information Sciences, Volume XL-2, 2014. ISPRS Technical Commission II Symposium, 6 – 8 October 2014, Toronto, Canada. Retrieved from http://www.int-arch-photogramm-remote-sens-spatial-inf-sci.net/XL-2/87/2014/isprsarchives-XL-2-87-2014.pdf S. Bhamidipati (2014) A simulation framework for asset management in climate-change adaptation of transportation infrastructure. In: Proceedings of 42nd European Transport Conference. Frankfurt, Germany. Retrieved from http://abstracts.aetransport.org/paper/download/id/4317 Gaudou, B., Sibertin-Blanc, C., Thérond, O., Amblard, F., Auda, Y., Arcangeli, J.-P., Balestrat, M., Charron-Moirez, M.-H., Gondet, E., Hong, Y., Lardy, R., Louail, T., Mayor, E., Panzoli, D., Sauvage, S., Sanchez-Perez, J., Taillandier, P., Nguyen, V. B., Vavasseur, M., Mazzega, P. (2014). The MAELIA multi-agent platform for integrated assessment of low-water management issues. In: International Workshop on Multi-Agent-Based Simulation (MABS 2013), Saint-Paul, MN, USA, 06/05/2013-07/05/2013, Vol. 8235, Shah Jamal Alam, H. Van Dyke Parunak, (Eds.), Springer, Lecture Notes in Computer Science, p. 85-110. Gaudou, B., Lorini, E., Mayor, E. (2014.) Moral Guilt: An Agent-Based Model Analysis. In: Conference of the European Social Simulation Association (ESSA 2013), Warsaw, 16/09/2013-20/09/2013, Vol. 229, Springer, Advances in Intelligent Systems and Computing, p. 95-106.      2013   * Drogoul, A., Gaudou, B., Grignard, A., Taillandier, P., & Vo, D. A. (2013). Practical Approach To Agent-Based Modelling. In: Water and its Many Issues. Methods and Cross-cutting Analysis. Stéphane Lagrée (Eds.), Journées de Tam Dao, p. 277-300, Regional Social Sciences Summer University.   Drogoul, A., Gaudou, B. (2013) Methods for Agent-Based Computer Modelling. In: Water and its Many Issues. Methods and Cross-cutting Analysis. Stéphane Lagrée (Eds.), Journées de Tam Dao, 1.6, p. 130-154, Regional Social Sciences Summer University.  Truong, M.-T., Amblard, F., Gaudou, B., Sibertin-Blanc, C., Truong, V. X., Drogoul, A., Hyunh, X. H., Le, M. N. (2013). An implementation of framework of business intelligence for agent-based simulation. In: Symposium on Information and Communication Technology (SoICT 2013), Da Nang, Viet Nam, 05/12/2013-06/12/2013, Quyet Thang Huynh, Thanh Binh Nguyen, Van Tien Do, Marc Bui, Hong Son Ngo (Eds.), ACM, p. 35-44. Le, V. M., Gaudou, B., Taillandier, P., Vo, D. A (2013). A New BDI Architecture To Formalize Cognitive Agent Behaviors Into Simulations. In: Advanced Methods and Technologies for Agent and Multi-Agent Systems (KES-AMSTA 2013), Hue, Vietnam, 27/05/2013-29/05/2013, Vol. 252, Dariusz Barbucha, Manh Thanh Le, Robert J. Howlett, C. Jain Lakhmi (Eds.), IOS Press, Frontiers in Artificial Intelligence and Applications, p. 395-403.      2012   * Taillandier, P., Therond, O., Gaudou B. (2012), A new BDI agent architecture based on the belief theory. Application to the modelling of cropping plan decision-making. In  International Environmental Modelling and Software Society , Germany, pp. 107-116.   Taillandier, P., Therond, O., Gaudou B. (2012), Une architecture d agent BDI basée sur la théorie des fonctions de croyance: application à la simulation du comportement des agriculteurs. In  Journées Francophones sur les Systèmes Multi-Agents , France, pp. 107-116. NGUYEN, Quoc Tuan, Alain BOUJU, and Pascal ESTRAILLIER.  Multi-agent architecture with space-time components for the simulation of urban transportation systems.  (2012). Cisse, A., Bah, A., Drogoul, A., Cisse, A.T., Ndione, J.A., Kebe, C.M.F. & Taillandier P. (2012), Un modèle à base d agents sur la transmission et la diffusion de la fièvre de la Vallée du Rift à Barkédji (Ferlo, Sénégal), Studia Informatica Universalis 10 (1), pp. 77-97. Taillandier, P., Amouroux, E., Vo, D.A. and Olteanu-Raimond A.M. (2012), Using Belief Theory to formalize the agent behavior: application to the simulation of avian flu propagation. In  The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS) , India, Volume 7057/2012, pp. 575-587. Le, V.M., Adam, C., Canal, R., Gaudou, B., Ho, T.V. and Taillandier, P. (2012), Simulation of the emotion dynamics in a group of agents in an evacuation situation. In  The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS) , India, Volume 7057/2012, pp. 604-619. Nguyen Vu, Q. A., Canal, R., Gaudou, B., Hassas, S., Armetta, F. (2012), TrustSets - Using trust to detect deceitful agents in a distributed information collecting system. In: Journal of Ambient Intelligence and Humanized Computing, Springer-Verlag, Vol. 3 N. 4, p. 251-263.      2011   * Taillandier, P. & Therond, O. (2011), Use of the Belief Theory to formalize Agent Decision Making Processes : Application to cropping Plan Decision Making. In  25th European Simulation and Modelling Conference , Guimaraes, Portugal, pp. 138-142.   Taillandier, P. & Amblard, F. (2011), Cartography of Multi-Agent Model Parameter Space through a reactive Dicotomous Approach. In  25th European Simulation and Modelling Conference , Guimaraes, Portugal, pp. 38-42. Taillandier, P. & Stinckwich, S. (2011), Using the PROMETHEE Multi-Criteria Decision Making Method to Define New Exploration Strategies for Rescue Robots , IEEE International Symposium on Safety, Security, and Rescue Robotics, Kyoto, Japon, pp. 321 - 326.      2010   * Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S. and Armetta, F. (2010), A cluster-based approach for disturbed, spatialized, distributed information gathering systems,  in  The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS) , India, pp. 588-603.   Nguyen, N.D., Taillandier, P., Drogoul, A. and Augier, P. (2010), Inferring Equation-Based Models from Agent-Based Models: A Case Study in Competition Dynamics.In  The 13th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA) , India, Volume 7057/2012, pp. 413-427. Amouroux, E., Gaudou, B. Desvaux, S. and Drogoul, A. (2010), O.D.D.: a Promising but Incomplete Formalism For Individual-Based Model Specification. in  IEEE International Conference on Computing and Telecommunication Technologies  (2010 IEEE RIVF ), pp. 1-4. Nguyen, N.D., Phan, T.H.D., Nguyen, T.N.A., Drogoul, A. and Zucker, J-D. (2010), Disk Graph-Based Model for Competition Dynamic, Paper to appear in  IEEE International Conference on Computing and Telecommunication Technologies  (2010 IEEE RIVF ). Nguyen, T.K., Marilleau, N., Ho T.V. and El Fallah Seghrouchni, A. (2010), A meta-model for specifying collaborative simulation, Paper to appear in  IEEE International Conference on Computing and Telecommunication Technologies  (2010 IEEE RIVF ). Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S. and Armetta, F. (2010), TrustSets - Using trust to detect deceitful agents in a distributed information collecting system, Paper to appear in  IEEE International Conference on Computing and Telecommunication Technologies  (2010 IEEE RIVF ), the best student paper award. Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S., Armetta, F. and Stinckwich, S. (2010), Using trust and cluster organisation to improve robot swarm mapping, Paper to appear in  Workshop on Robots and Sensors integration in future rescue INformation system   (ROSIN 2010).      2009   * Taillandier, P. and Buard, E. (2009), Designing Agent Behaviour in Agent-Based Simulation through participatory method. In  The 12th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA) , Nagoya, Japan, pp. 571–578.   Taillandier, P. and Chu, T.Q. (2009), Using Participatory Paradigm to Learn Human Behaviour. In  International Conference on Knowledge and Systems Engineering , Ha noi, Viet Nam, pp. 55–60. Gaudou, B., Ho, T.V. and Marilleau, N. (2009), Introduce collaboration in methodologies of modeling and simulation of Complex Systems. In  International Conference on Intelligent Networking and Collaborative Systems (INCOS  09) . Barcelona, pp. 1–8. Nguyen, T.K., Gaudou B., Ho T.V. and Marilleau N. (2009), Application of PAMS Collaboration Platform to Simulation-Based Researches in Soil Science: The Case of the MIcro-ORganism Project. In  IEEE International Conference on Computing and Telecommunication Technologies (IEEE-RIVF 09) . Da Nang, Viet Nam, pp. 296–303. Nguyen, V.Q., Gaudou B., Canal R., Hassas S. and Armetta F. (2009), Stratégie de communication dans un système de collecte d information à base d agents perturbés. In  Journées Francophones sur les Systèmes Multi-Agents (JFSMA 09) .      2008   * Chu, T.Q., Boucher, A., Drogoul, A., Vo, D.A., Nguyen, H.P. and Zucker, J.D. (2008). Interactive Learning of Expert Criteria for Rescue Simulations. In  Pacific Rim International Workshop on Multi-Agents , Ha Noi, Viet Nam, pp. 127–138.     Amouroux, E., Desvaux, S. and Drogoul, A. (2008), Towards Virtual Epidemiology: An Agent-Based Approach to the Modeling of H5N1 Propagation and Persistence in North-Vietnam. In  Pacific Rim International Workshop on Multi-Agents , Ha Noi, Viet Nam, pp. 26–33.  ","url":"wiki/References.md"},{"id":"wiki/WritingModels.md","title":" Writing Models","content":"Writing Models  Models in GAMA play the same role as classes in Java or C++: they represent both the knowledge about a particular phenomenon a user wants to simulate and the way(s) to simulate it. A model is nothing more than a text file (or a collection of text files that refer to each other), which contains instructions in a specific language called GAML (for  GAMA Modeling Language ). A model can then be theoretically edited using any text processor and later loaded into GAMA to run experiments. However, because of the richness of the language, using a dedicated tool (with online help, live validation) is clearly the best way to write correct models.  The GUI version of GAMA offers such an integrated model development environment, which is composed of a set of coupled tools to support modelers in the edition, validation, and management of models. An optional graphical modeling editor can also be installed on top of these tools to support higher-level modeling activities (similar to what a UML editor with Java bindings may provide to a Java development environment).  This chapter contains a description of these different tools and a comprehensive guide to the GAML language, including a complete reference of all the built-in structures and facilities offered in its current version.  Please proceed to one of these sections :       Editing Models   GAML Language   GAML Reference   Optimizing Models   ","url":"wiki/WritingModels.md"},{"id":"wiki/G__BlankPage.md","title":"G__BlankPage","content":"","url":"wiki/G__BlankPage.md"},{"id":"wiki/Home.md","title":" Multiple application domains","content":"The new website of GAMA is now available at this address : gama-platform.org    GAMA is a modeling and simulation development environment for building spatially explicit agent-based simulations.     Multiple application domains : Use GAMA for whatever application domain you want.   High-level and Intuitive Agent-based language : Write your models easily using GAML, a high-level and intuitive agent-based language.   GIS and Data-Driven models : Instantiate agents from any dataset, including GIS data, and execute large-scale simulations (up to millions of agents).   Declarative user interface : Declare interfaces supporting deep inspections on agents, user-controlled action panels, multi-layer 2D/3D displays & agent aspects.   Its latest version, 1.7, can be freely downloaded or built from source, and comes pre-loaded with several models, tutorials and a complete on-line documentation.  Multiple application domains  GAMA has been developed with a very general approach, and can be used for many application domains. Some additional plugins had been developed to fit with particular needs.  Example of application domains where GAMA is mostly present : * Transport * Urban planning * Epidemiology * Environment  Some training sessions about topics such as  urban management ,  epidemiology ,  risk management  are also provided by the team. Since GAMA is an open-source software that continues to grow, if you have any particular needs of improvement, feel free to share it to its active community !    High level and intuitive language  Thanks to its high-level and intuitive language, GAMA has been developed to be used by non-computer scientists. You can declare your species, giving them some special behaviors, create them in your world, and display them in less than 10 minutes.  GAML is the language used in GAMA, coded in Java. It is an agent-based language, that provides you the possibility to build your model with several paradigms of modeling. Once your model is ready, some features allows you to explore and calibrate it, using the parameters you defined as input of your simulation.  We provides you a continual support through the active mailing list where the team will answer your questions. Besides, you can learn GAML on your own, following the step by step tutorial, or personal learning path in order reach the point you are interested in.    GIS and Data-Driven models  GAMA (GIS Agent-based Modeling Architecture) provides you, since its creation, the possibility to load easily GIS (Geographic Information System).  You can import a large number of data types, such as text, files, CSV, shapefile, OSM (open street map data), grid, images, SVG, but also 3D files, such as 3DS or OBJ, with their texture.  Some advanced features provides you the possibility to connect GAMA to databases, and also to use powerful statistical tools such as R.  GAMA has been used in large-scale projects, using a great number of agents (up to millions of agents).    Declarative user interface  GAMA provides you the possibility to have multiple displays for the same model. You can add as much visual representations as you want for the same model, in order to highlight a certain aspect of your simulation. Add easily new visual aspects to your agents.  Advanced 3D displays are provided : you can control lights, cameras, and also adding textures to your 3D objects. In an other hand, dedicated statements allows you to define easily charts, such as series, histogram, or pies.  During the simulations, some advanced features are available to inspect the population of your agents. To make your model more interactive, you can add easily some user-controlled action panels, or mouse events.      GAMA is developed by several teams under the umbrella of the IRD/UPMC international research unit UMMISCO:     MSI Research Team, Vietnam National University, Hanoi, Vietnam (2007 - 2015)   UMR 6228 IDEES, CNRS/University of Rouen, France (2010 - 2015)   UMR 5505 IRIT, CNRS/University of Toulouse 1, France (2010 - 2015)   DREAM Research Team, University of Can Tho, Vietnam (2011 - 2015)   UMR 8623 LRI, CNRS/University Paris-Sud, France (2011 - 2015)     Acknowledgement:    YourKit supports open source projects with its full-featured Java Profiler. YourKit, LLC is the creator of YourKit Java Profiler and YourKit .NET Profiler, innovative and intelligent tools for profiling Java and .NET applications. ","url":"wiki/Home.md"}]