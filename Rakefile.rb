require 'yaml'
require 'uri'
require 'json'
require 'nokogiri'
require 'kramdown'
# use Jekyll configuration file
CONFIG = YAML.load_file("_config.yml")
URL_LAYOUT_DEFAULT = "../_layouts/default.html"
URL_LAYOUT_HOME = "../_layouts/home.html"
URL_MENU_FILE = "_Sidebar.md"
task default: :build_dev


#-----------------------------------------
#                TOOLS
#-----------------------------------------
def check_configuration
  if CONFIG['wikiToJekyll'].nil? or CONFIG['wikiToJekyll'].empty?
    raise "Please set your configuration in _config.yml. See the readme."
  end
end

def build_jekyll
  system 'jekyll build'
end

#deploying the updated website to the github.io repository
def deploy
    puts "deploying"
    #add the vendor to things ignored by github
    open(".gitignore", 'w') do |gitPage|
        gitPage.puts "vendor/*"
    end
    #add the repository of the github.io to a remote git folder to commit it
    system 'git remote add origin https://hqnghi88:$HQN_KEY@github.com/gama-platform/gama-platform.github.io.git'
    system 'git config user.name "Travis CI"'
    system 'git config user.email "travis@travis-ci.org"'
    system "git add -A"
    message = "Site wiki update #{Time.now.utc}"
    puts "\n## :Committing => #{message}"
    system "git commit -m \"#{message}\""
    puts "\n## Pushing website"
    system "git push origin --quiet"
    puts "\n## Github Pages deploy complete"
end
#count the number of times a substring is occuring inside a string
def count_em(string, substring)
  string.scan(/(?=#{substring})/).count
end

def g(key)
  CONFIG['wikiToJekyll'][ key ]
end

#method to add the submodule and import the wiki files inside the folder to update the website github.io
def wikisubfunction
  puts "adding wiki as submodule"
  #check the configuration of the module
  check_configuration
  wiki_repository = get_wiki_repository_url
  command = 'git submodule add ' + wiki_repository + ' ' + g('wiki_source')
  command += ' && git submodule init'
  command += ' && git submodule update'
  #execute the command written previously to add the submodule and import it
  output = `#{command}`
  puts output
  if output.include? 'failed'
    abort("submodule add failed : verify you configuration and that your wiki is public") # exit
  end

  puts "wiki submodule OK"
end

#method to return the wiki_repository url
def get_wiki_repository_url
  url = g('wiki_repository_url') #|| derived_url
end

#method to update the submodule in case of it being already present in the folder but not being at the newest version
def update_wiki_submodule
    pullCommand = 'git submodule foreach git pull origin master'
    puts "Updating wiki submodule"
    output = `#{pullCommand}`

    if output.include? 'Already up-to-date'
      puts "No update necessary" # exit
    end
    puts output
  end
def wikibuildfunction
  clean_wiki_folders
  copy_wiki_pages
  build_jekyll
end

#-----------------------------------------
#     Clean the destination folder
#-----------------------------------------
def clean_wiki_folders
  puts "Trying to clean the wiki"
  if File.exist?(g('wiki_dest'))
    #remove the folder to clean the wiki
    removeFolder("")    
  end
  #create the destination folder for the wiki
  FileUtils.mkdir(g('wiki_dest'))
end

def removeFolder(folder)
  puts "Inside "+folder
  #Delete all the files contained in the given folder
  Dir.glob(File.join("#{g('wiki_dest')}",folder,"/*.md")) do |wikiPage|
    FileUtils.rm_rf(wikiPage)
  end
  #Finally remove the folder once all the files contained have being removed
  FileUtils.rm_rf(File.join("#{g('wiki_dest')}",folder))
end


#-----------------------------------------
#    Copy the wiki pages and resources
#-----------------------------------------
def copy_wiki_pages
  index = []
  puts "--------------------FINDING PAGES--------------------"
  #retreive all the pages inside the folder and add them to the index array
  findPages("",index)
  puts "--------------------COPYING RESOURCES--------------------"
  #copy all the resources found inside the wiki folder
  copyResources()
  puts "--------------------GENERATING MENU--------------------"
  #create the menu that will be presented in the Documentation and Tutorials left side, generated by the one given in the wiki
  defineLayoutMenu()
  #Generate the index using all the pages for the search module
  File.open("./indexes/lunr.json","w") do |f|
    f.write(JSON.generate(index))
  end
end
def copyResources()
  #copy all the resources contained inside the folder resources of the wiki folder
  folderResources = "resources"
  findResources(folderResources)
end
def findResources(folder)
  #Find all resources contained inside a folder and its children folders
  FileUtils.mkdir(File.join("#{g('wiki_dest')}",folder))
  subdir_list = Dir.entries(File.join("#{g('wiki_source')}",folder)).select {|entry| File.directory? File.join("#{g('wiki_source')}",folder,entry) and !(entry =='.'||entry =='.git' || entry == '..') }
  #Do in a recursive way, a search of all the folders contained in the resources folder
  subdir_list.each do |subfolder|
    findResources(File.join(folder,subfolder))
  end
  #copy all the resources files of the folder to the wiki destination folder building the same folder tree 
  Dir.glob(File.join("#{g('wiki_source')}",folder,"*.*")) do |aResource|
    FileUtils.chmod(0777, aResource)
    FileUtils.cp_r(aResource,File.join("#{g('wiki_dest')}",folder,File.basename(aResource)))
  end
end
def findPages(folder,index)
  #find all the md pages inside a folder and its subfolder
  #puts "Looking for pages in "+folder
  subdir_list = Dir.entries(File.join("#{g('wiki_source')}",folder)).select {|entry| File.directory? File.join("#{g('wiki_source')}",folder,entry) and !(entry =='.'||entry =='.git' || entry == '..' || entry =="resources") }
  
  #Do in a recursive way, a search of all the folders contained in the current folder having .md files
  subdir_list.each do |subfolder|
    findPages(File.join(folder,subfolder),index)
  end
  #do the thing for all the .md files
  Dir.glob(File.join("#{g('wiki_source')}",folder,"*.*")) do |aFile|
    wikiPageFileName = File.basename(aFile).gsub(" ","-")
    wikiPagePath     = File.join("#{g('wiki_dest')}", wikiPageFileName)
    #puts "Copying Page :  "+aFile+" to "+wikiPagePath
    if(File.extname(aFile)==".md")
          
          # remove extension
          wikiPageName    = wikiPageFileName.sub(/.[^.]+\z/,'')
          wikiPageTitle = File.basename(wikiPageName)
          File.foreach(aFile) do |line|
            if(line.include? "#")and(line[0]=="#")
              wikiPageTitle = line.gsub("\#","")
              wikiPageTitle = wikiPageTitle.gsub("\n","")
              if(wikiPageTitle[0]!=" ")
                wikiPageTitle=" "+wikiPageTitle
              end
              break
            end
          end 
          fileContent      = File.read(aFile)
          fileHTML=Kramdown::Document.new(fileContent).to_html
          doc = Nokogiri::HTML(fileHTML)
          text = doc.xpath("//text()").text.to_s
          text = text.encode('UTF-8', :invalid => :replace, :undef => :replace)
          text = text.gsub("\\t"," ")
          text = text.gsub("\"","")
          text = text.gsub("\n"," ")
          text = text.gsub("\r"," ")
          text = text.gsub("\""," ")
          text = text.gsub("\'"," ")
          text = text.gsub("'"," ")
          text = text.gsub("\\r"," ")
          text = text.gsub("           "," ")
          text = text.gsub("        "," ")
          text = text.gsub("*.\s.*"," ")
          text = text.gsub("\t"," ")
          text = text.gsub("\“"," ")
          text = text.gsub("\‘"," ")
          text = text.gsub("\’"," ")
          text = text.gsub("\”"," ")
          text = text.gsub("\`"," ")
          text = text.gsub("\[","")
          text = text.gsub("\[","")
          text = text.gsub("\]","")
          text = text.gsub("\]","")
          index<<{"id"=>wikiPagePath,"title"=>wikiPageTitle,"content"=>text,"url"=>wikiPagePath}
          folderString = File.join("#{g('wiki_dest')}",folder)
          # write the new file with yaml front matter
          open(wikiPagePath, 'w') do |newWikiPage|
            newWikiPage.puts "---"
            newWikiPage.puts "layout: default"
            newWikiPage.puts "title:#{wikiPageTitle}"
            newWikiPage.puts "wikiPageName: #{wikiPageName}"
            newWikiPage.puts "wikiPagePath: #{wikiPagePath}"
            newWikiPage.puts "---"
            newWikiPage.puts fileContent
          end
          if(File.basename(aFile)=="OperatorsSplitted.md")
            tmp_index=[]
            fileContent.scan(/.*(\[\/\/\]:\s\#\s\(keyword\|operator\_.*\))/) do |anOccurence|
                strOcc = clearFromCharacterForJson(anOccurence,"operator_")
                tmp_index<<{"id"=>strOcc,"title"=>"operator:\s"+strOcc, "url"=>"/wiki/OperatorsSplitted#"+strOcc, "content"=>strOcc}
            end
            File.open("./indexes/lunr.operators.json","w") do |f|
                f.write(tmp_index.to_json)
            end
          end
          if(File.basename(aFile)=="BuiltInArchitectures.md")
            tmp_index=[]
            fileContent.scan(/.*(\[\/\/\]:\s\#\s\(keyword\|architecture\_.*\))/) do |anOccurence|
                strOcc = clearFromCharacterForJson(anOccurence,"architecture_")
                tmp_index<<{"id"=>strOcc,"title"=>"architecture:\s"+strOcc, "url"=>"/wiki/BuiltInArchitectures#"+strOcc, "content"=>strOcc}
            end
            File.open("./indexes/lunr.architectures.json","w") do |f|
                f.write(tmp_index.to_json)
            end
          end
          if(File.basename(aFile)=="BuiltInSkills.md")
            tmp_index=[]
            fileContent.scan(/.*(\[\/\/\]:\s\#\s\(keyword\|skill\_.*\))/) do |anOccurence|
                strOcc = clearFromCharacterForJson(anOccurence,"skill_")
                tmp_index<<{"id"=>strOcc,"title"=>"skill:\s"+strOcc, "url"=>"/wiki/BuiltInSkills#"+strOcc, "content"=>strOcc}
            end
            File.open("./indexes/lunr.skills.json","w") do |f|
                f.write(tmp_index.to_json)
            end
          end
          if(File.basename(aFile)=="BuiltInSpecies.md")
            tmp_index=[]
            fileContent.scan(/.*(\[\/\/\]:\s\#\s\(keyword\|species\_.*\))/) do |anOccurence|
                strOcc = clearFromCharacterForJson(anOccurence,"species_")
                tmp_index<<{"id"=>strOcc,"title"=>"species:\s"+strOcc, "url"=>"/wiki/BuiltInSpecies#"+strOcc, "content"=>strOcc}
            end
            File.open("./indexes/lunr.species.json","w") do |f|
                f.write(tmp_index.to_json)
            end
          end
          if(File.basename(aFile)=="DataTypes.md")
            tmp_index=[]
            fileContent.scan(/.*(\[\/\/\]:\s\#\s\(keyword\|type\_.*\))/) do |anOccurence|
                strOcc = clearFromCharacterForJson(anOccurence,"type_")
                tmp_index<<{"id"=>strOcc,"title"=>"type:\s"+strOcc, "url"=>"/wiki/DataTypes#"+strOcc, "content"=>strOcc}
            end
            File.open("./indexes/lunr.types.json","w") do |f|
                f.write(tmp_index.to_json)
            end
          end
          if(File.basename(aFile)=="Literals.md")
            tmp_index=[]
            fileContent.scan(/.*(\[\/\/\]:\s\#\s\(keyword\|concept\_.*\))/) do |anOccurence|
                strOcc = clearFromCharacterForJson(anOccurence,"concept_")
                tmp_index<<{"id"=>strOcc,"title"=>"concept:\s"+strOcc, "url"=>"/wiki/Literals#"+strOcc, "content"=>strOcc}
            end
            File.open("./indexes/lunr.literals.json","w") do |f|
                f.write(tmp_index.to_json)
            end
          end
          if(File.basename(aFile)=="Statements.md")
            tmp_index=[]
            fileContent.scan(/.*(\[\/\/\]:\s\#\s\(keyword\|statement\_.*\))/) do |anOccurence|
                strOcc = clearFromCharacterForJson(anOccurence,"statement_")
                tmp_index<<{"id"=>strOcc,"title"=>"statement:\s"+strOcc, "url"=>"/wiki/Statements#"+strOcc, "content"=>strOcc}
            end
            File.open("./indexes/lunr.statements.json","w") do |f|
                f.write(tmp_index.to_json)
            end
          end
          if(File.basename(aFile)=="UnitsAndConstants.md")
            tmp_index=[]
            fileContent.scan(/.*(\[\/\/\]:\s\#\s\(keyword\|constant\_.*\))/) do |anOccurence|
                strOcc = clearFromCharacterForJson(anOccurence,"constant_")
                tmp_index<<{"id"=>strOcc,"title"=>"constant:\s"+strOcc, "url"=>"/wiki/UnitsAndConstants#"+strOcc, "content"=>strOcc}
            end
            File.open("./indexes/lunr.constants.json","w") do |f|
                f.write(tmp_index.to_json)
            end
          end
    else
      FileUtils.cp(aFile,wikiPagePath)
    end
  end
end
def clearFromCharacterForJson(anOccurence,removable)
    strOcc = anOccurence.to_s
    strOcc = strOcc.sub("\"","")
    strOcc = strOcc.sub("\"","")
    strOcc = strOcc.sub("\[","")
    strOcc = strOcc.sub("\[","")
    strOcc = strOcc.sub("\]","")
    strOcc = strOcc.sub("\]","")
    strOcc = strOcc.sub("\(","")
    strOcc = strOcc.sub("\)","")
    strOcc = strOcc.sub("\#","")
    strOcc = strOcc.sub("\:","")
    strOcc = strOcc.sub("\/","")
    strOcc = strOcc.sub("\/","")
    strOcc = strOcc.sub(" ","")
    strOcc = strOcc.sub(" ","")
    strOcc = strOcc.sub("keyword","")
    strOcc = strOcc.sub(removable,"")
    strOcc = strOcc.sub("|","")
    return strOcc
end
#-----------------------------------------
#      Creation of the Menu Layout
#-----------------------------------------
def defineLayoutMenu
  #puts "Removing Old Menu and Home Layout"
  rm_rf File.join("#{g('wiki_source')}",URL_LAYOUT_DEFAULT)
  #puts "Generating New Menu"
  open(File.join("#{g('wiki_source')}",URL_LAYOUT_DEFAULT), 'w') do |newLayout|
    newLayout.puts '
    <!doctype html><html lang="en"><head><meta charset="utf-8"><title>{{ page.title }}</title></head>
    <body>
    {% include style.html %}
    {% include menu.html %}
    '
    oldUnder=-1
    File.foreach(File.join("#{g('wiki_source')}",URL_MENU_FILE)) do |line|
      currentUnder = count_em(line,"#")
      #Fils du courant
      if(currentUnder>0)
        if(oldUnder==-1)
          newLayout.puts '
    <div class="w3-row-padding w3-container">
        <div>
             <div class="w3-quarter">
                <div class="w3-margin-right">
		<nav class="w3-bar-block w3-collapse w3-large w3-theme-l5 w3-animate-left w3-small w3-round w3-light-gray w3-border w3-border-black"  style="margin-left:10px" id="mySidebar">
                    <div class="w3-medium w3-text-black w3-margin-left" style=""><div id="sub" class="w3-bar-block w3-small">'
          
          title=line.gsub("#","")
          newLayout.puts "<b>"+linkup(title)+"</b><br/>"
          oldUnder=1
        else
          newLayout.puts "</div>      <div id='sub' class='w3-bar-block w3-small'>"
          title=line.gsub("#","")
          newLayout.puts "<b>"+linkup(title)+"</b><br/>"
        end
      else
          title=line.gsub("#"," ")
          ind = 0
          strSpace =""
          while ind < getNbWSpacesBeforeCharacter(title)  do
            ind=ind+1
            strSpace=strSpace+" "
          end
          newLayout.puts strSpace+"<div style='padding-left:"+ind.to_s+"em'>"+linkup(title)+"</div>"
      end
      
    end
    newLayout.puts '</div></div></div></nav></div>
    <div class="w3-twothird w3-margin-left">
    <div class="w3-threequarter">
        {{ content }}
    </div>
    </div>
    </div>
    </div>
    </body></html>'
  end
  
 
end
def getNbWSpacesBeforeCharacter(str)
    nbSpace=0
    str.split("").each do |i|
        if(i==" ")
            nbSpace=nbSpace+1
        else
            if(i=="[")
                break
            end
        end
    end
    return nbSpace
end
def linkup( str )
    nbBrackets=-1
    posStarting=-1
    posEnding=-1
    nbCount=-1
    str.split("").each do |i|
        nbCount=nbCount+1
        if(i=="[")
            nbBrackets=nbBrackets+1
            if(nbBrackets==0)
                posStarting=nbCount
            end
        end
        if(i=="]")
            nbBrackets=nbBrackets-1
            if(nbBrackets==-1)
                posEnding=nbCount
            end
        end
    end
    label = str[posStarting+1..posEnding-1]
    
    nbParenthesis=-1
    posParenthesisStarting=posEnding+1
    posParenthesisEnding=-1
    nbCount=posEnding+1
    
    str[posEnding+1..str.length()].split("").each do |i|
        nbCount=nbCount+1
        if(i=="(")
            nbParenthesis=nbParenthesis+1
            if(nbParenthesis==0)
                posParenthesisStarting=nbCount
            end
        end
        if(i==")")
            nbParenthesis=nbParenthesis-1
            if(nbParenthesis==-1)
                posParenthesisEnding=nbCount
            end
        end
    end
    link = str[posParenthesisStarting..posParenthesisEnding-2]
    if(posStarting==-1)
        str=label
    else
        str='<a href="/wiki/'+link+'" class="wiki_menu" >'+label+'</a>'
    end
end
#-----------------------------------------
#               Tasks
#-----------------------------------------
#Function to synchronise the git
task :wiki do |t|
    puts "Checking Configuration"
    check_configuration
    puts "Adding Submodule"
    wikisubfunction
    puts "Updating Submodule"
    update_wiki_submodule
    puts "Executing Wikibuild"
    wikibuildfunction
    command = 'git rm -r --cached _wiki'
    output = `#{command}` 
    
    #puts "Deploying"
    #deploy
    open(".gitignore", 'w') do |gitPage|
        gitPage.puts "vendor/*"
        gitPage.puts ".bundle/*"
    end
    puts "Wiki synchronisation success !"
end
#Function to add the git of the wiki to a folder
task :wikisub do |t|
  wikisubfunction
end

task :wikiupdate do |t|
    update_wiki_submodule
end

#Function to build the wiki
task :wikibuild do |t|
  puts ':rake =>wikibuild'
  wikibuildfunction
end
#Function to define the menu
task :wikimenu do |t|
  puts ':rake =>wikimenu'
  defineLayoutMenu()
end


task :prod do |t|
  puts "Building with production parameters"
  sh 'jekyll build'
end

task :deploy do |t|
    deploy
end
