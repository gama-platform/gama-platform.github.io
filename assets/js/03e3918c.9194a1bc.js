"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[61969],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(n),d=o,f=m["".concat(s,".").concat(d)]||m[d]||u[d]||a;return n?r.createElement(f,i(i({ref:t},c),{},{components:n})):r.createElement(f,i({ref:t},c))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:o,i[1]=l;for(var p=2;p<a;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},95845:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>l,metadata:()=>p,toc:()=>m});var r=n(87462),o=n(63366),a=(n(67294),n(3905)),i=["components"],l={title:"4. Inspectors and Monitors"},s=void 0,p={unversionedId:"PredatorPrey_step4",id:"version-1.8.1/PredatorPrey_step4",title:"4. Inspectors and Monitors",description:"This fourth step illustrates how to monitor more precisely the simulation. Practically, we will define monitors to follow the evolution of specific variables (or expression) whereas inspectors allow the user to follow the state of a given agent (or a species).",source:"@site/versioned_docs/version-1.8.1/PredatorPrey_step4.md",sourceDirName:".",slug:"/PredatorPrey_step4",permalink:"/wiki/1.8.1/PredatorPrey_step4",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/PredatorPrey_step4/_edit",tags:[],version:"1.8.1",frontMatter:{title:"4. Inspectors and Monitors"},sidebar:"tuto",previous:{title:"3. Prey Agent Behavior",permalink:"/wiki/1.8.1/PredatorPrey_step3"},next:{title:"5. Predator Agent",permalink:"/wiki/1.8.1/PredatorPrey_step5"}},c={},m=[{value:"Formulation",id:"formulation",level:2},{value:"Model Definition",id:"model-definition",level:2},{value:"global variable",id:"global-variable",level:3},{value:"monitor",id:"monitor",level:3},{value:"inspector",id:"inspector",level:3},{value:"Complete Model",id:"complete-model",level:2}],u={toc:m};function d(e){var t=e.components,l=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},u,l,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This fourth step illustrates how to monitor more precisely the simulation. Practically, we will define monitors to follow the evolution of specific variables (or expression) whereas inspectors allow the user to follow the state of a given agent (or a species)."),(0,a.kt)("h2",{id:"formulation"},"Formulation"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Adding of a monitor to follow the evolution of the number of prey agents")),(0,a.kt)("h2",{id:"model-definition"},"Model Definition"),(0,a.kt)("h3",{id:"global-variable"},"global variable"),(0,a.kt)("p",null,"We add a new global variable:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"nb_preys"),": returns, each time it is called, the current number of (live) prey agents")),(0,a.kt)("p",null,"To do so we use the ",(0,a.kt)("inlineCode",{parentName:"p"},"->{expression}")," facet which returns the value of ",(0,a.kt)("strong",{parentName:"p"},"expression"),", each time it is called.\nWe use as well the operator ",(0,a.kt)("inlineCode",{parentName:"p"},"length")," that returns the number of elements in a list."),(0,a.kt)("p",null,"Thus, in the global section, we add the ",(0,a.kt)("inlineCode",{parentName:"p"},"nb_preys")," global variable:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"int nb_preys -> {length (prey)};\n")),(0,a.kt)("h3",{id:"monitor"},"monitor"),(0,a.kt)("p",null,"A monitor allows to follow the value of an arbitrary expression in GAML. It has to be defined in an output section. A monitor is defined as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"monitor monitor_name value: an_expression refresh: every(nb_steps);\n")),(0,a.kt)("p",null,"With:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"value"),": mandatory, its that value will be displayed in the monitor."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"refresh"),": bool, optional: if the expression is true, compute (default is true).")),(0,a.kt)("p",null,"In this model, we define a monitor to follow the value of the variable ",(0,a.kt)("strong",{parentName:"p"},"nb","_","preys"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'monitor "number of preys" value: nb_preys;\n')),(0,a.kt)("h3",{id:"inspector"},"inspector"),(0,a.kt)("p",null,"Inspectors allow to obtain information about a species or an agent. There are two kinds of agent information features:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Species browser"),": provides information about all the agents of a species. Available in the Agents menu.")),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"images/browser_table.png",src:n(57274).Z,width:"2706",height:"2100"})),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Agent inspector"),": provides information about one specific agent. Also allows to change the values of its variables during the simulation. Available from the Agents menu, by right","_","clicking on a display, in the species inspector or when inspecting another agent. It provides also the possibility to \xabhighlight\xbb the inspected agent.")),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"images/inspector.png",src:n(63061).Z,width:"3282",height:"1878"})),(0,a.kt)("h2",{id:"complete-model"},"Complete Model"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'model prey_predator\n\nglobal {\n    int nb_preys_init <- 200;\n    float prey_max_energy <- 1.0;\n    float prey_max_transfer <- 0.1;\n    float prey_energy_consum <- 0.05;\n    int nb_preys -> {length (prey)};\n    \n    init {\n    create prey number: nb_preys_init ;\n    }\n}\n\nspecies prey {\n    float size <- 1.0 ;\n    rgb color <- #blue;\n    float max_energy <- prey_max_energy ;\n    float max_transfer <- prey_max_transfer ;\n    float energy_consum <- prey_energy_consum ;\n        \n    vegetation_cell my_cell <- one_of (vegetation_cell) ; \n    float energy <- rnd(max_energy) update: energy - energy_consum max: max_energy ;\n        \n    init { \n        location <- my_cell.location;\n    }\n        \n    reflex basic_move { \n    my_cell <- one_of (my_cell.neighbors2) ;\n    location <- my_cell.location ;\n    }\n    reflex eat when: my_cell.food > 0 { \n    float energy_transfer <- min([max_transfer, my_cell.food]) ;\n    my_cell.food <- my_cell.food - energy_transfer ;\n    energy <- energy + energy_transfer ;\n    }\n    reflex die when: energy <= 0 {\n    do die ;\n    }\n\n    aspect base {\n    draw circle(size) color: color ;\n    }\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n    float max_food <- 1.0 ;\n    float food_prod <- rnd(0.01) ;\n    float food <- rnd(1.0) max: max_food update: food + food_prod ;\n    rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\n    list<vegetation_cell> neighbors2  <- (self neighbors_at 2);\n}\n\nexperiment prey_predator type: gui {\n    parameter "Initial number of preys: " var: nb_preys_init min: 1 max: 1000 category: "Prey" ;\n    parameter "Prey max energy: " var: prey_max_energy category: "Prey" ;\n    parameter "Prey max transfer: " var: prey_max_transfer  category: "Prey" ;\n    parameter "Prey energy consumption: " var: prey_energy_consum  category: "Prey" ;\n    output {\n    display main_display {\n        grid vegetation_cell lines: #black ;\n        species prey aspect: base ;\n    }\n    monitor "Number of preys" value: nb_preys ;\n    }\n}\n')))}d.isMDXComponent=!0},57274:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/predator_prey_browser-a0da665795c9d5342bcdd164c76ca884.png"},63061:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/predator_prey_inspector-cb33c8dfd4c98093b5c5338778203752.png"}}]);