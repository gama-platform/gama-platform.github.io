"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9639],{16185:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var i=l(74848),t=l(28453);const a={title:"Example usage of clean_network in GAMA Platform"},o=void 0,s={id:"CleaningGISData",title:"Example usage of clean_network in GAMA Platform",description:"Introduction",source:"@site/../docs/CleaningGISData.md",sourceDirName:".",slug:"/CleaningGISData",permalink:"/wiki/next/CleaningGISData",draft:!1,unlisted:!1,editUrl:"https://github.com/gama-platform/gama/wiki/CleaningGISData/_edit",tags:[],version:"current",frontMatter:{title:"Example usage of clean_network in GAMA Platform"},sidebar:"main",previous:{title:"Manipulate OSM Datas",permalink:"/wiki/next/ManipulateOSMDatas"},next:{title:"Implementing diffusion",permalink:"/wiki/next/Diffusion"}},r={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Syntax",id:"syntax",level:2},{value:"Parameters Explained",id:"parameters-explained",level:2},{value:"1. geometries (list&lt;geometry&gt;)",id:"1-geometries-listgeometry",level:3},{value:"2. tolerance (float)",id:"2-tolerance-float",level:3},{value:"3. split_lines (boolean)",id:"3-split_lines-boolean",level:3},{value:"4. keepMainConnectedComponent (boolean)",id:"4-keepmainconnectedcomponent-boolean",level:3},{value:"Common Usage",id:"common-usage",level:2},{value:"Basic Network Cleaning",id:"basic-network-cleaning",level:3},{value:"Implementation Example",id:"implementation-example",level:2}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"clean_network"})," operator can be used used for cleaning and optimizing road networks. It helps deal with issues in GIS data such as disconnected segments, overlapping roads, and imprecise geometry."]}),"\n",(0,i.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-gama",children:"clean_network(\n    list<geometry> geometries,\n    float tolerance,\n    bool split_lines,\n    bool keepMainConnectedComponent\n)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"parameters-explained",children:"Parameters Explained"}),"\n",(0,i.jsx)(n.h3,{id:"1-geometries-listgeometry",children:"1. geometries (list<geometry>)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"What it is: Collection of geometries (usually road segments) to clean"}),"\n",(0,i.jsxs)(n.li,{children:["How to get it: ",(0,i.jsx)(n.code,{children:"road collect each.shape"})," or ",(0,i.jsx)(n.code,{children:"road_shapefile.contents"})]}),"\n",(0,i.jsx)(n.li,{children:"Example:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-gama",children:"list<geometry> road_geometries <- road collect each.shape;\nlist<geometry> road_geometries <- road_shapefile.contents;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-tolerance-float",children:"2. tolerance (float)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"What it is: Maximum distance between points to be considered for merging"}),"\n",(0,i.jsxs)(n.li,{children:["Recommended values:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Small networks: 0.1 to 1.0 (e.g., urban network)"}),"\n",(0,i.jsx)(n.li,{children:"Large networks: 1.0 to 5.0 (e.g., rural network, highway network)"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Effects:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Lower values (e.g., 0.1): More precise, less merging"}),"\n",(0,i.jsx)(n.li,{children:"Higher values (e.g., 5.0): More aggressive merging"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Example scenarios:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["For precise road networks: ",(0,i.jsx)(n.code,{children:"tolerance <- 0.5"})]}),"\n",(0,i.jsxs)(n.li,{children:["For rough networks: ",(0,i.jsx)(n.code,{children:"tolerance <- 2.0"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-split_lines-boolean",children:"3. split_lines (boolean)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"What it is: Whether to split roads at intersection points"}),"\n",(0,i.jsxs)(n.li,{children:["Values:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"true: Split roads at intersections (recommended for navigation)"}),"\n",(0,i.jsx)(n.li,{children:"false: Keep roads as continuous lines"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["When to use:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"true: For routing and navigation purposes"}),"\n",(0,i.jsx)(n.li,{children:"false: For visualization or analysis only"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"4-keepmainconnectedcomponent-boolean",children:"4. keepMainConnectedComponent (boolean)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"What it is: Whether to keep only the main connected network"}),"\n",(0,i.jsxs)(n.li,{children:["Values:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"true: Remove isolated road segments"}),"\n",(0,i.jsx)(n.li,{children:"false: Keep all road segments"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["When to use:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"true: For ensuring network connectivity"}),"\n",(0,i.jsx)(n.li,{children:"false: When isolated segments are important"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"common-usage",children:"Common Usage"}),"\n",(0,i.jsx)(n.h3,{id:"basic-network-cleaning",children:"Basic Network Cleaning"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-gama",children:"// Basic cleaning with default values\nlist<geometry> clean_lines <- clean_network(\n    road collect each.shape,\n    1.0,    // moderate tolerance\n    true,   // split at intersections\n    true    // keep only main network \n);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"implementation-example",children:"Implementation Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-gama",children:"global {\n  // Network cleaning parameters\n  float tolerance <- 1.0;\n  bool split_lines <- true;\n  bool keep_main_connected <- true;\n\n    init {\n        // Create initial roads\n        create road from: road_shapefile;\n        \n        // Clean the network\n        list<geometry> clean_lines <- clean_network(\n            road collect each.shape,\n            tolerance,\n            split_lines,\n            keep_main_connected\n        );\n        \n        // Remove old roads\n        ask road {\n            do die;\n        }\n        \n        // Create new roads\n        loop clean_geom over: clean_lines {\n            create road {\n                shape <- clean_geom;\n            }\n        }\n        \n        // Create network graph\n        road_network <- as_edge_graph(road);\n    }\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,l)=>{l.d(n,{R:()=>o,x:()=>s});var i=l(96540);const t={},a=i.createContext(t);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);