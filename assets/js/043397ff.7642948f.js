"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[25237],{87752(e,n,t){t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"DefiningGUIExperiment","title":"Defining GUI Experiment","description":"[//]: # (startConcept|gui_experiments)","source":"@site/../docs/DefiningGUIExperiment.md","sourceDirName":".","slug":"/DefiningGUIExperiment","permalink":"/wiki/next/DefiningGUIExperiment","draft":false,"unlisted":false,"editUrl":"https://github.com/gama-platform/gama/wiki/DefiningGUIExperiment/_edit","tags":[],"version":"current","frontMatter":{"title":"Defining GUI Experiment"},"sidebar":"main","previous":{"title":"Multi-level architecture","permalink":"/wiki/next/MultiLevelArchitecture"},"next":{"title":"Defining Parameters","permalink":"/wiki/next/DefiningParameters"}}');var s=t(74848),r=t(28453);const o={title:"Defining GUI Experiment"},l=void 0,a={},c=[{value:"Types of experiments",id:"types-of-experiments",level:2},{value:"Experiment attributes",id:"experiment-attributes",level:2},{value:"Experiment facets",id:"experiment-facets",level:2},{value:"Defining displays layout",id:"defining-displays-layout",level:2},{value:"Defining elements of the GUI experiment",id:"defining-elements-of-the-gui-experiment",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"When you execute your simulation, you will often need to display some information. For each simulation, you can define some inputs, outputs and behaviors:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The inputs will be composed of parameters manipulated by the user for each simulation."}),"\n",(0,s.jsxs)(n.li,{children:["The behaviors will be used to define behavior executed at each step of the ",(0,s.jsx)(n.strong,{children:"experiment"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The outputs will be composed of displays, monitors and inspectors. They will be defined inside the scope ",(0,s.jsx)(n.code,{children:"output"}),". The definition of their layout can also be set with the ",(0,s.jsx)(n.code,{children:"layout"})," statement."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"A typical GUI experiment code follows this pattern:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"experiment exp_name type: gui {\n    [input]\n    [behaviors]\n    output {\n        layout [layout_option]\n        [display statements]\n        [monitor statements]\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"types-of-experiments",children:"Types of experiments"}),"\n",(0,s.jsxs)(n.p,{children:["You can define fours types of experiments (through the facet ",(0,s.jsx)(n.code,{children:"type"}),"):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"gui"})})," experiments (the default type) are used to play an experiment and displays its outputs. It is also used when the user wants to interact with the simulation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"batch"})})," experiments are used to play an experiment several times (usually with other input values), used for model exploration. We will ",(0,s.jsx)(n.a,{href:"BatchExperiments",children:"come back to this notion a bit further in the tutorial"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"test"})})," experiments are used to ",(0,s.jsx)(n.a,{href:"Writing_Tests",children:"write unit tests"})," on a model (used to ensure its quality)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"memorize"})})," experiments are GUI experiments in which ",(0,s.jsx)(n.a,{href:"Save-and-restore-simulations",children:"the simulation state is kept in memory and the user can backtrack to any previous step"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"experiment-attributes",children:"Experiment attributes"}),"\n",(0,s.jsxs)(n.p,{children:["Inside experiment scope, you can access to some built-in attributes which can be useful, such as ",(0,s.jsx)(n.code,{children:"minimum_cycle_duration"}),", to force the duration of one cycle."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"experiment my_experiment type: gui {\n    float minimum_cycle_duration <- 2.0#minute;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In addition, the attribute ",(0,s.jsx)(n.code,{children:"simulations"})," contain the list of all the simulation agents that are running in the current experiment. Whereas the attribute ",(0,s.jsx)(n.code,{children:"simulation"})," represents a single simulation, the last element of the simulation list."]}),"\n",(0,s.jsx)(n.h2,{id:"experiment-facets",children:"Experiment facets"}),"\n",(0,s.jsxs)(n.p,{children:["Finally, in the case of a GUI experiment, the facets ",(0,s.jsx)(n.code,{children:"autorun"})," and ",(0,s.jsx)(n.code,{children:"benchmark"})," can be used as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"experiment name type: gui autorun: true benchmark: true { }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"autorun"})," is set to ",(0,s.jsx)(n.code,{children:"true"})," the launch of the experiment will be followed automatically by its run. When ",(0,s.jsx)(n.code,{children:"benchmark"})," is set to true, GAMA records the number of invocations and running time of the statements and operators of the simulations launched in this experiment. The results are automatically saved in a csv file in a folder called 'benchmarks' when the experiment is closed."]}),"\n",(0,s.jsxs)(n.p,{children:["Other built-ins are available, to learn more about, go to the page ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"Statements#experiment",children:"experiment built-in"})}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"defining-displays-layout",children:"Defining displays layout"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"layout"})," can be added to ",(0,s.jsx)(n.code,{children:"output"})," to specify the layout of the various displays defined below (e.g. ",(0,s.jsx)(n.code,{children:"#none"}),", ",(0,s.jsx)(n.code,{children:"#split"}),", ",(0,s.jsx)(n.code,{children:"#stack"}),", ",(0,s.jsx)(n.code,{children:"#vertical"})," or ",(0,s.jsx)(n.code,{children:"#horizontal"}),"). It will also define which elements of the interface are displayed: ",(0,s.jsx)(n.code,{children:"parameters"}),", ",(0,s.jsx)(n.code,{children:"navigator"}),", ",(0,s.jsx)(n.code,{children:"editors"}),", ",(0,s.jsx)(n.code,{children:"consoles"}),", ",(0,s.jsx)(n.code,{children:"toolbars"}),", ",(0,s.jsx)(n.code,{children:"tray"}),", or ",(0,s.jsx)(n.code,{children:"tabs"})," facets (expecting a boolean value). You will find more detailed information in the ",(0,s.jsx)(n.a,{href:"Statements#layout",children:"statement's documentation"})]}),"\n",(0,s.jsx)(n.h2,{id:"defining-elements-of-the-gui-experiment",children:"Defining elements of the GUI experiment"}),"\n",(0,s.jsxs)(n.p,{children:["In this part, we will focus on the ",(0,s.jsx)(n.strong,{children:"gui experiments"}),". We will start with learning how to ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"DefiningParameters",children:"define input parameters"})}),", then we will study the outputs, such as ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"DefiningDisplaysGeneralities",children:"displays"})}),", ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"DefiningMonitorsAndInspectors",children:"monitors and inspectors"})}),", and ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"DefiningExportFiles",children:"export files"})}),". We will finish this part with how to define ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"DefiningUserInteraction",children:"user commands"})}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453(e,n,t){t.d(n,{R:()=>o,x:()=>l});var i=t(96540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);