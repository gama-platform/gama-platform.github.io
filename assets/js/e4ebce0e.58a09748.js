"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[67038],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=s(n),u=i,f=d["".concat(p,".").concat(u)]||d[u]||m[u]||o;return n?a.createElement(f,r(r({ref:t},c),{},{components:n})):a.createElement(f,r({ref:t},c))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=u;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[d]="string"==typeof e?e:i,r[1]=l;for(var s=2;s<o;s++)r[s]=n[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},38274:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>p,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>d});var a=n(87462),i=n(63366),o=(n(67294),n(3905)),r=["components"],l={title:"6. Exploration of the model"},p=void 0,s={unversionedId:"LuneraysFlu_step6",id:"version-1.8.1/LuneraysFlu_step6",title:"6. Exploration of the model",description:"This final step illustrates how to explore the model through the introduction of batch experiments.",source:"@site/versioned_docs/version-1.8.1/LuneraysFlu_step6.md",sourceDirName:".",slug:"/LuneraysFlu_step6",permalink:"/wiki/1.8.1/LuneraysFlu_step6",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/LuneraysFlu_step6/_edit",tags:[],version:"1.8.1",frontMatter:{title:"6. Exploration of the model"},sidebar:"tuto",previous:{title:"5. Definition of 3D displays",permalink:"/wiki/1.8.1/LuneraysFlu_step5"},next:{title:"BDI Agents",permalink:"/wiki/1.8.1/BDIAgents"}},c={},d=[{value:"Formulation",id:"formulation",level:2},{value:"Model Definition",id:"model-definition",level:2},{value:"Sensitivity analysis toward stochasticity",id:"sensitivity-analysis-toward-stochasticity",level:3},{value:"Exploration",id:"exploration",level:3},{value:"Calibration",id:"calibration",level:3},{value:"Complete Model",id:"complete-model",level:2}],m={toc:d};function u(e){var t=e.components,n=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This final step illustrates how to explore the model through the introduction of batch experiments."),(0,o.kt)("h2",{id:"formulation"},"Formulation"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Add an experiment to launch 10 simulations to analyze the sensitivity toward stochasticity."),(0,o.kt)("li",{parentName:"ul"},"Add an experiment to explore the impact of the ",(0,o.kt)("inlineCode",{parentName:"li"},"proba_leave")," parameter."),(0,o.kt)("li",{parentName:"ul"},"Add an experiment to calibrate the model.")),(0,o.kt)("p",null,"These 3 additions will add each a new experiment of type batch, more details about ",(0,o.kt)("a",{parentName:"p",href:"BatchExperiments"},"batch experiment on this page"),"."),(0,o.kt)("h2",{id:"model-definition"},"Model Definition"),(0,o.kt)("h3",{id:"sensitivity-analysis-toward-stochasticity"},"Sensitivity analysis toward stochasticity"),(0,o.kt)("p",null,"The aim is to run many simulations with the default values for parameters to analyze the impact of stochasticity over the simulation results. We choose as indicator to compare the simulations the ",(0,o.kt)("inlineCode",{parentName:"p"},"infected_rate")," value after 2hours of simulations. We will launch 10 simulations and display the mean and standard deviation values of this variable over the 10 simulations."),(0,o.kt)("p",null,"To this purpose we need to define a new experiment with the following facet values:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"type"),": the type of the experiment, here we choose the ",(0,o.kt)("inlineCode",{parentName:"li"},"batch")," mode to be able to launch many simulations in one launch."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"until"),": the stop condition in the batch experiment, here ",(0,o.kt)("inlineCode",{parentName:"li"},"time > 2#h"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"repeat"),": the number of simulations to run with the same parameter values (number of replications), here 10.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'experiment test_robustness type: batch until: time > 2#h repeat: 10 {\n    reflex information {\n    list<float> vals <- simulations collect each.infected_rate;\n    write "mean: " + mean(vals) + " standard deviation: " + standard_deviation(vals);   \n    }\n}\n')),(0,o.kt)("p",null,"Experiments are also a kind of species. They can thus have variables and behaviors. Here we use the ",(0,o.kt)("inlineCode",{parentName:"p"},"simulations")," variable that is the list of the 10 simulations (for the 10 replications). In addition, in batch mode, a reflex is executed at the end of all the replication simulations. We can thus create the list of all the ",(0,o.kt)("inlineCode",{parentName:"p"},"infected_rate")," values (with the ",(0,o.kt)("inlineCode",{parentName:"p"},"collect")," operator) and compute the ",(0,o.kt)("inlineCode",{parentName:"p"},"mean")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"standard_deviation"),"."),(0,o.kt)("h3",{id:"exploration"},"Exploration"),(0,o.kt)("p",null,"The aim here is to explore the impact of one parameter over the simulations' result. We keep the same indicator. We add the ",(0,o.kt)("inlineCode",{parentName:"p"},"parameter")," to explore the ",(0,o.kt)("inlineCode",{parentName:"p"},"experiment")," and specify the possible it can take with either the ",(0,o.kt)("inlineCode",{parentName:"p"},"among")," facet or the combination of ",(0,o.kt)("inlineCode",{parentName:"p"},"min"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"max")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"step")," facets."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'experiment explore_model type: batch until: time > 2#h repeat: 2 {\n    parameter "proba_leave" var: proba_leave among: [0, 0.01, 0.05, 0.1, 1.0];\n    \n    reflex save_results {\n    ask simulations {\n        write "proba_leave: " + proba_leave + " infected_rate: " + self.infected_rate;\n        save [proba_leave, self.infected_rate] type: csv to:"results.csv";\n    }\n    }\n}\n')),(0,o.kt)("p",null,"In order to do a deeper investigation, in particular with an external tool, it could be useful to save the values in a file. To this purpose, we use the ",(0,o.kt)("a",{parentName:"p",href:"Statements#save"},(0,o.kt)("inlineCode",{parentName:"a"},"save")," statement"),". In our example, we save a list of values in the csv file (",(0,o.kt)("inlineCode",{parentName:"p"},"type: csv"),") specified in the ",(0,o.kt)("inlineCode",{parentName:"p"},"to")," facet."),(0,o.kt)("h3",{id:"calibration"},"Calibration"),(0,o.kt)("p",null,"The calibration process corresponds to the search of parameter values that maximize/minimize indicators. To this purpose, we need to define:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the parameters to explore, with their possible values,"),(0,o.kt)("li",{parentName:"ul"},"the indicator to minimize/maximize,"),(0,o.kt)("li",{parentName:"ul"},"the exploration method.")),(0,o.kt)("p",null,"Here we choose to minimize the value ",(0,o.kt)("inlineCode",{parentName:"p"},"abs(infected_rate - 0.5)")," (i.e. we want to find parameters' value that makes the simulation having an ",(0,o.kt)("inlineCode",{parentName:"p"},"infected_rate")," as close as possible to 0.5) after 2hours of simulation. The chosen optimization method is a genetic algorithm (",(0,o.kt)("a",{parentName:"p",href:"ExplorationMethods"},"more details on this page"),")."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'experiment calibration_model type: batch until: time > 2#h repeat: 3 {\n    parameter "infection distance" var: infection_distance min: 1.0 max: 20.0 step: 1;\n    parameter "proba infection" var: proba_infection min: 0.01 max: 1.0 step: 0.01;\n    \n    method genetic pop_dim: 3 max_gen: 5 minimize: abs(infected_rate - 0.5);\n}\n')),(0,o.kt)("h2",{id:"complete-model"},"Complete Model"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'model model6\n\nglobal {\n    int nb_people <- 2147;\n    int nb_infected_init <- 5;\n    float step <- 5 #mn;\n    \n    float proba_leave <- 0.05;\n    \n    float infection_distance <- 5 #m;\n    float proba_infection <- 0.05;\n    \n    file roads_shapefile <- file("../includes/roads.shp");\n    file buildings_shapefile <- file("../includes/buildings.shp");\n    geometry shape <- envelope(roads_shapefile);    \n    graph road_network;\n    \n    \n    int nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n    int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n    float infected_rate update: nb_people_infected/nb_people;\n    \n    \n    init{\n        create road from: roads_shapefile;\n        road_network <- as_edge_graph(road);        \n        create building from: buildings_shapefile;\n        create people number:nb_people {\n            location <- any_location_in(one_of(building));                \n        }\n        ask nb_infected_init among people {\n            is_infected <- true;\n        }\n    }\n}\n\nspecies people skills:[moving]{        \n    float speed <- (2 + rnd(3)) #km/#h;\n    bool is_infected <- false;\n    point target;\n    \n    reflex stay when: target = nil {\n        if flip(proba_leave) {\n            target <- any_location_in (one_of(building));\n        }\n    }\n        \n    reflex move when: target != nil{\n        do goto target:target on: road_network;\n        if (location = target) {\n            target <- nil;\n        } \n    }\n\n    reflex infect when: is_infected{\n        ask people at_distance infection_distance {\n            if flip(proba_infection) {\n                is_infected <- true;\n            }\n        }\n    }\n    \n    aspect circle {\n        draw circle(10) color:is_infected ? #red : #green;\n    }\n    \n    aspect geom3D {\n        if target != nil {\n            draw obj_file("../includes/people.obj", 90::{-1,0,0}) size: 5\n            at: location + {0,0,7} rotate: heading - 90 color: is_infected ? #red : #green;\n        }\n    }\n    \n}\n\nspecies road {\n    aspect geom {\n        draw shape color: #black;\n    }\n    aspect geom3D {\n        draw line(shape.points, 2.0) color: #black;\n    }\n}\n\nspecies building {\n    aspect geom {\n        draw shape color: #gray;\n    }\n    aspect geom3D {\n        draw shape depth: 20 #m border: #black texture:["../includes/roof_top.png","../includes/texture.jpg"];\n    }\n}\n\nexperiment main type: gui {\n    parameter "Nb people infected at init" var: nb_infected_init min: 1 max: 2147;\n\n    output {\n        monitor "Infected people rate" value: infected_rate;\n        \n        display map {\n            species road aspect:geom;\n            species building aspect:geom;\n            species people aspect:circle;            \n        }\n    \n        display chart_display refresh: every(10 #cycles) {\n            chart "Disease spreading" type: series {\n                data "susceptible" value: nb_people_not_infected color: #green;\n                data "infected" value: nb_people_infected color: #red;\n            }\n        }\n        display view3D type: opengl ambient_light: 80 {\n            image "../includes/luneray.png" refresh:false; \n            species building aspect:geom3D refresh: false;\n            species road aspect: geom3D refresh: false;\n            species people aspect: geom3D ; \n        }\n    }\n}\n\nexperiment test_robustness type: batch until: time > 2#h repeat: 10 {\n    reflex information {\n        list<float> vals <- simulations collect each.infected_rate;\n        write "mean: " + mean(vals) + " standard deviation: " + standard_deviation(vals);    \n    }\n}\n\nexperiment explore_model type: batch until: time > 2#h repeat: 2 {\n    parameter "proba_leave" var: proba_leave among: [0, 0.01, 0.05, 0.1, 1.0];\n    \n    reflex save_results {\n        ask simulations {\n            write "proba_leave: " + proba_leave + " infected_rate: " + self.infected_rate;\n            save [proba_leave, self.infected_rate] type: csv to:"results.csv";\n        }\n    }\n}\n\nexperiment calibration_model type: batch until: time > 2#h repeat: 3 {\n    parameter "infection distance" var: infection_distance min: 1.0 max: 20.0 step: 1;\n    parameter "proba infection" var: proba_infection min: 0.01 max: 1.0 step: 0.01;\n    \n    method genetic pop_dim: 3 max_gen: 5 minimize: abs(infected_rate - 0.5);\n}\n')))}u.isMDXComponent=!0}}]);