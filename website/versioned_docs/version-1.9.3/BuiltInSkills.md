---
title:  Built-in Skills
---


----

**This file is automatically generated from java files. Do Not Edit It.**

----

## Introduction

Skills are built-in modules, written in Java, that provide a set of related built-in variables and built-in actions (in addition to those already provided by GAMA) to the species that declare them. A declaration of skill is done by filling the skills attribute in the species definition:

```
species my_species skills: [skill1, skill2] {
    ...
}
```

Skills have been designed to be mutually compatible so that any combination of them will result in a functional species. An example of skill is the `moving` skill.
  
So, for instance, if a species is declared as:

```
species foo skills: [moving]{
...
}
```

Its agents will automatically be provided with the following variables : `speed`, `heading`, `destination` and the following actions: `move`, `goto`, `wander`, `follow` in addition to those built-in in species and declared by the modeller. Most of these variables, except the ones marked read-only, can be customized and modified like normal variables by the modeller. For instance, one could want to set a maximum for the speed; this would be done by redeclaring it like this:

```
float speed max:100 min:0;
```

Or, to obtain a speed increasing at each simulation step:

```
float speed max:100 min:0  <- 1 update: speed * 1.01;
```

Or, to change the speed in a behavior:

```
if speed = 5 {
    speed <- 10;
}
```

----


## Table of Contents

[advanced_driving](#advanced_driving), [dynamic_body](#dynamic_body), [fipa](#fipa), [messaging](#messaging), [moving](#moving), [moving3D](#moving3d), [network](#network), [pedestrian](#pedestrian), [pedestrian_road](#pedestrian_road), [skill_road](#skill_road), [skill_road_node](#skill_road_node), [SQLSKILL](#sqlskill), [static_body](#static_body), [thread](#thread), 
    	
----




## `advanced_driving`

 

### Variables

	   
* **`acc_bias`** (`float`): the bias term used for asymmetric lane changing, parameter 'a_bias' in MOBIL   
* **`acc_gain_threshold`** (`float`): the minimum acceleration gain for the vehicle to switch to another lane, introduced to prevent frantic lane changing. Known as the parameter 'a_th' in the MOBIL lane changing model   
* **`acceleration`** (`float`): the current acceleration of the vehicle (in m/s^2)   
* **`allowed_lanes`** (`list`): a list containing possible lane index values for the attribute lowest_lane   
* **`current_index`** (`int`): the index of the current edge (road) in the path   
* **`current_lane`** (`int`): the current lane on which the agent is   
* **`current_path`** (`path`): the path which the agent is currently following   
* **`current_road`** (`agent`): the road which the vehicle is currently on   
* **`current_target`** (`agent`): the current target of the agent   
* **`delta_idm`** (`float`): the exponent used in the computation of free-road acceleration in the Intelligent Driver Model   
* **`distance_to_current_target`** (`float`): euclidean distance to the current target node   
* **`distance_to_goal`** (`float`): euclidean distance to the endpoint of the current segment   
* **`final_target`** (`agent`): the final target of the agent   
* **`follower`** (`agent`): the vehicle following this vehicle   
* **`ignore_oneway`** (`boolean`): if set to `true`, the vehicle will be able to violate one-way traffic rule   
* **`lane_change_cooldown`** (`float`): the duration that a vehicle must wait before changing lanes again   
* **`lane_change_limit`** (`int`): the maximum number of lanes that the vehicle can change during a simulation step   
* **`leading_distance`** (`float`): the distance to the leading vehicle   
* **`leading_speed`** (`float`): the speed of the leading vehicle   
* **`leading_vehicle`** (`agent`): the vehicle which is right ahead of the current vehicle.
If this is set to nil, the leading vehicle does not exist or might be very far away.   
* **`linked_lane_limit`** (`int`): the maximum number of linked lanes that the vehicle can use; the default value is -1, i.e. the vehicle can use all available linked lanes   
* **`lowest_lane`** (`int`): the lane with the smallest index that the vehicle is in   
* **`max_acceleration`** (`float`): the maximum acceleration of the vehicle. Known as the parameter 'a' in the Intelligent Driver Model   
* **`max_deceleration`** (`float`): the maximum deceleration of the vehicle. Known as the parameter 'b' in the Intelligent Driver Model   
* **`max_safe_deceleration`** (`float`): the maximum deceleration that the vehicle is willing to induce on its back vehicle when changing lanes. Known as the parameter 'b_save' in the MOBIL lane changing model   
* **`max_speed`** (`float`): the maximum speed that the vehicle can achieve. Known as the parameter 'v0' in the Intelligent Driver Model   
* **`min_safety_distance`** (`float`): the minimum distance of the vehicle's front bumper to the leading vehicle's rear bumper, known as the parameter s0 in the Intelligent Driver Model   
* **`min_security_distance`** (`float`): the minimal distance to another vehicle   
* **`next_road`** (`agent`): the road which the vehicle will enter next   
* **`num_lanes_occupied`** (`int`): the number of lanes that the vehicle occupies   
* **`on_linked_road`** (`boolean`): is the agent on the linked road?   
* **`politeness_factor`** (`float`): determines the politeness level of the vehicle when changing lanes. Known as the parameter 'p' in the MOBIL lane changing model   
* **`proba_block_node`** (`float`): probability to block a node (do not let other vehicle cross the crossroad), within one second   
* **`proba_lane_change_down`** (`float`): probability to change to a lower lane (right lane if right side driving) to gain acceleration, within one second   
* **`proba_lane_change_up`** (`float`): probability to change to a upper lane (left lane if right side driving) to gain acceleration, within one second   
* **`proba_respect_priorities`** (`float`): probability to respect priority (right or left) laws, within one second   
* **`proba_respect_stops`** (`list`): probability to respect stop laws - one value for each type of stop, within one second   
* **`proba_use_linked_road`** (`float`): probability to change to a linked lane to gain acceleration, within one second   
* **`real_speed`** (`float`): the actual speed of the agent (in meter/second)   
* **`right_side_driving`** (`boolean`): are vehicles driving on the right size of the road?   
* **`safety_distance_coeff`** (`float`): the coefficient for the computation of the the min distance between two vehicles (according to the vehicle speed - security_distance =max(min_security_distance, security_distance_coeff `*` min(self.real_speed, other.real_speed) )   
* **`security_distance_coeff`** (`float`): the coefficient for the computation of the the min distance between two vehicles (according to the vehicle speed - safety_distance =max(min_safety_distance, safety_distance_coeff `*` min(self.real_speed, other.real_speed) )   
* **`segment_index_on_road`** (`int`): current segment index of the agent on the current road   
* **`speed`** (`float`): the speed of the agent (in meter/second)   
* **`speed_coeff`** (`float`): speed coefficient for the speed that the vehicle want to reach (according to the max speed of the road)   
* **`targets`** (`list`): the current list of points that the agent has to reach (path)   
* **`time_headway`** (`float`): the time gap that to the leading vehicle that the driver must maintain. Known as the parameter 'T' in the Intelligent Driver Model   
* **`time_since_lane_change`** (`float`): the elapsed time since the last lane change   
* **`using_linked_road`** (`boolean`): indicates if the vehicle is occupying at least one lane on the linked road   
* **`vehicle_length`** (`float`): the length of the vehicle (in meters)   
* **`violating_oneway`** (`boolean`): indicates if the vehicle is moving in the wrong direction on an one-way (unlinked) road 
 	
### Actions
	  
	 
#### **`advanced_follow_driving`**

**moves the agent towards along the path passed in the arguments while considering the other agents in the network (only for graph topology)**


**Returned type:** `float`  : the remaining time

##### Additional facets: 
  	 			
* **`path`** (path): a path to be followed. 			
* **`target`** (point): the target to reach 			
* **`speed`** (float): the speed to use for this move (replaces the current value of speed) 			
* **`time`** (float): time to travel

##### Examples: 
``` 
do osm_follow path: the_path on: road_network;
```
  
	 
#### **`choose_lane`**

**Override this if you want to manually choose a lane when entering new road. By default, the vehicle tries to stay in the current lane. If the new road has fewer lanes than the current one and the current lane index is too big, it tries to enter the most uppermost lane.**


**Returned type:** `int`  : an integer representing the lane index

##### Additional facets: 
  	 			
* **`new_road`** (agent): the new road that's the vehicle is going to enter  
	 
#### **`compute_path`**

**Action to compute the shortest path to the target node, or shortest path based on the provided list of nodes**


**Returned type:** `path`  : the computed path, or nil if no valid path is found

##### Additional facets: 
  	 			
* **`graph`** (graph): the graph representing the road network 			
* **`target`** (agent): the target node to reach 			
* **`source`** (agent): the source node (optional, if not defined, closest node to the agent location) 			
* **`nodes`** (list): the nodes forming the resulting path

##### Examples: 
``` 
do compute_path graph: road_network target: target_node; 
do compute_path graph: road_network nodes: [node1, node5, node10];
```
  
	 
#### **`drive`**

**action to drive toward the target**


**Returned type:** `bool`


##### Examples: 
``` 
do drive;
```
  
	 
#### **`drive_random`**

**action to drive by chosen randomly the next road**


**Returned type:** `bool`

##### Additional facets: 
  	 			
* **`graph`** (graph): a graph representing the road network 			
* **`proba_roads`** (map): a map containing for each road (key), the probability to be selected as next road (value)

##### Examples: 
``` 
do drive_random init_node: some_node;
```
  
	 
#### **`external_factor_impact`**

**action that allows to define how the remaining time is impacted by external factor**


**Returned type:** `float`  : the remaining time

##### Additional facets: 
  	 			
* **`new_road`** (agent): the road on which to the vehicle wants to go 			
* **`remaining_time`** (float): the remaining time

##### Examples: 
``` 
do external_factor_impact new_road: a_road remaining_time: 0.5;
```
  
	 
#### **`force_move`**

**action to drive by chosen randomly the next road**


**Returned type:** `float`

##### Additional facets: 
  	 			
* **`lane`** (int): the lane on which to make the agent move 			
* **`acceleration`** (float): acceleration of the vehicle 			
* **`time`** (float): time of move

##### Examples: 
``` 
do drive_random init_node: some_node;
```
  
	 
#### **`goto_drive`**

**moves the agent towards the target passed in the arguments.**


**Returned type:** `path`  : optional: the path followed by the agent.

##### Additional facets: 
  	 			
* **`target`** (geometry): the entity towards which to move. 			
* **`speed`** (float): the speed to use for this move (replaces the current value of speed) 			
* **`on`** (any type): graph, topology, list of geometries or map of geometries that restrain this move 			
* **`recompute_path`** (boolean): if false, the path is not recompute even if the graph is modified (by default: true) 			
* **`return_path`** (boolean): if true, return the path followed (by default: false) 			
* **`following`** (path): Path to follow.

##### Examples: 
``` 
do goto_drive target: one_of road on: road_network;
```
  
	 
#### **`lane_choice`**

**action to choose a lane**


**Returned type:** `int`  : the chosen lane, return -1 if no lane can be taken

##### Additional facets: 
  	 			
* **`new_road`** (agent): the road on which to choose the lane

##### Examples: 
``` 
do lane_choice new_road: a_road;
```
  
	 
#### **`on_entering_new_road`**

**override this if you want to do something when the vehicle enters a new road (e.g. adjust parameters)**


**Returned type:** `void`
  
	 
#### **`path_from_nodes`**

**action to compute a path from a list of nodes according to a given graph**


**Returned type:** `path`  : the computed path, return nil if no path can be taken

##### Additional facets: 
  	 			
* **`graph`** (graph): the graph representing the road network 			
* **`nodes`** (list): the list of nodes composing the path

##### Examples: 
``` 
do compute_path_from_nodes graph: road_network nodes: [node1, node5, node10];
```
  
	 
#### **`ready_to_cross`**

**action to test if the vehicle cross a road node to move to a new road**


**Returned type:** `bool`  : true if the vehicle can cross the road node, false otherwise

##### Additional facets: 
  	 			
* **`node`** (agent): the road node to test 			
* **`new_road`** (agent): the road to test

##### Examples: 
``` 
do is_ready_next_road new_road: a_road lane: 0;
```
  
	 
#### **`speed_choice`**

**action to choose a speed**


**Returned type:** `float`  : the chosen speed

##### Additional facets: 
  	 			
* **`new_road`** (agent): the road on which to choose the speed

##### Examples: 
``` 
do speed_choice new_road: the_road;
```
  
	 
#### **`test_next_road`**

**action to test if the vehicle can take the given road**


**Returned type:** `bool`  : true (the vehicle can take the road) or false (the vehicle cannot take the road)

##### Additional facets: 
  	 			
* **`new_road`** (agent): the road to test

##### Examples: 
``` 
do test_next_road new_road: a_road;
```
  
	 
#### **`unregister`**

**remove the vehicle from its current roads**


**Returned type:** `bool`


##### Examples: 
``` 
do unregister
```

    	
----




## `dynamic_body`

 

### Variables

	   
* **`angular_damping`** (`float`): Between 0 and 1. an angular decelaration coefficient that occurs even without contact   
* **`angular_velocity`** (`point`): The angular velocity of the agent in the three directions, expressed as a point.   
* **`contact_damping`** (`float`): Between 0 and 1. a decelaration coefficient that occurs in case of contact. Only available in the native Bullet library (no effect on the Java implementation)   
* **`damping`** (`float`): Between 0 and 1. a linear decelaration coefficient that occurs even without contact   
* **`velocity`** (`point`): The linear velocity of the agent in the three directions, expressed as a point. 
 	
### Actions
	  
	 
#### **`apply`**

**An action that allows to apply different effects to the object, like forces, impulses, etc.**


**Returned type:** `unknown`

##### Additional facets: 
  	 			
* **`clearance`** (boolean): If true clears all forces applied to the agent and clears its veolicity as well 			
* **`impulse`** (point): An idealised change of momentum. Adds to the velocity of the object. This is the kind of push that you would use on a pool billiard ball. 			
* **`force`** (point): Move (push) the object once with a certain moment, expressed as a point (vector). Adds to the existing forces. 			
* **`torque`** (point): Rotate (twist) the object once around its axes, expressed as a point (vector)
    	
----




## `fipa`
The fipa skill offers some primitives and built-in variables which enable agent to communicate with each other using the FIPA interaction protocol.
 

### Variables

	   
* **`accept_proposals`** (`list`): A list of 'accept_proposal' performative messages in the agent's mailbox   
* **`agrees`** (`list`): A list of 'agree' performative messages.   
* **`cancels`** (`list`): A list of 'cancel' performative messages.   
* **`cfps`** (`list`): A list of 'cfp' (call for proposal) performative messages.   
* **`conversations`** (`list`): A list containing the current conversations of agent. Ended conversations are automatically removed from this list.   
* **`failures`** (`list`): A list of 'failure' performative messages.   
* **`informs`** (`list`): A list of 'inform' performative messages.   
* **`proposes`** (`list`): A list of 'propose' performative messages .   
* **`queries`** (`list`): A list of 'query' performative messages.   
* **`refuses`** (`list`): A list of 'propose' performative messages.   
* **`reject_proposals`** (`list`): A list of 'reject_proposal' performative messages.   
* **`requests`** (`list`): A list of 'request' performative messages.   
* **`requestWhens`** (`list`): A list of 'request-when' performative messages.   
* **`subscribes`** (`list`): A list of 'subscribe' performative messages. 
 	
### Actions
	  
	 
#### **`accept_proposal`**

**Replies a message with an 'accept_proposal' performative message.**


**Returned type:** `unknown`

##### Additional facets: 
  	 			
* **`message`** (message): The message to be replied 			
* **`contents`** (list): The content of the replying message  
	 
#### **`agree`**

**Replies a message with an 'agree' performative message.**


**Returned type:** `unknown`

##### Additional facets: 
  	 			
* **`message`** (message): The message to be replied 			
* **`contents`** (list): The content of the replying message  
	 
#### **`cancel`**

**Replies a message with a 'cancel' peformative message.**


**Returned type:** `unknown`

##### Additional facets: 
  	 			
* **`message`** (message): The message to be replied 			
* **`contents`** (list): The content of the replying message  
	 
#### **`cfp`**

**Replies a message with a 'cfp' performative message.**


**Returned type:** `unknown`

##### Additional facets: 
  	 			
* **`message`** (message): The message to be replied 			
* **`contents`** (list): The content of the replying message  
	 
#### **`end_conversation`**

**Reply a message with an 'end_conversation' peprformative message. This message marks the end of a conversation. In a 'no-protocol' conversation, it is the responsible of the modeler to explicitly send this message to mark the end of a conversation/interaction protocol. Please note that if the contents of the messages of the conversation are not read, then this command has no effect (i.e. it  must be read by at least one of the agents in the conversation)**


**Returned type:** `unknown`

##### Additional facets: 
  	 			
* **`message`** (message): The message to be replied 			
* **`contents`** (list): The content of the replying message  
	 
#### **`failure`**

**Replies a message with a 'failure' performative message.**


**Returned type:** `unknown`

##### Additional facets: 
  	 			
* **`message`** (message): The message to be replied 			
* **`contents`** (list): The content of the replying message  
	 
#### **`inform`**

**Replies a message with an 'inform' performative message.**


**Returned type:** `unknown`

##### Additional facets: 
  	 			
* **`message`** (message): The message to be replied 			
* **`contents`** (list): The content of the replying message  
	 
#### **`propose`**

**Replies a message with a 'propose' performative message.**


**Returned type:** `unknown`

##### Additional facets: 
  	 			
* **`message`** (message): The message to be replied 			
* **`contents`** (list): The content of the replying message  
	 
#### **`query`**

**Replies a message with a 'query' performative message.**


**Returned type:** `unknown`

##### Additional facets: 
  	 			
* **`message`** (message): The message to be replied 			
* **`contents`** (list): The content of the replying message  
	 
#### **`refuse`**

**Replies a message with a 'refuse' performative message.**


**Returned type:** `unknown`

##### Additional facets: 
  	 			
* **`message`** (message): The message to be replied 			
* **`contents`** (list): The contents of the replying message  
	 
#### **`reject_proposal`**

**Replies a message with a 'reject_proposal' performative message.**


**Returned type:** `unknown`

##### Additional facets: 
  	 			
* **`message`** (message): The message to be replied 			
* **`contents`** (list): The content of the replying message  
	 
#### **`reply`**

**Replies a message. This action should be only used to reply a message in a 'no-protocol' conversation and with a 'user defined performative'. For performatives supported by GAMA (i.e., standard FIPA performatives), please use the 'action' with the same name of 'performative'. For example, to reply a message with a 'request' performative message, the modeller should use the 'request' action.**


**Returned type:** `unknown`

##### Additional facets: 
  	 			
* **`message`** (message): The message to be replied 			
* **`performative`** (string): The performative of the replying message 			
* **`contents`** (list): The content of the replying message  
	 
#### **`request`**

**Replies a message with a 'request' performative message.**


**Returned type:** `unknown`

##### Additional facets: 
  	 			
* **`message`** (message): The message to be replied 			
* **`contents`** (list): The content of the replying message  
	 
#### **`send`**

**Starts a conversation/interaction protocol.**


**Returned type:** `message`

##### Additional facets: 
  	 			
* **`to`** (list): A list of receiver agents 			
* **`contents`** (list): The content of the message. A list of any GAML type 			
* **`performative`** (string): A string, representing the message performative 			
* **`protocol`** (string): A string representing the name of interaction protocol  
	 
#### **`start_conversation`**

**Starts a conversation/interaction protocol.**


**Returned type:** `message`

##### Additional facets: 
  	 			
* **`to`** (list): A list of receiver agents 			
* **`contents`** (list): The content of the message. A list of any GAML type 			
* **`performative`** (string): A string, representing the message performative 			
* **`protocol`** (string): A string representing the name of interaction protocol  
	 
#### **`subscribe`**

**Replies a message with a 'subscribe' performative message.**


**Returned type:** `unknown`

##### Additional facets: 
  	 			
* **`message`** (message): The message to be replied 			
* **`contents`** (list): The content of the replying message
    	
----




## `messaging`
A simple skill that provides agents with a mailbox than can be filled with messages
 

### Variables

	   
* **`mailbox`** (`list`): The list of messages that can be consulted by the agent 
 	
### Actions
	  
	 
#### **`send`**

**Action used to send a message (that can be of any kind of object) to an agent or a server.**


**Returned type:** `message`

##### Additional facets: 
  	 			
* **`to`** (any type): The agent, or server, to which this message will be sent to 			
* **`contents`** (any type): The contents of the message, an arbitrary object

##### Examples: 
``` 
do send to:dest contents:"This message is sent by " + name + " to " + dest;
```

    	
----




## `moving`
The moving skill is intended to define the minimal set of behaviours required for agents that are able to move on different topologies
 

### Variables

	   
* **`current_edge`** (`geometry`): Represents the agent/geometry on which the agent is located (only used with a graph)   
* **`current_path`** (`path`): Represents the path on which the agent is moving on (goto action on a graph)   
* **`destination`** (`point`): Represents the next location of the agent if it keeps its current speed and heading (read-only). ** Only correct in continuous topologies and may return nil values if the destination is outside the environment **   
* **`heading`** (`float`): Represents the absolute heading of the agent in degrees.   
* **`location`** (`point`): Represents the current position of the agent   
* **`real_speed`** (`float`): Represents the actual speed of the agent (in meter/second)   
* **`speed`** (`float`): Represents the speed of the agent (in meter/second) 
 	
### Actions
	  
	 
#### **`follow`**

**moves the agent along a given path passed in the arguments.**


**Returned type:** `path`  : optional: the path followed by the agent.

##### Additional facets: 
  	 			
* **`speed`** (float): the speed to use for this move (replaces the current value of speed) 			
* **`path`** (path): a path to be followed. 			
* **`move_weights`** (map): Weights used for the moving. 			
* **`return_path`** (boolean): if true, return the path followed (by default: false)

##### Examples: 
``` 
do follow speed: speed * 2 path: road_path;
```
  
	 
#### **`goto`**

**moves the agent towards the target passed in the arguments.**


**Returned type:** `path`  : optional: the path followed by the agent.

##### Additional facets: 
  	 			
* **`target`** (geometry): the location or entity towards which to move. 			
* **`speed`** (float): the speed to use for this move (replaces the current value of speed) 			
* **`on`** (any type): graph, topology, list of geometries or map of geometries that restrain this move 			
* **`recompute_path`** (boolean): if false, the path is not recompute even if the graph is modified (by default: true) 			
* **`return_path`** (boolean): if true, return the path followed (by default: false) 			
* **`move_weights`** (map): Weights used for the moving.

##### Examples: 
``` 
do goto target: (one_of road).location speed: speed * 2 on: road_network;
```
  
	 
#### **`move`**

**moves the agent forward, the distance being computed with respect to its speed and heading. The value of the corresponding variables are used unless arguments are passed.**


**Returned type:** `path`

##### Additional facets: 
  	 			
* **`speed`** (float): the speed to use for this move (replaces the current value of speed) 			
* **`heading`** (float): the angle (in degree) of the target direction. 			
* **`bounds`** (geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry

##### Examples: 
``` 
do move speed: speed - 10 heading: heading + rnd (30) bounds: agentA;
```
  
	 
#### **`wander`**

**Moves the agent towards a random location at the maximum distance (with respect to its speed). The heading of the agent is chosen randomly if no amplitude is specified. This action changes the value of heading.**


**Returned type:** `bool`

##### Additional facets: 
  	 			
* **`speed`** (float): the speed to use for this move (replaces the current value of speed) 			
* **`amplitude`** (float): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2) 			
* **`bounds`** (geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry) 			
* **`on`** (graph): the graph that restrains this move (the agent moves on the graph 			
* **`proba_edges`** (map): When the agent moves on a graph, the probability to choose another edge. If not defined, each edge has the same probability to be chosen

##### Examples: 
``` 
do wander speed: speed - 10 amplitude: 120 bounds: agentA;
```

    	
----




## `moving3D`
The moving skill 3D is intended to define the minimal set of behaviours required for agents that are able to move on different topologies
 

### Variables

	   
* **`destination`** (`point`): continuously updated destination of the agent with respect to its speed and heading (read-only)   
* **`heading`** (`float`): the absolute heading of the agent in degrees (in the range 0-359)   
* **`pitch`** (`float`): the absolute pitch of the agent in degrees (in the range 0-359)   
* **`roll`** (`float`): the absolute roll of the agent in degrees (in the range 0-359)   
* **`speed`** (`float`): the speed of the agent (in meter/second) 
 	
### Actions
	  
	 
#### **`move`**

**moves the agent forward, the distance being computed with respect to its speed and heading. The value of the corresponding variables are used unless arguments are passed.**


**Returned type:** `path`

##### Additional facets: 
  	 			
* **`speed`** (float): the speed to use for this move (replaces the current value of speed) 			
* **`heading`** (int): int, optional, the direction to take for this move (replaces the current value of heading) 			
* **`pitch`** (int): int, optional, the direction to take for this move (replaces the current value of pitch) 			
* **`roll`** (int): int, optional, the direction to take for this move (replaces the current value of roll) 			
* **`bounds`** (geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry

##### Examples: 
``` 
do move speed: speed - 10 heading: heading + rnd (30) bounds: agentA;
```

    	
----




## `network`
The network skill provides new features to let agents exchange message through network. Sending and receiving data is done with the messaging skill's actions.
 

### Variables

	   
* **`network_groups`** (`list`): The set of groups the agent belongs to   
* **`network_name`** (`string`): Net ID of the agent   
* **`network_server`** (`list`): The list of all the servers to which the agent is connected 
 	
### Actions
	  
	 
#### **`connect`**

**Action used by a networking agent to connect to a server or to create a server.**


**Returned type:** `bool`

##### Additional facets: 
  	 			
* **`protocol`** (string): protocol type (MQTT (by default), TCP, UDP, websocket, arduino): the possible value ares 'udp_server', 'udp_emitter', 'tcp_server', 'tcp_client', 'websocket_server', 'websocket_client', 'http', 'arduino', otherwise the MQTT protocol is used. 			
* **`port`** (int): Port number 			
* **`raw`** (boolean): message type raw or rich 			
* **`with_name`** (string): ID of the agent (its name) for the simulation 			
* **`login`** (string): login for the connection to the server 			
* **`password`** (string): password associated to the login 			
* **`force_network_use`** (boolean): force the use of the network even interaction between local agents 			
* **`to`** (string): server URL (localhost or a server URL) 			
* **`size_packet`** (int): For UDP connection, it sets the maximum size of received packets (default = 1024bits).

##### Examples: 
``` 
 do connect with_name:"any_name"; 
 do connect to:"localhost" port:9876 with_name:"any_name"; 
 do connect to:"localhost" protocol:"MQTT" port:9876 with_name:"any_name"; 
 do connect to:"localhost" protocol:"udp_server" port:9876 with_name:"Server"; 
 do connect to:"localhost" protocol:"udp_client" port:9876 with_name:"Client"; 
 do connect to:"localhost" protocol:"udp_server" port:9877 size_packet: 4096; 
 do connect to:"localhost" protocol:"tcp_client" port:9876; 
 do connect to:"localhost" protocol:"tcp_server" port:9876 raw:true; 
 do connect to: "https://openlibrary.org" protocol: "http" port: 443 raw: true; 
 do connect protocol: "arduino";
```
  
	 
#### **`execute`**

**Action that executes a command in the OS, as if it is executed from a terminal.**


**Returned type:** `string`  : The error message if any

##### Additional facets: 
  	 			
* **`command`** (string): command to execute  
	 
#### **`fetch_message`**

**Fetch the first message from the mailbox (and remove it from the mailing box). If the mailbox is empty, it returns a nil message.**


**Returned type:** `message`


##### Examples: 
``` 
message mess <- fetch_message(); 
loop while:has_more_message(){ 
	message mess <- fetch_message();
	write message.contents;
}
```
  
	 
#### **`fetch_message_from_network`**

**Fetch all messages from network to mailbox. Use this in specific case only, this action is done at the end of each step.**


**Returned type:** `bool`


##### Examples: 
``` 
do fetch_message_from_network;//forces gama to get all the new messages since the begining of the cycle
loop while: has_more_message(){ 
	message mess <- fetch_message();
	write message.contents;
}
```
  
	 
#### **`has_more_message`**

**Check whether the mailbox contains any message.**


**Returned type:** `bool`


##### Examples: 
``` 
bool mailbox_contain_messages <- has_more_message(); 
loop while:has_more_message(){ 
	message mess <- fetch_message();
	write message.contents;
}
```
  
	 
#### **`join_group`**

**Allow an agent to join a group of agents in order to broadcast messages to other members or to receive messages sent by other members. Note that all members of the group called : "ALL".**


**Returned type:** `bool`

##### Additional facets: 
  	 			
* **`with_name`** (string): name of the group

##### Examples: 
``` 
do join_group with_name:"group name"; 
do join_group with_name:"group name";
do send to:"group name" contents:"I am new in this group";
```
  
	 
#### **`leave_group`**

**leave a group of agents. The leaving agent will not receive any message from the group. Overwhise, it can send messages to the left group**


**Returned type:** `bool`

##### Additional facets: 
  	 			
* **`with_name`** (string): name of the group the agent wants to leave

##### Examples: 
``` 
 do leave_group with_name:"my_group";
```

    	
----




## `pedestrian`

 

### Variables

	   
* **`A_obstacles_SFM`** (`float`): Value of A in the SFM model for obstacles - the force of repulsive interactions (classic values : mean = 4.5, std = 0.3)   
* **`A_pedestrians_SFM`** (`float`): Value of A in the SFM model for pedestrians - the force of repulsive interactions (classic values : mean = 4.5, std = 0.3)   
* **`avoid_other`** (`boolean`): has the pedestrian to avoid other pedestrians?   
* **`B_obstacles_SFM`** (`float`): Value of B in the SFM model for obstacles - the range (in meters) of repulsive interactions   
* **`B_pedestrians_SFM`** (`float`): Value of B in the SFM model for pedestrians - the range (in meters) of repulsive interactions   
* **`current_index`** (`int`): the current index of the agent waypoint (according to the waypoint list)   
* **`current_waypoint`** (`geometry`): the current waypoint of the agent   
* **`final_waypoint`** (`geometry`): the final waypoint of the agent   
* **`forces`** (`map`): the map of forces   
* **`gama_SFM`** (`float`): Value of gama in the SFM model  the amount of normal social force added in tangential direction. between 0.0 and 1.0 (classic values : mean = 0.35, std = 0.01)   
* **`k_SFM`** (`float`): Value of k in the SFM model: force counteracting body compression   
* **`kappa_SFM`** (`float`): Value of kappa in the SFM model: friction counteracting body compression   
* **`lambda_SFM`** (`float`): Value of lambda in the SFM model - the (an-)isotropy (between 0.0 and 1.0)   
* **`minimal_distance`** (`float`): Minimal distance between pedestrians   
* **`n_prime_SFM`** (`float`): Value of n' in the SFM model (classic values : mean = 3.0, std = 0.7)   
* **`n_SFM`** (`float`): Value of n in the SFM model (classic values : mean = 2.0, std = 0.1)   
* **`obstacle_consideration_distance`** (`float`): Distance of consideration of obstacles (to compute the nearby obstacles, used as distance, the max between this value and (step * speed) - classic value: 3.5m   
* **`obstacle_species`** (`list`): the list of species that are considered as obstacles   
* **`pedestrian_consideration_distance`** (`float`): Distance of consideration of other pedestrians (to compute the nearby obstacles, used as distance, the max between this value and (step * speed) - classic value: 3.5m   
* **`pedestrian_model`** (`string`): Model use for the movement of agents (Social Force Model). Can be either "simple" or "advanced" (default) for different versions of SFM Helbing model   
* **`pedestrian_species`** (`list`): the list of species that are considered as pedestrians   
* **`proba_detour`** (`float`): probability to accept to do a detour   
* **`relaxion_SFM`** (`float`): Value of relaxion in the SFM model - the amount of delay time for an agent to adapt.(classic values : mean = 0.54, std = 0.05)   
* **`roads_waypoints`** (`map`): for each waypoint, the associated road   
* **`shoulder_length`** (`float`): The width of the pedestrian (in meters) - classic values: [0.39, 0.515]   
* **`tolerance_waypoint`** (`float`): distance to a waypoint (in meters) to consider that an agent is arrived at the waypoint   
* **`use_geometry_waypoint`** (`boolean`): use geometries as waypoint instead of points   
* **`velocity`** (`point`): The velocity of the pedestrian (in meters)   
* **`waypoints`** (`list`): the current list of points/shape that the agent has to reach (path) 
 	
### Actions
	  
	 
#### **`compute_virtual_path`**

**action to compute a path to a location according to a given graph**


**Returned type:** `path`  : the computed path, return nil if no path can be taken

##### Additional facets: 
  	 			
* **`pedestrian_graph`** (graph): the graph on wich compute the path 			
* **`target`** (geometry): the target to reach, can be any agent

##### Examples: 
``` 
do compute_virtual_path graph: pedestrian_network target: any_point;
```
  
	 
#### **`release_path`**

**clean all the interne state of the agent**


**Returned type:** `bool`

##### Additional facets: 
  	 			
* **`current_road`** (agent): current road on which the agent is located (can be nil)  
	 
#### **`walk`**

**action to walk toward the final target using the current_path (requires to use the compute_virtual_path action before)**


**Returned type:** `bool`


##### Examples: 
``` 
do walk;
```
  
	 
#### **`walk_to`**

**action to walk toward a target**


**Returned type:** `bool`

##### Additional facets: 
  	 			
* **`target`** (geometry): Move toward the target using the SFM model 			
* **`bounds`** (geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry

##### Examples: 
``` 
do walk_to {10,10};
```

    	
----




## `pedestrian_road`

 

### Variables

	   
* **`agents_on`** (`list`): for each people on the road   
* **`exit_nodes`** (`map`): The exit hub (several exit connected to each road extremities) that makes it possible to reduce angular distance when travelling to connected pedestrian roads   
* **`free_space`** (`geometry`): for each people on the road   
* **`intersection_areas`** (`map`): map of geometries to connect segments linked to this road   
* **`linked_pedestrian_roads`** (`list`): the close pedestrian roads   
* **`road_status`** (`int`): When road status equals 1 it has 2D continuous space property for pedestrian; when equal to 2 is simply a 1D road 
 	
### Actions
	  
	 
#### **`build_exit_hub`**

**Add exit hub to pedestrian corridor to reduce angular distance between node of the network**


**Returned type:** `bool`

##### Additional facets: 
  	 			
* **`pedestrian_graph`** (graph): The pedestrian network from which to find connected corridors 			
* **`distance_between_targets`** (float): min distances between 2 targets

##### Examples: 
``` 
do build_exit_hub pedestrian_graph: pedestrian_network distance_between_targets: 10.0;
```
  
	 
#### **`build_intersection_areas`**

**Build intersection areas with connected roads**


**Returned type:** `bool`

##### Additional facets: 
  	 			
* **`pedestrian_graph`** (graph): The pedestrian network from which to find connected corridors

##### Examples: 
``` 
do build_intersection_areas pedestrian_graph: pedestrian_network;
```
  
	 
#### **`initialize`**

**action to initialize the free space of roads**


**Returned type:** `bool`

##### Additional facets: 
  	 			
* **`distance`** (float): the maximal distance to the road 			
* **`obstacles`** (container): the list of species to consider as obstacles to remove from the free space 			
* **`distance_extremity`** (float): the distance added to the extremimity to connect to other road (in meters) 			
* **`bounds`** (container): the geometries (the localized entity geometries) that restrains the agent movement (the agent moves inside this geometry 			
* **`masked_by`** (container): if defined, keep only the part of the geometry that is visible from the location of the road considering the given obstacles 			
* **`masked_by_precision`** (int): if masked_by is defined, number of triangles used to compute the visible geometries (default: 120) 			
* **`status`** (int): the status (int) of the road: 1 (default) for roads where agent move on a continuous 2D space and 0 for 1D roads with queu-in queu-out like movement

##### Examples: 
``` 
do initialize distance: 10.0 obstacles: [building];
```

    	
----




## `skill_road`

 

### Variables

	   
* **`agents_on`** (`list`): for each lane of the road, the list of agents for each segment   
* **`all_agents`** (`list`): the list of agents on the road   
* **`linked_road`** (`agent`): the linked road: the lanes of this linked road will be usable by drivers on the road   
* **`maxspeed`** (`float`): the maximal speed on the road   
* **`num_lanes`** (`int`): the number of lanes   
* **`num_segments`** (`int`): the number of road segments   
* **`segment_lengths`** (`list`): stores the length of each road segment. The index of each element corresponds to the segment index.   
* **`source_node`** (`agent`): the source node of the road   
* **`target_node`** (`agent`): the target node of the road   
* **`vehicle_ordering`** (`list`): provides information about the ordering of vehicle on any given lane 
 	
### Actions
	  
	 
#### **`register`**

**register the agent on the road at the given lane**


**Returned type:** `bool`

##### Additional facets: 
  	 			
* **`agent`** (agent): the agent to register on the road. 			
* **`lane`** (int): the lane index on which to register; if lane index >= number of lanes, then register on the linked road

##### Examples: 
``` 
do register agent: the_driver lane: 0;
```
  
	 
#### **`unregister`**

**unregister the agent on the road**


**Returned type:** `bool`

##### Additional facets: 
  	 			
* **`agent`** (agent): the agent to unregister on the road.

##### Examples: 
``` 
do unregister agent: the_driver;
```

    	
----




## `skill_road_node`

 

### Variables

	   
* **`block`** (`map`): define the list of agents blocking the node, and for each agent, the list of concerned roads   
* **`priority_roads`** (`list`): the list of priority roads   
* **`roads_in`** (`list`): the list of input roads   
* **`roads_out`** (`list`): the list of output roads   
* **`stop`** (`list`): define for each type of stop, the list of concerned roads 
 	
### Actions
	
    	
----




## `SQLSKILL`
This skill allows agents to be provided with actions and attributes in order to connect to SQL databases
 

### Variables

	 
 	
### Actions
	  
	 
#### **`executeUpdate`**

**Action used to execute any update query (CREATE, DROP, INSERT...) to the database (query written in SQL).**


**Returned type:** `int`

##### Additional facets: 
  	 			
* **`params`** (map): Connection parameters 			
* **`updateComm`** (string): SQL commands such as Create, Update, Delete, Drop with question mark 			
* **`values`** (list): List of values that are used to replace question mark

##### Examples: 
``` 
do executeUpdate params: PARAMS updateComm: "DROP TABLE IF EXISTS registration"; 
do executeUpdate params: PARAMS updateComm: "INSERT INTO registration " + "VALUES(100, 'Zara', 'Ali', 18);"; 
do executeUpdate params: PARAMS updateComm: "INSERT INTO registration " + "VALUES(?, ?, ?, ?);" values: [101, 'Mr', 'Mme', 45];
```
  
	 
#### **`insert`**

**Action used to insert new data in a database**


**Returned type:** `int`

##### Additional facets: 
  	 			
* **`params`** (map): Connection parameters 			
* **`into`** (string): Table name 			
* **`columns`** (list): List of column name of table 			
* **`values`** (list): List of values that are used to insert into table. Columns and values must have same size

##### Examples: 
``` 
do insert params: PARAMS into: "registration" values: [102, 'Mahnaz', 'Fatma', 25]; 
do insert params: PARAMS into: "registration" columns: ["id", "first", "last"] values: [103, 'Zaid tim', 'Kha'];
```
  
	 
#### **`list2Matrix`**

**Action that transforms the list of list of data and metadata (resulting from a query) into a matrix.**


**Returned type:** `matrix`

##### Additional facets: 
  	 			
* **`param`** (list): Param: a list of records and metadata 			
* **`getName`** (boolean): getType: a boolean value, optional parameter 			
* **`getType`** (boolean): getType: a boolean value, optional parameter

##### Examples: 
``` 
list<list> t <- list<list> (select(PARAMS, "SELECT * FROM registration"));
write list2Matrix(t, true, true);
```
  
	 
#### **`select`**

**Action used to restrieve data from a database**


**Returned type:** `list`

##### Additional facets: 
  	 			
* **`params`** (map): Connection parameters 			
* **`select`** (string): select string with question marks 			
* **`values`** (list): List of values that are used to replace question marks

##### Examples: 
``` 
list<list> t <- list<list> (select(PARAMS, "SELECT * FROM registration"));
```
  
	 
#### **`testConnection`**

**Action used to test the connection to a database**


**Returned type:** `bool`

##### Additional facets: 
  	 			
* **`params`** (map): Connection parameters

##### Examples: 
``` 
if (!first(DB_Accessor).testConnection(PARAMS)) {
			write "Connection impossible";
			do pause;
		}

```

    	
----




## `static_body`

 

### Variables

	   
* **`aabb`** (`geometry`): The axis-aligned bounding box. A box used to evaluate the probability of contacts between objects. Can be displayed as any other GAMA shapes/geometries in order to verify that the physical representation of the agent corresponds to its geometry in the model   
* **`friction`** (`float`): Between 0 and 1. The coefficient of friction of the agent (how much it decelerates the agents in contact with him). Default is 0.5   
* **`mass`** (`float`): The mass of the agent. Should be equal to 0.0 for static, motionless agents   
* **`restitution`** (`float`): Between 0 and 1. The coefficient of restitution of the agent (defines the 'bounciness' of the agent). Default is 0   
* **`rotation`** (`pair`): The rotation of the physical body, expressed as a pair which key is the angle in degrees and value the axis around which it is measured 
 	
### Actions
	  
	 
#### **`contact_added_with`**

**This action can be redefined in order for the agent to implement a specific behavior when it comes into contact (collision) with another agent. It is automatically called by the physics simulation engine on both colliding agents. The default built-in behavior does nothing.**


**Returned type:** `unknown`

##### Additional facets: 
  	 			
* **`other`** (agent): represents the other agent with which a collision has been detected  
	 
#### **`contact_removed_with`**

**This action can be redefined in order for the agent to implement a specific behavior when a previous contact with another agent is removed. It is automatically called by the physics simulation engine on both colliding agents. The default built-in behavior does nothing.**


**Returned type:** `unknown`

##### Additional facets: 
  	 			
* **`other`** (agent): represents the other agent with which a collision has been detected  
	 
#### **`update_body`**

**This action must be called when the geometry of the agent changes in the simulation world and this change must be propagated to the physical world. The change of location (in either worlds) or the rotation due to physical forces do not count as changes, as they are already taken into account. However, a rotation in the simulation world need to be handled by calling this action. As it involves long operations (removing the agent from the physical world, then reinserting it with its new shape), this action should not be called too often.**


**Returned type:** `unknown`

    	
----




## `thread`
The thread skill is intended to define the minimal set of behaviours required for agents that are able to run an action in a thread
 

### Variables

	 
 	
### Actions
	  
	 
#### **`end_thread`**

**End the current thread.**


**Returned type:** `bool`  : true if the thread was well stopped, false otherwise


##### Examples: 
``` 
do end_thread;
```
  
	 
#### **`run_thread`**

**Start a new thread that will run the 'thread_action' either once if no facets are defined, of at a fixed rate if 'every:' is defined or with a fixed delay if 'interval:' is defined.**


**Returned type:** `bool`  : true if the thread was well created and started, false otherwise

##### Additional facets: 
  	 			
* **`every`** (float): Rate in machine time at which this action is run. Default unit is in seconds, use explicit units to specify another, like 10 #ms. If no rate (and no interval) is specified, the action is run once. If the action takes longer than the interval to run, it it run immediately after the previous execution 			
* **`interval`** (float): Interval -- or delay -- between two executions of the action. Default unit is in seconds, use explicit units to specify another, like 10 #ms. If no interval (and no rate) is specified, the action is run once. An interval of 0 will make the action run continuously without delays

##### Examples: 
``` 
do run_thread every: 10#ms;
```
  
	 
#### **`thread_action`**

**A virtual action, which contains what to execute in the thread. It needs to be redefined in the species that implement the `thread` skill**


**Returned type:** `unknown`

	