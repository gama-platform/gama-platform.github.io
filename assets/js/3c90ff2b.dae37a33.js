"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[66803],{73428:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>r});var i=n(85893),s=n(11151);const a={title:"Runtime Concepts"},l=void 0,o={id:"RuntimeConcepts",title:"Runtime Concepts",description:"[//]: # (startConcept|runtimeandschedulers)",source:"@site/versioned_docs/version-1.8.1/RuntimeConcepts.md",sourceDirName:".",slug:"/RuntimeConcepts",permalink:"/wiki/1.8.1/RuntimeConcepts",draft:!1,unlisted:!1,editUrl:"https://github.com/gama-platform/gama/wiki/RuntimeConcepts/_edit",tags:[],version:"1.8.1",frontMatter:{title:"Runtime Concepts"},sidebar:"main",previous:{title:"Optimizing Models",permalink:"/wiki/1.8.1/OptimizingModelsSection"},next:{title:"Optimizing Models",permalink:"/wiki/1.8.1/OptimizingModels"}},c={},r=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"Simulation initialization",id:"simulation-initialization",level:2},{value:"Agents Creation",id:"agents-creation",level:2},{value:"Agents Step",id:"agents-step",level:2},{value:"Schedule Agents",id:"schedule-agents",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"When a model is being simulated, a number of algorithms are applied, for instance, to determine the order in which to run the different agents, or the order in which the initialization of agents is performed, etc. This section details some of them, which can be important when building models and understanding how they will be effectively simulated."}),"\n",(0,i.jsx)(t.h2,{id:"table-of-contents",children:"Table of contents"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#simulation-initialization",children:"Simulation initialization"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#agents-creation",children:"Agents Creation"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#agents-step",children:"Agents Step"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#schedule-agents",children:"Schedule Agents"})}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"simulation-initialization",children:"Simulation initialization"}),"\n",(0,i.jsxs)(t.p,{children:["Once the user launches an experiment, GAMA starts by creating an experiment agent that will manage the initialization of the simulation(s). For each simulation, first, it creates a ",(0,i.jsxs)(t.a,{href:"GlobalSpecies",children:[(0,i.jsx)(t.code,{children:"world"})," agent"]}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["It initializes all its attributes with their init values. This includes its ",(0,i.jsx)(t.code,{children:"shape"})," (that will be used as the environment of the simulation)."]}),"\n",(0,i.jsxs)(t.p,{children:["If a species of type ",(0,i.jsx)(t.a,{href:"GridSpecies",children:"grid"})," exists in the model, agents of this species are created."]}),"\n",(0,i.jsxs)(t.p,{children:["Finally, the ",(0,i.jsx)(t.code,{children:"init"})," statement of the ",(0,i.jsx)(t.code,{children:"global"})," is executed. It should include the creation of all the other agents of ",(0,i.jsx)(t.a,{href:"RegularSpecies",children:"regular species"})," of the simulation. After their creation and initialization, they are added in the list ",(0,i.jsx)(t.code,{children:"members"})," the ",(0,i.jsx)(t.code,{children:"world"})," (that contains all the micro-agent of the ",(0,i.jsx)(t.code,{children:"world"}),")."]}),"\n",(0,i.jsx)(t.h2,{id:"agents-creation",children:"Agents Creation"}),"\n",(0,i.jsxs)(t.p,{children:["Except ",(0,i.jsx)(t.a,{href:"GridSpecies",children:(0,i.jsx)(t.code,{children:"grid"})})," agents, other agents are created using the ",(0,i.jsxs)(t.a,{href:"Statements#create",children:[(0,i.jsx)(t.code,{children:"create"})," statement"]}),". It is used to allocate memory for each agent and to initialize all its attributes."]}),"\n",(0,i.jsxs)(t.p,{children:["If no explicit initialization exists for an attribute, it will get the default value corresponding to its ",(0,i.jsx)(t.a,{href:"DataTypes",children:"type"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"The initialization of an attribute can be located at several places in the code; they are executed in the following order (which means that, if several ways are used, the attribute will finally have the value of the last applied one):"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["in the attribute declaration, using the ",(0,i.jsx)(t.code,{children:"init"})," or ",(0,i.jsx)(t.code,{children:"<-"})," facet."]}),"\n",(0,i.jsxs)(t.li,{children:["using the ",(0,i.jsx)(t.code,{children:"from:"})," or ",(0,i.jsx)(t.code,{children:"with"})," facet of the ",(0,i.jsx)(t.code,{children:"create"})," statement."]}),"\n",(0,i.jsxs)(t.li,{children:["in the ",(0,i.jsx)(t.code,{children:"init"})," block of the species."]}),"\n",(0,i.jsxs)(t.li,{children:["in the embedded block of the ",(0,i.jsx)(t.code,{children:"create"})," statement."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"agents-step",children:"Agents Step"}),"\n",(0,i.jsxs)(t.p,{children:["When an agent is asked to ",(0,i.jsx)(t.em,{children:"step"}),", it means that it is expected to:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["update its variables (facet ",(0,i.jsx)(t.code,{children:"update"})," in the variable declaration),"]}),"\n",(0,i.jsx)(t.li,{children:"run its behaviors (reflex, state...),"}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.em,{children:"step"})," its micro-agents (if any)."]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"step of agent agent_a\n    {\n        species_a <- agent_a.species\n        architecture_a <- species_a.architecture\n        ask architecture_a to step agent_a {\n             ask agent_a to update species_a.variables\n             ask agent_a to run architecture_a.behaviors\n        }\n\n        ask each micro-population mp of agent_a to step {\n            list<agent> sub-agents <- mp.compute_agents_to_schedule\n            ask each agent_b of sub-agents to step //... recursive call...\n        }\n    }\n"})}),"\n",(0,i.jsx)(t.p,{children:"Notice that, using architecture to manage the behavior of agents, is only a possibility provided by GAMA to ease the development of a model. Modelers who need precise control on the agents' step can:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["redefine the ",(0,i.jsx)(t.code,{children:"_step_"})," action of the species, in order to explicit how the agents will behave,"]}),"\n",(0,i.jsxs)(t.li,{children:["implement no behavior in the species (but only ",(0,i.jsx)(t.code,{children:"action"}),"). The execution of agents can thus be controlled from a reflex of the ",(0,i.jsx)(t.code,{children:"global"})," that can control the execution of each of them."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"schedule-agents",children:"Schedule Agents"}),"\n",(0,i.jsxs)(t.p,{children:["The global scheduling of agents is then simply the application of this previous ",(0,i.jsx)(t.em,{children:"step"})," to the ",(0,i.jsx)(t.em,{children:"experiment agent"}),', keeping in mind that this agent has only one micro-population (of simulation agents, each instance of the model species), and that the simulation(s) inside this population contain(s), in turn, all the "regular" populations of agents of the model.']}),"\n",(0,i.jsxs)(t.p,{children:["To influence this schedule, then, one possible way is to change the way populations compute their lists of agents to schedule, which can be done in a model by providing custom definitions to the ",(0,i.jsx)(t.code,{children:"schedules"})," facet of one or several species."]}),"\n",(0,i.jsx)(t.p,{children:"A practical application of this facet is to reduce simulation artifacts created by the default scheduling of populations, which is sequential (i.e. their agents are executed in turn in their order of creation). To enable pseudo-parallel scheduling based on a random scheduling recomputed at each step, one has simply to define the corresponding species like in the following example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"species A schedules: shuffle(A) {...}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Moving further, it is possible to enable completely random scheduling, that will eliminate the sequential scheduling of populations, by defining a custom species acting as a scheduler of the agents (that will be executed after the ",(0,i.jsx)(t.code,{children:"world"})," agent):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"global {...}\n\nspecies scheduler schedules: shuffle(A + B + C);\n\nspecies A schedules: [] {...}\nspecies B schedules: [] {...}\nspecies C schedules: [] {...}\n"})}),"\n",(0,i.jsx)(t.p,{children:"It is important to suppress the population-based scheduling to avoid having agents being scheduled 2 times (one time in the custom definition, one time by their population). Note that it is not necessary to create a scheduler agent."}),"\n",(0,i.jsx)(t.p,{children:"Other schemes are possible. For instance, the following definition will completely suppress the default scheduling mechanism to replace it with a custom scheduler that will execute the world, then all agents of species A in a random way and then all agents of species B in their order of creation:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"global {...} \n\nspecies scheduler schedules: shuffle(A) + B; // explicit scheduling in the world\n\nspecies A schedules [];\nspecies B schedules: [];\n\n"})}),"\n",(0,i.jsx)(t.p,{children:"Complex conditions can be used to express which agents need to be scheduled at each step. For instance, in the following definition, only agents of A that return true to a particular condition are scheduled:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"species A schedules: A where each.can_be_scheduled() {\n\n    bool can_be_scheduled() {\n         ...\n         returns true_or_false;\n    }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Be aware that enabling a custom scheduling can potentially end up in non-functional simulations. For example, the following definition will result in an ",(0,i.jsx)(t.strong,{children:"infinite loop"})," (which will trigger a stack overflow at some point):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"global {} // The world is normally scheduled...\n\nspecies my_scheduler schedules: [world]; // ... but schedules itself again as a consequence of scheduling the micro-species 'my_scheduler'\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Note that ",(0,i.jsx)(t.code,{children:"schedules"})," facet will not be taken into account when it is added to the ",(0,i.jsx)(t.code,{children:"global"}),". It is thus not possible to unschedule the ",(0,i.jsx)(t.code,{children:"world"})," agent."]})]})}function d(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>l});var i=n(67294);const s={},a=i.createContext(s);function l(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);