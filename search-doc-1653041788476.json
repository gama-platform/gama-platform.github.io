[{"title":"Introducing GAMA Blog","type":0,"sectionRef":"#","url":"blog/2019/10/30/gama-blog","content":"","keywords":""},{"title":"Community​","type":1,"pageTitle":"Introducing GAMA Blog","url":"blog/2019/10/30/gama-blog#community","content":" We welcome your contributions to GAMA, whether you want to use it for your own project, you want to contribute to the GAMA core or just have questions. Follow us on GitHub and Twitter. "},{"title":"Resources​","type":1,"pageTitle":"Introducing GAMA Blog","url":"blog/2019/10/30/gama-blog#resources","content":"Read our documentationFollow our Twitter feedFollow us on FacebookFollow us on Github "},{"title":"GAMA Platform is now on Docker","type":0,"sectionRef":"#","url":"blog/2020/02/20/gama-docker","content":"","keywords":""},{"title":"Why Docker?​","type":1,"pageTitle":"GAMA Platform is now on Docker","url":"blog/2020/02/20/gama-docker#why-docker","content":"Docker provides a robust platform for Continuous Delivery, Continuous Integration and Continuous Deployment, facilitating delivery of innovation faster.Facilitates customers packaging their configured systems into images and containersFacilitates easy portability to virtual machines or bare metal servers, on-premise or in the cloud (IaaS)Docker provides a transparent mechanism that facilitates collaboration with the open-source community, facilitating rapid convergence on best practices for DevOps (build, functional/PSR test, demo, deploy). "},{"title":"What for​","type":1,"pageTitle":"GAMA Platform is now on Docker","url":"blog/2020/02/20/gama-docker#what-for","content":"This container aim to help the usage of the GAMA headless to everyone. Thanks to that container, you'll be able to easily deploy a container on  "},{"title":"Roadmap​","type":1,"pageTitle":"GAMA Platform is now on Docker","url":"blog/2020/02/20/gama-docker#roadmap","content":"Even if the container is already usable, this image Docker is still under an heavy developpement and you should use it wisely. Our goal in a near future are : To reduce it's size. The container packed the whole GAMA software, but the headless do not use it all, so we have to cut every useless part for the headlessHave a fully working CI based on the Travis-CI releasesImprove the usability of the container. For now a lot of mistakes have been made about the input/output of the container "},{"title":"Try it!​","type":1,"pageTitle":"GAMA Platform is now on Docker","url":"blog/2020/02/20/gama-docker#try-it","content":"Even if it's not perfectly finished, we already published our Dockerfiles on Github and the Docker Hub. Go take a look if you're interested. We would love to hear about your experiences with the GAMA Platform on Docker so we can continue to improve it. Enjoy! "},{"title":"Release of GAMA 1.8.1","type":0,"sectionRef":"#","url":"blog/2020/06/22/release181","content":"We are pleased to release version 1.8.1 of the GAMA modelling and simulation platform. It is mainly a bug fix release, with a few minor enhancements. See the changelog here (or on GitHub here). All the models running on 1.8 should work without changes on 1.8.1. As usual, make a backup of your files before upgrading and report any issues here.","keywords":""},{"title":"COMOKIT 1.0.1 is out","type":0,"sectionRef":"#","url":"blog/2020/07/01/comokit101","content":"We are thrilled to announce the release of version 1.0.1 of COMOKIT, as well as its official archiving on the COMSES website. COMOKIT, the COVID-19 modeling kit built on GAMA, is a computer model that allows in silico exploration of intervention policies before their implementation phase. It can take into account important dimensions of policy actions, such as the heterogeneity of individual responses or the spatial aspect of containment strategies. COMOKIT 1.0.1 is a bugfix version that makes it easier to create case studiees. It comes pre-bundled with sample datasets, which you can adapt to your case studies. Others are also available on GitHub.","keywords":""},{"title":"GAMA Days 2020","type":0,"sectionRef":"#","url":"blog/2019/11/15/gama-days-2020","content":"Agent-based modeling is nowadays becoming increasingly popular for the study of complex systems. Nevertheless, its use requires significant computer programming work because it requires describing all agents and their behavior in the form of algorithms. The GAMA open-source platform aims to help modelers do this work. This generic platform, which has been developed since 2007 by a consortium of research teams allows the content of a model to be built using a modeling language that is easy to access and simulated. GAMA has experienced significant growth in recent years thanks to its ability to build and simulate large-scale models, including hundreds of thousands of agents and detailed geographic data. It also has advanced 3D visualization tools as well as tools dedicated to the construction of serious games. This platform is now used in many research projects dealing with issues as varied as epidemiology, land-use change, natural or technological risks, natural resource management, and urban mobility. However, while many training courses on this platform are organized around the world every year, no event has ever had the ambition to bring users and developers together in the same place. This is precisely the objective of the GAMA days, which will be held from 10 to 12 June in Toulouse (France). The challenge is to encourage exchanges between participants: to allow platform (or plug-in) developers to present their latest creations and to allow users to show how they use the platform. These exchanges will be an important step towards a better structuring of the GAMA community. In practical terms, these days will be composed of 3 types of sessions: presentation of new functionalities and exchanges with users on existing functionalities presentation of new models or projects that are based on, or include, GAMA,tutorials on specific features, extensions or applications of GAMA Official Website: https://www.irit.fr/GamaDays2020/ Steering committee: Frédéric Amblard - UT1, UMR IRITKevin Chapuis - IRD, UMI UMMISCOAlexis Drogoul - IRD, UMI UMMISCOBenoit Gaudou - UT1/IRD, UMR IRIT/UMI UMMISCODominique Longin - CNRS, UMR IRITNicolas Verstaevel - UT1, UMR IRIT Organizer: Patrick Taillandier - INRA, MIAT Program committee: Carole Adam - UGA, LIG LaboratoryDiana F. Adamatti - Universidade Federal do Rio Grande, FURGConceição de Maria A Alves - Department of Civil and Environmental Engineering, University of BrasiliaArnaud Banos - CNRS, IDEES LaboratoryJohan Barthélémy - University of Wollongong, SMART InfrastructureSrirama Bhamidipati - University of DelftEric Daudé - CNRS, IDEES LaboratoryJulie Dugdale - UGA, LIG LaboratoryArnaud Grignard - MIT, MediaLabMyriam Grillot - INRA, AGIR LaboratoryQuang Nghi Huynh - University of Can Tho, DREAM laboratorySimone Z Leao - City Futures Research Centre, Faculty of Built Environment, University of New South Wales, SydneyNicolas Marilleau - IRD, UMMISCO LaboratorySébastien Rey-Coyrehourcq - University of Rouen, IDEES LaboratoryFranck Taillandier - IRSTEA, RECOVER LaboratoryYoucef Sklab - IRD, UMMISCO LaboratoryOlivier Therond - INRA, LAE LaboratoryRallou Thomopoulos - INRA, IATE LaboratoryJean Villerd - INRA, LAE LaboratoryGudrun Walletin - Universität Salzburg, ZGIS Team","keywords":""},{"title":"GAMA Coding camp 2022","type":0,"sectionRef":"#","url":"blog/2022/05/10/coding-camp","content":"From the 4th to the 9th of May 2022 the Gama team held a Coding camp gathering Gama enthusiasts in Tam Cốc at Chez Loan to work on the next Gama release and on future models. The main focus was on getting a last round of development to finish Gama 1.8.2, that will be released in the coming days, together with a brand new website and a clean documentation. More than that, we already started important discussions about the architecture of Gama 2.0 and its development cycle. We also had workshops around a future model supporting a serious game about the waste management system in Bắc Hưng Hải irrigation system. The model provides visual support to spatialize the players actions. For those interested, you can already try the Release Candidate of Gama 1.8.2 here Thanks to all the participants for your hard work and good spirits.","keywords":""},{"title":"GAMA Days 2021","type":0,"sectionRef":"#","url":"blog/2021/03/26/gama-days-2021","content":"GAMA days 2021 is the 1st Conference where users, modelers and developers of the GAMA modeling and simulation platform will have an opportunity to meet, present their work, expose their difficulties, propose enhancements and, more generally, exchange and collaborate on exciting topics related to GAMA! Besides models themselves, which will constitute the main focus of the conference, we also seek original contributions on three transversal themes, from the point of view of users: GAMA and training: how to teach modeling and simulation using GAMA? How to teach using GAMA itself? What kind of pedagogical material should be available? How to share this material? Share training experiences? GAMA Missing features: what are the most important features missing in GAMA? Extensions that should be developed urgently? Capabilities overlooked for too many years? Integrations with other tools missing? Next generation GAMA: how should a platform like GAMA evolve in the next 10 years? Which roadmaps should we define? Which technological advances, necessary for users, should be embraced? Co-organized by MIAT (INRAE), IRIT (CNRS, INPT, Toulouse universities) and UMMISCO (IRD) laboratories, the event will be held from June 23 to 25, 2021. Due to the covid-19 pandemics and in order to allow the participation of as many people as possible, the GAMA days will take place online and registration will be free. Official Website: https://www.irit.fr/GamaDays2021/ Steering committee: Frédéric Amblard - UT1, UMR IRITKevin Chapuis - IRD, UMI UMMISCOAlexis Drogoul - IRD, UMI UMMISCOBenoit Gaudou - UT1/IRD, UMR IRIT/UMI UMMISCODominique Longin - CNRS, UMR IRITNicolas Verstaevel - UT1, UMR IRIT Organizer: Patrick Taillandier - INRAE, MIAT Program committee: Carole Adam - UGA, LIG LaboratoryDiana F. Adamatti - Universidade Federal do Rio Grande, FURGConceição de Maria A Alves - Department of Civil and Environmental Engineering, University of BrasiliaArnaud Banos - CNRS, IDEES LaboratoryJohan Barthélémy - University of Wollongong, SMART InfrastructureSrirama Bhamidipati - University of DelftEric Daudé - CNRS, IDEES LaboratoryJulie Dugdale - UGA, LIG LaboratoryArnaud Grignard - MIT, MediaLabMyriam Grillot - INRAE, AGIR LaboratoryQuang Nghi Huynh - University of Can Tho, DREAM laboratorySimone Z Leao - City Futures Research Centre, Faculty of Built Environment, University of New South Wales, SydneyNicolas Marilleau - IRD, UMMISCO LaboratorySébastien Rey-Coyrehourcq - University of Rouen, IDEES LaboratoryFranck Taillandier - INRAE, RECOVER LaboratoryYoucef Sklab - IRD, UMMISCO LaboratoryOlivier Therond - INRAE, LAE LaboratoryRallou Thomopoulos - INRAE, IATE LaboratoryJean Villerd - INRAE, LAE LaboratoryGudrun Walletin - Universität Salzburg, ZGIS Team","keywords":""},{"title":"Attaching Skills","type":0,"sectionRef":"#","url":"wiki/AttachingSkills","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"Attaching Skills","url":"wiki/AttachingSkills#index","content":"The moving skillOther skillsExample of implementation "},{"title":"Skills​","type":1,"pageTitle":"Attaching Skills","url":"wiki/AttachingSkills#skills","content":"A declaration of skill is done by filling the skills facet in the species definition: species my_species skills: [skill1,skill2] { }  A very useful and common skill is the moving skill. species my_species skills: [moving] { }  Once your species has the moving skill, it earns automatically the following attributes: speed, heading, destination and the following actions: move, goto, follow, wander and wander_3D. "},{"title":"Attributes:​","type":1,"pageTitle":"Attaching Skills","url":"wiki/AttachingSkills#attributes","content":"speed (float) designs the speed of the agent, in m/s.heading (int) designs the heading of an agent in degrees, which means that is the maximum angle the agent can turn around each step.destination (point) is the updated destination of the agent, with respect to its speed and heading. It's a read-only attribute, you can't change its value. "},{"title":"Actions:​","type":1,"pageTitle":"Attaching Skills","url":"wiki/AttachingSkills#actions","content":"follow​ moves the agent along a given path passed in the arguments. returns: path speed (float): the speed to use for this move (replaces the current value of speed) path (path): a path to be followed. move_weights (map): Weights used for the moving. return_path (boolean): if true, return the path followed (by default: false)  goto​ moves the agent towards the target passed in the arguments. returns: path target (agent,point,geometry): the location or entity towards which to move. speed (float): the speed to use for this move (replaces the current value of speed) on (graph): graph that restrains this move recompute_path (boolean): if false, the path is not recompute even if the graph is modified (by default: true) return_path (boolean): if true, return the path followed (by default: false) move_weights (map): Weights used for the moving.  move​ moves the agent forward, the distance being computed with respect to its speed and heading. The value of the corresponding variables are used unless arguments are passed. returns: path speed (float): the speed to use for this move (replaces the current value of speed) heading (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2) bounds (geometry,agent): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry  wander​ Moves the agent towards a random location at the maximum distance (with respect to its speed). The heading of the agent is chosen randomly if no amplitude is specified. This action changes the value of heading. returns: void speed (float): the speed to use for this move (replaces the current value of speed) amplitude (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2) bounds (agent,geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry  wander_3D​ Moves the agent towards a random location (3D point) at the maximum distance (with respect to its speed). The heading of the agent is chosen randomly if no amplitude is specified. This action changes the value of heading. returns: path speed (float): the speed to use for this move (replaces the current value of speed) amplitude (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2) z_max (int): the maximum altitude (z) the geometry can reach bounds (agent,geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry  "},{"title":"Other skills​","type":1,"pageTitle":"Attaching Skills","url":"wiki/AttachingSkills#other-skills","content":"A lot of other skills are available. Some of them can be built in skills, integrated by default in GAMA, other are linked to additional plugins. This is the list of skills:Advanced_driving, communication, driving, GAMASQL, graphic, grid, MDXSKILL, moving, moving3D, physical3D, skill_road, skill_road, skill_road_node, SQLSKILL "},{"title":"Example​","type":1,"pageTitle":"Attaching Skills","url":"wiki/AttachingSkills#example","content":"We can now build a model using the skill moving. Let's design 2 species, one is &quot;species_red&quot;, the other is &quot;species_green&quot;. Species_green agents are moving randomly with a certain speed and a certain heading. Species_red agents wait for a species_green agent to be in a certain range of distance. Once it is the case, the agent move toward the species_green agent. A line link the red_species agent and its target.  Here is an example of implementation: model green_and_red_species global{ float distance_to_intercept &lt;- 10.0; int number_of_green_species &lt;- 50; int number_of_red_species &lt;- 50; init { create speciesA number:number_of_green_species; create speciesB number:number_of_red_species; } } species speciesA skills:[moving] { init { speed &lt;- 1.0; } reflex move { do wander amplitude: 90.0; } aspect default { draw circle(1) color:#green border: #black; } } species speciesB skills:[moving] { speciesA target; init { speed &lt;- 0.0; heading &lt;- 90.0; } reflex search_target when: target=nil { ask speciesA at_distance(distance_to_intercept) { myself.target &lt;- self; } } reflex follow when: target!=nil { speed &lt;- 0.8; do goto target: target; } aspect default { draw circle(1) color:#red border: #black; if (target!=nil) { draw polyline([self.location,target.location]) color:#black; } } } experiment my_experiment type: gui { output{ display myDisplay { species speciesA aspect:default; species speciesB aspect:default; } } }  "},{"title":"Defining Batch Experiments","type":0,"sectionRef":"#","url":"wiki/BatchExperiments","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Defining Batch Experiments","url":"wiki/BatchExperiments#table-of-contents","content":"The batch experiment facetsAction _step_ and reflexesPermanent "},{"title":"The batch experiment facets​","type":1,"pageTitle":"Defining Batch Experiments","url":"wiki/BatchExperiments#the-batch-experiment-facets","content":"Batch experiments have the following three facets: until: (expression) Specifies when to stop each simulation. Its value is a condition on variables defined in the model. The run will stop when the condition is evaluated to true. If omitted, the first simulation run will go forever, preventing any subsequent run to take place (unless a halt command is used in the model itself).repeat: (integer) Specifies the number of simulations replications for each parameter configuration (a set of values assigned to the parameters). This means that several simulation will be run with the same parameter values, however a different random seed will be used for the pseudo-random number generator for each simulation. This allows to get some statistical power from the experiments conducted for stochastic models. The default value is 1.keep_seed: (boolean) If true, the same series of random seeds will be used from one parameter configuration to another. The default value is false. experiment my_batch_experiment type: batch repeat: 5 keep_seed: true until: (cycle = 300) { [parameter to explore] [exploration method] }  "},{"title":"Action _step_ and reflexes​","type":1,"pageTitle":"Defining Batch Experiments","url":"wiki/BatchExperiments#action-_step_-and-reflexes","content":"As for any species, experiment can define as many reflex as needed. In a batch experiment, they will be executed at the end of each bunch of simulations (set of replications) for a given parameters configuration. Note that at the experiment level, you have access to all the species and all the global variables and to all the simulations (variable simulations). To be complete, each experiment (as any agent) will call at each step (i.e. the end of the replications set) the _step_ action: this action is in charge of executing the behavior of the experiment agent, that is by default the execution of each of its reflex. It is possible to redefine the action _step_, but this should be used with care since this inhibits the reflexes. For instance, the following experiment runs the simulation 5 times, and saves the people agents in a single shapefile at the end of the 5 simulations. experiment 'Run 5 simulations' type: batch repeat: 5 keep_seed: true until: ( time &gt; 1000 ) { int cpt &lt;- 0; reflex save_people { save people type:&quot;shp&quot; to:&quot;people_shape&quot; + cpt + &quot;.shp&quot; with: [is_infected::&quot;INFECTED&quot;, is_immune::&quot;IMMUNE&quot;]; cpt &lt;- cpt + 1; } }  The same can be done using the action _step_ { instead of reflex save_people {. But if now we want to save information from the 5 simulations and save 1 shapefile per replication, we need to use the built-in attribute simulations. To save 1 shapefile per simulation run, we thus need to write: experiment 'Run 5 simulations' type: batch repeat: 5 keep_seed: true until: ( time &gt; 1000 ) { reflex end_of_runs { int cpt &lt;- 0; ask simulations { save people type: &quot;shp&quot; to: &quot;result/people_shape&quot; + cpt + &quot;.shp&quot; with: [is_infected::&quot;INFECTED&quot;, is_immune::&quot;IMMUNE&quot;]; cpt &lt;- cpt + 1; } } }  If now we want to save in a file aggregated values over the five simulations, such as the average number of infected people over the five simulations, we need to write: experiment 'Run 5 simulations' type: batch repeat: 5 keep_seed: true until: ( cycle &gt; 1000 ) { reflex t { save [cycle, simulations mean_of each.nb_infected] to: &quot;result.txt&quot; type: &quot;csv&quot;; } }  "},{"title":"Permanent​","type":1,"pageTitle":"Defining Batch Experiments","url":"wiki/BatchExperiments#permanent","content":"The permanent statement allows the modeler to define an output block that will not be re-initialized at the beginning of each simulation but will be filled instead at the end of each simulation. For instance, this permanent section will plot for each simulation the end value of the food_gathered variable (defined as a global variable in the model). permanent { display Ants background: #white refresh: every(1#cycle) { chart &quot;Food Gathered&quot; type: series { data &quot;Food&quot; value: food_gathered; } } }  "},{"title":"Parameter sets in parallel​","type":1,"pageTitle":"Defining Batch Experiments","url":"wiki/BatchExperiments#parameter-sets-in-parallel","content":"There is an option in the Preferences... menu of Gama to allow multiple replications to be executed in parallel, that is to fully use assigned cores to computation. In that case, permanent and reflex blocks in the experiment will only be triggered once at the end of the whole set of simulations, rather than after each set of replications. Therefor, this option should only be used when doing none GUI batch experiment "},{"title":"Batch Specific UI","type":0,"sectionRef":"#","url":"wiki/BatchSpecific","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Batch Specific UI","url":"wiki/BatchSpecific#table-of-contents","content":"Batch Specific UI Information barBatch UI "},{"title":"Information bar​","type":1,"pageTitle":"Batch Specific UI","url":"wiki/BatchSpecific#information-bar","content":"In batch mode, the top information bar displays 3 distinct information (instead of only the cycle number in the GUI experiment): The run number: One run corresponds to N executions of simulation with one given parameters values (N is an integer given by the facet repeat in the definition of a batch experiment. The number of runs is chosen by the exploration method).The simulation number: the number of replications done (and the number of replications specified with the repeat facet);The number of thread: the number of threads used for the simulation.  "},{"title":"Batch UI​","type":1,"pageTitle":"Batch Specific UI","url":"wiki/BatchSpecific#batch-ui","content":"The parameters view is also a bit different in the case of a Batch UI: it shows both the parameters of the experiment, with a distinction between the ones that will be explored and the ones that will not.it also shows the state of the exploration. The provided information will depend on the exploration method. The following interface is generated given the following experiment (the exploration method is here the exhaustive one): experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed) or (time &gt; 400) { parameter 'Size of the grid:' var: gridsize init: 75 unit: 'width and height'; parameter 'Number:' var: ants_number init: 200 unit: 'ants'; parameter 'Evaporation:' var: evaporation_per_cycle among: [0.1, 0.2, 0.5, 0.8, 1.0] unit: 'rate every cycle (1.0 means 100%)'; parameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3; method exhaustive maximize: food_gathered; }   The interface summarises all model parameters and the parameters given to the exploration method: Environment and Population: displays all the model parameters that should not be explored. Those parameters must be initialized with a fixed value when they are defined in the experiment.Parameters to explore: the parameters to explore are the parameters defined in the experiment with a range of values (with among facet or min, max and step facets);Exploration method: it displays information about the exploration method and the stop condition. It displays the size of the parameter space in the case of the exhaustive method, and different parameters (e.g. mutation or crossover probability...) for other methods. Finally, the best and the last fitnesses found are shown, along with the associated parameter sets. The following interface corresponds to the same experiment as previously, but with the genetic exploration method. experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed) or (time &gt; 400) { // [Parameters] method genetic maximize: food_gathered; }   "},{"title":"BDI Agents","type":0,"sectionRef":"#","url":"wiki/BDIAgents","content":"","keywords":""},{"title":"Model Overview​","type":1,"pageTitle":"BDI Agents","url":"wiki/BDIAgents#model-overview","content":"The model built in this tutorial concerns gold miners that try to find and sell gold nuggets. More precisely, we consider that several gold mines containing a certain amount of gold nuggets are located in the environment. In the same way, a market where the miners can sell their gold nuggets is located in the environment. The gold miners try to find gold mines, to extract gold nuggets from them and to sell the gold extracted nuggets at the market. "},{"title":"Step List​","type":1,"pageTitle":"BDI Agents","url":"wiki/BDIAgents#step-list","content":"This tutorial is composed of 5 steps corresponding to 5 models. For each step, we present its purpose, an explicit formulation, and the corresponding GAML code. Creation of the basic model: gold mines and marketDefinition of the BDI minersDefinition of social relations between minersUse of emotions and personality for the minersAdding norms, obligations and enforcement "},{"title":"1. Skeleton model","type":0,"sectionRef":"#","url":"wiki/BDIAgents_step1","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"1. Skeleton model","url":"wiki/BDIAgents_step1#formulation","content":"Definition of the gold mine speciesDefinition of the market speciesCreation of the gold mine and market agentsDefinition of a display with the gold mines and the market "},{"title":"Model Definition​","type":1,"pageTitle":"1. Skeleton model","url":"wiki/BDIAgents_step1#model-definition","content":""},{"title":"species​","type":1,"pageTitle":"1. Skeleton model","url":"wiki/BDIAgents_step1#species","content":"In this first model, we have to define two species of agents: the gold_mine agents and the market ones. These agents will not have a particular behavior, they will just be displayed. For the gold mine species, we define a new attribute: quantity of type int, with for initial value a random integer between 1 and 20. We also define an aspect named default that displays the gold mine as a triangle with a gray color if the gold mine is empty, yellow otherwise. The size of the triangle depends on the quantity of gold nuggets in the mine. Concerning the market species, we define a new attribute: golds of type int. We define as well an aspect named default that displays the market as a blue square. species gold_mine { int quantity &lt;- rnd(1,20); aspect default { draw triangle(200 + quantity * 50) color: (quantity &gt; 0) ? #yellow : #gray border: #black; } } species market { int golds; aspect default { draw square(1000) color: #black ; } }  "},{"title":"global variables​","type":1,"pageTitle":"1. Skeleton model","url":"wiki/BDIAgents_step1#global-variables","content":"We define two global variables for the model: one called nb_mines that will be used to define the number of mines and that will be set to 10. One call the_market that will represent the market agent (that will be unique). In addition, we define the duration of a simulation step to 10 minutes, and we define the shape of the environment by a square with a side size of 20 kilometers. global { int nb_mines &lt;- 10; market the_market; float step &lt;- 10#mn; geometry shape &lt;- square(20 #km); }  "},{"title":"global init​","type":1,"pageTitle":"1. Skeleton model","url":"wiki/BDIAgents_step1#global-init","content":"At the initialization of the model, we create a market agent and nb_mines gold mine agents. For the market agent, we set the value of the the_market agent with the created agent. global { ... init { create market { the_market &lt;- self; } create gold_mine number: nb_mines; } }  "},{"title":"display​","type":1,"pageTitle":"1. Skeleton model","url":"wiki/BDIAgents_step1#display","content":"We define a display to visualize the market and gold mine agents. We use for that the classic species keyword. In order to optimize the display, we use an OpenGL display (facet type: opengl). In the experiment block: output { display map type: opengl { species market ; species gold_mine ; } }  "},{"title":"Complete Model​","type":1,"pageTitle":"1. Skeleton model","url":"wiki/BDIAgents_step1#complete-model","content":"msi.gaml.architecture.simplebdi/models/BDI%20Architecture/models/Tutorial/BDI%20tutorial%201.gaml loading... See full example on GitHub "},{"title":"Basic programming concepts in GAML","type":0,"sectionRef":"#","url":"wiki/BasicProgrammingConceptsInGAML","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"Basic programming concepts in GAML","url":"wiki/BasicProgrammingConceptsInGAML#index","content":"Variables Basic typesThe point typeA word about dimensions Declare variables using facetOperators in GAMA Logical operatorsComparison operatorsType casting operatorsOther operators Conditional structuresLoopManipulate containersRandom values "},{"title":"Variables​","type":1,"pageTitle":"Basic programming concepts in GAML","url":"wiki/BasicProgrammingConceptsInGAML#variables","content":"Variables are declared very easily in GAML, starting with the keyword for the type, following by the name you want for your variable. NB: The declaration has to be inside the global, the experiment, or the species scope. typeName myVariableName;  "},{"title":"Basic types​","type":1,"pageTitle":"Basic programming concepts in GAML","url":"wiki/BasicProgrammingConceptsInGAML#basic-types","content":"All the &quot;basic&quot; types are present in GAML:int, float, string, bool (see the data type page for information about all the available datatype). The operator for the affectation in GAML is &lt;- (the operator = is used to test the equality). int integerVariable &lt;- 3; float floatVariable &lt;- 2.5; string stringVariable &lt;- &quot;test&quot;; // you can also write simple ' : &lt;- 'test' bool booleanVariable &lt;- true; // or false  To follow the behavior of a variable, we can write their value in the console. Let's go back to our basic skeleton of a model, and let's create a reflex in the global scope (to be short, a reflex is a procedure that is executed in each step. We will come back to this concept later). The write statement works very easily, simply writing down the keyword write and the name of the variable we want to be displayed. model firstModel global { int integerVariable &lt;- 3; float floatVariable &lt;- 2.5; string stringVariable &lt;- &quot;test&quot;; // you can also write simple ' : &lt;- 'test' bool booleanVariable &lt;- true; // or false reflex writeDebug { write integerVariable; write floatVariable; write stringVariable; write booleanVariable; } } experiment myExperiment {}  The statement write is overloaded for each type of variable (even for the more complex type, such as containers). Note that before being initialized, a variable has the value nil. reflex update { string my_string; write my_string; // this will write &quot;nil&quot;. int my_int; write my_int; // this will write &quot;0&quot;, which is the default value for int. }  nil is also a literal you can use to initialize your variables (you can learn more about the concept of literal in this page). reflex update { string my_string &lt;- &quot;a string&quot;; my_string &lt;- nil; write my_string; // this will write &quot;nil&quot;. int my_int &lt;- 6; my_int &lt;- nil; write my_int; // this will write &quot;0&quot;, which is the default value for int. }  "},{"title":"The point type​","type":1,"pageTitle":"Basic programming concepts in GAML","url":"wiki/BasicProgrammingConceptsInGAML#the-point-type","content":"Another variable type you should know is the point type. This type of variable is used to describe coordinates. It is in fact a complex variable, composed of two float variables (or three if you are working in 3D). To declare it, you have to use the curly bracket {: point p &lt;- {0.2,2.4};  The first field is related to the x value, and the second one to the y value. You can easily get this value as follows: point p &lt;- {0.2,2.4}; write p.x; // the output will be 0.2 write p.y; // the output will be 2.4  You cannot modify directly the value. But if you want, you can do a simple operation to get what you want: point p &lt;- {0.2,2.4}; p &lt;- p + {0.0,1.0}; write p.y; // the output will be 3.4  "},{"title":"A world about dimensions​","type":1,"pageTitle":"Basic programming concepts in GAML","url":"wiki/BasicProgrammingConceptsInGAML#a-world-about-dimensions","content":"When manipulating float values, you can specify the dimension (also called unit) of your value. Dimensions are preceded by # or ° (exactly the same). float a &lt;- 5°m; float b &lt;- 4#cm; float c &lt;- a + b; // c is equal to 5.0399999 (it's not equal to 5.04 because it is a float value, not as precise as int)  "},{"title":"Declare variables using facet​","type":1,"pageTitle":"Basic programming concepts in GAML","url":"wiki/BasicProgrammingConceptsInGAML#declare-variables-using-facet","content":"Facets are used to describe the behavior of a variable during its declaration, by adding the keyword facet just after the variable name, followed by the value you want for the facet (or also just after the initial value). See the page related to the variable declaration for all the facets. type variableName &lt;- initialValue facet1:valueForFacet1 facet2:valueForFacet2; // or: type variableName facet1:valueForFacet1 facet2:valueForFacet2; variableName &lt;- initialValue;  You can use the facet update if you want the value of your variable to change at every simulation step. For example, to increment your integer variable each step, you can do as follow: int integerVariable &lt;- 3 min: 0 max: 10 update: integerVariable+1; // nb: the operator &quot;++&quot; doesn't exist in gaml.  You can use the facets min and max to constraint the value in a specific range of values: int integerVariable &lt;- 3 min: 0 max: 10 update: integerVariable+1; // the result will be 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - 10 - 10 - ...  The facet among can also be useful (that can be seen as an enum): string fruits &lt;- &quot;banana&quot; among: [&quot;pear&quot;,&quot;apple&quot;,&quot;banana&quot;];  "},{"title":"Operators in GAMA​","type":1,"pageTitle":"Basic programming concepts in GAML","url":"wiki/BasicProgrammingConceptsInGAML#operators-in-gama","content":"In GAML language, you can use a lot of different operators. An operator is a function, i.e. a way to get the result of a computation. All of them are listed in this page, but here are the most useful ones: "},{"title":"Mathematical operators​","type":1,"pageTitle":"Basic programming concepts in GAML","url":"wiki/BasicProgrammingConceptsInGAML#mathematical-operators","content":"The basic arithmetical operators, such as +(add), -(substract), *(multiply), /(divide), ^(power) are used this way: // FirstOperand BinaryOperator SecondOperand // --&gt; ex: 5 * 3; // return 15 int fif &lt;- 5 * 3;  Some other operators, such as cos(cosinus), sin(sinus), tan(tangent), sqrt(square root), round(rounding) etc... are used this way: // UnaryOperator(Operand) // --&gt; ex: sqrt(49); // return 7.0 float sq &lt;- sqrt(49);  "},{"title":"Logical operators​","type":1,"pageTitle":"Basic programming concepts in GAML","url":"wiki/BasicProgrammingConceptsInGAML#logical-operators","content":"Logical operators such as and(and), or(inclusive or) are used the same way as basic arithmetical operators. The operator !(negation) has to be placed just before the operand. They return a boolean result. // FirstOperand Operator SecondOperand // --&gt; ex: true or false; // return true // NegationOperator Operand // --&gt; ex: !(true or false); // return false  "},{"title":"Comparison operators​","type":1,"pageTitle":"Basic programming concepts in GAML","url":"wiki/BasicProgrammingConceptsInGAML#comparison-operators","content":"The comparison operators !=(different than), &lt;(smaller than), &lt;=(smaller of equal), =(equal), &gt;(bigger than), &gt;=(bigger or equal) are used the same way as basic arithmetical operators: // FirstOperand Operator SecondOperand // --&gt; ex: 5 &lt; 3; // return false bool cmp &lt;- 5 &lt; 3;  "},{"title":"Type casting operators​","type":1,"pageTitle":"Basic programming concepts in GAML","url":"wiki/BasicProgrammingConceptsInGAML#type-casting-operators","content":"You can cast an operand to a special type using casting operator: // Operator(Operand); // --&gt; ex: int(2.1); // return 2 int intTwo &lt;- int(2.1);  "},{"title":"Other operators​","type":1,"pageTitle":"Basic programming concepts in GAML","url":"wiki/BasicProgrammingConceptsInGAML#other-operators","content":"A lot of other operators exist in GAML. The standard way to use those operators is as followed: Operator(FirstOperand,SecondOperand,...) --&gt; ex: rnd(1,8);  Some others are used in a more intuitive way: FirstOperand Operator SecondOperand --&gt; ex: 2[6,4,5] contains(5);  "},{"title":"Conditional structures​","type":1,"pageTitle":"Basic programming concepts in GAML","url":"wiki/BasicProgrammingConceptsInGAML#conditional-structures","content":"You can write conditionals with if/else in GAML: if (integerVariable&amp;lt;0) { write &quot;my value is negative !! The exact value is &quot; + integerVariable; } else if (integerVariable&gt;0) { write &quot;my value is positive !! The exact value is &quot; + integerVariable; } else if (integerVariable=0) { write &quot;my value is equal to 0 !!&quot;; } else { write &quot;hey... This is not possible, right ?&quot;; }  GAML also accepts ternary operator: stringVariable &lt;- (booleanVariable) ? &quot;booleanVariable = true&quot; : &quot;booleanVariable = false&quot;;  "},{"title":"Loop​","type":1,"pageTitle":"Basic programming concepts in GAML","url":"wiki/BasicProgrammingConceptsInGAML#loop","content":"Loops in GAML are designed by the keyword loop. As for variables, a loop have multiple facets to determine its behavior: The facet times, to repeat a fixed number of times a set of statements: loop times: 2 { write &quot;helloWorld&quot;; } // the output will be helloWorld - helloWorld  The facet while, to repeat a set of statements while a condition is true: loop while: true { } // infinity loop  The facet from / to, to repeat a set of statements while an index iterates over a range of values with a fixed step of 1: loop i from: 0 to: 5 { write i; } // the output will be 0 - 1 - 2 - 3 - 4 - 5  The facet from / to combine with the facet step to choose the step: loop i from: 0 to: 5 step: 2 { write i; } // the output will be 0 - 2 - 4  The facet over to browse containers, as we will see in the next part. loop i over: [0, 2, 4] { write i; } // the output will be 0 - 2 - 4  Nb: you can interrupt a loop at any time by using the break statement. "},{"title":"Manipulate containers​","type":1,"pageTitle":"Basic programming concepts in GAML","url":"wiki/BasicProgrammingConceptsInGAML#manipulate-containers","content":"We saw in the previous parts &quot;simple&quot; types of variable. You also have multiple containers types, such as list, matrix, map, pair... In this section, we will only focus on the container list (you can learn the other by reading the section about datatypes). How to declare a list? To declare a list, you can either or not specify the type of the data of its elements: list&amp;lt;int&gt; listOfInt &lt;- [5,4,9,8]; list listWithoutType &lt;- [2,4.6,&quot;oij&quot;,[&quot;hoh&quot;,0.0]];  How to know the number of elements of a list? To know the number of elements of a list, you can use the operator length that returns the number of elements (note that this operator also works with strings). int numberOfElements &lt;- length([12,13]); // will return 2 int numberOfElements &lt;- length([]); // will return 0 int numberOfElements &lt;- length(&quot;stuff&quot;); // will return 5  There is another operator, empty, that returns you a boolean telling you if the list is empty or not. bool isEmpty &lt;- empty([12,13]); // will return false bool isEmpty &lt;- empty([]); // will return true bool isEmpty &lt;- empty(&quot;stuff&quot;); // will return false  How to get an element from a list? To get an element from a list by its index, you have to use the operator at (nb: it is indeed an operator and not a facet, so no &quot;:&quot; after the keyword). int theFirstElementOfTheList &lt;- [5,4,9,8] at 0; // this will return 5 int theThirdElementOfTheList &lt;- [5,4,9,8] at 2; // this will return 9  How to know the index of an element of a list? You can know the index of the first occurrence of a value in a list using the operator index_of. You can know the index of the last occurrence of a value in a list using the operator last_index_of. int result &lt;- [4,2,3,4,5,4] last_index_of 4; // result equals 5 int result &lt;- [4,2,3,4,5,4] index_of 4; // result equals 0  How to know if an element exists in a list? You can use the operator contains (return a boolean): bool result &lt;- [{1,2}, {3,4}, {5,6}] contains {3,4}; // result equals true  How to insert/remove an element to/from a list? For those operation, you can use dedicated statements. The statements add and put are used to insert/modify an element, while the statement remove is used to remove an element. Here are some examples of how to use those 3 statements with the most common facets: list&amp;lt;int&gt; list_int &lt;- [1,5,7,6,7]; remove from:list_int index:1; // remove the 2nd element of the list write list_int; // the output is : [1,7,6,7] remove item:7 from:list_int; // remove the 1st occurrence of 7 write list_int; // the output is : [1,6,7] add item:9 to: list_int at: 2; // add 9 in the 3rd position write list_int; // the output is : [1,6,9,7] add 0 to: list_int; // add 0 in the last position write list_int; // the output is : [1,6,9,7,0] put 3 in: list_int at: 0; // put 3 in the 1st position write list_int; // the output is : [3,6,9,7,0] put 2 in: list_int key: 2; // put 2 in the 3rd position write list_int; // the output is : [3,6,2,7,0]  Note that the + and - operators can be used to add an element at the end of a list and to remove the last element of a list: list&amp;lt;int&gt; list_int &lt;- [1,5,7,6,7]; list_int &lt;- list_int + 8; write list_int; // the output is : [1,5,7,6,7,8] list_int &lt;- list_int - 7; write list_int; // the output is : [1,5,7,6,8]  How to add 2 lists? You can add 2 lists by creating a third one and browsing the 2 first one, but you can do it much easily by using the operator + : list&amp;lt;int&gt; list_int1 &lt;- [1,5,7,6,7]; list&amp;lt;int&gt; list_int2 &lt;- [6,9]; list&amp;lt;int&gt; list_int_result &lt;- list_int1 + list_int2;  How to browse a list? You can use the facet over of a loop: list&amp;lt;int&gt; exampleOfList &lt;- [4,2,3,4,5,4]; loop i over: exampleOfList { write i; } // the output will be 4 - 2 - 3 - 4 - 5 - 4  How to filter a list? If you want to get all the elements of a list that fulfill a particular condition, you need the operator where. In the condition, you can design all the elements of a particular list by using the pseudo-variable each as followed: list&amp;lt;int&gt; exampleOfList &lt;- [4,2,3,4,5,4] where (each &lt;= 3); // the list is now [2,3]  Other useful operators for the manipulation of lists: Here are some other operators which can be useful to manipulate lists: sort, sort_by, shuffle, reverse, collect, accumulate, among. Please read the GAML Reference if you want to know more about those operators. "},{"title":"Random values​","type":1,"pageTitle":"Basic programming concepts in GAML","url":"wiki/BasicProgrammingConceptsInGAML#random-values","content":"When you will implement your model, you will have to manipulate some random values quite often. To get a random value in a range of value, use the operator rnd. You can use this operator in many ways: int var0 &lt;- rnd (2); // var0 equals 0, 1 or 2 float var1 &lt;- rnd (1000) / 1000; // var1 equals a float between 0 and 1 with a precision of 0.001 float var2 &lt;- rnd(3.4); // var4 equals a random float between 0.0 and 3.4 point var3 &lt;- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}, 1); // var2 equals a point with x = 2.0, y equal to 2.0, 3.0 or 4.0 and z between 0.0 and 10.0 every 1.0 float var4 &lt;- rnd (2.0, 4.0, 0.5); // var3 equals a float number between 2.0 and 4.0 every 0.5 int var5 &lt;- rnd (2, 4); // var7 equals 2, 3 or 4 int var6 &lt;- rnd (2, 12, 4); // var5 equals 2, 6 or 10 point var7 &lt;- rnd ({2.5,3, 0.0}); // var6 equals {x,y} with x in [0.0,2.0], y in [0.0,3.0], z = 0.0 point var8 &lt;- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}); // var8 equals a point with x = 2.0, y between 2.0 and 4.0 and z between 0.0 and 10.0 float var9 &lt;- rnd (2.0, 4.0); // var9 equals a float number between 2.0 and 4.0  Use the operator flip if you want to pick a boolean value with a certain probability: bool result &lt;- flip(0.2); // result will have 20% of chance to be true  You can use randomness in list, by using the operator shuffle, or also by using the operator among to pick randomly one (or several) element of your list: list TwoRandomValuesFromTheList &lt;- 2 among [5,4,9,8]; // the list will be for example [5,9].  You can use probabilistic laws, using operators such as gauss, poisson, binomial, or truncated_gauss (we invite you to read the documentation for those operators). "},{"title":"2. BDI Agents","type":0,"sectionRef":"#","url":"wiki/BDIAgents_step2","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"2. BDI Agents","url":"wiki/BDIAgents_step2#formulation","content":"Definition of global predicatesDefinition of the gold miner speciesDefinition of the gold miner perceptionsDefinition of the gold miner rulesDefinition of the gold miner plansCreation and display of the gold miners "},{"title":"BDI agents​","type":1,"pageTitle":"2. BDI Agents","url":"wiki/BDIAgents_step2#bdi-agents","content":"A classic paradigm to formalize the internal architecture of cognitive agents in Agent-Oriented Software Engineering is the BDI (Belief-Desire-Intention) paradigm. This paradigm, based on the philosophy of action (Bratman, 1987), allows to design expressive and realistic agents. The concepts of Belief-Desire-Intention can be summarized as follow for the Gold Miner: the Miner agent has a general desire to find gold. As it is the only thing it wants at the beginning, it is its initial intention (what it is currently doing). To find gold, it wanders around (its plan is to wander). When it perceives some gold nuggets, it stores this information (it has a new belief about the existence and location of this gold nugget), and it adopts a new desire (it wants to extract the gold). When it perceives a gold nugget, the intention to find gold is put on hold and a new intention is selected (to extract gold). To achieve this intention, the plan has two steps, i.e. two new (sub)intentions: to choose a gold nugget to extract (among its known gold nuggets) and to go and take it. And so on. In GAMA, we propose a control architecture for agents based on this paradigm. This control architecture provides the agents with 3 databases linked to the agent cognition (that are 3 additional variables): belief_base (what it knows): the internal knowledge the agent has about the world or about its internal state, updated during the simulation. A belief can concern any type of information (a quantity, a location, a boolean value, etc).desire_base (what it wants): objectives that the agent would like to accomplish, also updated during the simulation. Desires can have hierarchical links (sub/super desires) when a desire is created as an intermediary objective.intention_base (what it is doing): what the agent has chosen to do. The current intention will determine the selected plan. Intentions can be put on hold (for example when they require a sub-intention to be achieved). In addition, the BDI architecture provides agents with three types of behavior structures: Perception: a perception is a function executed at each iteration to update the agent's Belief base, to know the changes in its environment (the world, the other agents and itself). The agent can perceive other agents up to a fixed distance or inside a specific geometry. Rule: a rule is a function executed at each iteration to infer new desires or beliefs from the agent's current beliefs and desires, i.e. a new desire or belief can emerge from the existing ones. Plan: the agent has a set of plans, which are behaviors defined to accomplish specific intentions. Plans can be instantaneous and/or persistent and may have a priority value (that can be dynamic), used to select a plan when several possible plans are available to accomplish the same intention. To be more precise on the behavior of BDI agents (what the agent is going to do when activated), this one is composed of 10 steps (see (Caillou et al., 2017) and (Taillandier et al., 2016) for more details): Perceive: Perceptions are executed.Rule: Rules are executed.Is one of my intentions achieved?: If one of my intentions is achieved, sets the current plan to nil and removes the intention from the intention base. If the achieved intention's super-intention is on hold, it is reactivated (its sub-intention just got completed).Do I keep the current intention?: To take into account the environment instability, an intention-persistence coefficient is applied: with this probability, the current intention is removed from the intention stack. Do I have a current plan?: If I have a current plan, just execute it. Similarly to intentions, a plan-persistence coefficient is defined: with this probability, the current plan is just dropped.Choose a desire as new current intention: If the current intention is on hold (or the intention base is empty), choose a desire as new current intention. The new selected intention is the desire with higher priority.Choose a plan as a new current plan: The new current plan is selected among the plans compatible with the current intention (and if their activation condition is checked) and with the highest priority.Execute the plan: The current plan is executed.Is my plan finished?: To allow persistent plans, a plan may have a termination condition. If it is not reached, the same plan will be kept for the next iteration.Was my plan instantaneous?: Most agent-based simulation frameworks (GAMA included) are synchronous frameworks using steps. One consequence is that it may be useful to apply several plans during one single step. For example, if a step represents a day or a year, it would be unrealistic for an agent to spend one step to apply a plan like &quot;choose a destination&quot;. This kind of plans (mostly reasoning plans) can be defined as instantaneous: in this case a new thinking loop is applied during the same agent step. The architecture introduces two new main types of variables related to cognition: predicate: a predicate unifies the representation of the information about the world. It can represent a situation, an event or an action. mental_state: it represents the element (belief, desire, intention) manipulated by the agent and the architecture to take a decision. A mental state is composed of a modality, a predicate or another mental state, a real value and a lifetime. The modality indicates the type of the mental state (e.g. a belief or a desire), the predicate indicates the fact about which is this mental state (a mental state can also be about another mental state like a belief about a belief, etc), the value has a different interpretation depending on the modality and finally, the lifetime indicates the duration of the mental state (it can be infinite). "},{"title":"Model Definition​","type":1,"pageTitle":"2. BDI Agents","url":"wiki/BDIAgents_step2#model-definition","content":""},{"title":"predicates​","type":1,"pageTitle":"2. BDI Agents","url":"wiki/BDIAgents_step2#predicates","content":"As a first step of the integration of the BDI agents in our model, we define a set of global predicates that will represent all the information that will be manipulated by the miner agents: mine_location: represents the information about the location of a gold mine.choose_gold_mine: represents the information that the miner wants to choose a gold mine.has_gold: represents the information that the miner has a gold nugget.find_gold: represents the information that the miner wants to find gold.sell_gold: represents the information that the miner wants to sell gold. We define as well two global string (mine_at_location and empty_mine_location) for simplification purpose and to avoid misspellings. global { ... string mine_at_location &lt;- &quot;mine_at_location&quot;; string empty_mine_location &lt;- &quot;empty_mine_location&quot;; predicate mine_location &lt;- new_predicate(mine_at_location) ; predicate choose_gold_mine &lt;- new_predicate(&quot;choose a gold mine&quot;); predicate has_gold &lt;- new_predicate(&quot;extract gold&quot;); predicate find_gold &lt;- new_predicate(&quot;find gold&quot;) ; predicate sell_gold &lt;- new_predicate(&quot;sell gold&quot;) ; ... }  "},{"title":"skeleton of the miner species​","type":1,"pageTitle":"2. BDI Agents","url":"wiki/BDIAgents_step2#skeleton-of-the-miner-species","content":"We then define a miner species with the moving skill and the simple_bdi control architecture. The miner agents have 5 variables: view_dist: distance of perception of the miner agentspeed: speed of the agentmy_color: the color of the agent (random color)target: where the agent wants to gogold_sold: the number of gold nuggets sold by the agent We define the init block of the species such as to add at the creation of the agent the desire to find gold nuggets (find_gold predicate). we use for that the add_desire action provides with the BDI architecture. At last, we define an aspect in which we draw the agent with its my_color color and with a depth that depends on the number of gold nuggets collected. We then add a circle around the miner of radius view_dist to visualize the distance of perception of each agent, we set the wireframe facet to true in order to draw only its border. species miner skills: [moving] control:simple_bdi { float view_dist &lt;- 1000.0; float speed &lt;- 2#km/#h; rgb my_color &lt;- rnd_color(255); point target; int gold_sold; init { do add_desire(find_gold); } aspect default { draw circle(200) color: my_color border: #black depth: gold_sold; draw circle(view_dist) color: my_color border: #black depth: gold_sold wireframe: true; } }  "},{"title":"perception​","type":1,"pageTitle":"2. BDI Agents","url":"wiki/BDIAgents_step2#perception","content":"We add a perceive statement for the miner agents. This perceive will allow the agent to detect the gold mines that are not empty (i.e. the quantity of gold is higher than 0) at a distance lower or equal to view_dist. The use of the focus statement allows adding for each detected gold mine a belief corresponding to the location of this gold mine. The name of the belief will be mine_at_location and the location value of the gold_mine will be stored in the values (a map) variable of the belief at the key location_value. In addition, we ask the miner agent to remove the intention to find gold, allowing the agent to choose a new intention. The boolean value of the remove_intention action is used to specify if the agent should or not remove the given intention from the desire base as well. In our case, we choose to keep the desire to find golds. species miner skills: [moving] control: simple_bdi { ... perceive target: gold_mine where (each.quantity &gt; 0) in: view_dist { focus id: mine_at_location var:location; ask myself { do remove_intention(find_gold, false); } } }  Note that the perceive statement works as the ask statement: the instructions written in the statement are executed in the context of the perceive agents. It is for that that we have to use the myself keyword to ask the miner agent to execute the remove_intention action. "},{"title":"rules​","type":1,"pageTitle":"2. BDI Agents","url":"wiki/BDIAgents_step2#rules","content":"We define two rules for the miner agents: if the agent believes that there is somewhere at least one gold mine with gold nuggets, the agent gets the new desire to has a gold nugget with a strength of 2. if the agent believes that it has a gold nugget, the agent gets the new desire to sell the gold nugget with a strength of 3.  species miner skills: [moving] control:simple_bdi { ... rule belief: mine_location new_desire: has_gold strength: 2.0; rule belief: has_gold new_desire: sell_gold strength: 3.0; }  The strength of a desire will be used when selecting a desire as a new intention: the agent will choose as new intention the one with the highest strength. In our model, if the agent has the desires to find gold, to has gold and to sell gold, it will choose as intention to sell gold as it is the one with the highest strength. It is possible to replace this deterministic choice by a probabilistic one by setting the probabilistic_choice built-in variable of the BDI agent to true (false by default). "},{"title":"plans​","type":1,"pageTitle":"2. BDI Agents","url":"wiki/BDIAgents_step2#plans","content":"The last (and most important) part of the definition of BDI agents consists in defining the plans that the agents can carry out to achieve its intention. The first plan called lets_wander is defined to achieve the find_gold intention. This plan will just consist of executing the wander action of the moving skill (random move). species miner skills: [moving] control: simple_bdi { ... plan lets_wander intention: find_gold { do wander; } ... }  The second plan called get_gold is defined to achieve the has_gold intention. If the agent has no target (it does not know where to go), it adds a new sub-intention to choose a gold mine and puts the current intention on hold (the agent will wait to select a gold mine to go before executing again this plan). The add_subintention operator is used to this purpose and has 3 arguments: the sub-intention (choose_gold_mine), the super intention (has_gold) and a boolean that defines if the sub-intention should or not be added as well as a desire. The super intention (this is in fact the current intention) can be accessed with get_current_intention(). If the agent has already a target, it moves toward this target using the goto action of the moving skill. If the agent reaches its target (a gold mine) (target = location), the agent tries to extract gold nuggets from it. If the corresponding gold mine (that one located at the target location) is not empty, the agent extracts a gold nugget from it: the agent adds the belief that it has a gold nugget, then the quantity of golds in the gold mine is reduced. Otherwise, if the gold mine is empty, the agent adds the belief that this gold mine is empty and the target is set to nil. species miner skills: [moving] control:simple_bdi { ... plan get_gold intention:has_gold { if (target = nil) { do add_subintention(get_current_intention(),choose_gold_mine, true); do current_intention_on_hold(); } else { do goto target: target ; if (target = location) { gold_mine current_mine&lt;- gold_mine first_with (target = each.location); if current_mine.quantity &gt; 0 { do add_belief(has_gold); ask current_mine {quantity &lt;- quantity - 1;} } else { do add_belief(new_predicate(empty_mine_location, [&quot;location_value&quot;::target])); } target &lt;- nil; } } } ... }  The third plan called choose_closest_gold_mine is defined to achieve the choose_gold_mine intention that is instantaneous. First, the agent defines the list of all the gold mines it knows (mine_at_location beliefs), then removes the gold mines that it knows that they are empty (empty_mine_location beliefs). If the list of the possible mines is empty, the agent removes the desire and the intention to extract_gold. We use for that the remove_intention action, that removes an intention from the intention base; the second argument allows to define if the intention should be removed as well from the desire base. If the agent knows at least one gold mine that is not empty, it defines as its new target the closest gold mine. species miner skills: [moving] control: simple_bdi { ... plan choose_closest_gold_mine intention: choose_gold_mine instantaneous: true { list&amp;lt;point&gt; possible_mines &lt;- get_beliefs_with_name(mine_at_location) collect (point(get_predicate(mental_state (each)).values[&quot;location_value&quot;])); list&amp;lt;point&gt; empty_mines &lt;- get_beliefs_with_name(empty_mine_location) collect (point(get_predicate(mental_state (each)).values[&quot;location_value&quot;])); possible_mines &lt;- possible_mines - empty_mines; if (empty(possible_mines)) { do remove_intention(extract_gold, true); } else { target &lt;- (possible_mines with_min_of (each distance_to self)).location; } do remove_intention(choose_gold_mine, true); } ... }  The last plan called return_to_base is defined to achieve the sell_gold intention. The agent moves in the direction of the market using the goto action. When the agent reaches the market, it sells its gold nugget to it: first, it removes the belief that it has a gold nugget, then it removes the intention and the desire to sell golds, at last, it increments its gold_sold variable. species miner skills: [moving] control: simple_bdi { ... plan return_to_base intention: sell_gold { do goto target: the_market ; if (the_market.location = location) { do remove_belief(has_gold); do remove_intention(sell_gold, true); gold_sold &lt;- gold_sold + 1; } } ... }  "},{"title":"Gobal section​","type":1,"pageTitle":"2. BDI Agents","url":"wiki/BDIAgents_step2#gobal-section","content":"We define two new global variables: nb_miners: number of gold miners.inequality: recomputed at each simulation step: standard deviation of the number of gold nuggets extracted per miners. In the global init, after creating the gold mines and the market, we create the gold miner agents. At last, we define a global reflex end_simulation that is activated when all the gold mines are empty and no more miner has a gold nugget and that pauses the simulation and display the gold sold by each miner. global { ... int nb_minerd &lt;- 5; float inequality &lt;- 0.0 update:standard_deviation(miner collect each.gold_sold); ... init { ... create miner number: nb_miner; } reflex end_simulation when: sum(gold_mine collect each.quantity) = 0 and empty(miner where each.has_belief(has_gold)){ do pause; ask miner { write name + &quot; : &quot; +gold_sold; } } }  "},{"title":"Map display​","type":1,"pageTitle":"2. BDI Agents","url":"wiki/BDIAgents_step2#map-display","content":"We add to the map display the miner species. We also create a chart showing the gold sold of each miner. experiment GoldBdi type: gui { output { display map type: opengl { species market ; species gold_mine ; species miner; } display chart { chart &quot;Money&quot; type: series { datalist legend: miner accumulate each.name value: miner accumulate each.gold_sold color: miner accumulate each.my_color; } } } }  "},{"title":"Complete Model​","type":1,"pageTitle":"2. BDI Agents","url":"wiki/BDIAgents_step2#complete-model","content":"msi.gaml.architecture.simplebdi/models/BDI%20Architecture/models/Tutorial/BDI%20tutorial%202.gaml loading... See full example on GitHub "},{"title":"4. Emotions and Personality","type":0,"sectionRef":"#","url":"wiki/BDIAgents_step4","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"4. Emotions and Personality","url":"wiki/BDIAgents_step4#formulation","content":"Definition of global emotionsModification of the miner species to integrate emotions and personality "},{"title":"Emotions​","type":1,"pageTitle":"4. Emotions and Personality","url":"wiki/BDIAgents_step4#emotions","content":"The BDI architecture of GAMA gives the possibility to generate emotions and to use them in the cognition. The definition of emotions in GAMA is based on the OCC theory of emotions. According to this theory, an emotion is a valued answer to the appraisal of a situation. In GAMA an emotion is represented by a set of 5 elements: E: the name of the emotion felt by agent i.P: the predicate that represents the fact about which the emotion is expressed.A: the agent causing the emotion.I: the intensity of the emotion.D: the decay of the emotion's intensity. The BDI architecture of GAMA integrates a dynamic creation of emotions process that will create emotions according to the mental states of the agent. More precisely, twenty emotions can be created: eight emotions related to events, four emotions related to other agents and eight emotions related to actions. The complete description of these emotions and their creation rules can be found in (Bourgais et al., 2017). "},{"title":"Personality​","type":1,"pageTitle":"4. Emotions and Personality","url":"wiki/BDIAgents_step4#personality","content":"In order to facilitate the parametrization of the BDI agents, we add the possibility to define all the parameters related to the BDI architecture through the OCEAN model, which proposes to represent the personality of a person according to five factors (corresponding to the 5 variables of the BDI agents): O: represents the openness of someone (open-minded/narrow-minded).C: represents the consciousness of someone (act with preparations/impulsive).E: represents the extroversion of someone (extrovert/shy).A: represents the agreeableness of someone (friendly/hostile).N: represent the degree of control someone has on its emotions (calm/neurotic) Each of these variables has a value between 0 and 1. 0.5 represents the neutral value, below 0.5, the value is considered negatively and above 0.5, it is considered positively. For example, someone with a value of 1 for N is considered as calm and someone with a value of 0 for A is considered as hostile. "},{"title":"Model Definition​","type":1,"pageTitle":"4. Emotions and Personality","url":"wiki/BDIAgents_step4#model-definition","content":""},{"title":"Emotions​","type":1,"pageTitle":"4. Emotions and Personality","url":"wiki/BDIAgents_step4#emotions-1","content":"We add a new global emotion called joy that represents the joy emotion. global { ... emotion joy &lt;- new_emotion(&quot;joy&quot;); ... }  "},{"title":"Emotions and personality​","type":1,"pageTitle":"4. Emotions and Personality","url":"wiki/BDIAgents_step4#emotions-and-personality","content":"To use emotions (and to activate the automatic emotion generation process), we just have to set the value of the built-in variable use_emotions_architecture to true (false by default). In our case, one of the possible desires concerns the predicate has_gold, and when an agent fulfill this desire and find a gold nugget (plan get_gold), it gets the belief has_gold, and the emotion engine automatically creates a joy emotion. To be able to define the parameter of a BDI agent through the OCEAN model, we have to set the value of the built-in variable use_personality to true (false by default). In this model, we chose to use the default value of the O, C, E, A and N variables (default value: 0.5). The interest of using the personality in our case is to allow the emotion engine to give a lifetime to the created emotions (otherwise, the emotions would have an infinite lifetime). In this model, we only use the emotions to define if the miner agents are going to share or not its knowledge about the gold mines. We consider that the miner only shares information if it has a joy emotion (and the agent tells that it is joyfous). species miner skills: [moving] control: simple_bdi { ... bool use_emotions_architecture &lt;- true; bool use_personality &lt;- true; perceive target: gold_mine where (each.quantity &gt; 0) in: view_dist { focus mine_at_location var:location; ask myself { if (has_emotion(joy)) { write self.name + &quot; is joyous&quot;; do add_desire(predicate:share_information, strength: 5.0); } do remove_intention(find_gold, false); } } ... }  "},{"title":"Complete Model​","type":1,"pageTitle":"4. Emotions and Personality","url":"wiki/BDIAgents_step4#complete-model","content":"msi.gaml.architecture.simplebdi/models/BDI%20Architecture/models/Tutorial/BDI%20tutorial%204.gaml loading... See full example on GitHub "},{"title":"3. Social relation","type":0,"sectionRef":"#","url":"wiki/BDIAgents_step3","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"3. Social relation","url":"wiki/BDIAgents_step3#formulation","content":"Definition of the gold miner perceptions with socializationDefinition of a new gold miner plan to share information "},{"title":"Social relationships​","type":1,"pageTitle":"3. Social relation","url":"wiki/BDIAgents_step3#social-relationships","content":"The BDI architecture of GAMA allows the modeler to define explicit social relations between agents. Based on the work of (Svennevig, 2000), a social link with another agent is defined as a tuple &lt;agent, liking, dominance, solidarity, familiarity, trust&gt; with the following elements: Agent: the agent concerned by the link, identified by its name.Liking: a real value between -1 and 1 representing the degree of liking with the agent concerned by the link. A value of -1 indicates that the concerned agent is hated, a value of 1 indicates that the concerned agent is liked.Dominance: a real value between -1 and 1 representing the degree of power exerted on the agent concerned by the link. A value of -1 indicates that the concerned agent is dominating, a value of 1 indicates that the concerned agent is dominated.Solidarity: a real value between 0 and 1 representing the degree of solidarity with the agent concerned by the link. A value of 0 indicates no solidarity with the concerned agent, a value of 1 indicates a complete solidarity with the concerned agent.Familiarity: a real value between 0 and 1 representing the degree of familiarity with the agent concerned by the link. A value of 0 indicates no familiarity with the concerned agent, a value of 1 indicates a complete familiarity with the concerned agent. Trust: a real value between -1 and +1 representing the degree of trust with the agent concerned by th link. A value of -1 indicates a doubt about the agent concerned, a value of 1 indicates a complete trust with the concerned agent. With this definition, a social relation is not necessarily symmetric. For example, let's take two agents, Alice and Bob, with a social link towards each other. The agent Bob may have a social link &lt;Alice,1,-0.5,0.6,0.8,-0.2&gt; (Bob likes Alice with a value of 1, he thinks he is dominated by Alice, he is solidary with Alice with a value of 0.6, he is familiar with Alice with a value of 0.8 and he doubts about her with a value 0.2) and Alice may have a social link &lt;Bob,-0.2,0.2,0.4,0.5,0.8&gt; (Alice dislikes Bob with a value of 0.2, she thinks she is dominating Bob, she is solidary with Bob with a value of 0.4, she is familiar with Bob with a value of 0.5 and she trusts Bob with a value of 0.5). "},{"title":"Model Definition​","type":1,"pageTitle":"3. Social relation","url":"wiki/BDIAgents_step3#model-definition","content":""},{"title":"predicates​","type":1,"pageTitle":"3. Social relation","url":"wiki/BDIAgents_step3#predicates","content":"We add a new global predicate called share_information that represents the information that the miner wants to share information. global { ... predicate share_information &lt;- new_predicate(&quot;share information&quot;) ; ... }  "},{"title":"perception​","type":1,"pageTitle":"3. Social relation","url":"wiki/BDIAgents_step3#perception","content":"We add a new perceive statement for the miner agents. This perceive will allow creating a social relation with the miners that are located at a distance lower or equal to view_dist to the agent. For each of these miner agents, the agents create a new social relation using the socialize statement with a liking value that depends on the color of the agents: more the agents are close, higher will be the liking value. species miner skills: [moving] control: simple_bdi { ... perceive target: miner in: view_dist { socialize liking: 1 - point(my_color.red, my_color.green, my_color.blue) distance_to point(myself.my_color.red, myself.my_color.green, myself.my_color.blue) / 255; } }  We also modify the perceive statement previously defined in order to add the desire to share information with a strength of 5 if the agent finds a gold mine. species miner skills: [moving] control:simple_bdi { ... perceive target: gold_mine where (each.quantity &gt; 0) in: view_dist { focus mine_at_location var:location; ask myself { do add_desire(predicate:share_information, strength: 5.0); do remove_intention(find_gold, false); } } }  "},{"title":"plan​","type":1,"pageTitle":"3. Social relation","url":"wiki/BDIAgents_step3#plan","content":"At last, we add a new plan for the miner agents called share_information_to_friends to achieve the intention share_information that is instantaneous. In this plan, the miner agent first defines its list of friends, i.e. the miners with which it has a social link and that it likes (liking higher than 0). then for each friend, it shares its list of known mines (beliefs about their location), then its knowledge about the mines that are empty (beliefs about their location). As these information are already beliefs, we use the add_directly_belief action. At last, it removes the desire and intention to share_information. species miner skills: [moving] control: simple_bdi { ... plan share_information_to_friends intention: share_information instantaneous: true{ list&amp;lt;miner&gt; my_friends &lt;- list&amp;lt;miner&gt;((social_link_base where (each.liking &gt; 0)) collect each.agent); loop known_gold_mine over: get_beliefs_with_name(mine_at_location) { ask my_friends { do add_directly_belief(known_gold_mine); } } loop known_empty_gold_mine over: get_beliefs_with_name(empty_mine_location) { ask my_friends { do add_directly_belief(known_empty_gold_mine); } } do remove_intention(share_information, true); } }  "},{"title":"display​","type":1,"pageTitle":"3. Social relation","url":"wiki/BDIAgents_step3#display","content":"To show the new social link, we propose to create a new agent used to display these links (the display is done in the global section): global{ ... reflex display_social_links{ loop tempMiner over: miner{ loop tempDestination over: tempMiner.social_link_base{ if (tempDestination !=nil){ bool exists&lt;-false; loop tempLink over: socialLinkRepresentation{ if((tempLink.origin=tempMiner) and (tempLink.destination=tempDestination.agent)){ exists&lt;-true; } } if(not exists){ create socialLinkRepresentation number: 1{ origin &lt;- tempMiner; destination &lt;- tempDestination.agent; if(get_liking(tempDestination)&gt;0){ my_color &lt;- #green; } else { my_color &lt;- #red; } } } } } } } } species socialLinkRepresentation{ miner origin; agent destination; rgb my_color; aspect base{ draw line([origin,destination],50.0) color: my_color; } } experiment{ ... display socialLinks type: opengl{ species socialLinkRepresentation aspect: base; } ... }  "},{"title":"Complete Model​","type":1,"pageTitle":"3. Social relation","url":"wiki/BDIAgents_step3#complete-model","content":"msi.gaml.architecture.simplebdi/models/BDI%20Architecture/models/Tutorial/BDI%20tutorial%203.gaml loading... See full example on GitHub "},{"title":"Built-in Architectures","type":0,"sectionRef":"#","url":"wiki/BuiltInArchitectures","content":"","keywords":""},{"title":"INTRODUCTION​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#introduction","content":" "},{"title":"Table of Contents​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#table-of-contents","content":"fsm, parallel_bdi, probabilistic_tasks, reflex, rules, simple_bdi, sorted_tasks, user_first, user_last, user_only, weighted_tasks,  "},{"title":"fsm​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#fsm","content":""},{"title":"Variables​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#variables","content":"state (string): Returns the name of the current state of the agent states (list): Returns the list of all the states defined in the species  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#actions","content":" "},{"title":"parallel_bdi​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#parallel_bdi","content":"compute the bdi architecture in parallel. This skill inherit all actions and variables from SimpleBdiArchitecture "},{"title":"Variables​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#variables-1","content":""},{"title":"Actions​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#actions-1","content":" "},{"title":"probabilistic_tasks​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#probabilistic_tasks","content":"A control architecture, based on the concept of tasks, which are executed with a probability depending on their weight. This skill extends WeightedTasksArchitecture skills and have all his actions and variables "},{"title":"Variables​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#variables-2","content":""},{"title":"Actions​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#actions-2","content":" "},{"title":"reflex​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#reflex","content":"Represents the default behavioral architecture attached to species of agents if none is specified. This skills extends AbstractArchitecture and have all his actions and variables "},{"title":"Variables​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#variables-3","content":""},{"title":"Actions​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#actions-3","content":" "},{"title":"rules​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#rules","content":"A control architecture based on the concept of rules "},{"title":"Variables​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#variables-4","content":""},{"title":"Actions​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#actions-4","content":" "},{"title":"simple_bdi​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#simple_bdi","content":"this architecture enables to define a behaviour using BDI. It is an implementation of the BEN architecture (Behaviour with Emotions and Norms) "},{"title":"Variables​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#variables-5","content":"agreeableness (float): an agreeableness value for the personality belief_base (list): the belief base of the agent charisma (float): a charisma value. By default, it is computed with personality conscientiousness (float): a conscientiousness value for the personality current_norm (any type): the current norm of the agent current_plan (any type): thecurrent plan of the agent desire_base (list): the desire base of the agent emotion_base (list): the emotion base of the agent extroversion (float): an extraversion value for the personality ideal_base (list): the ideal base of the agent intention_base (list): the intention base of the agent intention_persistence (float): intention persistence law_base (list): the law base of the agent neurotism (float): a neurotism value for the personality norm_base (list): the norm base of the agent obedience (float): an obedience value. By default, it is computed with personality obligation_base (list): the obligation base of the agent openness (float): an openness value for the personality plan_base (list): the plan base of the agent plan_persistence (float): plan persistence probabilistic_choice (boolean): indicates if the choice is deterministic or probabilistic receptivity (float): a receptivity value. By default, it is computed with personality sanction_base (list): the sanction base of the agent social_link_base (list): the social link base of the agent thinking (list): the list of the last thoughts of the agent uncertainty_base (list): the uncertainty base of the agent use_emotions_architecture (boolean): indicates if emotions are automaticaly computed use_norms (boolean): indicates if the normative engine is used use_persistence (boolean): indicates if the persistence coefficient is computed with personality (false) or with the value given by the modeler use_personality (boolean): indicates if the personnality is used use_social_architecture (boolean): indicates if social relations are automaticaly computed  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#actions-5","content":"add_belief​ add the predicate in the belief base. returns: bool predicate (predicate): predicate to add as a belief strength (float): the stregth of the belief lifetime (int): the lifetime of the belief  add_belief_emotion​ add the belief about an emotion in the belief base. returns: bool emotion (emotion): emotion to add as a belief strength (float): the stregth of the belief lifetime (int): the lifetime of the belief  add_belief_mental_state​ add the predicate in the belief base. returns: bool mental_state (mental_state): predicate to add as a belief strength (float): the stregth of the belief lifetime (int): the lifetime of the belief  add_desire​ adds the predicates is in the desire base. returns: bool predicate (predicate): predicate to add as a desire strength (float): the stregth of the belief lifetime (int): the lifetime of the belief todo (predicate): add the desire as a subintention of this parameter  add_desire_emotion​ adds the emotion in the desire base. returns: bool emotion (emotion): emotion to add as a desire strength (float): the stregth of the desire lifetime (int): the lifetime of the desire todo (predicate): add the desire as a subintention of this parameter  add_desire_mental_state​ adds the mental state is in the desire base. returns: bool mental_state (mental_state): mental_state to add as a desire strength (float): the stregth of the desire lifetime (int): the lifetime of the desire todo (predicate): add the desire as a subintention of this parameter  add_directly_belief​ add the belief in the belief base. returns: bool belief (mental_state): belief to add in th belief base  add_directly_desire​ add the desire in the desire base. returns: bool desire (mental_state): desire to add in th belief base  add_directly_ideal​ add the ideal in the ideal base. returns: bool ideal (mental_state): ideal to add in the ideal base  add_directly_uncertainty​ add the uncertainty in the uncertainty base. returns: bool uncertainty (mental_state): uncertainty to add in the uncertainty base  add_emotion​ add the emotion to the emotion base. returns: bool emotion (emotion): emotion to add to the base  add_ideal​ add a predicate in the ideal base. returns: bool predicate (predicate): predicate to add as an ideal praiseworthiness (float): the praiseworthiness value of the ideal lifetime (int): the lifetime of the ideal  add_ideal_emotion​ add a predicate in the ideal base. returns: bool emotion (emotion): emotion to add as an ideal praiseworthiness (float): the praiseworthiness value of the ideal lifetime (int): the lifetime of the ideal  add_ideal_mental_state​ add a predicate in the ideal base. returns: bool mental_state (mental_state): mental state to add as an ideal praiseworthiness (float): the praiseworthiness value of the ideal lifetime (int): the lifetime of the ideal  add_intention​ check if the predicates is in the desire base. returns: bool predicate (predicate): predicate to check strength (float): the stregth of the belief lifetime (int): the lifetime of the belief  add_intention_emotion​ check if the predicates is in the desire base. returns: bool emotion (emotion): emotion to add as an intention strength (float): the stregth of the belief lifetime (int): the lifetime of the belief  add_intention_mental_state​ check if the predicates is in the desire base. returns: bool mental_state (mental_state): predicate to add as an intention strength (float): the stregth of the belief lifetime (int): the lifetime of the belief  add_obligation​ add a predicate in the ideal base. returns: bool predicate (predicate): predicate to add as an obligation strength (float): the strength value of the obligation lifetime (int): the lifetime of the obligation  add_social_link​ add the social link to the social link base. returns: bool social_link (social_link): social link to add to the base  add_subintention​ adds the predicates is in the desire base. returns: bool predicate (mental_state): the intention that receives the sub_intention subintentions (predicate): the predicate to add as a subintention to the intention add_as_desire (boolean): add the subintention as a desire as well (by default, false)  add_uncertainty​ add a predicate in the uncertainty base. returns: bool predicate (predicate): predicate to add strength (float): the stregth of the belief lifetime (int): the lifetime of the belief  add_uncertainty_emotion​ add a predicate in the uncertainty base. returns: bool emotion (emotion): emotion to add as an uncertainty strength (float): the stregth of the belief lifetime (int): the lifetime of the belief  add_uncertainty_mental_state​ add a predicate in the uncertainty base. returns: bool mental_state (mental_state): mental state to add as an uncertainty strength (float): the stregth of the belief lifetime (int): the lifetime of the belief  change_dominance​ changes the dominance value of the social relation with the agent specified. returns: bool agent (agent): an agent with who I get a social link dominance (float): a value to change the dominance value  change_familiarity​ changes the familiarity value of the social relation with the agent specified. returns: bool agent (agent): an agent with who I get a social link familiarity (float): a value to change the familiarity value  change_liking​ changes the liking value of the social relation with the agent specified. returns: bool agent (agent): an agent with who I get a social link liking (float): a value to change the liking value  change_solidarity​ changes the solidarity value of the social relation with the agent specified. returns: bool agent (agent): an agent with who I get a social link solidarity (float): a value to change the solidarity value  change_trust​ changes the trust value of the social relation with the agent specified. returns: bool agent (agent): an agent with who I get a social link trust (float): a value to change the trust value  clear_beliefs​ clear the belief base returns: bool  clear_desires​ clear the desire base returns: bool  clear_emotions​ clear the emotion base returns: bool  clear_ideals​ clear the ideal base returns: bool  clear_intentions​ clear the intention base returns: bool  clear_obligations​ clear the obligation base returns: bool  clear_social_links​ clear the intention base returns: bool  clear_uncertainties​ clear the uncertainty base returns: bool  current_intention_on_hold​ puts the current intention on hold until the specified condition is reached or all subintentions are reached (not in desire base anymore). returns: bool until (any type): the current intention is put on hold (fited plan are not considered) until specific condition is reached. Can be an expression (which will be tested), a list (of subintentions), or nil (by default the condition will be the current list of subintentions of the intention)  get_belief​ return the belief about the predicate in the belief base (if several, returns the first one). returns: mental_state predicate (predicate): predicate to get  get_belief_emotion​ return the belief about the emotion in the belief base (if several, returns the first one). returns: mental_state emotion (emotion): emotion about which the belief to get is  get_belief_mental_state​ return the belief about the mental state in the belief base (if several, returns the first one). returns: mental_state mental_state (mental_state): mental state to get  get_belief_with_name​ get the predicates is in the belief base (if several, returns the first one). returns: mental_state name (string): name of the predicate to check  get_beliefs​ get the list of predicates in the belief base returns: list&lt;mental_state&gt; predicate (predicate): predicate to check  get_beliefs_metal_state​ get the list of bliefs in the belief base containing the mental state returns: list&lt;mental_state&gt; mental_state (mental_state): mental state to check  get_beliefs_with_name​ get the list of predicates is in the belief base with the given name. returns: list&lt;mental_state&gt; name (string): name of the predicates to check  get_current_intention​ returns the current intention (last entry of intention base). returns: mental_state  get_current_plan​ get the current plan. returns: BDIPlan  get_desire​ get the predicates is in the desire base (if several, returns the first one). returns: mental_state predicate (predicate): predicate to check  get_desire_mental_state​ get the mental state is in the desire base (if several, returns the first one). returns: mental_state mental_state (mental_state): mental state to check  get_desire_with_name​ get the predicates is in the belief base (if several, returns the first one). returns: mental_state name (string): name of the predicate to check  get_desires​ get the list of predicates is in the desire base returns: list&lt;mental_state&gt; predicate (predicate): name of the predicates to check  get_desires_mental_state​ get the list of mental states is in the desire base returns: list&lt;mental_state&gt; mental_state (mental_state): name of the mental states to check  get_desires_with_name​ get the list of predicates is in the belief base with the given name. returns: list&lt;mental_state&gt; name (string): name of the predicates to check  get_emotion​ get the emotion in the emotion base (if several, returns the first one). returns: emotion emotion (emotion): emotion to get  get_emotion_with_name​ get the emotion is in the emotion base (if several, returns the first one). returns: emotion name (string): name of the emotion to check  get_ideal​ get the ideal about the predicate in the ideal base (if several, returns the first one). returns: mental_state predicate (predicate): predicate to check ad an ideal  get_ideal_mental_state​ get the mental state in the ideal base (if several, returns the first one). returns: mental_state mental_state (mental_state): mental state to return  get_intention​ get the predicates in the intention base (if several, returns the first one). returns: mental_state predicate (predicate): predicate to check  get_intention_mental_state​ get the mental state is in the intention base (if several, returns the first one). returns: mental_state mental_state (mental_state): mental state to check  get_intention_with_name​ get the predicates is in the belief base (if several, returns the first one). returns: mental_state name (string): name of the predicate to check  get_intentions​ get the list of predicates is in the intention base returns: list&lt;mental_state&gt; predicate (predicate): name of the predicates to check  get_intentions_mental_state​ get the list of mental state is in the intention base returns: list&lt;mental_state&gt; mental_state (mental_state): mental state to check  get_intentions_with_name​ get the list of predicates is in the belief base with the given name. returns: list&lt;mental_state&gt; name (string): name of the predicates to check  get_obligation​ get the predicates in the obligation base (if several, returns the first one). returns: mental_state predicate (predicate): predicate to return  get_plan​ get the first plan with the given name returns: BDIPlan name (string): the name of the planto get  get_plans​ get the list of plans. returns: list&lt;BDIPlan&gt;  get_social_link​ get the social link (if several, returns the first one). returns: social_link social_link (social_link): social link to check  get_social_link_with_agent​ get the social link with the agent concerned (if several, returns the first one). returns: social_link agent (agent): an agent with who I get a social link  get_uncertainty​ get the predicates is in the uncertainty base (if several, returns the first one). returns: mental_state predicate (predicate): predicate to return  get_uncertainty_mental_state​ get the mental state is in the uncertainty base (if several, returns the first one). returns: mental_state mental_state (mental_state): mental state to return  has_belief​ check if the predicates is in the belief base. returns: bool predicate (predicate): predicate to check  has_belief_mental_state​ check if the mental state is in the belief base. returns: bool mental_state (mental_state): mental state to check  has_belief_with_name​ check if the predicate is in the belief base. returns: bool name (string): name of the predicate to check  has_desire​ check if the predicates is in the desire base. returns: bool predicate (predicate): predicate to check  has_desire_mental_state​ check if the mental state is in the desire base. returns: bool mental_state (mental_state): mental state to check  has_desire_with_name​ check if the prediate is in the desire base. returns: bool name (string): name of the predicate to check  has_emotion​ check if the emotion is in the belief base. returns: bool emotion (emotion): emotion to check  has_emotion_with_name​ check if the emotion is in the emotion base. returns: bool name (string): name of the emotion to check  has_ideal​ check if the predicates is in the ideal base. returns: bool predicate (predicate): predicate to check  has_ideal_mental_state​ check if the mental state is in the ideal base. returns: bool mental_state (mental_state): mental state to check  has_ideal_with_name​ check if the predicate is in the ideal base. returns: bool name (string): name of the predicate to check  has_obligation​ check if the predicates is in the obligation base. returns: bool predicate (predicate): predicate to check  has_social_link​ check if the social link base. returns: bool social_link (social_link): social link to check  has_social_link_with_agent​ check if the social link base. returns: bool agent (agent): an agent with who I want to check if I have a social link  has_uncertainty​ check if the predicates is in the uncertainty base. returns: bool predicate (predicate): predicate to check  has_uncertainty_mental_state​ check if the mental state is in the uncertainty base. returns: bool mental_state (mental_state): mental state to check  has_uncertainty_with_name​ check if the predicate is in the uncertainty base. returns: bool name (string): name of the uncertainty to check  is_current_intention​ check if the predicates is the current intention (last entry of intention base). returns: bool predicate (predicate): predicate to check  is_current_intention_mental_state​ check if the mental state is the current intention (last entry of intention base). returns: bool mental_state (mental_state): mental state to check  is_current_plan​ tell if the current plan has the same name as tested returns: bool name (string): the name of the plan to test  remove_all_beliefs​ removes the predicates from the belief base. returns: bool predicate (predicate): predicate to remove  remove_belief​ removes the predicate from the belief base. returns: bool predicate (predicate): predicate to remove  remove_belief_mental_state​ removes the mental state from the belief base. returns: bool mental_state (mental_state): mental state to remove  remove_desire​ removes the predicates from the desire base. returns: bool predicate (predicate): predicate to remove from desire base  remove_desire_mental_state​ removes the mental state from the desire base. returns: bool mental_state (mental_state): mental state to remove from desire base  remove_emotion​ removes the emotion from the emotion base. returns: bool emotion (emotion): emotion to remove  remove_ideal​ removes the predicates from the ideal base. returns: bool predicate (predicate): predicate to remove  remove_ideal_mental_state​ removes the mental state from the ideal base. returns: bool mental_state (mental_state): metal state to remove  remove_intention​ removes the predicates from the intention base. returns: bool predicate (predicate): intention's predicate to remove desire_also (boolean): removes also desire  remove_intention_mental_state​ removes the mental state from the intention base. returns: bool mental_state (mental_state): intention's mental state to remove desire_also (boolean): removes also desire  remove_obligation​ removes the predicates from the obligation base. returns: bool predicate (predicate): predicate to remove  remove_social_link​ removes the social link from the social relation base. returns: bool social_link (social_link): social link to remove  remove_social_link_with_agent​ removes the social link from the social relation base. returns: bool agent (agent): an agent with who I get the social link to remove  remove_uncertainty​ removes the predicates from the uncertainty base. returns: bool predicate (predicate): predicate to remove  remove_uncertainty_mental_state​ removes the mental state from the uncertainty base. returns: bool mental_state (mental_state): mental state to remove  replace_belief​ replace the old predicate by the new one. returns: bool old_predicate (predicate): predicate to remove predicate (predicate): predicate to add  "},{"title":"sorted_tasks​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#sorted_tasks","content":"A control architecture, based on the concept of tasks, which are executed in an order defined by their weight. This skill extends the WeightedTasksArchitecture skill and take all his actions and variables "},{"title":"Variables​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#variables-6","content":""},{"title":"Actions​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#actions-6","content":" "},{"title":"user_first​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#user_first","content":"A control architecture, based on FSM, where the user is being given control before states / reflexes of the agent are executed. This skill extends the UserControlArchitecture skill and take all his actions and variables "},{"title":"Variables​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#variables-7","content":""},{"title":"Actions​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#actions-7","content":" "},{"title":"user_last​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#user_last","content":"A control architecture, based on FSM, where the user is being given control after states / reflexes of the agent are executed. This skill extends the UserControlArchitecture skill and take all his actions and variables "},{"title":"Variables​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#variables-8","content":""},{"title":"Actions​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#actions-8","content":" "},{"title":"user_only​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#user_only","content":"A control architecture, based on FSM, where the user is being given complete control of the agents. This skill extends the UserControlArchitecture skill and take all his actions and variables "},{"title":"Variables​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#variables-9","content":""},{"title":"Actions​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#actions-9","content":" "},{"title":"weighted_tasks​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#weighted_tasks","content":"The class WeightedTasksArchitecture. A simple architecture of competing tasks, where one can be active at a time. Weights of the tasks are computed every step and the chosen task is simply the one with the maximal weight "},{"title":"Variables​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#variables-10","content":""},{"title":"Actions​","type":1,"pageTitle":"Built-in Architectures","url":"wiki/BuiltInArchitectures#actions-10","content":""},{"title":"5. Norms, obligation, and enforcement","type":0,"sectionRef":"#","url":"wiki/BDIAgents_step5","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"5. Norms, obligation, and enforcement","url":"wiki/BDIAgents_step5#formulation","content":"Definition of the policeman speciesDefinition of the enforcement done by policeman speciesDefinition of the law agents have to followDefinition of a gold miner norm to fulfill its obligation and its social normsDefinition of the enforcement done by gold miners "},{"title":"Norms, obligations, and enforcement​","type":1,"pageTitle":"5. Norms, obligation, and enforcement","url":"wiki/BDIAgents_step5#norms-obligations-and-enforcement","content":"The BDI architecture of GAMA allows defining explicit social norms, laws that lead to obligations and an enforcement process to sanction or reward the other agent depending on their behavior toward norms. A social norm is a set of actions executed under certain conditions which are known by the people as the right things to do in that condition. As it is, it can be assimilated into a plan. However, a norm can be violated which mean an agent chose to disobey and do not execute it while it should. To do this, each agent has an obedient value, between 0 and 1 and computed from its personality and each norm has a threshold. If the obedient value of the agent is above the threshold, the norm is executed. An obligation is a mental state that can be assimilated with a desire. It is created by a law that indicates under which conditions the agent has to follow a particular obligation. Once again, the law can have a threshold value to be activated or not depending on the obedient value of the agent. If an agent has an obligation, it will give up its current intention and current plan to get this obligation as its intention. Then, it will choose a specific norm to answer this obligation, once again with a threshold on the obedient value. Finally, an enforcement mechanism can be defined during the perception process. Norms, laws, and obligation can be enforced. If a violation is detected, a sanction can be executed. If the norm/law/obligation is fulfilled, a reward can be executed. "},{"title":"Model Definition​","type":1,"pageTitle":"5. Norms, obligation, and enforcement","url":"wiki/BDIAgents_step5#model-definition","content":""},{"title":"law​","type":1,"pageTitle":"5. Norms, obligation, and enforcement","url":"wiki/BDIAgents_step5#law","content":"We add a law to the gold miner species that will create the obligation to get gold if a gold nugget is perceived. This law replaces a rule and expresses the fact that miners are working or not, depending on their obedience value. species miner skills: [moving] control:simple_bdi { ... law working belief: mine_location new_obligation: has_gold when:not has_obligation(has_gold) and not has_belief(has_gold) strength: 2.0 threshold: threshold_aw; ... }  "},{"title":"norms​","type":1,"pageTitle":"5. Norms, obligation, and enforcement","url":"wiki/BDIAgents_step5#norms","content":"The miners will have two norms. A first one to answer the obligation to collect gold. This norm replaces the previous plan created for this purpose. However, a new plan is declared to get 3 pieces of gold at each time. This plan will be considered illegal by the policeman species. species miner skills: [moving] control: simple_bdi { ... norm doing_job obligation: has_gold finished_when: has_belief(has_gold) threshold: threshold_obligation { if (target = nil) { do add_subintention(has_gold,choose_gold_mine, true); do current_intention_on_hold(); } else { do goto target: target ; if (target = location) { gold_mine current_mine&lt;- gold_mine first_with (target = each.location); if current_mine.quantity &gt; 0 { gold_transported &lt;- gold_transported+1; do add_belief(has_gold); ask current_mine {quantity &lt;- quantity - 1;} } else { do add_belief(new_predicate(empty_mine_location, [&quot;location_value&quot;::target])); do remove_belief(new_predicate(mine_at_location, [&quot;location_value&quot;::target])); } target &lt;- nil; } } } }  The second norm is a social norm to communicate the list of known mines to one's friends. It replaces the previous plan that did this action, while a new plan is added to give a wrong list of mines to one's friend. species miner skills: [moving] control: simple_bdi { ... norm share_information intention: share_information threshold: threshold_norm instantaneous: true { list&amp;lt;miner&gt; my_friends &lt;- list&amp;lt;miner&gt;((social_link_base where (each.liking &gt; 0)) collect each.agent); loop known_gold_mine over: get_beliefs_with_name(mine_at_location) { ask my_friends { do add_belief(known_gold_mine); } } loop known_empty_gold_mine over: get_beliefs_with_name(empty_mine_location) { ask my_friends { do add_belief(known_empty_gold_mine); } } do remove_intention(share_information, true); } }  "},{"title":"Enforcement of the social norm​","type":1,"pageTitle":"5. Norms, obligation, and enforcement","url":"wiki/BDIAgents_step5#enforcement-of-the-social-norm","content":"Finally, for the gold-miner agent, an enforcement is defined about the social norm to communicate the location of mines to other agents. A sanction and a reward are declared to change the liking value with the agent controlled, depending on if the norm is violated or fulfilled. species miner skills: [moving] control:simple_bdi { ... perceive target: miner in: view_dist { myself.agent_perceived &lt;- self; enforcement norm:&quot;share_information&quot; sanction:&quot;sanction_to_norm&quot; reward:&quot;reward_to_norm&quot;; } sanction sanction_to_norm{ do change_liking(agent_perceived,-0.1); } sanction reward_to_norm{ do change_liking(agent_perceived,0.1); } }  "},{"title":"Definition of policeman species​","type":1,"pageTitle":"5. Norms, obligation, and enforcement","url":"wiki/BDIAgents_step5#definition-of-policeman-species","content":"Finally, we define a policeman species that will wander through the map and enforce the miners about the law and the obligation. The sanctions will be a fine collected by policemen. species policeman skills: [moving] control:simple_bdi { predicate patroling &lt;- new_predicate(&quot;patrolling&quot;); float view_dist &lt;- 1000.0; miner agent_perceived &lt;- nil; init { do add_desire(patroling); } perceive target:miner in: view_dist { myself.agent_perceived &lt;- self; enforcement law: &quot;working&quot; sanction: &quot;sanction_to_law&quot;; enforcement obligation: has_gold sanction: &quot;sanction_to_obligation&quot; reward: &quot;reward_to_obligation&quot;; } sanction sanction_to_law { ask agent_perceived{ threshold_law &lt;- 0.0; gold_sold &lt;- gold_sold-5; } fine &lt;- fine +5; } sanction sanction_to_obligation { ask agent_perceived{ gold_sold &lt;- gold_sold-3; do remove_intention(sell_gold,true); thresholdObligation &lt;- self.threshold_obligation - 0.1; } fine &lt;- fine + 3; } sanction reward_to_obligation{ ask agent_perceived{ gold_sold &lt;- gold_sold+2; } fine &lt;- fine - 2; } plan patrol intention: patroling{ do wander; } aspect base{ draw circle(view_dist) color: #blue depth:0.0; } }  "},{"title":"Modification of the chart​","type":1,"pageTitle":"5. Norms, obligation, and enforcement","url":"wiki/BDIAgents_step5#modification-of-the-chart","content":"We add to the output chart displayed the data coming from the policeman. display chart { chart &quot;Money&quot; type: series { datalist legend: miner accumulate each.name value: miner accumulate each.gold_sold color: miner accumulate each.my_color; data &quot;policeman&quot; value: fine color: #red; } }  "},{"title":"Complete Model​","type":1,"pageTitle":"5. Norms, obligation, and enforcement","url":"wiki/BDIAgents_step5#complete-model","content":"msi.gaml.architecture.simplebdi/models/BDI%20Architecture/models/Tutorial/BDI%20tutorial%205.gaml loading... See full example on GitHub "},{"title":"Built-in Species","type":0,"sectionRef":"#","url":"wiki/BuiltInSpecies","content":"","keywords":""},{"title":"Table of Contents​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#table-of-contents","content":"agent, AgentDB, base_edge, experiment, graph_edge, graph_node, physical_world,  "},{"title":"agent​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#agent","content":""},{"title":"Variables​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#variables","content":"host (-29): Returns the agent that hosts the population of the receiver agent location (point): Returns the location of the agent name (string): Returns the name of the agent (not necessarily unique in its population) peers (list): Returns the population of agents of the same species, in the same host, minus the receiver agent shape (geometry): Returns the shape of the receiver agent  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#actions","content":"_init_​  Returned type: unknown _step_​  Returned type: unknown  "},{"title":"AgentDB​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#agentdb","content":"AgentDB is an abstract species that can be extended to provide agents with capabilities to access databases "},{"title":"Variables​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#variables-1","content":"agents (list): Returns the list of agents for the population(s) of which the receiver agent is a direct or undirect host members (container): Returns the list of agents for the population(s) of which the receiver agent is a direct host  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#actions-1","content":"close​ Close the established database connection. Returned type: unknown : Returns null if the connection was successfully closed, otherwise, it returns an error. connect​ Establish a database connection. Returned type: unknown : Returns null if connection to the server was successfully established, otherwise, it returns an error. Additional facets:​ params (map): Connection parameters  executeUpdate​ - Make a connection to DBMS - Executes the SQL statement in this PreparedStatement object, which must be an SQL INSERT, UPDATE or DELETE statement; or an SQL statement that returns nothing, such as a DDL statement. Returned type: int : Returns the number of updated rows. Additional facets:​ updateComm (string): SQL commands such as Create, Update, Delete, Drop with question mark values (list): List of values that are used to replace question mark  getParameter​ Returns the list used parameters to make a connection to DBMS (dbtype, url, port, database, user and passwd). Returned type: unknown : Returns the list of used parameters to make a connection to DBMS. insert​ - Make a connection to DBMS - Executes the insert statement. Returned type: int : Returns the number of updated rows. Additional facets:​ into (string): Table name columns (list): List of column name of table values (list): List of values that are used to insert into table. Columns and values must have same size  isConnected​ To check if connection to the server was successfully established or not. Returned type: bool : Returns true if connection to the server was successfully established, otherwise, it returns false. select​ Make a connection to DBMS and execute the select statement. Returned type: list : Returns the obtained result from executing the select statement. Additional facets:​ select (string): select string values (list): List of values that are used to replace question marks  setParameter​ Sets the parameters to use in order to make a connection to the DBMS (dbtype, url, port, database, user and passwd). Returned type: unknown : null. Additional facets:​ params (map): Connection parameters  testConnection​ To test a database connection . Returned type: bool : Returns true if connection to the server was successfully established, otherwise, it returns false. Additional facets:​ params (map): Connection parameters  timeStamp​ Get the current time of the system. Returned type: float : Current time of the system in millisecondes  "},{"title":"base_edge​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#base_edge","content":"A built-in species for agents representing the edges of a graph, from which one can inherit "},{"title":"Variables​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#variables-2","content":"source (agent): The source agent of this edge target (agent): The target agent of this edge  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#actions-2","content":" "},{"title":"experiment​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#experiment","content":"An experiment is a declaration of the way to conduct simulations on a model. Any experiment attached to a model is a species (introduced by the keyword 'experiment' which directly or indirectly inherits from an abstract species called 'experiment' itself. This abstract species (sub-species of 'agent') defines several attributes and actions that can then be used in any experiment. 'experiment' defines several attributes, which, in addition to the attributes inherited from agent, form the minimal set of knowledge any experiment will have access to. "},{"title":"Variables​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#variables-3","content":"minimum_cycle_duration (float): The minimum duration (in seconds) a simulation cycle should last. Default is 0. Units can be used to pass values smaller than a second (for instance '10 °msec') model_path (string): Contains the absolute path to the folder in which the current model is located project_path (string): Contains the absolute path to the project in which the current model is located rng (string): The random number generator to use for this simulation. Three different ones are at the disposal of the modeler: mersenne represents the default generator, based on the Mersenne-Twister algorithm. Very reliable; cellular is a cellular automaton based generator that should be a bit faster, but less reliable; and java invokes the standard Java generator rng_usage (int): Returns the number of times the random number generator of the experiment has been drawn seed (float): The seed of the random number generator. Each time it is set, the random number generator is reinitialized. WARNING: Setting it to zero actually means that you let GAMA choose a random seed simulation (-27): Contains a reference to the current simulation being run by this experiment simulations (list): Contains the list of currently running simulations warnings (boolean): The value of the preference 'Consider warnings as errors' workspace_path (string): Contains the absolute path to the workspace of GAMA  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#actions-3","content":"compact_memory​ Forces a 'garbage collect' of the unused objects in GAMA Returned type: unknown update_outputs​ Forces all outputs to refresh, optionally recomputing their values Returned type: unknown Additional facets:​ recompute (boolean): Whether or not to force the outputs to make a computation step  "},{"title":"graph_edge​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#graph_edge","content":"A species that represents an edge of a graph made of agents. The source and the target of the edge should be agents "},{"title":"Variables​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#variables-4","content":"source (agent): The source agent of this edge target (agent): The target agent of this edge  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#actions-4","content":" "},{"title":"graph_node​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#graph_node","content":"A base species to use as a parent for species representing agents that are nodes of a graph "},{"title":"Variables​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#variables-5","content":"my_graph (graph): A reference to the graph containing the agent  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#actions-5","content":"related_to​ This operator should never be called Returned type: bool Additional facets:​ other (agent): The other agent  "},{"title":"physical_world​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#physical_world","content":"The base species for models that act as a 3D physical world. Can register and manage agents provided with either the 'static_body' or 'dynamic_body' skill. Inherits from 'static_body', so it can also act as a physical body itself (with a 'mass', 'friction', 'gravity'), of course without motion -- in this case, it needs to register itself as a physical agent using the 'register' action "},{"title":"Variables​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#variables-6","content":"accurate_collision_detection (boolean): Enables or not a better (but slower) collision detection automated_registration (boolean): If set to true (the default), makes the world automatically register and unregister agents provided with either the 'static_body' or 'dynamic_body' skill. Otherwise, they must be registered using the 'register' action, which can be useful when only some agents need to be considered as 'physical agents'. Note that, in any case, the world needs to manually register itself if it is supposed to act as a physical body. gravity (point): Defines the value of gravity in this world. The default value is set to -9.80665 on the z-axis, that is 9.80665 m/s2 towards the 'bottom' of the world. Can be set to any direction and intensity and applies to all the bodies present in the physical world library (string): This attribute allows to manually switch between two physics library, named 'bullet' and 'box2D'. The Bullet library, which comes in two flavors (see 'use_native') and the Box2D libray in its Java version (https://github.com/jbox2d/jbox2d). Bullet is the default library but models in 2D should better use Box2D max_substeps (int): If equal to 0 (the default), makes the simulation engine be stepped alongside the simulation (no substeps allowed). Otherwise, sets the maximum number of physical simulation substeps that may occur within one GAMA simulation step terrain (31): This attribute is a matrix of float that can be used to represent a 3D terrain. The shape of the world, in that case, should be a box, where thedimension on the z-axis is used to scale the z-values of the DEM. The world needs to be register itself as a physical object use_native (boolean): This attribute allows to manually switch between the Java version of the Bullet library (JBullet, a modified version of https://github.com/stephengold/jbullet, which corresponds to version 2.72 of the original library) and the native Bullet library (Libbulletjme, https://github.com/stephengold/Libbulletjme, which is kept up-to-date with the 3.x branch of the original library).The native version is the default one unless the libraries cannot be loaded, making JBullet the default  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Species","url":"wiki/BuiltInSpecies#actions-6","content":"register​ An action that allows to register agents in this physical world. Unregistered agents will not be governed by the physical laws of this world. If the world is to play a role in the physical world,then it needs to register itself (i.e. do register([self]); Returned type: unknown Additional facets:​ bodies (container): the list or container of agents to register in this physical world "},{"title":"Calling R from GAMA models","type":0,"sectionRef":"#","url":"wiki/CallingR","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Calling R from GAMA models","url":"wiki/CallingR#introduction","content":"The R language is a powerful tool for statistical computing and graphics, and its community is very large in the world (See the website). Adding a support for the R language is one of our strong endeavors to accelerate many statistical and data mining tools integration into the GAMA platform. "},{"title":"Table of contents​","type":1,"pageTitle":"Calling R from GAMA models","url":"wiki/CallingR#table-of-contents","content":"IntroductionInstalling R and rJavaConfiguration in GAMA Linking the R connectorInstalling the R plugin Calling R from GAML Before computationComputation Evaluate an R expressionEvaluate an R scriptConvert GAMA object to R objectConvert a species to a dataframe "},{"title":"Installing R and rJava​","type":1,"pageTitle":"Calling R from GAMA models","url":"wiki/CallingR#installing-r-and-rjava","content":"Install R on your computer: please refer to the R official website, or to RStudio if you want in addition a nice IDE. Before running this model, you should install the rJava library in R. In the R (RStudio) console, write:install.packages(&quot;rJava&quot;) to install the library. To check that the install is correct, you load the library using library(rJava) (in the R console). If no error message appears, it means the installation is correct. In case of trouble: On MacOSX, in recent versions you should first write in a terminal: R CMD javareconf sudo ln -f -s $(/usr/libexec/java_home)/jre/lib/server/libjvm.dylib /usr/local/lib For Linux, make sure you have the default-jdk and default-jre packages installed and then execute the command sudo R CMD javareconf For Windows, make sure you have java environment variable setup JAVA_HOME = C:\\Program Files\\Java\\OpenJDK17U-jdk_x64_windows_hotspot_17.0.2_8\\jdk-17.0.2+8\\bin\\ CLASSPATH = C:\\Program Files\\Java\\OpenJDK17\\bin\\ If the rJava library doesnt appear in the R library directory, copy the installed rJava library from where he was installed by install.packages(&quot;rJava&quot;) to R\\R-4.2.0\\library You need to Configure the Environment Variable R_HOME (the procedure depends on your OS). * **On Windows**, ``` R_HOME = C:\\Program Files\\R\\R-4.2.0\\ R_PATH = C:\\Program Files\\R\\R-4.2.0\\bin\\x64 ``` * **On Linux**, by default it should be `/usr/lib/R`, you can thus just append the line `R_HOME=/usr/lib/R` to your `/etc/environment` file and reboot your computer * **On macOS**, you need to create (or update) the file `environment.plist` in the folder: `~/Library/LaunchAgents/` (for the current user, note that this folder is a hidden folder) or in `/Library/LaunchAgents/` (for all users) It should look like: &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt; &amp;lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;my.startup&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;sh&lt;/string&gt; &lt;string&gt;-c&lt;/string&gt; &lt;string&gt; launchctl setenv R_HOME /Library/Frameworks/R.framework/Resources/ &lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/plist&gt;  "},{"title":"Configuration in GAMA​","type":1,"pageTitle":"Calling R from GAMA models","url":"wiki/CallingR#configuration-in-gama","content":""},{"title":"Linking the R connector​","type":1,"pageTitle":"Calling R from GAMA models","url":"wiki/CallingR#linking-the-r-connector","content":"From GAMA 1.8.2, you need to specify the path to the R connector library in the GAMA launching arguments. To this purpose, you need to add to either: the GAMA.ini file if you use the release version of GAMA or the launching configuration (if you use the source code version) the following line: (replace PATH_TO_R by the path to R, i.e. the value in $R_HOME): on macOS: -Djava.library.path=PATH_TO_R/library/rJava/jri/rlibjri.jnilibon Windows: -Djava.library.path=PATH_TO_R/library/rJava/jri/on Linux: -Djava.library.path=PATH/TO/JRI As an example, under macOS, you need to add: -Djava.library.path=/Library/Frameworks/R.framework/Resources/library/rJava/jri/  On Windows and Linux, the jri library could be in a different location than the R_HOME, for example on Linux by default it would be in: -Djava.library.path=/home/user_name/R/x86_64-pc-linux-gnu-library/3.6/rJava/jri/  "},{"title":"Installing the R plugin​","type":1,"pageTitle":"Calling R from GAMA models","url":"wiki/CallingR#installing-the-r-plugin","content":"Next you need to install the R plugin from Gama. To do it, select &quot;Install new plugins...&quot; in the &quot;Help&quot; menu of Gama. In the Work with drop down select the repository ending with &quot;experimental/&quot; followed by your Gama version. Once done, you need to select the plugin rJava, click on next and then finish. After this, you could be asked to &quot;trust&quot; the plugin, simply select the first line and click on Trust selected Finally, you will be asked to restart Gama, click on Restart now. For more details, readers can refer to the page dedicated to the installation of additional plugins. "},{"title":"Calling R from GAML​","type":1,"pageTitle":"Calling R from GAMA models","url":"wiki/CallingR#calling-r-from-gaml","content":""},{"title":"Before computation​","type":1,"pageTitle":"Calling R from GAMA models","url":"wiki/CallingR#before-computation","content":"Any agent aiming at using R for some computation needs to be provided with the RSkill. Before calling any computation, this agent needs to start a connection with the R software. As an example, if we want that the global agent can use R, we need to have the following minimal model: global skills: [RSkill] { init { do startR; } }  "},{"title":"Computation​","type":1,"pageTitle":"Calling R from GAMA models","url":"wiki/CallingR#computation","content":"Evaluate an R expression​ The R_eval operator can be used to evaluate any R expression. It can also be used to initialize a variable or call any function. It can return any data type (depending on the R output). As in an R session, the various evaluations are dependent on the previous ones. Example: global skills: [RSkill] { init{ do startR; write R_eval(&quot;x&lt;-1&quot;); write R_eval(&quot;rnorm(50,0,5)&quot;); } }  Evaluate an R script​ To evaluate an R script, stored in a (text) file, open the file and execute each of its lines. global skills:[RSkill]{ file Rcode &lt;- text_file(&quot;../includes/rScript.txt&quot;); init{ do startR; // Loop that takes each line of the R script and execute it. loop s over: Rcode.contents{ unknown a &lt;- R_eval(s); write &quot;R&gt;&quot;+s; write a; } } }  Convert GAMA object to R object​ To use GAMA complex objects into R functions, we need to transform them using the to_R_data operator: it transforms any GAMA object into a R object. global skills:[RSkill] { init { do startR(); string s2 &lt;- &quot;s2&quot;; list&amp;lt;int&gt; numlist &lt;- [1,2,3,4]; write R_eval(&quot;numlist = &quot; + to_R_data(numlist)); } }  Convert a species to a dataframe​ Dataframe is a powerful R data type allowing to ease data manipulation... Dataframe wan of course be defined at hand using R commands. But GAML provides the to_R_dataframe operator to directly transform a species of agents into a dataframe for future analysis. global skills: [RSkill] { init{ do startR(); create people number: 10; do R_eval(&quot;df&lt;-&quot; + to_R_dataframe(people)); write R_eval(&quot;df&quot;); write R_eval(&quot;df$flipCoin&quot;); } } species people { bool flipCoin &lt;- flip(0.5); }  "},{"title":"Changing Workspace","type":0,"sectionRef":"#","url":"wiki/ChangingWorkspace","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Changing Workspace","url":"wiki/ChangingWorkspace#table-of-contents","content":"Changing Workspace Switching to another WorkspaceCloning the Current Workspace "},{"title":"Switching to another Workspace​","type":1,"pageTitle":"Changing Workspace","url":"wiki/ChangingWorkspace#switching-to-another-workspace","content":"This process is similar to the choice of the workspace location when GAMA is launched for the first time. The only preliminary step is to invoke the appropriate command (&quot;Switch Workspace&quot;) from the &quot;File&quot; menu.  In the dialog that appears, the current workspace location should already be entered. Changing it to a new location (or choosing one in the file selector invoked by clicking on &quot;Browse...&quot;) and pressing &quot;OK&quot; will then either create a new workspace if none existed at that location or switch to this new workspace. Both operations will restart GAMA and set the new workspace location. To come back to the previous location, just repeat this step (the previous location is normally now accessible from the combo box).  Notice that, when GAMA restarts and that you have not ticked &quot;Remember workspace&quot;, GAMA will ask you again the workspace (just as when you launch GAMA). "},{"title":"Cloning the Current Workspace​","type":1,"pageTitle":"Changing Workspace","url":"wiki/ChangingWorkspace#cloning-the-current-workspace","content":"Another possibility, if you have models in your current workspace that you would like to keep in the new one (and that you do not want to import one by one after switching workspace), or if you change workspace because you suspect the current one is corrupted, or outdated, etc. but you still want to keep your models, is to clone the current workspace into a new (or existing) one. Please note that cloning (as its name implies) is an operation that will make a copy of the files into a new workspace. So, if projects are stored in the current workspace, this will result in two different instances of the same projects/models with the same name in the two workspaces. However, for projects that are simply linked from the current workspace, only the link will be copied (which allows having different workspaces &quot;containing&quot; the same project) This can be done by entering the new workspace location and choosing &quot;Clone current workspace&quot; in the previous dialog instead of &quot;Ok&quot;.  If the new location does not exist, GAMA will ask you to confirm the creation and cloning using a specific dialog box. Dismissing it will cancel the operation.  If the new location is already the location of an existing workspace, another confirmation dialog is produced. It is important to note that all projects in the target workspace will be erased and replaced by the projects in the current workspace if you proceed. Dismissing it will cancel the operation.  There are two cases where cloning is not accepted. The first one is when the user tries to clone the current workspace into itself (i.e. the new location is the same as the current location).  The second case is when the user tries to clone the current workspace into one of its subdirectories (which is not feasible).  "},{"title":"Built-in Skills","type":0,"sectionRef":"#","url":"wiki/BuiltInSkills","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#introduction","content":"Skills are built-in modules, written in Java, that provide a set of related built-in variables and built-in actions (in addition to those already provided by GAMA) to the species that declare them. A declaration of skill is done by filling the skills attribute in the species definition: species my_species skills: [skill1, skill2] { ... }  Skills have been designed to be mutually compatible so that any combination of them will result in a functional species. An example of skill is the moving skill. So, for instance, if a species is declared as: species foo skills: [moving]{ ... }  Its agents will automatically be provided with the following variables : speed, heading, destination and the following actions: move, goto, wander, follow in addition to those built-in in species and declared by the modeller. Most of these variables, except the ones marked read-only, can be customized and modified like normal variables by the modeller. For instance, one could want to set a maximum for the speed; this would be done by redeclaring it like this: float speed max:100 min:0;  Or, to obtain a speed increasing at each simulation step: float speed max:100 min:0 &lt;- 1 update: speed * 1.01;  Or, to change the speed in a behavior: if speed = 5 { speed &lt;- 10; }   "},{"title":"Table of Contents​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#table-of-contents","content":"advanced_driving, driving, dynamic_body, fipa, messaging, moving, moving3D, network, public_transport, public_transport_scheduler, skill_road, skill_road_node, SQLSKILL, static_body,  "},{"title":"advanced_driving​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#advanced_driving","content":""},{"title":"Variables​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#variables","content":"acc_bias (float): the bias term used for asymmetric lane changing, parameter 'a_bias' in MOBIL acc_gain_threshold (float): the minimum acceleration gain for the vehicle to switch to another lane, introduced to prevent frantic lane changing. Known as the parameter 'a_th' in the MOBIL lane changing model acceleration (float): the current acceleration of the vehicle (in m/s^2) allowed_lanes (list): a list containing possible lane index values for the attribute lowest_lane current_index (int): the index of the current edge (road) in the path current_lane (int): the current lane on which the agent is current_path (path): the path which the agent is currently following current_road (agent): the road which the vehicle is currently on current_target (agent): the current target of the agent delta_idm (float): the exponent used in the computation of free-road acceleration in the Intelligent Driver Model distance_to_current_target (float): euclidean distance to the current target node distance_to_goal (float): euclidean distance to the endpoint of the current segment final_target (agent): the final target of the agent follower (agent): the vehicle following this vehicle ignore_oneway (boolean): if set to true, the vehicle will be able to violate one-way traffic rule lane_change_cooldown (float): the duration that a vehicle must wait before changing lanes again lane_change_limit (int): the maximum number of lanes that the vehicle can change during a simulation step leading_distance (float): the distance to the leading vehicle leading_speed (float): the speed of the leading vehicle leading_vehicle (agent): the vehicle which is right ahead of the current vehicle. If this is set to nil, the leading vehicle does not exist or might be very far away. linked_lane_limit (int): the maximum number of linked lanes that the vehicle can use; the default value is -1, i.e. the vehicle can use all available linked lanes lowest_lane (int): the lane with the smallest index that the vehicle is in max_acceleration (float): the maximum acceleration of the vehicle. Known as the parameter 'a' in the Intelligent Driver Model max_deceleration (float): the maximum deceleration of the vehicle. Known as the parameter 'b' in the Intelligent Driver Model max_safe_deceleration (float): the maximum deceleration that the vehicle is willing to induce on its back vehicle when changing lanes. Known as the parameter 'b_save' in the MOBIL lane changing model max_speed (float): the maximum speed that the vehicle can achieve. Known as the parameter 'v0' in the Intelligent Driver Model min_safety_distance (float): the minimum distance of the vehicle's front bumper to the leading vehicle's rear bumper, known as the parameter s0 in the Intelligent Driver Model min_security_distance (float): the minimal distance to another vehicle next_road (agent): the road which the vehicle will enter next num_lanes_occupied (int): the number of lanes that the vehicle occupies on_linked_road (boolean): is the agent on the linked road? politeness_factor (float): determines the politeness level of the vehicle when changing lanes. Known as the parameter 'p' in the MOBIL lane changing model proba_block_node (float): probability to block a node (do not let other vehicle cross the crossroad), within one second proba_lane_change_down (float): probability to change to a lower lane (right lane if right side driving) to gain acceleration, within one second proba_lane_change_up (float): probability to change to a upper lane (left lane if right side driving) to gain acceleration, within one second proba_respect_priorities (float): probability to respect priority (right or left) laws, within one second proba_respect_stops (list): probability to respect stop laws - one value for each type of stop, within one second proba_use_linked_road (float): probability to change to a linked lane to gain acceleration, within one second real_speed (float): the actual speed of the agent (in meter/second) right_side_driving (boolean): are vehicles driving on the right size of the road? safety_distance_coeff (float): the coefficient for the computation of the the min distance between two vehicles (according to the vehicle speed - security_distance =max(min_security_distance, security_distance_coeff * min(self.real_speed, other.real_speed) ) security_distance_coeff (float): the coefficient for the computation of the the min distance between two vehicles (according to the vehicle speed - safety_distance =max(min_safety_distance, safety_distance_coeff * min(self.real_speed, other.real_speed) ) segment_index_on_road (int): current segment index of the agent on the current road speed (float): the speed of the agent (in meter/second) speed_coeff (float): speed coefficient for the speed that the vehicle want to reach (according to the max speed of the road) targets (list): the current list of points that the agent has to reach (path) time_headway (float): the time gap that to the leading vehicle that the driver must maintain. Known as the parameter 'T' in the Intelligent Driver Model time_since_lane_change (float): the elapsed time since the last lane change using_linked_road (boolean): indicates if the vehicle is occupying at least one lane on the linked road vehicle_length (float): the length of the vehicle (in meters) violating_oneway (boolean): indicates if the vehicle is moving in the wrong direction on an one-way (unlinked) road  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#actions","content":"advanced_follow_driving​ moves the agent towards along the path passed in the arguments while considering the other agents in the network (only for graph topology) Returned type: float : the remaining time Additional facets:​ path (path): a path to be followed. target (point): the target to reach speed (float): the speed to use for this move (replaces the current value of speed) time (float): time to travel Examples:​ do osm_follow path: the_path on: road_network;  choose_lane​ Override this if you want to manually choose a lane when entering new road. By default, the vehicle tries to stay in the current lane. If the new road has fewer lanes than the current one and the current lane index is too big, it tries to enter the most uppermost lane. Returned type: int : an integer representing the lane index Additional facets:​ new_road (agent): the new road that's the vehicle is going to enter  compute_path​ Action to compute the shortest path to the target node, or shortest path based on the provided list of nodes Returned type: path : the computed path, or nil if no valid path is found Additional facets:​ graph (graph): the graph representing the road network target (agent): the target node to reach source (agent): the source node (optional, if not defined, closest node to the agent location) nodes (list): the nodes forming the resulting path Examples:​ do compute_path graph: road_network target: target_node; do compute_path graph: road_network nodes: [node1, node5, node10];  drive​ action to drive toward the target Returned type: bool Examples:​ do drive;  drive_random​ action to drive by chosen randomly the next road Returned type: bool Additional facets:​ graph (graph): a graph representing the road network proba_roads (map): a map containing for each road (key), the probability to be selected as next road (value) Examples:​ do drive_random init_node: some_node;  external_factor_impact​ action that allows to define how the remaining time is impacted by external factor Returned type: float : the remaining time Additional facets:​ new_road (agent): the road on which to the vehicle wants to go remaining_time (float): the remaining time Examples:​ do external_factor_impact new_road: a_road remaining_time: 0.5;  force_move​ action to drive by chosen randomly the next road Returned type: float Additional facets:​ lane (int): the lane on which to make the agent move acceleration (float): acceleration of the vehicle time (float): time of move Examples:​ do drive_random init_node: some_node;  lane_choice​ action to choose a lane Returned type: int : the chosen lane, return -1 if no lane can be taken Additional facets:​ new_road (agent): the road on which to choose the lane Examples:​ do lane_choice new_road: a_road;  on_entering_new_road​ override this if you want to do something when the vehicle enters a new road (e.g. adjust parameters) Returned type: void path_from_nodes​ action to compute a path from a list of nodes according to a given graph Returned type: path : the computed path, return nil if no path can be taken Additional facets:​ graph (graph): the graph representing the road network nodes (list): the list of nodes composing the path Examples:​ do compute_path_from_nodes graph: road_network nodes: [node1, node5, node10];  ready_to_cross​ action to test if the vehicle cross a road node to move to a new road Returned type: bool : true if the vehicle can cross the road node, false otherwise Additional facets:​ node (agent): the road node to test new_road (agent): the road to test Examples:​ do is_ready_next_road new_road: a_road lane: 0;  speed_choice​ action to choose a speed Returned type: float : the chosen speed Additional facets:​ new_road (agent): the road on which to choose the speed Examples:​ do speed_choice new_road: the_road;  test_next_road​ action to test if the vehicle can take the given road Returned type: bool : true (the vehicle can take the road) or false (the vehicle cannot take the road) Additional facets:​ new_road (agent): the road to test Examples:​ do test_next_road new_road: a_road;  unregister​ remove the vehicle from its current roads Returned type: bool Examples:​ do unregister   "},{"title":"driving​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#driving","content":""},{"title":"Variables​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#variables-1","content":"lanes_attribute (string): the name of the attribut of the road agent that determine the number of road lanes living_space (float): the min distance between the agent and an obstacle (in meter) obstacle_species (list): the list of species that are considered as obstacles speed (float): the speed of the agent (in meter/second) tolerance (float): the tolerance distance used for the computation (in meter)  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#actions-1","content":"follow_driving​ moves the agent along a given path passed in the arguments while considering the other agents in the network. Returned type: path : optional: the path followed by the agent. Additional facets:​ speed (float): the speed to use for this move (replaces the current value of speed) path (path): a path to be followed. return_path (boolean): if true, return the path followed (by default: false) move_weights (map): Weigths used for the moving. living_space (float): min distance between the agent and an obstacle (replaces the current value of living_space) tolerance (float): tolerance distance used for the computation (replaces the current value of tolerance) lanes_attribute (string): the name of the attribut of the road agent that determine the number of road lanes (replaces the current value of lanes_attribute) Examples:​ do follow speed: speed * 2 path: road_path;  goto_driving​ moves the agent towards the target passed in the arguments while considering the other agents in the network (only for graph topology) Returned type: path : optional: the path followed by the agent. Additional facets:​ target (geometry): the location or entity towards which to move. speed (float): the speed to use for this move (replaces the current value of speed) on (any type): list, agent, graph, geometry that restrains this move (the agent moves inside this geometry) return_path (boolean): if true, return the path followed (by default: false) move_weights (map): Weigths used for the moving. living_space (float): min distance between the agent and an obstacle (replaces the current value of living_space) tolerance (float): tolerance distance used for the computation (replaces the current value of tolerance) lanes_attribute (string): the name of the attribut of the road agent that determine the number of road lanes (replaces the current value of lanes_attribute) Examples:​ do gotoTraffic target: one_of (list (species (self))) speed: speed * 2 on: road_network living_space: 2.0;   "},{"title":"dynamic_body​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#dynamic_body","content":""},{"title":"Variables​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#variables-2","content":"angular_damping (float): Between 0 and 1. an angular decelaration coefficient that occurs even without contact angular_velocity (point): The angular velocity of the agent in the three directions, expressed as a point. contact_damping (float): Between 0 and 1. a decelaration coefficient that occurs in case of contact. Only available in the native Bullet library (no effect on the Java implementation) damping (float): Between 0 and 1. a linear decelaration coefficient that occurs even without contact velocity (point): The linear velocity of the agent in the three directions, expressed as a point.  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#actions-2","content":"apply​ An action that allows to apply different effects to the object, like forces, impulses, etc. Returned type: unknown Additional facets:​ clearance (boolean): If true clears all forces applied to the agent and clears its veolicity as well impulse (point): An idealised change of momentum. Adds to the velocity of the object. This is the kind of push that you would use on a pool billiard ball. force (point): Move (push) the object once with a certain moment, expressed as a point (vector). Adds to the existing forces. torque (point): Rotate (twist) the object once around its axes, expressed as a point (vector)  "},{"title":"fipa​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#fipa","content":"The fipa skill offers some primitives and built-in variables which enable agent to communicate with each other using the FIPA interaction protocol. "},{"title":"Variables​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#variables-3","content":"accept_proposals (list): A list of 'accept_proposal' performative messages in the agent's mailbox agrees (list): A list of 'agree' performative messages. cancels (list): A list of 'cancel' performative messages. cfps (list): A list of 'cfp' (call for proposal) performative messages. conversations (list): A list containing the current conversations of agent. Ended conversations are automatically removed from this list. failures (list): A list of 'failure' performative messages. informs (list): A list of 'inform' performative messages. proposes (list): A list of 'propose' performative messages . queries (list): A list of 'query' performative messages. refuses (list): A list of 'propose' performative messages. reject_proposals (list): A list of 'reject_proposal' performative messages. requests (list): A list of 'request' performative messages. requestWhens (list): A list of 'request-when' performative messages. subscribes (list): A list of 'subscribe' performative messages.  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#actions-3","content":"accept_proposal​ Replies a message with an 'accept_proposal' performative message. Returned type: unknown Additional facets:​ message (24): The message to be replied contents (list): The content of the replying message  agree​ Replies a message with an 'agree' performative message. Returned type: unknown Additional facets:​ message (24): The message to be replied contents (list): The content of the replying message  cancel​ Replies a message with a 'cancel' peformative message. Returned type: unknown Additional facets:​ message (24): The message to be replied contents (list): The content of the replying message  cfp​ Replies a message with a 'cfp' performative message. Returned type: unknown Additional facets:​ message (24): The message to be replied contents (list): The content of the replying message  end_conversation​ Reply a message with an 'end_conversation' peprformative message. This message marks the end of a conversation. In a 'no-protocol' conversation, it is the responsible of the modeler to explicitly send this message to mark the end of a conversation/interaction protocol. Please note that if the contents of the messages of the conversation are not read, then this command has no effect (i.e. it must be read by at least one of the agents in the conversation) Returned type: unknown Additional facets:​ message (24): The message to be replied contents (list): The content of the replying message  failure​ Replies a message with a 'failure' performative message. Returned type: unknown Additional facets:​ message (24): The message to be replied contents (list): The content of the replying message  inform​ Replies a message with an 'inform' performative message. Returned type: unknown Additional facets:​ message (24): The message to be replied contents (list): The content of the replying message  propose​ Replies a message with a 'propose' performative message. Returned type: unknown Additional facets:​ message (24): The message to be replied contents (list): The content of the replying message  query​ Replies a message with a 'query' performative message. Returned type: unknown Additional facets:​ message (24): The message to be replied contents (list): The content of the replying message  refuse​ Replies a message with a 'refuse' performative message. Returned type: unknown Additional facets:​ message (24): The message to be replied contents (list): The contents of the replying message  reject_proposal​ Replies a message with a 'reject_proposal' performative message. Returned type: unknown Additional facets:​ message (24): The message to be replied contents (list): The content of the replying message  reply​ Replies a message. This action should be only used to reply a message in a 'no-protocol' conversation and with a 'user defined performative'. For performatives supported by GAMA (i.e., standard FIPA performatives), please use the 'action' with the same name of 'performative'. For example, to reply a message with a 'request' performative message, the modeller should use the 'request' action. Returned type: unknown Additional facets:​ message (24): The message to be replied performative (string): The performative of the replying message contents (list): The content of the replying message  request​ Replies a message with a 'request' performative message. Returned type: unknown Additional facets:​ message (24): The message to be replied contents (list): The content of the replying message  send​ Starts a conversation/interaction protocol. Returned type: msi.gaml.extensions.fipa.FIPAMessage Additional facets:​ to (list): A list of receiver agents contents (list): The content of the message. A list of any GAML type performative (string): A string, representing the message performative protocol (string): A string representing the name of interaction protocol  start_conversation​ Starts a conversation/interaction protocol. Returned type: msi.gaml.extensions.fipa.FIPAMessage Additional facets:​ to (list): A list of receiver agents contents (list): The content of the message. A list of any GAML type performative (string): A string, representing the message performative protocol (string): A string representing the name of interaction protocol  subscribe​ Replies a message with a 'subscribe' performative message. Returned type: unknown Additional facets:​ message (24): The message to be replied contents (list): The content of the replying message  "},{"title":"messaging​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#messaging","content":"A simple skill that provides agents with a mailbox than can be filled with messages "},{"title":"Variables​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#variables-4","content":"mailbox (list): The list of messages that can be consulted by the agent  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#actions-4","content":"send​  Returned type: message Additional facets:​ to (any type): The agent, or server, to which this message will be sent to contents (any type): The contents of the message, an arbitrary object  "},{"title":"moving​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#moving","content":"The moving skill is intended to define the minimal set of behaviours required for agents that are able to move on different topologies "},{"title":"Variables​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#variables-5","content":"current_edge (geometry): Represents the agent/geometry on which the agent is located (only used with a graph) current_path (path): Represents the path on which the agent is moving on (goto action on a graph) destination (point): Represents the next location of the agent if it keeps its current speed and heading (read-only). Only correct in continuous topologies and may return nil values if the destination is outside the environment heading (float): Represents the absolute heading of the agent in degrees. location (point): Represents the current position of the agent real_speed (float): Represents the actual speed of the agent (in meter/second) speed (float): Represents the speed of the agent (in meter/second)  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#actions-5","content":"follow​ moves the agent along a given path passed in the arguments. Returned type: path : optional: the path followed by the agent. Additional facets:​ speed (float): the speed to use for this move (replaces the current value of speed) path (path): a path to be followed. move_weights (map): Weights used for the moving. return_path (boolean): if true, return the path followed (by default: false) Examples:​ do follow speed: speed * 2 path: road_path;  goto​ moves the agent towards the target passed in the arguments. Returned type: path : optional: the path followed by the agent. Additional facets:​ target (geometry): the location or entity towards which to move. speed (float): the speed to use for this move (replaces the current value of speed) on (any type): graph, topology, list of geometries or map of geometries that restrain this move recompute_path (boolean): if false, the path is not recompute even if the graph is modified (by default: true) return_path (boolean): if true, return the path followed (by default: false) move_weights (map): Weights used for the moving. Examples:​ do goto target: (one_of road).location speed: speed * 2 on: road_network;  move​ moves the agent forward, the distance being computed with respect to its speed and heading. The value of the corresponding variables are used unless arguments are passed. Returned type: path Additional facets:​ speed (float): the speed to use for this move (replaces the current value of speed) heading (float): the angle (in degree) of the target direction. bounds (geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry Examples:​ do move speed: speed - 10 heading: heading + rnd (30) bounds: agentA;  wander​ Moves the agent towards a random location at the maximum distance (with respect to its speed). The heading of the agent is chosen randomly if no amplitude is specified. This action changes the value of heading. Returned type: bool Additional facets:​ speed (float): the speed to use for this move (replaces the current value of speed) amplitude (float): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2) bounds (geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry) on (graph): the graph that restrains this move (the agent moves on the graph proba_edges (map): When the agent moves on a graph, the probability to choose another edge. If not defined, each edge has the same probability to be chosen Examples:​ do wander speed: speed - 10 amplitude: 120 bounds: agentA;   "},{"title":"moving3D​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#moving3d","content":"The moving skill 3D is intended to define the minimal set of behaviours required for agents that are able to move on different topologies "},{"title":"Variables​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#variables-6","content":"destination (point): continuously updated destination of the agent with respect to its speed and heading (read-only) heading (float): the absolute heading of the agent in degrees (in the range 0-359) pitch (float): the absolute pitch of the agent in degrees (in the range 0-359) roll (float): the absolute roll of the agent in degrees (in the range 0-359) speed (float): the speed of the agent (in meter/second)  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#actions-6","content":"move​ moves the agent forward, the distance being computed with respect to its speed and heading. The value of the corresponding variables are used unless arguments are passed. Returned type: path Additional facets:​ speed (float): the speed to use for this move (replaces the current value of speed) heading (int): int, optional, the direction to take for this move (replaces the current value of heading) pitch (int): int, optional, the direction to take for this move (replaces the current value of pitch) roll (int): int, optional, the direction to take for this move (replaces the current value of roll) bounds (geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry Examples:​ do move speed: speed - 10 heading: heading + rnd (30) bounds: agentA;   "},{"title":"network​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#network","content":"The network skill provides new features to let agents exchange message through network. "},{"title":"Variables​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#variables-7","content":"network_groups (list): The set of groups the agent belongs to network_name (string): Net ID of the agent network_server (list): The list of all the servers to which the agent is connected  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#actions-7","content":"connect​ Action used by a networking agent to connect to a server or as a server. Returned type: bool Additional facets:​ protocol (string): protocol type (MQTT (by default), TCP, UDP): the possible value ares 'udp_server', 'udp_emitter', 'tcp_server', 'tcp_client', otherwise the MQTT protocol is used. port (int): Port number raw (boolean): message type raw or rich with_name (string): ID of the agent (its name) for the simulation login (string): login for the connection to the server password (string): password associated to the login force_network_use (boolean): force the use of the network even interaction between local agents to (string): server URL (localhost or a server URL) size_packet (int): For UDP connection, it sets the maximum size of received packets (default = 1024bits). Examples:​  do connect with_name:&quot;any_name&quot;; do connect to:\\&quot;localhost\\&quot; port:9876 with_name:&quot;any_name&quot;; do connect to:\\&quot;localhost\\&quot; protocol:\\&quot;MQTT\\&quot; port:9876 with_name:&quot;any_name&quot;; do connect to:&quot;localhost&quot; protocol:&quot;udp_server&quot; port:9876 with_name:&quot;Server&quot;; do connect to:&quot;localhost&quot; protocol:&quot;udp_client&quot; port:9876 with_name:&quot;Client&quot;; do connect to:&quot;localhost&quot; protocol:&quot;udp_server&quot; port:9877 size_packet: 4096;  execute​  Returned type: string Additional facets:​ command (string): command to execute Examples:​   fetch_message​  Returned type: message has_more_message​  Returned type: bool join_group​ allow an agent to join a group of agents in order to broadcast messages to other membersor to receive messages sent by other members. Note that all members of the group called : &quot;ALL&quot;. Returned type: bool Additional facets:​ with_name (string): name of the group Examples:​ do join_group with_name:&quot;group name&quot;; do join_group with_name:&quot;group name&quot;;do send to:&quot;group name&quot; contents:&quot;I am new in this group&quot;;  leave_group​ leave a group of agents. The leaving agent will not receive any message from the group. Overwhise, it can send messages to the left group Returned type: bool Additional facets:​ with_name (string): name of the group the agent wants to leave Examples:​  do leave_group with_name:&quot;my_group&quot;;  simulate_step​ Simulate a step to test the skill. It must be used for Gama-platform test only Returned type: bool : nothing Examples:​ do simulate_step;   "},{"title":"public_transport​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#public_transport","content":""},{"title":"Variables​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#variables-8","content":"is_stopped (boolean): Is the transport waiting for passengers next_stop (agent): the next stop for the transport stops (list): The list of stops the bus have and will going through transport_line (string): The name of the bus line transport_state (string): ?  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#actions-8","content":"define_next_target​ set up next target Returned type: bool Examples:​ do define_next_target;  define_noria​ action to define a bus noria Returned type: bool Additional facets:​ pickup_point (agent): The pickup point where passengers are taken evacuation_point (agent): The evacuation exit return_point (agent): The bus re-entry on the graph waiting_time (int): waiting time at pickup point in second (can be ignored if transport is full) return_time (int): time before the re-entry on the graph in second Examples:​ do define_noria pickup_point: bus_pickup evacuation_point: exit_point return_point: exit_point waiting_time: 300 return_time: 600;  define_route​ action to define the route of a bus Returned type: bool Additional facets:​ stops (list): The stops' list to go by schedule (list): The times' list for each stop Examples:​ do define_route stops: bus_stops schedule: bus_schedule;  init_departure​ initialise the vehicle Returned type: bool Examples:​ do init_departure;  is_time_to_go​ test the departure time Returned type: bool : returns true if it's time to go, false otherwise Examples:​ if(is_time_to_go())...   "},{"title":"public_transport_scheduler​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#public_transport_scheduler","content":""},{"title":"Variables​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#variables-9","content":"next_departure (int): ? next_departure_cycle (int): ? schedule (matrix): ? start_time_hour (int): The name of the bus line start_time_minute (int): The name of the bus line start_time_second (int): The name of the bus line stops (list): ? transport_line (string): The name of the bus line  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#actions-9","content":"check_departure​ action to check if a transport must depart Returned type: list&amp;lt;int&gt; Examples:​ do check_departure;  check_next_departure​ action to check next departure time Returned type: bool Examples:​ do check_next_departure;  define_schedule​ action to define the schedule of a bus_line Returned type: bool Additional facets:​ schedule (matrix): The stop(x)/time(y) matrix[x,y] Examples:​ do define_schedule schedule: busline_schedule;   "},{"title":"skill_road​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#skill_road","content":""},{"title":"Variables​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#variables-10","content":"agents_on (list): for each lane of the road, the list of agents for each segment all_agents (list): the list of agents on the road linked_road (-199): the linked road: the lanes of this linked road will be usable by drivers on the road maxspeed (float): the maximal speed on the road num_lanes (int): the number of lanes num_segments (int): the number of road segments segment_lengths (list): stores the length of each road segment. The index of each element corresponds to the segment index. source_node (agent): the source node of the road target_node (agent): the target node of the road vehicle_ordering (list): provides information about the ordering of vehicle on any given lane  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#actions-10","content":"register​ register the agent on the road at the given lane Returned type: bool Additional facets:​ agent (agent): the agent to register on the road. lane (int): the lane index on which to register; if lane index &gt;= number of lanes, then register on the linked road Examples:​ do register agent: the_driver lane: 0  unregister​ unregister the agent on the road Returned type: bool Additional facets:​ agent (agent): the agent to unregister on the road. Examples:​ do unregister agent: the_driver   "},{"title":"skill_road_node​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#skill_road_node","content":""},{"title":"Variables​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#variables-11","content":"block (map): define the list of agents blocking the node, and for each agent, the list of concerned roads priority_roads (list): the list of priority roads roads_in (list): the list of input roads roads_out (list): the list of output roads stop (list): define for each type of stop, the list of concerned roads  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#actions-11","content":" "},{"title":"SQLSKILL​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#sqlskill","content":"This skill allows agents to be provided with actions and attributes in order to connect to SQL databases "},{"title":"Variables​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#variables-12","content":""},{"title":"Actions​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#actions-12","content":"executeUpdate​  Returned type: int Additional facets:​ params (map): Connection parameters updateComm (string): SQL commands such as Create, Update, Delete, Drop with question mark values (list): List of values that are used to replace question mark  getCurrentDateTime​  Returned type: string Additional facets:​ dateFormat (string): date format examples: 'yyyy-MM-dd' , 'yyyy-MM-dd HH:mm:ss'  getDateOffset​  Returned type: string Additional facets:​ dateFormat (string): date format examples: 'yyyy-MM-dd' , 'yyyy-MM-dd HH:mm:ss' dateStr (string): Start date offset (string): number on day to increase or decrease  insert​  Returned type: int Additional facets:​ params (map): Connection parameters into (string): Table name columns (list): List of column name of table values (list): List of values that are used to insert into table. Columns and values must have same size  list2Matrix​  Returned type: matrix Additional facets:​ param (list): Param: a list of records and metadata getName (boolean): getType: a boolean value, optional parameter getType (boolean): getType: a boolean value, optional parameter  select​  Returned type: list Additional facets:​ params (map): Connection parameters select (string): select string with question marks values (list): List of values that are used to replace question marks  testConnection​  Returned type: bool Additional facets:​ params (map): Connection parameters  timeStamp​  Returned type: float  "},{"title":"static_body​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#static_body","content":""},{"title":"Variables​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#variables-13","content":"aabb (geometry): The axis-aligned bounding box. A box used to evaluate the probability of contacts between objects. Can be displayed as any other GAMA shapes/geometries in order to verify that the physical representation of the agent corresponds to its geometry in the model friction (float): Between 0 and 1. The coefficient of friction of the agent (how much it decelerates the agents in contact with him). Default is 0.5 mass (float): The mass of the agent. Should be equal to 0.0 for static, motionless agents restitution (float): Between 0 and 1. The coefficient of restitution of the agent (defines the 'bounciness' of the agent). Default is 0 rotation (pair): The rotation of the physical body, expressed as a pair which key is the angle in degrees and value the axis around which it is measured  "},{"title":"Actions​","type":1,"pageTitle":"Built-in Skills","url":"wiki/BuiltInSkills#actions-13","content":"contact_added_with​ This action can be redefined in order for the agent to implement a specific behavior when it comes into contact (collision) with another agent. It is automatically called by the physics simulation engine on both colliding agents. The default built-in behavior does nothing. Returned type: unknown Additional facets:​ other (agent): represents the other agent with which a collision has been detected  contact_removed_with​ This action can be redefined in order for the agent to implement a specific behavior when a previous contact with another agent is removed. It is automatically called by the physics simulation engine on both colliding agents. The default built-in behavior does nothing. Returned type: unknown Additional facets:​ other (agent): represents the other agent with which a collision has been detected  update_body​ This action must be called when the geometry of the agent changes in the simulation world and this change must be propagated to the physical world. The change of location (in either worlds) or the rotation due to physical forces do not count as changes, as they are already taken into account. However, a rotation in the simulation world need to be handled by calling this action. As it involves long operations (removing the agent from the physical world, then reinserting it with its new shape), this action should not be called too often. Returned type: unknown "},{"title":"Using Comodel","type":0,"sectionRef":"#","url":"wiki/Comodel","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Using Comodel","url":"wiki/Comodel#introduction","content":"In the trend of developing a complex system of multi-disciplinary, composing and coupling models are days by days becoming the most attractive research objectives. GAMA is supporting the co-modeling and co-simulation which are supposed to be a common coupling infrastructure. "},{"title":"Example of a Comodel​","type":1,"pageTitle":"Using Comodel","url":"wiki/Comodel#example-of-a-comodel","content":"A Comodel is a model, especially an agent-based model, composed of several sub-models, called micro-models. A comodel itself could be also a micro-model of another comodel. From the point of view of a micro-model, the comodel is called a macro-model. A micro-model must be imported, instantiated, and life-controlled by a macro-model.  "},{"title":"Why and when can we use Comodel?​","type":1,"pageTitle":"Using Comodel","url":"wiki/Comodel#why-and-when-can-we-use-comodel","content":"Co-models ca definitely be very useful when the whole model can be decomposed in several sub-models, each of them representing, in general, a dynamics of the whole model, and that interact through some entities of the model. In particular, it allows several modelers to develop the part of the model dedicated to their expertise field, to test it extensively, before integrating it inside the whole model (where integration tests should not be omitted!). "},{"title":"Use of Comodel in a GAML model​","type":1,"pageTitle":"Using Comodel","url":"wiki/Comodel#use-of-comodel-in-a-gaml-model","content":"The GAML language has evolved by extending the import section. The old importation told the compiler to merge all imported elements into as one model, but the new one allows modelers to keep the elements coming from imported models separately from the caller model. "},{"title":"Definition of a micro-model​","type":1,"pageTitle":"Using Comodel","url":"wiki/Comodel#definition-of-a-micro-model","content":"Defining a micro-model of comodel is to import an existing model with an alias name. The syntax is: import &amp;lt;path to the GAML model&gt; as &amp;lt;identifier&gt;  The identifier is then become the new name of the micro-model. As an example taken from the model library, we can write: import &quot;Prey Predator Adapter.gaml&quot; as Organism  "},{"title":"Instantiation of a micro-model​","type":1,"pageTitle":"Using Comodel","url":"wiki/Comodel#instantiation-of-a-micro-model","content":"After the importation and giving an identifier, micro-model must be explicitly instantiated. It could be done by the create statement. create &amp;lt;micro-model identifier&gt; . &amp;lt;experiment name&gt; [optional parameter];  The &amp;lt;exeperiment name&gt; is an experiment inside micro-model. This syntax will generate some experiment agents and attach an implicit simulation. Note: The creation of several instances is not multi-simulation, but multi-experiment. Modelers could create an experiment with multi-simulation by explicitly do the init inside the experiment scope. As an example taken from the model library, we can write: global { init { //instantiate three instant of micro-model PreyPredator create Organism.Simple number: 3 with: [shape::square(100), preyinit::10, predatorinit::1] ; } }  "},{"title":"Control micro-model life-cycle​","type":1,"pageTitle":"Using Comodel","url":"wiki/Comodel#control-micro-model-life-cycle","content":"A micro-model can be controlled as any normal agent by asking the corresponding identifier, and also be destroyed by the do die; statement. And it can be recreated any time we need. ask (&amp;lt;micro-model identifier&gt; . &amp;lt;experiment name&gt; at &amp;lt;number&gt; ) . simulation { ... }  More generally, to schedule all the created simulations, we can do: reflex simulate_micro_models { // ask all simulation do their job ask (Organism.Simple collect each.simulation) { do _step_; } }  "},{"title":"Visualization of the micro-model​","type":1,"pageTitle":"Using Comodel","url":"wiki/Comodel#visualization-of-the-micro-model","content":"The micro-model species could display in comodel with the support of agent layer agents &quot;name of layer&quot; value: (&amp;lt;micro-model&gt; . &amp;lt;experiment name&gt; at &amp;lt;number&gt;).&amp;lt;get List of agents&gt;;  As an example: display &quot;Comodel display&quot; { agents &quot;agentprey&quot; value: (Organism.Simple accumulate each.get_prey()); agents &quot;agentpredator&quot; value: (Organism.Simple accumulate each.get_predator()); }  "},{"title":"More details​","type":1,"pageTitle":"Using Comodel","url":"wiki/Comodel#more-details","content":""},{"title":"Example of the comodel​","type":1,"pageTitle":"Using Comodel","url":"wiki/Comodel#example-of-the-comodel","content":"The following illustrations are taken from the model library provided with the GAMA platform. "},{"title":"Urbanization model with a Traffic model​","type":1,"pageTitle":"Using Comodel","url":"wiki/Comodel#urbanization-model-with-a-traffic-model","content":" "},{"title":"Flood model with Evacuation model​","type":1,"pageTitle":"Using Comodel","url":"wiki/Comodel#flood-model-with-evacuation-model","content":"The aim of this model is to couple the two existing models: Flood Simulation and Evacuation. Toy Models/Evacuation/models/continuous_move.gaml  Toy Models/Flood Simulation/models/Hydrological Model.gaml  The comodel explores the effect of a flood on an evacuation plan:  Simulation results:  "},{"title":"Contribute","type":0,"sectionRef":"#","url":"wiki/Contribute","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Contribute","url":"wiki/Contribute#table-of-contents","content":"Developer documentationSharing modelsSource codeGAMA Developer mailing listCiting GAMA "},{"title":"Developer documentation​","type":1,"pageTitle":"Contribute","url":"wiki/Contribute#developer-documentation","content":"You saw an error on the website and you want to correct it. The first thing is to check which page should be updated ! "},{"title":"Editing wiki​","type":1,"pageTitle":"Contribute","url":"wiki/Contribute#editing-wiki","content":"Let's start by taking a look at the URL. For example : https://gama-platform.org/wiki/Home ^^^^  If in the URL you have the keyword wiki, you should modify the GAMA wiki and the correction will appear in the website after the next build done by Travis CI. To keep the same example, the file to edit will be here : https://gama-platform.org/wiki/Home ^^^^ ^^^^ =FILE-TO-EDIT=&gt; https://github.com/gama-platform/gama/wiki/Home ^^^^ ^^^^  "},{"title":"Sharing models​","type":1,"pageTitle":"Contribute","url":"wiki/Contribute#sharing-models","content":"You can find models shared by the community in the experimental repository. From there you can just download the zip file of the repository, decompress it and import the models you want to try. If you want to share your model to the community you can simply click on the add file button on the main page and upload the directory containing your gama project. "},{"title":"Source Code​","type":1,"pageTitle":"Contribute","url":"wiki/Contribute#source-code","content":"GAMA can be downloaded as a regular application or built from source, which is necessary, if you want to contribute to the platform. The source code is available from this GitHub repository: https://github.com/gama-platform/gama  Which you can also browse from the web here. It is, in any case, recommended to follow the instructions on this page in order to build GAMA from source. "},{"title":"GAMA Dev mailing list​","type":1,"pageTitle":"Contribute","url":"wiki/Contribute#gama-dev-mailing-list","content":"If you want to contribute to the platform, you can send a request to the developping team to be in the gama-dev@googlegroups.com mailing list. "},{"title":"Product your own release of GAMA","type":0,"sectionRef":"#","url":"wiki/CreatingAReleaseOfGama","content":"","keywords":""},{"title":"Install Maven if not already installed​","type":1,"pageTitle":"Product your own release of GAMA","url":"wiki/CreatingAReleaseOfGama#install-maven-if-not-already-installed","content":"Download the latest version of Maven here: &lt;https://maven.apache.org/download.cgi&gt;. Proceed to install it as explained on this page: &lt;https://maven.apache.org/install.html&gt; "},{"title":"Locate the build.sh shell script​","type":1,"pageTitle":"Product your own release of GAMA","url":"wiki/CreatingAReleaseOfGama#locate-the-buildsh-shell-script","content":"It is located at the root of the gama Git repository on your computer. The easiest way to proceed is to select one of the GAMA projects in the Eclipse explorer and choose, in the contextual menu, Show in &gt; System Explorer. Then open a shell with this path and cd ... Alternatively, you can open a shell and cd to your Git repository and then inside gama. "},{"title":"Launch the script​","type":1,"pageTitle":"Product your own release of GAMA","url":"wiki/CreatingAReleaseOfGama#launch-the-script","content":"Simply type ../build.sh in your terminal and the build should begin and log its activity. "},{"title":"Locate the applications built by the script​","type":1,"pageTitle":"Product your own release of GAMA","url":"wiki/CreatingAReleaseOfGama#locate-the-applications-built-by-the-script","content":"They are in ummisco.gama.product/target/products/ummisco.gama.application.product in their binary form or alternatively in ummisco.gama.product/target/products in their zipped form. "},{"title":"Instruction for Travis build (Continuous Integration)​","type":1,"pageTitle":"Product your own release of GAMA","url":"wiki/CreatingAReleaseOfGama#instruction-for-travis-build-continuous-integration","content":"GAMA is built by Travis-ci.org. There are some triggers for developers to control travis: &quot;ci skip&quot;: skip the build for a commit&quot;ci deploy&quot;: deploy the artifacts/features to p2 server (currently to the ovh server of gama, www.gama-platform.org/updates)&quot;ci clean&quot;: used with ci deploy, this trigger remove all old artifacts/features in server's p2 repository&quot;ci docs&quot;: tell travis to regenerate the documentation of operators on wiki page, and update the website githubio&quot;ci release&quot;: travis release zip package for OSs and place it on https://github.com/gama-platform/gama/releases/tag/latest&quot;ci ext&quot;: The msi.gama.ext has big size, so it is not rebuilt every time, it will be compiled automatically only when it was changed, Or use this command to force travis to deploy msi.gama.ext&quot;ci fullbuild&quot;: Full deploy all features/plugins These instructions above can be used in 2 ways: Place them anywhere in the commit message, i.e: &quot; fix bug #1111 ci deploy ci clean ci docs&quot;, &quot; update readme ci skip &quot;In Travis-ci, go to More Options -&gt; Settings, add an environment variable named MSG, add the value as string, i.e.: &quot;ci fullbuild ci deploy ci clean ci docs&quot; "},{"title":"Control Architectures","type":0,"sectionRef":"#","url":"wiki/ControlArchitecture","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"Control Architectures","url":"wiki/ControlArchitecture#index","content":"Finite State Machine Declarationstate statement Task Based Declarationtask User Control Architecture user_only, user_first, user_lastAdditional attributeuser_panel Other Control Architectures "},{"title":"Finite State Machine​","type":1,"pageTitle":"Control Architectures","url":"wiki/ControlArchitecture#finite-state-machine","content":"FSM (Finite State Machine) is a finite state machine-based behavior model. During its life cycle, the agent can be in several states. At any given time step, it is in one single state. Such an agent needs to have one initial state (the state in which it will be at its initialization). At each time step, the agent will: first (only if he just entered in its current state) execute statement embedded in the enter statement,then all the statements in the state statement,it will evaluate the condition of each embedded transition statements. If one condition is fulfilled, the agent executes the embedded statements. Note that an agent executes only one state at each step. "},{"title":"Declaration​","type":1,"pageTitle":"Control Architectures","url":"wiki/ControlArchitecture#declaration","content":"Using the FSM architecture for a species require to use the control facet: species dummy control: fsm { ... }  "},{"title":"state statement​","type":1,"pageTitle":"Control Architectures","url":"wiki/ControlArchitecture#state-statement","content":"Facets​ initial: a boolean expression, indicates the initial state of the agent (only one state with initial set to true is allowed in a species).final: a boolean expression, indicates the final state of the agent. Sub Statements​ enter: a sequence of statements to execute upon entering the state.exit: a sequence of statements to execute right before exiting the state. Note that the exit statement will be executed even if the fired transition points to the same state (the FSM architecture in GAMA does not implement 'internal transitions' like the ones found in UML statecharts: all transitions, even &quot;self-transitions&quot;, follow the same rules).transition: allows to define a condition that, when evaluated to true, will designate the next state of the life-cycle. Note that the evaluation of transitions is short-circuited: the first one that evaluates to true, in the order in which they have been defined, will be followed. I.e., if two transitions evaluate to true during the same time step, only the first one will be triggered. Things worth to be mentioned regarding these sub-statements: Obviously, only one definition of exit and enter is accepted in a given state.transition statements written in the middle of the state statements will only be evaluated at the end, so, even if it evaluates to true, the remaining of the statements found after the definition of the transition will be nevertheless executed. So, despite the appearance, a transition written somewhere in the sequence will &quot;not stop&quot; the state at that point (but only at the end). Definition​ A state can contain several statements that will be executed, at each time step, by the agent. There are three exceptions to this rule: statements enclosed in enter will only be executed when the state is entered (after a transition, or because it is the initial state).Those enclosed in exit will be executed when leaving the state as a result of a successful transition (and before the statements enclosed in the transition).Those enclosed in a transition will be executed when performing this transition (but after the exit sequence has been executed). For example, consider the following example: species dummy control: fsm { state state1 initial: true { write string(cycle) + &quot;:&quot; + name + &quot;-&gt;&quot; + &quot;state1&quot;; transition to: state2 when: flip(0.5) { write string(cycle) + &quot;:&quot; + name + &quot;-&gt;&quot; + &quot;transition to state1&quot;; } transition to: state3 when: flip(0.2) ; } state state2 { write string(cycle) + &quot;:&quot; + name + &quot;-&gt;&quot; + &quot;state2&quot;; transition to: state1 when: flip(0.5) { write string(cycle) + &quot;:&quot; + name + &quot;-&gt;&quot; + &quot;transition to state1&quot;; } exit { write string(cycle) + &quot;:&quot; + name + &quot;-&gt;&quot; + &quot;leave state2&quot;; } } state state3 { write string(cycle) + &quot;:&quot; + name + &quot;-&gt;&quot; + &quot;state3&quot;; transition to: state1 when: flip(0.5) { write string(cycle) + &quot;:&quot; + name + &quot;-&gt;&quot; + &quot;transition to state1&quot;; } transition to: state2 when: flip(0.2) ; } }  The dummy agents start at state1. At each simulation step, they have a probability of 0.5 to change their state to state2. If they do not change their state to state2, they have a probability of 0.2 to change their state to state3. In state2, at each simulation step, they have a probability of 0.5 to change their state to state1. At last, in step3, at each simulation step, they have a probability of 0.5 to change their state to state1. If they do not change their state to state1, they have a probability of 0.2 to change their state to state2. Here a possible result that can be obtained with one dummy agent: 0:dummy0-&gt;state1 0:dummy0-&gt;transition to state1 1:dummy0-&gt;state2 2:dummy0-&gt;state2 2:dummy0-&gt;leave state2 2:dummy0-&gt;transition to state1 3:dummy0-&gt;state1 3:dummy0-&gt;transition to state1 4:dummy0-&gt;state2 5:dummy0-&gt;state2 5:dummy0-&gt;leave state2 5:dummy0-&gt;transition to state1 6:dummy0-&gt;state1 7:dummy0-&gt;state3 8:dummy0-&gt;state2  "},{"title":"Task-Based​","type":1,"pageTitle":"Control Architectures","url":"wiki/ControlArchitecture#task-based","content":"GAMA integrated several task-based control architectures. Species can define any number of tasks within their body. At any given time, only one or several tasks are executed according to the architecture chosen: weighted_tasks: in this architecture, only the task with the maximal weight is executed.sorted_tasks: in this architecture, the tasks are all executed in the order specified by their weights (biggest first)probabilistic_tasks: this architecture uses the weights as a support for making a weighted probabilistic choice among the different tasks. If all tasks have the same weight, one is randomly chosen each step. "},{"title":"Declaration​","type":1,"pageTitle":"Control Architectures","url":"wiki/ControlArchitecture#declaration-1","content":"Using one of the task architectures for a species requires to use the control facet: species dummy control: weighted_tasks { ... }  species dummy control: sorted_tasks { ... }  species dummy control: probabilistic_tasks { ... }  "},{"title":"task statement​","type":1,"pageTitle":"Control Architectures","url":"wiki/ControlArchitecture#task-statement","content":"Facets​ Besides a sequence of statements like reflex, a task contains the following additional facet: weight: Mandatory. The priority level of the task. Definition​ As reflex, a task is a sequence of statements that can be executed, at each time step, by the agent. If an agent owns several tasks, the scheduler chooses a task to execute based on its current priority weight value. For example, consider the following example: species dummy control: weighted_tasks { task task1 weight: cycle mod 3 { write string(cycle) + &quot;:&quot; + name + &quot;-&gt;&quot; + &quot;task1&quot;; } task task2 weight: 2 { write string(cycle) + &quot;:&quot; + name + &quot;-&gt;&quot; + &quot;task2&quot;; } }  As the weighted_tasks control architecture was chosen, at each simulation step, the dummy agents execute only the task with the highest behavior. Thus, when cycle modulo 3 is higher to 2, task1 is executed; when cycle modulo 3 is lower than 2, task2 is executed. In case when cycle modulo 3 is equal 2 (at cycle 2, 5, ...), the only the first task defined (here task1) is executed. Here the result obtained with one dummy agent: 0:dummy0-&gt;task2 1:dummy0-&gt;task2 2:dummy0-&gt;task1 3:dummy0-&gt;task2 4:dummy0-&gt;task2 5:dummy0-&gt;task1 6:dummy0-&gt;task2  "},{"title":"Rules-based architecture​","type":1,"pageTitle":"Control Architectures","url":"wiki/ControlArchitecture#rules-based-architecture","content":"The behavior of an agent with the rules-based architecture can contain reflex and rule statements. The reflex block will always be executed first. Then the rules are fired (executed) when their condition becomes true and in the order defined by their decreasing priorities. "},{"title":"Declaration​","type":1,"pageTitle":"Control Architectures","url":"wiki/ControlArchitecture#declaration-2","content":"Using the rules-based architectures for a species requires to use the control facet: species dummy control: rules { ... }  "},{"title":"rule statement​","type":1,"pageTitle":"Control Architectures","url":"wiki/ControlArchitecture#rule-statement","content":"facets​ when: (boolean), the condition that needs to be fulfilled to execute the rule.priority: (float), an optional priority for the rule, which is used to sort activable rules and run them in that order. Definition​ As reflex, a rule is a sequence of statements that can be executed, at each time step, by the agent. They are executed if and only if their condition expression (when facet) is fulfilled. Among all the rules that fulfill their condition, the tasks are executed in the decreasing order of their priority (priority facet). For example, consider the following example: species simple_rules_statements control: rules { int priority_of_a &lt;- 0 update: rnd(100); int priority_of_b &lt;- 0 update: rnd(100); reflex show_priorities { write &quot;Priority of rule a = &quot; + priority_of_a + &quot;, priority of rule b = &quot; + priority_of_b; } rule a when: priority_of_a &lt; 50 priority: priority_of_a { write &quot; Rule a fired with priority: &quot; + priority_of_a; } rule b when: priority_of_b &gt; 25 priority: priority_of_b { write &quot; Rule b fired with priority: &quot; + priority_of_b; } }  At each simulation step, first, the agents update the priority values associated with the rules. The reflex will first display these values. Then the conditions are evaluated and the rules that can be executed are executed in their priority order. Here a possible result: Priority of rule a = 38, priority of rule b = 32 Rule a fired with priority: 38 Rule b fired with priority: 32 Priority of rule a = 91, priority of rule b = 32 Rule b fired with priority: 32 Priority of rule a = 37, priority of rule b = 2 Rule a fired with priority: 37 Priority of rule a = 77, priority of rule b = 90 Rule b fired with priority: 90 Priority of rule a = 32, priority of rule b = 23 Rule a fired with priority: 32 Priority of rule a = 18, priority of rule b = 7 Rule a fired with priority: 18 Priority of rule a = 95, priority of rule b = 94 Rule b fired with priority: 94 Priority of rule a = 20, priority of rule b = 5 Rule a fired with priority: 20 Priority of rule a = 78, priority of rule b = 47 Rule b fired with priority: 47 Priority of rule a = 77, priority of rule b = 76 Rule b fired with priority: 76  "},{"title":"User Control Architecture​","type":1,"pageTitle":"Control Architectures","url":"wiki/ControlArchitecture#user-control-architecture","content":""},{"title":"user_only, user_first, user_last​","type":1,"pageTitle":"Control Architectures","url":"wiki/ControlArchitecture#user_only-user_first-user_last","content":"A specific type of control architecture has been introduced to allow users to take control of an agent during the course of the simulation. When the user gets control of the agent, a control panel will appear in the interface. This architecture can be invoked using three different keywords: user_only, user_first, user_last. species user control: user_only { ... }  If the control chosen is user_first, it means that the user-controlled panel is opened first, and then the agent has a chance to run its &quot;own&quot; behaviors (reflexes, essentially, or &quot;init&quot; in the case of a &quot;user_init&quot; panel). If the control chosen is user_last, it is the contrary. "},{"title":"Additional attribute​","type":1,"pageTitle":"Control Architectures","url":"wiki/ControlArchitecture#additional-attribute","content":"Each agent provided with this architecture inherits a boolean attribute called user_controlled. If this attribute becomes false, no panels will be displayed and the agent will run &quot;normally&quot; unless its species is defined with a user_only control. "},{"title":"user_panel​","type":1,"pageTitle":"Control Architectures","url":"wiki/ControlArchitecture#user_panel","content":"This control architecture is a specialization of the Finite State Machine Architecture where the &quot;behaviors&quot; of agents can be defined by using new constructs called user_panel (and one user_init), mixed with state or reflex. This user_panel translates, in the interface, in a semi-modal view that awaits the user to choose action buttons, change attributes of the controlled agent, etc. Each user_panel, like a state in FSM, can have an enter and exit sections, but it is only defined in terms of a set of user_commands which describe the different action buttons present in the panel. user_command can also accept inputs, in order to create more interesting commands for the user. This uses the user_input statement (and not operator), which is basically the same as a temporary variable declaration whose value is asked to the user. As user_panel is a specialization of state, the modeler has the possibility to describe several panels and choose the one to open depending on some condition, using the same syntax than for finite state machines: either adding transitions to the user_panels,or setting the state attribute to a new value, from inside or from another agent. This ensures great flexibility for the design of the user interface proposed to the user, as it can be adapted to the different stages of the simulation, etc... Follows a simple example, where, every 10 steps, and depending on the value of an attribute called &quot;advanced&quot;, either the basic or the advanced panel is proposed. (The full model is provided in the GAMA model library.) species user control:user_only { user_panel default initial: true { transition to: &quot;Basic Control&quot; when: every (10 #cycles) and !advanced_user_control; transition to: &quot;Advanced Control&quot; when: every(10 #cycles) and advanced_user_control; } user_panel &quot;Basic Control&quot; { user_command &quot;Kill one cell&quot; { ask (one_of(cell)){ do die; } } user_command &quot;Create one cell&quot; { create cell ; } transition to: default when: true; } user_panel &quot;Advanced Control&quot; { user_command &quot;Kill cells&quot; { user_input &quot;Number&quot; returns: number type: int &lt;- 10; ask (number among cell){ do die; } } user_command &quot;Create cells&quot; { user_input &quot;Number&quot; returns: number type: int &lt;- 10; create cell number: number ; } transition to: default when: true; } }  The panel marked with the initial: true facet will be the one run first when the agent is supposed to run. If none is marked, the first panel (in their definition order) is chosen. A special panel called user_init will be invoked only once when initializing the agent if it is defined. If no panel is described or if all panels are empty (i.e. no user_command), the control view is never invoked. If the control is said to be user_only, the agent will then not run any of its behaviors. "},{"title":"Other Control Architectures​","type":1,"pageTitle":"Control Architectures","url":"wiki/ControlArchitecture#other-control-architectures","content":"Some other control architectures are available in additional plugins. For instance, BDI (Belief, desire, intention) architecture is available. Feel free to read about it if you want to learn more. Do you need some other control architectures for your model? Feel free to make your suggestion to the team of developers through the mailing list. Remember also that GAMA is an open-source platform, you can design your own control architecture easily. Go to the section Community/contribute if you want to jump into coding! "},{"title":"Defining 3D Displays","type":0,"sectionRef":"#","url":"wiki/Defining3DDisplays","content":"","keywords":""},{"title":"OpenGL display​","type":1,"pageTitle":"Defining 3D Displays","url":"wiki/Defining3DDisplays#opengl-display","content":"The use an OpenGL display, we have to define the attribute type of the display with type:opengl in the chosen display of your model (or use the preferences-&gt;display windows to use it by default): output { display DisplayName type: opengl { species mySpecies; } }  The OpenGL display shares most of the features that the java2D offers and that are described here. Using 3D display offers much more options to draw and show a simulation. A layer can be positioned and scaled in a 3D world. It is possible to superpose layers on different z value and display different information on the model at different positions on the screen. Most of the features offers by GAMA in 3D can be found as model example in the model library in the Visualization and User Interaction/3D Visualization Such as: 3D Model: Creating a simple model with building in 3D from a GIS file extruded in Building Elevation.gaml   Built-in 3D shapes supported by GAMA are described in Built-In Shapes.gaml  Features related to camera and the way to manipulate it are found in Camera Definitions.gaml  Different point of view can be described on the same simulation and shared by different displays in Camera Shared Zoom.experiment   Any GIS file can be visualized in 3D and a texture can be applied to the 3D shape in GIS Visualization.gaml  GAMA is handling different kind of lighting such as spot lights and point lights as illustrated in Lighting.gaml  Moving 3D object.gaml which shows how to draw a moving objet as a OBJ File and how to apply a 3D rotation on it   Specular light can also be defined as illustrated in Specular effects.gaml  "},{"title":"Types","type":0,"sectionRef":"#","url":"wiki/DataTypes","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#table-of-contents","content":"Types (Under Construction) Primitive built-in types boolfloatintstring Complex built-in types agentcontainerconversationfieldfilegeometrygraphlistmapmatrixmessage pairpathpointrgbspeciesSpecies names as typestopology Defining custom types "},{"title":"Primitive built-in types​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#primitive-built-in-types","content":""},{"title":"bool​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#bool","content":"Definition: primitive datatype providing two values: true or false.Litteral declaration: both true or false are interpreted as boolean constants.Other declarations: expressions that require a boolean operand often directly apply a casting to bool to their operand. It is a convenient way to directly obtain a bool value. bool (0) -&gt; false  Top of the page "},{"title":"float​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#float","content":"Definition: primitive datatype holding floating point values, its absolute value is comprised between 4.9E-324 and 1.8E308.Comments: this datatype is internally backed up by the Java double datatype.Litteral declaration: decimal notation 123.45 or exponential notation 123e45 are supported.Other declarations: expressions that require an integer operand often directly apply a casting to float to their operand. Using it is a way to obtain a float constant. float (12) -&gt; 12.0  Top of the page "},{"title":"int​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#int","content":"Definition: primitive datatype holding integer values comprised between -2147483648 and 2147483647 (i.e. between -2^31 and 2^31 - 1.Comments: this datatype is internally backed up by the Java int datatype.Litteral declaration: decimal notation like 1, 256790 or hexadecimal notation like #1209FF are automatically interpreted.Other declarations: expressions that require an integer operand often directly apply a casting to int to their operand. Using it is a way to obtain an integer constant. int (234.5) -&gt; 234.  Top of the page "},{"title":"string​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#string","content":"Definition: a datatype holding a sequence of characters.Comments: this datatype is internally backed up by the Java String class. However, contrary to Java, strings are considered as a primitive type, which means they do not contain character objects. This can be seen when casting a string to a list using the list operator: the result is a list of one-character strings, not a list of characters.Litteral declaration: a sequence of characters enclosed in quotes, like 'this is a string' . If one wants to literally declare strings that contain quotes, one has to double these quotes in the declaration. Strings accept escape characters like \\n (newline), \\r (carriage return), \\t (tabulation), as well as any Unicode character (\\uXXXX).Other declarations: see stringExample: see string operators. Top of the page "},{"title":"Complex built-in types​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#complex-built-in-types","content":"Contrarily to primitive built-in types, complex types have often various attributes. They can be accessed in the same way as attributes of agents: complex_type nom_var &lt;- init_var; ltype_attr attr_var &lt;- nom_var.attr_name;  For example: file fileText &lt;- file(&quot;../data/cell.Data&quot;); bool fileTextReadable &lt;- fileText.readable;  "},{"title":"agent​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#agent","content":"Definition: a generic datatype that represents an agent whatever its actual species.Built-in attributes: these attributes are common to any agent of the simulation location (type = point): the location of the agentshape (type = geometry): the shape of the agentname (type = string): name of the agent (not necessarily unique in its population)peers (type = list of agents of the same species): the population of agents of the same species, in the same host, minus the receiver agenthost (type = agent): the agent that hosts the population of the agent Comments: This datatype is barely used since species name can be directly used as datatypes themselves.Declaration: the agent casting operator can be applied to any unknown object to cast it as an agent. Top of the page "},{"title":"container​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#container","content":"Definition: a generic datatype that represents a collection of data.Comments: a container variable can be a list, a matrix, a map... Conversely, each list, matrix, and map is a kind of container. In consequence, every container can be used in container-related operators.See also: Container operatorsDeclaration: container c &lt;- [1,2,3]; container c &lt;- matrix [[1,2,3],[4,5,6]]; container c &lt;- map [&quot;x&quot;::5, &quot;y&quot;::12]; container c &lt;- list species1;  Top of the page "},{"title":"conversation​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#conversation","content":"Definition: a datatype that represents a conversation between agents in a FIPA-ACL interaction. It contains in particular all the exchanged messages.Built-in attributes: messages (type = list of messages): the list of messages that compose this conversationprotocol (type = string): the name of the protocol followed by the conversationinitiator (type = agent): the agent that has initiated this conversationparticipants (type = list of agents): the list of agents that participate to this conversationended (type = bool): whether this conversation has ended or not  Top of the page "},{"title":"field​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#field","content":"Definition: Fields are two-dimensional matrices holding float values. They can be easily created from arbitrary sources (grid, raster or DEM files, matrices grids) and of course by hand. The values they hold are accessible by agents like grids are, using their current location. They can be the target of the 'diffuse' statement and can be displayed using the 'mesh' layer definition. As such, they represent a lightweight alternative to grids, as they hold spatialized discrete values without having to build agents, which can be particularly interesting for models with large raster data. Several fields can of course be defined, and it makes sense to define them in the global section as, for the moment, they cover by default the whole environment, exactly like grids, and are created alongside them.Built-in attributes: a field is a kind of matrix, it thus inherits from the matrix's attributes. dimension (type = point): the dimension (columns x rows) of the receiver matrixcolumns (type = int): the number of columns of the receiver matrixrows (type = int): the number of rows of the receiver matrixcell_size (type = point): the dimension of an individual cell as a point (width, height). Setting it will only change the interpretation made by the field of the values it contains, but not the values themselves.bands (type = list of field): The list of bands that are optionally present in the field. The first band is the primary field itself, and each of these bands is a field w/o bandsno_data (type = float): the value that indicates the absence of data. Setting it will only change the interpretation made by the field of the values it contains, but not the values themselves. See also: Field operatorsDeclaration: a field can be created from a raster datafile (such as .asc of .tif files), a matrix or be specifying its dimensions. a field can be created from a raster datafile // Initialize a field from a asc simple raster file field field_from_asc &lt;- field(grid_file(&quot;includes/grid.asc&quot;)); // initialize using a tiff raster file field field_from_tiff &lt;- field(grid_file(&quot;includes/Lesponne.tif&quot;));  a field can be created manually: // Init from a user defined matrix field field_from_matrix &lt;- field(matrix([[1,2,3],[4,5,6],[7,8,9]])); // init an empty field of a given size field empty_field_from_size &lt;- field(10,10); // init a field for of a given value field full_field_from_size&lt;- field(10,10,1.0); // init a field of given size, with a given value and no data field full_field_from_size_with_nodata &lt;- field (1,1,1.0,0.0);  a field can be created from a grid of cells, the value stored will be the grid's grid_value attribute global { field field_from_grid &lt;- field(matrix(cell)); } grid cell width: 100 height: 100 { float grid_value &lt;- rnd(1.0,self distance_to world.location); }  "},{"title":"file​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#file","content":"Definition: a datatype that represents a file.Built-in attributes: name (type = string): the name of the represented file (with its extension)extension(type = string): the extension of the filepath (type = string): the absolute path of the file readable (type = bool, read-only): a flag expressing whether the file is readablewritable (type = bool, read-only): a flag expressing whether the file is writableexists (type = bool, read-only): a flag expressing whether the file existsis_folder (type = bool, read-only): a flag expressing whether the file is foldercontents (type = container): a container storing the content of the file Comments: a variable with the file type can handle any kind of file (text, image or shape files...). The type of the content attribute will depend on the kind of file. Note that the allowed kinds of file are the followings: text files: files with the extensions .txt, .data, .csv, .text, .tsv, .asc. The content is by default a list of string.image files: files with the extensions .pgm, .tif, .tiff, .jpg, .jpeg, .png, .gif, .pict, .bmp. The content is by default a matrix of int.shapefiles: files with the extension .shp. The content is by default a list of geometry.properties files: files with the extension .properties. The content is by default a map of string::string.folders. The content is by default a list of string. Remark: Files are also a particular kind of container and can thus be read, written or iterated using the container operators and commands.See also: File operatorsDeclaration: a file can be created using the generic file (that opens a file in read only mode and tries to determine its contents), folder or the new_folder (to open an existing folder or create a new one) unary operators. But things can be specialized with the combination of the read/write and image/text/shapefile/properties unary operators. folder(a_string) // returns a file managing a existing folder file(a_string) // returns any kind of file in read-only mode read(text(a_string)) // returns a text file in read-only mode read(image(a_string)) // does the same with an image file. write(properties(a_string)) // returns a property file which is available for writing // (if it exists, contents will be appended unless it is cleared // using the standard container operations).  Top of the page "},{"title":"geometry​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#geometry","content":"Definition: a datatype that represents a vector geometry, i.e. a list of georeferenced points.Built-in attributes: location (type = point): the centroid of the geometryarea (type = float): the area of the geometryperimeter (type = float): the perimeter of the geometryholes (type = list of geometry): the list of the hole inside the given geometrycontour (type = geometry): the exterior ring of the given geometry and of his holesenvelope (type = geometry): the geometry bounding boxwidth (type = float): the width of the bounding boxheight (type = float): the height of the bounding boxpoints (type = list of point): the set of the points composing the geometry Comments: a geometry can be either a point, a polyline or a polygon. Operators working on geometries handle transparently these three kinds of geometry. The envelope (a.k.a. the bounding box) of the geometry depends on the kind of geometry: If this Geometry is the empty geometry, it is an empty point.If the Geometry is a point, it is a non-empty point.Otherwise, it is a Polygon whose points are (minx, miny), (maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny). See also: Spatial operatorsDeclaration: geometries can be built from a point, a list of points or by using specific operators (circle, square, triangle...). geometry varGeom &lt;- circle(5); geometry polygonGeom &lt;- polygon([{3,5}, {5,6},{1,4}]);  Top of the page "},{"title":"graph​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#graph","content":"Definition: a datatype that represents a graph composed of vertices linked by edges.Built-in attributes: edges(type = list of agent/geometry): the list of all edgesvertices(type = list of agent/geometry): the list of all verticescircuit (type = path): an approximate minimal traveling salesman tour (hamiltonian cycle)spanning_tree (type = list of agent/geometry): minimum spanning tree of the graph, i.e. a sub-graph such as every vertex lies in the tree, and as much edges lies in it but no cycles (or loops) are formed.connected(type = bool): test whether the graph is connected Remark: graphs are also a particular kind of container and can thus be manipulated using the container operators and commands.This algorithm used to compute the circuit requires that the graph be complete and the triangle inequality exists (if x,y,z are vertices then d(x,y)+d(y,z)&lt;d(x,z) for all x,y,z) then this algorithm will guarantee a hamiltonian cycle such that the total weight of the cycle is less than or equal to double the total weight of the optimal hamiltonian cycle.The computation of the spanning tree uses an implementation of the Kruskal's minimum spanning tree algorithm. If the given graph is connected it computes the minimum spanning tree, otherwise it computes the minimum spanning forest. See also: Graph operatorsDeclaration: graphs can be built from a list of vertices (agents or geometries) or from a list of edges (agents or geometries) by using specific operators. They are often used to deal with a road network and are built from a shapefile. create road from: shape_file_road; graph the_graph &lt;- as_edge_graph(road); graph([1,9,5]) --: ([1: in[] + out[], 5: in[] + out[], 9: in[] + out[]], []) graph([node(0), node(1), node(2)] // if node is a species graph(['a'::345, 'b'::13]) --: ([b: in[] + out[b::13], a: in[] + out[a::345], 13: in[b::13] + out[], 345: in[a::345] + out[]], [a::345=(a,345), b::13=(b,13)]) graph(a_graph) --: a_graph graph(node1) --: null  Top of the page "},{"title":"list​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#list","content":"Definition: a composite datatype holding an ordered collection of values.Comments: lists are more or less equivalent to instances of ArrayList in Java (although they are backed up by a specific class). They grow and shrink as needed, can be accessed via an index (see @ or index_of), support set operations (like union and difference), and provide the modeller with a number of utilities that make it easy to deal with collections of agents (see, for instance, shuffle, reverse,where,sort_by,...).Remark: lists can contain values of any datatypes, including other lists. Note, however, that due to limitations in the current parser, lists of lists cannot be declared litteraly; they have to be built using assignments. Lists are also a particular kind of container and can thus be manipulated using the container operators and commands.Litteral declaration: a set of expressions separated by commas, enclosed in square brackets, like [12, 14, 'abc', self]. An empty list is noted [].Other declarations: lists can be built literally from a point, or a string, or any other element by using the list casting operator. list (1) -&gt; [1]  list&amp;lt;int&gt; myList &lt;- [1,2,3,4]; myList[2] =&gt; 3  Top of the page "},{"title":"map​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#map","content":"Definition: a composite datatype holding an ordered collection of pairs (a key, and its associated value).Built-in attributes: keys (type = list): the list of all keysvalues (type = list): the list of all valuespairs (type = list of pairs): the list of all pairs key::value Comments: maps are more or less equivalent to instances of Hashtable in Java (although they are backed up by a specific class).Remark: maps can contain values of any datatypes, including other maps or lists. Maps are also a particular kind of container and can thus be manipulated using the container operators and commands.Litteral declaration: a set of pair expressions separated by commas, enclosed in square brackets; each pair is represented by a key and a value separated by ::. An example of map is [agentA::'big', agentB::'small', agentC::'big']. An empty map is noted [].Other declarations: lists can be built literally from a point, or a string, or any other element by using the map casting operator. map (1) -&gt; [1::1] map ({1,5}) -&gt; [x::1, y::5] [] // empty map  Top of the page "},{"title":"matrix​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#matrix","content":"Definition: a composite datatype that represents either a two-dimension array (matrix) or a one-dimension array (vector), holding any type of data (including other matrices).Built-in attributes: dimension (type = point): the dimension (columns x rows) of the receiver matrixcolumns (type = int): the number of columns of the receiver matrixrows (type = int): the number of rows of the receiver matrix Comments: Matrices are fixed-size structures that can be accessed by index (point for two-dimensions matrices, integer for vectors).Litteral declaration: Matrices cannot be defined literally. One-dimensions matrices can be built by using the matrix casting operator applied on a list. Two-dimensions matrices need to be declared as variables first, before being filled. //builds a one-dimension matrix, of size 5 matrix mat1 &lt;- matrix ([10, 20, 30, 40, 50]); // builds a two-dimensions matrix with 10 columns and 5 rows, where each cell is initialized to 0.0 matrix mat2 &lt;- 0.0 as_matrix({10,5}); // builds a two-dimensions matrix with 2 columns and 3 rows, with initialized cells matrix mat3 &lt;- matrix([[&quot;c11&quot;,&quot;c12&quot;,&quot;c13&quot;],[&quot;c21&quot;,&quot;c22&quot;,&quot;c23&quot;]]); -&gt; c11;c21 c12;c22 c13;c23  Top of the page "},{"title":"message​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#message","content":"Definition: a datatype containing a message (sent during a communication, such as the one sent/received in a FIPA interaction).Built-in attributes: contents (type = unknown): the contents of this message, as a list of arbitrary objectssender (type = unknown): the sender that has sent this messageunread (type = bool): whether this message is unread or notemission_timestamp (type = int): the emission time stamp of this message (I.e. at what cycle it has been emitted)recention_timestamp (type = int): the reception time stamp of this message (I.e. at what cycle it has been received) "},{"title":"pair​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#pair","content":"Definition: a datatype holding a key and its associated value.Built-in attributes: key (type = string): the key of the pair, i.e. the first element of the pairvalue (type = string): the value of the pair, i.e. the second element of the pair Remark: pairs are also a particular kind of container and can thus be manipulated using the container operators and commands.Litteral declaration: a pair is defined by a key and a value separated by ::.Other declarations: a pair can also be built from: a point,a map (in this case the first element of the pair is the list of all the keys of the map and the second element is the list of all the values of the map),a list (in this case the two first element of the list are used to build the pair) pair testPair &lt;- &quot;key&quot;::56; pair testPairPoint &lt;- {3,5}; // 3::5 pair testPairList2 &lt;- [6,7,8]; // 6::7 pair testPairMap &lt;- [2::6,5::8,12::45]; // [12,5,2]::[45,8,6]  Top of the page "},{"title":"path​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#path","content":"Definition: a datatype representing a path linking two agents or geometries in a graph.Built-in attributes: source (type = point): the source point, i.e. the first point of the pathtarget (type = point): the target point, i.e. the last point of the pathgraph (type = graph): the current topology (in the case it is a spatial graph), null otherwiseedges (type = list of agents/geometries): the edges of the graph composing the pathvertices (type = list of agents/geometries): the vertices of the graph composing the pathsegments (type = list of geometries): the list of the geometries composing the pathshape (type = geometry) : the global geometry of the path (polyline) Comments: the path created between two agents/geometries or locations will strongly depend on the topology in which it is created.Remark: a path is immutable, i.e. it can not be modified after it is created.Declaration: paths are very barely defined literally. We can nevertheless use the path unary operator on a list of points to build a path. Operators dedicated to the computation of paths (such as path_to or path_between) are often used to build a path. path([{1,5},{2,9},{5,8}]) // a path from {1,5} to {5,8} through {2,9} geometry rect &lt;- rectangle(5); geometry poly &lt;- polygon([{10,20},{11,21},{10,21},{11,22}]); path pa &lt;- rect path_to poly; // built a path between rect and poly, in the topolopy // of the current agent (i.e. a line in a&amp; continuous topology, // a path in a graph in a graph topology ) a_topology path_between a_container_of_geometries // idem with an explicit topology and the possibility // to have more than 2 geometries // (the path is then built incrementally) path_between (a_graph, a_source, a_target) // idem with a the given graph as topology  Top of the page "},{"title":"point​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#point","content":"Definition: a datatype normally holding two positive float values. Represents the absolute coordinates of agents in the model.Built-in attributes: x (type = float): coordinate of the point on the x-axisy (type = float): coordinate of the point on the y-axis Comments: point coordinates should be positive, if a negative value is used in its declaration, the point is built with the absolute value.Remark: points are particular cases of geometries and containers. Thus they have also all the built-in attributes of both the geometry and the container datatypes and can be used with every kind of operator or command admitting geometry and container.Litteral declaration: two numbers, separated by a comma, enclosed in braces, like {12.3, 14.5}Other declarations: points can be built literally from a list, or from an integer or float value by using the point casting operator. point ([12,123.45]) -&gt; {12.0, 123.45} point (2) -&gt; {2.0, 2.0}  Top of the page "},{"title":"rgb​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#rgb","content":"Definition: a datatype that represents a color in the RGB space.Built-in attributes: red(type = int): the red component of the colorgreen(type = int): the green component of the colorblue(type = int): the blue component of the colordarker(type = rgb): a new color that is a darker version of this colorbrighter(type = rgb): a new color that is a brighter version of this color Remark: rgb is also a particular kind of container and can thus be manipulated using the container operators and commands.Litteral declaration: there exist a lot of ways to declare a color. We use the rgb casting operator applied to: a string. The allowed color names are the constants defined in the Color Java class, i.e.: black, blue, cyan, darkGray, lightGray, gray, green, magenta, orange, pink, red, white, yellow.a list. The integer value associated to the three first elements of the list are used to define the three red (element 0 of the list), green (element 1 of the list) and blue (element 2 of the list) components of the color.a map. The red, green, blue components take the value associated to the keys &quot;r&quot;, &quot;g&quot;, &quot;b&quot; in the map.an integer &lt;- the decimal integer is translated into a hexadecimal &lt;- OxRRGGBB. The red (resp. green, blue) component of the color takes the value RR (resp. GG, BB) translated in decimal.Since GAMA 1.6.1, colors can be directly obtained like units, by using the ° or # symbol followed by the name in lowercase of one of the 147 CSS colors (see http://www.cssportal.com/css3-color-names/). Declaration: rgb cssRed &lt;- #red; // Since 1.6.1 rgb testColor &lt;- rgb('white'); // rgb [255,255,255] rgb test &lt;- rgb(3,5,67); // rgb [3,5,67] rgb te &lt;- rgb(340); // rgb [0,1,84] rgb tete &lt;- rgb([&quot;r&quot;::34, &quot;g&quot;::56, &quot;b&quot;::345]); // rgb [34,56,255]  Top of the page "},{"title":"species​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#species","content":"Definition: a generic datatype that represents a speciesBuilt-in attributes: topology (type=topology): the topology is which lives the population of agents Comments: this datatype is actually a &quot;meta-type&quot;. It allows to manipulate (in a rather limited fashion, however) the species themselves as any other values.Litteral declaration: the name of a declared species is already a literal declaration of species.Other declarations: the species casting operator, or its variant called species_of can be applied to an agent in order to get its species. Top of the page "},{"title":"Species names as types​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#species-names-as-types","content":"Once a species has been declared in a model, it automatically becomes a datatype. This means that: It can be used to declare variables, parameters or constants,It can be used as an operand to commands or operators that require species parameters,It can be used as a casting operator (with the same capabilities as the built-in type agent) In the simple following example, we create a set of &quot;humans&quot; and initialize a random &quot;friendship network&quot; among them. See how the name of the species, human, is used in the create command, as an argument to the list casting operator, and as the type of the variable named friend. global { init { create human number: 10; ask human { friend &lt;- one_of (human - self); } } } entities { species human { human friend &lt;- nil; } }  Top of the page "},{"title":"topology​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#topology","content":"Definition: a topology is basically on neighborhoods, distance,... structures in which agents evolves. It is the environment or the context in which all these values are computed. It also provides the access to the spatial index shared by all the agents. And it maintains a (eventually dynamic) link with the 'environment' which is a geometrical border.Built-in attributes: places(type = container): the collection of places (geometry) defined by this topology.environment(type = geometry): the environment of this topology (i.e. the geometry that defines its boundaries) Comments: the attributes places depends on the kind of the considered topology. For continuous topologies, it is a list with their environment. For discrete topologies, it can be any of the container supporting the inclusion of geometries (list, graph, map, matrix)Remark: There exist various kinds of topology: continuous topology and discrete topology (e.g. grid, graph...)Declaration: To create a topology, we can use the topology unary casting operator applied to: an agent: returns a continuous topology built from the agent's geometrya species name: returns the topology defined for this species populationa geometry: returns a continuous topology built on this geometrya geometry container (list, map, shapefile): returns an half-discrete (with corresponding places), half-continuous topology (to compute distances...)a geometry matrix (i.e. a grid): returns a grid topology which computes specifically neighborhood and distancesa geometry graph: returns a graph topology which computes specifically neighborhood and distances More complex topologies can also be built using dedicated operators, e.g. to decompose a geometry... "},{"title":"Defining custom types​","type":1,"pageTitle":"Types","url":"wiki/DataTypes#defining-custom-types","content":"Sometimes, besides the species of agents that compose the model, it can be necessary to declare custom datatypes. Species serve this purpose as well, and can be seen as &quot;classes&quot; that can help to instantiate simple &quot;objects&quot;. In the following example, we declare a new kind of &quot;object&quot;, bottle, that lacks the skills habitually associated with agents (moving, visible, etc.), but can nevertheless group together attributes and behaviors within the same closure. The following example demonstrates how to create the species: species bottle { float volume &lt;- 0.0 max:1 min:0.0; bool is_empty -&gt; {volume = 0.0}; action fill { volume &lt;- 1.0; } }  How to use this species to create new bottles: create bottle { volume &lt;- 0.5; }  And how to use bottles as any other agent in a species (a drinker owns a bottle; when he gets thirsty, it drinks a random quantity from it; when it is empty, it refills it): species drinker { ... bottle my_bottle&lt;- nil; float quantity &lt;- rnd (100) / 100; bool thirsty &lt;- false update: flip (0.1); ... action drink { if condition: ! bottle.is_empty { bottle.volume &lt;-bottle.volume - quantity; thirsty &lt;- false; } } ... init { create bottle return: created_bottle; volume &lt;- 0.5; } my_bottle &lt;- first(created_bottle); } ... reflex filling_bottle when: bottle.is_empty { ask my_bottle { do fill; } } ... reflex drinking when: thirsty { do drink; } }  "},{"title":"Defining actions and behaviors","type":0,"sectionRef":"#","url":"wiki/DefiningActionsAndBehaviors","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"Defining actions and behaviors","url":"wiki/DefiningActionsAndBehaviors#index","content":"Action Declare an actionCall an action BehaviorExample "},{"title":"Action​","type":1,"pageTitle":"Defining actions and behaviors","url":"wiki/DefiningActionsAndBehaviors#action","content":""},{"title":"Declare an action​","type":1,"pageTitle":"Defining actions and behaviors","url":"wiki/DefiningActionsAndBehaviors#declare-an-action","content":"An action is a function or procedure run by an instance of species. An action can return a value (in that case, the type of return has to be specified just before the name of the action), or not (in that case, you just have to put the keyword action before the name of the action). The former ones are often named functions, whereas the latter ones are named procedures in many programming languages. species my_species { int action_with_return_value { // statements... return 1; } action action_without_return_value { // statements... } }  Arguments can also be mandated in your action. You have to specify the type and the name of the argument: action action_without_return_value (int argA, float argB) { // statements... }  If you want to have some optional arguments in the list, you can give some by default values to turn them optional. Nb: it is better to define the optional arguments at the end of the list of argument. action my_action (int argA, float argB &lt;- 5.1, point argC &lt;- {0,0}) { // statements... }  "},{"title":"Call an action​","type":1,"pageTitle":"Defining actions and behaviors","url":"wiki/DefiningActionsAndBehaviors#call-an-action","content":"To call an action, it depends whether you want to get the returned value of not: to call a procedure (without getting any returned value): you have to use the statement do.to call a function and thus get the returned value, you need to use any_agent action(arguments) and assigned this value to a variable. You can use the statement do in different ways: With facets: after specifying the name of your action, you can specify the values of your arguments as if the name of your arguments were facets: do my_action argA: 5 argB: 5.1;  With parenthesis: after specifying the name of your action, you can specify the values of your arguments in the same order they were declared, between parenthesis (just as if you used an operator): do my_action (5,5.1);  We encourage you to use the second way. To catch the returned value, you have to skip the do statement, and store the value directly in a temporary variable: int var1 &lt;- my_action(5,5.1); // or int var1 &lt;- my_action(argA: 5, argB: 5.1);  "},{"title":"Behavior​","type":1,"pageTitle":"Defining actions and behaviors","url":"wiki/DefiningActionsAndBehaviors#behavior","content":"A behavior, or reflex, is a set of statements which is called automatically at each time step by an agent. Note that, a behavior is linked to an architecture; the reflex-based architecture is the default one, others can be used with the controls facet of the species`. reflex my_reflex { write (&quot;Executing the inconditional reflex&quot;); // statements... }  With the facet when, this reflex is only executed when the boolean expression evaluates to true. It is a convenient way to specify the behavior of agents. reflex my_reflex when: flip(0.5) { write (&quot;Executing the conditional reflex&quot;); // statements... }  Reflex, unlike actions, cannot be called from another context. But a reflex can, of course, call actions. NB: Init is a special reflex, that occurs only when the agent is created. "},{"title":"Example​","type":1,"pageTitle":"Defining actions and behaviors","url":"wiki/DefiningActionsAndBehaviors#example","content":"To practice a bit with those notions, we will build an easy example. Let's build a model with a species balloon that has 2 attributes: balloon_size (float) and balloon_color (rgb). Each balloon has a random position and color, his aspect is a sphere. Each step, a balloon has a probability to spawn in the environment. Once a balloon is created, its size is 10cm, and each step, the size increases by 1cm. Once the balloon size reaches 50cm, the balloon has a probability to burst. Once 10 balloons are destroyed, the simulation stops. The volume of each balloon is displayed in the balloon position.  Here is one of the multiple possible implementations: model burst_the_baloon global{ float worldDimension &lt;- 5#m; geometry shape &lt;- square(worldDimension); int nbBaloonDead &lt;- 0; reflex buildBaloon when: (flip(0.1)) { create balloon number: 1; } reflex endSimulation when: nbBaloonDead&gt;10 { do pause; } } species balloon { float balloon_size; rgb balloon_color; init { balloon_size &lt;- 0.1; balloon_color &lt;- rgb(rnd(255),rnd(255),rnd(255)); } reflex balloon_grow { balloon_size &lt;- balloon_size + 0.01; if (balloon_size &gt; 0.5) { if (flip(0.2)) { do balloon_burst; } } } float balloon_volume (float diameter) { float exact_value &lt;- 2/3 * #pi * diameter^3; float round_value &lt;- round(exact_value*1000)/1000; return round_value; } action balloon_burst { write &quot;the baloon is dead !&quot;; nbBaloonDead &lt;- nbBaloonDead + 1; do die; } aspect balloon_aspect { draw circle(balloon_size) color: balloon_color; draw string(balloon_volume(balloon_size)) color: #black; } } experiment my_experiment type: gui { output { display myDisplay { species balloon aspect: balloon_aspect; } } }  "},{"title":"Defining advanced species","type":0,"sectionRef":"#","url":"wiki/DefiningAdvancedSpecies","content":"Defining advanced species In the previous chapter, we saw how to declare and manipulate regular species and the global species (as a reminder, the instance of the global species is the world agent). We will now see that GAMA provides you the possibility to declare some special species, such as grids or graphs, with their own built-in attributes and their own built-in actions. We will also see how to declare mirror species, which is a &quot;copy&quot; of a regular species, in order to give it an other representation. Finally, we will learn how to represent several agents through one unique agent, with multi-level architecture.","keywords":""},{"title":"Defining displays (Generalities)","type":0,"sectionRef":"#","url":"wiki/DefiningDisplaysGeneralities","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"Defining displays (Generalities)","url":"wiki/DefiningDisplaysGeneralities#index","content":"Displays and layersOrganize your layersExample of layers species layergrid layeragents layerimage layergraphics layer "},{"title":"Displays and layers​","type":1,"pageTitle":"Defining displays (Generalities)","url":"wiki/DefiningDisplaysGeneralities#displays-and-layers","content":"A display is one of the graphical outputs of your simulation. You can define several displays related to what you want to represent from your model execution. To define a display, use the keyword display inside the output scope, and specify a name (name facet). experiment my_experiment type: gui { output { display &quot;display1&quot; { } display name:&quot;display2&quot; { } } }  Other facets are available when defining your display: Use background to define a color for your background: display &quot;my_display&quot; background: #red  Use refresh if you want to refresh the display when a condition is true (to refresh your display every number of steps, use the operator every) display &quot;my_display&quot; refresh:every(10)  You can choose between two types of displays, by using the facet type: java2D displays will be used when you want to have 2D visualization. It is used for example when you manipulate charts. This is the default value for the facet type. opengl displays allows you to have 3D visualization. You can save the display on the disk, as a png file, in the folder name_of_model/models/snapshots, by using the facet autosave. This facet takes a boolean as argument (to allow or not to save each frame) or a point to define the size of your image (note that when no unit is provided, the unit is #px (pixel) ). display my_display autosave: true type: java2D {}  The complete list of the display's facets are available in the documentation Each display can be decomposed in one or several layers. Most of the time, all the layers are superimposed and cover all the environment space. In a 3D (OpenGL) display the layers can be split in order to be visualized separately (cf the page about displays). "},{"title":"Organize your layers​","type":1,"pageTitle":"Defining displays (Generalities)","url":"wiki/DefiningDisplaysGeneralities#organize-your-layers","content":"In one 2D display, you will have several types of layers, giving what you want to display in your model. You have a large number of layers available. You already know some of them, such as species, agents, grid, but other specific layers such as image (to display image) and graphics (to freely draw shapes/geometries/texts without having to define a species) are also available Each layer will be displayed in the same order as you declare them. The last declared layer will be above the others. As a consequence, any layer can hide elements of the lower levels. Thus, the following code: experiment expe type: gui { output { display my_display { graphics &quot;layer1&quot; { draw square(20) at: {10,10} color: #gold; } graphics &quot;layer2&quot; { draw square(20) at: {15,15} color: #darkorange; } graphics &quot;layer3&quot; { draw square(20) at: {20,20} color: #cornflowerblue; } } } }  Will have this output:  Most of the layers have a transparency facet that you can use in order to see the layers which are under. experiment expe type:gui { output { display my_display { graphics &quot;layer1&quot; { draw square(20) at:{10,10} color:#darkorange; } graphics &quot;layer2&quot; transparency:0.5 { draw square(20) at:{15,15} color:#cornflowerblue; } } } }   To specify a position and a size for your layer, you can use the position and the size facets. The position facet is used with a point type, between {0,0} and {1,1}, which corresponds to the position of the upper left corner of your layer in percentage of the display's dimensions. Thus, if you choose the point {0.5,0.5}, the upper left corner of your layer will be in the center of your display. By default, this value is {0,0} which corresponds to the top-left corner. The size facet is used with a point type, between {0,0} and {1,1} also. It corresponds to the size occupied by the layer in percentage of the display's dimensions. By default, this value is {1,1} which represents 100% of the width and height available. experiment expe type:gui { output { display my_display { graphics &quot;layer1&quot; position:{0,0} size:{0.5,0.8} { draw shape color:#darkorange; } graphics &quot;layer2&quot; position:{0.3,0.1} size:{0.6,0.2} { draw shape color:#cornflowerblue; } graphics &quot;layer3&quot; position:{0.4,0.2} size:{0.3,0.8} { draw shape color:#gold; } } } }   NB: displays can have a background, while graphics can't. If you want to put a background for your graphics, a solution can be to draw the shape of the world (which is, by default, a square 100m*100m). A lot of other facets are available for the various layers. Please read the documentation of graphics for more information. "},{"title":"Example of layers​","type":1,"pageTitle":"Defining displays (Generalities)","url":"wiki/DefiningDisplaysGeneralities#example-of-layers","content":""},{"title":"species layer​","type":1,"pageTitle":"Defining displays (Generalities)","url":"wiki/DefiningDisplaysGeneralities#species-layer","content":"species allows the modeler to display all the agents of a given species in the current display. In particular, the modeler can choose the aspect used to display them. Please read the documentation about species statement if you are interested. "},{"title":"grid layer​","type":1,"pageTitle":"Defining displays (Generalities)","url":"wiki/DefiningDisplaysGeneralities#grid-layer","content":"Similarly to species, grid allows the modeler to display all the agents of a given species in the current display, but only in the case where the species is a grid. The lines color can be specified. The inner color of the cells is determined by the color built-in attribute of grid agents. This is an optimized way of displaying the grid agents (compared to the species layers). Please read the documentation about grid agents if you are interested. "},{"title":"agents layer​","type":1,"pageTitle":"Defining displays (Generalities)","url":"wiki/DefiningDisplaysGeneralities#agents-layer","content":"agents allows the modeler to display only the agents that fulfill a given condition. Please read the documentation about agents statement if you are interested. "},{"title":"image layer​","type":1,"pageTitle":"Defining displays (Generalities)","url":"wiki/DefiningDisplaysGeneralities#image-layer","content":"image allows the modeler to display an image (e.g. as the background of a simulation). Please read the documentation about image statement if you are interested. "},{"title":"graphics layer​","type":1,"pageTitle":"Defining displays (Generalities)","url":"wiki/DefiningDisplaysGeneralities#graphics-layer","content":"graphics allows the modeler to freely draw shapes/geometries/texts without having to define a species. Please read the documentation about graphics statement if you are interested. "},{"title":"Defining Charts","type":0,"sectionRef":"#","url":"wiki/DefiningCharts","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"Defining Charts","url":"wiki/DefiningCharts#index","content":"Define a chartData definitionVarious types of charts pieserieshistogramxyheatmapradarscatterbox_whisker Other charts possibilities "},{"title":"Define a chart​","type":1,"pageTitle":"Defining Charts","url":"wiki/DefiningCharts#define-a-chart","content":"To define a chart, we have to use the chart statement. A chart has to be named (with the name facet), and the type has to be specified (with the type facet). The value of the type facet can be histogram, pie, series, scatter, xy, radar, heatmap or box_whisker. A chart has to be defined inside a display. experiment my_experiment type: gui { output { display &quot;my_display&quot; { chart &quot;my_chart&quot; type:pie { } } } }  chart can be configured by setting by facets: in particular the labels in x and y-axis can be set (x_serie_labels, y_serie_labels), axes colors (axes), a third axis can be added... After declaring your chart, you have to define the data you want to display in your chart. "},{"title":"Data definition​","type":1,"pageTitle":"Defining Charts","url":"wiki/DefiningCharts#data-definition","content":"Data can be specified with: several data statements to specify each series.one datalist statement to give a list of series. It can be useful if the number of series is unknown, variable or too high. The data statement is used to specify which expression will be displayed. You have to give your data a name (that will be displayed in your chart), the value of the expression you want to follow (using the value facet). You can add some optional facets such as color to specify the color of your data. global { int numberA &lt;- 2 update: numberA*2; int numberB &lt;- 10000 update: numberB-1000; } experiment my_experiment type: gui { float minimum_cycle_duration &lt;- 0.1; output { display &quot;my_display&quot; { chart &quot;my_chart&quot; type: pie { data &quot;numberA&quot; value: numberA color: #red; data &quot;numberB&quot; value: numberB color: #blue; } } } }   The datalist statement is used to write several data statements in one statement. Instead of giving simple values, datalist is expecting value lists. The previous chart is thus equivalent to the following one using the datalist statement: display &quot;my_display2&quot; { chart &quot;my_chart2&quot; type: pie { datalist [&quot;numberA&quot;,&quot;numberB&quot;] value: [numberA,numberB] color: [#red,#blue] ; } }  datalist is particularly suitable in the case where the number of data series to plot can change during the simulation. As an example, when we want to plot the evolution of an attribute value for each agent (and new agents are created), we need to use this statement. As an example, in the following model, we want to plot the energy of each people agent. Each simulation step one agent is created.  global { init { create people number:15; } reflex population_growth when: length(people) &lt; 50 { create people number:1; } } species people { int energy &lt;- rnd(100) min:0; rgb color &lt;- rnd_color(255); reflex aging { energy &lt;- energy - 3; } } experiment my_experiment type: gui { float minimum_cycle_duration &lt;- 0.1; output { display &quot;my_display&quot; { chart &quot;my_chart&quot; type: series { datalist people collect (each.name) value: people collect (each.energy) color: people collect (each.color) ; } } } }   datalist provides you some additional facets you can use. If you want to learn more about them, please read the documentation. "},{"title":"Various types of charts​","type":1,"pageTitle":"Defining Charts","url":"wiki/DefiningCharts#various-types-of-charts","content":"As we already said, you can display several types of graphs: the histograms, the pies, the series, the radars, heatmap... "},{"title":"pie​","type":1,"pageTitle":"Defining Charts","url":"wiki/DefiningCharts#pie","content":"The pie chart shows on a single pie diagram the ratio of each data series over the sum of all the series. It has already been illustrated above. "},{"title":"series​","type":1,"pageTitle":"Defining Charts","url":"wiki/DefiningCharts#series","content":"The series type is perhaps the most basic plot: it displays in an x-y coordinates space the value of each data series over time (simulation step): the x-axis displays the simulation step, the y-axis represents the value of the data series. The previously defined pie chart, can be displayed using a series simply by changing the chart type. global { int numberA &lt;- 2 update: numberA*2; int numberB &lt;- 10000 update: numberB-1000; } experiment my_experiment type: gui { float minimum_cycle_duration &lt;- 0.1; output { display &quot;my_display&quot; { chart &quot;my_chart&quot; type: series { data &quot;numberA&quot; value: numberA color: #red; data &quot;numberB&quot; value: numberB color: #blue; } } } }   "},{"title":"histogram​","type":1,"pageTitle":"Defining Charts","url":"wiki/DefiningCharts#histogram","content":"The histogram charts represent with bars the value of several data series. The previous example can be displayed with a histogram chart.  Histograms are often used to display the distribution of a value inside a population. For example, let consider a population of agents representing human beings with an age attribute. The following model illustrates the plot of the age distribution over the population. We used the operator distribution_of to compute the distribution to plot: here we display the number of people agent in 20 ranges computed among the ages between 0 and 100. model NewModel global { init { create people number: 10000; } } species people { float age &lt;- gauss(40.0, 15.0); } experiment my_experiment type: gui { float minimum_cycle_duration &lt;- 0.1; output { display &quot;my_display&quot; { chart &quot;my_chart&quot; type: histogram { datalist (distribution_of(people collect each.age,20,0,100) at &quot;legend&quot;) value:(distribution_of(people collect each.age,20,0,100) at &quot;values&quot;); } } } }   Note that the facet reverse_axes (with true value) can be added to the chart statement to display horizontal bars. "},{"title":"xy​","type":1,"pageTitle":"Defining Charts","url":"wiki/DefiningCharts#xy","content":"The xy displays are used when we want to display a value in function of another one (instead of plotting a value in function of the time): in this case, the x-axis does not represent the time in general. It can be used for example to plot a phase portrait, e.g. in the Lotka-Volterra model (prey-predator model) in which we want to plot the number of preys according to the number of predators. The code for the chart is then: display PhasePortrait { chart &quot;Lotka Volterra Phase Portrait&quot; type: xy { data 'Preys/Predators' value: {first(LotkaVolterra_agent).nb_prey, first(LotkaVolterra_agent).nb_predator} color: #black ; } }   "},{"title":"radar​","type":1,"pageTitle":"Defining Charts","url":"wiki/DefiningCharts#radar","content":"A radar chart displays the evolution of expression over time in a kind of circular representation: the radar representation. If reuse the example describes previously and used in the previous types of charts, we get the following adapted model: global { int numberA &lt;- 2 update: numberA*2; int numberB &lt;- 10000 update: numberB-1000; } experiment my_experiment type: gui { float minimum_cycle_duration &lt;- 0.1; output { display &quot;my_display&quot; { chart &quot;my_chart&quot; type: radar background: #white axes:#black { data &quot;numberA&quot; value: numberA color: #red accumulate_values: true; data &quot;numberB&quot; value: numberB color: #blue accumulate_values: true; } } } }   "},{"title":"heatmap​","type":1,"pageTitle":"Defining Charts","url":"wiki/DefiningCharts#heatmap","content":"The heatmap in GAMA is close to a stack of histograms charts (allowing to keep a view of the evolution of values over time), representing the height of the bars by color in a gradient. Let consider the model of a human population characterized by their age. We had a population dynamic: at each step, their age is incremented by 1. They also have a probability to die at each step (that increases with their age). When an agent dies, it creates a new agent with an age equals to 0. model NewModel global { init { create people number: 10000; } } species people { float age &lt;- gauss(40.0, 15.0); reflex older { age &lt;- age + 1; } reflex die when: flip(age / 1000) { create people { age &lt;- 0.0; } do die; } } experiment my_experiment type: gui { output { display &quot;my_display&quot; { chart &quot;my_chart&quot; type: histogram { datalist (distribution_of(people collect each.age, 20, 0, 100) at &quot;legend&quot;) value: (distribution_of(people collect each.age, 20, 0, 100) at &quot;values&quot;); } } display DistributionPosition { chart &quot;Distribution of age&quot; type: heatmap x_serie_labels: (distribution_of(people collect each.age, 20, 0, 100) at &quot;legend&quot;) { data &quot;Agedistrib&quot; value: (distribution_of(people collect each.age, 20, 0, 100) at &quot;values&quot;) color: #red; } } } }  We thus displayed the evolution of the age distribution using both a histogram chart (for the instantaneous distribution) and a heatmap display to key a track of the evolution over time. In the heatmap, the left Y-axis represents the time (the simulation step number); as a consequence 1 line represents the state at 1 simulation step. The x-axis represents the various ranges of the distribution (same meaning as for histograms). The right Y-axis shows the meaning of the color gradient.  "},{"title":"scatter​","type":1,"pageTitle":"Defining Charts","url":"wiki/DefiningCharts#scatter","content":"The scatter chart allows us to represent in a 2D space the &quot;spatial distribution&quot; of a set of values. As an example, it allows us to plot the age of all the people agents: the X-axis represents the possible age value and not the time as in a series charts. Here is an example of a chart of type scatter on the previous model example: experiment my_experiment type: gui { output { display &quot;my_display&quot; { chart &quot;my_chart&quot; type: scatter { data &quot;Avg age&quot; value: (people collect each.age) accumulate_values: true line_visible:false ; } } } }   "},{"title":"box_whisker​","type":1,"pageTitle":"Defining Charts","url":"wiki/DefiningCharts#box_whisker","content":"The box_whisker charts represent the distribution of a value. A circle for the average, a horizontal line for the median, a filled bar (the &quot;box&quot;) for the top 75% and the bottom 25% and a line (the &quot;whisker&quot;) for the maximum and minimum values. For example, let consider again a population of agents representing human beings with an age attribute (with an aging mechanism). The following model illustrates the plot of the age distribution over the population. model NewModel global { init { create people number: 100; } } species people { float age &lt;- gauss(40.0, 15.0); reflex older { age &lt;- age + 1; } reflex die when: flip(age / 1000) { create people { age &lt;- 0.0; } do die; } } experiment my_experiment type: gui { float minimum_cycle_duration &lt;- 0.1; output { display &quot;chart age&quot; { chart &quot;age&quot; type: box_whisker series_label_position:yaxis { data &quot;age&quot; value: [mean(people collect each.age),median(people collect each.age), quantile((people sort_by each.age) collect each.age,0.25),quantile((people sort_by each.age)collect each.age,0.75), min(people collect each.age),max(people collect each.age)] color: #green accumulate_values: true; } } } }   Note that the facet series_label_position (with yaxis value) int the chart statement is used to display the serie label (&quot;age&quot;) on the y axis. With more series, we can display the labels as a legend (with the 'legend' value). "},{"title":"Other charts possibilities​","type":1,"pageTitle":"Defining Charts","url":"wiki/DefiningCharts#other-charts-possibilities","content":"The chart, data and datalist come with a huge number of additional facets, allowing you to design advanced result display. We can mention here some of them. "},{"title":"Error values​","type":1,"pageTitle":"Defining Charts","url":"wiki/DefiningCharts#error-values","content":"Just as a box plot, drawing error values around a value, allows the user to visually identify a value (e.g. a mean value) and the distribution of this value around it. The y_err_values facet of data can be used to show in the data plot and a range around it (e.g. the min and max value of an expression in the agent population). In this example, we plot the average age of agents in the population, with the minimum and maximum value. Here is only the experiment code related to the model shown in the previous parts. experiment my_experiment type: gui { float minimum_cycle_duration &lt;- 0.1; output { display &quot;my_display&quot; { chart &quot;my_chart&quot; type: series { data &quot;average age&quot; value: people mean_of each.age color: #red y_err_values: [people min_of each.age,people max_of each.age]; } } } }   "},{"title":"Defining export files","type":0,"sectionRef":"#","url":"wiki/DefiningExportFiles","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"Defining export files","url":"wiki/DefiningExportFiles#index","content":"The Save StatementExport files in experimentAutosave "},{"title":"The Save Statement​","type":1,"pageTitle":"Defining export files","url":"wiki/DefiningExportFiles#the-save-statement","content":"Allows to save data in a file. The type of file can be &quot;shp&quot;, &quot;json&quot; and &quot;kml&quot; for vector spatial data (agents and geometries), &quot;asc&quot; and &quot;geotiff&quot; for raster spatial data (grid), &quot;image&quot; for image, &quot;dimacs&quot;, &quot;dot&quot;, &quot;gexf&quot;, &quot;graphml&quot;, &quot;gml&quot; and &quot;graph6&quot; for graphs, &quot;text&quot; and &quot;csv&quot;. The save statement can be use in an init block, a reflex, an action or in a user command. "},{"title":"Facets​","type":1,"pageTitle":"Defining export files","url":"wiki/DefiningExportFiles#facets","content":"attributes, optional, expects any type in [map, list] - Allows to specify the attributes of a shape file or GeoJson file where agents are saved. Can be expressed as a list of string or as a literal map. When expressed as a list, each value should represent the name of an attribute of the shape or agent. The keys of the map are the names of the attributes that will be present in the file, the values are whatever expressions needed to define their value. crs, optional, expects any type - the name of the projection, e.g. crs:&quot;EPSG:4326&quot; or its EPSG id, e.g. crs:4326. Here a list of the CRS codes (and EPSG id)data, optional, expects any type - the data that will be saved to the fileheader, optional, expects bool - an expression that evaluates to a boolean, specifying whether the save will write a header if the file does not existrewrite, optional, expects bool - a boolean expression specifying whether to erase the file if it exists or append data at the end of it. Only applicable to &quot;text&quot; or &quot;csv&quot; files. Default is trueto, optional, expects string - an expression that evaluates to an string, the path to the file, or directly to a filetype, optional, expects an identifier, takes values in [shp, text, csv, asc, geotiff, image, kml, kmz, json, dimacs, dot, gexf, graphml, gml, graph6]. - an expression that evaluates to an string, the type of the output file.  "},{"title":"Usages​","type":1,"pageTitle":"Defining export files","url":"wiki/DefiningExportFiles#usages","content":"Its simple syntax is: save data to: output_file type: a_type_file;  To save data in a text file: save (string(cycle) + &quot;-&gt;&quot; + name + &quot;:&quot; + location) to: &quot;save_data.txt&quot; type: text;  To save the values of some attributes of the current agent in csv file: save [name, location, host] to: &quot;save_data.csv&quot; type: csv;  To save the geometries of all the agents of a species into a shapefile or a geojson (with optional attributes): save species_of(self) to: &quot;save_shapefile.shp&quot; type: shp attributes: [name::&quot;nameAgent&quot;, location::&quot;locationAgent&quot;] crs: &quot;EPSG:4326&quot;; save species_of(self) to: &quot;save_shapefile.geojson&quot; type: json attributes: [name::&quot;nameAgent&quot;, location::&quot;locationAgent&quot;] ;  To save a grid into a geotiff or a asc file (the value considered will be the &quot;grid_value&quot; attribute of the cell): save cell to:&quot;../results/grid.tif&quot; type:geotiff; save cell to:&quot;../results/grid.asc&quot; type:asc;  To save a grid into an image file: save cell to:&quot;../results/grid.png&quot; type:image;  "},{"title":"Export files in an experiment​","type":1,"pageTitle":"Defining export files","url":"wiki/DefiningExportFiles#export-files-in-an-experiment","content":"When the modeler wants to save data at each simulation step, it is recommended to use the save statement either in the model itself or in a reflex of the experiment (the syntax and the use are similar in all the cases). The use of save in experiment is mandatory when we want to save a value related to several simulations running in parallel (e.g. the average of a value over several simulations). It is in particular in batch experiments to save a value at the end of simulations. "},{"title":"Autosave​","type":1,"pageTitle":"Defining export files","url":"wiki/DefiningExportFiles#autosave","content":"Image files can be exported also through the autosave facet of the display, as explained in this previous part. "},{"title":"Defining monitors and inspectors","type":0,"sectionRef":"#","url":"wiki/DefiningMonitorsAndInspectors","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"Defining monitors and inspectors","url":"wiki/DefiningMonitorsAndInspectors#index","content":"Define a monitorDefine an inspector "},{"title":"Define a monitor​","type":1,"pageTitle":"Defining monitors and inspectors","url":"wiki/DefiningMonitorsAndInspectors#define-a-monitor","content":"A monitor allows to follow the value of an arbitrary expression in GAML. It will appear, in the User Interface, in a small window on its own and be recomputed every time step (or according to its refresh facet). Definition of a monitor: monitor monitor_name value: an_expression refresh: boolean_statement;  with: value: mandatory, the expression whose value will be displayed by the monitor.refresh: bool statement, optional: the new value is computed if the bool statement returns true. Example: experiment my_experiment type: gui { output { monitor monitor_name value: cycle refresh: every(1#cycle); } }  NB: you can also declare monitors during the simulation, by clicking on the button &quot;Add new monitor&quot;, and specifying the name of the variable you want to follow. "},{"title":"Define an inspector​","type":1,"pageTitle":"Defining monitors and inspectors","url":"wiki/DefiningMonitorsAndInspectors#define-an-inspector","content":"During the simulation, the user interface of GAMA provides the user the possibility to inspect an agent, or a group of agents. But you can also define the inspector you want directly from your model, as an output of the experiment. Use the statement inspect to define your inspector, in the output scope of your GUI experiment. The inspector has to be named (using the facet name), a value has to be specified (with the value facet). inspect &quot;inspector_name&quot; value: the_value_you_want_to_display;  Note that you can inspect any type of species (regular species, grid species, even the world...) or agent. The optional facet type is used to specify the type of your inspector. 2 values are possible: agent (default value) if you want to display the information as a regular agent inspector. Note that if you want to inspect a large number of agents, this can take a lot of time. In this case, prefer the other type tabletable if you want to display the information as an agent browser. The optional facet attributes is used to filter the attributes you want to display in your inspector. Beware: only one agent inspector (type: agent) can be used for an experiment. Besides, you can add as many agent browsers (type: table) as you want for your experiment. Example of implementation: model new global { init { create my_species number:3; } } species my_species { int int_attr &lt;- 6; string str_attr &lt;- &quot;my_value&quot;; string str_attr_not_important &lt;- &quot;blabla&quot;; } grid my_grid_species width: 10 height: 10 { int rnd_value &lt;- rnd(5); } experiment my_experiment type:gui { output { inspect &quot;my_species_inspector&quot; value: my_species attributes: [&quot;int_attr&quot;,&quot;str_attr&quot;]; inspect &quot;my_species_browser&quot; value: my_species type: table; inspect &quot;my_grid_species_browser&quot; value: 5 among my_grid_species type: table; } }  Another statement, browse, is doing a similar thing, but prefer the table type (if you want to browse an agent species, the default type will be the table type). "},{"title":"Defining GUI Experiment","type":0,"sectionRef":"#","url":"wiki/DefiningGUIExperiment","content":"","keywords":""},{"title":"Types of experiments​","type":1,"pageTitle":"Defining GUI Experiment","url":"wiki/DefiningGUIExperiment#types-of-experiments","content":"You can define fours types of experiments (through the facet type): gui experiments (the default type) are used to play an experiment and displays its outputs. It is also used when the user wants to interact with the simulation.batch experiments are used to play an experiment several times (usually with other input values), used for model exploration. We will come back to this notion a bit further in the tutorial.test experiments are used to write unit tests on a model (used to ensure its quality).memorize experiments are GUI experiments in which the simulation state is kept in memory and the user can backtrack to any previous step. "},{"title":"Experiment attributes​","type":1,"pageTitle":"Defining GUI Experiment","url":"wiki/DefiningGUIExperiment#experiment-attributes","content":"Inside experiment scope, you can access to some built-in attributes which can be useful, such as minimum_cycle_duration, to force the duration of one cycle. experiment my_experiment type: gui { float minimum_cycle_duration &lt;- 2.0#minute; }  In addition, the attribute simulations contain the list of all the simulation agents that are running in the current experiment. Whereas the attribute simulation represents a single simulation, the last element of the simulation list. "},{"title":"Experiment facets​","type":1,"pageTitle":"Defining GUI Experiment","url":"wiki/DefiningGUIExperiment#experiment-facets","content":"Finally, in the case of a GUI experiment, the facets autorun and benchmark can be used as follows: experiment name type: gui autorun: true benchmark: true { }  When autorun is set to true the launch of the experiment will be followed automatically by its run. When benchmark is set to true, GAMA records the number of invocations and running time of the statements and operators of the simulations launched in this experiment. The results are automatically saved in a csv file in a folder called 'benchmarks' when the experiment is closed. Other built-ins are available, to learn more about, go to the page experiment built-in. "},{"title":"Defining displays layout​","type":1,"pageTitle":"Defining GUI Experiment","url":"wiki/DefiningGUIExperiment#defining-displays-layout","content":"A layout can be added to output to specify the layout of the various displays defined below (e.g. #none, #split, #stack, #vertical or #horizontal). It will also define which elements of the interface are displayed: parameters, navigator, editors, consoles, toolbars, tray, or tabs facets (expecting a boolean value). You will find more detailed information in the statement's documentation "},{"title":"Defining elements of the GUI experiment​","type":1,"pageTitle":"Defining GUI Experiment","url":"wiki/DefiningGUIExperiment#defining-elements-of-the-gui-experiment","content":"In this part, we will focus on the gui experiments. We will start with learning how to define input parameters, then we will study the outputs, such as displays, monitors and inspectors, and export files. We will finish this part with how to define user commands. "},{"title":"Defining Parameters","type":0,"sectionRef":"#","url":"wiki/DefiningParameters","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"Defining Parameters","url":"wiki/DefiningParameters#index","content":"Defining parametersAdditional facets "},{"title":"Defining parameters​","type":1,"pageTitle":"Defining Parameters","url":"wiki/DefiningParameters#defining-parameters","content":"You can define parameters inside the global scope when defining your global variables with the facet parameter (this way of defining parameters is not the recommended one, as it makes the variable a parameter of all the experiments that will be defined and does not offer the possibility to redefine its initial and possible values in several ways in each experiment): global { int my_integer_global_value &lt;- 5 parameter: &quot;My integer global value&quot;; }  When launching your experiment, the parameter will appear in your &quot;Parameters&quot; panel, with the name you chose for the parameter facet.  You can also define your parameter inside the experiment (recommended), using the statement parameter. You have to specify first the name of your parameter, then the name of the global variable through the facet var. global { int my_integer_global_value &lt;- 5; } experiment MyExperiment type: gui { parameter &quot;My integer global value&quot; var:my_integer_global_value; }  NB: This variable has to be initialized with a value. If you do not want to initialize your value in the global block, you can initialize the value directly in the parameter statement, using the facet init or &lt;-. global { int my_integer_global_value; } experiment MyExperiment type: gui { parameter &quot;My integer global value&quot; var: my_integer_global_value init: 5; }  "},{"title":"Additional facets​","type":1,"pageTitle":"Defining Parameters","url":"wiki/DefiningParameters#additional-facets","content":"You can use some facets to arrange your parameters. For example, you can categorize your parameters under a label, using the facet category: global { int attr_1 &lt;- 5 ; int attr_2 &lt;- 5 ; int attr_3 &lt;- 5 ; } experiment MyExperiment type: gui { parameter &quot;attr 1&quot; category: &quot;Category 1&quot; var: attr_1 &lt;- 5; parameter &quot;attr 2&quot; category: &quot;Category 1&quot; var: attr_2 &lt;- 5; parameter &quot;attr 3&quot; category: &quot;Category 2&quot; var: attr_3 init: 5; }   You also can add some facets such as min, max, step or among to improve the declaration of the parameter (and define the possible values the parameter can take). global { string fruit &lt;- &quot;none&quot; ; string vegetable &lt;- &quot;none&quot;; int integer_variable &lt;- 5; } experiment MyExperiment type: gui { parameter &quot;fruit&quot; category:&quot;food&quot; var: fruit &lt;- &quot;none&quot; among:[&quot;none&quot;,&quot;apple&quot;,&quot;banana&quot;] ; parameter &quot;vegetable&quot; category:&quot;food&quot; var: vegetable &lt;- &quot;none&quot; among:[&quot;none&quot;,&quot;cabbage&quot;,&quot;carrot&quot;]; parameter &quot;integer variable&quot; category:&quot;other&quot;var: integer_variable &lt;- 5 min:0 max:100 step:5; }  We can notice that the parameters will not appear graphically in the same way if they are defined with a set of possible values (with among) or with a range of possible values (defined by a min, max and a step). The definition of the initial value and of the possible values can be set in the global or in the experiment depending on the aim of this limitation: for example if a variable has a maximum value set to 1 in the global, this limitation can be used in the model in order that the variable value does not exceed this value. If the maximum boundary is set in the experiment, some executions of the model can be done without it...  "},{"title":"Developing architecture","type":0,"sectionRef":"#","url":"wiki/DevelopingControlArchitectures","content":"","keywords":""},{"title":"Implementation​","type":1,"pageTitle":"Developing architecture","url":"wiki/DevelopingControlArchitectures#implementation","content":"A control architecture is a Java class, that: is annotated by the @skill annotation,extends the AbstractArchitecture class (to get benefits of everything from the reflex-based control architecture, the ReflexArchitecture class can be extended instead). The AbstractArchitecture extends the ISkill and IStatement interfaces and add the 2 following methods: public abstract boolean init(IScope scope) throws GamaRuntimeException;public abstract void verifyBehaviors(ISpecies context); The three main methods to implement are thus: public void setChildren(final List&amp;lt;? extends ISymbol&gt; children): this method will be called at the compilation of the model. It allows to manage all the embeded statements (in children) and for example separate the statements that should be executed at the initialization only from the ones that should be executed at each simulation step. Following example allows to test the name of the all the embedded statements: for ( final ISymbol c : children ) { if( IKeyword.INIT.equals(c.getFacet(IKeyword.KEYWORD).literalValue()) ) {  public abstract boolean init(IScope scope) throws GamaRuntimeException: this method is called only once, at the initialization of the agent.public Object executeOn(final IScope scope) throws GamaRuntimeException: this method is executed at each simulation step. It should manage the execution of the various embedded behaviors (e.g. their order or choose which one will be executed...). "},{"title":"Developing Extensions","type":0,"sectionRef":"#","url":"wiki/DevelopingExtensions","content":"Developing Extensions GAMA accepts extensions to the GAML language, defined by external programmers and dynamically loaded by the platform each time it is run. Extensions can represent new built-in species, types, file-types, skills, operators, statements, new control architectures or even types of displays. Other internal structures of GAML will be progressively &quot;opened&quot; to this mechanism in the future: display layers (hardwired for the moment), new types of outputs (hardwired for the moment), scheduling policies (hardwired for the moment), random number generators (hardwired for the moment). The extension mechanism relies on two complementary techniques: the first one consists in defining the GAML extensions in a plug-in (in the OSGI sense, see here) that will be loaded by GAMA at runtime and must &quot;declare&quot; that it is contributing to the platform.the second one is to indicate to GAMA where to look for extensions, using Java annotations that are gathered at compile time (some being also used at runtime) and directly compiled into GAML structures. The following sections describe this extension process. Developing Plugins Developing Skills Developing Statements Developing Operators Developing Types Developing Species Developing Control Architectures IScope Index of annotations","keywords":""},{"title":"Defining user interaction","type":0,"sectionRef":"#","url":"wiki/DefiningUserInteraction","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"Defining user interaction","url":"wiki/DefiningUserInteraction#index","content":"Catch Mouse EventDefine User command ... in the GUI Experiment scope... in global or regular speciesuser_locationuser_input User Control Architecture "},{"title":"Catch Mouse Event​","type":1,"pageTitle":"Defining user interaction","url":"wiki/DefiningUserInteraction#catch-mouse-event","content":"You can catch mouse event during the simulation using the statement event. This statement has 2 required facets: name (identifier) : Specify which event do you want to trigger (among the following values : mouse_down, mouse_up, mouse_move, mouse_enter, mouse_exit or any alphanumeric symbol/key of the keyboard, such as, 'a', 'b'...).action (identifier) : Specify the name of the global action to call. event mouse_down action: my_action;  The event statement has to be defined in the experiment/output/display scope. Once the event is triggered, the global action linked will be called. The action linked cannot have arguments. To get the location of the mouse click, the #user_location can be used; to get the agents on which the mouse has clicked, you can use spatial query (e.g. my_species overlapping #user_location). global { action my_action { write &quot;do action&quot;; } } species my_species { } experiment my_experiment type: gui { output { display my_display { species my_species; event mouse_down action: my_action; } } }  "},{"title":"Define User command​","type":1,"pageTitle":"Defining user interaction","url":"wiki/DefiningUserInteraction#define-user-command","content":"Anywhere in the global block, in a species or in an (GUI) experiment, user_command statements can be implemented. They can either call directly an existing action (with or without arguments) or be followed by a block that describes what to do when this command is run. Their syntax can be (depending of the modeler needs) either: user_command cmd_name action: action_without_arg_name; //or user_command cmd_name action: action_name with: [arg1::val1, arg2::val2]; //or user_command cmd_name { // statements }  For instance: user_command kill_myself action: die; //or user_command kill_myself action: some_action with: [arg1::5, arg2::3]; //or user_command kill_myself { do die; }  "},{"title":"Defining User command in GUI Experiment scope​","type":1,"pageTitle":"Defining user interaction","url":"wiki/DefiningUserInteraction#defining-user-command-in-gui-experiment-scope","content":"The user command can be defined directly inside the GUI experiment scope. In that case, the implemented action appears as a button in the top of the parameter view. Here is a very short code example : model quick_user_command_model global { action createAgent { create my_species; } } species my_species { aspect base { draw circle(1) color:#blue; } } experiment expe type:gui { user_command cmd_inside_experiment action:createAgent; output { display my_display { species my_species aspect:base; } } }  And here is screenshots of the execution :  "},{"title":"Defining User command in a global or regular species​","type":1,"pageTitle":"Defining user interaction","url":"wiki/DefiningUserInteraction#defining-user-command-in-a-global-or-regular-species","content":"The user command can also be defined inside a species scope (either global or regular one). Here is a quick example of model : model quick_user_command_model global { init { create my_species number:10; } } species my_species { user_command cmd_inside_experiment action:die; aspect base { draw circle(1) color:#blue; } } experiment expe type:gui { output { display my_display { species my_species aspect:base; } } }  During the execution, you have 2 ways to access to the action: When the agent is inspected, they appear as buttons above the agents' attributes  When the agent is selected by a right-click in a display, these commands appear under the usual &quot;Inspect&quot;, &quot;Focus&quot; and &quot;Highlight&quot; commands in the pop-up menu.  Remark: The execution of a command obeys the following rules: when the command is called from right-click pop-menu, it is executed immediatelywhen the command is called from panels, its execution is postponed until the end of the current step and then executed at that time. "},{"title":"user_location​","type":1,"pageTitle":"Defining user interaction","url":"wiki/DefiningUserInteraction#user_location","content":"In the special case when the user_command is called from the pop-up menu (from a right-click on an agent in a display), the location chosen by the user (translated into the model coordinates) is passed to the execution scope under the name user_location. Example: global { user_command &quot;Create agents here&quot; { create my_species number: 10 with: [location::user_location]; } }  This will allow the user to click on a display, choose the world (always present now), and select the menu item &quot;Create agents here&quot;. Note that if the world is inspected (this user_command appears thus as a button) and the user chooses to push the button, the agent will be created at a random location. "},{"title":"user_input​","type":1,"pageTitle":"Defining user interaction","url":"wiki/DefiningUserInteraction#user_input","content":"As it is also, sometimes, necessary to ask the user for some values (not defined as parameters), the user_input unary operator has been introduced. This operator takes a map [string::value] as argument (the key is the name of the chosen parameter, the value is the default value), displays a dialog asking the user for these values, and returns the same map with the modified values (if any). You can also add a text as first argument of the operator, which will be displayed as a title for your dialog popup. The dialog is modal and will interrupt the execution of the simulation until the user has either dismissed or accepted it. It can be used, for instance, in an init section like the following one to force the user to input new values instead of relying on the initial values of parameters. Here is an example of implementation: model quick_user_command_model global { init { map values &lt;- user_input(&quot;Choose a number of agent to create&quot;,[&quot;Number&quot; :: 100]); create my_species number: int(values at &quot;Number&quot;); } } species my_species { aspect base { draw circle(1) color:#blue; } } experiment expe type:gui { output { display my_display { species my_species aspect:base; } } }  When running this model, you will first have to input a number:  "},{"title":"User Control Architecture​","type":1,"pageTitle":"Defining user interaction","url":"wiki/DefiningUserInteraction#user-control-architecture","content":"The other way to define user interaction is to use user control architecture. Please jump directly to the section user control architecture if you want to learn more about this point. "},{"title":"Get into the GAMA Java API","type":0,"sectionRef":"#","url":"wiki/developingGAMA","content":"Get into the GAMA Java API GAMA is written in Java and made of tens of Eclipse plugins and projects, thousand of classes, methods and annotations. This section of the wiki should help you have a general idea on how to manipulate GAMA Java API and where to find the proper classes and methods. A general introduction to the GAMA architecture gives a general overview of the organization of Java packages and Eclipse plugins, and should be read first. In the following sub-sections we give a more practical introduction. Introduction to GAMA Java API Installing the GIT versionArchitecture of GAMAIScope Developing Extensions Developing PluginsDeveloping SkillsDeveloping StatementsDeveloping OperatorsDeveloping TypesDeveloping SpeciesDeveloping Control ArchitecturesIndex of annotations Create a release of GamaGeneration of the documentation","keywords":""},{"title":"IScope interface","type":0,"sectionRef":"#","url":"wiki/DevelopingIScope","content":"","keywords":""},{"title":"Use of an IScope​","type":1,"pageTitle":"IScope interface","url":"wiki/DevelopingIScope#use-of-an-iscope","content":"A variable scope of type IScope can be used to: get the current agent with: scope.getAgentScope() IAgent agent = scope.getAgentScope();  evaluate an expression in the current scope: String mes = Cast.asString(scope, message.value(scope));  know whether the scope has been interrupted: boolean b = scope.interrupted();  "},{"title":"Index of annotations","type":0,"sectionRef":"#","url":"wiki/DevelopingIndexAnnotations","content":"","keywords":""},{"title":"@action​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#action","content":"This annotation is used to tag a method that will be considered as an action (or primitive) in GAML. The method must have the following signature: Object methodName(IScope) throws GamaRuntimeException and be contained in a class annotated with @species or @skill (or a related class, like a subclass or an interface). This annotation contains: name (String): the name of the variable as it can be used in GAML.virtual (boolean, false by default): if true the action is virtual, i.e. equivalent to abstract method in java.args (set of @arg, empty by default): the list of arguments passed to this action. Each argument is an instance of arg.doc (set of @doc, empty by default): the documentation associated to the action. "},{"title":"@arg​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#arg","content":"This annotation describes an argument passed to an action. This annotation contains: name (String, &quot;&quot; by default): the name of the argument as it can be used in GAML.type (set of ints, empty by default): An array containing the textual representation of the types that can be taken by the argument (see IType).optional (boolean, true by default): whether this argument is optional or not.doc (set of @doc, empty by default): the documentation associated to the argument. "},{"title":"@constant​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#constant","content":"This annotation is used to annotate fields that are used as constants in GAML. This annotation contains: category (set of Strings, empty by default): an array of strings, each representing a category in which this constant can be classified (for documentation indexes).value (String): a string representing the basic keyword for the constant. Does not need to be unique throughout GAML.altNames (set of Strings, empty by default): an Array of strings, each representing a possible alternative name for the constant. Does not need to be unique throughout GAML.doc (set of @doc, empty by default): the documentation attached to this constant. "},{"title":"@doc​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#doc","content":"It provides a unified way of attaching documentation to the various GAML elements tagged by the other annotations. The documentation is automatically assembled at compile time and also used at runtime in GAML editors. This annotation contains: value (String, &quot;&quot; by default): a String representing the documentation of a GAML element.masterDoc (boolean, false by default): a boolean representing the fact that this instance of the operator is the master one, that is whether its value will subsume the value of all other instances of it.deprecated (String, &quot;&quot; by default): a String indicating (if it is not empty) that the element is deprecated and defining, if possible, what to use instead.returns (String, &quot;&quot; by default): the documentation concerning the value(s) returned by this element (if any)..comment (String, &quot;&quot; by default): an optional comment that will appear differently from the documentation itself.special_cases (set of Strings, empty by default): an array of String representing the documentation of the &quot;special cases&quot; in which the documented element takes part.examples (set of @example, empty by default): an array of String representing some examples or use-cases about how to use this element.usages (set of @usage, empty by default): An array of usages representing possible usage of the element in GAML.see (set of Strings, empty by default): an array of String representing cross-references to other elements in GAML. "},{"title":"@example​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#example","content":"This facet describes an example, that can be used either in the documentation, as unit test or as pattern. This annotation contains: value (String, &quot;&quot; by default): a String representing the expression as example.var (String, &quot;&quot; by default): The variable that will be tested in the equals, if it is omitted a default variable will be used.equals (String, &quot;&quot; by default): The value to which the value will be compared.returnType (String, &quot;&quot; by default): The type of the value that should be tested.isNot (String, &quot;&quot; by default): The value to which the value will be compared.raises (String, &quot;&quot; by default): The exception or warning that the expression could raise.isTestOnly (boolean, false by default): specifies that the example should not be included in the documentation.isExecutable (boolean, true by default): specifies that the example is correct GAML code that can be executed.test (boolean, true by default): specifies that the example is will be tested with the equals.isPattern (boolean, false by default): whether or not this example should be treated as part of a pattern (see @usage). If true, the developers might want to consider writing the example line (and its associated lines) using template variables (e.g. ${my_agent}). "},{"title":"@facet​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#facet","content":"This facet describes a facet in a list of facets. This annotation contains: name (String): the name of the facet. Must be unique within a symbol.type (set of int): the string values of the different types that can be taken by this facet.values (set of Strings, empty by default): the values that can be taken by this facet. The value of the facet expression will be chosen among the values described here.optional (boolean, false by default): whether or not this facet is optional or mandatory.doc (set of @doc, empty by default): the documentation associated to the facet. "},{"title":"@facets​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#facets","content":"This annotation describes a list of facets used by a statement in GAML. This annotation contains: value (set of @facet): array of @facet, each representing a facet name, type..ommissible (string): the facet that can be safely omitted by the modeler (provided its value is the first following the keyword of the statement). "},{"title":"@file​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#file","content":"This annotation is used to define a type of file. This annotation contains: name (String): a (human-understandable) string describing this type of files, suitable for use in composed operator names (e.g. &quot;shape&quot;, &quot;image&quot;...). This name will be used to generate two operators: name+&quot;_file&quot; and &quot;is&quot;+name. The first operator may have variants taking one or several arguments, depending on the @builder annotations present on the class_.extensions (set of Strings): an array of extensions (without the '.' delimiter) or an empty array if no specific extensions are associated to this type of files (e.g. [&quot;png&quot;,&quot;jpg&quot;,&quot;jpeg&quot;...]). The list of file extensions allowed for this type of file. These extensions will be used to check the validity of the file path, but also to generate the correct type of file when a path is passed to the generic &quot;file&quot; operator.buffer_content (int, ITypeProvider.NONE by default): the type of the content of the buffer. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the content type is searched using this provider).buffer_index (int, ITypeProvider.NONE by default): the type of the index of the buffer. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the index type is searched using this provider).buffer_type (int, ITypeProvider.NONE by default): the type of the buffer. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the type is searched using this provider).doc (set of @doc, empty by default): the documentation attached to this operator. "},{"title":"@getter​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#getter","content":"This annotation is used to indicate that a method is to be used as a getter for a variable defined in the class. The variable must be defined on its own (in vars). This annotation contains: value (String): the name of the variable for which the annotated method is to be considered as a getter.initializer (boolean, false by default): returns whether or not this getter should also be used as an initializer "},{"title":"@inside​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#inside","content":"This annotation is used in conjunction with @symbol. It provides a way to tell where this symbol should be located in a model (i.e. what its parents should be). Either direct symbol names (in symbols) or generic symbol kinds can be used. This annotation contains: symbols (set of Strings, empty by default): symbol names of the parents.kinds (set of int, empty by default): generic symbol kinds of the parents (see ISymbolKind.java for more details). "},{"title":"@operator​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#operator","content":"This annotation represents an &quot;operator&quot; in GAML and is used to define its name(s) as well as some meta-data that will be used during the validation process. This annotation contains: value (set of Strings, empty by default): names of the operator.category (set of string, empty by default): categories to which the operator belongs (for documentation purpose).iterator (boolean, false by default): true if this operator should be treated as an iterator (i.e.requires initializing the special variable &quot;each&quot; of WorldSkill within the method).can_be_const (boolean, false by default): if true: if the operands are constant, returns a constant value.content_type (int, ITypeProvider.NONE by default): the type of the content if the returned value is a container. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the content type is searched using this provider).index_type (int, ITypeProvider.NONE by default): the type of the index if the returned value is a container. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the index type is searched using this provider).expected_content_type (set of int, empty by default): if the argument is a container, returns the types expected for its contents. Should be an array of IType.XXX.type (int, ITypeProvider.NONE by default): the type of the expression if it cannot be determined at compile time (i.e. when the return type is &quot;Object&quot;). Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the type is searched using this provider)..internal (boolean, false by default): returns whether this operator is for internal use only. doc (set of @doc, empty by default): the documentation attached to this operator. "},{"title":"@serializer​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#serializer","content":"It allows to declare a custom serializer for Symbols (statements, var declarations, species, experiments, etc.). This serializer will be called instead of the standard serializer, superseding this last one. Serializers must be subclasses of the SymbolSerializer class. value (Class): the serializer class. "},{"title":"@setter​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#setter","content":"This annotation is used to indicate that a method is to be used as a setter for a variable defined in the class. The variable must be defined on its own (in vars). This annotation contains: value (String): the name of the variable for which the annotated method is to be considered as a setter. "},{"title":"@skill​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#skill","content":"This annotation allows to define a new skill (class grouping variables and actions that can be used by agents). This annotation contains: name (String): a String representing the skill name in GAML (must be unique throughout GAML).attach_to (set of strings): an array of species names to which the skill will be automatically added (complements the &quot;skills&quot; parameter of species).internal (boolean, false by default): return whether this skill is for internal use only.doc (set of @doc, empty by default): the documentation associated to the skill. "},{"title":"@species​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#species","content":"This annotation represents a &quot;species&quot; in GAML. The class annotated with this annotation will be the support of a species of agents. This annotation contains: name (string): the name of the species that will be created with this class as base. Must be unique throughout GAML.skills (set of strings, empty by default): An array of skill names that will be automatically attached to this species. Example: @species(value=&quot;animal&quot; skills={&quot;moving&quot;})internal (boolean, false by default): whether this species is for internal use only.doc (set of @doc, empty by default): the documentation attached to this operator. "},{"title":"@symbol​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#symbol","content":"This annotation represents a &quot;statement&quot; in GAML and is used to define its name(s) as well as some meta-data that will be used during the validation process. This annotation contains: name (set of string, empty by default): names of the statement.kind (int): the kind of the annotated symbol (see ISymbolKind.java for more details).with_scope (boolean, true by default): indicates if the statement (usually a sequence) defines its own scope. Otherwise, all the temporary variables defined in it are actually defined in the super-scope.with_sequence (boolean): indicates whether or not a sequence can or should follow the symbol denoted by this class.with_args (boolean, false by default): indicates whether or not the symbol denoted by this class will accept arguments.remote_context (boolean, false by default): indicates that the context of this statement is actually a hybrid context: although it will be executed in a remote context, any temporary variables declared in the enclosing scopes should be passed on as if the statement was executed in the current context.doc (set of @doc, empty by default): the documentation attached to this symbol.internal (boolean, false by default): returns whether this symbol is for internal use only.unique_in_context (boolean, false by default): Indicates that this statement must be unique in its super context (for example, only one return is allowed in the body of an action)..unique_name (boolean, false by default): Indicates that only one statement with the same name should be allowed in the same super context. "},{"title":"@type​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#type","content":"It provides information necessary to the processor to identify a type. This annotation contains: name (String, &quot;&quot; by default): a String representing the type name in GAML.id (int, 0 by default): the unique identifier for this type. User-added types can be chosen between IType.AVAILABLE_TYPES and IType.SPECIES_TYPES (exclusive) (cf. IType.java).wraps (tab of Class, null by default): the list of Java Classes this type is &quot;wrapping&quot; (i.e. representing). The first one is the one that will be used preferentially throughout GAMA. The other ones are to ensure compatibility, in operators, with compatible Java classes (for instance, List and GamaList).kind (int, ISymbolKind.Variable.REGULAR by default): the kind of Variable used to store this type. See ISymbolKind.Variable.internal (boolean, false by default): whether this type is for internal use only.doc (set of @doc, empty by default): the documentation associated to the facet. "},{"title":"@usage​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#usage","content":"This replaces @special_cases and @examples, and unifies the doc for operators, statements, and others. An @usage can also be used for defining a template for a GAML structure, and in that case, requires the following to be defined: A name (attribute &quot;name&quot;), optional, but betterA description (attribute &quot;value&quot;), optionalA menu name (attribute &quot;menu&quot;), optionalA hierarchical path within this menu (attribute &quot;path&quot;), optionalA pattern (attribute &quot;pattern&quot; or concatenation of the @example present in &quot;examples&quot; that define &quot;isPattern&quot; as true) This annotation contains: value (String): a String representing one usage of the keyword. Note that for usages aiming at defining templates, the description is displayed on a tooltip in the editor. The use of the path allows to remove unnecessary explanations. For instance, instead of writing: description=&quot;This template illustrates the use of a complex form of the &quot;create&quot; statement, which reads agents from a shape file and uses the tabular data of the file to initialize their attributes&quot;, choose: name=&quot;Create agents from shapefile&quot; menu=STATEMENT; path={&quot;Create&quot;, &quot;Complex forms&quot;} description=&quot;Read agents from a shape file and initialize their attributes&quot;. If no description is provided, GAMA will try to grab it from the context where the template is defined (in the documentation, for example).menu (String, &quot;&quot; by default): Define the top-level menu where this template should appear. Users are free to use other names than the provided constants if necessary (i.e. &quot;My templates&quot;). When no menu is defined, GAMA tries to guess it from the context where the template is defined.path (set of Strings, empty by default): The path indicates where to put this template in the menu. For instance, the following annotation: &quot; menu = STATEMENT; path = {&quot;Control&quot;, &quot;If&quot;} will put the template in a menu called &quot;If&quot;, within &quot;Control&quot;, within the top menu &quot;Statement&quot;. When no path is defined, GAMA will try to guess it from the context where the template is defined (i.e. keyword of the statement, etc.)name (String, &quot;&quot; by default): The name of the template should be both concise (as it will appear in a menu) and precise (to remove ambiguities between templates).examples (set of @example, empty by default): An array of String representing some examples or use-cases about how to use this element, related to the particular usage above.pattern (String, &quot;&quot; by default): Alternatively, the contents of the usage can be described using a @pattern (rather than an array of @example). The formatting of this string depends entirely on the user (e.g. including \\n and \\t for indentation, for instance). "},{"title":"@validator​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#validator","content":"It allows to declare a custom validator for Symbols (statements, var declarations, species, experiments, etc.). This validator, if declared on subclasses of Symbol, will be called after the standard validation is done. The validator must be a subclass of IDescriptionValidator. value (Class): the validator class. "},{"title":"@variable​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#variable","content":"This annotation is used to describe a single variable or field. This annotation contains: name (String): the name of the variable as it can be used in GAML.type (int): The textual representation of the type of the variable (see IType).of (int, 0 by default): The textual representation of the content type of the variable (see IType#defaultContentType()).index (int, 0 by default): The textual representation of the index type of the variable (see IType#defaultKeyType()).constant (boolean, false by default): returns whether or not this variable should be considered as non modifiable.init (String, &quot;&quot; by default): the initial value of this variable as a String that will be interpreted by GAML.depend_on (set of Strings, empty by default): an array of String representing the names of the variables on which this variable depends (so that they are computed before).internal (boolean, false by default): return whether this var is for internal use only.doc (set of @doc, empty by default): the documentation associated to the variable. "},{"title":"@vars​","type":1,"pageTitle":"Index of annotations","url":"wiki/DevelopingIndexAnnotations#vars","content":"This annotation is used to describe a set of variables or fields. This annotation contains: value (set of @var): an Array of var instances, each representing a variable. "},{"title":"Developing Operators","type":0,"sectionRef":"#","url":"wiki/DevelopingOperators","content":"","keywords":""},{"title":"Implementation​","type":1,"pageTitle":"Developing Operators","url":"wiki/DevelopingOperators#implementation","content":"A new operator can be any Java method that: begins by the @operator (other fields can be added to the annotation): @operator(value = &quot;name_of_the_operator_gaml&quot;), @operator(value = &quot;rgb&quot;) public static GamaColor rgb(final int r, final int g, final int b, final double alpha) {  The method: must return a value (that has to be one of the GAMA Type: Integer, Double, Boolean, String, IShape, IList, IGraph, IAgent...),can define any number of parameters, defined using Java type,can be either static or non-static: in the case it is static, the number of parameters (except an IScope attribute) of the method is equal to the number of operands of the GAML operator.in the case it is not static, a first operand is added to the operator with the type of the current class. can have a IScope parameter, that will be taken into account as operand of the operator. "},{"title":"Annotations​","type":1,"pageTitle":"Developing Operators","url":"wiki/DevelopingOperators#annotations","content":""},{"title":"@operator​","type":1,"pageTitle":"Developing Operators","url":"wiki/DevelopingOperators#operator","content":"This annotation represents an &quot;operator&quot; in GAML, and is used to define its name(s) as well as some meta-data that will be used during the validation process. This annotation contains: value (set of string, empty by default): names of the operator.content_type (integer) : if the operator returns a container, type of elements contained in the containercan_be_const (boolean, false by default): if true: if the operands are constant, returns a constant value.category (set of string, empty by default): categories to which the operator belong (for documentation purpose).doc (set of @doc, empty by default): the documentation attached to this operator. "},{"title":"@doc​","type":1,"pageTitle":"Developing Operators","url":"wiki/DevelopingOperators#doc","content":"It provides a unified way of attaching documentation to the various GAML elements tagged by the other annotations. The documentation is automatically assembled at compile time and also used at runtime in GAML editors. value (String, &quot;&quot; by default): a String representing the documentation of a GAML element.deprecated (String, &quot;&quot; by default): a String indicating (if it is not empty) that the element is deprecated and defining, if possible, what to use instead.returns (String, &quot;&quot; by default): the documentation concerning the value(s) returned by this element (if any)..comment (String, &quot;&quot; by default): an optional comment that will appear differently from the documentation itself.special_cases (set of Strings, empty by default): an array of String representing the documentation of the &quot;special cases&quot; in which the documented element takes part.examples (set of Strings, empty by default): an array of String representing some examples or use-cases about how to use this element.see (set of Strings, empty by default): an array of String representing cross-references to other elements in GAML. All these annotations are defined in the GamlAnnotations.java file of the msi.gama.processor plug-in. "},{"title":"Developing Plugins","type":0,"sectionRef":"#","url":"wiki/DevelopingPlugins","content":"","keywords":""},{"title":"Creation of a plug-in​","type":1,"pageTitle":"Developing Plugins","url":"wiki/DevelopingPlugins#creation-of-a-plug-in","content":"Here are detailled steps to create and configure a new GAMA plug-in. File &gt; New &gt; Project &gt; plug-in projectIn the &quot;New plug-in Project&quot; / &quot;Plug-in project&quot; window: Choose as name « name_of_the_plugin » (or anything else)Check &quot;Use défaut location&quot;Check &quot;Create a Java Project&quot;The project should be targeted to run with Eclipseworking set is uncheckedClick on &quot;Next&quot; In the &quot;New plug-in Project&quot; / &quot;Content&quot; window: Id : could contain the name of your institution and/or your project, e.g. « irit.maelia.gaml.additions »version 1.0.0.qualifier (this latter mention is important if you plan on distributing the plugin on GAMA update site)Name « Additions to GAML from Maelia project »Uncheck &quot;Generate an activator, a Java class that controls the plug-in's life cycle&quot; ,Uncheck &quot;This plug-in will make contributions to the UI&quot;Check &quot;No&quot; when it asks &quot;Would you like to create a rich client application ?&quot;Click on &quot;Next&quot; In the &quot;New plug-in Project&quot; / &quot;Templates&quot; window: Uncheck &quot;Create a plug-in using one of the templates&quot;Click on &quot;Finish&quot; Your plug-in has been created. Edit the file &quot;Manifest.MF&quot;: Overview pane: check « This plug-in is a singleton » Dependencies pane: add (at least minimum) the two plug-ins &quot;msi.gama.core&quot; and &quot;msi.gama.ext&quot; in the &quot;Required Plug-ins&quot;. When you click on &quot;Add&quot;, a new window will appear without any plug-in. Just write the beginning of the plug-in name in the text field under &quot;Select a plug-in&quot;. Runtime pane: In exported Packages: nothing (but when you will have implemented new packages in the plug-in you should add them there)Add in the classpath all the additional libraries (.jar files) used in the project. Extensions pane: &quot;Add&quot; &quot;gaml.extension&quot; Save the file. This should create a &quot;plugin.xml&quot; file. Select the project and in menu Project &gt; Properties: Java Compiler &gt; Annotation Processing: check &quot;Enable project specific settings&quot;, then in &quot;Generated Source Directory&quot;, change &quot;.apt_generated&quot; to &quot;gaml&quot;,Java Compiler &gt; Annotation Processing &gt; Factory path: check &quot;Enable project specific settings&quot;, then &quot;Add Jars&quot; and choose &quot;msi.gama.processor/processor/plugins/msi.gama.processor.1.4.0.jar&quot;Close the menu. It should compile the project and create the gaml directory.Return in the Project &gt; Properties Menu.In Java Buildpath &gt; Source, check that the gaml directory has been added. Otherwise click on Add Folder and select the gaml directory The plug-in is ready to accept any addition to the GAML language, e.g. skills, actions, operators. Do not forget to export the created packages that could be used by &quot;clients&quot;, especially the packages containing the code of the additions (in the plugin.xml of the new project, tab &quot;Runtime&quot;). To test the plug-in and use it into GAMA, developers have to define a new feature project containing your plugin and its dependencies, and adds this feature to the existing product (or a new .product file of your own). The use of feature is also mandatory to define a plug-in that can be uploaded on the update site and can be installed in the release of GAMA. "},{"title":"Creation of a feature​","type":1,"pageTitle":"Developing Plugins","url":"wiki/DevelopingPlugins#creation-of-a-feature","content":"A feature is an Eclipse project dedicated to gather one or several plug-ins to integrate them into a product or to deploy them on the update site and install them from the GAMA release (a feature is mandatory in this case). Here are detailled steps to create and configure a new feature. File &gt; New &gt; Feature project (or File &gt; New &gt; Project... then Plug-in Development &gt; Feature Project)In Feature properties Choose a project name (e.g. &quot;institution.gama.feature.pluginsName&quot;)Click on &quot;Next&quot; In Referenced Plug-ins and fragments Check &quot;Initialize from the plug-ins list:&quot;Choose the plug-ins that have to be gathered in the featureClick on &quot;Finish&quot; A new project has been created. The &quot;feature.xml&quot; file will configure the feature. In &quot;Information pane&quot;: You can add description of the various plug-ins of the feature, define the copyright notice and the licence. In &quot;Plug-ins and Fragments&quot; In the Plug-ins and Fragments, additional plug-ins can be added. "},{"title":"Addition of a feature to the product​","type":1,"pageTitle":"Developing Plugins","url":"wiki/DevelopingPlugins#addition-of-a-feature-to-the-product","content":"In the product, e.g. gama.product in the ummisco.gama.product project: Contents pane Click on Add buttonIn the window select the featureClick on OK. Remark: To check whether the new plug-in has been taken into account by GAMA, after GAMA launch, it should appear in the Eclipse console in a line beginning by &quot;&gt;&gt; GAMA bundle loaded in &quot;. "},{"title":"Create examples model​","type":1,"pageTitle":"Developing Plugins","url":"wiki/DevelopingPlugins#create-examples-model","content":"In order to make your plugin usable by everyone, it is very important to bring potential users model examples to introduce new gaml primitives, statements and operators. This way, modelers can easily get into the plugin you developed in a practical way. The process is twofold: Mount your plugin into your GAMA (see below or use the Git version)Create a new project in the user model folder. Put your GAMA model examples there.Move your project into a folder called &quot;models&quot; at the root of the plugin  Hence this is done, you can update your Plugin models library folder and have access to the plugin models "},{"title":"How to make a plug-in available at GAMA update site for the GAMA release​","type":1,"pageTitle":"Developing Plugins","url":"wiki/DevelopingPlugins#how-to-make-a-plug-in-available-at-gama-update-site-for-the-gama-release","content":"Considering a working GAMA plugin named institution.gama.pluginsName "},{"title":"Configure plugin to be available for Maven​","type":1,"pageTitle":"Developing Plugins","url":"wiki/DevelopingPlugins#configure-plugin-to-be-available-for-maven","content":"a/ Add pom.xml for plugin institution.gama.pluginsName: Right click -&gt; Configure -&gt; Convert to maven project to add pom.xml:Set: Group id: institution.gama.pluginsNameArtifact id: institution.gama.pluginsNameVersion: 1.0.0-SNAPSHOT // must have -SNAPSHOT if the plugin version is x.x.x.qualifierPackaging: eclipse-plugin // this element is not in the list (jar/pom/war) because of the incompatible of tycho, maven and eclipse, so just type it in although it will be a warning Finish b/ Configure pom.xml to recognize the parent pom.xml for Maven builds Open pom.xml in institution.gama.pluginsNameTab overview, Parent section, type in: Group id: msi.gamaArtifact id: msi.gama.experimental.parentVersion: 1.7.0-SNAPSHOTRelative path: ../msi.gama.experimental.parent Save c/ Update maven cache in eclipse (optional) It will fix this compilation error &quot;Project configuration is not up-to-date with pom.xml. Select: Maven-&gt;Update Project... from the project context menu or use Quick Fix.&quot; Right click -&gt; Maven -&gt; Update project "},{"title":"Create a feature for the plugin​","type":1,"pageTitle":"Developing Plugins","url":"wiki/DevelopingPlugins#create-a-feature-for-the-plugin","content":"a/ Create new feature New -&gt; Project -&gt; type in : feature -&gt; Select &quot;Feature Project&quot;Set: Project name: institution.gama.feature.pluginsNameUncheck use default location, type in: {current git repository}\\aaa.bbb.feature.cccFeature Version: 1.0.0.qualifierUpdate Site URL: http://updates.gama-platform.org/experimentalUpdate Site Name: GAMA 1.7.x Experimental Plugins Update Site Click Next Initialize from the plugin list -&gt; check all plugins needed: institution.gama.pluginsName (1.0.0.qualifier) Finish b/ Add pom.xml for feature institution.gama.feature.pluginsName: Right click -&gt; Configure -&gt; Convert to maven project (to add pom.xml)Set: Group id: institution.gama.feature.pluginsNameArtifact id: institution.gama.feature.pluginsNameVersion: 1.0.0-SNAPSHOT Packaging: eclipse-feature Finish c/ Configure pom.xml to recognize the parent pom.xml for Maven builds Open pom.xml in institution.gama.pluginsNameTab overview, Parent section, type in: Group id: msi.gamaArtifact id: msi.gama.experimental.parentVersion: 1.7.0-SNAPSHOTRelative path: ../msi.gama.experimental.parent Save d/ Update maven cache in eclipse (optional) It will fix this compilation error &quot;Project configuration is not up-to-date with pom.xml. Select: Maven-&gt;Update Project... from the project context menu or use Quick Fix.&quot; Right click -&gt; Maven -&gt; Update project "},{"title":"Update p2updatesite category.xml (this step will be done automatically by travis, soon)​","type":1,"pageTitle":"Developing Plugins","url":"wiki/DevelopingPlugins#update-p2updatesite-categoryxml-this-step-will-be-done-automatically-by-travis-soon","content":"Open msi.gama.experimental.p2updatesite Tab Managing the Categories -&gt; Add feature -&gt; institution.gama.feature.pluginsName "},{"title":"How to make a plug-in available as an extension for the GAMA release (obsolete)​","type":1,"pageTitle":"Developing Plugins","url":"wiki/DevelopingPlugins#how-to-make-a-plug-in-available-as-an-extension-for-the-gama-release-obsolete","content":"Once the plug-in has been tested in the GAMA SVN version, it can be made available for GAMA release users. First, the update_site should be checked out from the SVN repository: File &gt; New &gt; Other... &gt; SVN &gt; Project from SVNIn Checkout Project from SVN repository Use existing repository location (it is the same location as for the GAMA code)Next In Select resource: Browse choose svn &gt; update_site Finish Finish Now the update_site project is available in the project list (in Package Explorer). The sequel describes how to add a new feature to the update site. Open the site.xml fileIn update site Map: Click on Extensionsclick on the Add Feature... button Choose the feature to be addedIt should appear in Extensions Select the added feature and click on the Synchronize... button Check Synchronize selected features onlyFinish Select the added feature and click on the Build button All the files and folder of the update_site project have been modified.Commit all the modifications on the SVN repository Richt-click on the project, Team &gt; UpdateRicht-click on the project, Team &gt; Commit... The plug-in is now available as an extension from the GAMA release. More details about the update of the GAMA release are available on the dedicated page. "},{"title":"Developing Skills","type":0,"sectionRef":"#","url":"wiki/DevelopingSkills","content":"","keywords":""},{"title":"Defining the class​","type":1,"pageTitle":"Developing Skills","url":"wiki/DevelopingSkills#defining-the-class","content":"A Skill is basically a singleton and stateless Java class that: extends the abstract class Skill,begins by the annotation @skill: @skill(name = &quot;name_of_the_skill_in_gaml&quot;). Note: GAMA annotations are classes defined into the msi.gama.precompiler.GamlAnnotations class. "},{"title":"Defining new attributes​","type":1,"pageTitle":"Developing Skills","url":"wiki/DevelopingSkills#defining-new-attributes","content":"To add new attributes to the species that declares this skill, developers have to define them before the class using the @vars and @variable annotations. The @vars annotation contains a set of @variable elements. In a @variable element, one has to define the name, the type and the default value of the attribute. For example in MovingSkill: @vars({ @variable(name = IKeyword.SPEED, type = IType.FLOAT, init = &quot;1.0&quot;), @variable(name = IKeyword.HEADING, type = IType.INT, init = &quot;rnd(359)&quot;) })  In order to detail how to access these new attributes (if needed), developers have to define a getter (using @getter) and a setter (using @setter) methods. If no getter (and setter) is defined, the attribute can nevertheless be set and get, using implicit by default getter and setter. But as soon as a getter and/or a setter is defined, they replace the implicit default ones. For example: @getter(IKeyword.SPEED) public double getSpeed(final IAgent agent) { return (Double) agent.getAttribute(IKeyword.SPEED); } @setter(IKeyword.SPEED) public void setSpeed(final IAgent agent, final double s) { agent.setAttribute(IKeyword.SPEED, s); }  "},{"title":"Defining new actions​","type":1,"pageTitle":"Developing Skills","url":"wiki/DevelopingSkills#defining-new-actions","content":"An action (also called primitive) is basically a Java method that can be called from the GAML language using the same syntax as the one used for calling actions defined in a model. The method should be annotated with @action, supplying the name of the action as it will be available in GAML. The developer can also define parameters for this action using the annotation @arg will a set of parameters names. For example, the action goto of the MovingSkill is defined as follows: @action(name=&quot;goto&quot;, args={ @arg(name = &quot;target&quot;, type = { IType.AGENT, IType.POINT,IType.GEOMETRY }, optional = false), @arg(name = IKeyword.SPEED, type = IType.FLOAT, optional = true), @arg(name = &quot;on&quot;, type = { IType.GRAPH }, optional = true) } ) public IPath primGoto(final IScope scope) throws GamaRuntimeException { ... }  It is called in GAMA models with: do goto (target: the_target, on: the_graph);  or path path_followed &lt;- self goto (target: the_target, on: the_graph, return_path: true);  "},{"title":"Access to parameters in actions​","type":1,"pageTitle":"Developing Skills","url":"wiki/DevelopingSkills#access-to-parameters-in-actions","content":"To get the value of the arguments passed in GAML to the Java code, two methods can be useful: scope.hasArg(&quot;name_of_argument&quot;) returns a boolean value testing whether the argument &quot;name_of_argument&quot; has been defined by the modeler, since all the arguments to actions should be considered as optional.getArg(name_arg,IType), getFloatArg(name_param_of_float), getIntArg(name_param_of_int) and their variants return the value of the given parameter using a given (or predefined) type to cast it. "},{"title":"Warnings​","type":1,"pageTitle":"Developing Skills","url":"wiki/DevelopingSkills#warnings","content":"Developers should notice that: the method associated with an action has to return a non-void object.the method should have only one parameter: the scope (type IScope).the method can only throw GamaRuntimeExceptions. Other exceptions should be caught in the method and wrapped in a GamaRuntimeException before being thrown. "},{"title":"Annotations​","type":1,"pageTitle":"Developing Skills","url":"wiki/DevelopingSkills#annotations","content":""},{"title":"@skill​","type":1,"pageTitle":"Developing Skills","url":"wiki/DevelopingSkills#skill","content":"This annotations Allows to define a new skill (class grouping variables and actions that can be used by agents). This annotation contains: name (String): a String representing the skill name in GAML (must be unique throughout GAML).attach_to (set of strings): an array of species names to which the skill will be automatically added (complements the &quot;skills&quot; parameter of species).internal (boolean, false by default): return whether this skill is for internal use only.doc (set of @doc, empty by default): the documentation associated to the skill. "},{"title":"@variable​","type":1,"pageTitle":"Developing Skills","url":"wiki/DevelopingSkills#variable","content":"This annotations is used to describe a single variable or field. This annotation contains: name (String): the name of the variable as it can be used in GAML.type (int): The textual representation of the type of the variable (see IType).of (int, 0 by default): The textual representation of the content type of the variable (see IType#defaultContentType()).index (int, 0 by default): The textual representation of the index type of the variable (see IType#defaultKeyType()).constant (int, false by default): returns whether or not this variable should be considered as non modifiable.init (String, &quot;&quot; by default): the initial value of this variable as a String that will be interpreted by GAML.depend_on (set of Strings, empty by default): an array of String representing the names of the variables on which this variable depends (so that they are computed before).internal (boolean, false by default): return whether this var is for internal use only.doc (set of @doc, empty by default): the documentation associated to the variable. "},{"title":"@doc​","type":1,"pageTitle":"Developing Skills","url":"wiki/DevelopingSkills#doc","content":"It provides a unified way of attaching documentation to the various GAML elements tagged by the other annotations. The documentation is automatically assembled at compile time and also used at runtime in GAML editors. value (String, &quot;&quot; by default): a String representing the documentation of a GAML element.deprecated (String, &quot;&quot; by default): a String indicating (if it is not empty) that the element is deprecated and defining, if possible, what to use instead.returns (String, &quot;&quot; by default): the documentation concerning the value(s) returned by this element (if any)..comment (String, &quot;&quot; by default): an optional comment that will appear differently from the documentation itself.special_cases (set of Strings, empty by default): an array of String representing the documentation of the &quot;special cases&quot; in which the documented element takes part.examples (set of Strings, empty by default): an array of String representing some examples or use-cases about how to use this element.see (set of Strings, empty by default): an array of String representing cross-references to other elements in GAML. "},{"title":"@getter​","type":1,"pageTitle":"Developing Skills","url":"wiki/DevelopingSkills#getter","content":"This annotations is used to indicate that a method is to be used as a getter for a variable defined in the class. The variable must be defined on its own (in vars). This annotation contains: value (String): the name of the variable for which the annotated method is to be considered as a getter.initializer (boolean, false by default): returns whether or not this getter should also be used as an initializer "},{"title":"@setter​","type":1,"pageTitle":"Developing Skills","url":"wiki/DevelopingSkills#setter","content":"This annotations is used to indicate that a method is to be used as a setter for a variable defined in the class. The variable must be defined on its own (in vars). This annotation contains: value (String): the name of the variable for which the annotated method is to be considered as a setter. "},{"title":"@action​","type":1,"pageTitle":"Developing Skills","url":"wiki/DevelopingSkills#action","content":"This annotations is used to tag a method that will be considered as an action (or primitive) in GAML. The method must have the following signature: Object methodName(IScope) throws GamaRuntimeException and be contained in a class annotated with @species or @skill (or a related class, like a subclass or an interface). This annotation contains: name (String): the name of the variable as it can be used in GAML.virtual (boolean, false by default): if true the action is virtual, i.e. equivalent to abstract method in java.args (set of arg, empty by default): the list of arguments passed to this action. Each argument is an instance of arg.doc (set of @doc, empty by default): the documentation associated to the action. "},{"title":"@arg​","type":1,"pageTitle":"Developing Skills","url":"wiki/DevelopingSkills#arg","content":"This annotations describes an argument passed to an action. This annotation contains: name (String, &quot;&quot; by default): the name of the argument as it can be used in GAML.type (set of ints, empty by default): An array containing the textual representation of the types that can be taken by the argument (see IType).optional (boolean, true by default): whether this argument is optional or not.doc (set of @doc, empty by default): the documentation associated to the argument. All these annotations are defined in the GamlAnnotations.java file of the msi.gama.processor plug-in. "},{"title":"Developing Species","type":0,"sectionRef":"#","url":"wiki/DevelopingSpecies","content":"","keywords":""},{"title":"Implementation​","type":1,"pageTitle":"Developing Species","url":"wiki/DevelopingSpecies#implementation","content":"A new species can be any Java class that: extends the GamlAgent class,begins by the @species: @species(name = &quot;name_of_the_species_gaml&quot;), @species(name = &quot;multicriteria_analyzer&quot;) public class MulticriteriaAnalyzer extends GamlAgent {  Similarly to skills, a species can define additional attributes and actions. "},{"title":"Additional attributes​","type":1,"pageTitle":"Developing Species","url":"wiki/DevelopingSpecies#additional-attributes","content":"Defining new attributes needs: to add @vars (and one embedded @var per additional attribute) annotation on top of the class,to define @setter and @getter annotations to the accessors methods. For example, regular species are defined with the following annotation: @vars({ @var(name = IKeyword.NAME, type = IType.STRING), @var(name = IKeyword.PEERS, type = IType.LIST), @var(name = IKeyword.HOST, type = IType.AGENT), @var(name = IKeyword.LOCATION, type = IType.POINT, depends_on = IKeyword.SHAPE), @var(name = IKeyword.SHAPE, type = IType.GEOMETRY) })  And accessors are defined using: @getter(IKeyword.NAME) public abstract String getName(); @setter(IKeyword.NAME) public abstract void setName(String name);  "},{"title":"Additional actions​","type":1,"pageTitle":"Developing Species","url":"wiki/DevelopingSpecies#additional-actions","content":"An additional action is a method annotated by the @action annotation. @action(name = ISpecies.stepActionName) public Object _step_(final IScope scope) {  "},{"title":"Annotations​","type":1,"pageTitle":"Developing Species","url":"wiki/DevelopingSpecies#annotations","content":""},{"title":"@species​","type":1,"pageTitle":"Developing Species","url":"wiki/DevelopingSpecies#species","content":"This annotation represents a &quot;species&quot; in GAML. The class annotated with this annotation will be the support of a species of agents. This annotation contains: name (string): the name of the species that will be created with this class as base. Must be unique throughout GAML.skills (set of strings, empty by default): An array of skill names that will be automatically attached to this species. Example: @species(value=&quot;animal&quot; skills={&quot;moving&quot;})internal (boolean, false by default): whether this species is for internal use only.doc (set of @doc, empty by default): the documentation attached to this operator. All these annotations are defined in the GamlAnnotations.java file of the msi.gama.processor plug-in. "},{"title":"Developing Types","type":0,"sectionRef":"#","url":"wiki/DevelopingTypes","content":"","keywords":""},{"title":"Implementation​","type":1,"pageTitle":"Developing Types","url":"wiki/DevelopingTypes#implementation","content":"Developing a new type requires the implementation of 2 Java files: the first one that describes the data structure (e.g.: GamaColor.java to define a type color)the second one that implements the type itself, wrapping the data structure file (e.g.: GamaColorType.java), and providing accessors to data structure attributes. "},{"title":"The data structure file​","type":1,"pageTitle":"Developing Types","url":"wiki/DevelopingTypes#the-data-structure-file","content":"The class representing the data structure is a Java class annotated by: a @vars annotation to describe the attributes of a complex type. The @vars annotation contains a set of @variable elements. @vars ({ @variable ( name = &quot;red&quot;, type = IType.INT, doc = { @doc (&quot;Returns the red component of the color (between 0 and 255)&quot;) }), @variable ( name = &quot;green&quot;, type = IType.INT, doc = { @doc (&quot;Returns the green component of the color (between 0 and 255)&quot;) }), @variable ( name = &quot;blue&quot;, type = IType.INT, doc = { @doc (&quot;Returns the blue component of the color (between 0 and 255)&quot;) }), })  It is recommended that this class implements the IValue interface. It provides a clean way to give a string representation of the type and thus eases good serialization of the object. You will need to implement the stringValue method: public class GamaColor implements IValue { @Override public String stringValue(IScope scope) throws GamaRuntimeException { ... } }  You should also have some class attributes that correspond to your custom data type's attributes public class GamaColor implements IValue { private int red; private int green; private int blue; ... }  and then you can create setters and/or getters for each of the attributes. Setters and getters are methods annotated by the @getter or @setter annotations. @getter(&quot;red&quot;) public Integer getRed() { return this.red; } @setter(&quot;red&quot;) public void setRed(int red) { this.red = red; }  "},{"title":"The type file​","type":1,"pageTitle":"Developing Types","url":"wiki/DevelopingTypes#the-type-file","content":"The class representing the type is a Java class such that: the class should be annotated by the @type annotation,the class should extend the class GamaType&amp;lt;DataStructureFile&gt; (and thus implement its 3 methods), Example (from GamaFloatType.java): @type( name = IKeyword.FLOAT, id = IType.FLOAT, wraps = { Double.class,double.class }, kind = ISymbolKind.Variable.NUMBER, doc = { @doc(&quot;Represents floating point numbers (equivalent to Double in Java)&quot;) }, concept = { IConcept.TYPE }) public class GamaFloatType extends GamaType&amp;lt;Double&gt; {  "},{"title":"Inheritance from the GamaType&lt;T> class​","type":1,"pageTitle":"Developing Types","url":"wiki/DevelopingTypes#inheritance-from-the-gamatypeltt-class","content":"Each java class aiming at implementing a type should inherit from the GamaType abstract class. Example (from GamaColorType.java): public class GamaColorType extends GamaType&amp;lt;GamaColor&gt;  This class imposes to implement the three following methods (with the example of the GamaColorType): public boolean canCastToConst()public GamaColor cast(IScope scope, Object obj, Object param): the way to cast any object in the type,public GamaColor getDefault(): to define the default value of a variable of the current type. Remark: for each type, a unary operator is created with the exact name of the type. It can be used to cast any expression in the given type. This operator calls the previous cast method. "},{"title":"Annotations​","type":1,"pageTitle":"Developing Types","url":"wiki/DevelopingTypes#annotations","content":""},{"title":"@type​","type":1,"pageTitle":"Developing Types","url":"wiki/DevelopingTypes#type","content":"It provides information necessary to the processor to identify a type. This annotation contains: name (String, &quot;&quot; by default): a String representing the type name in GAML.id (int, 0 by default): the unique identifier for this type. User-added types can be chosen between IType.AVAILABLE_TYPE and IType.SPECIES_TYPE (exclusive) (cf. IType.java).wraps (tab of Class, null by default): the list of Java Classes this type is &quot;wrapping&quot; (i.e. representing). The first one is the one that will be used preferentially throughout GAMA. The other ones are to ensure compatibility, in operators, with compatible Java classes (for instance, List and GamaList).kind (int, ISymbolKind.Variable.REGULAR by default): the kind of Variable used to store this type. See ISymbolKind.Variable.internal (boolean, false by default): whether this type is for internal use only.doc (set of @doc, empty by default): the documentation associated to the facet. All these annotations are defined in the file GamlAnnotations.java. "},{"title":"Developing Statements","type":0,"sectionRef":"#","url":"wiki/DevelopingStatements","content":"","keywords":""},{"title":"Defining the class​","type":1,"pageTitle":"Developing Statements","url":"wiki/DevelopingStatements#defining-the-class","content":"A new statement must be a Java class that: either implements the interface IStatement or extends an existing implementation of this interface (like AbstractStatement or AbstractSequenceStatement).begins by the 2 following mandatory annotations: @symbol: @symbol(name = &quot;name_of_the_statement_gaml&quot;, kind = &quot;kind_of_statement&quot;, with_sequence = true/false),@inside: @symbol(kinds = {&quot;kind_of_statement_1&quot;,&quot;kind_of_statement_2&quot;,&quot;...&quot;} In addition the 4 following optional annotations can be added: @facets: to describe the set of @facet annotations,@doc: to document the statement.@serializer: in addition, statements can benefit from a custom serializer, by declaring @serializer(CustomSerializer.class), with a class extending SymbolSerializer.@validator: in addition, statements can benefit from a custom validation during the validation process, by declaring @validator(CustomValidator.class) with a class implementing IDescriptionValidator as value. This class will receive the IDescription of the statement and be able to execute further validations on the type of expressions, etc. or even to change the IDescription (by adding new information, changing the value of facets, etc.). Note: GAMA annotations are classes defined into the msi.gama.precompiler.GamlAnnotations class. "},{"title":"Examples​","type":1,"pageTitle":"Developing Statements","url":"wiki/DevelopingStatements#examples","content":""},{"title":"The write statement​","type":1,"pageTitle":"Developing Statements","url":"wiki/DevelopingStatements#the-write-statement","content":"The write statement is an example of a SINGLE_STATEMENT (i.e. statement that does not embed a sequence of statements). It can used inside a BEHAVIOR statement (i.e. reflex, init...), a SEQUENCE_STATEMENT (e.g. loop, ask, if...) or a LAYER statement. It defines a single facet (&quot;message&quot;) mandatory and omissible. @symbol(name = IKeyword.WRITE, kind = ISymbolKind.SINGLE_STATEMENT, with_sequence = false) @inside(kinds = { ISymbolKind.BEHAVIOR, ISymbolKind.SEQUENCE_STATEMENT, ISymbolKind.LAYER }) @facets(value = { @facet(name = IKeyword.MESSAGE, type = IType.NONE, optional = false) }, omissible = IKeyword.MESSAGE) public class WriteStatement extends AbstractStatement {  "},{"title":"The aspect statement​","type":1,"pageTitle":"Developing Statements","url":"wiki/DevelopingStatements#the-aspect-statement","content":"The aspect statement defines an example of BEHAVIOR statement (i.e. a statement that can written at the same level as init, reflex...), containing a sequence of embedded statements. It can only be used inside a species statement (i.e. the definition of a new species) and the global block. It defines a single facet name mandatory and omissible. @symbol(name = { IKeyword.ASPECT }, kind = ISymbolKind.BEHAVIOR, with_sequence = true, unique_name = true) @inside(kinds = { ISymbolKind.SPECIES, ISymbolKind.MODEL }) @facets(value = { @facet(name = IKeyword.NAME, type = IType.ID, optional = true) }, omissible = IKeyword.NAME) public class AspectStatement extends AbstractStatementSequence {  "},{"title":"The action statement​","type":1,"pageTitle":"Developing Statements","url":"wiki/DevelopingStatements#the-action-statement","content":"The action statement defines an example of ACTION statement containing a sequence of embedded statements and that can have arguments. It can be used (to define an action) in any species, experiment or global statement. It defines several facets and uses a custom validator and a custom serializer. @symbol(name = IKeyword.ACTION, kind = ISymbolKind.ACTION, with_sequence = true, with_args = true, unique_name = true) @inside(kinds = { ISymbolKind.SPECIES, ISymbolKind.EXPERIMENT, ISymbolKind.MODEL }) @facets(value = { @facet(name = IKeyword.NAME, type = IType.ID, optional = false), @facet(name = IKeyword.TYPE, type = IType.TYPE_ID, optional = true, internal = true), @facet(name = IKeyword.OF, type = IType.TYPE_ID, optional = true, internal = true), @facet(name = IKeyword.INDEX, type = IType.TYPE_ID, optional = true, internal = true), @facet(name = IKeyword.VIRTUAL, type = IType.BOOL, optional = true) }, omissible = IKeyword.NAME) @validator(ActionValidator.class) @serializer(ActionSerializer.class) public class ActionStatement extends AbstractStatementSequenceWithArgs {  "},{"title":"Implementation​","type":1,"pageTitle":"Developing Statements","url":"wiki/DevelopingStatements#implementation","content":"All the statements inherit from the abstract class AbstractStatement. Statements with a sequence of embedded statements inherit from the class AbstractStatementSequence (which extends AbstractStatement). The main methods of a statement class are: its constructor, that is executed at the compilation of the model.executeOn(final IScope scope), it executes the statement on a given scope. This method is executed at each call of the statement in the model,privateExecuteIn(IScope scope): the executeOn(final IScope scope) method implemented in AbstractStatement does some verification and call the privateExecuteIn(IScope scope) method to perform the statement. The execution of any statement should be redefined in this method. "},{"title":"Define a SINGLE_STATEMENT statement​","type":1,"pageTitle":"Developing Statements","url":"wiki/DevelopingStatements#define-a-single_statement-statement","content":"To define a SINGLE_STATEMENT statement that can be executed in any behavior and sequence of statements and with 2 facets, we first define a new Java class that extends AbstractStatement such as: @symbol(name = &quot;testStatement&quot;, kind = ISymbolKind.SINGLE_STATEMENT, with_sequence = false) @inside(kinds = { ISymbolKind.BEHAVIOR, ISymbolKind.SEQUENCE_STATEMENT}) @facets(value = { @facet(name = IKeyword.NAME, type = IType.NONE, optional = false), @facet(name = &quot;test_facet&quot;, type = IType.NONE, optional = true) }, omissible = IKeyword.NAME) public class SingleStatementExample extends AbstractStatement {  The class should at least implement: a constructor: the constructor is called at the compilation. It is usually used to get the expressions given to the facets (using the getFacet(String) method) and to store it into an attribute of the class. final IExpression name; public SingleStatementExample(final IDescription desc) { super(desc); name = getFacet(IKeyword.NAME); }  the method privateExecuteIn: this method is executed each time the statement is called in the model. protected Object privateExecuteIn(IScope scope) throws GamaRuntimeException { IAgent agent = scope.getAgent(); String nameStr = null; if (agent != null &amp;&amp; !agent.dead()) { nameStr = Cast.asString(scope, name.value(scope)); if (nameStr == null) { nameStr = &quot;nil&quot;; } scope.getGui().getConsole().informConsole(nameStr, scope.getRoot()); } return nameStr; }  The variable scope of type IScope can be used to: get the current agent with: scope.getAgent()evaluate an expression in the current scope: Cast.asString(scope, message.value(scope)) "},{"title":"Define a statement with sequence​","type":1,"pageTitle":"Developing Statements","url":"wiki/DevelopingStatements#define-a-statement-with-sequence","content":"This kind of statements includes SEQUENCE_STATEMENT (e.g. if, loop,...), BEHAVIOR (e.g. reflex,...)... Such a statement is defined in a class extending the AbstractStatementSequence class, e.g.: @symbol(name = { IKeyword.REFLEX, IKeyword.INIT }, kind = ISymbolKind.BEHAVIOR, with_sequence = true, unique_name = true) @inside(kinds = { ISymbolKind.SPECIES, ISymbolKind.EXPERIMENT, ISymbolKind.MODEL }) @facets(value = { @facet(name = IKeyword.WHEN, type = IType.BOOL, optional = true), @facet(name = IKeyword.NAME, type = IType.ID, optional = true) }, omissible = IKeyword.NAME) @validator(ValidNameValidator.class) public class ReflexStatement extends AbstractStatementSequence {  This class should only implement a constructor. The class AbstractStatementSequence provides a generic implementation for: privateExecuteIn(IScope scope): it executes each embedded statement with the scope.executeOn(final IScope scope): it executes the statement with a given scope. "},{"title":"Additional methods that can be implemented​","type":1,"pageTitle":"Developing Statements","url":"wiki/DevelopingStatements#additional-methods-that-can-be-implemented","content":"The following methods have a default implementation, but can be overridden if necessary: the String getTrace(final IScope scope) method is called to trace the execution of statements using trace statement. public String getTrace(final IScope scope) { // We dont trace write statements return &quot;&quot;; }  the setChildren(final List&amp;lt;? extends ISymbol&gt; commands) is used to define which are the statement children to the sequence statement. By default, all the embedded statements are taken as children "},{"title":"Annotations​","type":1,"pageTitle":"Developing Statements","url":"wiki/DevelopingStatements#annotations","content":""},{"title":"@symbol​","type":1,"pageTitle":"Developing Statements","url":"wiki/DevelopingStatements#symbol","content":"This annotation represents a &quot;statement&quot; in GAML, and is used to define its name(s) as well as some meta-data that will be used during the validation process. This annotation contains: name (set of string, empty by default): names of the statement.kind (int): the kind of the annotated symbol (see ISymbolKind.java for more details).with_scope (boolean, true by default): indicates if the statement (usually a sequence) defines its own scope. Otherwise, all the temporary variables defined in it are actually defined in the super-scope.with_sequence (boolean): indicates wether or not a sequence can or should follow the symbol denoted by this class.with_args (boolean, false by default): indicates wether or not the symbol denoted by this class will accept arguments.remote_context (boolean, false by default): indicates that the context of this statement is actually an hybrid context: although it will be executed in a remote context, any temporary variables declared in the enclosing scopes should be passed on as if the statement was executed in the current context.doc (set of @doc, empty by default): the documentation attached to this symbol. "},{"title":"@inside​","type":1,"pageTitle":"Developing Statements","url":"wiki/DevelopingStatements#inside","content":"This annotation is used in conjunction with symbol. Provides a way to tell where this symbol should be located in a model (i.e. what its parents should be). Either direct symbol names (in symbols) or generic symbol kinds can be used. This annotation contains: symbols (set of Strings, empty by default): symbol names of the parents.kinds (set of int, empty by default): generic symbol kinds of the parents (see ISymbolKind.java for more details). "},{"title":"@facets​","type":1,"pageTitle":"Developing Statements","url":"wiki/DevelopingStatements#facets","content":"This annotation describes a list of facets used by a statement in GAML. This annotation contains: value (set of @facet): array of @facet, each representing a facet name, type..ommissible (string): the facet that can be safely omitted by the modeler (provided its value is the first following the keyword of the statement). "},{"title":"@facet​","type":1,"pageTitle":"Developing Statements","url":"wiki/DevelopingStatements#facet","content":"This facet describes a facet in a list of facets. This annotation contains: name (String): the name of the facet. Must be unique within a symbol.type (set of Strings): the string values of the different types that can be taken by this facet.values (set of Strings): the values that can be taken by this facet. The value of the facet expression will be chosen among the values described here.optional (boolean, false by default): whether or not this facet is optional or mandatory.doc (set of @doc, empty by default): the documentation associated to the facet. "},{"title":"@doc​","type":1,"pageTitle":"Developing Statements","url":"wiki/DevelopingStatements#doc","content":"It provides a unified way of attaching documentation to the various GAML elements tagged by the other annotations. The documentation is automatically assembled at compile time and also used at runtime in GAML editors. value (String, &quot;&quot; by default): a String representing the documentation of a GAML element.deprecated (String, &quot;&quot; by default): a String indicating (if it is not empty) that the element is deprecated and defining, if possible, what to use instead.returns (String, &quot;&quot; by default): the documentation concerning the value(s) returned by this element (if any)..comment (String, &quot;&quot; by default): an optional comment that will appear differently from the documentation itself.special_cases (set of Strings, empty by default): an array of String representing the documentation of the &quot;special cases&quot; in which the documented element takes part.examples (set of Strings, empty by default): an array of String representing some examples or use-cases about how to use this element.see (set of Strings, empty by default): an array of String representing cross-references to other elements in GAML. "},{"title":"@serializer​","type":1,"pageTitle":"Developing Statements","url":"wiki/DevelopingStatements#serializer","content":"It allows to declare a custom serializer for Symbols (statements, var declarations, species, experiments, etc.). This serializer will be called instead of the standard serializer, superseding this last one. Serializers must be subclasses of the SymbolSerializer class. value (Class): the serializer class. "},{"title":"@validator​","type":1,"pageTitle":"Developing Statements","url":"wiki/DevelopingStatements#validator","content":"It allows to declare a custom validator for Symbols (statements, var declarations, species, experiments, etc.). This validator, if declared on subclasses of Symbol, will be called after the standard validation is done. The validator must be a subclass of IDescriptionValidator. value (Class): the validator class. All these annotations are defined in the GamlAnnotations.java file of the msi.gama.processor plug-in. "},{"title":"Using Differential Equations","type":0,"sectionRef":"#","url":"wiki/DifferentialEquations","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Using Differential Equations","url":"wiki/DifferentialEquations#introduction","content":"ODEs (Ordinary Differential Equations) models are often used in physics, chemistry, biology, ecology and epidemiology. They allow tracking continuous changes of a system, and offer the possibility of a mathematical analysis. The possibility to find a numerical solution (for a given Cauchy problem) of first order differential equations has been implemented in Gama. In population dynamics, systems of ODEs are used to describe the macroscopic evolution over time of a population, which is usually split into several compartments. The state of the population is described by the number of individuals in each compartment. Each equation of the ODE system describes the evolution of the number of individuals in a compartment. In such an approach, individuals are not taken into account individually, with own features and behaviors. On the contrary, they are aggregated and only the population density is considered. Compartmental models are widely used to represent the spread of a disease in a population, with a large variety of models derived from the classical Kermack-McKendrick model, often referred to as the SIR model. More information about compartmental models in epidemiology can be found here. In SIR class models, the population is split into 3 (or more) compartments: S (Susceptible), I (Infected), R (Recovered). It is not usually possible to find an analytical solution of the ODE system, and an approximate solution has to be found, using various numerical schemes (such as Euler, Runge-Kutta, Dormand-Prince...) "},{"title":"Example of a SIR model​","type":1,"pageTitle":"Using Differential Equations","url":"wiki/DifferentialEquations#example-of-a-sir-model","content":"In the SIR model, the population is split into 3 compartments: S (Susceptible), I (Infected), R (Recovered). Susceptible individuals become infected (move from compartment S to I) at a rate proportional to the size of both S and I populations. People recover (are removed from compartment I) at a constant rate. This can be represented by the following Forrester diagram: boxes represent compartments and arrows are flows. Arrows hold the rate of a compartment population flowing to another compartment.  The corresponding ODE system contains one equation per compartment. For example, the I compartment evolution is influenced by an inner (so positive) flow from the S compartment and an outer (so negative) flow to the R compartment.  Given an initial condition (initial values) at time t=0, such as S = 499I = 1R = 0beta = 0.4gamma = 0.1 h = 0.1 one can obtain the evolution of the evolution of S, I and R over time, by integrating the ODE system using a numerical scheme.  "},{"title":"Why and when can we use ODE in agent-based models?​","type":1,"pageTitle":"Using Differential Equations","url":"wiki/DifferentialEquations#why-and-when-can-we-use-ode-in-agent-based-models","content":"ODE models are often used when a system can be considered at a macro (population) level, i.e when the individual variability as little influence on dynamics at the aggregated level. It is relevant to use ODE in agent-based models in several cases: Large scale agent-based models require many resources to run and a very large computation time. For example, if we want to implement a model describing the worldwide epidemic spread and the impact of air traffic on it, we cannot simulate the 7 billion people. Instead we can represent only cities with airports and airplanes as agents. In this case, cities are entities are represented by a compartment, on which a SIR class epidemiological model can be run, using an ODE system. Such a model combines some advantages of agent-based models (detailed description of the disease spread from one city to another with the plane agents) and mathematical modeling (good description of an epidemiological dynamics at a city level, using fewer resources and less computation time). Some processes may be easier to manipulate at the aggregated level, for several reasons: 1) a global description of a system may turn sometimes more informative than a detailed one, 2) a detailed description may require to fit too many parameters for which there is no sufficient data, in that case it is easier to fit a global model with less parameters, and 3) when one wants to keep a low number of parameters, in order to avoid overfitting or to optimize Akaike Information Criterion. Some systems are better described with a continuous dynamics than with a discrete one. This is the case for many physical or biological systems (physics laws such as gravity or water dynamics, biological processes such as respiration or cell growth). Coupling ABM and ODE model allow considering individual/discrete processes along with continuous processes. Some models already exist in an ODE version, and could be coupled to another model in Gama without having to rewrite an Agent-Based version of the model. "},{"title":"Use of ODE in a GAML model​","type":1,"pageTitle":"Using Differential Equations","url":"wiki/DifferentialEquations#use-of-ode-in-a-gaml-model","content":"A stereotypical use of ODE in a GAMA agent-based model is to describe species where some agents attribute evolution is described using an ODE system. As a consequence, the GAML language has been increased by two main concepts (as two statements): equations can be written with the equation statement. An equation block is composed of a set of diff statement describing the evolution of species attributes.an equation can be numerically integrated using the solve statement Additionnally, Gama provides an intuitive, flexible and natural framework to build ODE models, since an ODE system may be split among several entities. For example, if there are three species (resp. agent) involved in a common dynamics, it is possible to declare each equation inside the corresponding species (resp. agent) definition. An example is shown below. "},{"title":"Defining and solving an ODE system​","type":1,"pageTitle":"Using Differential Equations","url":"wiki/DifferentialEquations#defining-and-solving-an-ode-system","content":""},{"title":"Defining an ODE system with equation​","type":1,"pageTitle":"Using Differential Equations","url":"wiki/DifferentialEquations#defining-an-ode-system-with-equation","content":"Defining a new ODE system needs to define a new equation block in a species. As an example, the following eqSI system describes the evolution of a population with 2 compartments (S and I) and the flow from S to I compartments: species userSI { float t ; float I ; float S ; int N ; float beta&lt;-0.4 ; float h ; equation eqSI { diff(S,t) = -beta * S * I / N ; diff(I,t) = beta * S * I / N ; } }  This equation has to be defined in a species with t, S and I attributes. beta (and other similar parameters) can be defined either in the specific species (if it is specific to each agent) or in the global if it is a constant. Note: it is mandatory to declare a differenciation variable (here t) as an attribute in the species. It is automatically updated using the solve statement and contains the time elapsed in the equation integration. "},{"title":"solve an ODE system​","type":1,"pageTitle":"Using Differential Equations","url":"wiki/DifferentialEquations#solve-an-ode-system","content":"Once the equation or system of equations has been defined, it is necessary to execute a solve statement inside a reflex in order to numerically integrate the ODE system. The reflex is executed at each cycle, and the values of the attributes used in the equations (S and I in the previous example) are updated with the values obtained by integrating the system between the start time end and end time of the current cycle. reflex solving { solve eqSI method: #rk4 step_size: h; }  Several numerical schemes are available to solve the ODE system. More details about the numerical schemes and the solve syntax are provided below. "},{"title":"Alternative way to define an ODE system​","type":1,"pageTitle":"Using Differential Equations","url":"wiki/DifferentialEquations#alternative-way-to-define-an-ode-system","content":""},{"title":"Split a system into several agents​","type":1,"pageTitle":"Using Differential Equations","url":"wiki/DifferentialEquations#split-a-system-into-several-agents","content":"An equation system can be split into several species and each part of the system are synchronized using the simultaneously facet of equation. The system split into several agents can be integrated using a single call to the solve statement. Notice that all the equation definition must have the same name. For example, the SI system presented above can be defined in two different species S_agt (containing the equation defining the evolution of the S value) and I_agt (containing the equation defining the evolution of the I value). These two equations are linked using the simultaneously facet of the equation statement. This facet expects a set of agents. The integration is called only once in a simulation step, e.g. in the S_agt agent. global { int N &lt;- 1000; float hRK4 &lt;- 0.01; } species S_agt { float t ; float Ssize ; equation evol simultaneously: [ I_agt ] { diff(Ssize, t) = (- sum(I_agt accumulate [each.beta * each.Isize]) * self.Ssize / N); } reflex solving {solve evol method: #rk4 step_size: hRK4 ;} } species I_agt { float t ; float Isize ; // number of infected float beta ; equation evol simultaneously: [ S_agt ] { diff(Isize, t) = (beta * first(S_agt).Ssize * Isize / N); } }  The interest is that the modeler can create several agents for each compartment, which different values. For example in the SI model, the modeler can choose to create 1 agent S_agt and 2 agents I_agt. The beta attribute will have different values in the two agents, in order to represent 2 different strains. global { int number_S &lt;- 495 ; // The number of susceptible int number_I &lt;- 5 ; // The number of infected int nb_I &lt;- 2; float gbeta &lt;- 0.3 ; // The parameter Beta int N &lt;- number_S + nb_I * number_I ; float hRK4 &lt;- 0.1 ; init { create S_agt { Ssize &lt;- float(number_S) ; } create I_agt number: nb_I { Isize &lt;- float(number_I) ; self.beta &lt;- myself.gbeta + rnd(0.5) ; } } }  The results are computed using the RK4 (Runge-Kutta 4) method with: number_S = 495 number_I = 5 nb_I = 2gbeta = 0.3 hKR4 = 0.1   Important note: the solve statement must be called once and only once per cycle. In this example, is it executed in the 'solving' reflex of the only S_agt agent. There is no 'solving' reflex in the I_agt agents: since the equations definitions blocks are connected through the simultaneously facet, there equation blocks will be integrated by the S_agt agent. Note also that if they were several S_agt agents, with the same definition of the 'solving' reflex, the solve statement would be executed several times, which could result in wrong results. To ensure that it is called only once, the 'solving' reflex should be rewritten. For example, it is possible to write this:  reflex solving when: (int(self)=0) {solve evol method: #rk4 step_size: hRK4 ;}  "},{"title":"More details​","type":1,"pageTitle":"Using Differential Equations","url":"wiki/DifferentialEquations#more-details","content":""},{"title":"Details about the solve statement​","type":1,"pageTitle":"Using Differential Equations","url":"wiki/DifferentialEquations#details-about-the-solve-statement","content":"The solve statement can have a huge set of facets (see this page for more details). The basic use of the solve statement requires only the equation identifier. By default, the integration method is Runge-Kutta 4 with a fixed integration step of 0.005*step, which means that each simulation step (cycle) is divided into 200 smaller integration steps that are used to simulate a continuous evolution of the system. For fixed integration step numerical schemes such as Runge-Kutta 4, the length of the integration step is defined in the step_size facet. Increasing the integration step results in faster computation at the cost of accuracy. Integration method with the method facet​ Several integration methods can be used in the method facet. GAMA relies on the Apache Commons Math library to provide numerical schemes; it thus provides access to the various solvers integrated into the library. The list of all the solver is detailed in this page, section 15.4 Available integrators. The GAML constants associated with each of them (to use in the method statement) are: ) Fixed Step Integrators #Euler for Euler. It implements the Euler integration method, which is mainly used for academic illustration of numerical schemes. It should not be used outside of this purpose due to its lack of precision (a very small integration step is required for an acceptable precision).#Midpoint for Midpoint#rk4 for Runge-Kutta 4. It implements the Runge-Kutta 4 integration method. It provides a faster convergence than the Euler method, and thus does not require very small integration steps. However the user has to determine manually the ideal integration step. For that reason, it is recommended to try first an adaptative stepsize integrator such as the Dorman-Prince 5(4) integration method.#Gill for Gill#ThreeEighthes for 3/8#Luther for Luther Adaptive Stepsize Integrators #HighamHall54 for Higham and Hall#DormandPrince54 for Dormand-Prince 5(4) It implements the Dorman-Prince 5(4) integration method. It is similar to the ode45in Matlab. This method is based on the Runge-Kutta solvers family. It evaluates the error between the numerical solution and the analytic solution, and adapt the integration step in order to minimize it. It is recommended to try this method first, even it may not the best one in case of stiff problems.#dp853 for Dormand-Prince 8(5,3). #GraggBulirschStoer for Gragg-Bulirsch-Stoer#AdamsBashforth for Adams-Bashforth#AdamsMoulton for Adams-Moulton Integration steps​ The length of the integration step has a huge impact on precision: a smaller integration step means more evaluation points, which results in a better precision but a longer computation time. In order to improve the precision of the integration or its speed, the integration step can be set using the step_size facet for fixed steps methods. step_size (float): integration step, use with most fixed steps integrator methods (default value: 0.005*step) Adaptative stepsize integrators (e.g. #DormandPrince54) automatically determine and set the integration step according to a given error tolerance. Some of them also use different integration steps all over the computation, since parts of the solution that are stable enough do not require a very small integration step, while parts with high variations need more precision. Such integrators require thus more information, through the following mandatory facets: min_step, max_step (float): these 2 values define the range of variation for the integration step. As an example, we can use: min_step:0.01 max_step:0.1.scalAbsoluteTolerance and scalRelativeTolerance (float): they defined the allowed absolute (resp. relative) error. As an example, we can use: scalAbsoluteTolerance:0.0001 scalRelativeTolerance:0.0001. Synchronization between simulation and integration​ The simulation and the integration are synchronized: if one simulation step represents 1 second, then one call of the solve statement will integrate over 1s in the ODE system. This means that the step attribute of the global has an impact on the integration. See below to observe this influence. It is thus important to specify the unit of the parameters used in the ODE system (in particular relatively to time). It is also important to notice that the integration step step_size will only control the precision of the integration. If step (of the global) is 1#s, then after 1 call of solve, 1#s has flowed in the equation system. If step_size is set to 1#s or to 0.01#s will not impact this fact. The only difference is that in the latter case, the solver made 100x more computations than in the former one (increasing the precision of the final result). Additional facets​ Here are additional facets that be added to the solve statement: t0 (float): the first bound of the integration interval (default value: cycle*step, the time at the beginning of the current cycle.)tf (float): the second bound of the integration interval. Can be smaller than t0 for a backward integration (default value: cycle*step, the time at the beginning of the current cycle.) This might be useful more model coupling, when the sytem to integrate is not linked to the time evolution of the main simulation. Intermediate results​ In one simulation step, if the statement solve is called one time, several integration steps will be done internally. Intermediate computation results can be accessed using the notation: var[] that returns the list of intermediate values of the variable var involved in a differential equation. As an example, with a SIR equation: species agent_with_SIR_dynamic { int N &lt;- 1500 ; int iInit &lt;- 1; float t; float S &lt;- N - float(iInit); float I &lt;- float(iInit); float R &lt;- 0.0; float alpha &lt;- 0.2 min: 0.0 max: 1.0; float beta &lt;- 0.8 min: 0.0 max: 1.0; float h &lt;- 0.01; equation SIR{ diff(S,t) = (- beta * S * I / N); diff(I,t) = (beta * S * I / N) - (alpha * I); diff(R,t) = (alpha * I); } reflex solving { solve SIR method: #rk4 step_size: h ; write S[]; write I[]; write R[]; write t[]; } }  We can use S[], I[], R[] and t[] to access the list of intermediate variables of these 4 variables. SinceS[] is a list the first element can be accessed with S[][0]. Note that the current value of a variable, i.e. S, equals to the last value of the list S[]: S = last(S[]). Accessing the intermediate values can be useful to provide smooth continuous charts. A way to do so is to provide the display with the full list of integration times and values, such as: experiment continuous_display type: gui { output { display display_charts axes: false{ chart 'SIR' type: series x_serie: first(agent_with_SIR_dynamic).t[] y_range: {0,1000} background: #white { data &quot;S&quot; value: first(agent_with_SIR_dynamic).S[] color: #green marker: false; data &quot;I&quot; value: first(agent_with_SIR_dynamic).I[] color: #red marker: false; data &quot;R&quot; value: first(agent_with_SIR_dynamic).R[] color: #blue marker: false; } } } }  The following picture illustrates the result: the top subfigure shows the dynamics with discrete visualization and the bottom one the continuous curves.  "},{"title":"Example of the influence of the integration step​","type":1,"pageTitle":"Using Differential Equations","url":"wiki/DifferentialEquations#example-of-the-influence-of-the-integration-step","content":"The step (of the global) and step_size (of solve) facets may have a huge influence on the results. step_size only has an impact on the result accuracy. The step facet changes the cycle duration and so the time scale and results in curves being horizontally scales. In the following image, the stepfacet has been change from 1.0 (first simulation) to 2.0 (second simulation). The dynamics are exactly the same, but they are viewed at different time scales. The following image illustrates this impact, by calling (with 3 different values of step):  When changing this facet, be sure that the time scale of the ODE system remains consistent with the one of the other agents. "},{"title":"Displays","type":0,"sectionRef":"#","url":"wiki/Displays","content":"","keywords":""},{"title":"Classical displays (java2D)​","type":1,"pageTitle":"Displays","url":"wiki/Displays#classical-displays-java2d","content":"The classical displays displaying any kind of content can be manipulated via the mouse (if no mouse event has been defined): the mouse left press and move allows to move the camera (in 2D),the mouse right click opens a context menu allowing the modeler to inspect displayed agents,the wheel allows the modeler to zoom in or out.  Each display provides several buttons to manipulate the display (from left to right): Pause or resume the current view: when pressed, the display will not be displayed anymore while the simulation is still running,Synchronize, when pressed, the display and the execution of the model are synchronized. Most of the time, this will reduce the speed of the simulation.Zoom in,Zoom to fit view,Zoom out,Take a snapshot: take a snapshot saved as a png image in the snapshots folder of the model folder.Toggle antialias: Antialising produces smoother outputs, but comes with a cost in terms of speed and memory used.Toggle fullscreen ESC: when pressed, the current view will be displayed in fullscreen. To exit this mode, press ESC key.Browse through all displayed agents: when pressed a browse view will be open. Only the species displayed can be browsed.  In addition to these commands, the contextual menu on the display provides three more commands (in &quot;Presentation&quot;): Toggle overlay: display/hide a semi-transparent toolbar on the bottom of the display, showing the coordinates of the mouse, the zoom, the number of fps (frame per second) of the simulation, and a scale (taking into account the zoom level).Toggle toolbar: display/hide the toolbar on the top of the display.Background: Change the background color. When the View is displayed in fullscreen mode, the toolbar is now located in the bottom of the View and contain in addition to the previously detailed toolbar, the toggle side-control, and overlay controls and controls of the experiment (run, pause, step...).  "},{"title":"OpenGL displays​","type":1,"pageTitle":"Displays","url":"wiki/Displays#opengl-displays","content":"The OpenGL displays displaying offers all the feature provided by java2D but a 3D environnement: same behaviors with left-click, right-click and wheel than in the Java2D displays.command pressed (on Mac OS) or Ctrl (on Windows and Linux) + Left-Click pressed + mouse move: it controls the camera and modify its location/target/orientation.  It opens many ways to visualize and understand your simulation(s) with most of the classical features provided by a 3D environment. More details and illustrations of those features can be found here Any OpenGL display has the same menu and buttons as the classical Java2D displays. Nevertheless, the sidebar provides more options to manage camera and other options related to OpenGL displays management.  "},{"title":"Camera commands​","type":1,"pageTitle":"Displays","url":"wiki/Displays#camera-commands","content":"Key\tFunctionDouble Click\tZoom Fit +\tZoom In -\tZoom Out Up\tVertical movement to the top Down\tVertical movement to the bottom Left\tHorizontal movement to the left Right\tHorizontal movement to the right CTRL or CMD + Up\tRotate the model up (decrease the phi angle of the spherical coordinates) CTRL or CMD + Down\tRotate the model down (increase the phi angle of the spherical coordinates) CTRL or CMD + Left\tRotate the model left (increase the theta angle of the spherical coordinates) CTRL or CMD + Right\tRotate the model right (decrease the theta angle of the spherical coordinates) SPACE\tReset the pivot to the center of the envelope KEYPAD 2,4,6,8\tQuick rotation (increase/decrease phi/theta by 30°) CTRL or CMD + LEFT_MOUSE\tMakes the camera rotate around the model ALT+LEFT_MOUSE\tBegins Agent Selection using an ROI (Region of Interest) SHIFT+LEFT_MOUSE\tDraws an ROI on the display, allowing to maintain it across frames SCROLL\tZoom-in/out to the current target (center of the sphere) WHEEL CLICK\tReset the pivot to the center of the envelope Keystone: the keystone allows to modify the location of the 4 corner points of the environment bounding box. It can be use to project a simulation on a physical model as the projector can introduce some image distortions. Press k to enter in keystone mode, ones the keystone is done repress k to copy the facet in the clipboard. You can now paste your keystone value as a facet in the display. "},{"title":"Implementing diffusion","type":0,"sectionRef":"#","url":"wiki/Diffusion","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"Implementing diffusion","url":"wiki/Diffusion#index","content":"Diffuse statementDiffusion with matrix Diffusion matrixGradient matrixCompute multiple propagations at the same stepExecuting several diffusion matrix Diffusion with parametersComputation methods ConvolutionDot Product Use mask GeneralitiesTips Pseudo code "},{"title":"Diffuse statement​","type":1,"pageTitle":"Implementing diffusion","url":"wiki/Diffusion#diffuse-statement","content":"The statement to use for the diffusion is diffuse. It has to be used in a grid species. The diffuse uses the following facets: var (an identifier), (omissible) : the variable to be diffused on (any type in [container, species]): the list of agents (in general cells of a grid), on which the diffusion will occuravoid_mask (boolean): if true, the value will not be diffused in the masked cells, but will be restituted to the neighboring cells, multiplied by the variation value (no signal loss). If false, the value will be diffused in the masked cells, but masked cells won't diffuse the value afterward (loss of signal). (default value : false)cycle_length (int): the number of diffusion operation applied in one simulation stepmask (matrix): a matrix masking the diffusion (matrix created from an image for example). The cells corresponding to the values smaller than &quot;-1&quot; in the mask matrix will not diffuse, and the other will diffuse.matrix (matrix): the diffusion matrix (&quot;kernel&quot; or &quot;filter&quot; in image processing). Can have any size, as long as dimensions are odd values.method (an identifier), takes values in: {convolution, dot_product}: the diffusion methodmin_value (float): if a value is smaller than this value, it will not be diffused. By default, this value is equal to 0.0. This value cannot be smaller than 0.propagation (a label), takes values in {diffusion, gradient} represents both the way the signal is propagated and the way to treat multiple propagations of the same signal occurring at once from different places. If propagation equals 'diffusion', the intensity of a signal is shared between its neighbors with respect to 'proportion', 'variation' and the number of neighbors of the environment places (4, 6 or 8). I.e., for a given signal S propagated from place P, the value transmitted to its N neighbors is S' = (S / N / proportion) - variation. The intensity of S is then diminished by S * proportion on P. In diffusion, the different signals of the same name see their intensities added to each other on each place. If propagation equals 'gradient', the original intensity is not modified, and each neighbor receives the intensity: S / proportion - variation. If multiple propagations occur at once, only the maximum intensity is kept on each place. If 'propagation' is not defined, it is assumed that it is equal to 'diffusion'.proportion (float): a diffusion rateradius (int): a diffusion radius (in number of cells from the center)variation (float): an absolute value to decrease at each neighbor  To write a diffusion, you first have to declare a grid and declare a special attribute for the diffusion. You will then have to write the diffuse statement in another scope (such as the global scope for instance), which will permit the values to be diffused at each step. There, you will specify which variable you want to diffuse (through the var facet), on which species or list of agents you want the diffusion (through the on facet), and how you want this value to be diffused (through all the other facets, we will see how it works with matrix and with special parameters just after). Here is the template of code we will use for the next following part of this page: global { int size &lt;- 64; // the size has to be a power of 2. cells selected_cells; // Initialize the emitter cell as the cell at the center of the word init { selected_cells &lt;- location as cells; } // Affecting &quot;1&quot; to each step reflex new_Value { ask(selected_cells){ phero &lt;- 1.0; } } reflex diff { // Declare a diffusion on the grid &quot;cells&quot; and on &quot;quick_cells&quot;. // The diffusion declared on &quot;quick_cells&quot; will make 10 computations at each step to accelerate the process. // The value of the diffusion will be store in the new variable &quot;phero&quot; of the cell. diffuse var: phero on: cells /*HERE WRITE DOWN THE DIFFUSION PROPERTIES*/; } } grid cells height: size width: size { // &quot;phero&quot; is the variable storing the value of the diffusion float phero &lt;- 0.0; // The color of the cell is linked to the value of &quot;phero&quot;. rgb color &lt;- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0); } experiment diffusion type: gui { output { display a type: opengl { // Display the grid with elevation grid cells elevation: phero * 10 triangulation: true; } } }  This model will simulate a diffusion through a grid at each step, affecting 1 to the center cell diffusing variable value. The diffusion will be seen during the simulation through a color code, and through the elevation of the cell. "},{"title":"Diffusion with matrix​","type":1,"pageTitle":"Implementing diffusion","url":"wiki/Diffusion#diffusion-with-matrix","content":"A first way of specifying the behavior of your diffusion is using diffusion matrix. A diffusion matrix is a 2-dimension matrix [n][m] with float values, where both n and m have to be odd values. The most often, diffusion matrices are square matrices, but you can also declare a rectangular matrix. Example of matrix: matrix&amp;lt;float&gt; mat_diff &lt;- matrix([ [1/9,1/9,1/9], [1/9,1/9,1/9], [1/9,1/9,1/9]]);  In the diffuse statement, you then have to specify the matrix of diffusion you want in the facet matrix. diffuse var: phero on: cells matrix:mat_diff;  Using the facet propagation, you can specify if you want the value to be propagated as a diffusion or as a gradient. "},{"title":"Diffusion matrix​","type":1,"pageTitle":"Implementing diffusion","url":"wiki/Diffusion#diffusion-matrix","content":"A diffusion (the default value of the facet propagation) will spread the values to the neighbors' cells according to the diffusion matrix, and all those values will be added together, as it is the case in the following example:  Note that the sum of all the values diffused at the next step is equal to the sum of the values that will be diffused multiply by the sum of the values of the diffusion matrix. That means that if the sum of the values of your diffusion matrix is larger than 1, the values will increase exponentially at each step. The sum of the value of a diffusion matrix is usually equal to 1. Here are some matrix examples you can use, played with the template model:   "},{"title":"Gradient matrix​","type":1,"pageTitle":"Implementing diffusion","url":"wiki/Diffusion#gradient-matrix","content":"A gradient (use facet : propagation:gradient) is another type of propagation. This time, only the larger value diffused will be chosen as the new one.  Note that unlike the diffusion propagation, the sum of your matrix can be greater than 1 (and it is the case, most often !). Here are some matrix examples with gradient propagation:   "},{"title":"Compute multiple propagations at the same step​","type":1,"pageTitle":"Implementing diffusion","url":"wiki/Diffusion#compute-multiple-propagations-at-the-same-step","content":"You can compute several times the propagation you want by using the facet cycle_length. GAMA will compute for you the corresponding new matrix and will apply it.  Writing those two things are exactly equivalent (for diffusion): matrix&amp;lt;float&gt; mat_diff &lt;- matrix([ [1/81,2/81,3/81,2/81,1/81], [2/81,4/81,6/81,4/81,2/81], [3/81,6/81,1/9,6/81,3/81], [2/81,4/81,6/81,4/81,2/81], [1/81,2/81,3/81,2/81,1/81]]); reflex diff { diffuse var: phero on: cells matrix:mat_diff;  and matrix&amp;lt;float&gt; mat_diff &lt;- matrix([ [1/9,1/9,1/9], [1/9,1/9,1/9], [1/9,1/9,1/9]]); reflex diff { diffuse var: phero on: cells matrix:mat_diff cycle_length:2;  "},{"title":"Executing several diffusion matrix​","type":1,"pageTitle":"Implementing diffusion","url":"wiki/Diffusion#executing-several-diffusion-matrix","content":"If you execute several times the statement diffuse with different matrix on the same variable, their values will be added (and centered if their dimensions are not equal). Thus, the following 3 matrices will be combined to create one unique matrix:  "},{"title":"Diffusion with parameters​","type":1,"pageTitle":"Implementing diffusion","url":"wiki/Diffusion#diffusion-with-parameters","content":"Sometimes writing diffusion matrix is not exactly what you want, and you may prefer to just give some parameters to compute the correct diffusion matrix. You can use the following facets in order to do that: propagation, variation and radius. Depending on which propagation you choose, and how many neighbors your grid has, the propagation matrix will be computed differently. The propagation matrix will have the size: range*2+1. Let's note P for the propagation value, V for the variation, R for the range and N for the number of neighbors. With diffusion propagation For diffusion propagation, we compute following the following steps: (1) We determine the &quot;minimale&quot; matrix according to N (if N = 8, the matrix will be [[P/9,P/9,P/9][P/9,1/9,P/9][P/9,P/9,P/9]]. if N = 4, the matrix will be [[0,P/5,0][P/5,1/5,P/5][0,P/5,0]]). (2) If R != 1, we propagate the matrix R times to obtain a [2*R+1][2*R+1] matrix (same computation as for cycle_length). (3) If V != 0, we substract each value by V*DistanceFromCenter (DistanceFromCenter depends on N). Ex with the default values (P=1, R=1, V=0, N=8): With gradient propagation The value of each cell will be equal to P/POW(N,DistanceFromCenter)-DistanceFromCenter*V. (DistanceFromCenter depends on N). Ex with R=2, other parameters default values (R=2, P=1, V=0, N=8):  Note that if you declared a diffusion matrix, you cannot use those 3 facets (it will raise a warning). Note also that if you use parameters, you will only have a uniform matrix. "},{"title":"Computation methods​","type":1,"pageTitle":"Implementing diffusion","url":"wiki/Diffusion#computation-methods","content":"You can compute the output matrix using two computation methods by using the facet method : the dot product and the convolution. Note that the result of those two methods is exactly the same (except if you use the avoid_mask facet, the results can be slightly different between the two computations). "},{"title":"Convolution​","type":1,"pageTitle":"Implementing diffusion","url":"wiki/Diffusion#convolution","content":"convolution is the default computation method for diffusion. For every output cells, we will multiply the input values and the flipped kernel together, as shown in the following image :  Pseudo-code (k the kernel, x the input matrix, y the output matrix) : for (i = 0 ; i &lt; y.nbRows ; i++) for (j = 0 ; j &lt; y.nbCols ; j++) for (m = 0 ; m &lt; k.nbRows ; m++) for (n = 0 ; n &lt; k.nbCols ; n++) y[i,j] += k[k.nbRows - m - 1, k.nbCols - n - 1] * x[i - k.nbRows/2 + m, j - k.nbCols/2 + n]  "},{"title":"Dot Product​","type":1,"pageTitle":"Implementing diffusion","url":"wiki/Diffusion#dot-product","content":"dot_product method will compute the matrix using a simple dot product between the matrix. For every input cells, we multiply the cell by the kernel matrix, as shown in the following image :  Pseudo-code (k the kernel, x the input matrix, y the output matrix) : for (i = 0 ; i &lt; y.nbRows ; i++) for (j = 0 ; j &lt; y.nbCols ; j++) for (m = 0 ; m &lt; k.nbRows ; m++) for (n = 0 ; n &lt; k.nbCols ; n++) y[i - k.nbRows/2 + m, j - k.nbCols/2 + n] += k[m, n] * x[i, j]  "},{"title":"Using a mask​","type":1,"pageTitle":"Implementing diffusion","url":"wiki/Diffusion#using-a-mask","content":""},{"title":"Generalities​","type":1,"pageTitle":"Implementing diffusion","url":"wiki/Diffusion#generalities","content":"If you want to propagate some values in a heterogeneous grid, you can use some mask to forbid some cells to propagate their values. You can pass a matrix to the facet mask. All the values smaller than -1 will not propagate, and all the values greater or equal to -1 will propagate. A simple way to use mask is by loading an image :  Note that when you use the on facet for the diffuse statement, you can choose only some cells, and not every cell. In fact, when you restrain the values to be diffuse, it is exactly the same process as if you were defining a mask.  When your diffusion is combined with a mask, the default behavior is that the non-masked cells will diffuse their values in all existing cells (that means, even the masked cells !). To change this behavior, you can use the facet avoid_mask. In that case, the value which was supposed to be affected to the masked cell will be redistributed to the neighboring non-masked cells. "},{"title":"Tips​","type":1,"pageTitle":"Implementing diffusion","url":"wiki/Diffusion#tips","content":"Masks can be used to simulate a lot of environments. Here are some ideas for your models: Wall blocking the diffusion​ If you want to simulate a wall blocking a uniform diffusion, you can declare a second diffusion matrix that will be applied only on the cells where your wall will be. This diffusion matrix will &quot;push&quot; the values outside from himself, but conserving the values (the sum of the values of the diffusion still have to be equal to 1) : matrix&amp;lt;float&gt; mat_diff &lt;- matrix([ [1/9,1/9,1/9], [1/9,1/9,1/9], [1/9,1/9,1/9]]); matrix&amp;lt;float&gt; mat_diff_left_wall &lt;- matrix([ [0.0,0.0,2/9], [0.0,0.0,4/9], [0.0,0.0,2/9]]); reflex diff { diffuse var: phero on: (cells where(each.grid_x&gt;30)) matrix:mat_diff; diffuse var: phero on: (cells where(each.grid_x=30)) matrix:mat_diff_left_wall; }   Note that almost the same result can be obtained by using the facet avoid_mask: the value of all masked cells will remain at 0, and the value which was supposed to be affected to the masked cell will be distributed to the neighboring cells. Notice that the results can be slightly different if you are using the convolution or the dot_product method: the algorithm of redistribution of the value to the neighboring cells is a bit different. We advise you to use the dot_product with the avoid_mask facet, the results are more accurate. Wind pushing the diffusion​ Let's simulate a uniform diffusion that is pushed by a wind from &quot;north&quot; everywhere in the grid. A wind from &quot;west&quot; as blowing at the top side of the grid. We will here have to build 2 matrices: one for the uniform diffusion, one for the &quot;north&quot; wind and one for the &quot;west&quot; wind. The sum of the values for the 2 matrices meant to simulate the wind will be equal to 0 (as it will be added to the diffusion matrix). matrix&amp;lt;float&gt; mat_diff &lt;- matrix([ [1/9,1/9,1/9], [1/9,1/9,1/9], [1/9,1/9,1/9]]); matrix&amp;lt;float&gt; mat_wind_from_west &lt;- matrix([ [-1/9,0.0,1/9], [-1/9,0.0,1/9], [-1/9,0.0,1/9]]); matrix&amp;lt;float&gt; mat_wind_from_north &lt;- matrix([ [-1/9,-1/9,-1/9], [0.0,0.0,0.0], [1/9,1/9,1/9]]); reflex diff { diffuse var: phero on: cells matrix:mat_diff; diffuse var: phero on: cells matrix:mat_wind_from_north; diffuse var: phero on: (cells where (each.grid_y&gt;=32)) matrix:mat_wind_from_west; }   Endless world​ Note that when your world is not a torus, it has the same effect as a mask, since all the values outside from the world cannot diffuse some values back :  You can &quot;fake&quot; the fact that your world is endless by adding a different diffusion for the cells with grid_x=0 to have almost the same result :  matrix&amp;lt;float&gt; mat_diff &lt;- matrix([ [1/9,1/9,1/9], [1/9,1/9,1/9], [1/9,1/9,1/9]]); matrix&amp;lt;float&gt; mat_diff_upper_edge &lt;- matrix([ [0.0,0.0,0.0], [1/9+7/81,2/9+1/81,1/9+7/81], [1/9,1/9,1/9]]); reflex diff { diffuse var: phero on: (cells where(each.grid_y&gt;0)) matrix:mat_diff; diffuse var: phero on: (cells where(each.grid_y=0)) matrix:mat_diff_upper_edge; }  "},{"title":"Pseudo-code​","type":1,"pageTitle":"Implementing diffusion","url":"wiki/Diffusion#pseudo-code","content":"This section is more for a better understanding of the source code. Here is the pseudo-code for the computation of diffusion : 1) : Execute the statement diffuse, store the diffusions in a map (from class DiffusionStatement to class GridDiffuser) : - Get all the facet values - Compute the &quot;real&quot; mask, from the facet &quot;mask:&quot; and the facet &quot;on:&quot;. - If no value for &quot;mask:&quot; and &quot;on:&quot; all the grid, the mask is equal to null. - Compute the matrix of diffusion - If no value for &quot;matrix:&quot;, compute with &quot;nb_neighbors&quot;, &quot;is_gradient&quot;, &quot;proportion&quot;, &quot;propagation&quot;, &quot;variation&quot;, &quot;range&quot;. - Then, compute the matrix of diffusion with &quot;cycle_length&quot;. - Store the diffusion properties in a map - Map : [&quot;method_diffu&quot;, &quot;is_gradient&quot;, &quot;matrix&quot;, &quot;mask&quot;, &quot;min_value&quot;] is value, [&quot;var_diffu&quot;, &quot;grid_name&quot;] is key. - If the key exists in the map, try to &quot;mix&quot; the diffusions - If &quot;method_diffu&quot;, &quot;mask&quot; and &quot;is_gradient&quot; equal for the 2 diffusions, mix the diffusion matrix.  2) : At the end of the step, execute the diffusions (class GridDiffuser) : - For each key of the map, - Load the couple &quot;var_diffu&quot; / &quot;grid_name&quot; - Build the &quot;output&quot; and &quot;input&quot; array with the dimension of the grid. - Initialize the &quot;output&quot; array with -Double.MAX_VALUE. - For each value of the map for that key, - Load all the properties : &quot;method_diffu&quot;, &quot;is_gradient&quot;, &quot;matrix&quot;, &quot;mask&quot;, &quot;min_value&quot; - Compute : - If the cell is not masked, if the value of input is &gt; min_value, diffuse to the neighbors. - If the value of the cell is equal to -Double.MAX_VALUE, remplace it by input[idx] * matDiffu[i][j]. - Else, do the computation (gradient or diffusion). - Finish the diffusion : - If output[idx] &gt; -Double.MAX_VALUE, write the new value in the cell.  "},{"title":"Generation of the documentation","type":0,"sectionRef":"#","url":"wiki/Documentation","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Generation of the documentation","url":"wiki/Documentation#table-of-contents","content":"Requirements ConfigurationGenerated files location Workflow to generate wiki filesWorkflow to generate PDF filesWorkflow to generate unit testsMain internal steps Generate wiki filesGenerate pdf filesGenerate unit test files How to document The @doc annotationthe @example annotationHow to document operatorsHow to document statementsHow to document skills How to change the processorGeneral workflow of file generation The GAMA documentation comes in 2 formats: a set of wiki files availaible from the wiki section of the GitHub website and a PDF file. The PDF file is produced from the wiki files. In the wiki files, some are hand-written by the GAMA community and some others are generated automatically from the Java code and the associated java annotations. The section summarizes: how to generate this wiki files,how to generate the PDF documentation,how to generate the unit tests from the java annotations, how to add documentation in the java code. "},{"title":"Requirements​","type":1,"pageTitle":"Generation of the documentation","url":"wiki/Documentation#requirements","content":"To generate automatically the documentation, the GAMA Git version is required. See Install Git version for more details. Among all the GAMA plugins, the following ones are related to documentation generation: msi.gama.processor: the java preprocessor is called during java compilation of the various plugins and extract information from the java code and the java annotations. For each plugin it produces the docGAMA.xml file in the gaml directory.msi.gama.documentation: it contains all the java classes needed to gather all the docGAMA.xml files and generate wiki, pdf or unit test files. In addition, the folder containing the wiki files is required. In the GitHub architecture, the wiki documentation is stored in a separate Git repository https://github.com/gama-platform/gama.wiki.git. A local clone of this repository should thus be created: Open the Git perspective: Windows &gt; Open Perspective &gt; Other...Choose Git Click on &quot;Clone a Git repository&quot; In Source Git repository window: Fill in the URI label with: https://github.com/gama-platform/gama.wiki.gitOther fields will be automatically filled in. In Branch Selection windows, check the master branch Next In Local Destination windows, Choose the directory in which the gama Git repository has been clonedEverything else should be unchecked Finish In the Git perspective and the Git Repositories view, Right-Click on &quot;Working Directory&quot; inside the gama.wiki repository, and choose &quot;Import projects&quot; In the Select a wizard to use for importing projects window: &quot;Import existing projects&quot; should be checked&quot;Working Directory&quot; should be selected In Import Projects window: Uncheck &quot;Search for nested project&quot; Check the project gama.wikiFinish Go back to the Java perspective: a gama.wiki plugin should have been added. In order to generate the PDF file from the wiki files, we use an external application named Pandoc. Follow the Pandoc installation instructions to install it. Specify the path to the pandoc folder in the file &quot;Constants.java&quot;, in the static constant CMD_PANDOC : &quot;yourAbsolutePathToPandoc/pandoc&quot;. Note that Latex should be installed in order to be able to generate PDF files. Make sure you have already installed Miktex (for OS Windows and Mac). Specify the path to the miktex folder in the file &quot;Constants.java&quot;, in the static constant CMD_PDFLATEX : &quot;yourAbsolutePathToMiktex/pdflatex&quot;. "},{"title":"Configuration​","type":1,"pageTitle":"Generation of the documentation","url":"wiki/Documentation#configuration","content":"The location where the files are generated (and other constants used by the generator) are defined in the file msi.gama.documentation/src/msi/gama/doc/util/Constants.java. The use of Pandoc (path to the application and so on) is defined in the file msi.gama.documentation/src/msi/gama/doc/util/ConvertToPDF.java. This should be changed in the future... "},{"title":"Generated files location​","type":1,"pageTitle":"Generation of the documentation","url":"wiki/Documentation#generated-files-location","content":"The generated files are (by default) generated in various locations depending on their type: wiki files: they are generated in the plugin gama.wiki.pdf file: they are generated in the plugin msi.gama.documentation, in the folder files/gen/pdf.unit test files: they are generated in the plugin msi.gama.models, in the folder models/Tests. "},{"title":"Workflow to generate wiki files​","type":1,"pageTitle":"Generation of the documentation","url":"wiki/Documentation#workflow-to-generate-wiki-files","content":"The typical workflow to generate the wiki files is as follow: Clean and Build all the GAMA projects,Run the MainGenerateWiki.java file in the msi.gama.documentation,The wiki files are generated in the gama.wiki plugin. "},{"title":"Workflow to generate PDF files​","type":1,"pageTitle":"Generation of the documentation","url":"wiki/Documentation#workflow-to-generate-pdf-files","content":"The typical workflow to generate the wiki files is as follow: Clean and Build all the GAMA projects,In the file mytemplate.tex, specify the absolute path to your &quot;gama_style.tex&quot; (it should be just next to this file)Run the MainGeneratePDF.java file in the msi.gama.documentation, accepting all the packages install of latex,The wiki files are generated in the msi.gama.documentation plugin. Note that generating the PDF takes a lot of time. Please be patient! If you want to update the file &quot;gama_style.sty&quot; (for syntax coloration), you have to turn the flag &quot;generateGamaStyle&quot; to &quot;true&quot; (and make sure the file &quot;keywords.xml&quot; is already generated). "},{"title":"Workflow to generate unit tests​","type":1,"pageTitle":"Generation of the documentation","url":"wiki/Documentation#workflow-to-generate-unit-tests","content":"The typical workflow to generate the wiki files is as follow: Clean and Build all the GAMA projects,Run the MainGenerateUnitTest.java file in the msi.gama.documentation,The wiki files are generated in the msi.gama.models plugin. "},{"title":"Main internal steps​","type":1,"pageTitle":"Generation of the documentation","url":"wiki/Documentation#main-internal-steps","content":"Clean and Build all the GAMA projects will create a docGAMA.xml file in the gaml directory of each plugin,The MainGenerateXXX.java files then perform the following preparatory tasks: they prepare the gen folder by deleting the existing folders and create all the folders that may contain intermediary generated foldersthey merge all the docGAMA.xml files in a docGAMAglobal.xml file, created in the files/gen/java2xml folder. Only the plugins that are referred in the product files are merged. After these common main first steps, each generator (wiki, pdf or unit test) performs specific tasks. "},{"title":"Generate wiki files​","type":1,"pageTitle":"Generation of the documentation","url":"wiki/Documentation#generate-wiki-files","content":"The docGamaglobal.xml is parsed in order to generate 1 wiki file per kind of keyword: operators,statements,skills,architectures,built-in species,constants and units.in addition an index wiki file containing all the GAML keywords is generated. One wiki file is generated for each extension plugin, i.e. plugin existing in the Eclipse workspace but not referred in the product. "},{"title":"Generate pdf files​","type":1,"pageTitle":"Generation of the documentation","url":"wiki/Documentation#generate-pdf-files","content":"The pdf generator uses the table of content (toc) file located in the files/input/toc folder (msi.gama.documetation plugin) to organize the wiki files in a pdf file. MainGeneratePDF.java file parsers the toc file and create the associated PDF file using the wiki files associated to each element of the toc. The generation is tuned using files located in the files/input/pandocPDF folder. "},{"title":"Generate unit test files​","type":1,"pageTitle":"Generation of the documentation","url":"wiki/Documentation#generate-unit-test-files","content":"MainGenerateUnitTest.java creates GAMA model files for each kind of keyword from the docGAMAglobal.xml file. "},{"title":"How to document​","type":1,"pageTitle":"Generation of the documentation","url":"wiki/Documentation#how-to-document","content":"The documentation is generated from the Java code thanks to the Java additional processor, using mainly information from Java classes or methods and from the Java annotations. (see the list of all annotations for more details about annotations). "},{"title":"The @doc annotation​","type":1,"pageTitle":"Generation of the documentation","url":"wiki/Documentation#the-doc-annotation","content":"Most of the annotations can contain a @doc annotation, that can contain the main part of the documentation. For example, the inter (inter) operator is commented using: @doc( value = &quot;the intersection of the two operands&quot;, comment = &quot;both containers are transformed into sets (so without duplicated element, cf. remove_deplicates operator) before the set intersection is computed.&quot;, usages = { @usage(value = &quot;if an operand is a graph, it will be transformed into the set of its nodes&quot;), @usage(value = &quot;if an operand is a map, it will be transformed into the set of its values&quot;, examples = { @example(value = &quot;[1::2, 3::4, 5::6] inter [2,4]&quot;, equals = &quot;[2,4]&quot;), @example(value = &quot;[1::2, 3::4, 5::6] inter [1,3]&quot;, equals = &quot;[]&quot;) }), @usage(value = &quot;if an operand is a matrix, it will be transformed into the set of the lines&quot;, examples = @example(value = &quot;matrix([[1,2,3],[4,5,4]]) inter [3,4]&quot;, equals = &quot;[3,4]&quot;)) }, examples = { @example(value = &quot;[1,2,3,4,5,6] inter [2,4]&quot;, equals = &quot;[2,4]&quot;), @example(value = &quot;[1,2,3,4,5,6] inter [0,8]&quot;, equals = &quot;[]&quot;) }, see = { &quot;remove_duplicates&quot; })  This @docannotation contains 5 parts: value: describes the documented element, comment: a general comment about the documented element,usages: a set of ways to use the documented element, each of them being in a @usage annotation. The usage contains mainly a description and set of examples,examples: a set of examples that are not related to a particular usage, see: other related keywords. "},{"title":"the @example annotation​","type":1,"pageTitle":"Generation of the documentation","url":"wiki/Documentation#the-example-annotation","content":"This annotation contains a particular use example of the documented element. It is also used to generate unit test and patterns. The simplest way to use it: @example(value = &quot;[1::2, 3::4, 5::6] inter [2,4]&quot;, equals = &quot;[2,4]&quot;)  In this example: value contains an example of use of the operator,equals contains the expected results of expression in value. This will become in the documentation: list var3 &lt;- [1::2, 3::4, 5::6] inter [2,4]; // var3 equals [2,4]  When no variable is given in the annotation, an automatic name is generated. The type of the variable is determined thanks to the return type of the operator with these parameters. This example can also generate a unit test model. In this case, the value in the variable will be compared to the equals part. By default, the @example annotation has the following default values: isTestOnly = false, meaning that the example will be added to the documentation too,isExecutable = true, meaning that content of value can be added in a model and can be compiled (it can be useful to switch it to false, in a documentation example containing name of species that have not been defined),test = true, meaning that the content of value will be tested to the content of equals,isPattern = false. "},{"title":"How to document operators​","type":1,"pageTitle":"Generation of the documentation","url":"wiki/Documentation#how-to-document-operators","content":"A GAML operator is defined by a Java method annoted by the @operator annotation (see the list of all annotations for more details about annotations). In the core of GAMA, most of the operators are defined in the plugin msi.gama.core and in the package msi.gaml.operators. The documentation generator will use information from: the @operator annotation: value: it provides the name(s) of the operator (if an operator has several names, the other names will be considered as alternative names)category: it is used to classified the operators in categories the @doc annotation,the method definition: the return value typeparameters and their type (if the method is static, the IScope attribute is not taken into account) "},{"title":"How to document statements​","type":1,"pageTitle":"Generation of the documentation","url":"wiki/Documentation#how-to-document-statements","content":"A GAML statement is defined by a Java class annoted by the @symbol annotation (see the list of all annotations for more details about annotations). In the core of GAMA, most of the statements are defined in the plugin msi.gama.core and in the package msi.gaml.statements. The documentation generator will use information from: @symbol annotation,@facets annotation (each facet can contain a documentation in a @doc annotation),@inside annotation (where the statement can be used),@doc annotation "},{"title":"How to document skills​","type":1,"pageTitle":"Generation of the documentation","url":"wiki/Documentation#how-to-document-skills","content":"A GAML skill is defined by a Java class annoted by the @skill annotation (see the list of all annotations for more details about annotations). In the core of GAMA, most of the skills are defined in the plugin msi.gama.core and in the package msi.gaml.skills. The documentation generator will use information from: @skill annotation,@vars annotation (each var can contain a documentation in a @doc annotation),@doc annotation "},{"title":"How to change the processor​","type":1,"pageTitle":"Generation of the documentation","url":"wiki/Documentation#how-to-change-the-processor","content":"If you make some modifications in the plugin processor, you have to rebuild the .jar file associated to the processor to take into account the changes. Here are the several steps you have to do: In the msi.gama.processor plugin, click on Generate Processor.jardesc (in processor)Click on Finish (you can check that msi.gama.processor and ummisco.gama.annotations are checked). Accept the warning popup.It should have changed the processor / plugins / msi.gama.processor_1.4.0.jar file.Right-click on the folder processor to refresh. In case some projects have errors after the update of the processor: Clean and build the projectsClose Eclipse and reopen it and clean and build the projectsCheck that Eclipse has been launched with the same JVM as GAMA. To this purpose, have a look at Eclipse / About Eclipse, Installation details and check the java version (i.e. after the -vm option). If it does not fit with the one used for eclipse plugin, change it (in the eclipse.ini file. This following diagram explains roughly the workflow for the generation of the different files: "},{"title":"Editing models","type":0,"sectionRef":"#","url":"wiki/EditingModels","content":"Editing models Editing models in GAMA is very similar to editing programs in a modern IDE like Eclipse. After having successfully launched the program, the user has two fundamental concepts at its disposal: a workspace, which contains models or links to models organized like a hierarchy of files in a filesystem, and the workbench (aka, the main window), which contains the tools to create, modify and experiment these models. Understanding how to navigate in the workspace is covered in another section and, for the purpose of this section, we just need to understand that it is organized in projects, which contain models and their associated data. Projects are further categorized, in GAMA, into four categories: Models Library, Plugin models, Test models (built-in models shipped with GAMA and automatically linked from the workspace), and User Models. This section covers the following sub-sections: GAML Editor GeneralitiesGAML Editor ToolbarValidation of ModelsGraphical Editor","keywords":""},{"title":"Errors View","type":0,"sectionRef":"#","url":"wiki/ErrorsView","content":"Errors View Whenever a runtime error, or a warning, is issued by the currently running experiment, a view called &quot;Errors&quot; is opened automatically. This view provides, together with the error/warning itself, some contextual information about who raised the error (i.e. which agent(s)) and where (i.e. in which portion of the model code). As with other &quot;status&quot; in GAMA, errors will appear in red color and warnings in orange. Since an error appearing in the code is likely to be raised by several agents at once, GAMA groups similar errors together, simply indicating which agent(s) raised them. Note that, unless the error is raised by the experiment agent itself, its message will indicate that at least 2 agents raised it: the original agent and the experiment in which it is plunged. When we unfold the error, to have an idea of its location in the code. In addition clicking on one of the lines should highlight the corresponding line in the code. One of the most current (and sometimes the most mysterious) error is linked to an empty agent (with the value nil) on which we want to access to one of its attributes. It is expressed by Cannot evaluate ATTRIBUTE_NAME as the target agent is nil or Java nil. In this case, modelers have to check carefully their codes to be sure that all the agent variables have a not nil value.","keywords":""},{"title":"Experiments User Interface","type":0,"sectionRef":"#","url":"wiki/ExperimentsUserInterface","content":"Experiments User Interface As soon as an experiment is launched, the modeler is facing a new environment (with different menus and views) called the Simulation Perspective). The Navigator is still available in this perspective (below the parameter view), though, and it is still possible to edit models in it, but it is considered as good practice to use each perspective for what it has been designed for: editing models in the Modeling perspective and running simulations in the Simulation perspective. Switching perspectives is easy. The small button in the top-left corner of the window allows to switch back and forth the two perspectives. The actual contents of the simulation perspective will depend on the experiment being run and the outputs it defines. The next sections will present the most common ones (inspectors, monitors and displays), as well as the views that are not defined in outputs, like the Parameters or Errors view. An overview of the menus and commands specific to the simulation perspective is also available.","keywords":""},{"title":"Exhaustive list of GAMA Keywords","type":0,"sectionRef":"#","url":"wiki/Exhaustive-list-of-GAMA-Keywords","content":"","keywords":""},{"title":"Operators​","type":1,"pageTitle":"Exhaustive list of GAMA Keywords","url":"wiki/Exhaustive-list-of-GAMA-Keywords#operators","content":"-, :, ::, !, !=, ?, /, ., ., ^, @, *, +, &lt;, &lt;=, =, &gt;, &gt;=, abs, accumulate, acos, action, add_3Dmodel, add_attribute, add_census_file, add_days, add_edge, add_geometry, add_hours, add_icon, add_mapper, add_marginals, add_minutes, add_months, add_ms, add_node, add_point, add_range_attribute, add_seconds, add_values, add_weeks, add_years, adjacency, after, agent, agent_closest_to, agent_farthest_to, agent_from_geometry, agent_intersecting, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, all_indexes_of, all_match, all_pairs_shortest_path, all_verify, alpha_index, among, and, and, angle_between, any, any_location_in, any_point_in, append_horizontally, append_vertically, arc, around, as, as_4_grid, as_distance_graph, as_driving_graph, as_edge_graph, as_grid, as_hexagonal_grid, as_int, as_intersection_graph, as_map, as_matrix, as_path, as_spatial_graph, asin, at, at_distance, at_location, atan, atan2, attributes, auto_correlation, BDIPlan, before, beta, beta_index, between, betweenness_centrality, biggest_cliques_of, binomial, binomial_coeff, binomial_complemented, binomial_sum, blend, bool, box, brewer_colors, brewer_palettes, buffer, build, cartesian_product, ceil, cell_at, cells_in, cells_overlapping, centroid, char, chi_square, chi_square_complemented, choose, circle, clean, clean_network, closest_points_with, closest_to, closest_tob, collect, column_at, columns_list, command, cone, cone3D, connected_components_of, connectivity_index, container, contains, contains_all, contains_any, contains_edge, contains_key, contains_node, contains_value, contains_vertex, conversation, convex_hull, copy, copy_between, copy_file, copy_to_clipboard, correlation, cos, cos_rad, count, covariance, covering, covers, create_map, cross, crosses, crossing, crs, CRS_transform, csv_file, cube, curve, cylinder, date, dbscan, dead, degree_of, delete_file, det, determinant, diff, diff2, directed, direction_between, direction_to, directory, disjoint_from, distance_between, distance_to, distinct, distribution_of, distribution2d_of, div, dnorm, dtw, durbin_watson, dxf_file, edge, edge_between, edge_betweenness, edges, eigenvalues, electre_DM, ellipse, elliptical_arc, emotion, empty, enlarged_by, enter, envelope, eval_gaml, eval_when, evaluate_sub_model, even, every, every_cycle, evidence_theory_DM, exp, fact, farthest_point_to, farthest_to, field, file, file_exists, first, first_of, first_with, flip, float, floor, folder, folder_exists, font, frequency_of, from, fuzzy_choquet_DM, fuzzy_kappa, fuzzy_kappa_sim, gaml_file, gaml_type, gamma, gamma_density, gamma_distribution, gamma_distribution_complemented, gamma_index, gamma_rnd, gamma_trunc_rnd, gauss, gauss_rnd, gen_population_generator, gen_range, generate_barabasi_albert, generate_complete_graph, generate_random_graph, generate_terrain, generate_watts_strogatz, geojson_file, geometric_mean, geometry, geometry_collection, get, get_about, get_agent, get_agent_cause, get_belief_op, get_belief_with_name_op, get_beliefs_op, get_beliefs_with_name_op, get_current_intention_op, get_decay, get_desire_op, get_desire_with_name_op, get_desires_op, get_desires_with_name_op, get_dominance, get_familiarity, get_ideal_op, get_ideal_with_name_op, get_ideals_op, get_ideals_with_name_op, get_intensity, get_intention_op, get_intention_with_name_op, get_intentions_op, get_intentions_with_name_op, get_lifetime, get_liking, get_modality, get_obligation_op, get_obligation_with_name_op, get_obligations_op, get_obligations_with_name_op, get_plan_name, get_predicate, get_solidarity, get_strength, get_super_intention, get_trust, get_truth, get_uncertainties_op, get_uncertainties_with_name_op, get_uncertainty_op, get_uncertainty_with_name_op, get_values, gif_file, gini, girvan_newman_clustering, gml_file, gradient, graph, graph6_file, graphdimacs_file, graphdot_file, graphgexf_file, graphgml_file, graphml_file, graphtsplib_file, grayscale, grid_at, grid_cells_to_graph, grid_file, group_by, harmonic_mean, has_belief_op, has_belief_with_name_op, has_desire_op, has_desire_with_name_op, has_ideal_op, has_ideal_with_name_op, has_intention_op, has_intention_with_name_op, has_obligation_op, has_obligation_with_name_op, has_uncertainty_op, has_uncertainty_with_name_op, hexagon, hierarchical_clustering, horizontal, hsb, hypot, IDW, image_file, in, in_degree_of, in_edges_of, incomplete_beta, incomplete_gamma, incomplete_gamma_complement, indented_by, index_by, index_of, inside, int, inter, interleave, internal_integrated_value, intersecting, intersection, intersects, inverse, inverse_distance_weighting, inverse_rotation, is, is_csv, is_dxf, is_error, is_finite, is_gaml, is_geojson, is_gif, is_gml, is_graph6, is_graphdimacs, is_graphdot, is_graphgexf, is_graphgml, is_graphml, is_graphtsplib, is_grid, is_image, is_json, is_number, is_obj, is_osm, is_pgm, is_property, is_reachable, is_saved_simulation, is_shape, is_skill, is_svg, is_text, is_threeds, is_warning, is_xml, json_file, k_spanning_tree_clustering, kappa, kappa_sim, kmeans, kml, kurtosis, label_propagation_clustering, last, last_index_of, last_of, last_with, layout_circle, layout_force, layout_force_FR, layout_force_FR_indexed, layout_grid, length, lgamma, line, link, list, list_with, ln, load_shortest_paths, load_sub_model, log, log_gamma, lognormal_density, lognormal_rnd, lognormal_trunc_rnd, lower_case, main_connected_component, map, masked_by, material, matrix, matrix_with, max, max_flow_between, max_of, maximal_cliques_of, mean, mean_deviation, mean_of, median, mental_state, message, milliseconds_between, min, min_of, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_seconds, minus_weeks, minus_years, mod, moment, months_between, moran, mul, nb_cycles, neighbors_at, neighbors_of, new_emotion, new_folder, new_mental_state, new_predicate, new_social_link, node, nodes, none_matches, none_verifies, norm, Norm, normal_area, normal_density, normal_inverse, normalized_rotation, not, not, obj_file, of, of_generic_species, of_species, one_matches, one_of, one_verifies, or, or, osm_file, out_degree_of, out_edges_of, overlapping, overlaps, pair, palette, partially_overlapping, partially_overlaps, path, path_between, path_to, paths_between, pbinom, pchisq, percent_absolute_deviation, percentile, pgamma, pgm_file, plan, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_seconds, plus_weeks, plus_years, pnorm, point, points_along, points_at, points_in, points_on, poisson, polygon, polyhedron, polyline, polyplan, predecessors_of, predicate, predict, product, product_of, promethee_DM, property_file, pValue_for_fStat, pValue_for_tStat, pyramid, quantile, quantile_inverse, range, rank_interpolated, read, rectangle, reduced_by, regex_matches, regression, remove_duplicates, remove_node_from, rename_file, replace, replace_regex, restore_simulation, restore_simulation_from_file, reverse, rewire_n, rgb, rgb, rms, rnd, rnd_choice, rnd_color, rotated_by, rotation_composition, round, row_at, rows_list, sample, Sanction, save_simulation, saved_simulation_file, scale, scaled_by, scaled_to, select, serialize, serialize_agent, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_lifetime, set_liking, set_modality, set_predicate, set_solidarity, set_strength, set_trust, set_truth, set_z, shape_file, shuffle, signum, simple_clustering_by_distance, simple_clustering_by_envelope_distance, simplification, sin, sin_rad, since, skeletonize, skew, skew_gauss, skewness, skill, smooth, social_link, solid, sort, sort_by, source_of, spatial_graph, species, species_of, sphere, split, split_at, split_geometry, split_in, split_lines, split_using, split_with, sqrt, square, squircle, stack, standard_deviation, step_sub_model, strahler, string, student_area, student_t_inverse, subtract_days, subtract_hours, subtract_minutes, subtract_months, subtract_ms, subtract_seconds, subtract_weeks, subtract_years, successors_of, sum, sum_of, svg_file, t_test, tan, tan_rad, tanh, target_of, teapot, text_file, TGauss, threeds_file, to, to_GAMA_CRS, to_gaml, to_rectangles, to_segments, to_squares, to_sub_geometries, to_triangles, tokenize, topology, topology, touches, touching, towards, trace, transformed_by, translated_by, translated_to, transpose, triangle, triangulate, truncated_gauss, type_of, undirected, union, unknown, until, unzip, upper_case, use_cache, user_confirm, user_input_dialog, using, values_in, variance, variance_of, vertical, voronoi, weibull_density, weibull_rnd, weibull_trunc_rnd, weight_of, weighted_means_DM, where, with_generation_algo, with_k_shortest_path_algorithm, with_max_of, with_min_of, with_precision, with_shortest_path_algorithm, with_values, with_weights, without_holes, wizard, wizard_page, writable, xml_file, xor, years_between, zip,  "},{"title":"Statements​","type":1,"pageTitle":"Exhaustive list of GAMA Keywords","url":"wiki/Exhaustive-list-of-GAMA-Keywords#statements","content":"=, abort, action, add, agents, annealing, ask, aspect, assert, benchmark, break, browse, camera, capture, catch, chart, conscious_contagion, coping, create, data, datalist, default, diffuse, diffusion, display, display_grid, display_population, do, draw, else, emotional_contagion, enforcement, enter, equation, error, event, exhaustive, exit, experiment, explicit, focus, focus_on, generate, genetic, global, graphics, grid, highlight, hill_climbing, if, image, init, inspect, invoke, law, layout, let, light, loop, match, match_between, match_one, match_regex, mesh, migrate, monitor, norm, output, output_file, overlay, parameter, perceive, permanent, plan, pso, put, reactive_tabu, reflex, release, remove, return, rotation, rule, rule, run, sanction, save, set, setup, simulate, sobol, socialize, solve, species, start_simulation, state, status, switch, tabu, task, test, text, trace, transition, try, unconscious_contagion, user_command, user_init, user_input, user_panel, using, Variable_container, Variable_number, Variable_regular, warn, write,  "},{"title":"Architectures​","type":1,"pageTitle":"Exhaustive list of GAMA Keywords","url":"wiki/Exhaustive-list-of-GAMA-Keywords#architectures","content":"fsm, parallel_bdi, probabilistic_tasks, reflex, rules, simple_bdi, sorted_tasks, user_first, user_last, user_only, weighted_tasks,  "},{"title":"Constants and colors​","type":1,"pageTitle":"Exhaustive list of GAMA Keywords","url":"wiki/Exhaustive-list-of-GAMA-Keywords#constants-and-colors","content":"#µm (#micrometer,#micrometers), #AdamsBashforth, #AdamsMoulton, #aliceblue, #ambient, #antiquewhite, #aqua, #aquamarine, #AStar, #azure, #beige, #BellmannFord, #Bhandari, #BidirectionalDijkstra, #bisque, #black, #blanchedalmond, #blue, #blueviolet, #bold, #bottom_center, #bottom_left, #bottom_right, #brown, #burlywood, #cadetblue, #camera_location, #camera_orientation, #camera_target, #center, #chartreuse, #CHBidirectionalDijkstra, #chocolate, #cl (#centiliter,#centiliters), #cm (#centimeter,#centimeters), #coral, #cornflowerblue, #cornsilk, #crimson, #current_error, #custom, #cyan, #cycle (#cycles), #darkblue, #darkcyan, #darkgoldenrod, #darkgray, #darkgreen, #darkgrey, #darkkhaki, #darkmagenta, #darkolivegreen, #darkorange, #darkorchid, #darkred, #darksalmon, #darkseagreen, #darkslateblue, #darkslategray, #darkslategrey, #darkturquoise, #darkviolet, #day (#days), #deeppink, #deepskyblue, #DeltaStepping, #Dijkstra, #dimgray, #dimgrey, #direction, #display_height, #display_width, #dl (#deciliter,#deciliters), #dm (#decimeter,#decimeters), #dodgerblue, #DormandPrince54, #dp853, #e, #epoch, #Eppstein, #Euler, #firebrick, #flat, #floralwhite, #FloydWarshall, #foot (#feet,#ft), #forestgreen, #from_above, #from_front, #from_left, #from_right, #from_up_front, #from_up_left, #from_up_right, #fuchsia, #gainsboro, #ghostwhite, #Gill, #gold, #goldenrod, #GraggBulirschStoer, #gram (#grams), #gray, #green, #greenyellow, #grey, #h (#hour,#hours), #HighamHall54, #hl (#hectoliter,#hectoliters), #honeydew, #horizontal, #hotpink, #inch (#inches), #indianred, #indigo, #infinity, #iso_local, #iso_offset, #iso_zoned, #isometric, #italic, #ivory, #kg (#kilo,#kilogram,#kilos), #khaki, #km (#kilometer,#kilometers), #l (#liter,#liters,#dm3), #lavender, #lavenderblush, #lawngreen, #left_center, #lemonchiffon, #lightblue, #lightcoral, #lightcyan, #lightgoldenrodyellow, #lightgray, #lightgreen, #lightgrey, #lightpink, #lightsalmon, #lightseagreen, #lightskyblue, #lightslategray, #lightslategrey, #lightsteelblue, #lightyellow, #lime, #limegreen, #linen, #longton (#lton), #Luther, #m (#meter,#meters), #m2, #m3, #magenta, #maroon, #max_float, #max_int, #mediumaquamarine, #mediumblue, #mediumorchid, #mediumpurple, #mediumseagreen, #mediumslateblue, #mediumspringgreen, #mediumturquoise, #mediumvioletred, #midnightblue, #Midpoint, #mile (#miles), #min_float, #min_int, #mintcream, #minute (#minutes,#mn), #mistyrose, #mm (#milimeter,#milimeters), #moccasin, #month (#months), #msec (#millisecond,#milliseconds,#ms), #nan, #navajowhite, #navy, #NBAStar, #NBAStarApprox, #nm (#nanometer,#nanometers), #none, #now, #oldlace, #olive, #olivedrab, #orange, #orangered, #orchid, #ounce (#oz,#ounces), #palegoldenrod, #palegreen, #paleturquoise, #palevioletred, #papayawhip, #peachpuff, #peru, #pi, #pink, #pixels (#px), #plain, #plum, #point, #pound (#lb,#pounds,#lbm), #powderblue, #purple, #red, #right_center, #rk4, #rosybrown, #round, #royalblue, #saddlebrown, #salmon, #sandybrown, #seagreen, #seashell, #sec (#second,#seconds,#s), #shortton (#ston), #sienna, #silver, #skyblue, #slateblue, #slategray, #slategrey, #snow, #split, #spot, #springgreen, #sqft (#square_foot,#square_feet), #sqin (#square_inch,#square_inches), #sqmi (#square_mile,#square_miles), #square, #stack, #steelblue, #stone (#st), #Suurballe, #tan, #teal, #thistle, #ThreeEighthes, #to_deg, #to_rad, #tomato, #ton (#tons), #top_center, #top_left, #top_right, #TransitNodeRouting, #transparent, #turquoise, #user_location, #vertical, #violet, #week (#weeks), #wheat, #white, #whitesmoke, #yard (#yards), #year (#years,#y), #yellow, #yellowgreen, #Yen, #zoom,  "},{"title":"Skills​","type":1,"pageTitle":"Exhaustive list of GAMA Keywords","url":"wiki/Exhaustive-list-of-GAMA-Keywords#skills","content":"advanced_driving, driving, dynamic_body, fipa, messaging, moving, moving3D, network, public_transport, public_transport_scheduler, skill_road, skill_road_node, SQLSKILL, static_body,  "},{"title":"Species​","type":1,"pageTitle":"Exhaustive list of GAMA Keywords","url":"wiki/Exhaustive-list-of-GAMA-Keywords#species","content":"agent, AgentDB, base_edge, experiment, graph_edge, graph_node, physical_world,world  "},{"title":"Actions​","type":1,"pageTitle":"Exhaustive list of GAMA Keywords","url":"wiki/Exhaustive-list-of-GAMA-Keywords#actions","content":"init, step, isConnected, close, timeStamp, connect, testConnection, select, executeUpdate, getParameter, setParameter, insert, update_outputs, compact_memory, related_to, register, advanced_follow_driving, ready_to_cross, test_next_road, compute_path, path_from_nodes, drive_random, drive, on_entering_new_road, external_factor_impact, unregister, speed_choice, lane_choice, choose_lane, force_move, follow_driving, goto_driving, apply, start_conversation, send, reply, accept_proposal, agree, cancel, cfp, end_conversation, failure, inform, propose, query, refuse, reject_proposal, request, subscribe, send, wander, move, follow, goto, move, execute, connect, fetch_message, has_more_message, join_group, leave_group, simulate_step, define_route, define_noria, init_departure, is_time_to_go, define_next_target, define_schedule, check_next_departure, check_departure, register, unregister, timeStamp, getCurrentDateTime, getDateOffset, testConnection, executeUpdate, insert, select, list2Matrix, update_body, contact_added_with, contact_removed_with,  "},{"title":"Variables​","type":1,"pageTitle":"Exhaustive list of GAMA Keywords","url":"wiki/Exhaustive-list-of-GAMA-Keywords#variables","content":"speed, real_speed, acceleration, current_path, final_target, current_target, current_index, targets, security_distance_coeff, safety_distance_coeff, min_security_distance, min_safety_distance, current_lane, lowest_lane, num_lanes_occupied, vehicle_length, speed_coeff, max_speed, time_headway, max_acceleration, max_deceleration, delta_idm, politeness_factor, max_safe_deceleration, acc_gain_threshold, acc_bias, lane_change_cooldown, time_since_lane_change, ignore_oneway, violating_oneway, current_road, next_road, on_linked_road, using_linked_road, allowed_lanes, linked_lane_limit, lane_change_limit, proba_lane_change_up, proba_lane_change_down, proba_use_linked_road, proba_respect_priorities, proba_respect_stops, proba_block_node, right_side_driving, distance_to_goal, distance_to_current_target, segment_index_on_road, leading_vehicle, leading_distance, leading_speed, follower, living_space, lanes_attribute, tolerance, obstacle_species, speed, damping, angular_damping, contact_damping, angular_velocity, velocity, conversations, accept_proposals, agrees, cancels, cfps, failures, informs, proposes, queries, refuses, reject_proposals, requests, requestWhens, subscribes, mailbox, location, speed, heading, current_path, current_edge, real_speed, destination, speed, heading, pitch, roll, destination, network_name, network_groups, network_server, transport_line, stops, is_stopped, next_stop, transport_state, schedule, stops, next_departure, next_departure_cycle, transport_line, start_time_hour, start_time_minute, start_time_second, agents_on, all_agents, source_node, target_node, num_lanes, num_segments, linked_road, maxspeed, segment_lengths, vehicle_ordering, roads_in, priority_roads, roads_out, stop, block, mass, rotation, friction, restitution, aabb,  "},{"title":"Pseudo-Variables​","type":1,"pageTitle":"Exhaustive list of GAMA Keywords","url":"wiki/Exhaustive-list-of-GAMA-Keywords#pseudo-variables","content":"self, myself, each  "},{"title":"Types​","type":1,"pageTitle":"Exhaustive list of GAMA Keywords","url":"wiki/Exhaustive-list-of-GAMA-Keywords#types","content":"action, agent, attributes, BDIPlan, bool, container, conversation, date, directory, emotion, field, file, float, font, gaml_type, gen_population_generator, gen_range, geometry, graph, int, kml, list, map, material, matrix, mental_state, message, Norm, pair, path, point, predicate, regression, rgb, Sanction, skill, social_link, species, string, topology, unknown,  "},{"title":"the world​","type":1,"pageTitle":"Exhaustive list of GAMA Keywords","url":"wiki/Exhaustive-list-of-GAMA-Keywords#the-world","content":"torus, Environment Size,world, timecycle, step,time, duration,total_durationaverage_duration,machine_time,agents, stop,halt, pause,scheduling  "},{"title":"Grid​","type":1,"pageTitle":"Exhaustive list of GAMA Keywords","url":"wiki/Exhaustive-list-of-GAMA-Keywords#grid","content":"grid_x, grid_y, agents,color, grid_value  "},{"title":"Other concepts​","type":1,"pageTitle":"Exhaustive list of GAMA Keywords","url":"wiki/Exhaustive-list-of-GAMA-Keywords#other-concepts","content":"scheduling, step, Key concepts,Object-oriented paradigm to GAML, Correspondence GAML and Netlogo "},{"title":"Exploring Models","type":0,"sectionRef":"#","url":"wiki/ExploringModels","content":"Exploring Models We just learnt how to launch GUI Experiments from GAMA. A GUI Experiment will start with a particular set of input, compute several outputs, and will stop at the end (if asked). In order to explore models (by automatically running the Experiment using several configurations to analyze the outputs), a first approach is to run several simulations from the same experiment, considering each simulation as an agent. A second approach, much more efficient for larger explorations, is to run an other type of experiment : the Batch Experiment. We will start this part by learning how to run several simulations from the same experiment. Then, we will see how batch experiments work, and we will focus on how to use those batch experiments to explore models by using exploration methods.","keywords":""},{"title":"Expressions","type":0,"sectionRef":"#","url":"wiki/Expressions","content":"Expressions Expressions in GAML are the value part of the statements' facets. They represent or compute data that will be used as the value of the facet when the statement will be executed. An expression can be either a literal, a unit, a constant, a variable, an attribute or the application of one or several operators to compose a complex expression.","keywords":""},{"title":"Exploration Methods","type":0,"sectionRef":"#","url":"wiki/ExplorationMethods","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#table-of-contents","content":"The method statementExhaustive exploration of the parameter space: exhaustiveHill Climbing: hill_climbingSimulated Annealing: annealingTabu Search: tabuReactive Tabu Search: reactive_tabuGenetic Algorithm: geneticParticle Swarm Optimization: psoSobol Exploration: sobol "},{"title":"The method statement​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#the-method-statement","content":"The optional method statement controls the algorithm which drives the batch. If this element is omitted, the batch will run using the exhaustive method, changing one parameter value at each step until all the possible combinations of parameter values have been covered. See the Exhaustive exploration of the parameter space for more details. When used, this element must contain at least a name attribute to specify the algorithm to use. It has the following facets: minimize or maximize (mandatory for optimization methods): a facet defining the expression to be optimized.aggregation (optional): the possible values are min or max (string). Each combination of parameter values is tested repeat times. The aggregated fitness of one combination is by default the average of fitness values obtained with those repetitions. This aggregated fitness can be turned to the minimum or the maximum of the obtained fitness values using this facet.other parameters that are specific to the exploration method (optional): see below for a description of these facets. Examples of the use of the method statement: method exhaustive minimize: nb_infected ;  or method genetic pop_dim: 3 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 5 minimize: nb_infected aggregation: &quot;max&quot;;  "},{"title":"Exhaustive exploration of the parameter space: exhaustive​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#exhaustive-exploration-of-the-parameter-space-exhaustive","content":"This is the default batch exploration method. It explores all the combination of parameter values in a sequential way. Example: experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time &gt; 400 ) { parameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)'; parameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3; }  The order of the simulations depends on the order of the parameters. In our example, the first combinations will be the followings: evaporation_rate = 0.1, diffusion_rate = 0.1, (2 times)evaporation_rate = 0.1, diffusion_rate = 0.4, (2 times)evaporation_rate = 0.1, diffusion_rate = 0.7, (2 times)evaporation_rate = 0.1, diffusion_rate = 1.0, (2 times)evaporation_rate = 0.2, diffusion_rate = 0.1, (2 times)... Note: this method can also be used for optimization by adding a maximize or a minimize facet to the method statement: experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time &gt; 400 ) { parameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)'; parameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3; method exhaustive maximize: food_gathered; }  "},{"title":"Hill Climbing: hill_climbing​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#hill-climbing-hill_climbing","content":"This algorithm is an implementation of the Hill Climbing algorithm. See the Wikipedia article for a more detailed explanation. This is a local search method that tries at each step, given a solution s, to find a solution s' in the neighborhood of s that increases (or decreases depending on the aim of the exploration) the fitness. This method is more efficient than the global exploration to find an optimum, but with the risk of finding a local optimum, whereas a global optimum could exist. "},{"title":"Algorithm:​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#algorithm","content":" Initialization of an initial solution s iter = 0 While iter &lt;= iter_max, do: Choice of the solution s' in the neighborhood of s that maximize the fitness function If f(s') &gt; f(s) s = s' Else end of the search process EndIf iter = iter + 1 EndWhile  "},{"title":"Method facets (i.e. parameters):​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#method-facets-ie-parameters","content":"iter_max: number of iterations before stoping the exploration. "},{"title":"Example:​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#example","content":"experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time &gt; 400 ) { parameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)'; parameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3; method hill_climbing iter_max: 50 maximize: food_gathered; }  "},{"title":"Simulated Annealing: annealing​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#simulated-annealing-annealing","content":"This algorithm is an implementation of the Simulated Annealing algorithm. See the Wikipedia article for more details. This is a global search method able to find an approximation of a global optimum. The idea is close to the one of slow cooling: given a solution, the algorithm will look for a better one in its neighborhood. This size of the neighborhood (represented by the temperature) will decrease over the execution of the algorithm. "},{"title":"Algorithm:​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#algorithm-1","content":" Initialization of an initial solution s temp = temp_init While temp &gt; temp_end, do: iter = 0 While iter &lt; nb_iter_cst_temp, do: Random choice of a solution s2 in the neighborhood of s df = f(s2)-f(s) If df &gt; 0 s = s2 Else, rand = random number between 0 and 1 If rand &lt; exp(df/temp) s = s2 EndIf EndIf iter = iter + 1 EndWhile temp = temp * temp_decrease EndWhile  "},{"title":"Method facets (i.e. parameters):​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#method-facets-ie-parameters-1","content":"temp_init: Initial temperature.temp_end: Final temperature.temp_decrease: Temperature decrease coefficient.nb_iter_cst_temp: Number of iterations per level of temperature. "},{"title":"Example:​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#example-1","content":"experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time &gt; 400 ) { parameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)'; parameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3; method annealing temp_init: 100 temp_end: 1 temp_decrease: 0.5 nb_iter_cst_temp: 5 maximize: food_gathered; }  "},{"title":"Tabu Search: tabu​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#tabu-search-tabu","content":"This algorithm is an implementation of the Tabu Search algorithm. See the Wikipedia article for more details. This is a local search method. To avoid the issue of local optimum, two additional principals are added: (i) worsening, i.e. the algorithm can sometimes choose a worse solution, (ii) prohibitions, i.e. solutions that have already been explored will become tabu in order to avoid that the algorithm considers them repeatedly. "},{"title":"Algorithm:​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#algorithm-2","content":" Initialization of an initial solution s tabuList = {} iter = 0 While iter &lt;= iter_max, do: Choice of the solution s2 in the neighborhood of s such that: s2 is not in tabuList the fitness function is maximal for s2 s = s2 If size of tabuList = tabu_list_size removing of the oldest solution in tabuList EndIf tabuList = tabuList + s iter = iter + 1 EndWhile  "},{"title":"Method facets (i.e. parameters):​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#method-facets-ie-parameters-2","content":"iter_max: number of iterations.tabu_list_size: size of the tabu list. "},{"title":"Example:​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#example-2","content":"experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time &gt; 400 ) { parameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)'; parameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3; method tabu iter_max: 50 tabu_list_size: 5 maximize: food_gathered; }  "},{"title":"Reactive Tabu Search: reactive_tabu​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#reactive-tabu-search-reactive_tabu","content":"This algorithm is a simple implementation of the Reactive Tabu Search algorithm (Battiti et al., 1993). This Reactive Tabu Search is an enhanced version of the Tabu search. It adds two new elements to the classic Tabu Search. The first one concerns the size of the tabu list: in the Reactive Tabu Search, this one is not constant anymore but it dynamically evolves according to the context. Thus, when the exploration process visits too often the same solutions, the tabu list is extended in order to favor the diversification of the search process. On the other hand, when the process has not visited an already known solution for a high number of iterations, the tabu list is shortened in order to favor the intensification of the search process. The second new element concerns the adding of cycle detection capacities. Thus, when a cycle is detected, the process applies random movements in order to break the cycle. "},{"title":"Method parameters:​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#method-parameters","content":"iter_max: number of iterations.tabu_list_size_ini: initial size of the tabu list.tabu_list_size_min: minimal size of the tabu list.tabu_list_size_max: maximal size of the tabu list.nb_tests_wthout_col_max: number of movements without collision before shortening the tabu list.cycle_size_min: minimal size of the considered cycles.cycle_size_max: maximal size of the considered cycles. "},{"title":"Example:​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#example-3","content":"experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time &gt; 400 ) { parameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)'; parameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3; method reactive_tabu iter_max: 50 tabu_list_size_init: 5 tabu_list_size_min: 2 tabu_list_size_max: 10 nb_tests_wthout_col_max: 20 cycle_size_min: 2 cycle_size_max: 20 maximize: food_gathered; }  "},{"title":"Genetic Algorithm: genetic​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#genetic-algorithm-genetic","content":"This is a simple implementation of Genetic Algorithms (GA). See the Wikipedia article for more details. The principle of GA is to search an optimal solution by applying evolution operators on an initial population of solutions. There are three types of evolution operators: Crossover: Two solutions are combined in order to produce new solutions.Mutation: a solution is modified.Selection: only a part of the population is kept. Different techniques can be applied to this selection. Most of them are based on solution quality (fitness). Representation of the solutions: Individual solution: {Param1 = val1; Param2 = val2; ...}Gene: Parami = vali Initial population building: the system builds nb_prelim_gen random initial populations composed of pop_dim individual solutions. Then, the best pop_dim solutions are selected to be part of the initial population. Selection operator: roulette-wheel selection: the probability to choose a solution is equal to fitness(solution)/ Sum of the population fitness. A solution can be selected several times. Ex: population composed of 3 solutions with fitness (that we want to maximize) 1, 4 and 5. Their probability to be chosen is equal to 0.1, 0.4 and 0.5. Mutation operator: The value of one parameter is modified. Ex: The solution {Param1 = 3; Param2 = 2} can mute to {Param1 = 3; Param2 = 4} Crossover operator: A cut point is randomly selected and two new solutions are built by taking the half of each parent solution. Ex: let {Param1 = 4; Param2 = 1} and {Param1 = 2; Param2 = 3} be two solutions. The crossover operator builds two new solutions: {Param1 = 2; Param2 = 1} and {Param1 = 4; Param2 = 3}. "},{"title":"Method facets (i.e. parameters):​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#method-facets-ie-parameters-3","content":"pop_dim: size of the population (number of individual solutions).crossover_prob: crossover probability between two individual solutions.mutation_prob: mutation probability for an individual solution.nb_prelim_gen: number of random populations used to build the initial population.max_gen: number of generations. "},{"title":"Example:​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#example-4","content":"experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time &gt; 400 ) { parameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)'; parameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3; method genetic maximize: food_gathered pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 20; }  "},{"title":"Particle Swarm Optimization: pso​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#particle-swarm-optimization-pso","content":"This is an implementation of the Partical Swarm Optimization algorithme (PSO). See the Wikipedia article for more details. It solves a problem by having a population of candidate solutions, here dubbed particles, and moving these particles around in the search-space according to simple mathematical formula over the particle's position and velocity. Each particle's movement is influenced by its local best known position, but is also guided toward the best known positions in the search-space, which are updated as better positions are found by other particles. This is expected to move the swarm toward the best solutions. "},{"title":"Method facets (i.e. parameters):​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#method-facets-ie-parameters-4","content":"iter_max, number of iterations.num_particles, number of particles.weight_cognitive, weight for the cognitive component.weight_inertia, weight for the inertia component.weight_social, weight for the social component. "},{"title":"Example:​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#example-5","content":"experiment PSO type: batch keep_seed: true repeat: 3 until: ( time &gt; 5000 ) { parameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01; parameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01; method pso num_particles: 3 weight_inertia:0.7 weight_cognitive: 1.5 weight_social: 1.5 iter_max: 5 minimize: num_dead ; }  "},{"title":"Sobol Exploration: sobol​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#sobol-exploration-sobol","content":"This is an implementation of the Sobol sensitivity analysis exploration. It is based on the implementation of the algorithm provided by http://moeaframework.org under the GPL GNU licence. Rational behind the Sobol sensitivity analysis can be found in Saltelli article (https://doi.org/10.1016/S0010-4655(02)00280-1). To put it simple, the procedure randomly drawn N x P points in the parameter space (with N defined by the sample parameter and P the number of parameters to explore), execute the set of associated simulation and compute first, second and total ordered sensitivity indexes. Intuitively, those values give an estimated contribution of the parameters to the variability of one or several outputs (the outputs list in parameter of the method). "},{"title":"Method facets (i.e. parameters):​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#method-facets-ie-parameters-5","content":"outputs, the list of output variables to analyse through sobol indexes.report, the path to the file where the Sobol report will be written.results, the path to the file where the automatic batch report will be written.sample, the size of the sample for the sobol sequence. "},{"title":"Example:​","type":1,"pageTitle":"Exploration Methods","url":"wiki/ExplorationMethods#example-6","content":"experiment Sobol type: batch keep_seed:true until:( time &gt; 5000 ) { parameter 'Infection rate' var: infection_rate min:0.0 max:1.0; parameter 'Probability of dying' var:dying_proba min:0.01 max:0.25; method sobol outputs:[&quot;num_dead&quot;] sample:100 report:&quot;Results/sobol.txt&quot; results:&quot;Results/sobol_raw.csv&quot;; }  "},{"title":"File Types","type":0,"sectionRef":"#","url":"wiki/FileTypes","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#table-of-contents","content":"File Types Text File ExtensionsContentOperators CSV File ExtensionsContentOperators Shapefile ExtensionsContentOperators OSM File ExtensionsContentOperators Grid File ExtensionsContentOperators Image File ExtensionsContentOperators SVG File ExtensionsContentOperators Property File ExtensionsContentOperators R File ExtensionsContentOperators 3DS File ExtensionsContentOperators OBJ File ExtensionsContentOperators "},{"title":"Text File​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#text-file","content":""},{"title":"Extensions​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#extensions","content":"Here the list of possible extensions for text file: &quot;txt&quot;&quot;data&quot;&quot;csv&quot;&quot;text&quot;&quot;tsv&quot;&quot;xml&quot; Note that when trying to define the type of a file with the default file loading operator (file), GAMA will first try to test the other type of file. For example, for files with &quot;.csv&quot; extension, GAMA will cast them as csv file and not as text file. "},{"title":"Content​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#content","content":"The content of a text file is a list of string corresponding to each line of the text file. For example: global { init { file my_file &lt;- text_file(&quot;../includes/data.txt&quot;); loop el over: my_file { write el; } } }  will give: sepallength,sepalwidth,petallength,petalwidth,type 5.1,3.5,1.4,0.2,Iris-setosa 4.9,3.0,1.4,0.2,Iris-setosa 4.7,3.2,1.3,0.2,Iris-setosa  "},{"title":"Operators​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#operators","content":"List of operators related to text files: text_file(string path): load a file (with an authorized extension) as a text file.text_file(string path, list content): load a file (with an authorized extension) as a text file and fill it with the given content.is_text(op): tests whether the operand is a text file "},{"title":"CSV File​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#csv-file","content":""},{"title":"Extensions​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#extensions-1","content":"Here the list of possible extensions for csv file: * &quot;csv&quot; * &quot;tsv&quot;  "},{"title":"Content​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#content-1","content":"The content of a csv file is a matrix of objects: each row of the matrix is a line of the file; each column of the matrix is values delimited by the separator. By default, the delimiter is the &quot;,&quot; and the datatype depends on the dataset. For example: global { init { file my_file &lt;- csv_file(&quot;../includes/data.csv&quot;); loop el over: my_file { write el; } } }  will give: sepallength sepalwidth petallength petalwidth type 5.1 3.5 1.4 0.2 Iris-setosa 4.9 3.0 1.4 0.2 Iris-setosa ...  To manipulate easily the data, we can consider the contents of the data file, that is a matrix. As an example, we can access the number of lines and columns of a data file named my_file with my_file.contents.dimension. "},{"title":"Operators​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#operators-1","content":"There are many operators available to load a csv_file. csv_file(string path): load a file (with an authorized extension) as a csv file with default separator (&quot;,&quot;), and no assumption on the type of data.csv_file(string path,bool header)&quot;: load a file as a CSV file with the default separator (coma), with specifying if the model has a header or not (boolean), and no assumption on the type of data.csv_file(string path, string separator): load a file (with an authorized extension) as a csv file with the given separator, without making any assumption on the type of data. Headers should be detected automatically if they exist. file my_file &lt;- csv_file(&quot;../includes/data.csv&quot;, &quot;;&quot;);  csv_file(string path, string separator, bool header): load a file (with an authorized extension) as a csv file, specifying (1) the separator used; (2) if the model has a header or not, without making any assumption on the type of data. csv_file(string path, string separator, string text_qualifier, bool header): load a file as a csv file specifying (1) the separator used; (2) the text qualifier used; (3) if the model has a header or not, without making any assumption on the type of data&quot;,csv_file(string path, string separator, type datatype): load a file as a csv file specifying a given separator, no header, and the type of data. No text qualifier will be used. file my_file &lt;- csv_file(&quot;../includes/data.csv&quot;, &quot;;&quot;, int);  csv_file(string path, string separator, string text_qualifier, type datatype): load a file as a csv file specifying the separator, text qualifier to use, and the type of data to read. Headers should be detected automatically if they exist.csv_file(string path, string separator, type datatype, bool header): load a file as a csv file specifying the given separator, the type of data, with specifying if the model has a header or not (boolean). No text qualifier will be used&quot;.csv_file(string path, string separator, type datatype, bool header, point dimensions): load a file as a csv file specifying a given separator, the type of data, with specifying the number of cols and rows taken into account. No text qualifier will be used.csv_file(string path, matrix content): This file constructor allows to store a matrix in a CSV file (it does not save it - just store it in memory) Finally, it is possible to check whether a file is a csv file: is_csv(op): tests whether the operand is a csv file "},{"title":"Shapefile​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#shapefile","content":"Shapefiles are classical GIS data files. A shapefile is not simple file, but a set of several files (source: wikipedia): Mandatory files : .shp - shape format; the feature geometry itself.shx - shape index format; a positional index of the feature geometry to allow seeking forwards and backwards quickly.dbf - attribute format; columnar attributes for each shape, in dBase IV format Optional files : .prj - projection format; the coordinate system and projection information, a plain text file describing the projection using well-known text format.sbn and .sbx - a spatial index of the features.fbn and .fbx - a spatial index of the features for shapefiles that are read-only.ain and .aih - an attribute index of the active fields in a table.ixs - a geocoding index for read-write shapefiles.mxs - a geocoding index for read-write shapefiles (ODB format).atx - an attribute index for the .dbf file in the form of shapefile.columnname.atx (ArcGIS 8 and later).shp.xml - geospatial metadata in XML format, such as ISO 19115 or other XML schema.cpg - used to specify the code page (only for .dbf) for identifying the character encoding to be used More details about shapefiles can be found here. "},{"title":"Extensions​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#extensions-2","content":"Here the list of possible extension for shapefile: &quot;shp&quot; "},{"title":"Content​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#content-2","content":"The content of a shapefile is a list of geometries corresponding to the objects of the shapefile. For example: global { init { file my_file &lt;- shape_file(&quot;../includes/data.shp&quot;); loop el over: my_file { write el; } } }  will give: Polygon Polygon Polygon Polygon Polygon Polygon Polygon ...  Note that the attributes of each object of the shapefile are stored in their corresponding GAMA geometry. The operator &quot;get&quot; (or &quot;read&quot;) allows to get the value of corresponding attributes. For example: file my_file &lt;- shape_file(&quot;../includes/data.shp&quot;); write &quot;my_file: &quot; + my_file.contents; loop el over: my_file { write (el get &quot;TYPE&quot;); }  "},{"title":"Operators​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#operators-2","content":"List of operators related to shapefiles: shape_file(string path): load a file (with an authorized extension) as a shapefile with default projection (if a prj file is defined, use it, otherwise use the default projection defined in the preference).shape_file(string path, string code): load a file (with an authorized extension) as a shapefile with the given projection (GAMA will automatically decode the code. For a list of the possible projections see: http://spatialreference.org/ref/)shape_file(string path, int EPSG_ID): load a file (with an authorized extension) as a shapefile with the given projection (GAMA will automatically decode the epsg code. For a list of the possible projections see: http://spatialreference.org/ref/) file my_file &lt;- shape_file(&quot;../includes/data.shp&quot;, &quot;EPSG:32601&quot;);  shape_file(string path, list content): load a file (with an authorized extension) as a shapefile and fill it with the given content.is_shape(op): tests whether the operand is a shapefile "},{"title":"OSM File​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#osm-file","content":"OSM (Open Street Map) is a collaborative project to create a free editable map of the world. The data produced in this project (OSM File) represent physical features on the ground (e.g., roads or buildings) using tags attached to its basic data structures (its nodes, ways, and relations). Each tag describes a geographic attribute of the feature being shown by that specific node, way or relation (source: openstreetmap.org). More details about OSM data can be found here. "},{"title":"Extensions​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#extensions-3","content":"Here the list of possible extension for shapefile: &quot;osm&quot;&quot;pbf&quot;&quot;bz2&quot;&quot;gz&quot; "},{"title":"Content​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#content-3","content":"The content of an OSM data is a list of geometries corresponding to the objects of the OSM file. For example: global { init { file my_file &lt;- osm_file(&quot;../includes/data.gz&quot;); loop el over: my_file { write el; } } }  will give: Point Point Point Point Point LineString LineString Polygon Polygon Polygon ...  Note that like for shapefiles, the attributes of each object of the osm file is stored in their corresponding GAMA geometry. The operator &quot;get&quot; (or &quot;read&quot;) allows to get the value of corresponding attributes. "},{"title":"Operators​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#operators-3","content":"List of operators related to osm file: osm_file(string path): load a file (with an authorized extension) as an osm file with default projection (if a prj file is defined, use it, otherwise use the default projection defined in the preference). In this case, all the nodes and ways of the OSM file will become a geometry.osm_file(string path, string code): load a file (with an authorized extension) as an osm file with the given projection (GAMA will automatically decode the code. For a list of the possible projections see: http://spatialreference.org/ref/). In this case, all the nodes and ways of the OSM file will become a geometry.osm_file(string path, int EPSG_ID): load a file (with an authorized extension) as an osm file with the given projection (GAMA will automatically decode the epsg code. For a list of the possible projections see: http://spatialreference.org/ref/). In this case, all the nodes and ways of the OSM file will become a geometry. file my_file &lt;- osm_file(&quot;../includes/data.gz&quot;, &quot;EPSG:32601&quot;);  osm_file(string path, map filter): load a file (with an authorized extension) as an osm file with default projection (if a prj file is defined, use it, otherwise use the default projection defined in the preference). In this case, only the elements with the defined values are loaded from the file. //map used to filter the object to build from the OSM file according to attributes. map filtering &lt;- map([&quot;highway&quot;::[&quot;primary&quot;, &quot;secondary&quot;, &quot;tertiary&quot;, &quot;motorway&quot;, &quot;living_street&quot;,&quot;residential&quot;, &quot;unclassified&quot;], &quot;building&quot;::[&quot;yes&quot;]]); //OSM file to load file&amp;lt;geometry&gt; osmfile &lt;- file&amp;lt;geometry (osm_file(&quot;../includes/rouen.gz&quot;, filtering)) ;  osm_file(string path, map filter, string code): load a file (with an authorized extension) as a osm file with the given projection (GAMA will automatically decode the code. For a list of the possible projections see: http://spatialreference.org/ref/). In this case, only the elements with the defined values are loaded from the file.osm_file(string path, map filter, int EPSG_ID): load a file (with an authorized extension) as a osm file with the given projection (GAMA will automatically decode the epsg code. For a list of the possible projections see: http://spatialreference.org/ref/). In this case, only the elements with the defined values are loaded from the file.is_osm(op): tests whether the operand is a osm file "},{"title":"Grid File​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#grid-file","content":"Esri ASCII Grid files are classic text raster GIS data. More details about Esri ASCII grid file can be found here. Note that grid files can be used to initialize a grid species. The number of rows and columns will be read from the file. Similarly, the values of each cell contained in the grid file will be accessible through the grid_value attribute. grid cell file: grid_file { }  "},{"title":"Extensions​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#extensions-4","content":"Here the list of possible extension for grid file: &quot;asc&quot; "},{"title":"Content​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#content-4","content":"The content of a grid file is a list of geometries corresponding to the cells of the grid. For example: global { init { file my_file &lt;- grid_file(&quot;../includes/data.asc&quot;); loop el over: my_file { write el; } } }  will give: Polygon Polygon Polygon Polygon Polygon Polygon Polygon ...  Note that the values of each cell of the grid file is stored in their corresponding GAMA geometry (grid_value attribute). The operator &quot;get&quot; (or &quot;read&quot;) allows to get the value of this attribute. For example: file my_file &lt;- grid_file(&quot;../includes/data.asc&quot;); write &quot;my_file: &quot; + my_file.contents; loop el over: my_file { write el get &quot;grid_value&quot;; }  "},{"title":"Operators​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#operators-4","content":"List of operators related to shapefiles: grid_file(string path): load a file (with an authorized extension) as a grid file with default projection (if a prj file is defined, use it, otherwise use the default projection defined in the preference).grid_file(string path, string code): load a file (with an authorized extension) as a grid file with the given projection (GAMA will automatically decode the code. For a list of the possible projections see: http://spatialreference.org/ref/)grid_file(string path, int EPSG_ID): load a file (with an authorized extension) as a grid file with the given projection (GAMA will automatically decode the epsg code. For a list of the possible projections see: http://spatialreference.org/ref/) file my_file &lt;- grid_file(&quot;../includes/data.shp&quot;, &quot;EPSG:32601&quot;);  is_grid(op): tests whether the operand is a grid file. "},{"title":"Image File​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#image-file","content":""},{"title":"Extensions​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#extensions-5","content":"Here the list of possible extensions for image file: &quot;tif&quot;&quot;tiff&quot;&quot;jpg&quot;&quot;jpeg&quot;&quot;png&quot;&quot;gif&quot;&quot;pict&quot;&quot;bmp&quot; "},{"title":"Content​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#content-5","content":"The content of an image file is a matrix of int: each pixel is a value in the matrix. For example: global { init { file my_file &lt;- image_file(&quot;../includes/DEM.png&quot;); loop el over: my_file { write el; } } }  will give: -9671572 -9671572 -9671572 -9671572 -9934744 -9934744 -9868951 -9868951 -10000537 -10000537 ...  "},{"title":"Operators​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#operators-5","content":"List of operators related to csv files: image_file(string path): load a file (with an authorized extension) as an image file.image_file(string path, matrix content): load a file (with an authorized extension) as an image file and fill it with the given content.is_image(op): tests whether the operand is an image file "},{"title":"SVG File​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#svg-file","content":"Scalable Vector Graphics (SVG) is an XML-based vector image format for two-dimensional graphics with support for interactivity and animation. Note that interactivity and animation features are not supported in GAMA. More details about SVG file can be found here. "},{"title":"Extensions​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#extensions-6","content":"Here the list of possible extension for SVG file: &quot;svg&quot; "},{"title":"Content​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#content-6","content":"The content of a SVG file is a list of geometries. For example: global { init { file my_file &lt;- svg_file(&quot;../includes/data.svg&quot;); loop el over: my_file { write el; } } }  will give: Polygon  "},{"title":"Operators​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#operators-6","content":"List of operators related to svg files: shape_file(string path): load a file (with an authorized extension) as a SVG file.shape_file(string path, point size): load a file (with an authorized extension) as a SVG file with the given size: file my_file &lt;- svg_file(&quot;../includes/data.svg&quot;, {5.0,5.0});  is_svg(op): tests whether the operand is a SVG file "},{"title":"Property File​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#property-file","content":""},{"title":"Extensions​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#extensions-7","content":"Here the list of possible extensions for property file: &quot;properties&quot; "},{"title":"Content​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#content-7","content":"The content of a property file is a map of string corresponding to the content of the file. For example: global { init { file my_file &lt;- property_file(&quot;../includes/data.properties&quot;); loop el over: my_file { write el; } } }  with the given property file: sepallength = 5.0 sepalwidth = 3.0 petallength = 4.0 petalwidth = 2.5 type = Iris-setosa  will give: 3.0 4.0 5.0 Iris-setosa 2.5  "},{"title":"Operators​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#operators-7","content":"List of operators related to text files: property_file(string path): load a file (with an authorized extension) as a property file.is_property(op): tests whether the operand is a property file "},{"title":"R File​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#r-file","content":"R is a free software environment for statistical computing and graphics. GAMA allows to execute R script (if R is installed on the computer). More details about R can be found here. Note that GAMA also integrates some operators to manage R scripts: R_computeR_compute_param "},{"title":"Extensions​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#extensions-8","content":"Here the list of possible extensions for R file: &quot;r&quot; "},{"title":"Content​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#content-8","content":"The content of a R file corresponds to the results of the application of the script contained in the file. For example: global { init { file my_file &lt;- R_file(&quot;../includes/data.r&quot;); loop el over: my_file { write el; } } }  will give: 3.0  "},{"title":"Operators​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#operators-8","content":"List of operators related to R files: R_file(string path): load a file (with an authorized extension) as a R file.is_R(op): tests whether the operand is a R file. "},{"title":"3DS File​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#3ds-file","content":"3DS is one of the file formats used by the Autodesk 3ds Max 3D modeling, animation and rendering software. 3DS files can be used in GAMA to load 3D geometries. More details about 3DS file can be found here. "},{"title":"Extensions​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#extensions-9","content":"Here the list of possible extension for 3DS file: &quot;3ds&quot;&quot;max&quot; "},{"title":"Content​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#content-9","content":"The content of a 3DS file is a list of geometries. For example: global { init { file my_file &lt;- threeds_file(&quot;../includes/data.3ds&quot;); loop el over: my_file { write el; } } }  will give: Polygon  "},{"title":"Operators​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#operators-9","content":"List of operators related to 3ds files: threeds_file(string path): load a file (with an authorized extension) as a 3ds file.is_threeds(op): tests whether the operand is a 3DS file "},{"title":"OBJ File​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#obj-file","content":"OBJ file is a geometry definition file format first developed by Wavefront Technologies for its Advanced Visualizer animation package. The file format is open and has been adopted by other 3D graphics application vendors. More details about Obj file can be found here. "},{"title":"Extensions​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#extensions-10","content":"Here the list of possible extension for OBJ files: &quot;obj&quot; "},{"title":"Content​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#content-10","content":"The content of a OBJ file is a list of geometries. For example: global { init { file my_file &lt;- obj_file(&quot;../includes/data.obj&quot;); loop el over: my_file { write el; } } }  will give: Polygon  "},{"title":"Operators​","type":1,"pageTitle":"File Types","url":"wiki/FileTypes#operators-10","content":"List of operators related to obj files: obj_file(string path): load a file (with an authorized extension) as a obj file.is_obj(op): tests whether the operand is a OBJ file "},{"title":"Creation of a basic disease spreading model","type":0,"sectionRef":"#","url":"wiki/G__GraphicalEditorTutorial","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"Creation of a basic disease spreading model","url":"wiki/G__GraphicalEditorTutorial#formulation","content":"Define the people species with a moving skillDefine the move reflex that allows the people agent to move randomly and the infect_others reflex that allows them to infect other people agents.Define the aspect of the people speciesAdd the people species to a displayAdd a chart display to follow the evolution of the number of infected people "},{"title":"Diagram Definition​","type":1,"pageTitle":"Creation of a basic disease spreading model","url":"wiki/G__GraphicalEditorTutorial#diagram-definition","content":""},{"title":"Project and diagram​","type":1,"pageTitle":"Creation of a basic disease spreading model","url":"wiki/G__GraphicalEditorTutorial#project-and-diagram","content":"The first step of this tutorial consists in defining a new project, then in defining a new model from a skeleton (choose &quot;skeleton&quot; in &quot;Choose a diagram&quot;.  "},{"title":"diagram structure​","type":1,"pageTitle":"Creation of a basic disease spreading model","url":"wiki/G__GraphicalEditorTutorial#diagram-structure","content":"A GAMA diagram is composed of three main types of elements: world : this element, generated at the creation of the diagram, that is unique, defines the &quot;world&quot; agent, a special agent of a GAMA model. It represents all that is global to the model: dynamics, variables, actions. In addition, it allows to initialize the simulation (init block).species and grid: these elements define the species of agents composing the model.experiment : these elements define a context of the execution of the simulations. In particular, it defines the input (parameters) and output (displays, files...) of a model. "},{"title":"species​","type":1,"pageTitle":"Creation of a basic disease spreading model","url":"wiki/G__GraphicalEditorTutorial#species","content":" A species represents a «prototype» of agents: it defines their common properties. Three main elements can be defined in a species: the internal state of its agents (attributes)their behaviorhow they are displayed (aspects) In our model, we define a new people species. In addition, we want to add a new capability to our agent: the possibility to move randomly. For that, we add a specific skill to our people agents. A skill is a built-in module that provides the modeler a self-contain and relevant set of actions and variables. The moving provides the agents with several attributes and actions related to movement. Internal state​ An attribute is defined as follows: type of the attribute and name. Numerous types of attributes are available: int (integer), float (floating-point number), string, bool (boolean, true or false), point (coordinates), list, pair, map, file, matrix, agents species, rgb (color), graph, path... In addition to the attributes the modeler explicitly defines, species &quot;inherits&quot; other attributes called &quot;built-in&quot; variables: A name (name): the identifier of the speciesA shape (shape): the default shape of the agents to be constructed after the species. It can be a point, a polygon, etc.A location (location): the centroid of its shape. In our model, we define 2 new attributes to our people agents: is_infected of type bool, with for initial value: falsecolor of type rgb, with for initial value: #green Behavior​  GAMA proposes several ways to define the behavior of a species: dynamic variables (update facet), reflexes... A reflex is a element (that can be defined to the world or any species) that will be automatically executed at each simulation step if its condition is true. The condition is optional: when it is omitted, the reflex is activated at each time step. We define a first reflex called move that is activated at each simulation step (no condition) and that makes the people move randomly using the wander action from the moving skill with an amplitude of 30°. do wander amplitude: 30.0;  We define a second reflex called infect that is activated only when the agent is infected (is_infected = true) and that ask all the people at a distance of 5m to test a probability to be infected. ask people at_distance 5.0 { if flip(0.1) { is_infected &lt;- true; color &lt;- #red; } }  The ask allows an agent to ask other agents to do something (i.e. to execute a sequence of statements). The at_distance operator allows to get the list of agents (here of people agents) that are located at a distance lower or equal to the given distance (here 5m). The flip operator allows to test a probability. Display​  An agent aspects have to be defined. An aspect is a way to display the agents of a species. In an aspect, it is possible to draw: A geometry: for instance, the shape of the agent (but it may be a different one, for instance, a circle instead of a complex polygon)An image: to draw iconsA text: to draw a text In our model, we define an aspect for the people agent called circle that draw the agents as a circle of 1m radius with a color that depends on their color attribute. If the people agent is infected, it will be drawn in red, in green otherwise. "},{"title":"global section​","type":1,"pageTitle":"Creation of a basic disease spreading model","url":"wiki/G__GraphicalEditorTutorial#global-section","content":"The global section represents a specific agent, called world. Defining this agent follows the same principle as any agent and is, thus, defined after a species. The world agent represents everything that is global to the model: dynamics, variables... It allows to initialize simulations (init block): the world is always created and initialized first when a simulation is launched (before any other agents). The geometry (shape) of the world agent is by default a square with 100m for side size but can be redefined if necessary. The step attribute of the world agent allows to specify the duration of one simulation step (by default, 1 step = 1 seconde). Model initialization​  The init section of the world allows to initialize the define what will happen at the initialization of a simulation, for instance, to create agents. We use the statement create to create agents of a specific species: create species_name + : number: number of agents to create (int, 1 by default)from: GIS file to use to create the agents (optional, string or file)returns: list of created agents (list) For our model, we define the init block in order to create nb_people people agents and ask nb_infected_init of them to be infected: create people number: nb_people; ask one_of(people) { is_infected &lt;- true; color &lt;- #red; }  "},{"title":"experiment​","type":1,"pageTitle":"Creation of a basic disease spreading model","url":"wiki/G__GraphicalEditorTutorial#experiment","content":"An experiment defines how a model can be simulated (executed). Several experiments can be defined for a given model. Two types of experiment exists: gui: experiment with a graphical interface, which displays its input parameters and outputs.batch: Allows to setup a series of simulations (w/o graphical interface). In our model, a gui experiment called my_GUI_xp is already defined. output​  Output blocks are defined in an experiment and define how to visualize a simulation (with one or more display blocks that define separate windows). Each display can be refreshed independently by defining the facet refresh_every: nb (int) (the display will be refreshed every nb steps of the simulation). Each display can include different layers (like in a GIS): Agents lists : agents layer_name value: agents_list aspect: my_aspect;Agents species : species my_species aspect: my_aspectImages: image layer_name file: image_file;Charts : see later. Note that it is possible to define a opengl display (for 3D display or just to optimize the display) by using the facet type: opengl. In our model, we add to the existing display my_display a layer for the people species with the circle aspect. Run simulation​ To run the simulation, just click on the button corresponding to the existing experiment (in our case my_GUI_xp) Define a chart​ It is possible to define a chart layer in a display. In our model, we add a new display called chart in which we define a layer of type chart to display the evolution of the number of infected and susceptible people.   "},{"title":"The Graphical Editor","type":0,"sectionRef":"#","url":"wiki/G__GraphicalEditor","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"The Graphical Editor","url":"wiki/G__GraphicalEditor#table-of-contents","content":"The Graphical Editor Installing the graphical editorCreating a first modelStatus of models in editorsDiagram definition frameworkFeatures agents speciesgridInheriting linkworld agent features actionreflexaspect experiment GUI experimentdisplaybatch experiment BDI Architecture planruleperception Finite State Machine state Tasked-based Architecture task Pictogram color modificationGAML Model generation "},{"title":"Installing the graphical editor​","type":1,"pageTitle":"The Graphical Editor","url":"wiki/G__GraphicalEditor#installing-the-graphical-editor","content":"Using the graphical editor requires to install the graphical modeling plug-in. See here for information about plug-ins and their installation. The graphical editor plug-in is called Graphical_modeling and is directly available from the GAMA update site http://updates.gama-platform.org/graphical_modeling/1.8.2 Note that the graphical editor is still under development. Updates of the plug-in will be added to the GAMA website. After installing the plug-in (and periodically), check for updates for this plug-in: in the &quot;Help&quot; menu, choose &quot;Check for Updates&quot; and install the proposed updates for the graphical modeling plug-in. "},{"title":"Creating a first model​","type":1,"pageTitle":"The Graphical Editor","url":"wiki/G__GraphicalEditor#creating-a-first-model","content":"A new diagram can be created in a new GAMA project. First, right-click on a project, then select &quot;New&quot; on the contextual menu. In the New Wizard, select &quot;GAMA -&gt; Model Diagram&quot;, then &quot;Next&gt;&quot;  In the next Wizard dialog, select the type of diagram (Empty, Skeleton or Example) then the name of the file and the author.  Skeleton and Example diagram types allow to add to the diagram some basic features. "},{"title":"Status of models in editors​","type":1,"pageTitle":"The Graphical Editor","url":"wiki/G__GraphicalEditor#status-of-models-in-editors","content":"Similarly to GAML editor, the graphical editor proposes a live display of errors and model statuses. A graphical model can actually be in three different states, which are visually accessible above the editing area: Functional (orange color), Experimentable (green color) and InError (red color). See the section on model validation for more precise information about these statuses. In its initial state, a model is always in the Functional state, which means it compiles without problems, but cannot be used to launch experiments. The InError state occurs when the file contains errors (syntactic or semantic ones). Reaching the Experimentable state requires that all errors are eliminated and that at least one experiment is defined in the model. The experiment is immediately displayed as a button in the toolbar, and clicking on it will allow the modeler to launch this experiment on your model. Experiment buttons are updated in real-time to reflect what's in your code. If more than one experiment is defined, corresponding buttons will be displayed in addition to the first one. "},{"title":"Diagram definition framework​","type":1,"pageTitle":"The Graphical Editor","url":"wiki/G__GraphicalEditor#diagram-definition-framework","content":"The following figure presents the editing framework:  "},{"title":"Features​","type":1,"pageTitle":"The Graphical Editor","url":"wiki/G__GraphicalEditor#features","content":""},{"title":"agents​","type":1,"pageTitle":"The Graphical Editor","url":"wiki/G__GraphicalEditor#agents","content":"species​  The species feature allows the modeler to define a species with a continuous topology. A species is always a micro-species of another species. The top-level (macro-species of all species) is the world species. source: a species (macro-species)target: -  grid​  The grid feature allows the modeler to define a species with a grid topology. A grid is always a micro-species of another species. source: a species (macro-species)target: -  Inheriting link​ The inheriting link feature allows the modeler to define an inheriting link between two species. source: a species (parent)target: a species (child)  world​  When a model is created, a world species is always defined. It represents the global part of the model. The world species, which is unique, is the top-level species. All other species are micro-species of the world species.  "},{"title":"agent features​","type":1,"pageTitle":"The Graphical Editor","url":"wiki/G__GraphicalEditor#agent-features","content":"action​  The action feature allows the modeler to define an action for a species. source: a species (owner of the action)target: -  reflex​  The reflex feature allows the modeler to define a reflex for a species. source: a species (owner of the reflex)target: -  aspect​  The aspect feature allows the modeler to define an aspect for a species. source: a species (owner of the aspect)target: -   equation​  The equation feature allows the modeler to define an equation for a species. source: a species (owner of the equation)target: - "},{"title":"experiment​","type":1,"pageTitle":"The Graphical Editor","url":"wiki/G__GraphicalEditor#experiment","content":"GUI experiment​  The GUI Experiment feature allows the modeler to define a GUI experiment. source: world speciestarget: -  display​  The display feature allows the modeler to define a display. source: GUI experimenttarget: -   batch experiment​  The Batch Experiment feature allows the modeler to define a Batch experiment. source: world speciestarget: - "},{"title":"BDI Architecture​","type":1,"pageTitle":"The Graphical Editor","url":"wiki/G__GraphicalEditor#bdi-architecture","content":"Plan​  The Plan feature allows the modeler to define a plan for a BDI species, i.e. a sequence of statements that will be executed in order to fulfill a particular intention. source: a species with a BDI architecturetarget: - s Rule​  The Rule feature allows the modeler to define a rule for a BDI species, i.e. a function executed at each iteration to infer new desires or beliefs from the agent's current beliefs and desires. source: a species with a BDI architecturetarget: - Perception​  The Perception feature allows the modeler to define a perception for a BDI species, i.e. a function executed at each iteration that updates the agent's Belief base according to the agent perception. source: a species with a BDI architecturetarget: - "},{"title":"Finite State Machine Architecture​","type":1,"pageTitle":"The Graphical Editor","url":"wiki/G__GraphicalEditor#finite-state-machine-architecture","content":"State​  The State feature allows the modeler to define a state for a FSM species, i.e. sequence of statements that will be executed if the agent is in this state (an agent has a unique state at a time). source: a species with a finite state machine architecturetarget: - "},{"title":"Task-based Architecture​","type":1,"pageTitle":"The Graphical Editor","url":"wiki/G__GraphicalEditor#task-based-architecture","content":"Task​  The Task feature allows the modeler to define a task for a Tasked-based species, i.e. sequence of statements that can be executed, at each time step, by the agent. If an agent owns several tasks, the scheduler chooses a task to execute based on its current priority weight value. source: a species with a task-based architecturetarget: - "},{"title":"Pictogram color modification​","type":1,"pageTitle":"The Graphical Editor","url":"wiki/G__GraphicalEditor#pictogram-color-modification","content":"It is possible to change the color of a pictogram. Right-click on a pictogram, then select the &quot;Chance the color&quot;. "},{"title":"GAML Model generation​","type":1,"pageTitle":"The Graphical Editor","url":"wiki/G__GraphicalEditor#gaml-model-generation","content":"It is possible to automatically generate a Gaml model from a diagram. Right-click on the graphical framework (where the diagram is defined), then select the &quot;Generate Gaml model&quot;. A new GAML model with the same name as the diagram is created (and open). "},{"title":"Architecture of GAMA","type":0,"sectionRef":"#","url":"wiki/GamaArchitecture","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Architecture of GAMA","url":"wiki/GamaArchitecture#table-of-contents","content":"Architecture of GAMA The minimal configurationOptional Plugins Plugins present in the release versionPlugins not present by default in the release versionPlugins not designated to be in the release version Unmaintained projectsFeaturesModelsPlugins overview "},{"title":"The minimal configuration​","type":1,"pageTitle":"Architecture of GAMA","url":"wiki/GamaArchitecture#the-minimal-configuration","content":"Here is the list of projects which have to be imported in order to run the GAMA platform, and to execute a simple model in gaml language: msi.gama.core : Encapsulates the core of the modeling and simulation facilities offered by the platform : runtime, simulation, meta-model, data structures, simulation kernel, scheduling, etc. It contains 2 main packages : msi.gamamsi.gaml, wich defines the GAML modeling language: keywords, operators, statements, species, skills msi.gama.application : Describes the graphical user interface (msi.gama.gui package). This project also contains the file gama1.7.Eclipse3_8_2.product, when you can configure the application (and also launch the application). It contains the following sub-packages : msi.gama.gui.displaysmsi.gama.gui.navigatormsi.gama.gui.parametersmsi.gama.gui.swtmsi.gama.gui.viewsmsi.gama.gui.wizardsmsi.gama.gui.viewers msi.gama.ext : Gathers all the external libraries upon which GAMA relies upon msi.gama.lang.gaml : Contains the gaml.xtext file which defines the GAML grammarmsi.gama.lang.gaml.ui : Contains the GAML Editor (syntax highlighting, code completion) msi.gama.processor : Is responsible for processing the annotations made in the Java source code and producing additions to GAML (Java, properties and documentation files), which are added into a source package called &quot;gaml.additions&quot; (containing two main generated files: GamlAdditions.java and GamlDocumentation.java). These additions are loaded automatically when GAMA launches, allowing extensions made by developers in other plugins to be recognized when their plugin is added to the platform.ummisco.gaml.editbox : Project used to define the edit boxes in the gaml ui. Minimal configuration projects dependencies:  "},{"title":"Optional Plugins​","type":1,"pageTitle":"Architecture of GAMA","url":"wiki/GamaArchitecture#optional-plugins","content":""},{"title":"Plugins present in the release version​","type":1,"pageTitle":"Architecture of GAMA","url":"wiki/GamaArchitecture#plugins-present-in-the-release-version","content":"From this minimal configuration, it is possible to add some features. Here is the list of the features installed by default in the release version: idees.gama.mapcomparison : Contains some useful tools to do map comparaisonmsi.gaml.extensions.fipa : Provides some operators for communication between agents, using the FIPA standardsmsi.gama.headless : Enables to run simulations in console modesimtools.gaml.extensions.traffic : Provides operators and skills for traffic simulationsimtools.gaml.extensions.physics : Physics engine, collision modelling, using the library JBulletummisco.gaml.extensions.maths : Solving differential equation, using Euler methods and Runge Kutta.irit.gaml.extensions.database : Provides database manipulation tools, using SQL requestsirit.gaml.extensions.test : Add unitary test statementsummisco.gama.opengl : Provide a 3D visualization using OpenGL.simtools.gamanalyzer.fr : Adding tools for the analysis of several execution result of a simulation (in order to find some correlations).dream.gama.opengis : Used to load some geographic information datas from online GIS server.simtools.graphanalysis.fr : Advanced graph operators "},{"title":"Plugins not present by default in the release version​","type":1,"pageTitle":"Architecture of GAMA","url":"wiki/GamaArchitecture#plugins-not-present-by-default-in-the-release-version","content":"Some other plugins are not present by default in the release version (because their use is very specific), but it's possible to install them through features. Here is the list of those plugins: idees.gama.weka : Data-mining operators, using the library Weka.msi.gaml.architecture.simplebdi : Architecture for using the Belief-Desire-Intention software model.ummisco.gaml.extensions.sound : Use of sound in simulationsummisco.gaml.extensions.stats : Advanced statistics operatorsummisco.gama.communicator : Communication between several instances of GAMAummisco.gaml.extensions.rjava : Adding the R language into GAMA for data mining "},{"title":"Plugins not designated to be in the release version​","type":1,"pageTitle":"Architecture of GAMA","url":"wiki/GamaArchitecture#plugins-not-designated-to-be-in-the-release-version","content":"Other plugins will never be on the released version, and will never be loaded during the gama execution. They are just used in the &quot;developer&quot; version: msi.gama.documentation : Generate automatically the documentation in the wiki form (and also a pdf file) "},{"title":"Unmaintained projects​","type":1,"pageTitle":"Architecture of GAMA","url":"wiki/GamaArchitecture#unmaintained-projects","content":"Some other projects are still in the git repository in case we need to work on it one day, but they are either unfinished, obsolete, or used in very rare situations (They are not delivered in release versions, of course). Here is the list: cenres.gaml.extensions.hydro : Provide some tools in order to create hydrology modelsmsi.gaml.extensions.traffic2d : Provide some tools for traffic in 2 dimensions (depreciated, now replace by msi.gaml.extensions.traffic)msi.gaml.extensions.humainmoving : Provide a skill to represent human movementummisco.gama.gpu : Computation directly on the GPU for more efficiency. Results or not concluant, slower than using CPU.msi.gama.hpc : &quot;High Power Computing&quot; to execute gama simulation in several computers.msi.gaml.extensions.cplex : Originaly designed to be able to run CPLEX function in GAMA. The CPLEX is a proprietary library, we can't deliver it in the project. Instead, we use a stub, &quot;cplex.jar&quot;, that you can replace by the real cplex.jar file.irit.maelia.gaml.additions : Used for the project &quot;Maelia&quot;. Provide the possibility to represent the computing time in a simulation.msi.gama.display.web : Originaly designed to run some GAMA simulation in a browser, inside gama application, using WebGL. Does not work for the momentummisco.miro.extension : Once used for the &quot;miro&quot; project, no longer used.ummisco.miro.extension.traffic : Once used for the &quot;miro&quot; project, no longer used. "},{"title":"Features​","type":1,"pageTitle":"Architecture of GAMA","url":"wiki/GamaArchitecture#features","content":"ummisco.gama.feature.audio : sound pluginummisco.feature.stats : stats pluginummisco.gama.feature.opengl.jogl2 : gathers physics and opengl pluginssimtools.graphlayout.feature : gathers core, ext, processor and graphanalysis pluginsummisco.gama.feature.core : gathers mapcomparison, database, test, application, core, ext, headless, gaml, gaml.ui, processor, fipa, traffic and maths pluginsummisco.gama.feature.dependencies : a bunch of libraries and pluginsother.gama.feature.plugins gathers hydro, opengis, addition, web, hpc, cplex, traffic2d, communicator, gpu, stats, extensions and traffic pluginsummisco.gama.feature.models : model pluginidees.gama.features.weka : weka pluginummisco.gama.feature.jogl2.product : gathering of the following features : core, dependencies, models, jogl2ummisco.gama.feature.product : gathering of the following features : core, dependencies, models, jogl1 "},{"title":"Models​","type":1,"pageTitle":"Architecture of GAMA","url":"wiki/GamaArchitecture#models","content":"Beside those plugins and features, a project dedicated to gather a bunch of examples is also in the git repository. It contains gaml code: msi.gama.models "},{"title":"Plugins overview​","type":1,"pageTitle":"Architecture of GAMA","url":"wiki/GamaArchitecture#plugins-overview","content":"Global architecture of GAMA (nb: the features graphlayout, core, dependencies, plugins, jogl2.product and product are not represented here)  "},{"title":"The GAML Editor - Generalities","type":0,"sectionRef":"#","url":"wiki/GamlEditorGeneralities","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"The GAML Editor - Generalities","url":"wiki/GamlEditorGeneralities#table-of-contents","content":"The GAML Editor - Generalities Creating a first model Create a new model or test fileCreate a new experiment file Status of models in editorsEditor PreferencesAdditional information in the EditorMultiple editorsLocal history "},{"title":"Creating a first model​","type":1,"pageTitle":"The GAML Editor - Generalities","url":"wiki/GamlEditorGeneralities#creating-a-first-model","content":"Editing a model requires that at least one project is created in User Models. If there is none, right-click on User Models and choose &quot;New... &gt; Gama Project...&quot; (if you already have user projects and want to create a model in one of them, skip the next step).  A dialog is then displayed, offering you to enter the name of the project. You can also choose whether you want to create at the same time a first model file and if you want the project contains test models. An error will be displayed if the project name already exists in the workspace, in which case you will have to change it. Two projects with similar names cannot coexist in the workspace (even if they belong to different categories).  If you want to create a new model file in your project, navigate to it and right-click on it and on the command &quot;New ...&gt;&quot;. You have a choice between three kinds of file: Model file: to create a normal .gaml model file used to define your model.Experiment file: to create a file containing only an experiment on an existing model.Test experiment file: to create unit test experiment. It is typically used to define some unit test on a given model, to ensure its quality and prevent regression bugs.  "},{"title":"Create a new model or test file​","type":1,"pageTitle":"The GAML Editor - Generalities","url":"wiki/GamlEditorGeneralities#create-a-new-model-or-test-file","content":"A new dialog is displayed, which asks for several required or optional information: The Container is normally the name of the project you have selected, but you can choose to place the file elsewhere. An error will be displayed if the container does not exist (yet) in the workspace. You can then choose whether you want to create an empty file, a file with already a skeleton of model (with the main needed elements of a model file) or simply a test model. Finally, you are invited to give this file a name. An error is displayed if this name already exists in this project. The name of the model, which is by default computed with respect to the name of the file, can be actually completely different (but it may not contain white spaces or punctuation characters). The name of the author, as well as the textual description of the model and the creation of an HTML documentation, are optional.  "},{"title":"Create a new experiment file​","type":1,"pageTitle":"The GAML Editor - Generalities","url":"wiki/GamlEditorGeneralities#create-a-new-experiment-file","content":"A new dialog is displayed, which asks for several required or optional information: The Container is normally the name of the project you have selected, but you can choose to place the file elsewhere. An error will be displayed if the container does not exist (yet) in the workspace. You can then choose the model you want to experiment on. Just type the path toward this gaml model, or browse and select one among all the models existing in the workspace.Finally, you are invited to give this file a name. An error is displayed if this name already exists in this project. The name of the model, which is by default computed with respect to the name of the file, can be actually completely different (but it may not contain white spaces or punctuation characters). The name of the author, as well as the textual description of the model and the creation of an HTML documentation, are optional.  "},{"title":"Status of models in editors​","type":1,"pageTitle":"The GAML Editor - Generalities","url":"wiki/GamlEditorGeneralities#status-of-models-in-editors","content":"Once this dialog is filled and accepted, GAMA will display the new &quot;empty&quot; model.  Although GAML files are just plain text files, and can, therefore, be produced or modified in any text processor, using the dedicated GAML editor offers many advantages, among which the live display of errors and model statuses. A model can actually be in four different states, which are visually accessible above the editing area: Functional (grey color), Experimentable (green color), InError (red color), InImportedError (red color). See the section on model compilation for more precise information about these statuses. In its initial state, a model is always in the Functional state (when it is empty), which means it compiles without problems, but cannot be used to launch experiments. If the model is created with a skeleton, it is Experimentable. The InError state, depicted below, occurs when the file contains errors (syntactic or semantic ones).  While the file is not saved, these errors remain displayed in the editor and nowhere else. If you save the file, they are now considered as &quot;workspace errors&quot; and get displayed in the &quot;Syntax errors&quot; view below the editor and explanation is available on the error icon in the GAML editor.  Reaching the Experimentable state requires that all errors are eliminated and that at least one experiment is defined in the model, which is the case now in our toy model. The experiment is immediately displayed as a button in the toolbar, and clicking on it will allow to launch this experiment on your model. See the section about running experiments for more information on this point.  Experiment buttons are updated in real-time to reflect what is in your code. If more than one experiment is defined, corresponding buttons will be displayed in addition to the first one.  The toolbar on the top of the GAML editor displays, in addition to the green experiment buttons, a button to add an experiment in the current model.  "},{"title":"Editor Preferences​","type":1,"pageTitle":"The GAML Editor - Generalities","url":"wiki/GamlEditorGeneralities#editor-preferences","content":"Text editing in general, and especially in Eclipse-based editors, sports several options and preferences. You might want to turn off/on the numbering of the lines, change the fonts used, change the colors used to highlight the code, etc. All of these preferences are accessible from the &quot;Preferences...&quot; item of the editor contextual menu.  Explore the different items present there, keeping in mind that these preferences will apply to all the editors of GAMA and will be stored in your workspace.  "},{"title":"Additional information in the Editor​","type":1,"pageTitle":"The GAML Editor - Generalities","url":"wiki/GamlEditorGeneralities#additional-information-in-the-editor","content":"You can choose to display or not some information in your Editor, from the Models menu available when the GAML editor is active.  In particular, this menu allows the user to activate/deactivate the additional information that can be displayed in the editor: &quot;Display line number&quot;: the display of the line number in the left margin.&quot;Fold code sections&quot;: the - and + icons on the left of each code section can fold/unfold the associated code section.&quot;Mark occurrence of symbols&quot;: when the name of a variable or species is selected in the code, all its other occurrences will be also marked.&quot;Colorize code sections&quot;: the code section can be colorized, improving the visualization of the model organization (see below).&quot;Show markers overview&quot;: a right-click on the left margin of the editor allows the user to add either bookmarks or tasks to the editor (with a mark on the right margin.   One particular option, shipped by default with GAMA, is the possibility to not only highlight the code of your model, but also its structure (complementing, in that sense, the Outline view). It is a slightly modified version of a plugin called EditBox.  The Default theme of EditBox might not suit everyone's tastes, so the preferences allow to entirely customize how the &quot;boxes&quot; are displayed and how they can support the modeler in better understanding &quot;where&quot; it is in the code. The &quot;themes&quot; defined in this way are stored in the workspace, but can also be exported for reuse in other workspaces, or sharing them with other modelers.  "},{"title":"Multiple editors​","type":1,"pageTitle":"The GAML Editor - Generalities","url":"wiki/GamlEditorGeneralities#multiple-editors","content":"GAMA inherits from Eclipse the possibility to entirely configure the placement of the views, editors, etc. This can be done by rearranging their position using the mouse (click and hold on an editor's title and move it around). In particular, you can have several editors side by side, which can be useful for viewing the documentation while coding a model.  "},{"title":"Local history​","type":1,"pageTitle":"The GAML Editor - Generalities","url":"wiki/GamlEditorGeneralities#local-history","content":"Among the various options present to work with models, which you are invited to try out and test at will, one, called Local history is particularly interesting and worth a small explanation. When you edit models, GAMA keeps in the background all the successive versions you save (the history duration is configurable in the preferences), whether or not you are using a versioning system like SVN or Git. This local history is accessible from the contextual menu on the chosen model.  This command invokes the opening of a new view, which you can see in the figure below, and which lists the different versions of your file so far. You can then choose one and, right-clicking on it, either open it in a new editor or compare it to your current version.  This allows you to precisely pinpoint the modifications brought to the file and, in case of problems, to revert them easily, or even revert the entire file to a previous version. Never lose your work again!  This short introduction to GAML editors is now over. You might want to take a look, now, at how the models you edit are parsed, validated and compiled, and how this information is accessible to the modeler. "},{"title":"GAML Editor tools","type":0,"sectionRef":"#","url":"wiki/GamlEditorToolbar","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#table-of-contents","content":"GAML Editor tools Navigation tools in the editorVisualization tools in the menuVocabulary tools in the menuVocabulary tools in the toolbarFormatting tools in the contextual menu Mini-map "},{"title":"Navigation tools in the editor​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#navigation-tools-in-the-editor","content":" In the Editor toolbar, you have some tools for search and navigation through the code. Here are explanations for each functionality: "},{"title":"Previous/next edit locations​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#previousnext-edit-locations","content":"The two arrow shape buttons that are coming first are used to jump from the current location of your cursor to the last position, even if the last position was in another file (and even if this file has been closed !). "},{"title":"The search engine​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#the-search-engine","content":"To search an occurrence of a word (or the part of a word), you can type your search in the field, and the result will be highlighted automatically in the text editor.  With the left/right arrows, you can highlight the previous/next occurrence of the word. If you prefer the eclipse interface for the search engine, you can also access the tool by taping Ctrl+F. "},{"title":"Show outline​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#show-outline","content":"This last tool of this section is used to show the global architecture of your model, with explicit icons for each section. A search field is also available if you want to search for a specific section. By double-clicking one line of the outline, you can jump directly to the chosen section. This feature can be useful if you have a big model to manipulate.  "},{"title":"Visualization Tools in the menu​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#visualization-tools-in-the-menu","content":"You can choose to display or not some information in your Editor, from the Model menu. Here are the different features available.  "},{"title":"Display line number​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#display-line-number","content":"The first toggle is used to show/hide the number of lines. "},{"title":"Fold code sections​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#fold-code-sections","content":"The second toggle provides you the possibility to expand or collapse lines in your model depending on the indentation. This feature can be very useful for big models, to collapse the part you have already finished. "},{"title":"Mark occurrences of symbols​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#mark-occurrences-of-symbols","content":"This third toggle is used to show occurrences when your cursor is pointing on one word. "},{"title":"Colorize code sections​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#colorize-code-sections","content":"One particular option, shipped by default with GAMA, is the possibility to not only highlight the code of your model but also its structure (complementing, in that sense, the Outline view). It is a slightly modified version of a plugin called EditBox, which can be activated by clicking on the &quot;green square&quot; icon in the toolbar.  The Default theme of EditBox might not suit everyone's tastes, so the preferences allow to entirely customize how the &quot;boxes&quot; are displayed and how they can support the modeler in better understanding &quot;where&quot; it is in the code. The &quot;themes&quot; defined in this way are stored in the workspace, but can also be exported for reuse in other workspaces, or sharing them with other modelers.  "},{"title":"Show markers overview​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#show-markers-overview","content":"It is possible to add two kinds of marker on the code: Bookmarks (a simple bookmark on a line of code that helps to go back to some lines of interest) and Tasks (in addition to a marker on a line, a Task expresses that something should be done, with a given priority, on the code line). The markers are also visible in the right margin of the editor. An additional view (named Tasks, that can be opened from the Views menu) gathers all the tasks, helping modelers to organize their work.  "},{"title":"Vocabulary tools in the menu​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#vocabulary-tools-in-the-menu","content":" The second group of commands in the Model menu are used to search the correct way to write a certain keyword. "},{"title":"Templates​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#templates","content":"The templates button is used to insert directly a code snippet in the current position of the cursor. Some snippets are already available, ordered by scope. You can custom the list of templates as much as you want, new templates can be added from the Preferences dialog. For example, if the modeler clicks on Template &gt; Species &gt; grid &gt; insert, the following code is generated: grid name width:grid_w height:grid_h { }  "},{"title":"Built-in structures​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#built-in-structures","content":"With this feature, you can easily know the list of built-in attributes and built-in actions you can use in such or such context. With this feature, you can also insert some templates to help you, for example, to insert a pre-made species using a particular skill, as it is shown it the following screenshot:  ... will generate the following code:  All the comments are generated automatically from the current documentation. "},{"title":"Operators​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#operators","content":"Once again, this powerful feature can be used to generate an example of structures for all the operators, ordered by categories. "},{"title":"Colors​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#colors","content":"Here is the list of the name for the different pre-made colors you can use. You can also add some custom colors.  "},{"title":"Vocabulary tools in the toolbar​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#vocabulary-tools-in-the-toolbar","content":"All the information that is available in the &quot;Model&quot; menu can also be accessed, in another way, from the research engine located in the GAMA interface toolbar, named &quot;GAML reference&quot;. Any word typed in this search engine will be searched in all the keyword of the GAML language: for example, if the word experiment is searched, the search engine retrieves its occurrence as a built-in species, a statement, an attribute or a type... This is definitely the easiest way to get information about any GAML keyword.  "},{"title":"Formatting tools in the contextual menu​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#formatting-tools-in-the-contextual-menu","content":" Some other tools are available in the contextual menu to help for the formatting and refactoring of the model: "},{"title":"Rename element​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#rename-element","content":"Once an element selected, this command allows the modeler to rename it. All the occurrences of this element name will be altered. This is particularly useful in a model when we want to refactor the model: e.g. rename an attribute and that this modification to be taken into account in all the model code. "},{"title":"Source > Comment​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#source--comment","content":"This command is used to comment a line (or a group of lines). "},{"title":"Source > Format​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#source--format","content":"This useful feature re-indent automatically all your model. "},{"title":"Mini-map​","type":1,"pageTitle":"GAML Editor tools","url":"wiki/GamlEditorToolbar#mini-map","content":"The mini-map provides a view of the whole model in a very tiny font. It helps to have an overview of the model. The mini-map is a View that needs to be shown, from the View menu.  The mini-map view can be moved close to the editor. The modeler can navigate in the mini-map to move quickly between the various parts of the model.  "},{"title":"GAML References","type":0,"sectionRef":"#","url":"wiki/GamlReference","content":"","keywords":""},{"title":"Index of keywords​","type":1,"pageTitle":"GAML References","url":"wiki/GamlReference#index-of-keywords","content":"The Index page contains the exhaustive list of the GAML keywords, with a link to a detailed description of each of them. "},{"title":"The global species","type":0,"sectionRef":"#","url":"wiki/GlobalSpecies","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"The global species","url":"wiki/GlobalSpecies#index","content":"DeclarationEnvironment SizeBuilt-in AttributesBuilt-in ActionsThe init statement "},{"title":"Declaration​","type":1,"pageTitle":"The global species","url":"wiki/GlobalSpecies#declaration","content":"A GAMA model contains a unique global section that defines the global species. global { // definition of global attributes, actions, behaviours }  global can use facets, such as the torus facet, to make the environment a torus or not (if it is a torus, all the agents going out of the environment will appear on the other side. If it's not, the agents won't be able to go out of the environment). By default, the environment is not a torus.  global torus:true { // definition of global attributes, actions, behaviours }  Other facets such as control or schedules are also available, but we will explain them later. Directly in the global scope, you have to declare all your global attributes (can be seen as &quot;static members&quot; in Java or C++). To declare them, proceed exactly as for declaring basic variables. Those attributes are accessible wherever you want inside the species scope. "},{"title":"Environment size​","type":1,"pageTitle":"The global species","url":"wiki/GlobalSpecies#environment-size","content":"In the global context, you have to define a size and a shape for your environment. In fact, an attribute already exists for the global species: it's called shape, and its type is a geometry. By default, shape is equal to a 100m*100m square. You can change the geometry of the shape by affecting another value: geometry shape &lt;- circle(50#mm); geometry shape &lt;- rectangle(10#m,20#m); geometry shape &lt;- polygon([{1°m,2°m},{3°m,50°cm},{3.4°m,60°dm}]);  nb: there are just examples. Try to avoid mixing dimensions! If no dimensions are specified, it will be meter by default. "},{"title":"Built-in attributes​","type":1,"pageTitle":"The global species","url":"wiki/GlobalSpecies#built-in-attributes","content":"Some attributes exist by default for the global species. The attribute shape is one of them (refers to the shape of the environment). Here is the list of the other built-in attributes: Like the other attributes of the global species, global built-in attributes can be accessed (and sometimes modified) by the world agent and every other agent in the model. "},{"title":"world​","type":1,"pageTitle":"The global species","url":"wiki/GlobalSpecies#world","content":"represents the sole instance of the model species (i.e. the one defined in the global section). It is accessible from everywhere (including experiments) and gives access to built-in or user-defined global attributes and actions. "},{"title":"experiment​","type":1,"pageTitle":"The global species","url":"wiki/GlobalSpecies#experiment","content":"contains the experiment agent that has created this simulation agent. "},{"title":"cycle​","type":1,"pageTitle":"The global species","url":"wiki/GlobalSpecies#cycle","content":"integer, read-only, designates the (integer) number of executions of the simulation cycles. Note that the first cycle is the cycle with number 0. To learn more about time, please read the recipe about dates. "},{"title":"step​","type":1,"pageTitle":"The global species","url":"wiki/GlobalSpecies#step","content":"float, is the length, in model time, of an interval between two cycles, in seconds. Its default value is 1 (second). Each turn, the value of time is incremented by the value of step. The definition of step must be coherent with that of the agents' variables like speed. The use of time units is particularly relevant for its definition. To learn more about time, please read the recipe about dates. global { ... float step &lt;- 10 #h; ... }  "},{"title":"time​","type":1,"pageTitle":"The global species","url":"wiki/GlobalSpecies#time","content":"float, read-only, represents the current simulated time in seconds (the default unit). It is the time in the model time. Begins at zero. Basically, we have: time = cycle * step . global { ... int nb_minutes function: { int(time / 60)}; ... }  To learn more about time, please read the recipe about dates. "},{"title":"starting_date and current_date​","type":1,"pageTitle":"The global species","url":"wiki/GlobalSpecies#starting_date-and-current_date","content":"date, represent the starting date (resp. the current date) of the simulation. The current_date is updated from the starting_date by the value step at each simulation step. To learn more about time, please read the recipe about dates. "},{"title":"duration​","type":1,"pageTitle":"The global species","url":"wiki/GlobalSpecies#duration","content":"string, read-only, represents the value that is equal to the duration in real machine time of the last cycle. "},{"title":"total_duration​","type":1,"pageTitle":"The global species","url":"wiki/GlobalSpecies#total_duration","content":"string, read-only, represents the sum of duration since the beginning of the simulation. "},{"title":"average_duration​","type":1,"pageTitle":"The global species","url":"wiki/GlobalSpecies#average_duration","content":"string, read-only, represents the average of duration since the beginning of the simulation. "},{"title":"machine_time​","type":1,"pageTitle":"The global species","url":"wiki/GlobalSpecies#machine_time","content":"float, read-only, represents the current machine time in milliseconds. "},{"title":"seed​","type":1,"pageTitle":"The global species","url":"wiki/GlobalSpecies#seed","content":"float, the seed of the random number generator. It will influence the set of random numbers that will be generated all over the simulation. 2 simulations of a model with the same parameters' values should behave identically when the seed is set to the same value. If it is not redefined by the modeler, it will be chosen randomly. "},{"title":"agents​","type":1,"pageTitle":"The global species","url":"wiki/GlobalSpecies#agents","content":"list, read-only, returns a list of all the agents of the model that are considered as &quot;active&quot; (i.e. all the agents with behaviors, excluding the places). Note that obtaining this list can be quite time consuming, as the world has to go through all the species and get their agents before assembling the result. For instance, instead of writing something like: ask agents of_species my_species { ... }  one would prefer to write (which is much faster): ask my_species { ... }  Note that any agent has the agents attribute, representing the agents it contains. So to get all the agents of the simulation, we need to access the agents of the world using: world.agents. "},{"title":"Built-in Actions​","type":1,"pageTitle":"The global species","url":"wiki/GlobalSpecies#built-in-actions","content":"The global species is provided with two specific actions. "},{"title":"pause​","type":1,"pageTitle":"The global species","url":"wiki/GlobalSpecies#pause","content":"pauses the simulation, which can then be continued by the user. global { ... reflex toto when: time = 100 { do pause; } }  "},{"title":"die​","type":1,"pageTitle":"The global species","url":"wiki/GlobalSpecies#die","content":"stops the simulation (in fact it kills the simulation). global { ... reflex halting when: empty (agents) { do die; } }  Other built-in actions are defined for the model species, just as in any other regular species. "},{"title":"The init statement​","type":1,"pageTitle":"The global species","url":"wiki/GlobalSpecies#the-init-statement","content":"After declaring all the global attributes and defining your environment size, you can define an initial state (before launching the simulation). Here, you normally initialize your global variables, and you instantiate your species. We will see in the next session how to initialize a regular species. "},{"title":"Graph Species","type":0,"sectionRef":"#","url":"wiki/GraphSpecies","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"Graph Species","url":"wiki/GraphSpecies#index","content":"Declaration Declare a graph with handmade agentsDeclare a graph by using an geometry fileDeclare a graph with nodes and edges Useful operators with graph Knowing the degree of a nodeGet the neighbors of a nodeCompute the shortest pathControl the weight in graph Example "},{"title":"Declaration​","type":1,"pageTitle":"Graph Species","url":"wiki/GraphSpecies#declaration","content":""},{"title":"Declare a graph with handmade agents​","type":1,"pageTitle":"Graph Species","url":"wiki/GraphSpecies#declare-a-graph-with-handmade-agents","content":"To instantiate this graph, we rely on the two built-in species graph_node and base_edge. We need to define our own node and edge species as children species of the 2 built-in species. First, the node species must inherit from the abstract species graph_node, then the method related_to must be redefined and finally an auxiliary species that inherits from base_edge used to represent the edges of the generated graph must be declared. A graph node is an abstract species that must redefine one method called related_to. species my_node parent: graph_node edge_species: edge_agent{ bool related_to(my_node other){ return true; } } species edge_agent parent: base_edge { }  The method related_to returns a boolean and takes the agents from the current species as argument. If the method returns true, the two agents (the current instance and the one as argument) will be linked. The method is automatically called for each agent with each other agent of the given species in argument. Note that in the following example, related_to returns always true, so each agent will be linked to each other agent: we will get a complete graph. model NewModel global { int number_of_agents &lt;- 5; init { create my_node number: number_of_agents; } } species my_node parent: graph_node edge_species: edge_agent { bool related_to (my_node other) { return true; } aspect base { draw circle(1) color: #green; } } species edge_agent parent: base_edge { aspect base { draw shape color: #blue; } } experiment MyExperiment type: gui { output { display MyDisplay type: java2D { species my_node aspect: base; species edge_agent aspect: base; } } }   You can, for example, link 2 agents when they are closer than a certain distance. Beware: The topology used in graph species is the graph topology and not the continuous topology. You can force the use of the continuous topology with the action using as follow: bool related_to(my_node other){ using topology(world) { return (self.location distance_to other.location &lt; 20); } }   The abstract mother species graph_node has an attribute my_graph, with the type graph. The graph type represents a graph composed of vertices linked with edges. This type has built-in attributes such as edges (the list of all the edges agents), or vertices (the list of all the vertices agents). "},{"title":"Declare a graph by using a geometry file​","type":1,"pageTitle":"Graph Species","url":"wiki/GraphSpecies#declare-a-graph-by-using-a-geometry-file","content":"In most cases, you will have to construct a graph from an existing file (example: a &quot;shp&quot; file). In that case, you will have to first instantiate a species from the shape file (with the create statement, using the facet from). Then, you will have to construct a graph from the agent, using one of the available operators such as as_edge_graph. model load_shape_file global { file roads_shapefile &lt;- file(&quot;../includes/road.shp&quot;); geometry shape &lt;- envelope(roads_shapefile); graph road_network; init { create road from: roads_shapefile; road_network &lt;- as_edge_graph(road); } } species road { aspect geom { draw shape color: #black; } } experiment main_experiment type:gui{ output { display map { species road aspect:geom; } } }  "},{"title":"Declare a graph with nodes and edges​","type":1,"pageTitle":"Graph Species","url":"wiki/GraphSpecies#declare-a-graph-with-nodes-and-edges","content":"Another way to create a graph is building it manually nodes by nodes, and then edges by edges, without using agent structures. Use the add_node operator and the add_edge operator to do so. Here is an example of how to do: list&amp;lt;point&gt; nodes &lt;- []; graph my_graph &lt;- graph([]); add point(0.0,0.0) to:nodes; add point(90.0,90.0) to:nodes; add point(20.0,20.0) to:nodes; add point(40.0,50.0) to:nodes; add point(100.0,0.0) to:nodes; loop nod over: nodes { my_graph &lt;- my_graph add_node(nod); } my_graph &lt;- my_graph add_edge (nodes at 0::nodes at 2); my_graph &lt;- my_graph add_edge (nodes at 2::nodes at 3); my_graph &lt;- my_graph add_edge (nodes at 3::nodes at 1); my_graph &lt;- my_graph add_edge (nodes at 0::nodes at 4); my_graph &lt;- my_graph add_edge (nodes at 4::nodes at 1);  Using this solution, my_graph can have two types: it can be an a-spatial graph, or a spatial graph. The spatial graph will have a proper geometry, with segments that follow the position of your graph (you can access to the segments by using the built-in &quot;segments&quot;). The a-spatial graph will not have any shape. global { graph my_spatial_graph&lt;-spatial_graph([]); graph my_aspatial_graph&lt;-graph([]); init { point node1 &lt;- {0.0,0.0}; point node2 &lt;- {10.0,10.0}; my_spatial_graph &lt;- my_spatial_graph add_node(node1); my_spatial_graph &lt;- my_spatial_graph add_node(node2); my_spatial_graph &lt;- my_spatial_graph add_edge(node1::node2); write my_spatial_graph.edges; // the output is [polyline ([{0.0,0.0,0.0},{10.0,10.0,0.0}])] my_aspatial_graph &lt;- my_aspatial_graph add_node(node1); my_aspatial_graph &lt;- my_aspatial_graph add_node(node2); my_aspatial_graph &lt;- my_aspatial_graph add_edge(node1::node2); write my_aspatial_graph.edges; // the output is [{0.0,0.0,0.0}::{10.0,10.0,0.0}] } }  "},{"title":"Useful operators with graph​","type":1,"pageTitle":"Graph Species","url":"wiki/GraphSpecies#useful-operators-with-graph","content":""},{"title":"Knowing the degree of a node​","type":1,"pageTitle":"Graph Species","url":"wiki/GraphSpecies#knowing-the-degree-of-a-node","content":"The operator degree_of returns the number of edges attached to a node. To use it, you have to specify a graph (on the left side of the operator), and a node (on the right side of the operator). The following code (to put inside the node species) displays the number of edges attached to each node: aspect base { draw string(my_graph degree_of node(5)) color:# black; }  "},{"title":"Get the neighbors of a node​","type":1,"pageTitle":"Graph Species","url":"wiki/GraphSpecies#get-the-neighbors-of-a-node","content":"To get the list of neighbors of a node, you should use the neighbors_of operator. On the left side of the operator, specify the graph you are using, and on the right side, specify the node. The operator returns the list of nodes located at a distance inferior or equal to 1, considering the graph topology. species graph_agent parent: graph_node edge_species: edge_agent { list&amp;lt;graph_agent&gt; list_neighbors &lt;- list&amp;lt;graph_agent&gt;(my_graph neighbors_of (self)); }  Here is an example of a model using those two previous concepts (a random node is chosen each step, displayed in red, and his neighbors are displayed in yellow):  model graph_model global { int number_of_agents &lt;- 50; init { create my_node number: number_of_agents; } reflex update { ask one_of(my_node) { status &lt;- 2; do update_neighbors; } } } species my_node parent: graph_node edge_species: edge_agent { int status &lt;- 0; list&amp;lt;int&gt; list_connected_index; init { int i &lt;- 0; loop g over: my_node { if (flip(0.1)) { add i to:list_connected_index; } i &lt;- i+1; } } bool related_to(my_node other){ if (list_connected_index contains (my_node index_of other)) { return true; } return false; } action update_neighbors { list&amp;lt;my_node&gt; list_neighbors &lt;- my_graph neighbors_of (self); loop neighb over: list_neighbors { neighb.status &lt;- 1; } } aspect base { if (status = 0) { draw circle(2) color: #green border: #black; } else if (status = 1) { draw circle(2) color: #yellow border: #black; } else if (status = 2) { draw circle(2) color: #red border: #black; } draw string(my_graph degree_of self) color: #black size: 4 at: {self.location.x-1, self.location.y-2}; status &lt;- 0; } } species edge_agent parent: base_edge { aspect base { draw shape color: #blue; } } experiment MyExperiment type: gui { output { display MyDisplay type: java2D { species my_node aspect: base; species edge_agent aspect: base; } } }  "},{"title":"Compute the shortest path​","type":1,"pageTitle":"Graph Species","url":"wiki/GraphSpecies#compute-the-shortest-path","content":"To compute the shortest path to go from a point to another one, pick a source and a destination among the vertices you have for your graph. Store those values as point type. point source; point destination; source &lt;- point(one_of(my_graph.vertices)); destination &lt;- point(one_of(my_graph.vertices));  Then, you can use the operator path_between to return the shortest path. To use this operator, you have to give the graph, then the source point, and the destination point. This operator returns a path type object. path shortest_path; shortest_path &lt;- path_between (my_graph, source,destination);  Another operator exists, paths_between, that returns a list of shortest paths between two points. Please read the documentation to learn more about this operator. Here is an example of code that shows the shortest path between two points of a graph:  model graph_model global { int number_of_agents &lt;- 50; point source; point target; graph the_graph; path shortest_path; init { create my_node number: number_of_agents; } reflex pick_two_points { if (the_graph = nil) { the_graph &lt;- one_of(my_node).my_graph; } shortest_path &lt;- nil; loop while: shortest_path = nil { source &lt;- (one_of(the_graph.vertices)); target &lt;- (one_of(the_graph.vertices)); if (source != target) { shortest_path &lt;- path_between(the_graph, source, target); } } } } species my_node parent: graph_node edge_species: edge_agent { list&amp;lt;int&gt; list_connected_index; init { int i &lt;- 0; loop g over: my_node { if (flip(0.1)) { add i to: list_connected_index; } i &lt;- i + 1; } } bool related_to (my_node other) { using topology(world) { return (self.location distance_to other.location &lt; 20); } } aspect base { draw circle(2) color: #green border: #black; } } species edge_agent parent: base_edge { aspect base { draw shape color: #blue; } } experiment MyExperiment type: gui { output { display MyDisplay type: java2D { species my_node aspect: base; species edge_agent aspect: base; graphics &quot;shortest path&quot; { if (shortest_path != nil) { draw circle(3) at: source color: #yellow border: #black; draw circle(3) at: target color: #cyan border: #black; draw (shortest_path.shape + 1) color: #magenta; } } } } }  "},{"title":"Control the weight in graph​","type":1,"pageTitle":"Graph Species","url":"wiki/GraphSpecies#control-the-weight-in-graph","content":"You can add a map of weight for the edges that compose the graph. Use the operator with_weights to put weights in your graph. The graph has to be on the left side of the operator, and the map has to be on the right side. In the map, you have to put edges as key, and the weight for that edge as value. One common use is to put the distance as weight: my_graph &lt;- my_graph with_weights (my_graph.edges as_map (each::geometry(each).perimeter));  The calculation of the shortest path can change according to the weight you choose for your edges. For example, here is the result of the calculation of the shortest path when all the edges have 1 as weight value (it is the default graph topology), and when the edges have their length as weight.  Here is an example of implementation: model shortest_path_with_weight global { graph my_graph&lt;-spatial_graph([]); path shortest_path; list&amp;lt;point&gt; nodes; init { add point(10.0,10.0) to:nodes; add point(90.0,90.0) to:nodes; add point(40.0,20.0) to:nodes; add point(80.0,50.0) to:nodes; add point(90.0,20.0) to:nodes; loop nod over: nodes { my_graph &lt;- my_graph add_node(nod); } my_graph &lt;- my_graph add_edge (nodes at 0::nodes at 2); my_graph &lt;- my_graph add_edge (nodes at 2::nodes at 3); my_graph &lt;- my_graph add_edge (nodes at 3::nodes at 1); my_graph &lt;- my_graph add_edge (nodes at 0::nodes at 4); my_graph &lt;- my_graph add_edge (nodes at 4::nodes at 1); // comment/decomment the following line to see the difference. my_graph &lt;- my_graph with_weights (my_graph.edges as_map (each::geometry(each).perimeter)); shortest_path &lt;- path_between(my_graph,nodes at 0, nodes at 1); } } experiment MyExperiment type: gui { output { display MyDisplay type: java2D { graphics &quot;shortest path&quot; { if (shortest_path != nil) { draw circle(3) at: point(shortest_path.source) color: #yellow; draw circle(3) at: point(shortest_path.target) color: #cyan; draw (shortest_path.shape+1) color: #magenta; } loop edges over: my_graph.edges { draw geometry(edges) color: #black; } } } } }  "},{"title":"Grid Species","type":0,"sectionRef":"#","url":"wiki/GridSpecies","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"Grid Species","url":"wiki/GridSpecies#index","content":"DeclarationBuilt-in attributesAccess to a cellDisplay gridGrid from a matrixExample "},{"title":"Declaration​","type":1,"pageTitle":"Grid Species","url":"wiki/GridSpecies#declaration","content":"Instead of using the species keyword, use the keyword grid to declare a grid species. The grid species has exactly the same facets as the regular species, plus some others. To declare a grid, you can specify the number of columns and rows first (another possibility to declare the grid is detailed below when (we create a grid from a matrix)[GridSpecies#grid-from-a-matrix]). You can do it in two different ways: Using the two facets width and height to fix the number of cells (the size of each cell will be determined thanks to the environment dimension). grid my_grid width: 8 height: 10 { // my_grid has 8 columns and 10 rows }  Using the two facets cell_width and cell_height to fix the size of each cell (the number of cells will be determined thanks to the environment dimension). grid my_grid cell_width: 3 cell_height: 2 { // my_grid has cells with dimension 3m width by 2m height }  By default, a grid is composed of 100 rows and 100 columns. Another facet exists for grid only, very useful. It is the neighbors facet, used to determine how many neighbors each cell has. You can choose among 3 values: 4 (Von Neumann), 6 (hexagon) or 8 (Moore).  A grid can also be provided with specific facets that allow to optimize the computation time and the memory space, such as use_regular_agents, use_indivitual_shapes and use_neighbors_cache. Please refer to the GAML Reference for more explanation about those particular facets. "},{"title":"Built-in attributes​","type":1,"pageTitle":"Grid Species","url":"wiki/GridSpecies#built-in-attributes","content":""},{"title":"grid_x​","type":1,"pageTitle":"Grid Species","url":"wiki/GridSpecies#grid_x","content":"This variable stores the column index of a cell. grid cell width: 10 height: 10 neighbors: 4 { init { write &quot;my column index is:&quot; + grid_x; } }  "},{"title":"grid_y​","type":1,"pageTitle":"Grid Species","url":"wiki/GridSpecies#grid_y","content":"This variable stores the row index of a cell. grid cell width: 10 height: 10 neighbors: 4 { init { write &quot;my row index is:&quot; + grid_y; } }  "},{"title":"color​","type":1,"pageTitle":"Grid Species","url":"wiki/GridSpecies#color","content":"The color built-in variable is used by the optimized grid display. Indeed, it is possible to use for grid agents an optimized aspect by using in a display the grid keyword. In this case, the grid will be displayed using the color defined by the color variable. The border of the cells can be displayed with a specific color by using the lines facet. Here an example of the display of a grid species named cell with black border. experiment main_xp type: gui{ output { display map { grid cell lines: #black ; } } }  "},{"title":"neighbors​","type":1,"pageTitle":"Grid Species","url":"wiki/GridSpecies#neighbors","content":"The neighbors built-in variable returns the list of cells at a distance of 1. This list obviously depends on the neighbor type defined in the grid statement (4,6, or 8). grid my_grid { reflex writeNeighbors { write neighbors; } }  "},{"title":"grid_value​","type":1,"pageTitle":"Grid Species","url":"wiki/GridSpecies#grid_value","content":"The grid_value built-in variable is used when initializing a grid from grid file (see later). It contains the value stored in the data file for the associated cell. It is also used for the 3D representation of DEM. "},{"title":"\"Missing\" attribute​","type":1,"pageTitle":"Grid Species","url":"wiki/GridSpecies#missing-attribute","content":"Information that is commonly asked a cell agent is the set of agents located inside it. This information is not stored in the agent, but can be computed using the inside operator:  grid cell width: 10 height: 10 neighbors: 4 { list&amp;lt;bug&gt; bugs_inside -&gt; {bug inside self}; }  "},{"title":"Access to a cell​","type":1,"pageTitle":"Grid Species","url":"wiki/GridSpecies#access-to-a-cell","content":"There are several ways to access a specific cell: by a location: by casting a location variable (of type point) to a cell, GAMA will compute the cell that covers the given location: global { init { write &quot;cell at {57.5, 45} :&quot; + cell({57.5, 45}); } } grid cell width: 10 height: 10 neighbors: 4 { }  by the row and column indexes: like matrix, it is possible to directly access to a cell from its indexes global { init { write &quot;cell [5,8] :&quot; + cell[5, 8]; } } grid cell width: 10 height: 10 neighbors: 4 { }  The operator grid_at also exists to get a particular cell. You just have to specify the index of the cell you want (in x and y): global { init { agent cellAgent &lt;- cell grid_at {5, 8}; write &quot;cell [5,8] :&quot; + cellAgent; } } grid cell width: 10 height: 10 neighbors: 4 { }  "},{"title":"Display Grid​","type":1,"pageTitle":"Grid Species","url":"wiki/GridSpecies#display-grid","content":"You can easily display your grid in your experiment as followed: experiment MyExperiment type: gui { output { display MyDisplay type: opengl { grid MyGrid; } } }  The grid will be displayed, using the color you defined for each cell (with the color built-in attribute). You can also show the border of each cell by using the facet lines and choosing a color: display MyDisplay type: opengl { grid MyGrid lines: #black; }  Another way to display a grid will be to define an aspect in your grid agent (the same way as for a regular species), and add your grid as a regular species in the display of in your experiment and thus by specifying its aspect: grid MyGrid { aspect firstAspect { draw square(1); } aspect secondAspect { draw circle(1); } } experiment MyExperiment type: gui { output { display MyDisplay type: opengl { species MyGrid aspect: firstAspect; } } }  Beware: do not use this second display when you have large grids: it is much slower. "},{"title":"Grid from a matrix​","type":1,"pageTitle":"Grid Species","url":"wiki/GridSpecies#grid-from-a-matrix","content":"An easy way to load some values in a grid is to use matrix data. A matrix is a type of container (we invite you to learn some more about this useful type here). Once you have declared your matrix, you can set the values of your cells using the ask statement : global { init { matrix data &lt;- matrix([[0,1,1],[1,2,0]]); ask cell { grid_value &lt;- float(data[grid_x, grid_y]); } } }  Declaring larger matrix in GAML can be boring as you can imagine. You can load your matrix directly from a csv file with the operator matrix (used for the contruction of the matrix). file my_file &lt;- csv_file(&quot;path/file.csv&quot;,&quot;separator&quot;); matrix my_matrix &lt;- matrix(my_file);  You can try to read the following csv : 0,0,0,0,0,0,0,0,0,0,0 0,0,0,1,1,1,1,1,0,0,0 0,0,1,1,0,0,0,1,1,0,0 0,1,1,0,0,0,0,0,0,0,0 0,1,1,0,0,1,1,1,1,0,0 0,0,1,1,0,0,1,1,1,0,0 0,0,0,1,1,1,1,0,1,0,0 0,0,0,0,0,0,0,0,0,0,0  With the following model: model import_csv global { file my_csv_file &lt;- csv_file(&quot;../includes/test.csv&quot;,&quot;,&quot;); init { matrix data &lt;- matrix(my_csv_file); ask my_gama_grid { grid_value &lt;- float(data[grid_x,grid_y]); write data[grid_x,grid_y]; } } } grid my_gama_grid width: 11 height: 8 { reflex update_color { write grid_value; color &lt;- (grid_value = 1) ? #blue : #white; } } experiment main type: gui{ output { display display_grid { grid my_gama_grid; } } }  For more complicated models, you can read some other files, such as ASCII files (asc), DEM files. In this case, the creation of the grid is even easier as the dimensions of the grid can be read from the file with the file facet: grid my_grid from: my_asc_file { }  "},{"title":"Example​","type":1,"pageTitle":"Grid Species","url":"wiki/GridSpecies#example","content":"To practice a bit those notions, we will build a quick model. A &quot;regular&quot; species will move randomly on the environment. A grid is displayed, and its cells becomes red when an instance of the regular species is waking inside this cell, and yellow when the regular agent is in the surrounding of this cell. If no regular agent is on the surrounding, the cell turns green.  Here is an example of implementation: model my_grid_model global{ float max_range &lt;- 5.0; int number_of_agents &lt;- 5; init { create my_species number: number_of_agents; } reflex update { ask my_species { do wander amplitude: 180.0; ask my_grid at_distance(max_range) { if(self overlaps myself) { self.color_value &lt;- 2; } else if (self.color_value != 2) { self.color_value &lt;- 1; } } } ask my_grid { do update_color; } } } species my_species skills:[moving] { float speed &lt;- 2.0; aspect default { draw circle(1) color: #blue; } } grid my_grid width:30 height:30 { int color_value &lt;- 0; action update_color { if (color_value = 0) { color &lt;- #green; } else if (color_value = 1) { color &lt;- #yellow; } else if (color_value = 2) { color &lt;- #red; } color_value &lt;- 0; } } experiment MyExperiment type: gui { output { display MyDisplay type: java2D { grid my_grid lines: #black; species my_species aspect: default; } } }  "},{"title":"Headless Batch","type":0,"sectionRef":"#","url":"wiki/HeadlessBatch","content":"","keywords":""},{"title":"Getting started​","type":1,"pageTitle":"Headless Batch","url":"wiki/HeadlessBatch#getting-started","content":"This headless mode is the Batch one. The advantage of this mode is how easily it is to prepare and launch, contrarily to the Headless Legacy, this mode do not need any other file than the GAML file holding the experiment of type batch. Once you finished preparing your batch experiment, you can run it with a command similar to this out: bash ./gama-headless.sh [option] -batch experimentName /path/to/file.gaml  with: -batch: the runner flag to launch a batch explorationexperimentName: the name of your batch experiment in the following file/path/to/file.gaml: the path (relative or absolute) containing the batch experiment "},{"title":"Simulation Output​","type":1,"pageTitle":"Headless Batch","url":"wiki/HeadlessBatch#simulation-output","content":"Unfortunatly, this mode can't save output data automatically, the actual way to do is saving wanted data inside CSV files from your model. "},{"title":"Headless Legacy","type":0,"sectionRef":"#","url":"wiki/HeadlessLegacy","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Headless Legacy","url":"wiki/HeadlessLegacy#table-of-contents","content":"Headless Mode Getting startedExperiment Input File HeadingParametersOutputs Output DirectorySimulation Output "},{"title":"Getting started​","type":1,"pageTitle":"Headless Legacy","url":"wiki/HeadlessLegacy#getting-started","content":"This headless mode is the Legacy one. So, if you are already familiar with headless from version 1.8.1 or older, nothing changed. This mode relies on writing an explicit simulation plan in XML file. Those simulations, mostly for legacy reason, have to be of type gui (which is pretty counterintuitive, but this type let you set the parameter value to each simulation independently), but you don't have to write it explicitly as it's the default type for an experiment. You can generate a first XML file corresponding to an existing experiment with the following command: bash ./gama-headless.sh -xml experimentName /path/to/inputFile.gaml /path/to/outputFile.xml  with: -xml: the flag asking the headless to generate a XML file well-formatted for our experimentexperimentName: the name of the experiment you want to run in headless/path/to/inputFile.gaml: the path (relative or absolute) to your GAML file containing the experiment you want to run/path/to/outputFile.xml: the path (relative or absolute) to the generated XML file You can see more in details the content of the generated XML file (applied on the model Predator Prey) in the Experiment Input File part. Once you finished preparing your XML file, you can run it with a command similar to the following one: bash ./gama-headless.sh /path/to/file.xml /path/to/generated/outputFolder  with: /path/to/file.xml: the path (relative or absolute) to the XML file containing the full exploration plan to run by the headless/path/to/generated/outputFolder: the path (relative or absolute) which will be generated by GAMA and hold every output files (variables, snapshots, and console messages) You can see result output folder in the Simulation Output part "},{"title":"Experiment Input File​","type":1,"pageTitle":"Headless Legacy","url":"wiki/HeadlessLegacy#experiment-input-file","content":"The XML input file contains for example (you can find it next to the file gama-headless.sh at the path samples/predatorPrey.xml: &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt; &amp;lt;Experiment_plan&gt; &amp;lt;Simulation experiment=&quot;prey_predatorExp&quot; finalStep=&quot;1000&quot; id=&quot;0&quot; seed=&quot;1.0&quot; sourcePath=&quot;./samples/predatorPrey/predatorPrey.gaml&quot;&gt; &lt;Parameters&gt; &lt;Parameter name=&quot;Nb Preys: &quot; type=&quot;INT&quot; value=&quot;200&quot; var=&quot;nb_preys_init&quot;/&gt; &lt;Parameter name=&quot;Prey max energy: &quot; type=&quot;FLOAT&quot; value=&quot;1.0&quot; var=&quot;prey_max_energy&quot;/&gt; &lt;Parameter name=&quot;Prey max transfert: &quot; type=&quot;FLOAT&quot; value=&quot;0.1&quot; var=&quot;prey_max_transfert&quot;/&gt; &lt;Parameter name=&quot;Prey energy consumption: &quot; type=&quot;FLOAT&quot; value=&quot;0.05&quot; var=&quot;prey_energy_consum&quot;/&gt; &lt;Parameter name=&quot;Nb predators: &quot; type=&quot;INT&quot; value=&quot;20&quot; var=&quot;nb_predators_init&quot;/&gt; &lt;Parameter name=&quot;Predator max energy: &quot; type=&quot;FLOAT&quot; value=&quot;1.0&quot; var=&quot;predator_max_energy&quot;/&gt; &lt;Parameter name=&quot;Predator energy transfert: &quot; type=&quot;FLOAT&quot; value=&quot;0.5&quot; var=&quot;predator_energy_transfert&quot;/&gt; &lt;Parameter name=&quot;Predator energy consumption: &quot; type=&quot;FLOAT&quot; value=&quot;0.02&quot; var=&quot;predator_energy_consum&quot;/&gt; &lt;/Parameters&gt; &lt;Outputs&gt; &lt;Output framerate=&quot;1&quot; id=&quot;0&quot; name=&quot;Number of preys&quot;/&gt; &lt;Output framerate=&quot;1&quot; id=&quot;1&quot; name=&quot;Number of predators&quot;/&gt; &lt;Output framerate=&quot;1&quot; id=&quot;2&quot; name=&quot;main_display&quot;/&gt; &lt;/Outputs&gt; &lt;/Simulation&gt; &lt;/Experiment_plan&gt;  NB: Several simulations can be determined in one experiment plan. These simulations are run in parallel according to the number of allocated cores. "},{"title":"Heading​","type":1,"pageTitle":"Headless Legacy","url":"wiki/HeadlessLegacy#heading","content":"&amp;lt;Simulation experiment=&quot;prey_predatorExp&quot; finalStep=&quot;1000&quot; id=&quot;0&quot; seed=&quot;1.0&quot; sourcePath=&quot;./samples/predatorPrey/predatorPrey.gaml&quot;&gt;  with: experiment (required): determines which experiment should be run on the model. This experiment should exist, otherwise, the headless mode will exit.finalStep (required): determines the number of simulation steps you want to run.id (required): permits to prefix output files for experiment plans with huge simulations.seed (optional): permits to set the seed value of the simulation.sourcePath (required): contains the relative or absolute path to read the gaml model.until (optional): defines a stop condition in GAML. It can be combined with the finalStep facet (in this case a simulation will finish when the stop condition is fulfilled or when the final step is reached).  "},{"title":"Parameters​","type":1,"pageTitle":"Headless Legacy","url":"wiki/HeadlessLegacy#parameters","content":"One line per parameter you want to specify a value to: &lt;Parameter name=&quot;Nb Preys: &quot; type=&quot;INT&quot; value=&quot;200&quot; var=&quot;nb_preys_init&quot;/&gt;  with: name: name of the parameter in the gaml modeltype (required): type of the parameter (INT, FLOAT, BOOLEAN, STRING)value (required): the chosen valuevar: name of the parameter variable in the gaml model NB: You need to set at least one of the attributes name or var in your Parameter tag) "},{"title":"Outputs​","type":1,"pageTitle":"Headless Legacy","url":"wiki/HeadlessLegacy#outputs","content":"One line per output value you want to retrieve. Outputs can be the name of monitors or displays defined in the 'output' section of experiments, or the names of attributes defined in the experiment or the model itself (in the 'global' section).  ... with the name of a monitor defined in the 'output' section of the experiment... &lt;Output framerate=&quot;1&quot; id=&quot;1&quot; name=&quot;Number of predators&quot;/&gt; ... with the name of a (built-in) variable defined in the experiment itself... &lt;Output framerate=&quot;1&quot; id=&quot;2&quot; name=&quot;main_display&quot;/&gt;  with: framerate (required): the frequency of the monitoring (each step, every 2 steps, every 100 steps...).id (optional): permits to prefix output files for simulation with huge outputsname (required): name of the output in the 'output'/'permanent' section in the experiment or name of the experiment/model attribute to retrieveoutput_path (optional): change the output directory where snapshot images are saved (for display output only!) NB: the lower the framerate value is, the longer the experiment. NB2: if the chosen output is a display, an image is produced and the output file contains the path to access this image "},{"title":"Output Directory​","type":1,"pageTitle":"Headless Legacy","url":"wiki/HeadlessLegacy#output-directory","content":"During headless experiments, a directory is created with the following structure: Outputed-directory-path/ out ├── console-outputs-0.txt ├── simulation-outputs0.xml └── snapshot ├── main_display0-0.png ├── main_display0-1.png ├── main_display0-2.png ├── main_display0-3.png ├── main_display0-4.png └── ...  with: console-outputs-&amp;lt;simulationId&gt;.xml: containing every message written in GAMA's consolesimulation-outputs&amp;lt;simulationId&gt;.xml: containing variables' results in a XML formatsnapshot: containing the snapshots (i.e. screenshots of gui displays) produced during the simulation "},{"title":"Simulation Output​","type":1,"pageTitle":"Headless Legacy","url":"wiki/HeadlessLegacy#simulation-output","content":"A file named simulation-output.xml is created with the following contents when the experiment runs. &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &amp;lt;Simulation id=&quot;0&quot; &gt; &amp;lt;Step id='0' &gt; &lt;Variable name='main_display' value='main_display2-0.png'/&gt; &lt;Variable name='number_of_preys' value='613'/&gt; &lt;Variable name='number_of_predators' value='51'/&gt; &lt;Variable name='duration' value='6' /&gt; &lt;/Step&gt; &amp;lt;Step id='1' &gt; &lt;Variable name='main_display' value='main_display2-0.png'/&gt; &lt;Variable name='number_of_preys' value='624'/&gt; &lt;Variable name='number_of_predators' value='51'/&gt; &lt;Variable name='duration' value='5' /&gt; &lt;/Step&gt; &amp;lt;Step id='2'&gt; ...  With: &amp;lt;Simulation id=&quot;0&quot; &gt;: tag containing results of the simulation. The id is set one set in the input file, in the heading part&amp;lt;Step id='0' &gt;: one block per step done containing the value of outputs variables. The id corresponds to the step number &lt;Variable /&gt; with: name: name of the outputvalue: the current value of the model variable at the given step. NB: The value of an output is repeated according to the framerate defined in the input experiment file. NB2: The value of an output display gives the relative path to the generated image saved in '.png' format. "},{"title":"Headless mode for dummies","type":0,"sectionRef":"#","url":"wiki/Headless-mode-for-dummies","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"Headless mode for dummies","url":"wiki/Headless-mode-for-dummies#overview","content":"This tutorial presents the headless mode usage of GAMA. We will execute the Predator-Prey model, already presented in this tutorial. Headless mode is documented in its dedicated part, here, we focus on the definition of an experiment plan, where the model is run several times. We only consider the shell script execution, not the java command execution. In headless-mode, GAMA can be seen as any shell command, whose behavior is controlled by passing arguments to it. You must provide 2 arguments : an input experiment file , used to describe the execution plan of your model, its inputs and the expected outputs.an output directory , where the results of the execution are stored Headless-mode is a little more technical to handle than the general GAMA use-case, and the following commands and code have been solely tested on a Linux Ubuntu 22.04 machine with the default GAMA 1.8.2 (installer version, with embedded JDK). You may have to perform some adjustments (such as paths definition) according to your machine, OS, java and GAMA versions and so on. "},{"title":"Setup​","type":1,"pageTitle":"Headless mode for dummies","url":"wiki/Headless-mode-for-dummies#setup","content":""},{"title":"GAMA version​","type":1,"pageTitle":"Headless mode for dummies","url":"wiki/Headless-mode-for-dummies#gama-version","content":"Headless mode is frequently updated by GAMA developers, so you have to get the very latest build version of GAMA. You can download it here https://github.com/gama-platform/gama/releases Be sure to pick the Continuous build version (The name looks like GAMA1.7_Linux_64_02.26.17_da33f5b.zip) and not the major release, e.g. GAMA1.7_Linux_64.zip. Big note on Windows OS (maybe on others), GAMA must be placed outside of several sensible folders (Program Files, Program Filesx64, Windows). RECOMMENED: Place GAMA in Users Folder of windows OS. "},{"title":"gama-headless.sh script setup​","type":1,"pageTitle":"Headless mode for dummies","url":"wiki/Headless-mode-for-dummies#gama-headlesssh-script-setup","content":"The gama-headless.sh script can be found under the headless directory, in GAMA installation directory e.g. : `~/GAMA/headless/ "},{"title":"Modifying the script (a little bit)​","type":1,"pageTitle":"Headless mode for dummies","url":"wiki/Headless-mode-for-dummies#modifying-the-script-a-little-bit","content":"The original script looks like this : #! /bin/bash memory=2048m declare -i i i=0 echo ${!i} for ((i=1;i&lt;=$#;i=$i+1)) do if test ${!i} = &quot;-m&quot; then i=$i+1 memory=${!i} else PARAM=$PARAM\\ ${!i} i=$i+1 PARAM=$PARAM\\ ${!i} fi done echo &quot;******************************************************************&quot; echo &quot;* GAMA version 1.7.0 V7 *&quot; echo &quot;* http://gama-platform.org *&quot; echo &quot;* (c) 2007-2016 UMI 209 UMMISCO IRD/UPMC &amp; Partners *&quot; echo &quot;******************************************************************&quot; passWork=.work$RANDOM java -cp ../plugins/org.eclipse.equinox.launcher*.jar -Xms512m -Xmx$memory -Djava.awt.headless=true org.eclipse.core.launcher.Main -application msi.gama.headless.id4 -data $passWork $PARAM $mfull $outputFile rm -rf $passWork  Notice the final command of the script rm -rf $passWork. It is intended to remove the temporary file used during the execution of the script. For now, we should comment this commmand, in order to check the logs if an error appears: #rm -rf $passWork "},{"title":"Setting the experiment file​","type":1,"pageTitle":"Headless mode for dummies","url":"wiki/Headless-mode-for-dummies#setting-the-experiment-file","content":"Headless mode uses a XML file to describe the execution plan of a model. An example is given in the headless mode documentation page. The script looks like this : N.B. this version of the script, given as an example, is deprecated &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &amp;lt;Experiment_plan&gt; &amp;lt;Simulation id=&quot;2&quot; sourcePath=&quot;./predatorPrey/predatorPrey.gaml&quot; finalStep=&quot;1000&quot; experiment=&quot;predPrey&quot;&gt; &lt;Parameters&gt; &lt;Parameter name=&quot;nb_predator_init&quot; type=&quot;INT&quot; value=&quot;53&quot; /&gt; &lt;Parameter name=&quot;nb_preys_init&quot; type=&quot;INT&quot; value=&quot;621&quot; /&gt; &lt;/Parameters&gt; &lt;Outputs&gt; &lt;Output id=&quot;1&quot; name=&quot;main_display&quot; framerate=&quot;10&quot; /&gt; &lt;Output id=&quot;2&quot; name=&quot;number_of_preys&quot; framerate=&quot;1&quot; /&gt; &lt;Output id=&quot;3&quot; name=&quot;number_of_predators&quot; framerate=&quot;1&quot; /&gt; &lt;Output id=&quot;4&quot; name=&quot;duration&quot; framerate=&quot;1&quot; /&gt; &lt;/Outputs&gt; &lt;/Simulation&gt; &lt;/Experiment_plan&gt;  As you can see, you need to define 3 things in this minimal example: Simulation: its id, path to the model, finalStep (or stop condition), and name of the experimentParameters name, of the model for this simulation (i.e. Simulation of id= 2)Outputs of the model: their id, name, type, and the rate (expressed in cycles) at which they are logged in the results file during the simulation We now describe how to constitute your experiment file. "},{"title":"Experiment File: Simulation​","type":1,"pageTitle":"Headless mode for dummies","url":"wiki/Headless-mode-for-dummies#experiment-file-simulation","content":""},{"title":"id​","type":1,"pageTitle":"Headless mode for dummies","url":"wiki/Headless-mode-for-dummies#id","content":"For now, we only consider one single execution of the model, so the simulation id is not critical, let it unchanged. Later example will include different simulations in the same experiment file. Simulation id is a string. Don't introduce weird symbols into it. "},{"title":"sourcePath​","type":1,"pageTitle":"Headless mode for dummies","url":"wiki/Headless-mode-for-dummies#sourcepath","content":"sourcePath is the relative (or absolute) path to the model file you want to execute headlessly. Here we want to execute the fourth model of the Predator Prey tutorial suite, located in ~/GAMA/plugins/msi.gama.models_1.7.0.XXXXXXXXXXXX/models/Tutorials/Predator Prey/models (with XXXXXXXXXXXX replaced by the number of the release you downloaded) So we set sourcePath=&quot;../plugins/msi.gama.models_1.7.0.201702260518/models/Tutorials/Predator Prey/models/Model 07.gaml&quot; (Remember that the headless script is located in ~/GAMA/headless/) Depending on the directory you want to run the gama-headless.sh script, sourcePath must me modified accordingly. Another workaround for shell more advanced users is to define a $GAMA_PATH, $MODEL_PATH and $OUPUT_PATH in gama-headless.sh script. Don't forget the quotes &quot; around your path. "},{"title":"finalStep​","type":1,"pageTitle":"Headless mode for dummies","url":"wiki/Headless-mode-for-dummies#finalstep","content":"The duration, in cycles, of the simulation. "},{"title":"experiment​","type":1,"pageTitle":"Headless mode for dummies","url":"wiki/Headless-mode-for-dummies#experiment","content":"This is the name of (one of) the experiment statement at the end of the model code. In our case there is only one, called prey_predator and it looks like this :  experiment prey_predator type: gui { parameter &quot;Initial number of preys: &quot; var: nb_preys_init min: 1 max: 1000 category: &quot;Prey&quot; ; parameter &quot;Prey max energy: &quot; var: prey_max_energy category: &quot;Prey&quot; ; parameter &quot;Prey max transfert: &quot; var: prey_max_transfert category: &quot;Prey&quot; ; parameter &quot;Prey energy consumption: &quot; var: prey_energy_consum category: &quot;Prey&quot; ; output { display main_display { grid vegetation_cell lines: #black ; species prey aspect: base ; } monitor &quot;Number of preys&quot; value: nb_preys ; } }  So we are now able to constitute the entire Simulation tag: &amp;lt;Simulation id=&quot;2&quot; sourcePath=&quot;~/GAMA/plugins/msi.gama.models_1.7.0.201702260518/models/Tutorials/Predator Prey/models/Model 01.gaml&quot; finalStep=&quot;1000&quot; experiment=&quot;prey_predator&quot;&gt; N.B. the numbers after msi.gama.models (the number of your GAMA release actually) have to be adapted to your own release of GAMA number. The path to the GAMA installation directory has also to be adapted of course. "},{"title":"Experiment File: Parameters​","type":1,"pageTitle":"Headless mode for dummies","url":"wiki/Headless-mode-for-dummies#experiment-file-parameters","content":"The parameters section of the experiment file describes the parameters names, types and values to be passed to the model for its execution. Let's say we want to fix the number of preys and their max energy for this simulation. We look at the experiment section of the model code and use their title . The title of a parameter is the name that comes right after the parameter statement. In our case, the strings &quot;Initial number of preys: &quot; and &quot;Prey max energy: &quot; (Mind the spaces, quotes and colon) The parameters section of the file would look like : &lt;Parameters&gt; &lt;Parameter name=&quot;Initial number of preys: &quot; type=&quot;INT&quot; value=&quot;621&quot; /&gt; &lt;Parameter name=&quot;Prey max energy: &quot; type=&quot;FLOAT&quot; value=&quot;1.0&quot; /&gt; &lt;/Parameters&gt;  Any declared parameter can be set this way, yet you don't have to set all of them, provided they are initialized with a default value in the model (see the global statement part of the model code). "},{"title":"Experiment File: Outputs​","type":1,"pageTitle":"Headless mode for dummies","url":"wiki/Headless-mode-for-dummies#experiment-file-outputs","content":"Output section of the experiment file is pretty similar to the previous one, except for the id that have to be set for each of the outputs . We can log some of the declared outputs : main_display and number_of_preys. The outputs section would look like the following: &lt;Outputs&gt; &lt;Output id=&quot;1&quot; name=&quot;main_display&quot; framerate=&quot;10&quot; /&gt; &lt;Output id=&quot;2&quot; name=&quot;Number of preys&quot; framerate=&quot;1&quot; /&gt; &lt;/Outputs&gt;  Outputs must have an id, a name, and a framerate. id is a number that identifies the outputframerate is the rate at which the output is written in the result file. It's a number of cycle of simulation (integer). In this example the display is saved every 10 cyclename is either the &quot;title&quot; of the corresponding monitor. In our case, the second output's is the title of the monitor &quot;Number of preys&quot;, i.e. &quot;Number of preys&quot; We also save a display output, that is an image of the simulation graphical display named main_display in the code of the model. Theses images is what you would have seen if you had run the model in the traditional GUI mode. "},{"title":"Execution and results​","type":1,"pageTitle":"Headless mode for dummies","url":"wiki/Headless-mode-for-dummies#execution-and-results","content":"Our new version of the experiment file is ready : &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Experiment_plan&gt;&lt;Simulation id=&quot;2&quot; sourcePath=&quot;/absolute/path/to/your/model/file/Model 04.gaml&quot; finalStep=&quot;1000&quot; experiment=&quot;prey_predator&quot;&gt;  &lt;Parameters&gt; &lt;Parameter name=&quot;Initial number of preys: &quot; type=&quot;INT&quot; value=&quot;621&quot; /&gt; &lt;Parameter name=&quot;Prey max energy: &quot; type=&quot;FLOAT&quot; value=&quot;1.0&quot; /&gt; &lt;/Parameters&gt; &lt;Outputs&gt; &lt;Output id=&quot;1&quot; name=&quot;main_display&quot; framerate=&quot;10&quot; /&gt; &lt;Output id=&quot;2&quot; name=&quot;Number of preys&quot; framerate=&quot;1&quot; /&gt; &lt;/Outputs&gt; &lt;/Simulation&gt;  &lt;/Experiment_plan&gt; "},{"title":"Execution​","type":1,"pageTitle":"Headless mode for dummies","url":"wiki/Headless-mode-for-dummies#execution","content":"We have to launch the gama-headless.sh script and provide two arguments : the experiment file we just completed and the path of a directory where the results will be written.  Warning In this example ,we are lazy and define the source path as the absolute path to the model we want to execute. If you want to use a relative path, note that it has to be define relatively to the location of your ExperimentFile.xml location (and the location where you launched the script) In a terminal, position yourself in the headless directory : `~/GAMA/headless/'. Then type the following command : bash gama-headless.sh -v ~/a/path/to/MyExperimentFile.xml /path/to/the/desired/output/directory  And replace paths by the location of your ExperimentFile and output directory You should obtain the following output in the terminal : ****************************************************************** * GAMA version 1.7.0 V7 * * http://gama-platform.org * * (c) 2007-2016 UMI 209 UMMISCO IRD/UPMC &amp; Partners * ****************************************************************** &gt;GAMA plugin loaded in 2927 ms: msi.gama.core &gt;GAMA plugin loaded in 67 ms: ummisco.gama.network &gt;GAMA plugin loaded in 56 ms: simtools.gaml.extensions.traffic &gt;GAMA plugin loaded in 75 ms: simtools.gaml.extensions.physics &gt;GAMA plugin loaded in 1 ms: irit.gaml.extensions.test &gt;GAMA plugin loaded in 75 ms: ummisco.gaml.extensions.maths &gt;GAMA plugin loaded in 47 ms: msi.gaml.extensions.fipa &gt;GAMA plugin loaded in 92 ms: ummisco.gama.serialize &gt;GAMA plugin loaded in 49 ms: irit.gaml.extensions.database &gt;GAMA plugin loaded in 2 ms: msi.gama.lang.gaml &gt;GAMA plugin loaded in 1 ms: msi.gama.headless &gt;GAMA plugin loaded in 103 ms: ummisco.gama.java2d &gt;GAMA plugin loaded in 189 ms: msi.gaml.architecture.simplebdi &gt;GAMA plugin loaded in 129 ms: ummisco.gama.opengl &gt;GAMA building GAML artefacts&gt;GAMA total load time 4502 ms. in 714 ms cpus :8 Simulation is running... .................................................................................................... Simulation duration: 7089ms  "},{"title":"Results​","type":1,"pageTitle":"Headless mode for dummies","url":"wiki/Headless-mode-for-dummies#results","content":"The results are stored in the output directory you provided as the second argument of the script. 3 items have appeared: A console_output.txt file, containing the output of the GAMA console of the model execution if anya XML file simulation-outputXX.xml, where XX is the id number of your simulation. In our case it should be 2.the folder snapshots containing the screenshots coming from the second declared output : main_display. image name format is main_display[id]_[cycle].png. The values of the monitor &quot;Number of preys&quot; are stored in the xml file simulation-outputXX.xml "},{"title":"Common error messages​","type":1,"pageTitle":"Headless mode for dummies","url":"wiki/Headless-mode-for-dummies#common-error-messages","content":"Exception in thread &quot;Thread-7&quot; No parameter named prey_max_energy in experiment prey_predatorProbably a typo in the name or the title of a parameter. check spaces, capital letters, symbols and so on. java.io.IOException: Model file does not exist: /home/ubuntu/dev/tutoGamaHeadless/../plugins/msi.gama.models_1 This may be a relative path mistake; try with absolute path. java.lang.NumberFormatException: For input string: &quot;1.0&quot; This may be a problem of type declaration in the parameter section. "},{"title":"Going further​","type":1,"pageTitle":"Headless mode for dummies","url":"wiki/Headless-mode-for-dummies#going-further","content":""},{"title":"Experiments of several simulation​","type":1,"pageTitle":"Headless mode for dummies","url":"wiki/Headless-mode-for-dummies#experiments-of-several-simulation","content":"You can launch several simulation by replicating the simulation declaration in your ExperimentFile.xml and varying the values of the parameters. Since you will have to edit the experiment file by hand, you should do that only for a reasonable number of simulations (e.g. &lt;10 ) "},{"title":"Design of experiments plans​","type":1,"pageTitle":"Headless mode for dummies","url":"wiki/Headless-mode-for-dummies#design-of-experiments-plans","content":"For more systematic parameter values samples, you should turn towards a more adapted tool such as GAMAR, to generate a ExperimentFile.xml with a huge number of simulations. "},{"title":"Server","type":0,"sectionRef":"#","url":"wiki/HeadlessServer","content":"","keywords":""},{"title":"Hello World Visualization in MapBox​","type":1,"pageTitle":"Server","url":"wiki/HeadlessServer#hello-world-visualization-in-mapbox","content":"Clone the repository gama.clientIn Javascript/gama_client.js edit the following variable ABSOLUTE_PATH_TO_GAMA to your local path (e.g var ABSOLUTE_PATH_TO_GAMA = '/Users/arno/'; open Javascript/index.htmlin a browser "},{"title":"Hello World Message example​","type":1,"pageTitle":"Server","url":"wiki/HeadlessServer#hello-world-message-example","content":"In chain_messages.js edit the following variable ABSOLUTE_PATH_TO_GAMA to your local path (e.g var ABSOLUTE_PATH_TO_GAMA = '/Users/arno/'; open Javascript/message_examplein a browser "},{"title":"GAMA Platform","type":0,"sectionRef":"#","url":"wiki/Home","content":"","keywords":""},{"title":"Large data-driven models​","type":1,"pageTitle":"GAMA Platform","url":"wiki/Home#large-data-driven-models","content":"GAMA provides, since its creation, the possibility to load and manipulate GIS (Geographic Information System) data in the models. One can also import and directly use a large number of data types, such as CSV files, shapefiles, OSM (open street map data), grid, images, SVG, but also 3D files, such as 3DS or OBJ. It also provides models with the possibility to directly connect to databases and use external tools and environments such as R.  "},{"title":"High-level and intuitive agent-based language​","type":1,"pageTitle":"GAMA Platform","url":"wiki/Home#high-level-and-intuitive-agent-based-language","content":"Thanks to GAML, its high-level and intuitive language, GAMA has been developed to be used by non-computer scientists: one can actually create a simulated world, declare species of agents, provide them with behaviors, and display them and their interactions in less than 10 minutes. GAML also offers all the power needed by advanced modellers: being an agent-oriented language coded in Java, it provides the possibility to build integrated models with several paradigms of modeling, to explore their parameters space and calibrate them and to run virtual experiments, all of these without leaving the platform. GAML can be learnt easily by following first the step by step tutorial and then exploring the other tutorials and pedagogical resources available throughout this site. Since 2007, the developers behind GAMA also provide a continuous support through the active mailing list. Finally, in addition to this online support, training sessions for specialised audiences, on topics such as &quot;urban management&quot;, &quot;epidemiology&quot;, &quot;risk management&quot; are also organised and delivered by GAMA developers and users. "},{"title":"Declarative user interface​","type":1,"pageTitle":"GAMA Platform","url":"wiki/Home#declarative-user-interface","content":"The user interface for both writing models and running experiments is one of the strongest points of GAMA. The platform indeed provides the possibility to have multiple displays for the same model, add as many visual representations as needed for the agents and therefore highlight the elements of interest in the simulations easily and beautifully. Advanced 3D displays are provided with all the support required for realistic renderings. Of course, dedicated statements allow to easily define charts for more dashboard-like presentations. During simulations, interactive features can be made available to inspect the population of agents, define user-controlled action panels, or interactions with the displays and external devices.   "},{"title":"Development Team​","type":1,"pageTitle":"GAMA Platform","url":"wiki/Home#development-team","content":"GAMA is developed by several teams under the umbrella of the IRD/SU international research unit UMMISCO: UMI 209 UMMISCO, IRD/SU, 32 Avenue Henri Varagnat, 93143 Bondy Cedex, France.ACROSS International Joint Lab, Thuyloi University, Hanoi, Vietnam (since 2021)DREAM Research Team, University of Can Tho, Vietnam (since 2011).UMR 5505 IRIT, CNRS/University of Toulouse 1, France (since 2010).UR MIAT, INRAE, 24 Chemin de Borde Rouge, 31326 Castanet Tolosan Cedex, France (since 2016).UMR 6228 IDEES, CNRS/University of Rouen, France (2010 - 2019).UMR 8623 LRI, CNRS/University Paris-Sud, France (2011 - 2019).MSI Research Team, Vietnam National University, Hanoi, Vietnam (2007 - 2015). "},{"title":"Citing GAMA​","type":1,"pageTitle":"GAMA Platform","url":"wiki/Home#citing-gama","content":"If you use GAMA in your research and want to cite it (in a paper, presentation, whatever), please use this reference: Taillandier, P., Gaudou, B., Grignard, A.,Huynh, Q.-N., Marilleau, N., P. Caillou, P., Philippon, D., &amp; Drogoul, A. (2019). Building, composing and experimenting complex spatial models with the GAMA platform. Geoinformatica, (2019), 23 (2), pp. 299-322, [doi:10.1007/s10707-018-00339-6] or you can choose to cite the website instead: GAMA Platform website, http://gama-platform.org A complete list of references (papers and PhD theses on or using GAMA) is available on the references page. "},{"title":"Acknowledgement​","type":1,"pageTitle":"GAMA Platform","url":"wiki/Home#acknowledgement","content":" YourKit supports open source projects with its full-featured Java Profiler. YourKit, LLC is the creator of YourKit Java Profilerand YourKit .NET Profiler, innovative and intelligent tools for profiling Java and .NET applications.   This page is licensed under a Creative Commons Attribution 4.0 International License . "},{"title":"Incremental Model","type":0,"sectionRef":"#","url":"wiki/IncrementalModel","content":"","keywords":""},{"title":"Model Overview​","type":1,"pageTitle":"Incremental Model","url":"wiki/IncrementalModel#model-overview","content":"The model built in this tutorial aim at simulating the spreading of a disease in a small city. Three type of entities are taken into account: the people, the buildings and the roads. We made the following modeling choice: Simulation step: 1 minute.People are moving on the roads from building to building.People use the shortest path to move between buildings.All people have the same speed and move at a constant speed.Each time, people arrived at a building they are staying a certain time.The staying time depends on the current hour (lower at 9h - go to work - at 12h go to lunch - at 18h - go back home).Infected people are never cured.  "},{"title":"Step List​","type":1,"pageTitle":"Incremental Model","url":"wiki/IncrementalModel#step-list","content":"This tutorial is composed of 7 steps corresponding to 7 models. For each step, we present its purpose, an explicit formulation, and the corresponding GAML code. Simple SI ModelChartsIntegration of GIS DataMovement on GraphVisualizing in 3DMulti-LevelDifferential Equations "},{"title":"Importing Models","type":0,"sectionRef":"#","url":"wiki/ImportingModels","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Importing Models","url":"wiki/ImportingModels#table-of-contents","content":"Importing Models The &quot;Import...&quot; Menu Command Import &quot;GAMA Project...&quot;Import &quot;External files from disk...&quot; and &quot;External files from archive...&quot;&quot;Other&quot; imports Silent importDrag'n Drop / Copy-Paste LimitationsImport from GitHub repository "},{"title":"The \"Import...\" Menu Command​","type":1,"pageTitle":"Importing Models","url":"wiki/ImportingModels#the-import-menu-command","content":"The simplest, safest and most secure way to import a project into the workspace is to use the built-in &quot;Import...&quot; menu command, available in the contextual menu on the User models (the modeler can only import projects in this category).  The &quot;Import...&quot; command allows the modeler to choose between: &quot;GAMA Project...&quot;: import a project in the workspace (from another folder or an archive),&quot;External files from disk...&quot;: import any files in a project of the workspace (from a folder),&quot;External files from archive...&quot;: import any files in a project of the workspace (from an archive),&quot;Other&quot;: other ways of importation. "},{"title":"Import \"GAMA Project...\"​","type":1,"pageTitle":"Importing Models","url":"wiki/ImportingModels#import-gama-project","content":"When &quot;GAMA project...&quot; is chosen, a dialog box will pop-up where the user will be asked to: Enter a location (or browse to a location) containing the GAMA project(s) to import. This can be the folder of a single project or a folder containing several projects. 2 possibilities are available: &quot;Select root directory&quot;: the user selects a folder containing the project,&quot;Select archive file&quot;: the user selects an archive file (e.g. a .zipfile) containing the project. Choose among the list of available projects (computed by GAMA) the ones to effectively import. Only projects that are not already in the workspace can be imported.Indicate whether or not these projects need to be copied to or linked from the workspace (the latter is done by default). In the case of an import from an archive, the content will be automatically copied in the workspace.  "},{"title":"Import \"External files from disk...\" and \"External files from archive...\"​","type":1,"pageTitle":"Importing Models","url":"wiki/ImportingModels#import-external-files-from-disk-and-external-files-from-archive","content":"These two commands allow the user to import some external files into an existing project of the workspace. These two commands are very similar, only the source of files is different: a folder or an archive. They allow to filter and select the files to import. The user will be asked to: Enter a location (or browse to a location) containing the files to import.Select the files to import.Select the project in the workspace where the files will be copied.  "},{"title":"\"Other\" imports​","type":1,"pageTitle":"Importing Models","url":"wiki/ImportingModels#other-imports","content":"When invoked, this command will open a dialog asking the user to choose the source of the importation. It can be a directory in the filesystem (in which GAMA will look for existing projects), a zip file, etc. It is safer, in any case, to choose &quot;Existing Projects into Workspace&quot;. If some extensions have been installed, they could add some entries in this menu (e.g. the Git extension).  "},{"title":"Silent import​","type":1,"pageTitle":"Importing Models","url":"wiki/ImportingModels#silent-import","content":"Another (possibly simpler, but less controllable) way of importing projects and models is to either pass a path to a model when launching GAMA from the command line or to double-click on a model file (ending in .gaml) in the Explorer or Finder (depending on your OS). If the file is not already part of an imported project in the current workspace, GAMA will: silently import the project (by creating a link to it),open an editor on the file selected. This procedure may fail, however, if a project of the same name (but in a different location) already exists in the workspace, in which case GAMA will refuse to import the project (and hence, the file). The solution, in this case, is to rename the project to import (or to rename the existing project in the workspace). "},{"title":"Drag'n Drop / Copy-Paste Limitations​","type":1,"pageTitle":"Importing Models","url":"wiki/ImportingModels#dragn-drop--copy-paste-limitations","content":"Currently, there is no way to drag and drop an entire project into GAMA Navigator (or to copy a project in the filesystem and paste it in the Navigator). Only individual model files, folders or resources can be moved this way (and they have to be dropped or pasted into existing projects). This limitation might be removed sometime in the future, however, allowing users to use the Navigator as a project drop or paste target, but it is not the case yet. "},{"title":"Import from GitHub repository​","type":1,"pageTitle":"Importing Models","url":"wiki/ImportingModels#import-from-github-repository","content":"In the case where the Git plugin is installed in GAMA, projects can be imported from a Git repository, as detailed in the recipes related to the use of Git in GAMA. "},{"title":"1. Simple SI Model","type":0,"sectionRef":"#","url":"wiki/IncrementalModel_step1","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"1. Simple SI Model","url":"wiki/IncrementalModel_step1#formulation","content":"Definition of the people species with a variable (is_infected) , an aspect (default) and two behaviors (move and infect).Definition of nb_infected_init, infection_distance and proba_infection parameters.Creation of 500 people agents randomly located in the environment (size: 500x500).Definition a display to visualize the people agents.  "},{"title":"Model Definition​","type":1,"pageTitle":"1. Simple SI Model","url":"wiki/IncrementalModel_step1#model-definition","content":""},{"title":"model structure​","type":1,"pageTitle":"1. Simple SI Model","url":"wiki/IncrementalModel_step1#model-structure","content":"A GAMA model is composed of three types of sections: global: this section, which is unique, defines the &quot;world&quot; agent, a special agent of a GAMA model. It represents all that is global to the model: dynamics, variables, actions. In addition, it allows to initialize the simulation (init block).species: these sections define the species of agents composing the model.experiment: these sections define a context of the execution of the simulations. In particular, it defines the input (parameters) and output (displays, files...) of a model. More details about the different sections of a GAMA model can be found here. "},{"title":"species​","type":1,"pageTitle":"1. Simple SI Model","url":"wiki/IncrementalModel_step1#species","content":"A species represents a «prototype» of agents: it defines their common properties. A species definition requires the definition of three different elements: the internal state of its agents (attributes)their behaviorhow they are displayed (aspects) Internal state​ An attribute is defined as follows: the type of the attribute and name. Numerous types of attributes are available: int (integer), float (floating-point number), string, bool (boolean, true or false), point (coordinates), list, pair, map, file, matrix, species of agents, rgb (color), graph, path... Optional facets: &lt;- (initial value), update (value recomputed at each step of the simulation), function:{..} (value computed each time the variable is used), min, max In addition to the attributes the modeler explicitly defines, species &quot;inherits&quot; other attributes called &quot;built-in&quot; variables: A name (name): the identifier of the species.A shape (shape): the default shape of the agents to be constructed after the species. It can be a point, a polygon, etc..A location (location): the centroid of its shape. We will give a variable to people agents: is_infected (bool): species people skills:[moving]{ bool is_infected &lt;- false; }  Concerning the display of an agent, aspects have to be defined. An aspect represents a possible way to display the agents of a species: aspect aspect_name {...}. In the block of an aspect, it is possible to draw: A geometry: for instance, the shape of the agent.An image: to draw icons.A text: to draw a text. We define here one aspect of this species. In this model, we want to display for each people agent a circle of radius 5 and red or green according to the value of is_infected (if infected: red, green otherwise). We then use the keyword draw with a circle shape. To define the color that depends on is_infected, we use the tertiary operator condition ? val1 : val2. If the condition is true, this operator will return val1, otherwise val2. Note that it is possible to get a color value by using the symbol # + color name: e.g. #blue, #red, #white, #yellow, #magenta, #pink... species people skills:[moving] { ... aspect default { draw circle(5) color: is_infected ? #red : #green; } }  Concerning the behavior of agents, the simplest way to define it is through reflexes. A reflex is a block of statements (that can be defined in global or any species) that will be automatically executed at each simulation step if its condition is true. A reflex is defined as follows:  reflex reflex_name when: condition {...}  The when facet is optional: when it is omitted, the reflex is activated at each time step. Note that if several reflexes are defined for a species, the reflexes will be activated following their definition order. We define a first reflex called move that allows the people agents to move using the wander action (provided by the moving skill) that allows to randomly move (with taking into account the agent speed). species people skills: [moving] { ... reflex move { do wander; } }  Note that an action is a capability available to the agents of a species (what they can do). It is a block of statements that can be used and reused whenever needed. Some actions, called primitives, are directly coded in Java: for instance, the wander action defined in the moving skill. An action can accept arguments. For instance, write takes an argument called message.An action can return a result. There are two ways to call an action: using a statement or as part of an expression for actions that do not return a result: do action_name arg1: v1 arg2: v2;  for actions that return a result: my_var &lt;- self action_name (arg1:v1, arg2:v2);  The second reflex we have to define is the infect one. This reflex will be activated only if is_infected is true. This reflex consists is asking all the people agents at a distance lower or equal to infection_distance to become infected with a probability proba_infection. species people skills:[moving]{ ... reflex infect when: is_infected{ ask people at_distance infection_distance { if (flip(proba_infection)) { is_infected &lt;- true; } } } ... }  Note that we used the ask statement. This statement allows to make a remote agent executes a list of statements. We used as well the flip operator that allows to test a probability. "},{"title":"global section​","type":1,"pageTitle":"1. Simple SI Model","url":"wiki/IncrementalModel_step1#global-section","content":"The global section represents the definition of the species of a specific agent (called world). The world agent represents everything that is global to the model: dynamics, variables... It allows to init simulations (init block): the world is always created and initialized first when a simulation is launched. The geometry (shape) of the world agent is by default a square with 100m for side size, but can be redefined if necessary. In the same way, the modeler can redefine the step variable that represents the duration of a simulation step and that is by default 1 second. global variables​ For our model, we define 5 global variables: nb_people (int, init value: 500), infection_distance (float value, init value: 2 meters), proba_infection (float, init value: 0.05), nb_infected_init (int, init value: 5) and agent_speed (float, init value: 5 #km/#h). In addition, we redefine the geometry of the world by a square of 500 meters size and a simulation step of 1 minute. global { int nb_people &lt;- 500; float agent_speed &lt;- 5.0 #km/#h; float infection_distance &lt;- 2.0 #m; float proba_infection &lt;- 0.05; int nb_infected_init &lt;- 5; float step &lt;- 1 #minutes; geometry shape&lt;-square(500 #m); }  Model initialization​ The init section of the global block allows to initialize the model. The statement create allows to create agents of a specific species: create species\\_name + : number: number of agents to create (int, 1 by default)from: GIS file to use to create the agents (string or file)returns: list of created agents (list) For our model, the definition of the init block in order to create nb_people people agents. We set the init value of the speed variable (given by the moving skill) to the value of the global variable agent_speed (i.e. 5km/h). In addition, we ask nb_infected_init people to become infected (use of the nb among list to randomly draw nb elements of the list). global{ ... init{ create people number:nb_people { speed &lt;- agent_speed; } ask nb_infected_init among people { is_infected &lt;- true; } } }  "},{"title":"experiment​","type":1,"pageTitle":"1. Simple SI Model","url":"wiki/IncrementalModel_step1#experiment","content":"An experiment block defines how a model can be simulated (executed). Several experiments can be defined for a model. They are defined using : experiment exp\\_name type: gui/batch {[input] [output]}. gui: experiment with a graphical interface, which displays its input parameters and outputs.batch: Allows to setup a series of simulations (w/o graphical interface). In our model, we define a gui experiment called main_experiment : experiment main_experiment type: gui { }  input​ Experiments can define (input) parameters. A parameter definition allows to make the value of a global variable definable by the user through the graphic interface. A parameter is defined as follows: parameter title var: global_var category: cat;  title: string to displayvar: reference to a global variable (defined in the global section)category: string used to «store» the operators on the UI - optional&lt;-: init value - optionalmin: min value - optionalmax: min value - optional Note that the init, min and max values can be defined in the global variable definition. In the experiment, we define three parameters from the global variables infection_distance, proba_infection and nb_infected_init: experiment main_experiment type: gui{ parameter &quot;Infection distance&quot; var: infection_distance; parameter &quot;Proba infection&quot; var: proba_infection min: 0.0 max: 1.0; parameter &quot;Nb people infected at init&quot; var: nb_infected_init ; ... }  output​ The output block is defined in an experiment and defines how to visualize a simulation (with one or more display blocks that define separate windows). Each display can be refreshed independently by defining the facet refresh (expecting a boolean expression, the display will be refreshed every time the expression is evaluated to true. This expression can be described in terms of nb of simulation, with e.g. every(5#cycle)). Each display can include different layers (like in a GIS): All the agents of a species: species my_species aspect: my_aspect;.Agents lists: agents layer_name value: agents_list aspect: my_aspect;.Images: image image_file_name;.Charts: see later. Note that it is possible to define a opengl display (for 3D display) by using the facet type: opengl. In our model, we define a display to draw the people agents with their default aspect. (note that, if the aspect facet is omitted, the aspect named default will be used) experiment main_experiment type: gui{ ... output { display map { species people ; // 'default' aspect is used automatically } } }  "},{"title":"Complete Model​","type":1,"pageTitle":"1. Simple SI Model","url":"wiki/IncrementalModel_step1#complete-model","content":"msi.gama.models/models/Tutorials/Incremental%20Model/models/Incremental%20Model%201.gaml loading... See full example on GitHub "},{"title":"2. Charts","type":0,"sectionRef":"#","url":"wiki/IncrementalModel_step2","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"2. Charts","url":"wiki/IncrementalModel_step2#formulation","content":"Definition of new global variables: current_hour, nb_people_infected, nb_people_not_infected, infected_rate.Definition of a monitor to follow the current hour and the nb of people infected.Definition of a series chart to follow the number of people infected and not infected.Definition of a stopping condition (when infected rate = 1).  "},{"title":"Model Definition​","type":1,"pageTitle":"2. Charts","url":"wiki/IncrementalModel_step2#model-definition","content":""},{"title":"global variables​","type":1,"pageTitle":"2. Charts","url":"wiki/IncrementalModel_step2#global-variables","content":"In order to define dynamic variable able to update itself, we use the update facet of variable definition. Indeed, at each simulation step, all the agents (and the world agent) apply for each dynamic variable (in their definition order) its update expression. We add 3 new global variables: nb_people_infected (int): nb of people with is_infected is true (use of the list count condition operator that count the number of elements of the list for which the condition is true)nb_people_not_infected (int): nb_people - nb_people_infectedinfected_rate (float): nb_people_infected / nb_people  global{ ... int nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected); int nb_people_not_infected &lt;- nb_people - nb_infected_init update: nb_people - nb_people_infected; float infected_rate update: nb_people_infected/nb_people; ... }  "},{"title":"stopping condition​","type":1,"pageTitle":"2. Charts","url":"wiki/IncrementalModel_step2#stopping-condition","content":"We add a new reflex that stops the simulation when all the people agents are infected (i.e. if the infected_rate is equal to 1). To stop the simulation, we use the pause global action. global { ... reflex end_simulation when: infected_rate = 1.0 { do pause; } }  "},{"title":"monitor​","type":1,"pageTitle":"2. Charts","url":"wiki/IncrementalModel_step2#monitor","content":"A monitor allows the modeler to follow the value of an arbitrary expression in GAML. It has to be defined in an output section. A monitor is defined as follows:  monitor monitor_name value: an_expression refresh:every(nb_steps);  With: value: mandatory, its value that will be displayed in the monitor.refresh: bool, optional: if the expression is true, compute (default is true). In this model, we define 2 monitors to follow: (i) the value of the variable infected_rate, and (ii) to follow the time in the simulation (we will display the hour day). As detailed in the dedicated page, GAML language provides a datatype to manage date (with second, minute, hour, day, month and year), and compute automatically the date in the simulation from the global variable starting_date of the simulation and the step value: this value is stored in the current_date global variable. To monitor the current hour, we can access to the hour attribute of this variable (current_date.hour). experiment main_experiment type: gui { ... output { monitor &quot;Current hour&quot; value: current_date.hour; monitor &quot;Infected people rate&quot; value: infected_rate; ... } }  "},{"title":"chart​","type":1,"pageTitle":"2. Charts","url":"wiki/IncrementalModel_step2#chart","content":"GAMA can display various chart types, for example: Time seriesPie chartsHistograms A chart must be defined in a display: it behaves exactly like any other layer. Definition of a chart: chart chart_name type: chart_type { [data] }  The data to draw are defined inside the chart block with the data statement: data data_legend value: data_value  We add a new display called &quot;chart&quot; and refreshed every 10 simulation steps. Inside this display, we define a chart of type series: &quot;Disease spreading&quot;; background: white; of type series and style spline (no remove the markers) data1: susceptible; color : greendata2: infected; color : red experiment main_experiment type: gui{ ... output { ... display chart refresh: every(10#cycles) { chart &quot;Disease spreading&quot; type: series style: spline { data &quot;susceptible&quot; value: nb_people_not_infected color: #green; data &quot;infected&quot; value: nb_people_infected color: #red; } } } }  "},{"title":"Complete Model​","type":1,"pageTitle":"2. Charts","url":"wiki/IncrementalModel_step2#complete-model","content":"https://github.com/gama-platform/gama/blob/GAMA_1.8.2/msi.gama.models/models/Tutorials/Incremental%20Model/models/Incremental%20Model%202.gaml  "},{"title":"3. Integration of GIS Data","type":0,"sectionRef":"#","url":"wiki/IncrementalModel_step3","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"3. Integration of GIS Data","url":"wiki/IncrementalModel_step3#formulation","content":"Load, agentify and display two layers of GIS data (building and road).Modify the initialization of the people agents to put them inside buildings.  "},{"title":"Model Definition​","type":1,"pageTitle":"3. Integration of GIS Data","url":"wiki/IncrementalModel_step3#model-definition","content":""},{"title":"species​","type":1,"pageTitle":"3. Integration of GIS Data","url":"wiki/IncrementalModel_step3#species","content":"To integrate easily the two data layers, we have to define two species of agents: the building agents and the road ones. These agents will not have a particular behavior, they will just be displayed. We define an aspect for these species. In this model, we want to represent the geometry of the agent, we then use their geometry in the draw statement. In order to draw the geometry of the agent, we use the attribute shape (which is a built-in attribute of all agents). species building { aspect default { draw shape color: #gray border: #black; } } species road { aspect default { draw shape color: #black; } }  "},{"title":"Global variables​","type":1,"pageTitle":"3. Integration of GIS Data","url":"wiki/IncrementalModel_step3#global-variables","content":"GAMA allows to automatically read GIS data that are formatted as shapefiles. In order to let the user chooses his/her shapefiles, we define two global variables. One allowing the user to choose the road shapefile, one allowing him/her to choose the building shapefile. Definition of the two global variables of type file representing the GIS files: global { file buildings_shapefile &lt;- file(&quot;../includes/building.shp&quot;); file roads_shapefile &lt;- file(&quot;../includes/road.shp&quot;); }  "},{"title":"agentification of GIS data​","type":1,"pageTitle":"3. Integration of GIS Data","url":"wiki/IncrementalModel_step3#agentification-of-gis-data","content":"In GAMA, the agentification of GIS data is very straightforward: it only requires to use the create command with the from facet with the shapefile. Each object of the shapefile will be directly used to instantiate one agent of the specified species. We modify the init section of the global block in order to create road and building agents from the shapefiles. Then, we define the initial location of people as a point inside one of the buildings. global { ... init { create road from: roads_shapefile; create building from: buildings_shapefile; create people number:nb_people { speed &lt;- agent_speed; location &lt;- any_location_in(one_of(building)); } ask nb_infected_init among people { is_infected &lt;- true; } } }  Note that the name of a species can be used to obtain all the agents of a species (here building returns the list of all the buildings). We can thus use the one_of operator on building to pick a random building agent. The any_location_in operator returns a random point inside a geometry or an agent geometry. "},{"title":"environment​","type":1,"pageTitle":"3. Integration of GIS Data","url":"wiki/IncrementalModel_step3#environment","content":"Building a GIS environment in GAMA requires nothing special, just to define the bounds of the environment, i.e. the geometry of the world agent. It is possible to use a shapefile to automatically define it by computing its envelope. In this model, we use the road shapefile to define it. global { ... geometry shape &lt;- envelope(roads_shapefile); ... }  "},{"title":"display​","type":1,"pageTitle":"3. Integration of GIS Data","url":"wiki/IncrementalModel_step3#display","content":"We add to the map display the road and building agents. Again, as we named the aspects default we can omit to specify them in the species inside the display. In the experiment block: output { display map { species road; species building; species people; } ... }  "},{"title":"Complete Model​","type":1,"pageTitle":"3. Integration of GIS Data","url":"wiki/IncrementalModel_step3#complete-model","content":"https://github.com/gama-platform/gama/blob/GAMA_1.8.2/msi.gama.models/models/Tutorials/Incremental%20Model/models/Incremental%20Model%203.gaml  "},{"title":"4. Movement on Graph","type":0,"sectionRef":"#","url":"wiki/IncrementalModel_step4","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"4. Movement on Graph","url":"wiki/IncrementalModel_step4#formulation","content":"Definition of a global graph to represent the road network.Definition of a new global variable: staying_coeff to represent the fact that people move more near 9h, 12h, and 18h.Definition of two new variables for the people agents: target and staying_counter (to manage their mobility).Definition of a new reflex for people agents: stay.Modification of the move reflex of the people agents.  "},{"title":"Model Definition​","type":1,"pageTitle":"4. Movement on Graph","url":"wiki/IncrementalModel_step4#model-definition","content":""},{"title":"global variables​","type":1,"pageTitle":"4. Movement on Graph","url":"wiki/IncrementalModel_step4#global-variables","content":"We define two new global variables: road_network (graph): represents the graph built from the road network.staying_coeff (float): represents the fact that people have more chance to move from their current building near 9h (go to work), 12h (lunchtime) and 18h (go home). This variable is updated at each simulation step (using the update facet). global{ .... graph road_network; float staying_coeff update: 10.0 ^ (1 + min([abs(current_date.hour - 9), abs(current_date.hour - 12), abs(current_date.hour - 18)])); .... }  "},{"title":"Initialization​","type":1,"pageTitle":"4. Movement on Graph","url":"wiki/IncrementalModel_step4#initialization","content":"We need to compute from the road agents, a graph for the moving of the people agents. The operator as_edge_graph allows doing that. It automatically builds from a set of agents or geometries a graph where the agents are the edges of the graph, a node represent the extremities of the agent geometry. The weight of each edge corresponds to the length of the road. global { ... init { ... create road from: roads_shapefile; road_network &lt;- as_edge_graph(road); ... } }  "},{"title":"people agent​","type":1,"pageTitle":"4. Movement on Graph","url":"wiki/IncrementalModel_step4#people-agent","content":"First, we add two new variables for the people agents: target (point): the target location that the people want to reach (a point inside a building).staying_counter (int): the number of cycles since the agent arrived at its building. We define a new reflex named stay that is activated when the agent has no target (target = nil), i.e. when the agent is inside a building. This reflex increments the staying_counter, then it tests the probability to leave that is computed from the staying_counter (longer the agent is inside the building, more it has a chance to leave) and the staying_coeff (closer to 9h, 12h, and 18h, more the agent has a chance to leave). If the agents decide to leave, it computes a new target as a random point inside one of the buildings (randomly chosen). species people skills: [moving] { ... reflex staying when: target = nil { staying_counter &lt;- staying_counter + 1; if flip(staying_counter / staying_coeff) { target &lt;- any_location_in (one_of(building)); } } ... }  We modify the move reflex. Now, this reflex is activated only when the agent has a target (target != nil). In this case, the agent moves toward its target using the built-in goto action. Note that we specified a graph (road_network) to constraint the moving of the agents on the road network with the facet on. The agent uses the shortest path (according to the graph) to go to the target point. When the agent arrives at destination (location = location), the target is set to nil (the agent will stop moving) and the staying_counter is set to 0. species people skills:[moving]{ ... reflex move when: target != nil{ do goto target: target on: road_network; if (location = target) { target &lt;- nil; staying_counter &lt;- 0; } } }  "},{"title":"Complete Model​","type":1,"pageTitle":"4. Movement on Graph","url":"wiki/IncrementalModel_step4#complete-model","content":" https://github.com/gama-platform/gama/blob/GAMA_1.8.2/msi.gama.models/models/Tutorials/Incremental%20Model/models/Incremental%20Model%204.gaml  "},{"title":"5. Visualizing in 3D","type":0,"sectionRef":"#","url":"wiki/IncrementalModel_step5","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"5. Visualizing in 3D","url":"wiki/IncrementalModel_step5#formulation","content":"Add a variable (height: int from 10m to 20m) and modify the aspect of buildings to display them in 3D.Add a variable (display_shape: geometry; shape with a buffer of 2m) and modify the aspect of the roads to display them with this new shape.Add a new global variable that indicate if it is night or not (bool: night before 7h and after 20h).Define a new aspect (sphere3D) for people to display them as sphere.Modify the display to use this new aspect.  "},{"title":"Model Definition​","type":1,"pageTitle":"5. Visualizing in 3D","url":"wiki/IncrementalModel_step5#model-definition","content":""},{"title":"building​","type":1,"pageTitle":"5. Visualizing in 3D","url":"wiki/IncrementalModel_step5#building","content":"First, we add a new variable for buildings (height) of type float from 10m to 20m. Then we modify the aspect in order to specify a depth for the geometry (using the depth facet). species building { float height &lt;- rnd(10#m, 20#m) ; aspect default { draw shape color: #gray border: #black depth: height; } }  "},{"title":"road​","type":1,"pageTitle":"5. Visualizing in 3D","url":"wiki/IncrementalModel_step5#road","content":"Concerning the road, we add a new variable (display_shape) of type geometry that corresponds to the shape of the road with a buffer of 2 meters. Then we modify the aspect in order to display this geometry instead of the shape of the agent. In order to avoid &quot;z-fighting&quot; problems, we add depth to the geometry (of 3 meters). species road { geometry display_shape &lt;- shape + 2.0; aspect default { draw display_shape color: #black depth: 3.0; } }  "},{"title":"global variable​","type":1,"pageTitle":"5. Visualizing in 3D","url":"wiki/IncrementalModel_step5#global-variable","content":"We define a new global variable called is_night of type bool to indicate if it is night or not. This variable will be updated at each simulation step and will be true if the current hour is lower than 7h or higher than 20h. It will be used in the display to change the light of the scene (to set it darker in the night). global{ ... bool is_night &lt;- true update: current_date.hour &lt; 7 or current_date.hour &gt; 20; ... }  "},{"title":"people​","type":1,"pageTitle":"5. Visualizing in 3D","url":"wiki/IncrementalModel_step5#people","content":"We define a new aspect for the people agent called sphere3D. This aspect draws people agent as a 3m sphere. In order to avoid to cut the sphere in half, we translate the centroid of the drawn sphere to 3m along the z-axis. species people skills:[moving]{ ... aspect sphere3D{ draw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green; } }  "},{"title":"display​","type":1,"pageTitle":"5. Visualizing in 3D","url":"wiki/IncrementalModel_step5#display","content":"The element that we have to modify is the display. We change its name to map_3D to better reflect its visual aspect. In order to get a 3D aspect, we specify that this display will be an OpenGL one. For that, we just have to add the facet type: opengl. In addition, we first add an ambient light with a light statement inside the display with the id #ambient and an intensity set to 20. To get a different light between night and day, we add one more light statement with the #default id and to have a nice effect night/day, we will set the intensity of the light to 50 during the night, and 127 for the day. To learn more about light, please read this page. Then, we add a new layer that consists of an image (soil.jpg) by using the image statement. In order to see the people inside the building, we add transparency to the building (0.5). The transparency of a layer is a float value between 0 (solid) and 1 (totally transparent). In order to be able to manage this transparency aspect, OpenGL has to draw the people agents before the building, thus we modify the order of drawing of the different layers (people agents before building agents). At last, we modify the displayed aspect of the people agents by the new one: sphere3D. experiment main_experiment type:gui{ ... output { ... display map_3D type: opengl { light #ambient intensity: 20; light #default intensity:(is_night ? 0 : 127); image &quot;../includes/soil.jpg&quot;; species road ; species people aspect:sphere3D; species building transparency: 0.5; } ... } }  "},{"title":"Complete Model​","type":1,"pageTitle":"5. Visualizing in 3D","url":"wiki/IncrementalModel_step5#complete-model","content":" https://github.com/gama-platform/gama/blob/GAMA_1.8.2/msi.gama.models/models/Tutorials/Incremental%20Model/models/Incremental%20Model%205.gaml  "},{"title":"6. Multi-Level","type":0,"sectionRef":"#","url":"wiki/IncrementalModel_step6","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"6. Multi-Level","url":"wiki/IncrementalModel_step6#formulation","content":"We propose to let the buildings manage what happens when the people are inside buildings. In this context, we will use the multi-level properties of GAMA: when a people agent will be inside a building, it will be captured by it and its species will be modified. It will be not anymore the people agent that will decide when to leave the building, but the building itself that will release it. We will need to: Define a micro-species of people inside the building species (people_in_building).Define two new behaviors for building: let_people_leave and let_people_enter.Modify the aspect of the building.Modify some global variables for counting the number of infected people.  "},{"title":"Model Definition​","type":1,"pageTitle":"6. Multi-Level","url":"wiki/IncrementalModel_step6#model-definition","content":""},{"title":"building​","type":1,"pageTitle":"6. Multi-Level","url":"wiki/IncrementalModel_step6#building","content":"First, we define a new species called people_in_building inside the building species. Thus, a building could have agents of this species as members and control them. The people_in_building species has for parent the people species, which means that a people_in_building agent has all the attributes, aspects and behaviors of a people agent. In our case, we want a people agent inside a building does not do anything. Thus, we use the schedules facet of the species to remove the people_in_building from the scheduler. species building { ... species people_in_building parent: people schedules: [] { } ... }  We define a first reflex for the buildings that will be activated at each simulation step and that will allow the building to capture all the people that are inside its geometry and that are not moving (target = nil). Capturing agents means putting them inside its members list and changing their species: here the people agents become people_in_building agents. species building { ... reflex let_people_enter { capture (people inside self where (each.target = nil)) as: people_in_building; } .... }  We define a second reflex for the buildings that will be activated at each simulation step and that will allow the building to release some of the people_in_building agents. First, it increments the staying counter of all the people_in_building agents. Then it builds the list of leaving people by testing the same probability as before for all the people_in_building agents. Finally, if this list is not empty, it releases them as people agents (and gives them a new target point). species building { ... reflex let_people_leave { ask people_in_building { staying_counter &lt;- staying_counter + 1; } release people_in_building where (flip(each.staying_counter / staying_coeff)) as: people in: world { target &lt;- any_location_in(one_of(building)); } } .... }  At last, we refine the aspect of the buildings: if there are no people inside the building, we draw it with gray color. If the number of people_in_building infected is higher than the number of people_in_building not infected, we draw it in red; otherwise in green. The number of infected people_in_building and its total number will be computed once a step (through the update facet of building attribute). species building { int nb_infected &lt;- 0 update: self.people_in_building count each.is_infected; int nb_total &lt;- 0 update: length(self.people_in_building); aspect default { draw shape color: nb_total = 0 ? #gray : (float(nb_infected) / nb_total &gt; 0.5 ? #red : #green) border: #black depth: height; } }  "},{"title":"global variables​","type":1,"pageTitle":"6. Multi-Level","url":"wiki/IncrementalModel_step6#global-variables","content":"In order to take into account the people that are inside the buildings for the computation of nb_people_infected, we first build the list of people_in_building. As people_in_building is microspecies of building, we cannot compute it directly like for the other species, we then aggregate all the list people_in_building of all building in a single list (list_people_in_buildings). Then, we compute the number of infected people as the number of people infected outside the building + the number of people infected inside them. global { ... list&amp;lt;people_in_building&gt; list_people_in_buildings update: (building accumulate each.people_in_building); int nb_people_infected &lt;- nb_infected_init update: (people + list_people_in_buildings) count (each.is_infected); ... }  "},{"title":"Complete Model​","type":1,"pageTitle":"6. Multi-Level","url":"wiki/IncrementalModel_step6#complete-model","content":" https://github.com/gama-platform/gama/blob/GAMA_1.8.2/msi.gama.models/models/Tutorials/Incremental%20Model/models/Incremental%20Model%206.gaml  "},{"title":"Inheritance","type":0,"sectionRef":"#","url":"wiki/Inheritance","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"Inheritance","url":"wiki/Inheritance#index","content":"Mother species / child speciesVirtual actionsGet all the subspecies from a species "},{"title":"Mother species/child species​","type":1,"pageTitle":"Inheritance","url":"wiki/Inheritance#mother-specieschild-species","content":"To make a species inherit from a mother species, you have to add the facet parent, and specify the mother species. species mother_species { } species child_species parent: mother_species { }  Thus, all the attributes, actions and reflex of the mother species are inherited to the child species. species mother_species { int attribute_A; action action_A {} } species child_species parent: mother_species { init { attribute_A &lt;- 5; do action_A; } }  If the mother species has a particular skill, its children will inherit all the attributes and actions. species mother_species skills:[moving] { } species child_species parent:mother_species { init { speed &lt;- 2.0; } reflex update { do wander; } }  You can redefine an action or a reflex by declaring an action or a reflex with the same name. In the redefined action, it is common to call the action of the mother species with some specific parameters or to add more computations. To this purpose, you need to use: invoke instead of do to call an action (procedure) of the mother species.super.action_name() to call an action (function) of the mother species. species animal { int age &lt;- 0; action grow { age &lt;- age + 1; } int get_age { return age; } } species cat parent: animal { action grow { invoke grow(); // call the action growth of the mother species animal write &quot;I am a cat and I grow up&quot;; } int get_age { return super.get_age() * 7; // call the action get_age from the mother species animal // 1 year is 7 year for cats } }  "},{"title":"Virtual action​","type":1,"pageTitle":"Inheritance","url":"wiki/Inheritance#virtual-action","content":"You have also the possibility to declare a virtual action in the mother species, which means an action without implementation, by using the facet virtual. Note that, when using virtual facet, the statement has to start by action and not a return type. If the action is expecting to return a value you need to add the type facet: action virtual_action virtual: true; action vistual_action_with_return_value virtual: true type: any_type;  When you declare an action as virtual in a species, this species becomes abstract, which means you cannot instantiate agent from it. All the children of this species have to implement this virtual action. species virtual_mother_species { action my_action virtual:true; } species child_species parent: virtual_mother_species { action my_action { // some statements } }  "},{"title":"Get all the subspecies from a species​","type":1,"pageTitle":"Inheritance","url":"wiki/Inheritance#get-all-the-subspecies-from-a-species","content":"If you declare a mother species, you create a child agent, then mother will return the population of agents mother and not the population of agents child, as it is shown in the following example: global { init { create child number: 2; create mother number: 1; } reflex update { write length(mother); // will write 1 and not 3 } } species mother {} species child parent: mother {}  We remind you that subspecies is a built-in attribute of the agent. Using this attribute, you can easily get all the subspecies agents of the mother species by writing the following GAML function: global { init { create child number: 2; create mother number: 1; } reflex update { write length(get_all_instances(mother)); // will write 3 (1+2) } list&amp;lt;agent&gt; get_all_instances(species&amp;lt;agent&gt; spec) { return spec.population + spec.subspecies accumulate (get_all_instances(each)); } } species mother {} species child parent: mother {}  The operator of_generic_species can also be used to filter a list of agents and get all the agents of a given species or of its children species. As a consequence, in the previous example, to count all the agents of mother and child species you can only write: write length(agents of_generic_species mother);  "},{"title":"7. Differential Equations","type":0,"sectionRef":"#","url":"wiki/IncrementalModel_step7","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"7. Differential Equations","url":"wiki/IncrementalModel_step7#formulation","content":"We are interested in the spreading of the disease inside the buildings. In order to model it, we will use differential equations. So, we will need to: Add two global variables to define the building epidemic properties (beta) and numerical integration parameter (h).Add new variables for the buildings (I, S, T, t, I_to1) to manage epidemic;Define differential equations for disease spreading inside buildings.Add one behavior for buildings for the spreading of the disease.  "},{"title":"Model Definition​","type":1,"pageTitle":"7. Differential Equations","url":"wiki/IncrementalModel_step7#model-definition","content":""},{"title":"global variables​","type":1,"pageTitle":"7. Differential Equations","url":"wiki/IncrementalModel_step7#global-variables","content":"We define two new global variables used in the disease spreading dynamic inside the buildings: (i) beta is the contamination rate, and h is the integration step (used in the solve statement). global { ... float beta &lt;- 0.01; float h &lt;- 0.1; ... }  "},{"title":"building​","type":1,"pageTitle":"7. Differential Equations","url":"wiki/IncrementalModel_step7#building","content":"In order to define the disease spread dynamics, we define several variables that will be used by the differential equations: I: float, number of people infected in the building.S: float, number of people not infected in the building.T: float, the total number of people in the building.t: float, the current time of the equation system integration.I_to1: float, the remaining number of people infected (float number lower between 0 and 1 according to the differential equations). species building { ... float I; float S; float T; float t; float I_to1; ... }  Then, we define the differential equations system that will be used for the disease spreading dynamic. Note that to define a differential equation system we use the block equation + name. These equations are the classic ones used by SI mathematical models. species building { .... equation SI{ diff(S,t) = (- beta * S * I / T) ; diff(I,t) = ( beta * S * I / T) ; } ... }  At last, we define a new reflex for the building called epidemic that will be activated only when there is someone inside the building. This reflex first computes the number of people inside the building (T), then the number of not infected people (S) and finally the number of infected ones (I). If there is at least one people infected and one people not infected, the differential equations is integrated (according to the integration step value h) with the method Runge-Kutta 4 to compute the new value of infected people. We then sum the old value of I_to1 with the number of people newly infected (this value is a float and not an integer). Finally, we cast this value as an integer, ask the corresponding number of not infected people to become infected, and decrement this integer value to I\\_to1. species building { ... reflex epidemic when: nb_total &gt; 0 { T &lt;- float(nb_total); S &lt;- float(nb_total - nb_infected); I &lt;- T - S; float I0 &lt;- I; if (I &gt; 0 and S &gt; 0) { solve SI method: #rk4 step_size: h; I_to1 &lt;- I_to1 + (I - I0); int I_int &lt;- min([int(S), int(I_to1)]); I_to1 &lt;- I_to1 - I_int; ask (I_int among (people_in_building where (!each.is_infected))) { is_infected &lt;- true; } } } ... }  "},{"title":"Complete Model​","type":1,"pageTitle":"7. Differential Equations","url":"wiki/IncrementalModel_step7#complete-model","content":"https://github.com/gama-platform/gama/blob/GAMA_1.8.2/msi.gama.models/models/Tutorials/Incremental%20Model/models/Incremental%20Model%207.gaml  "},{"title":"Inspectors and monitors","type":0,"sectionRef":"#","url":"wiki/InspectorsAndMonitors","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Inspectors and monitors","url":"wiki/InspectorsAndMonitors#table-of-contents","content":"Inspectors and monitors Agent BrowserAgent InspectorMonitor "},{"title":"Agent Browser​","type":1,"pageTitle":"Inspectors and monitors","url":"wiki/InspectorsAndMonitors#agent-browser","content":"The species browser provides information about all or a selection of agents of a species. The agent browser is available through the Agents menu.  It displays in a table all the values of the agent variables of the considered species; each line corresponding to an agent. The list of attributes is displayed on the left side of the view, and you can select the attributes you want to be displayed, simply by clicking on it (Ctrl + Click for multi-selection).  By clicking on the right mouse button on a line, it is possible to perform some actions on the corresponding agent (the same actions as when we right-click on it in a display). The Browse view provides also two interesting additional features: Browse a species: change the population displayed in the table.Save the agents and their attributes in a .csv file: this allows the modeler to manipulate and analyze the agent population at will in external software.  "},{"title":"Agent Inspector​","type":1,"pageTitle":"Inspectors and monitors","url":"wiki/InspectorsAndMonitors#agent-inspector","content":"The agent inspector provides information about one specific agent. It also allows the modeler to change the values of its variables during the simulation. The agent inspector is available from the Agents menu, by right_clicking on a display, in the species inspector or when inspecting another agent.  It is possible to &quot;highlight&quot; the selected agent, to focus on it in all the displays, or to kill it.  To change the color of the highlighted agent, go to Preferences/Display.  "},{"title":"Monitor​","type":1,"pageTitle":"Inspectors and monitors","url":"wiki/InspectorsAndMonitors#monitor","content":"Monitors allow the user to follow the value of a GAML expression. For instance, the following ones monitor the number of prey and predator agents during the simulation (the model is available in the Prey Predator tutorial). The monitor is updated at each simulation step.  It is possible to define a monitor inside a model (see this page). It is also possible to define a monitor through the graphical interface. To define a monitor, first choose Add Monitor in the Views menu (or by clicking on the icon in the Monitor view), then define the display legend and the expression to monitor. The expression is compiled when it is written in the text field: as long as the text field is surrounded by a red rectangle, it is incorrect. When the surrounding color becomes green, GAMA has accepted the expression and its value can be displayed in the monitor.  In the following example, we defined a monitor with the legend &quot;Total number of agents&quot; and its value is defined by the GAML expression computing the sum of the number of agents in each population: length(prey) + length(predator).  The expression should be written with the GAML language. See this page for more details about the GAML language. "},{"title":"Installation","type":0,"sectionRef":"#","url":"wiki/Installation","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Installation","url":"wiki/Installation#table-of-contents","content":"Installation Download GAMAInstall procedure Step-by-step WindowsStep-by-step macOSStep-by-step Ubuntu System Requirements "},{"title":"Download GAMA​","type":1,"pageTitle":"Installation","url":"wiki/Installation#download-gama","content":"GAMA 1.8.2 (the last release) comes in a version for each 3 environments Windows, macOS and Linux packaged in easy to use installers. You simply have to go on the downloads page and pick the one for your system. For advanced users : GAMA provide also some versions without embedeed JDK allowing you to download a lighter archive This version requires Java 17 JDK to be installed on your computer (at least 17.0.3+7) It's also possible to download those 2 kinds of release in simple zip archive (i.e. without installers) You'll find them on the Github Release page "},{"title":"Install procedure​","type":1,"pageTitle":"Installation","url":"wiki/Installation#install-procedure","content":"After downloading the chosen GAMA version from the Downloads page for your computer, you only have run the installer, follow steps, and launch GAMA. "},{"title":"Step-by-step Windows​","type":1,"pageTitle":"Installation","url":"wiki/Installation#step-by-step-windows","content":"Download the installer .exe for WindowsDouble-click on the downloaded .exe fileAccept to run the app  Follow the installer few stepsDone, you can start GAMA from your computer now. NB: If you need to launch GAMA Headless, GAMA is installed under C:\\Program Files(x86)\\GAMA Platform "},{"title":"Step-by-step macOS​","type":1,"pageTitle":"Installation","url":"wiki/Installation#step-by-step-macos","content":"Download the installer .dmg for macOS There is a built specifically for Macintosh M1 (also called with Apple silicon). You can check by clicking on the top-left apple, About this Mac: the pop-up window will give details about the processor. If you're not sure and your Macintosh is from 2021 (or earlier) you probably need this specific version Double-click on the downloaded .dmg fileDrag'n'drop GAMA icon to your computer (Applications folder or Desktop for instance)  Done, you can start GAMA from your computer now. At the first launch of GAMA, a popup window will appear warning you that GAMA is a software downloaded from internet and asking whether you want to open it. Click on the Open button.  NB: Note that the first launch of GAMA should be made in GUI mode (clicking on the icon) and not in headless mode. NB2: If you need to launch GAMA Headless after, GAMA is installed where you dragged and dropped the Gama.app "},{"title":"Step-by-step Ubuntu​","type":1,"pageTitle":"Installation","url":"wiki/Installation#step-by-step-ubuntu","content":"Download the installer .deb for Ubuntu (and any Debian-based systems)Double-click on the downloaded .deb fileClick on install  You could be asked for the passwordDone, you can start GAMA from your computer now  NB: If you need to launch GAMA Headless, GAMA is installed under /opt/gama-platform "},{"title":"System Requirements​","type":1,"pageTitle":"Installation","url":"wiki/Installation#system-requirements","content":"GAMA 1.8.2 requires approximately 540MB of disk space and a minimum of 2GB of RAM (to increase the portion of memory usable by GAMA, please refer to these instructions). "},{"title":"Installation and Launching","type":0,"sectionRef":"#","url":"wiki/InstallationAndLaunching","content":"Installation and Launching The GAMA platform can be easily installed in your machine, either if you are using Windows, Mac OS or Ubuntu. GAMA can then be extended by using a number of additional plugins. This part is dedicated to explain how to install GAMA, launching GAMA and extend the platform by installing additional plugins. All the known issues concerning installation are also explain. The GAMA team provides you a continuous support by proposing corrections to some serious issues through updating patchs. In this part, we will also present you briefly an other way to launch GAMA without any GUI : the headless mode. InstallationLaunching GAMAHeadless ModeUpdating GAMAInstalling Plugins","keywords":""},{"title":"Installing the GIT version","type":0,"sectionRef":"#","url":"wiki/InstallingGitVersion","content":"","keywords":""},{"title":"Install Eclipse 2022-03​","type":1,"pageTitle":"Installing the GIT version","url":"wiki/InstallingGitVersion#install-eclipse-2022-03","content":"Download the &quot;Installer of 2022-03&quot; and choose to install the Eclipse IDE for Java and DSL Developers version. This is the latest version under which GAMA is certified to work. Note: Regarding Java, Eclipse embeds the Adoptium (ex Adopt-OpenJDK) 17 LTS (HotSpot), which is the recommanded version for GAMA, you may be able to use another one, but we won't fix any related issue. "},{"title":"Install GAMA source code​","type":1,"pageTitle":"Installing the GIT version","url":"wiki/InstallingGitVersion#install-gama-source-code","content":"The source is to be downloaded from GitHub in two steps: by creating a local clone of the GitHub repository and then importing the different projects that constitute GAMA into the Eclipse workspace. Open the Git perspective: Windows &gt; Perspective &gt; Open Perspective &gt; Other...Choose Git Click on &quot;Clone a Git repository&quot; In Source Git repository window: * Fill in the URI label with: `https://github.com/gama-platform/gama.git` * Other fields will be automatically filled in. In Branch Selection windows, check the GAMA_1.8.2 branchNext  In Local Destination windows, Choose a Directory (where the source files will be downloaded).Everything else should be unchecked Finish  This can take a while... "},{"title":"Import projects into workspace​","type":1,"pageTitle":"Installing the GIT version","url":"wiki/InstallingGitVersion#import-projects-into-workspace","content":"You have now to import projects into the workspace (notice that the folders downloaded during the clone will neither be copied nor moved). Note: contrarily to previous Eclipse versions, import project from the Git perspective does not work properly for GAMA. In the Java perspective, choose: File / Import...,  In the install window, select Git / Projects from Git,Click on Next,In the Project from Git window, select Existing local repository.,  Click on Next,In the new window, select your Git repository,Click on Next,In the Select a wizard to used to import projects, check that Import existing Eclipse projects is selectedWorking Tree is selected  Click on Next, In the Import project window, * **Uncheck Search for nested projects** * Select all the projects Finish Clean project (Project menu &gt; Clean ...) "},{"title":"If you have errors...​","type":1,"pageTitle":"Installing the GIT version","url":"wiki/InstallingGitVersion#if-you-have-errors","content":"If errors continue to show on in the different projects, be sure to correctly set the JDK used in the Eclipse preferences. GAMA (version 1.8.2) is targeting JDK 17, and Eclipse could produce errors if it did not find in your environment. So, either you set the compatibility to 17 by default (in Preferences &gt; Java &gt; Compiler &gt; Compiler Compliance Level) or you change the error produced by Eclipse to a warning only (in Preferences &gt; Java &gt; Compiler &gt; Building &gt; &quot;No strictly compatible JRE for execution environment available). On Windows : if the project still dont compile, try to add the vm argument in eclipse.ini files (inside the directory where your eclipse is installed) before the -startup line Example : -vm C:\\Program Files\\Java\\JDK17\\bin -startup ..... "},{"title":"Run GAMA​","type":1,"pageTitle":"Installing the GIT version","url":"wiki/InstallingGitVersion#run-gama","content":"Be sure to be in the Java Perspective (top right button)In the ummisco.gama.product plugin, open the gama.runtime.product file (gama.product is used to produce the release).Go to &quot;Overview&quot; tab and click on SynchronizeClick on Launch an Eclipse Application "},{"title":"GIT Tutorials​","type":1,"pageTitle":"Installing the GIT version","url":"wiki/InstallingGitVersion#git-tutorials","content":"For those who want to learn more about Git and Egit, please consult the following tutorials/papers EGIT/User Guide http://wiki.eclipse.org/EGit/User_GuideGit version control with Eclipse (EGIT) - Tutorial http://www.vogella.com/tutorials/EclipseGit/article.html10 things I hate about Git http://stevebennett.me/2012/02/24/10-things-i-hate-about-git/Learn Git and GitHub Tutorial https://www.youtube.com/playlist?list=PL1F56EA413018EEE1 "},{"title":"Installing Plugins","type":0,"sectionRef":"#","url":"wiki/InstallingPlugins","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Installing Plugins","url":"wiki/InstallingPlugins#table-of-contents","content":"Installing Plugins InstallationSelected plugins provided by GAMA community Toward participative simulations with Remote.Gui and Gaming pluginsRJava pluginWeka and Matlab plugins Selected Plugins GitCSV EditQuickimageRSS/Atom Feed ViewCKEditorStartexplorerPathtools "},{"title":"Installation​","type":1,"pageTitle":"Installing Plugins","url":"wiki/InstallingPlugins#installation","content":"Installing new plugins is a process identical to the one described when updating GAMA, with one exception: the update site to enter is normally provided by the vendor of the additional plugin and must be entered instead of GAMA's one in the dialog. Let suppose that we want to install a GAMA plugin developed in order to allow GAMA to ask R to do some computations. This plugin is developed by the GAMA community, but the installation of any plugin will be similar, only the address of the update site will change. To install this plugin, open the pane to install new plugins: &quot;Help &gt; Install new plugins ... &quot;. Choose in the &quot;Work with...&quot; text field: msi.gama.experimental.p2updatesite - http://updates.gama-platform.org/experimental  If it is not available, you can simply type the address of the update site in the text field: http://updates.gama-platform.org/experimental  Among all the plugins, select RJava in the category &quot;Optional components of GAMA&quot; and click on &quot;Next &gt;&quot; button.  The initial dialog is followed by two other ones, a first to report that the plugin satisfies all the dependencies, a second to ask the user to accept the license agreement.   Once we dismiss the warning that the plugin is not signed and accept to restart GAMA, we can test the new plugin. In the case of plugins extending the features of GAMA, some example models are often provided with the new plugins to illustrate its use (and it is the case for RJava). These new models are accessible in GAMA from Plugin models in a dedicated folder (GAMA to Rjava in the case of RJava). We may need to refresh the model library to let it appear. Notice that you need to configure GAMA to access R before running these models.  "},{"title":"Selected plugins provided by the GAMA community​","type":1,"pageTitle":"Installing Plugins","url":"wiki/InstallingPlugins#selected-plugins-provided-by-the-gama-community","content":"The update site located at the address http://updates.gama-platform.org/experimental contains new plugins for GAMA mainly developed by the GAMA community (its Github repository is available here). As the name of the repository highlights it, these plugins are most of them still in development, before integration in the kernel of GAMA. "},{"title":"Toward participative simulations with Remote.Gui and Gaming plugins​","type":1,"pageTitle":"Installing Plugins","url":"wiki/InstallingPlugins#toward-participative-simulations-with-remotegui-and-gaming-plugins","content":"There are more and more applications of GAMA for participative simulations (LittoSim, MarakAir, HoanKiemAir...). There was thus a need for new features to improve the possible interactions with simulations and the definition of the Graphical User Interface. The two plugins Remote.Gui and Gaming (available in the &quot;Participative simulation&quot; category) attempts to fill this need. Remote.Gui allows exposing some model parameters, in order that they can be modified through a network. This allows, for example, to develop a remote application (e.g. Android application) to control the parameters' values during the simulation. Gaming allows the modeler to define displays that are much more interactive. This is used to define serious games in which the users can have a wide range of possible interactions with the simulation. "},{"title":"RJava plugin​","type":1,"pageTitle":"Installing Plugins","url":"wiki/InstallingPlugins#rjava-plugin","content":"This plugin allows the modeler to launch some computation on the R software. To this purpose, R should be installed on your computer and GAMA should be properly configured. This possible connection to R opens thus the possibility for the modeler to use all the statistical functions and libraries developed in this tool of reference. In addition, R scripts defined by the modeler can also be used directly from his/her GAMA model. "},{"title":"Weka and Matlab plugins​","type":1,"pageTitle":"Installing Plugins","url":"wiki/InstallingPlugins#weka-and-matlab-plugins","content":"Similarly to RJava, Matlab and Weka plugins allow the modeler to run computations on the Matlab and Weka software, taking advantages of all the possibilities of these softwares and of scripts defined by him/herself. Notice that the Matlab plugin requires that MATLAB 2019a is installed and activated on your computer. "},{"title":"Selected Plugins​","type":1,"pageTitle":"Installing Plugins","url":"wiki/InstallingPlugins#selected-plugins","content":"In addition to the plugins provided by GAMA community described above, below is a list of plugins that have been tested to work with GAMA. There are many others so take the time to explore them! "},{"title":"Git​","type":1,"pageTitle":"Installing Plugins","url":"wiki/InstallingPlugins#git","content":"Git is a version control system (like CVS or SVN, extensively used in GAMA) http://git-scm.com/. Free sharing spaces are provided on GitHub among others. Installing Git allows to share or gather models that are available in Git repositories.Update site: http://download.eclipse.org/egit/updatesSelect the following plugin: Git integration for Eclipse (in Git integration for Eclipse category). How to use it: This plugin adds new View for GAMA available from: &quot;Views &gt; Other... &gt; Show view &gt; Other...&quot;As an example, choose &quot;Git Repositories&quot;.A new view appears in GAMA. You have to clone an existing Git repository or add a local one. Details and tutorials about the use of Git in Eclipse.The projects available in the Git repository can now be imported in your User models.  "},{"title":"CSV Edit​","type":1,"pageTitle":"Installing Plugins","url":"wiki/InstallingPlugins#csv-edit","content":"An editor for CSV files. Quite handy if you do not want to launch Excel every time you need to inspect or change the CSV data files used in models. It allows the modification of cells, the insertion, addition, and deletion of a row.Update site: https://raw.githubusercontent.com/SegFaultError/CsvEdit/master/csvedit.update/site.xmlWebsite: https://github.com/Mathieuu/CsvEdit  "},{"title":"Quickimage​","type":1,"pageTitle":"Installing Plugins","url":"wiki/InstallingPlugins#quickimage","content":"A lightweight viewer of images, which can be useful when several images are used in a model. It allows viewing images one by one or as thumbnails. Supported formats: .gif, .jpg, .jpeg, .png, .bmp, .ico.Update site: http://manu26.manufrog.com/~psnetnu/eclipse/updates/Website (but seems outdated): https://github.com/persal/quickimage  "},{"title":"RSS/Atom Feed View​","type":1,"pageTitle":"Installing Plugins","url":"wiki/InstallingPlugins#rssatom-feed-view","content":"an RSS feed reader in GAMA! It can allow you to monitor the issues of GAMA from within GAMA itself!Update site: http://www.junginger.biz/eclipse/Select the following plugin: RSS View (Eclipse 3.x)Website: http://junginger.biz/eclipse/How to use it: This plugin adds new View for GAMA available from: &quot;Views &gt; Other... &gt; Show view &gt; Other...&quot;To monitor the issues of GAMA from within GAMA itself: right-click on the RSS View and choose &quot;Add a new feed&quot;Add the address: http://gh-feed.imsun.net/gama-platform/gama/issues  "},{"title":"CKEditor​","type":1,"pageTitle":"Installing Plugins","url":"wiki/InstallingPlugins#ckeditor","content":"CKEditor is a lightweight and powerful web-based editor, perfect for almost WYSIWYG edition of HTML files. It can be installed, directly in GAMA, in order to edit .html, .htm, .xml, .svg, etc. files directly without leaving the platform. No other dependencies are required. A must! Update site: https://kosz.bitbucket.io/eclipse-ckeditor/update-siteWebsite: https://ckeditor.com/  "},{"title":"Markdown Text Editor​","type":1,"pageTitle":"Installing Plugins","url":"wiki/InstallingPlugins#markdown-text-editor","content":"Plugin adding Markdown text-editing support to Eclipse. Makes editing text files in Eclipse a lot better. Markdown is a simple and intuitive text format syntax that lets you get rich formatting with 'normal' Update site: https://nodeclipse.github.io/updates/markdown/How to use it: Any markdown file can be opened with the Markdown Editor (to provide syntax highlighting)The plugin adds to the GAMA view: the Markdown View, to render the markdown file.  "},{"title":"Startexplorer​","type":1,"pageTitle":"Installing Plugins","url":"wiki/InstallingPlugins#startexplorer","content":"A nice utility that allows the user to select files, folders or projects in the Navigator and open them in the filesystem (either the UI Explorer, Finder, whatever, or in a terminal).Update site: http://basti1302.github.com/startexplorer/update/  "},{"title":"Pathtools​","type":1,"pageTitle":"Installing Plugins","url":"wiki/InstallingPlugins#pathtools","content":"Same purpose as StartExplorer, but much more complete, and additionally offers the possibility to add new commands to handle files (open them in specific editors, execute external programs on them, etc.). Very nice and professional. Works flawlessly in GAMA except that contributions to the toolbar are not accepted (so you have to rely on the commands present in the Navigator pop-up menu).Update site: http://cdn.rawgit.com/sandipchitale/pathtools/1.0.64/PathToolsUpdateSite/site.xml  "},{"title":"Interaction between agents","type":0,"sectionRef":"#","url":"wiki/InteractionBetweenAgents","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"Interaction between agents","url":"wiki/InteractionBetweenAgents#index","content":"The ask statementPseudo variablesSome useful interaction operatorsExample "},{"title":"The ask statement​","type":1,"pageTitle":"Interaction between agents","url":"wiki/InteractionBetweenAgents#the-ask-statement","content":"The ask statement can be used in any reflex or action scope. It is used to specify the interaction between the instances of your species and the other agents. You only have to specify the species of the agents you want to interact with. Here are the different ways of calling the ask statement: If you want to interact with one particular agent (for example, defined as an attribute of your species): species my_species { agent target; reflex update { ask target { // statements } } }  If you want to interact with a group of agents: species my_species { list&amp;lt;agent&gt; targets; reflex update { ask targets { // statements } } }  If you want to interact with agents, as if they were instance of a certain species (can raise an error if it's not the case!): species my_species { list&amp;lt;agent&gt; targets; reflex update { ask targets as:my_species { // statements } } }  If you want to interact with all the agents of a species (note that the name of the species can be used in the ask, and in many other situations, as the population of this species, i.e. the list of agents instance of this species): species my_species { reflex update { ask other_species { // statements } } } species other_species { }  Note that you can use the attribute population of species if you find it more explicit: ask other_species.population  If you want to interact with all the agents of a particular species from a list of agents (for example, using the global variable &quot;agents&quot;): species my_specie { reflex update { ask agents of_species my_specie { // statements } } }  "},{"title":"Pseudo-variables​","type":1,"pageTitle":"Interaction between agents","url":"wiki/InteractionBetweenAgents#pseudo-variables","content":"Once you are in the ask scope, you can use some pseudo-variables to refer to the receiver agent (the one specified just after the ask statement) or the transmitter agent (the agent which is asking). We use the pseudo-variable self to refer to the receiver agent, and the pseudo-variable myself to refer to the transmitter agent. The pseudo variable self can be omitted when calling actions or attributes. species speciesA { init { name &lt;- &quot;speciesA&quot;; } reflex update { ask speciesB { write name; // output : &quot;speciesB&quot; write self.name; // output : &quot;speciesB&quot; write myself.name; // output : &quot;speciesA&quot; } } } species speciesB { init { name &lt;- &quot;speciesB&quot;; } }  Now, if we introduce a third species, we can write an ask statement inside another. species speciesA { init { name &lt;- &quot;speciesA&quot;; } reflex update { ask speciesB { write self.name; // output : &quot;speciesB&quot; write myself.name; // output : &quot;speciesA&quot; ask speciesC { write self.name; // output : &quot;speciesC&quot; write myself.name; // output : &quot;speciesB&quot; } } } } species speciesB { init { name &lt;- &quot;speciesB&quot;; } } species speciesC { init { name &lt;- &quot;speciesC&quot;; } }  Nb: try to avoid multiple imbrications of ask statements. Most of the time, there is another way to do the same thing. "},{"title":"Some useful interaction operators​","type":1,"pageTitle":"Interaction between agents","url":"wiki/InteractionBetweenAgents#some-useful-interaction-operators","content":"The operator at_distance can be used to know the list of agents that are in a certain distance from another agent. species my_species { reflex update { list&amp;lt;agent&gt; neighbors &lt;- agents at_distance(5); // neighbors contains the list of all the agents located at a distance &lt;= 5 from the caller agent. } }  The operator closest_to returns the closest agent of a position among a container. species my_species { reflex update { agent agentA &lt;- agents closest_to(self); // agentA contains the closest agent from the caller agent. agent agentB &lt;- other_specie closest_to({2,3}); // agentB contains the closest instance of other_specie from the location {2,3}. } } species other_specie { }  "},{"title":"Example​","type":1,"pageTitle":"Interaction between agents","url":"wiki/InteractionBetweenAgents#example","content":"To practice those notions, here is a short basic example. Let's build a model with a given number of agents with a circle display (keep in mind that their shape has kept its default value: a point). They can move randomly on the environment (i.e. here move can be understood as changing its location), and when they are close enough from another agent, a line is displayed between them. This line is destroyed when the distance between the two agents is too important. Hint: use the operator polyline to construct a line. List the points between angle brackets [ and ].  Here is one example of implementation: model connect_the_neighbors global{ float speed &lt;- 0.2; float distance_to_intercept &lt;- 10.0; int number_of_circle &lt;- 100; init { create my_species number:number_of_circle; } } species my_species { reflex move { location &lt;- {location.x+rnd(-speed,speed),location.y+rnd(-speed,speed)}; } aspect default { draw circle(1) color: #yellow border: #black; ask my_species at_distance(distance_to_intercept) { draw polyline([self.location,myself.location]) color:#black; } } } experiment my_experiment type:gui { output{ display myDisplay { species my_species aspect:default; } } }  "},{"title":"Introduction","type":0,"sectionRef":"#","url":"wiki/Introduction","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Introduction","url":"wiki/Introduction#table-of-contents","content":"Key Concepts (Under construction) Lexical semantics of GAMLTranslation into a concrete syntaxVocabulary correspondance with the object-oriented paradigm as in JavaVocabulary correspondance with the agent-based paradigm as in NetLogo "},{"title":"Lexical semantics of GAML​","type":1,"pageTitle":"Introduction","url":"wiki/Introduction#lexical-semantics-of-gaml","content":"The vocabulary of GAML is described in the following sentences, in which the meaning and relationships of the important words of the language (in bold face) are summarized. The role of GAML is to support modelers in writing models, which are specifications of simulations that can be executed and controlled during experiments, themselves specified by experiment plans.The agent-oriented modeling paradigm means that everything &quot;active&quot; (entities of a model, systems, processes, activities, like simulations and experiments) can be represented in GAML as an agent (which can be thought of as a computational component owning its own data and executing its own behavior, alone or in interaction with other agents).Like in the object-oriented paradigm, where the notion of class is used to supply a specification for objects, agents in GAML are specified by their species, which provide them with a set of attributes (what they know), actions (what they can do), behaviors (what they actually do) and also specifies properties of their population, for instance its topology (how they are connected) or schedule (in which order and when they should execute).Any species can be nested in another species (called its macro-species), in which case the populations of its instances will imperatively be hosted by an instance of this macro-species. A species can also inherit its properties from another species (called its parent species), creating a relationship similar to specialization in object-oriented design. In addition to this, species can be constructed in a compositional way with the notion of skills, bundles of attributes and actions that can be shared between different species and inherited by their children.Given that all agents are specified by a species, simulations and experiments are then instances of two species which are, respectively, called model and experiment plan. Think of them as &quot;specialized&quot; categories of species.The relationships between species, models and experiment plans are codified in the meta-model of GAML in the form of a framework composed of three abstract species respectively called agent (direct or indirect parent of all species), model (parent of all species that define a model) and experiment (parent of all species that define an experiment plan). In this meta-model, instances of the children of agent know the instance of the child of model in which they are hosted as their world, while the instance of experiment plan identifies the same agent as one of the simulations it is in charge of. The following diagram summarizes this framework:  Putting this all together, writing a model in GAML then consists in defining a species which inherits from model, in which other species, inheriting (directly or not) from agent and representing the entities that populate this model, will be nested, and which is itself nested in one or several experiment plans among which a user will be able to choose which experiment he/she wants to execute.  At the operational level, i.e. when running an experiment in GAMA, an experiment agent is created. Its behavior, specified by its experiment plan, will create simulations agents (instance of the user model) and execute them. Recursively, the initialization of a simulation agent will create the agent population of the species defined in the model. Each of these agents, when they are created, can create the population of their micro-species... "},{"title":"Translation into a concrete syntax​","type":1,"pageTitle":"Introduction","url":"wiki/Introduction#translation-into-a-concrete-syntax","content":"The concepts presented above are expressed in GAML using a syntax which bears resemblances with mainstream programming languages like Java, while reusing some structures from Smalltalk (namely, the syntax of facets or the infix notation of operators). While this syntax is fully described in the subsequent sections of the documentation, we summarize here the meaning of its most prominent structures and their correspondence (when it exists) with the ones used in Java and NetLogo. A model is composed of a header, in which it can refer to other models, and a sequence of species and experiments declarations, in the form of special declarative statements of the language.A statement can be either a declaration or a command. It is always composed of a keyword followed by an optional expression, followed by a sequence of facets, each of them composed of a keyword (terminated by a ‘:’) and an expression.facets allow to pass arguments to statements. Their value is an expression of a given type. An expression can be a literary constant, the name of an attribute, variable or pseudo-variable, the name of a unit or constant of the language, or the application of an operator.A type can be a primitive type, a species type or a parametric type (i.e. a composition of types).Some statements can include sub-statements in a block (sequence of statements enclosed in curly brackets).declarative statements support the definition of special constructs of the language: for instance, species (including global and experiment species), attributes, actions, behaviors, aspects, variables, parameters and outputs of experiments.imperative statements that execute something or control the flow of execution of actions, behaviors and aspects are called commands.A species declaration (global, species or grid keywords) can only include 6 types of declarative statements : attributes, actions, behaviors, aspects, equations and (nested) species. In addition, experiment species allow to declare parameters, outputs and batch methods. "},{"title":"Vocabulary correspondence with the object-oriented paradigm as in Java​","type":1,"pageTitle":"Introduction","url":"wiki/Introduction#vocabulary-correspondence-with-the-object-oriented-paradigm-as-in-java","content":"GAML\tJavaspecies\tclass micro-species\tnested class parent species\tsuperclass child species\tsubclass model\tprogram experiment\t(main) class agent\tobject attribute\tmember action\tmethod behavior\tcollection of methods aspect\tcollection of methods, mixed with the behavior skill\tinterface (on steroids) statement\tstatement type\ttype parametric type\tgenerics "},{"title":"Vocabulary correspondence with the agent-based paradigm as in NetLogo​","type":1,"pageTitle":"Introduction","url":"wiki/Introduction#vocabulary-correspondence-with-the-agent-based-paradigm-as-in-netlogo","content":"GAML\tNetLogospecies\tbreed micro-species\t- parent species\t- child species\t- (only from 'turtle') model\tmodel experiment\tobserver agent\tturtle/observer attribute\t'breed'-own action\tglobal function applied only to one breed behavior\tcollection of global functions applied to one breed aspect\tonly one, mixed with the behavior skill\t- statement\tprimitive type\ttype parametric type\t- "},{"title":"Launching GAMA","type":0,"sectionRef":"#","url":"wiki/Launching","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Launching GAMA","url":"wiki/Launching#table-of-contents","content":"Launching GAMA Launching the ApplicationLaunching the Application from the command lineChoosing a WorkspaceWelcome Page "},{"title":"Launching the Application​","type":1,"pageTitle":"Launching GAMA","url":"wiki/Launching#launching-the-application","content":"The extraction of the downloaded archive provides: on Mac OS X: a single file named Gama.appon Windows and Linux: a folder named GAMA_1.8_YOUR_OS_NAME containing, among many other files and folders, the Gama.exe file (for Windows) and Gama (for Linux). Running GAMA requires that you launch the application file (Gama.app on Mac OS X, Gama.exe on Windows, Gama on Linux) by double-clicking on them or from a terminal. "},{"title":"Launching the Application from the command line​","type":1,"pageTitle":"Launching GAMA","url":"wiki/Launching#launching-the-application-from-the-command-line","content":"Note that GAMA can also be launched in two different other ways: In a so-called headless mode (i.e. without a user interface, from the command line, in order to conduct experiments or to be run remotely). Please refer to the corresponding instructions.From the terminal, using a path to a model file and the name or number of an experiment, in order to allow running this experiment directly (note that the two arguments are optional: if the second is omitted, the file is imported in the workspace if not already present and opened in an editor; if both are omitted, GAMA is launched as usual): Gama.app/Contents/MacOS/Gama path_to_a_model_file#experiment_name_or_number on Mac OS XGama path_to_a_model_file#experiment_name_or_number on LinuxGama.exe path_to_a_model_file#experiment_name_or_number on Windows "},{"title":"Choosing a Workspace​","type":1,"pageTitle":"Launching GAMA","url":"wiki/Launching#choosing-a-workspace","content":"Past the splash screen, GAMA will ask you to choose a workspace in which to store your models and their associated data and settings. The workspace can be any folder in your filesystem on which you have read/write privileges. If you want GAMA to remember your choice next time you run it (it can be handy if you run Gama from the command line), simply check the corresponding option. If this dialog does not show up when launching GAMA, it probably means that you inherit from an older workspace used with a previous GAMA version (and still &quot;remembered&quot;). In that case, a warning will be produced to indicate that the model library is out of date, offering you the possibility to create a new workspace.  You can enter its address or browse your filesystem using the appropriate button. If the folder already exists, it will be reused (after a warning if it is not already a workspace). If not, it will be created. It is always a good idea, when you launch a new version of GAMA for the first time, to create a new workspace. You will then, later, be able to import your existing models into it. Failing to do so might lead to odd errors in the various validation processes. When you try to choose a workspace used with a previous of GAMA, the following pop-up will appear.  The following pop-up appears when the user wants to create a new workspace in a folder that does not exist. Click on OK to create the folder and set this new folder as the GAMA workspace.  "},{"title":"Welcome Page​","type":1,"pageTitle":"Launching GAMA","url":"wiki/Launching#welcome-page","content":"As soon as the workspace is created, GAMA will open and you will be presented with its first window. GAMA is based on Eclipse and reuses most of its visual metaphors for organizing the work of the modeler. The main window is then composed of several parts, which can be views or editors, and are organized in a perspective. GAMA proposes 2 main perspectives: Modeling, dedicated to the creation of models, and Simulation, dedicated to their execution and exploration. Other perspectives are available if you use shared models. The default perspective in which GAMA opens is Modeling. It is composed of a central area where GAML editors are displayed, which is surrounded by a Navigator view on the left-hand side of the window, an Outline view (linked with the open editor), the Problems view, which indicates errors and warnings present in the models stored in the workspace and an interactive console, which allows the modeler to try some expressions and get an immediate result.  In the absence of previously open models, GAMA will display a Welcome page (actually a web page), from which you can find links to the website, current documentation, tutorials, etc. This page can be kept open (for instance if you want to display the documentation when editing models) but it can also be safely closed (and reopened later from the &quot;Views&quot; menu).  From this point, you are now able to edit a new model, navigate in the model library, or import an existing model. "},{"title":"Launching Experiments from the User Interface","type":0,"sectionRef":"#","url":"wiki/LaunchingExperiments","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Launching Experiments from the User Interface","url":"wiki/LaunchingExperiments#table-of-contents","content":"Launching Experiments from the User Interface From an EditorFrom the NavigatorRunning Experiments AutomaticallyRunning Several Simulations "},{"title":"From an Editor​","type":1,"pageTitle":"Launching Experiments from the User Interface","url":"wiki/LaunchingExperiments#from-an-editor","content":"As already mentioned in this page, GAML editors will provide the easiest way to launch experiments. Whenever a model that contains the definition of experiments is validated, these experiments will appear as distinct buttons, in the order in which they are defined in the file, in the header ribbon above the text. Simply clicking one of these buttons launches the corresponding experiment.  For each of those launching buttons, you can see different pictograms, showing the type of experiment. The various kinds of experiment are described in this page.  "},{"title":"From the Navigator​","type":1,"pageTitle":"Launching Experiments from the User Interface","url":"wiki/LaunchingExperiments#from-the-navigator","content":"You can also launch your experiments from the navigator, by expanding a model and double-clicking on one of the experiments available (the number of experiments for each model is visible also in the navigator). As for the editor, the various types of experimentations are differentiated by a pictogram.  "},{"title":"Running Experiments Automatically​","type":1,"pageTitle":"Launching Experiments from the User Interface","url":"wiki/LaunchingExperiments#running-experiments-automatically","content":"Once an experiment has been launched (unless it is run in headless mode, of course), it normally displays its views and waits from an input from the user, usually a click on the &quot;Run&quot; or &quot;Step&quot; buttons (see here). It is, however, possible to make experiments run directly once launched, without requiring any intervention from the user. To activate this feature, open the preferences of GAMA. In the &quot;Execution&quot; tab, simply check &quot;Auto-run experiments when they are launched&quot; (which is unchecked by default) and hit &quot;Save&quot; to dismiss the dialog. Next time you will launch an experiment, it will run automatically (this option also applies to experiments launched from the command line).  When the autorun is set in the Preferences, all the experiments in the workspace will be in autorun mode. If you want to activate this option only for a single experiment, it can be done programmatically by adding the autorun: to the experiment statement as detailed in this page. "},{"title":"Running Several Simulations​","type":1,"pageTitle":"Launching Experiments from the User Interface","url":"wiki/LaunchingExperiments#running-several-simulations","content":"It is possible in GAMA to run several simulations (multi-simulation feature). Each simulation will be launched with the same seed (which means that if the parameters are the same, then the result will be exactly the same). All those simulations are synchronized in the same cycle. To run several simulations, you have to write it directly in your model.  "},{"title":"Introduction to GAMA Java API","type":0,"sectionRef":"#","url":"wiki/Introduction-To-Gama-Java-API","content":"","keywords":""},{"title":"Table of content​","type":1,"pageTitle":"Introduction to GAMA Java API","url":"wiki/Introduction-To-Gama-Java-API#table-of-content","content":"Concepts FactoriesSpatialTypeIScopeExceptionDebugTest Packages 1.Core   "},{"title":"Factories​","type":1,"pageTitle":"Introduction to GAMA Java API","url":"wiki/Introduction-To-Gama-Java-API#factories","content":""},{"title":"Container factories​","type":1,"pageTitle":"Introduction to GAMA Java API","url":"wiki/Introduction-To-Gama-Java-API#container-factories","content":"GAMA provides 2 factories for containers: GamaListFactory and GamaMapFactory. Each of them has create methods to create objects of type IList and IMap. The types of elements in the container can be specified at creation using one of the elements defined in Types. Warning: the create method is used to create the container, with elements of a given type, but it also converts elements added in this type. To avoid conversion (not recommended), use the method createWithoutCasting. GamaListFactory : factory to create list of different type (see Java class)  As an example: IList&amp;lt;Double&gt; distribution = GamaListFactory.create(Types.FLOAT);  To create List object without specifying the type, use Types.NO_TYPE: IList&amp;lt;Object&gt; result = GamaListFactory.create(Types.NO_TYPE);  or only: IList&amp;lt;Object&gt; result = GamaListFactory.create();  GamaMapFactory : factory to create map of different type (see Java class)  As an example: final IMap&amp;lt;String, IList&lt;?&gt;&gt; ncdata = GamaMapFactory.create(Types.STRING, Types.LIST);  To create Map object without specifying the type, use Types.NO_TYPE: IMap&lt;Object, Object&gt; result = GamaMapFactory.create(Types.NO_TYPE, Types.NO_TYPE);  or only: IMap&amp;lt;Object, Object&gt; result = GamaMapFactory.create();  If you want to use map or set, try to the best to rely on collection that ensure order, so to avoid unconsistency in container access. Try the most to avoid returning high order hash based collection, e.g. Set or Map; in this case, rely on standard definition in Gama: TOrderedHashMap : see trove api. TLinkedHashSet : see trove api Stream : you can use java build-in streams but there is a special version in Gama taken from StreamEx that should be preferred. my_container.stream(my_scope)  If you want to get a stream back to a Gama container, you can use the collector in Factories: my_container.stream(my_scope).collect(GamaListFactory.toGamaList())  "},{"title":"Geometry factory​","type":1,"pageTitle":"Introduction to GAMA Java API","url":"wiki/Introduction-To-Gama-Java-API#geometry-factory","content":"Gama geometry is based on the well established Jstor geometric library, while geographic aspect are handle using GeoTools library Spatial.Creation : provide several static method to initialize geometries "},{"title":"Spatial​","type":1,"pageTitle":"Introduction to GAMA Java API","url":"wiki/Introduction-To-Gama-Java-API#spatial","content":"The Spatial class provide several static access to the main methods to create, query, manipulate and transform geometries "},{"title":"Operators​","type":1,"pageTitle":"Introduction to GAMA Java API","url":"wiki/Introduction-To-Gama-Java-API#operators","content":"Use as Spatial.Operators follow by the operator, usually one of Gaml language: union, intersection, minus, and other cross geometry operations "},{"title":"Queries​","type":1,"pageTitle":"Introduction to GAMA Java API","url":"wiki/Introduction-To-Gama-Java-API#queries","content":"closest, distance, overlapping, and other relative spatial relationship "},{"title":"Transpositions​","type":1,"pageTitle":"Introduction to GAMA Java API","url":"wiki/Introduction-To-Gama-Java-API#transpositions","content":"enlarge, transpose, rotate, reduce and other specific transposition (like triangulation, squarification, etc.) "},{"title":"Punctal​","type":1,"pageTitle":"Introduction to GAMA Java API","url":"wiki/Introduction-To-Gama-Java-API#punctal","content":"operations relative to points "},{"title":"Type​","type":1,"pageTitle":"Introduction to GAMA Java API","url":"wiki/Introduction-To-Gama-Java-API#type","content":"IType: The main class to manipulate GamaType (main implementation of IType) is Types, that provides access to most common type manipulated in Gama Opérateur de cast: Types.get(IType.class)  "},{"title":"IScope interface​","type":1,"pageTitle":"Introduction to GAMA Java API","url":"wiki/Introduction-To-Gama-Java-API#iscope-interface","content":"An object of type IScope represents the context of execution of an agent (including experiments, simulations, and &quot;regular&quot; agents). Everywhere it is accessible (either passed as a parameter or available as an instance variable in some objects), it provides an easy access to a number of features: the current active agent, the shared random number generator, the global clock, the current simulation and experiment agents, the local variables declared in the current block, etc. It also allows modifying this context, like changing values of local variables, adding new variables, although these functions should be reserved to very specific usages. Ordinarily, the scope is simply passed to core methods that allow to evaluate expressions, cast values, and so on. "},{"title":"Use of an IScope​","type":1,"pageTitle":"Introduction to GAMA Java API","url":"wiki/Introduction-To-Gama-Java-API#use-of-an-iscope","content":"A variable scope of type IScope can be used to: get the current agent with: scope.getAgentScope() IAgent agent = scope.getAgentScope();  evaluate an expression in the current scope: String mes = Cast.asString(scope, message.value(scope));  know whether the scope has been interrupted: boolean b = scope.interrupted();  "},{"title":"Exception​","type":1,"pageTitle":"Introduction to GAMA Java API","url":"wiki/Introduction-To-Gama-Java-API#exception","content":"Exceptions in GAMA An exception that can appear in the GAMA platform can be run using the GamaRuntimeException class. This class allows throwing an error (using error(String,IScope) method) or a warning (using warning(String,IScope) method). In particular, it can be useful to catch the Java Exception and to throw a GAMA exception. try { ... } catch(Exception e) { throw GamaRuntimeException.error(&quot;informative message&quot;, scope); }  "},{"title":"Debug​","type":1,"pageTitle":"Introduction to GAMA Java API","url":"wiki/Introduction-To-Gama-Java-API#debug","content":"Main class for debug is in ummisco.gama.dev.utils : DEBUG To turn GAMA Git version to debug mode change variable of the Debug class like: GLOBAL_OFF = false Turn on or off the debug for one class: DEBUG.ON() or DEBUG.OFF() You can benchmark a method call using : DEBUG.TIME(&quot;Title to log&quot;, () -&gt; methodToBenchmark(...)) You can use different built-in level to print: DEBUG.ERR(string s) DEBUG.LOG(string s) DEBUG.OUT(Object message) "},{"title":"Test​","type":1,"pageTitle":"Introduction to GAMA Java API","url":"wiki/Introduction-To-Gama-Java-API#test","content":"There are Gaml primitives and statement to define test: test &quot;Operator + (1)&quot; { assert (circle(5) + 5).height with_precision 1 = 20.0; assert (circle(5) + 5).location with_precision 9 = (circle(10)).location with_precision 9; }  Everything can be made using Java Annotation (translated to Gaml test) : examples = { @example (value=&quot;...&quot;,equals=&quot;...&quot; ) } test = { &quot;...&quot; } // don't forget to turn test arg of examples to false    "},{"title":"Core​","type":1,"pageTitle":"Introduction to GAMA Java API","url":"wiki/Introduction-To-Gama-Java-API#core","content":"The main plugin of the GAMA Platform that defines the core functionalities: most Gaml operators, statements, skills, types, etc. "},{"title":"Metamodel​","type":1,"pageTitle":"Introduction to GAMA Java API","url":"wiki/Introduction-To-Gama-Java-API#metamodel","content":" IAgent, IPopulation, IShape, ITopology, "},{"title":"Ouputs​","type":1,"pageTitle":"Introduction to GAMA Java API","url":"wiki/Introduction-To-Gama-Java-API#ouputs","content":" "},{"title":"Util​","type":1,"pageTitle":"Introduction to GAMA Java API","url":"wiki/Introduction-To-Gama-Java-API#util","content":" Randomness in Gama: msi.gama.util.random GamaRND is the main class that implements Random java class. It has several implementations and is mainly used with RandomUtils that define all the Gaml random operators Graph in Gama: File in Gama: "},{"title":"Operators​","type":1,"pageTitle":"Introduction to GAMA Java API","url":"wiki/Introduction-To-Gama-Java-API#operators-1","content":"The packages where you can find all the operators defined in the core of Gama "},{"title":"Learn GAML Step by Step","type":0,"sectionRef":"#","url":"wiki/LearnGAMLStepByStep","content":"","keywords":""},{"title":"How to proceed to learn better?​","type":1,"pageTitle":"Learn GAML Step by Step","url":"wiki/LearnGAMLStepByStep#how-to-proceed-to-learn-better","content":"As you will progress in the tutorial, you will see several links (written in blue to makes you jump to another part. You can click on them if you want to learn directly about a specific topic, but we do not encourage to do this, because you can get easily lost by reading this tutorial this way. As it is named, we encourage you to follow this tutorial &quot;step by step&quot;. For each chapter, some links are available in the &quot;search&quot; tab, if you want to learn more about this subject. Although, if you really want to learn about a specific topic, our advice is to use the &quot;learning graph&quot; interface, in the website, so that you can choose your area of interest, and a learning path will be automatically designed for you to assimilate the specific concept better. Good luck with your reading, and please do not hesitate to contact us through the mailing list if you have a question/suggestion! "},{"title":"Literals","type":0,"sectionRef":"#","url":"wiki/Literals","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Literals","url":"wiki/Literals#table-of-contents","content":"Literals Simple TypesLiteral ConstructorsUniversal Literal "},{"title":"Simple Types​","type":1,"pageTitle":"Literals","url":"wiki/Literals#simple-types","content":"Values of simple (i.e. not composed) types can all be expressed using literal expressions. Namely: bool: true and false.int: decimal value, such as 100, or hexadecimal value if preceded by '#' (e.g. #AAAAAA, which returns the int 11184810)float: the value in plain digits, using '.' for the decimal point (e.g. 123.297)string: a sequence of characters enclosed between quotes ('my string') or double quotes (&quot;my string&quot;) "},{"title":"Literal Constructors​","type":1,"pageTitle":"Literals","url":"wiki/Literals#literal-constructors","content":"Although they are not strictly literals in the sense given above, some special constructs (called literal constructors) allow the modeler to declare constants of other data types. They are actually operators but can be thought of literals when used with constant operands. pair: the key and the value separated by :: (e.g. 12::'abc')list: the elements, separated by commas, enclosed inside square brackets (e.g. [12,15,15])map: a list of pairs (e.g. [12::'abc', 13::'def'])point: 2 or 3 int or float ordinates enclosed inside curly brackets (e.g. {10.0,10.0,10.0}) "},{"title":"Universal Literal​","type":1,"pageTitle":"Literals","url":"wiki/Literals#universal-literal","content":"Finally, a special literal, of type unknown, is shared between the data types and all the agent types (aka species). Only bool, int and float, which do not derive from unknown, do not accept this literal. All the others will accept it (e.g. string s &lt;- nil; is ok). unknown: nil, which represents the non-initialized (or, literally, unknown) value. "},{"title":"Luneray's flu","type":0,"sectionRef":"#","url":"wiki/LuneraysFlu","content":"","keywords":""},{"title":"Model Overview​","type":1,"pageTitle":"Luneray's flu","url":"wiki/LuneraysFlu#model-overview","content":"The model built in this tutorial concerns the flu spreading in the city of Luneray (Normandie, France).  Two layers of GIS data are used: a road layer (polylines) and a building layer (polygons). In this model, people agents are moving from building to building using the road network. Each infected people can infect their neighbor people. Some data collected concerning Luneray and the disease: Number of inhabitants: 2147 (source: wikipedia)Mean speed of the inhabitants (while moving on the road): 2-5 km/hThe disease - non-lethal - is spreading (by air) from people to peopleTime to cure the disease: more than 100 daysInfection distance: 10 metersInfection probability (when two people are at infection distance) : 0.05/ 5 minutes From the data collected, we made some modeling choice: Simulation step: 5 minutesPeople are moving on the roads from building to building People use the shortest path to move between buildingsAll people move at a constant speedEach time, people arrived at a building they are staying a certain time Infected people are never cured "},{"title":"Step List​","type":1,"pageTitle":"Luneray's flu","url":"wiki/LuneraysFlu#step-list","content":"This tutorial is composed of 5 steps corresponding to 5 models. For each step, we present its purpose, an explicit formulation, and the corresponding GAML code. Creation of a first basic disease spreading modelDefinition of monitors and chart outputsImportation of GIS dataUse of a graph to constraint the movements of peopleDefinition of 3D displaysExploration of the model "},{"title":"2. Definition of monitors and chart outputs","type":0,"sectionRef":"#","url":"wiki/LuneraysFlu_step2","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"2. Definition of monitors and chart outputs","url":"wiki/LuneraysFlu_step2#formulation","content":"Add three new global dynamic variables to follow the evolution of the number of infected people agents, of not infected people agents and of the rate of infected people.Define an ending condition for the simulationDefine a monitor to follow the rate of infected people agentsDefine a chart to follow the rate of infected people agents "},{"title":"Model Definition​","type":1,"pageTitle":"2. Definition of monitors and chart outputs","url":"wiki/LuneraysFlu_step2#model-definition","content":""},{"title":"global section​","type":1,"pageTitle":"2. Definition of monitors and chart outputs","url":"wiki/LuneraysFlu_step2#global-section","content":"global variables​ GAMA offers the possibility to define a dynamic variable that will be recomputed at each simulation step by using the update facet when defining a variable. When an agent is activated, first, it recomputes each of its variables with an update facet (in their definition order), then it activates each of its reflexes (in their definition order). To better follow the evolution of sick people, we add three new global variables to the model: nb_people_infected of type int with nb_infected_init as init value and updated at each simulation step by the number of infected peoplenb_people_not_infected of type int with (nb_people - nb_infected_init) as init value and updated at each simulation step by the number of not infected peopleinfected_rate of type float updated at each simulation step by the number of infected people divided by the number of people. global{ //... other attributes int nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected); int nb_people_not_infected &lt;- nb_people - nb_infected_init update: nb_people - nb_people_infected; float infected_rate update: nb_people_infected/nb_people; //... init }  We used the count operator that allows to count the number of elements of a list for which the left condition is true. The keyword each represents each element of the list. Ending condition​ The simplest way to add an ending condition to a model is to add a global reflex that is activated at the end of the simulation that will pause the simulation (use of the pause global action). In our model, we add a new reflex called end_simulation that will be activated when the infected rate is 1.0 (i.e. all the people agents are infected) and that will apply the pause action. global { //.. variable and init definition reflex end_simulation when: infected_rate = 1.0 { do pause; } }  "},{"title":"experiment​","type":1,"pageTitle":"2. Definition of monitors and chart outputs","url":"wiki/LuneraysFlu_step2#experiment","content":"monitor​ GAMA provides modelers with the possibility to define monitors. A monitor allows to follow the value of an arbitrary expression in GAML. It will appear, in the User Interface, in a small window on its own and be recomputed every time step (or according to its refresh facet). Definition of a monitor: value: mandatory, the expression whose value will be displayed by the monitor.refresh: bool, optional: if the expression is true, compute (default is true). For our model, we define a monitor to follow the value of the infected_rate variable: experiment main_experiment type:gui{ //...parameters output { monitor &quot;Infected people rate&quot; value: infected_rate; //...display } }  Chart​ In GAMA, charts are considered as a display layer. GAMA can display 3 main types of charts using the type facet: histogrampieseries/xy/scatter: both display series with lines or dots, with 3 subtypes : series: to display the evolution of one/several variables (vs time or not).xy: to specify both x and y value. To allow stacked plots, only one y value for each x value.scatter: free x and y values for each series. In our model, we define a new display called chart_display that will be refreshed every 10 simulation steps. In this display, we add a series chart with 2 layers of data: susceptible: the number of people that are not infected (in green)infected: the number of people that are infected (in red) experiment main_experiment type:gui{ //...parameters output { //...display and monitors display chart_display refresh:every(10 #cycles) { chart &quot;Disease spreading&quot; type: series { data &quot;susceptible&quot; value: nb_people_not_infected color: #green; data &quot;infected&quot; value: nb_people_infected color: #red; } } } }  "},{"title":"Complete Model​","type":1,"pageTitle":"2. Definition of monitors and chart outputs","url":"wiki/LuneraysFlu_step2#complete-model","content":"msi.gama.models/models/Tutorials/Luneray%20flu/models/model2.gaml loading... See full example on GitHub Next step: Importation of GIS data "},{"title":"1. Creation of a first basic disease spreading model","type":0,"sectionRef":"#","url":"wiki/LuneraysFlu_step1","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"1. Creation of a first basic disease spreading model","url":"wiki/LuneraysFlu_step1#formulation","content":"Set the time duration of a time step to 5 minutesDefine the people species with a moving skillDefine the move reflex that allows the people agent to move randomly and the infect reflex that allows them to infect other people agents.Define the aspect of the people speciesAdd the people species to a display "},{"title":"Model Definition​","type":1,"pageTitle":"1. Creation of a first basic disease spreading model","url":"wiki/LuneraysFlu_step1#model-definition","content":""},{"title":"Project and model​","type":1,"pageTitle":"1. Creation of a first basic disease spreading model","url":"wiki/LuneraysFlu_step1#project-and-model","content":"The first step of this tutorial consists of launching GAMA and choosing a workspace, then to define a new project or to import the existing one. For people that do not want to re-write all the models but just to follow the model construction, they can just download the model project here and the follow this procedure to import it into GAMA. For the other, the project and model creation procedures are detailed here. Note that the concepts of workspace and projects are explained here. "},{"title":"model structure​","type":1,"pageTitle":"1. Creation of a first basic disease spreading model","url":"wiki/LuneraysFlu_step1#model-structure","content":"A GAMA model is composed of three types of sections: global : this section, that is unique, defines the &quot;world&quot; agent, a special agent of a GAMA model. It represents all that is global to the model: dynamics, variables, actions. In addition, it allows to initialize the simulation (init block).species and grid: these sections define the species of agents composing the model. Grid is defined in the following model step &quot;vegetation dynamic&quot;;experiment : these sections define a context of the execution of the simulations. In particular, it defines the input (parameters) and output (displays, files...) of a model. More details about the different sections of a GAMA model can be found here. "},{"title":"species​","type":1,"pageTitle":"1. Creation of a first basic disease spreading model","url":"wiki/LuneraysFlu_step1#species","content":"A species represents a «prototype» of agents: it defines their common properties. Three different elements can be defined in a species: the internal state of its agents (attributes)their behaviorhow they are displayed (aspects) In our model, we define a people species: species people { }  In addition, we want to add a new capability to our agent: the possibility to move randomly. For that, we add a specific skill to our people agents. A skill is a built-in module that provides the modeler a self-contain and relevant set of actions and variables. The moving provides the agents with several attributes and actions related to movement. species people skills: [moving]{ ... }  Internal state​ An attribute is defined as follows: type of the attribute and name. Numerous types of attributes are available: int (integer), float (floating-point number), string, bool (boolean, true or false), point (coordinates), list, pair, map, file, matrix, agents species, rgb (color), graph, path... Optional facets: &lt;- (initial value), update (value recomputed at each step of the simulation), function:{..} (value computed each time the variable is used), min, max In addition to the attributes the modeler explicitly defines, species &quot;inherits&quot; other attributes called &quot;built-in&quot; variables: A name (name): the identifier of the speciesA shape (shape): the default shape of the agents to be constructed after the species. It can be a point, a polygon, etc.A location (location): the centroid of its shape. In our model, we define 2 new attributes to our people agents: speed of type float, with for initial value: a random value between 2 and 5 km/his_infected of type bool, with for initial value: false species people skills:[moving]{ float speed &lt;- (2 + rnd(3)) #km/#h; bool is_infected &lt;- false; }  Note we use the rnd operator to define a random value between 2 and 5 for the speed. In addition, we precise a unit for the speed value by using the # symbol. For more details about units, see here. Behavior​ GAMA proposes several ways to define the behavior of a species: dynamic variables (update facet), reflexes... A reflex is a block of statements (that can be defined in global or any species) that will be automatically executed at each simulation step if its condition is true, it is defined as follows: reflex reflex_name when: condition {...}  The when facet is optional: when it is omitted, the reflex is activated at each time step. Note that if several reflexes are defined for a species, the reflexes will be activated following their definition order. We define a first reflex called move that is activated at each simulation step (no condition) and that makes the people move randomly using the wander action from the moving skill. species people skills:[moving]{ //variable definition reflex move{ do wander; } }  We define a second reflex called infect that is activated only when the agent is infected (is_infected = true) and that ask all the people at a distance of 10m to test a probability to be infected. species people skills:[moving]{ //variable definition and move reflex reflex infect when: is_infected{ ask people at_distance 10 #m { if flip(0.05) { is_infected &lt;- true; } } } }  The ask allows an agent to ask other agents to do something (i.e. to execute a sequence of statements). The at_distance operator allows to get the list of agents (here of people agents) that are located at a distance lower or equal to the given distance (here 10m). The flip operator allows to test a probability. Display​ An agent aspects have to be defined. An aspect is a way to display the agents of a species: aspect aspect_name {...}In the block of an aspect, it is possible to draw: A geometry: for instance, the shape of the agent (but it may be a different one, for instance, a disk instead of a complex polygon)An image: to draw iconsA text: to draw a text In our model, we define an aspect for the people agent called circle that draw the agents as a circle of 10m radius with a color that depends on their is_infected attribute. If the people agent is infected, it will be drawn in red, in green otherwise. species people { ...//variable and reflex definition aspect circle { draw circle(10) color:is_infected ? #red : #green; } }  The ? structure allows to return a different value (here red or green) according to a condition (here is_infected = true). "},{"title":"global section​","type":1,"pageTitle":"1. Creation of a first basic disease spreading model","url":"wiki/LuneraysFlu_step1#global-section","content":"The global section represents a specific agent, called world. Defining this agent follows the same principle as any agent and is, thus, defined after a species. The world agent represents everything that is global to the model: dynamics, variables... It allows to initialize simulations (init block): the world is always created and initialized first when a simulation is launched (before any other agents). The geometry (shape) of the world agent is by default a square with 100m for side size but can be redefined if necessary. The step attribute of the world agent allows to specify the duration of one simulation step (by default, 1 step = 1 seconde). global variable​ In the current model, we define 4 global attributes: nb_people: the number of people that we want to create (init value: 2147)nb_infected_init: the number of people infected at the initialization of the simulation (init value: 5)step: redefine in order to set the duration of a simulation step to 5 minutes.shape: redefine in order to set the geometry of the world to a square of 1500 meters side size.  global { int nb_people &lt;- 2147; int nb_infected_init &lt;- 5; float step &lt;- 5 #mn; geometry shape&lt;-square(1500 #m); }  Model initialization​ The init section of the global block allows to initialize the define what will happen at the initialization of a simulation, for instance, to create agents. We use the statement create to create agents of a specific species: create species_name + : number: number of agents to create (int, 1 by default)from: GIS file to use to create the agents (optional, string or file)returns: list of created agents (list) For our model, we define the init block in order to create nb_people people agents and ask nb_infected_init of them to be infected: global { // world variable definition init{ create people number:nb_people; ask nb_infected_init among people { is_infected &lt;- true; } } }  "},{"title":"experiment​","type":1,"pageTitle":"1. Creation of a first basic disease spreading model","url":"wiki/LuneraysFlu_step1#experiment","content":"An experiment block defines how a model can be simulated (executed). Several experiments can be defined for a given model. They are defined using : experiment exp_name type: gui/batch {[input] [output]} gui: experiment with a graphical interface, which displays its input parameters and outputs.batch: Allows to setup a series of simulations (w/o graphical interface). In our model, we define a gui experiment called main_experiment : experiment main_experiment type: gui { }  input​ Experiments can define (input) parameters. A parameter definition allows to make the value of a global variable definable by the user through the graphic interface. A parameter is defined as follows: parameter title var: global_var category: cat; title : string to displayvar : reference to a global variable (defined in the global section)category : string used to «store» the operators on the UI - optional&lt;- : init value - optionalmin : min value - optionalmax : min value - optional Note that the init, min and max values can be defined in the global variable definition. In our model, we define one parameter: &quot;Nb people infected at init&quot; that will define the value of the global variable nb_infected_init with a min value of 1 and a max value of 2147 (the number of people living in Luneray). experiment main_experiment type:gui{ parameter &quot;Nb people infected at init&quot; var: nb_infected_init min: 1 max: 2147; output { } }  output​ Output blocks are defined in an experiment and define how to visualize a simulation (with one or more display blocks that define separate windows). Each display can be refreshed independently by defining the facet refresh_every: nb (int) (the display will be refreshed every nb steps of the simulation). Each display can include different layers (like in a GIS): Agents lists : agents layer_name value: agents_list aspect: my_aspect;Agents species : species my_species aspect: my_aspectImages: image layer_name file: image_file;Charts : see later. Note that it is possible to define a opengl display (for 3D display or just to optimize the display) by using the facet type: opengl. output { display map { species people aspect: circle; } }  "},{"title":"Complete Model​","type":1,"pageTitle":"1. Creation of a first basic disease spreading model","url":"wiki/LuneraysFlu_step1#complete-model","content":"msi.gama.models/models/Tutorials/Luneray%20flu/models/model1.gaml loading... See full example on GitHub Next step: Definition of monitors and chart outputs "},{"title":"3. Importation of GIS data","type":0,"sectionRef":"#","url":"wiki/LuneraysFlu_step3","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"3. Importation of GIS data","url":"wiki/LuneraysFlu_step3#formulation","content":"Define 2 new species that will just be displayed: road and building.Define new global attributes to load GIS data (shapefile).Use the GIS data to create the road and building agents.Add the road and building agents to the display. "},{"title":"Model Definition​","type":1,"pageTitle":"3. Importation of GIS data","url":"wiki/LuneraysFlu_step3#model-definition","content":"For this step, you will need to add the shapefiles of the roads and buildings inside the includes folder of the project. The shapefiles (and all the other files) can be found here. "},{"title":"species​","type":1,"pageTitle":"3. Importation of GIS data","url":"wiki/LuneraysFlu_step3#species","content":"In this model, we have to define two species of agents: the road agents and the building ones. These agents will not have a particular behavior, they will just be displayed. For each of these species, we define an aspect called geom. As we want to represent the geometry of the agent, we then use the keyword draw that allows to draw a given geometry. In order to draw the geometry of the agent, we use the attribute shape (which is a built-in attribute of all agents). The road will be displayed in black and the building in gray. species road { aspect geom { draw shape color: #black; } } species building { aspect geom { draw shape color: #gray; } }  "},{"title":"global section​","type":1,"pageTitle":"3. Importation of GIS data","url":"wiki/LuneraysFlu_step3#global-section","content":"global variables​ GAMA allows to automatically read GIS data that are formatted as shapefiles (or as OSM file). In our model, we define 2 shapefiles: one corresponding to the roads and the other ones to the buildings. Note that GAMA is able to manage the projection of the GIS data. In order to set the right size (and position) of the world geometry, we define its value as the envelope of the road shapefile (and no more a square of 1500 meters). global { //... other attributes file roads_shapefile &lt;- file(&quot;../includes/routes.shp&quot;); file buildings_shapefile &lt;- file(&quot;../includes/batiments.shp&quot;); geometry shape &lt;- envelope(roads_shapefile); //... init }  "},{"title":"Agentification of GIS data​","type":1,"pageTitle":"3. Importation of GIS data","url":"wiki/LuneraysFlu_step3#agentification-of-gis-data","content":"In GAMA, the agentification of GIS data is very straightforward: it only requires to use the create command with the from facet to pass the shapefile. Each object of the shapefile will be directly used to instantiate an agent of the specified species. The reading of an attribute in a shapefile is also very simple. It only requires to use the with facet: the argument of this facet is a dictionary of which the keys are the names of the agent attributes and the value the read command followed by the name of the shapefile attribute. In our model, we modify the init section in order to first create the road agents from the road shapefile, and the building agents from the building shapefile. Then, when creating people agents, we choose for them a random location inside a random building. Note that it is possible to execute a sequence of statements at the creation of agents by using a block ({...}) rather than a simple line (;) when using the create statement. global { // world variable definition init{ create road from: roads_shapefile; create building from: buildings_shapefile; create people number:nb_people { location &lt;- any_location_in(one_of(building)); } ask nb_infected_init among people { is_infected &lt;- true; } } }  We used here the one_of operator that returns a random element from a list and the any_location_in operator that returns a random location inside a geometry. "},{"title":"experiment​","type":1,"pageTitle":"3. Importation of GIS data","url":"wiki/LuneraysFlu_step3#experiment","content":"Output​ In the map display, we add the road and building species with their geom aspect just before the people species (in order to draw the people agents on the top of the roads and buildings). experiment main_experiment type: gui { ... //parameter definition output { ... //monitor definition display map type: opengl{ species road aspect: geom; species building aspect: geom; species people aspect: circle; } ... //chart display definition } }  "},{"title":"Complete Model​","type":1,"pageTitle":"3. Importation of GIS data","url":"wiki/LuneraysFlu_step3#complete-model","content":"msi.gama.models/models/Tutorials/Luneray%20flu/models/model3.gaml loading... See full example on GitHub Next step: Use of a graph to constraint the movements of people "},{"title":"4. Use of a graph to constraint the movements of people","type":0,"sectionRef":"#","url":"wiki/LuneraysFlu_step4","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"4. Use of a graph to constraint the movements of people","url":"wiki/LuneraysFlu_step4#formulation","content":"Define a new global variable: the road network (graph).Build the road network graph from the road agentsAdd new attribute to the people agents (target)Define a new reflex for people agents: stay.Modify the move reflex of the people agents. "},{"title":"Model Definition​","type":1,"pageTitle":"4. Use of a graph to constraint the movements of people","url":"wiki/LuneraysFlu_step4#model-definition","content":""},{"title":"global section​","type":1,"pageTitle":"4. Use of a graph to constraint the movements of people","url":"wiki/LuneraysFlu_step4#global-section","content":"global variables​ In this model, we want people agents to move from buildings to buildings by using the shortest path in the road network. In order to compute this shortest path, we need to use a graph structure. We thus define a new global variable called road_network of type graph that will represent the road network. global{ //... other attributes graph road_network; //... init }  In order to compute the graph from the road network, we use, just after having created the road agents, the as_edge_graph operator. This operator automatically built a graph from a set of polylines. Each extremity point of the lines will become a node in the graph, and each polyline an edge. By default, the graph is not oriented and the weights of the edges are the perimeters of the polylines. It is of course possible to change through the use of some operators. global { // world variable definition init{ create road from: roads_shapefile; road_network &lt;- as_edge_graph(road); create building from: buildings_shapefile; create people number:nb_people { location &lt;- any_location_in(one_of(building)); } ask nb_infected_init among people { is_infected &lt;- true; } } }  "},{"title":"people species​","type":1,"pageTitle":"4. Use of a graph to constraint the movements of people","url":"wiki/LuneraysFlu_step4#people-species","content":"We want to modify the behavior of the people agents in order to make them move from buildings to buildings by using the shortest path in the road network. Variables​ In order to implement this behavior, we will add two variables to our people species: target of type point that will be the location where the agent wants to go species people skills:[moving]{ //...the other attributes point target; //.... }  Behavior​ First, we add a new reflex called stay that will be activated when the agent is in a house (i.e. its target is null) and that will define with a probability of 0.05 if the agent has to go or not. If the agent has to go, it will randomly choose a new target (a random location inside one of the building). reflex stay when: target = nil { if flip(0.05) { target &lt;- any_location_in (one_of(building)); } }  Then, we modify the move reflex. This one will be only activated when the agent will have to move (target not null). Instead of using the wander action of the moving skill, we use the goto one that allows to make an agent moves toward a given target. In addition, it is possible to add a facet on to precise on which topology the agent will have to move on. In our case, the topology is the road network. When the agent reaches its destination (location = target), it sets its target to null. reflex move when: target != nil{ do goto target: target on: road_network; if (location = target) { target &lt;- nil; } }  "},{"title":"Complete Model​","type":1,"pageTitle":"4. Use of a graph to constraint the movements of people","url":"wiki/LuneraysFlu_step4#complete-model","content":"msi.gama.models/models/Tutorials/Luneray%20flu/models/model4.gaml loading... See full example on GitHub Next step: Definition of 3D displays "},{"title":"5. Definition of 3D displays","type":0,"sectionRef":"#","url":"wiki/LuneraysFlu_step5","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"5. Definition of 3D displays","url":"wiki/LuneraysFlu_step5#formulation","content":"Define a new 3D aspect for roads.Define a new 3D aspect for buildingsDefine a new 3D aspect for peopleDefine a new 3D display  "},{"title":"Model Definition​","type":1,"pageTitle":"5. Definition of 3D displays","url":"wiki/LuneraysFlu_step5#model-definition","content":""},{"title":"species​","type":1,"pageTitle":"5. Definition of 3D displays","url":"wiki/LuneraysFlu_step5#species","content":"We define a new aspect for the road species called geom3D that draw the road agent that as a black tube of 2m radius built from its geometry. Note that it is possible to get the list of points composing a geometry by using the points variable of the geometry.  species road { //.... aspect geom3D { draw line(shape.points, 2.0) color: #black; } }  Concerning the building species, we define an aspect called geom3D that draws the shape of the building with a depth of 20 meters and with using a texture &quot;texture.jpg&quot; for the face and a texture for the roof &quot;roof_top.jpg&quot;.  species building { //.... aspect geom3D { draw shape depth: 20 #m border: #black texture: [&quot;../includes/roof_top.jpg&quot;,&quot;../includes/texture.jpg&quot;]; } }  At last, we define a new aspect called geom3D for the people species that displays the agent only if it is on a road (target != nil). In this aspect, we use an obj file that contains a 3D object. The use of the obj_file operator allows to apply an initial rotation to an obj file. In our case, we add a rotation of -90° along the x-axis. We specify with the size facet that we want to draw the 3D object inside a bounding box of 5m. As the location of the 3D object is its centroid and as we want to draw the 3D object on the top of the ground, we use the at facet to put an offset along the z-axis. We use also the rotate facet to change the orientation of the 3D object according to the heading of the agent. At last, we choose to draw the 3D object in green if the agent is not infected; in red otherwise.  species people skills:[moving]{ //.... aspect geom3D { if target != nil { draw obj_file(&quot;../includes/people.obj&quot;, 90::{-1,0,0}) size: 5 at: location + {0,0,7} rotate: heading - 90 color: is_infected ? #red : #green; } } }  "},{"title":"output​","type":1,"pageTitle":"5. Definition of 3D displays","url":"wiki/LuneraysFlu_step5#output","content":"We define a new display called view3D of type opengl with the facet antialias set to false. Inside this display, we first set a light of type ambient and with an intensity of 80. We then draw a background image representing the satellite image of the Luneray. Note that GAMA is able to manage world files to georeferenced images. In our case, as a PGW file exists in the includes folder, the satellite image will be well localized in the display. After drawing the background image, we display first the building species with their geom3D aspect, then the road species with their geom3D aspect and finally the people species with their geom3D aspect. Only the people agents will be redrawn at each simulation step. experiment main_experiment type: gui { output { // monitor and other displays display view3D type: opengl antialias: false { light #ambient intensity: 80; image &quot;../includes/luneray.jpg&quot; refresh: false; species building aspect: geom3D refresh: false; species road aspect: geom3D refresh: false; species people aspect: geom3D; } } }  "},{"title":"Complete Model​","type":1,"pageTitle":"5. Definition of 3D displays","url":"wiki/LuneraysFlu_step5#complete-model","content":"msi.gama.models/models/Tutorials/Luneray%20flu/models/model5.gaml loading... See full example on GitHub Next step: Exploration of the model "},{"title":"6. Exploration of the model","type":0,"sectionRef":"#","url":"wiki/LuneraysFlu_step6","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"6. Exploration of the model","url":"wiki/LuneraysFlu_step6#formulation","content":"Add an experiment to launch 10 simulations to analyze the sensitivity toward stochasticity.Add an experiment to explore the impact of the proba_leave parameter.Add an experiment to calibrate the model. These 3 additions will add each a new experiment of type batch, more details about batch experiment on this page. "},{"title":"Model Definition​","type":1,"pageTitle":"6. Exploration of the model","url":"wiki/LuneraysFlu_step6#model-definition","content":""},{"title":"Sensitivity analysis toward stochasticity​","type":1,"pageTitle":"6. Exploration of the model","url":"wiki/LuneraysFlu_step6#sensitivity-analysis-toward-stochasticity","content":"The aim is to run many simulations with the default values for parameters to analyze the impact of stochasticity over the simulation results. We choose as indicator to compare the simulations the infected_rate value after 2hours of simulations. We will launch 10 simulations and display the mean and standard deviation values of this variable over the 10 simulations. To this purpose we need to define a new experiment with the following facet values: type: the type of the experiment, here we choose the batch mode to be able to launch many simulations in one launch.until: the stop condition in the batch experiment, here time &gt; 2#h.repeat: the number of simulations to run with the same parameter values (number of replications), here 10. experiment test_robustness type: batch until: time &gt; 2#h repeat: 10 { reflex information { list&amp;lt;float&gt; vals &lt;- simulations collect each.infected_rate; write &quot;mean: &quot; + mean(vals) + &quot; standard deviation: &quot; + standard_deviation(vals); } }  Experiments are also a kind of species. They can thus have variables and behaviors. Here we use the simulations variable that is the list of the 10 simulations (for the 10 replications). In addition, in batch mode, a reflex is executed at the end of all the replication simulations. We can thus create the list of all the infected_rate values (with the collect operator) and compute the mean and standard_deviation. "},{"title":"Exploration​","type":1,"pageTitle":"6. Exploration of the model","url":"wiki/LuneraysFlu_step6#exploration","content":"The aim here is to explore the impact of one parameter over the simulations' results. We keep the same indicator. We add the parameter to explore the experiment and specify the possibility it can take with either the among facet or the combination of min, max, and step facets. experiment explore_model type: batch until: time &gt; 2#h repeat: 2 { parameter &quot;proba_leave&quot; var: proba_leave among: [0, 0.01, 0.05, 0.1, 1.0]; reflex save_results { ask simulations { write &quot;proba_leave: &quot; + proba_leave + &quot; infected_rate: &quot; + self.infected_rate; save [proba_leave, self.infected_rate] type: csv to:&quot;results.csv&quot; rewrite: (int(self) = 0) ? true : false header: true ; } } }  In order to do a deeper investigation, in particular with an external tool, it could be useful to save the values in a file. For this purpose, we use the save statement. In our example, we save a list of values in the csv file (type: csv) specified in the to facet. "},{"title":"Calibration​","type":1,"pageTitle":"6. Exploration of the model","url":"wiki/LuneraysFlu_step6#calibration","content":"The calibration process corresponds to the search of parameter values that maximize/minimize indicators. To this purpose, we need to define: the parameters to explore, with their possible values,the indicator to minimize/maximize,the exploration method. Here we choose to minimize the value abs(infected_rate - 0.5) (i.e. we want to find parameters' value that makes the simulation having an infected_rate as close as possible to 0.5) after 2hours of simulation. The chosen optimization method is a genetic algorithm (more details on this page). experiment calibration_model type: batch until: time &gt; 2#h repeat: 3 { parameter &quot;infection distance&quot; var: infection_distance min: 1.0 max: 20.0 step: 1; parameter &quot;proba infection&quot; var: proba_infection min: 0.01 max: 1.0 step: 0.01; method genetic pop_dim: 3 max_gen: 5 minimize: abs(infected_rate - 0.5); }  "},{"title":"Complete Model​","type":1,"pageTitle":"6. Exploration of the model","url":"wiki/LuneraysFlu_step6#complete-model","content":"msi.gama.models/models/Tutorials/Luneray%20flu/models/model6.gaml loading... See full example on GitHub "},{"title":"Manipulate basic species","type":0,"sectionRef":"#","url":"wiki/ManipulateBasicSpecies","content":"Manipulate basic species In this chapter, we will learn how to manipulate some basic species. As you already know, a species can be seen as the definition of a type of agent (we call agent the instance of a species). In OOP (Object-Oriented Programming), a species can be seen as the class. Each species is then defined by some attributes (&quot;member&quot; in OOP), actions (&quot;method&quot; in OOP) and behavior (&quot;method&quot; in OOP). In this section, we will first learn how to declare the world agent, using the global species. We will then learn how to declare regular species which will populate our world. The following lesson will be dedicated to learn how to define actions and behaviors for all those species. We will then learn how agents can interact between each other, especially with the statement ask. In the next chapter then, we will see how to attach skills to our species, giving them new attributes and actions. This section will be closed with a last lesson dealing with how inheritance works in GAML.","keywords":""},{"title":"Implementing light","type":0,"sectionRef":"#","url":"wiki/ManipulateLight","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"Implementing light","url":"wiki/ManipulateLight#index","content":"Light generalitiesDefault lightCustom lights "},{"title":"Light generalities​","type":1,"pageTitle":"Implementing light","url":"wiki/ManipulateLight#light-generalities","content":"Before going deep into the code, here is a quick explanation about how light works in OpenGL. First of all, you need to know that there are 3 types of lights you can manipulate: the ambient light, the diffuse light and the specular light. Each &quot;light&quot; in OpenGL is in fact composed of those 3 types of lights. "},{"title":"Ambient light​","type":1,"pageTitle":"Implementing light","url":"wiki/ManipulateLight#ambient-light","content":"The ambient light is the light of your world without any lighting. If a face of a cube is not stricken by the light rays, for instance, this face will appear totally black if there is no ambient light. To make your world more realistic, it is better to have ambient light. Ambient light has then no position or direction. It is equally distributed to all the objects of your scene. Here is an example of our GAML scene using only ambient light (color red) (see below how to define ambient light in GAML):  "},{"title":"Diffuse light​","type":1,"pageTitle":"Implementing light","url":"wiki/ManipulateLight#diffuse-light","content":"The diffuse light can be seen as the light rays: if a face of a cube is stricken by the diffuse light, it will take the color of this diffuse light. You have to know that the more perpendicular the face of your object will be to the light ray, the more lightened the face will be. A diffuse light has then a direction. It can have also a position. You have 2 categories of diffuse light: the positional lights, and the directional lights. Positional lights​ Those lights have a position in your world. It is the case of point lights and spot lights. Point lights Points lights can be seen as a candle in your world, diffusing the light equally in all the direction. Here is an example of our GAML scene using only diffuse light, with a point light (color red, the light source is displayed as a red sphere) :  Spot lights Spot lights can be seen as a torch light in your world. It needs a position, and also a direction and an angle. Here is an example of our GAML scene using only diffusion light, with a spot light (color red, the light source is displayed as a red cone) :  Positional lights, as they have a position, can also have an attenuation according to the distance between the light source and the object. The value of positional lights are computed with the following formula: diffuse_light = diffuse_light * ( 1 / (1 + constante_attenuation + linear_attenuation * d + quadratic_attenuation * d))  By changing those 3 values (constante_attenuation, linear_attenuation and quadratic_attenuation), you can control the way light is diffused over your world (if your world is &quot;foggy&quot; for instance, you may turn your linear and quadratic attenuation on). Note that by default, all those attenuations are equal to 0. Here is an example of our GAML scene using only diffusion light, with a point light with linear attenuation (color red, the light source is displayed as a red sphere):  Directional lights​ Directional lights have no real &quot;position&quot;: they only have a direction. A directional light will strike all the objects of your world in the same direction. An example of directional light you have in the real world would be the light of the sun: the sun is so far away from us that you can consider that the rays have the same direction and the same intensity wherever they strike. Since there is no position for directional lights, there is no attenuation either. Here is an example of our GAML scene using only diffusion light, with a directional light (color red) :  "},{"title":"Specular light​","type":1,"pageTitle":"Implementing light","url":"wiki/ManipulateLight#specular-light","content":"This is a more advanced concept, giving an aspect a little bit &quot;shinny&quot; to the objects stricken by the specular light. It is used to simulate the interaction between the light and a special material (ex: wood, steel, rubber...). This specular light is not implemented yet in GAMA, only the two others are. "},{"title":"Default light​","type":1,"pageTitle":"Implementing light","url":"wiki/ManipulateLight#default-light","content":"In your OpenGL display, without specifying any light, you will have only one light, with those following properties : Those values have been chosen in order to have the same visual effect in both OpenGL and java2D displays, when you display 2D objects, and also to have a nice &quot;3D effect&quot; when using the OpenGL displays. We chose the following setting by default: The ambient light value: rgb(127,127,127,255)diffuse light value: rgb(127,127,127,255)type of light: directiondirection of the light: (0.5,0.5,-1); Here is an example of our GAML scene using the default light:  "},{"title":"Custom lights​","type":1,"pageTitle":"Implementing light","url":"wiki/ManipulateLight#custom-lights","content":"In your OpenGL display, you can create several lights, giving them the properties you want. In order to add lights, or modifying the existing lights, you have to use the statement light inside your display scope: experiment my_experiment type:gui { output { display &quot;my_display&quot; type:opengl { light &quot;my_light&quot;; } } }  A name has to be declared for the light. Through this facet, you can specify which light you want. Once you are manipulating a light through the light statement, the light is turned on. To switch off the light, you have to add the facet active, and turn it to false. The light you are declaring through the light statement is, in fact, a &quot;diffuse&quot; light. You can specify the color of the diffuse light through the facet intensity (by default, the color will be turned to white). Another very important facet is the type facet. This facet accepts a value among #direction, #point and #spot. "},{"title":"Ambient light​","type":1,"pageTitle":"Implementing light","url":"wiki/ManipulateLight#ambient-light-1","content":"The ambient light can be set when declaring a light, using the #ambient constant, through the facet intensity: experiment my_experiment type: gui { output { display &quot;my_display&quot; type: opengl { light #ambient intensity: 100; } } }  Note for developers: Note that this ambient light is set to the GL_LIGHT0. This GL_LIGHT0 only contains an ambient light, and no either diffuse nor specular light. Declaring direction light​ A direction light, as explained in the first part, is a light without any position. Instead of the facet position, you will use the facet direction, giving a 3D vector. Example of implementation: light &quot;my_direction_light&quot; type: #direction direction: {1,1,1} intensity: #red;  Declaring point light​ A point light will need a facet position, in order to give the position of the light source. Example of implementation of a basic point light: light &quot;my_point_light&quot; type: #point location: {10,20,10} intensity: #red;  You can add, if you want, a custom attenuation of the light, through the facets linear_attenuation or quadratic_attenuation. Example of implementation of a point light with attenuation : light &quot;my_point_light&quot; type: #point location: {10,20,10} intensity: #red linear_attenuation: 0.1;  Declaring spot light​ A spot light will need the facet position (a spot light is a positional light) and the facet direction. A spot light will also need a special facet spot_angle to determine the angle of the spot (by default, this value is set to 45 degree). Example of implementation of a basic spot light: light &quot;my_spot_light&quot; type: #spot location: {0,0,100}direction:{0.5,0.5,-1} intensity: #red angle: 20;  Same as for point light, you can specify an attenuation for a spot light. Example of implementation of a spot light with attenuation: light &quot;my_spot_light&quot; type:#spot location:{0,0,100} direction:{0.5,0.5,-1} intensity:#red angle:30 linear_attenuation: 0.1;  Note that when you are working with lights, you can display your lights through the facet show (of light) to help you to implement your model. The three types of lights are displayed differently: The point light is represented by a sphere with the color of the diffuse light you specified, in the position of your light source.The spot light is represented by a cone with the color of the diffuse light you specified, in the position of your light source, the orientation of your light source. The size of the base of the cone will depend on the angle you specified.The direction light, as it has no real position, is represented with arrows a bit above the world, with the direction of your direction light, and the color of the diffuse light you specified.  Note for developers: Note that, since the GL_LIGHT0 is already reserved for the ambient light (only !), all the other lights (from 1 to 7) are the lights from GL_LIGHT1 to GL_LIGHT7. "},{"title":"Manipulate Dates","type":0,"sectionRef":"#","url":"wiki/ManipulateDates","content":"","keywords":""},{"title":"Managing Time in Models​","type":1,"pageTitle":"Manipulate Dates","url":"wiki/ManipulateDates#managing-time-in-models","content":"If some models are based on an abstract time - only the number of cycles is important - others are based on a real time. To this purpose, GAMA provides some tools to manage time. First, GAMA allows the modeler to define the duration of a simulation step. It provides access to different time variables. At last, since GAMA 1.7, it provides a date variable type and some global variables allowing to use a real calendar to manage time. "},{"title":"Definition of the step and use of temporal unity values​","type":1,"pageTitle":"Manipulate Dates","url":"wiki/ManipulateDates#definition-of-the-step-and-use-of-temporal-unity-values","content":"GAMA provides three important global variables to manage time: cycle (int - not modifiable): the current simulation step - this variable is incremented by 1 at each simulation stepstep (float - can be modified): the duration of a simulation step (in seconds). By default, the duration is one second.time (float - not modifiable): the current time spent since the beginning of the simulation - this variable is computed at each simulation step by: time = cycle * step.  The value of the cycle and time variables are shown in the top left (green rectangle) of the simulation interface. Clicking on the green rectangle allows to display either the number cycles or the time variable. Concerning this variable, it is presented following a years - months - days - hours - minutes - seconds format. In this presentation, every month is considered as being composed of 30 days (the different number of days of months are not taken into account). Concerning step global variable, the variable can be modified by the modeler. A classic way of doing it consists of reediting the variable in the global section: global { float step &lt;- 1 #hour; }  In this example, each simulation step will represent 1 hour. This time will be taken into account for all actions based on time (e.g. moving actions). Note that the value of the step variable should be given in seconds. To facilitate the definition of the step value and of all expressions based on time, GAMA provides different built-in constant variables accessible with the &quot;#&quot; symbol: #s : second - 1 second#mn : minute - 60 seconds#hour : hour - 60 minutes - 3600 seconds#day : day - 24 hours - 86400 seconds#week: week - 7 days - 604800 seconds#month : month - 30 days - 2592000 seconds#year : year - 12 month - 3.1104E7 seconds "},{"title":"The date variable type and the use of a real calendar​","type":1,"pageTitle":"Manipulate Dates","url":"wiki/ManipulateDates#the-date-variable-type-and-the-use-of-a-real-calendar","content":"Since GAMA 1.7, it is possible to use a real calendar to manage the time. For that, the modeler has only to define the starting date of the simulation. This variable is of type date which allows him/her to represent a date and time. A date variable has several attributes: year (int): the year component of the datemonth (int): the month component of the dateday (int): the day component of the datehour (int): the hour component of the dateminute (int): the minute component of the datesecond (int): the second component of the dateday_of_week (int): the day of the weekweek_of_year (int): the week of the year Several ways can be used to define a date. The simplest one consists in using a list of int values: [year,month of the year,day of the month, hour of the day, minute of the hour, second of the minute] date my_date &lt;- date([2010,3,23,17,30,10]); // the 23th of March 2010, at 17:30:10  Another way consists in using a string with the good format. The following one is perhaps the most complete, with year, month, day, hour, minute, second and also the time zone. date my_date &lt;- date(&quot;2010-3-23T17:30:10+07:00&quot;);  But the following ones can also be used: // without time zone: my_date3 &lt;- date(&quot;2010-03-23 17:30:10&quot;); //Dates (without time) my_date3 &lt;- date(&quot;20100323&quot;); my_date3 &lt;- date(&quot;2010-03-23&quot;); // Dates using some patterns: my_date3 &lt;- date(&quot;03 23 2010&quot;,&quot;MM dd yyyy&quot;); my_date3 &lt;- date(&quot;01 23 20&quot;,&quot;HH mm ss&quot;);  Note that the current (real) date can be accessed through the #now built-in variable (variable of type date). In addition, GAMA provides different useful operators working on dates. For instance, it is possible to compute the duration in seconds between 2 dates using the &quot;-&quot; operator. The result is given in seconds: float d &lt;- starting_date - my_date;  It is also possible to add or subtract a duration (in seconds) to a date: write &quot;my_date + 10: &quot; + (my_date + 10); write &quot;my_date - 10: &quot; + (my_date - 10);  At last, it is possible to add or subtract a duration (in years, months, weeks, days, hours, minutes, seconds) to a date: write &quot;my_date add_years 1: &quot; + (my_date add_years 1); write &quot;my_date add_months 1: &quot; + (my_date add_months 1); write &quot;my_date add_weeks 1: &quot; + (my_date add_weeks 1); write &quot;my_date add_days 1: &quot; + (my_date add_days 1); write &quot;my_date add_hours 1: &quot; + (my_date add_hours 1); write &quot;my_date add_minutes 1: &quot; + (my_date add_minutes 1); write &quot;my_date add_seconds 1: &quot; + (my_date add_seconds 1); write &quot;my_date subtract_years 1: &quot; + (my_date subtract_years 1); write &quot;my_date subtract_months 1: &quot; + (my_date subtract_months 1); write &quot;my_date subtract_weeks 1: &quot; + (my_date subtract_weeks 1); write &quot;my_date subtract_days 1: &quot; + (my_date subtract_days 1); write &quot;my_date subtract_hours 1: &quot; + (my_date subtract_hours 1); write &quot;my_date subtract_minutes 1: &quot; + (my_date subtract_minutes 1); write &quot;my_date subtract_seconds 1: &quot; + (my_date subtract_seconds 1);  "},{"title":"Date variables in the model​","type":1,"pageTitle":"Manipulate Dates","url":"wiki/ManipulateDates#date-variables-in-the-model","content":"For the modelers, two global date variables are available: starting_date: date considered as the beginning of the simulation (by default the starting date is 1970-01-01 07:00:00.current_date: current date of the simulation. Defining a value of the starting_date allows to change the normal time management of the simulation by a more realistic one (using a calendar): global { date starting_date &lt;- date([1979,12,17,19,45,10]); }  When a value is set to this variable, the current_date variable is automatically initialized with the same value. However, at each simulation step, the current_date variable is incremented by the step variable. The value of the current_date will replace the value of the time variable in the top left green panel. Note that you have to be careful when a real calendar is used, the built-in constants #month and #year should not be used as there are not consistent with the calendar (where month can be composed of 28, 29, 30 or 31 days). "},{"title":"Manipulate OSM Datas","type":0,"sectionRef":"#","url":"wiki/ManipulateOSMDatas","content":"Manipulate OSM Datas This section will be presented as a quick tutorial, showing how to proceed to manipulate OSM (Open street map) data, clean them and load them into GAMA. We will use the software QGIS to change the attributes of the OSM file. Note that GAMA can read and import OpenStreetMap data natively and create agents from them. An example model is provided in the Model Library (Data Importation / OSM File Import.gaml). In this case, you will have to write a model to import, select data from OpenStreetMap before creating agents and then could export them into shapefiles, much easier to use in GAMA. From the website openstreetmap.org, we will choose a place (in this example, we will take a neighborhood in New York City). Directly from the website, you can export the chosen area in the osm format. We have now to manipulate the attributes for the exported osm file. Several softwares can be used, but we will focus on QGIS, which is totally free and provides a lot of possibilities in term of manipulation of data. Once you have installed correctly QGIS, launch QGIS Desktop, and start to import the topology from the osm file. A message indicates that the import was successful. An output file .osm.db is created. You have now to export the topology to SpatiaLite. Specify the path for your DataBase file, then choose the export type (in your case, we will choose the type &quot;Polygons (closed ways)&quot;), choose an output layer name. If you want to use the open street maps attributes values, click on &quot;Load from DB&quot;, and select the attributes you want to keep. Click OK then. A message indicates that the export was successful, and you have now a new layer created. We will now manipulate the attributes of your datafile. Right-click on the layer, and select &quot;Open Attribute Table&quot;. The table of attribute appears. Select the little pencil on the top-left corner of the window to modify the table. We will add an attribute manually. Click on the button &quot;new column&quot;, choose a name and a type (we will choose the type &quot;text&quot;). A new column appears at the end of the table. Let's fill some values (for instance blue/red). Once you finish, click on the &quot;save edit&quot; button. Our file is now ready to be exported. Right-click on the layer, and click on &quot;Save As&quot;. Choose &quot;shapefile&quot; as format, choose a save path and click ok. Copy passed all the .shp created in the include folder of your GAMA project. You are now ready to write the model. model HowToUseOpenStreetMap global { // Global variables related to the Management units file shapeFile &lt;- file('../includes/new_york.shp'); //definition of the environment size from the shapefile. //Note that is possible to define it from several files by using: geometry shape &lt;- envelope(envelope(file1) + envelope(file2) + ...); geometry shape &lt;- envelope(shapeFile); init { //Creation of elementOfNewYork agents from the shapefile (and reading some of the shapefile attributes) create elementOfNewYork from: shapeFile with: [elementId::int(read('id')), elementHeight::int(read('height')), elementColor::string(read('attrForGama'))] ; } } species elementOfNewYork{ int elementId; int elementHeight; string elementColor; aspect basic{ draw shape color: (elementColor = &quot;blue&quot;) ? #blue : ( (elementColor = &quot;red&quot;) ? #red : #yellow ) depth: elementHeight; } } experiment main type: gui { output { display HowToUseOpenStreetMap type:opengl { species elementOfNewYork aspect: basic; } } } Here is the result, with a special colorization of the different elements regarding the value of the attribute &quot;attrForGama&quot;, and an elevation regarding the value of the attribute &quot;height&quot;.","keywords":""},{"title":"Controls of experiments","type":0,"sectionRef":"#","url":"wiki/MenusAndCommands","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Controls of experiments","url":"wiki/MenusAndCommands#table-of-contents","content":"Controls of experiments Experiment MenuAgents MenuGeneral Toolbar "},{"title":"Experiment Menu​","type":1,"pageTitle":"Controls of experiments","url":"wiki/MenusAndCommands#experiment-menu","content":"A menu, called &quot;Experiment&quot;, allows controlling the current experiment. It shares some of its commands with the general toolbar (see below).  Run/Pause Experiment: allows to run or pause the experiment depending on its current state.Step Experiment: runs the experiment for one cycle and pauses it after.Reload Experiment: stops the current experiment, deletes its contents and reloads it, taking into account the parameters values that might have been changed by the user.Stop at first error: if checked, the current experiment will stop running when an error is issued. The default value can be configured in the preferences.Treat warnings like errors: if checked, a warning will be considered as an error (and if the previous item is checked, will stop the experiment). The default value can be configured in the preferences.Display errors and warning: if checked, displays the errors and warnings issued by the experiment. If not, do not display them. The default value can be configured in the preferences.Close Experiment: forces the experiment to stop, whatever it is currently doing, purges the memory from it, and switches to the modeling perspective. Use this command with caution, as it can have undesirable effects depending on the state of the experiment (for example, if it is reading files, or outputting data, etc.). "},{"title":"Agents Menu​","type":1,"pageTitle":"Controls of experiments","url":"wiki/MenusAndCommands#agents-menu","content":"A second menu is added in the simulation perspective: &quot;Agents&quot;. This menu allows for easy access to the different agents that populate an experiment.  This hierarchical menu is always organized in the same way, whatever the experiment being run. A first level is dedicated to the current top-level experiment agent: it allows the modeler to inspect the agent itself and to browse its population(s) (i.e. the simulation agents). A second level lists the &quot;micro-populations&quot; present in each simulation agent and allows to inspect the agent itself. And the third level will give access to an overview of all the agents of the population in a table (&quot;Browse ant population...&quot;) and to each individual agent in these populations. This organization is, of course, recursive: if these agents are themselves, hosts of micro-populations, they will be displayed in their individual menu. Each agent, when selected, will reveal a similar individual menu. This menu will contain a set of predefined actions, the commands defined by the user for this species if any, and then the micro-populations hosted by this agent, if any. Agents (like the instances of &quot;ant&quot; below) that do not host other agents and whose species has no user commands will have a &quot;simple&quot; individual menu.  These are the 4 actions that will be there most of the time: Inspect: open an inspector on this agent.Focus on all displays: this option is not accessible if no displays are defined. Makes all the displays zoom on the selected agent (if it is displayed) so that it occupies the whole view.Highlight: makes this agent the current &quot;highlighted&quot; agent, forcing it to appear &quot;highlighted&quot; in all the displays that might have been defined.Kill: destroys the selected agent and disposes of it. Use this command with caution, as it can have undesirable effects if the agent is currently executing its behavior. If an agent hosts other agents (it is the case in multi-level architecture), you can access to the micro-population quite easily (e.g. in the model Library models/Modeling/Multi-Level Usage/Corridor.gaml):  If user commands are defined for a species (for example in the existing model Library models/Visualization and User Interaction/User Interaction/User Command.gaml), their individuals' menu will look like the following. Notice that in this model two species have user command: the simulation agent (2 user commands are defined in the global section of the model),the ants agents (2 user commands defined in the species definition section).  "},{"title":"General Toolbar​","type":1,"pageTitle":"Controls of experiments","url":"wiki/MenusAndCommands#general-toolbar","content":"The last piece of user interface specific to the Simulation Perspective is a toolbar, which contains controls and information displays related to the current experiment. This toolbar is voluntarily minimalist, with four buttons already present in the experiment menu (namely, &quot;Play/Pause Experiment&quot;, &quot;Step Experiment&quot;, &quot;Reload Experiment&quot; and &quot;Close Experiment&quot;), which do not need to be detailed here, and two new controls (&quot;Experiment status&quot; and &quot;Cycle Delay&quot;), which are explained below.  While opening an experiment, the status will display some information about what's going on. For instance, GAMA is busy instantiating the agents or opening the displays.   The orange color usually means that, although the experiment is not ready, things are progressing without problems (a red color message is an indication that something went wrong). When the loading of the experiment is finished, GAMA displays the message &quot;Simulation ready&quot; on a green background. If the user runs the simulation, the status changes and displays the number of cycles already elapsed in the simulation currently managed by the experiment.  Hovering over the status produces more accurate information about the internal clock of the simulation.  When we launch an experiment, an experiment agent is created with its own internal clock. It will then create 1 (or more) simulation agent(s). The toolbar provides thus information about both the experiment agent and the simulation(s), from top to bottom: the number of cycles elapsed,the simulated time already elapsed (in the example above, one cycle lasts one second of simulated time) for the simulation agents only, the duration of cycle in milliseconds, the average duration of one cycle (computed over the number of cycles elapsed),the total duration, so far, of the simulation (still in milliseconds). In the case of a multi-simulation (i.e. an experiment launching several simulations), one block per simulation is displayed.  Although these durations are entirely dependent on the speed of the simulation engine (and, of course, the number of agents, their behaviors, etc.), there is a way to control it partially with the second control, which allows the user to force a minimal duration (in milliseconds) for a cycle, from 0s (its initial position) to 1s. Note that this minimal duration (or delay) will remain the same for the subsequent reloads of the experiment.  In case it is necessary to have more than 1s of delay, it has to be defined, instead, as an attribute of the experiment. "},{"title":"Mirror species","type":0,"sectionRef":"#","url":"wiki/MirrorSpecies","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"Mirror species","url":"wiki/MirrorSpecies#index","content":"DeclarationExample "},{"title":"Declaration​","type":1,"pageTitle":"Mirror species","url":"wiki/MirrorSpecies#declaration","content":"A mirror species can be defined using the mirrors facet as following: species B mirrors: A { }  In this case, the species B mirrors the species A. By default, the location of the species B will be random but in many cases, one wants to place the mirror agent at the same location as the reference species. This can be achieved by simply adding the following lines in the mirror species: species B mirrors: A{ point location &lt;- target.location update: target.location; }  target is a built-in attribute of a mirror species. It refers to the instance of the species tracked. In the same spirit, any attribute of a reference species can be reached using the same syntax. For instance, if the species A has an attribute called attribute1 of type int it is possible to get this attribute from the mirror species B using the following syntax: int value &lt;- target.attribute1;  "},{"title":"Example​","type":1,"pageTitle":"Mirror species","url":"wiki/MirrorSpecies#example","content":"To practice a bit with the mirror notion, we will now build a simple model displaying a species A (aspect: white circle) moving randomly, and another species B (aspect: blue sphere) with the species A location on x and y, with an upper value for the z-axis.  Here is an example of an implementation for this model: model Mirror global { init{ create A number:100; } } species A skills:[moving]{ reflex update{ do wander; } aspect base{ draw circle(1) color: #white border: #black; } } species B mirrors: A{ point location &lt;- target.location update: {target.location.x,target.location.y,target.location.z+5}; aspect base { draw sphere(2) color: #blue; } } experiment mirroExp type: gui { output { display superposedView type: opengl{ species A aspect: base; species B aspect: base transparency:0.5; } } }  "},{"title":"Organization of a model","type":0,"sectionRef":"#","url":"wiki/ModelOrganization","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Organization of a model","url":"wiki/ModelOrganization#table-of-contents","content":"Model Header (model species)Species declarationsExperiment declarationsBasic skeleton of a model "},{"title":"Model Header (model species)​","type":1,"pageTitle":"Organization of a model","url":"wiki/ModelOrganization#model-header-model-species","content":"The header of a model file begins with the declaration of the name of the model. Contrarily to other statements, this declaration does not end with a semi-colon. model name_of_the_model  The name of the model is not necessarily the same as the name of the file. It must conform to the general rule for naming species, i.e. be a valid identifier (beginning with a letter, containing only letters, digits, and dashes). This name will be used for building the name of the model species, from which simulations will be instantiated. For instance, the following declaration: model dummy  will internally create a species called dummy_model, child of the abstract species model, from which simulations (called dummy_model0, dummy_model1, etc.) will be instantiated. This declaration is followed by optional import statements that indicate which other models this model is importing. Import statements do not end with a semi-colon. Importing a model can take two forms. The first one, called inheritance import, is declared as follows: import &quot;relative_path_to_a_model_file&quot; import &quot;relative_path_to_another_model_file&quot;  The second one, called usage import, is declared as follows: import &quot;relative_path_to_a_model_file&quot; as model_identifier  When importing models using the first form, all the declarations of the model(s) imported will be merged with those of the current model (in the order with which the import statements are declared, i.e. the latest definitions of global attributes or behaviors superseding the previous ones). The second form is reserved for using models as micro-models of the current model. This possibility is still experimental in the current version of GAMA. The last part of the header is the definition of the global species, which is the actual definition of the model species itself. global { // Definition of [global attributes](GlobalSpecies#declaration), [actions and behaviors](DefiningActionsAndBehaviors) }  Note that neither the imports nor the definition of global is mandatory. Only the model statement is. "},{"title":"Species declarations​","type":1,"pageTitle":"Organization of a model","url":"wiki/ModelOrganization#species-declarations","content":"The header is followed by the declaration of the different species of agents that populate the model. The special species global is the world species. You will declare here all the global attributes/actions/behaviors. The global species does not have a name, and is unique in your model. global { // definition of global attributes, actions, behaviors }  Regular species can be declared with the keyword species. You can declare several regular species, and they all have to be named. A species defines its attributes, actions and behaviors and aspects. species nameOfSpecies { // definition of your species attributes, actions and behaviors and aspects }  Note that the possibility to define the species after the global definition is actually a convenience: these species are micro-species of the model species and, hence, could be perfectly defined as nested species of global. For instance: global { // definition of global attributes, actions, behaviors } species A {...} species B {...}  is completely equivalent to: global { // definition of [global attributes](GlobalSpecies#declaration), actions, behaviors species A {...} species B {...} }  "},{"title":"Experiment declarations​","type":1,"pageTitle":"Organization of a model","url":"wiki/ModelOrganization#experiment-declarations","content":"Experiments are usually declared at the end of the file. They start with the keyword experiment. They contains the simulation parameters, and the definition of the output (such as displays, monitors or inspectors). You can declare as many experiments as you want. experiment first_experiment { // definition of parameters (intputs) // definition of output output {...} } experiment second_experiment { // definition of parameters (inputs) // definition of output }  Note that you have four types of experiments: A GUI experiment allows you to display a graphical interface with input parameters and outputs. It is declared with the following structure: experiment gui_experiment type:gui { [parameters] [output] [...] }  A Batch experiment allows you to execute numerous successive simulation runs (often used for model exploration). It is declared with the following structure: experiment batch_experiment type:batch { [parameters] [exploration method] [...] }  A Test experiment allows you to write unit tests on a model (used to ensure its quality). It is declared with the following structure: experiment test_experiment type:test autorun: true { [setup] [tests] [...] }  A memorize experiment allows you to store each step of the simulation in memory and to backtrack to previous steps. It is declared with the following structure: experiment test_experiment type:memorize { [parameters] [output] [...] }  "},{"title":"Basic skeleton of a model​","type":1,"pageTitle":"Organization of a model","url":"wiki/ModelOrganization#basic-skeleton-of-a-model","content":"Here is the basic skeleton of a model : model name_of_the_model global { // definition of [global attributes](GlobalSpecies#declaration), actions, behaviours } species my_specie { // definition of attributes, actions, behaviors } experiment my_experiment /* + specify the type : &quot;type:gui&quot;, &quot;type:batch&quot;, &quot;type:test&quot;, or &quot;test:memorize&quot; */ { // here the definition of your experiment, with... // ... your inputs output { // ... and your outputs } }  Don't forget this structure! This will be the basis for all the models you will create from now. "},{"title":"Multi-Paradigm Modeling","type":0,"sectionRef":"#","url":"wiki/MultiParadigmModeling","content":"Multi-Paradigm Modeling Multi-paradigm modeling is a research field focused on how to define a model semantically. From the beginning of this step by step tutorial, our approach is based on behavior (or reflex), for each agents. In this part, we will see that GAMA provides other ways to implement your model, using several control architectures. Sometime, it will be easier to implement your models choosing other paradigms. In a first part, we will see how to use some control architectures which already exist in GAML, such as finite state machine architecture, task based architecture or user control architecture. In a second part, we will see an approach based on mathematical modeling through use of differential equations.","keywords":""},{"title":"Multi-level architecture","type":0,"sectionRef":"#","url":"wiki/MultiLevelArchitecture","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"Multi-level architecture","url":"wiki/MultiLevelArchitecture#index","content":"Declaration of micro-speciesAccess to micro-agents / host agentRepresentation of an entity as different types of agentDynamic migration of agentsExample "},{"title":"Declaration of micro-species​","type":1,"pageTitle":"Multi-level architecture","url":"wiki/MultiLevelArchitecture#declaration-of-micro-species","content":"A species can have other species as micro-species. The micro-species of a species is declared inside the species' declaration. species macro_species { species micro_species_in_group { } }  In the above example, micro_species_in_group is a micro-species of macro_species. An agent of macro_species can have agents micro_species_in_group as micro-agents. Agents of micro_species_in_group have an agent of macro_species as host agent. As the species micro_species_in_group is declared inside the species macro_species, micro_species_in_group will return a list of micro_species_in_group agent inside the given macro_species agent. global { init { create macro_species number:5; } } species macro_species { init { create micro_species_in_group number: rnd(10); write &quot;the macro species agent named &quot;+name+&quot; contains &quot;+length(micro_species_in_group)+&quot; agents of micro-species.&quot;; } species micro_species_in_group { } } experiment my_experiment type: gui { }  In the above example, we create 5 macro-species agents, and each one creates a random number of inner micro-species agents. We can see that micro_species_in_group refers to the list of micro-species agents inside the given macro-species agent. "},{"title":"Access to micro-agents, host agent​","type":1,"pageTitle":"Multi-level architecture","url":"wiki/MultiLevelArchitecture#access-to-micro-agents-host-agent","content":"To access micro-agents (from a macro-agent), and to host agent (from a micro-agents), you have to use two built-in attributes. The members built-in attribute is used inside the macro-agent, to get the list of all its micro-agents. species macro_species { init { create first_micro_species number: 3; create second_micro_species number: 6; write &quot;the macro-agent named &quot;+name+&quot; contains &quot;+length(members)+&quot; micro-agents.&quot;; } species first_micro_species { } species second_micro_species { } }  The host built-in attribute is used inside a micro-agent to get its host macro-agent. species macro_species { micro_species_in_group micro_agent; init { create micro_species_in_group number: rnd(10); write &quot;the macro-agent named &quot;+name+&quot; contains &quot;+length(members)+&quot; micro-agents.&quot;; } species micro_species_in_group { init { write &quot;the micro-agent named &quot;+name+&quot; is hosted by &quot;+host; } } }  NB: We already said that the world agent is a particular agent, instantiated just once. In fact, the world agent is the host of all the agents. You can try to get the host for a regular species agent, you will get the world agent itself (named as you named your model). You can also try to get the members of your world (from the global scope for example), and you will get the list of the agents presents in the world. global { init { create macro_species number:5; write &quot;the world has &quot;+length(members)+&quot; members.&quot;; } } species macro_species { init { write &quot;the macro agent named &quot;+name+&quot; is hosted by &quot;+host; } }  "},{"title":"Representation of an entity as different types of agent​","type":1,"pageTitle":"Multi-level architecture","url":"wiki/MultiLevelArchitecture#representation-of-an-entity-as-different-types-of-agent","content":"The multi-level architecture is often used in order to represent an entity through different types of agent. For example, an agent &quot;bee&quot; can have a behavior when it is alone, but when the agent is near from a lot of agents, he can changes his type to &quot;bee_in_swarm&quot;, defined as a micro-species agent of a macro-species &quot;swarm&quot; agent. Another example: an agent &quot;pedestrian&quot; can have a certain behavior when walking on the street, and then change his type to &quot;pedestrian_in_building&quot; when he is in a macro-agent &quot;building&quot;. You have then to distinguish two different species to define your micro-species: The first can be seen as a regular species (it is the &quot;bee&quot; or the &quot;pedestrian&quot; for instance). We will name this species as &quot;micro_species&quot;.The second is the real micro-species, defined inside the macro-species (it is the &quot;bee_in_swarm&quot; or the &quot;pedestrian_in_building&quot; for instance). We will name this species as &quot;micro_species_in_group&quot;. This species has to inherit from the &quot;micro_species&quot; in order to allow migrations between micro_species_in_group and micro_species.  species micro_species { } species macro_species { species micro_species_in_group parent: micro_species { } }  "},{"title":"Dynamic migration of agents​","type":1,"pageTitle":"Multi-level architecture","url":"wiki/MultiLevelArchitecture#dynamic-migration-of-agents","content":"In our example about bees, a &quot;swarm&quot; entity is composed of nearby flying &quot;bee&quot; entities. When a &quot;bee&quot; entity approaches a &quot;swarm&quot; entity, this &quot;bee&quot; entity will become a member of the group. To represent this, the modeler lets the &quot;bee&quot; agent change its species to &quot;bee_in_swarm&quot; species. The &quot;bee&quot; agent hence becomes a &quot;bee_in_swarm&quot; agent. To change species of an agent, we can use one of the following statements: capture, release, migrate. The statement capture is used by the &quot;macro_species&quot; to capture one (or several) &quot;micro_species&quot; agent(s), and turn it (them) to a &quot;micro_species_in_group&quot;. You can specify which agent (or list of agents) you want to capture by passing them as the first argument of the statement capture. The facet as is used to cast the agent(s) from &quot;micro_species&quot; to the species &quot;micro_species_in_group&quot;. You can use the facet returns to get the newly captured agent(s). capture agents_of_micro_species as: micro_species_in_group;  The statement release is used by a &quot;macro_species&quot; agent to release one (or several) &quot;micro_species_in_group&quot; agent(s), and turn it (them) to a &quot;micro_species&quot;. You can specify which agent (or list of agents) you want to release by giving them as the first argument of the release statement. The facet as is used to cast the agents from &quot;micro_species_in_group&quot; species to &quot;micro_species&quot; species. The facet in is used to specify the new host (by default, it is the host of the &quot;macro_species&quot;). You can use the facet returns to get the newly released agent(s). release agents_of_micro_species_in_group as: micro_species in: world;  The statement migrate, less used, permits agents to migrate from one population/species to another population/species and stay in the same host after the migration. Read the GAML Reference to learn more about this statement. "},{"title":"Example:​","type":1,"pageTitle":"Multi-level architecture","url":"wiki/MultiLevelArchitecture#example","content":"Here is an example of micro_species that gather together in macro_species when they are close enough.  model multilevel global { int release_time &lt;- 20; int capture_time &lt;- 100; int remaining_release_time &lt;- 0; int remaining_capture_time &lt;- capture_time; init { create micro_species number:200; } reflex reflex_timer { if (remaining_release_time=1) { remaining_release_time &lt;- 0; remaining_capture_time &lt;- capture_time; } else if (remaining_capture_time=1) { remaining_capture_time &lt;- 0; remaining_release_time &lt;- release_time; } remaining_release_time &lt;- remaining_release_time - 1; remaining_capture_time &lt;- remaining_capture_time - 1; } reflex capture_micro_species when:(remaining_capture_time&gt;0 and flip(0.1)) { ask macro_species { list&amp;lt;micro_species&gt; micro_species_in_range &lt;- micro_species at_distance 1; if (micro_species_in_range != []) { do capture_micro_species(micro_species_in_range); } } ask micro_species { list&amp;lt;micro_species&gt; micro_species_list_to_be_captured &lt;- micro_species at_distance 1; if(micro_species_list_to_be_captured != []) { create macro_species { location &lt;- myself.location; add myself to:micro_species_list_to_be_captured; do capture_micro_species(micro_species_list_to_be_captured); } } } } } species micro_species skills:[moving] { geometry shape &lt;- circle(1); reflex move{ do wander; } aspect base { draw shape border: #black; } } species macro_species { geometry shape &lt;- circle(1) update:circle(length(members)); species micro_species_in_group parent:micro_species { } action capture_micro_species(list&amp;lt;micro_species&gt; micro_list) { loop mic_sp over:micro_list { capture mic_sp as:micro_species_in_group; } } reflex release_reflex when: (remaining_release_time&gt;0 and flip(0.1)) { release members as: micro_species in:world; do die; } aspect base { draw shape border: #black; draw string(length(members)) color:#black size:4; } } experiment MyExperiment type: gui { output { display MyDisplay type: java2D { species macro_species aspect: base; species micro_species aspect: base; } } }  "},{"title":"Navigating in the Workspace","type":0,"sectionRef":"#","url":"wiki/NavigatingWorkspace","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Navigating in the Workspace","url":"wiki/NavigatingWorkspace#table-of-contents","content":"Navigating in the Workspace Status of projects and modelsThe Different Categories of Models Library modelsPlugin modelsTest modelsUser models Inspect ModelsMoving Models AroundClosing and Deleting Projects "},{"title":"Status of projects and models​","type":1,"pageTitle":"Navigating in the Workspace","url":"wiki/NavigatingWorkspace#status-of-projects-and-models","content":"All the projects and models have an icon with a red or green circle on it. This eases to locate models containing compilation errors (red circle) and projects that have been successfully validated (green circle).  "},{"title":"The Different Categories of Models​","type":1,"pageTitle":"Navigating in the Workspace","url":"wiki/NavigatingWorkspace#the-different-categories-of-models","content":"In the Navigator, models are organized in four different categories: Models library, Plugin models, Test models, and User models. This organization is purely logical and does not reflect where the models are actually stored in the workspace (or elsewhere). Whatever their actual location, model files need to be stored in projects, which may contain also other files (called resources) needed for the models to function (such as data files). A project may, of course, contain several model files, especially if they are importing each other, if they represent different models on the same topic, or if they share the same resources.  "},{"title":"Library models​","type":1,"pageTitle":"Navigating in the Workspace","url":"wiki/NavigatingWorkspace#library-models","content":"This category represents the models that are shipped with each version of GAMA. They do not reside in the workspace but are considered as linked from it. This link is established every time a new workspace is created. Their actual location is within a plugin (msi.gama.models) of the GAMA application. This category contains 7 main projects in GAMA 1.8.1, which are further refined in folders and sub-folders that contain model files and resources.  The 7 main projects on the Library models are: Data: all these plugins illustrate how to manage data in GAML. This includes how to import data (in all the supported formats) into a model, export (i.e. save) agents or data in the simulations in files, clean data (e.g. clean a road network), get and save data in databases, and use data analysis operators.GAML Syntax: these models have the only goal to illustrate the syntax of the GAML language. This includes how to use the various data structures (list, map, matrix...), architectures, loop, interactions, and conditional structures, or how to schedule agents... Model Exploration: all these models illustrate the various ways to explore models and in particular the various possible experiment (batch, multi-simulations...).Modeling: these models provide implementations of various classical difficulties encountered by modelers: how to make agents move (on a graph, a grid...), how to implement decision-making process...Toy Models: these models are replications of classical models from the literature, including Sugarscape, Schelling, ants, boids...Tutorials: this project contains all the files of the various tutorials (available from the website).Visualization and User Interaction: these models illustrate most of the GAMA features in terms of visualization and interactions with the simulation, e.g. the 3D visualization...   It may happen, on some occasions, that the library of models is not synchronized with the version of GAMA that uses your workspace. This is the case if you use different versions of GAMA to work with the same workspace. In that case, it is required that the library be manually updated. This can be done using the &quot;Update library&quot; item in the contextual menu.  To look up for a particular model in the library, users can use the &quot;Find model...&quot; search bar, which allows looking for models by their title (for example, models containing &quot;BDI&quot; in the example below).  "},{"title":"Plugin models​","type":1,"pageTitle":"Navigating in the Workspace","url":"wiki/NavigatingWorkspace#plugin-models","content":"This category represents the models that are related to a specific plugin (additional or integrated by default). The corresponding plugin is shown between parenthesis.  When you add an additional plugin extending the GAML language is added, a new project can be added to this category. "},{"title":"Test models​","type":1,"pageTitle":"Navigating in the Workspace","url":"wiki/NavigatingWorkspace#test-models","content":"These models are unit tests for the GAML language: they aim at testing each element of the language to check whether they produce the expected result. The aim is to avoid regression after evolutions of the software. They can be run from the validation view. "},{"title":"User models​","type":1,"pageTitle":"Navigating in the Workspace","url":"wiki/NavigatingWorkspace#user-models","content":"This category regroups all the projects that have been created or imported in the workspace by the user. Each project can be actually a folder that resides in the folder of the workspace (so they can be easily located from within the filesystem) or a link to a folder located anywhere in the filesystem (in case of a project importation). Any modification (addition, removal of files...) made to them in the file system (or using another application) is immediately reflected in the Navigator and vice-versa. Model files, although it is by no means mandatory, usually reside in a sub-folder of the project called models. Similarly, all the test models are located in the tests folder.  "},{"title":"Inspect Models​","type":1,"pageTitle":"Navigating in the Workspace","url":"wiki/NavigatingWorkspace#inspect-models","content":"Each model is presented as a node in the navigation workspace, including Experiment buttons and/or a Contents node and/or a Uses node and/or a Tags node and/or an Imports node.  Imports: The node Impots lists all the model files that are imported in the current model.  Uses node: The node Uses is present if your model uses some external resources, and if the path to the resource is correct (if the path to the resource is not correct, the resource will not be displayed under Uses).  Tags node: The node Tags lists all the tags that have been specified in the header of the model.  Contents: The node Contents describes the tree of all the elements in the model. It is similar to the Overview view. Experiment button : Experiment buttons are present if your model contains experiments (it is usually the case !). To run the corresponding experiment, just click on it. To learn more about running experiments, jump into this section.  "},{"title":"Moving Models Around​","type":1,"pageTitle":"Navigating in the Workspace","url":"wiki/NavigatingWorkspace#moving-models-around","content":"Model files, as well as resources, or even complete projects, can be moved around between the &quot;Models Library&quot;/&quot;Plugin Models&quot; and &quot;Users Models&quot; categories, or within them, directly in the Navigator. Drag'n drop operations are supported, as well as copy and paste. For example, the model Life.gaml, present in the &quot;Models Library&quot;, can perfectly be copied and then pasted in a project in the &quot;Users Model&quot;. This local copy in the workspace can then be further edited by the user without altering the original one.  "},{"title":"Closing and Deleting Projects​","type":1,"pageTitle":"Navigating in the Workspace","url":"wiki/NavigatingWorkspace#closing-and-deleting-projects","content":"Users can choose to get rid of old projects by either closing or deleting them. Closing a project means that it will still reside in the workspace (and be still visible, although a bit differently, in the Navigator) but its model(s) won't participate to the build process and won't be displayable until the project is opened again.  Deleting a project must be invoked when the user wants this project to not appear in the workspace anymore (unless that is, it is imported again). Invoking this command will effectively make the workspace &quot;forget&quot; about this project, and this can be further doubled with a deletion of the project's resources and models from the filesystem.  "},{"title":"Versions of GAMA","type":0,"sectionRef":"#","url":"wiki/OlderVersions","content":"","keywords":""},{"title":"GAMA 1.8.2 (May 2022)​","type":1,"pageTitle":"Versions of GAMA","url":"wiki/OlderVersions#gama-182-may-2022","content":"Version 1.8.2 is the current version of GAMA, built originally to bring the compatibility with Windows 11, masOS Monterey, Apple Silicon processors, and JDK 17 (the latest long-term support version of Java). It also provides several new features, bug fixes and enhancements of existing features, which are listed on the release description. Documentation: Documentation in PDF  "},{"title":"GAMA 1.8.1 (June 2020)​","type":1,"pageTitle":"Versions of GAMA","url":"wiki/OlderVersions#gama-181-june-2020","content":"Version 1.8.1 improved many features over version 1.8. You can check the related changelog on the release description. It is the last version of GAMA running on JDK 8. Documentation: Documentation in PDF  "},{"title":"GAMA 1.8 (July 2019)​","type":1,"pageTitle":"Versions of GAMA","url":"wiki/OlderVersions#gama-18-july-2019","content":"Version 1.8 improved many features over version 1.7. Documentation: Documentation in PDF  "},{"title":"GAMA 1.7 RC 2 (April 2017)​","type":1,"pageTitle":"Versions of GAMA","url":"wiki/OlderVersions#gama-17-rc-2-april-2017","content":"This version introduced many features over 1.6.1:  "},{"title":"GAMA 1.6.1 (June 2014)​","type":1,"pageTitle":"Versions of GAMA","url":"wiki/OlderVersions#gama-161-june-2014","content":"GAMA 1.6.1 improves many features over version 1.6: OpenGL displays improvementsVarious enhancements for displays (overlay, focus, light, trace, DEM, colors with alpha, addition of CSS colors...)Compilation of models (errors tracked, memory, report of errors, etc.)Validation of stochastic models (random now extended to every areas of a model, incl. the operations on HashSets)GIS file handling (esp. with the possibility to pass a custom CRS)Handling of OSM dataComparison of raster and vectorial mapsTraffic moving skill improvementHandling of various other file types (uniform constructors, ...)Documentation itself (both online and on the website)Testing framework and debugging tools (trace, sample)Speed of computation of several spatial operatorsExperiments (permanent output, access to the duration of cycles)Type system (complete parametric definitions of types)Addition of several 3D operationsAuto-update mechanism of pluginsAutomatic importation of files/projects when double-clicked in the OS (or transmitted by command line arguments)Definition of charts (dynamic data lists, marker type, range, etc.) Documentation: Documentation in PDF  "},{"title":"GAMA 1.6 (July 2013)​","type":1,"pageTitle":"Versions of GAMA","url":"wiki/OlderVersions#gama-16-july-2013","content":"This version introduced many features over 1.5.1: correction of bugs (in particular, freeze, memory consumption)performance improvement (in particular for &quot;big&quot; models)further simplification of the GAML language (assignments, manipulation of containers)integration of an agent browserimprovement of the 3D integration (new operators, new display facet bug corrections...)removing of the environment blockmore user/simulation interaction (event statement) Documentation: Documentation in PDF  "},{"title":"GAMA 1.5 / 1.5.1 (July & November 2012)​","type":1,"pageTitle":"Versions of GAMA","url":"wiki/OlderVersions#gama-15--151-july--november-2012","content":"Key points: Improvement of the performance and stabilitySimplification of the modeling language (omissible facets, types as declarations, etc.)Integration of non-spatial graphsIntroduction of OpenGL displaysImprovement of the user interaction in the simulation perspectiveGeneralization of the notion of experiment Version 1.5.1 improved some features of 1.5: correction of bugs (in particular, no more freezes when reloading an experiment)performance improvement (in particular for &quot;big&quot; models)improvement of the 3D integration (new operators to add a &quot;z&quot; to geometries, bug corrections...)new models (driving_traffic, Vote, 3D models) Documentation: Documentation in PDF  "},{"title":"GAMA 1.4 (December 2011)​","type":1,"pageTitle":"Versions of GAMA","url":"wiki/OlderVersions#gama-14-december-2011","content":"This versions introduced the new integrated development environment based on XText, as well as a completely revamped modeling language, not based on XML anymore, and much easier to read and write. It also introduced new important types such as geometry, graph, path, and topology in order to ease the spatial manipulation of agents. Key points: Deep refactoring of the source codeNew programming language (based on XText)Integration of a true IDE based on Eclipse/XtextDeep refactoring of the meta-modelBetter integration of multi-level speciesNew important notion: topologyNew variable types: geometry, graph, path, topologyMany more novelties/improvements/enrichments... Documentation: Documentation in PDF  "},{"title":"GAMA 1.3 (August 2010)​","type":1,"pageTitle":"Versions of GAMA","url":"wiki/OlderVersions#gama-13-august-2010","content":"Version 1.3 added numerous operators to manipulate GIS data. Moreover, it integrated new features like the possibility to define custom displays and to define multi-level models. It allowed to use clustering and decision-making methods. And it greatly improved the performances of the platform. Key points: Important improvement of the performance of the platformImprovement of the simulation displayEnrichment of the spatial operators/actionsIntegration of multi-level modelsIntegration of clustering algorithmsIntegration of decision-making algorithms Documentation: Documentation in PDF  "},{"title":"GAMA 1.1 (October 2009)​","type":1,"pageTitle":"Versions of GAMA","url":"wiki/OlderVersions#gama-11-october-2009","content":"The first &quot;real&quot; release of GAMA, which incorporated several changes, including an XML editor coupled with the simulator, the possibility to take snapshots of every graphical window, save parameters and monitors for future reuse, save charts as CSV files, and definitely fixed the memory leaks observed in previous internal versions. Key points: Transformation into a more complete and versatile platformAddition of batch controllersIntegration of a true modeling language (based on XML)First release as an open-source project Documentation: Guidebook of GAMA 1.1Training session on GAMA 1.1 (Hanoi)    This page is licensed under a Creative Commons Attribution 4.0 International License . "},{"title":"Operators (B to C)","type":0,"sectionRef":"#","url":"wiki/OperatorsBC","content":"","keywords":""},{"title":"Definition​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#definition","content":"Operators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function. Most of them use a classical prefixed functional syntax (i.e. operator_name(operand1, operand2, operand3), see below), with the exception of arithmetic (e.g. +, /), logical (and, or), comparison (e.g. &gt;, &lt;), access (., [..]) and pair (::) operators, which require an infixed notation (i.e. operand1 operator_symbol operand1). The ternary functional if-else operator, ? :, uses a special infixed syntax composed with two symbols (e.g. operand1 ? operand2 : operand3). Two unary operators (- and !) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g. - 10, ! (operand1 or operand2)). Finally, special constructor operators ({...} for constructing points, [...] for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. {1,2,3}, [operand1, operand2, ..., operandn] or [key1::value1, key2::value2... keyn::valuen]). With the exception of these special cases above, the following rules apply to the syntax of operators: if they only have one operand, the functional prefixed syntax is mandatory (e.g. operator_name(operand1))if they have two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2)) or the infixed syntax (e.g. operand1 operator_name operand2) can be used.if they have more than two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2, ..., operand)) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. operand1 operator_name(operand2, ..., operand)) can be used. All of these alternative syntaxes are completely equivalent. Operators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.  "},{"title":"Priority between operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#priority-between-operators","content":"The priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first. GAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely: the constructor operators, like ::, used to compose pairs of operands, have the lowest priority of all operators (e.g. a &gt; b :: b &gt; c will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, [a &gt; 10, b &gt; 5] will return a list of boolean values.it is followed by the ?: operator, the functional if-else (e.g. a &gt; b ? a + 10 : a - 10 will return the result of the if-else).next are the logical operators, and and or (e.g. a &gt; b or b &gt; c will return the value of the test)next are the comparison operators (i.e. &gt;, &lt;, &lt;=, &gt;=, =, !=)next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)next the unary operators - and !next the access operators . and [] (e.g. {1,2,3}.x &gt; 20 + {4,5,6}.y will return the result of the comparison between the x and y ordinates of the two points)and finally the functional operators, which have the highest priority of all.  "},{"title":"Using actions as operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#using-actions-as-operators","content":"Actions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand. For instance, if the following species is defined: species spec1 { int min(int x, int y) { return x &gt; y ? x : y; } }  Any agent instance of spec1 can use min as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable: global { init { create spec1; spec1 my_agent &lt;- spec1[0]; int the_min &lt;- my_agent min(10,20); // or min(my_agent, 10, 20); } }  If the action doesn't have any operands, the syntax to use is my_agent the_action(). Finally, if it does not return a value, it might still be used but is considering as returning a value of type unknown (e.g. unknown result &lt;- my_agent the_action(op1, op2);). Note that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).  "},{"title":"Table of Contents​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#table-of-contents","content":" "},{"title":"Operators by categories​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#operators-by-categories","content":" "},{"title":"3D​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#3d","content":"box, cone3D, cube, cylinder, hexagon, pyramid, set_z, sphere, teapot,  "},{"title":"Arithmetic operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#arithmetic-operators","content":"-, /, ^, *, +, abs, acos, asin, atan, atan2, ceil, cos, cos_rad, div, even, exp, fact, floor, hypot, is_finite, is_number, ln, log, mod, round, signum, sin, sin_rad, sqrt, tan, tan_rad, tanh, with_precision,  "},{"title":"BDI​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#bdi","content":"add_values, and, eval_when, get_about, get_agent, get_agent_cause, get_belief_op, get_belief_with_name_op, get_beliefs_op, get_beliefs_with_name_op, get_current_intention_op, get_decay, get_desire_op, get_desire_with_name_op, get_desires_op, get_desires_with_name_op, get_dominance, get_familiarity, get_ideal_op, get_ideal_with_name_op, get_ideals_op, get_ideals_with_name_op, get_intensity, get_intention_op, get_intention_with_name_op, get_intentions_op, get_intentions_with_name_op, get_lifetime, get_liking, get_modality, get_obligation_op, get_obligation_with_name_op, get_obligations_op, get_obligations_with_name_op, get_plan_name, get_predicate, get_solidarity, get_strength, get_super_intention, get_trust, get_truth, get_uncertainties_op, get_uncertainties_with_name_op, get_uncertainty_op, get_uncertainty_with_name_op, get_values, has_belief_op, has_belief_with_name_op, has_desire_op, has_desire_with_name_op, has_ideal_op, has_ideal_with_name_op, has_intention_op, has_intention_with_name_op, has_obligation_op, has_obligation_with_name_op, has_uncertainty_op, has_uncertainty_with_name_op, new_emotion, new_mental_state, new_predicate, new_social_link, not, or, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_lifetime, set_liking, set_modality, set_predicate, set_solidarity, set_strength, set_trust, set_truth, with_values,  "},{"title":"Casting operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#casting-operators","content":"as, as_int, as_matrix, font, is, is_skill, list_with, matrix_with, species, to_gaml, topology,  "},{"title":"Color-related operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#color-related-operators","content":"-, /, *, +, blend, brewer_colors, brewer_palettes, gradient, grayscale, hsb, mean, median, palette, rgb, rnd_color, scale, sum,  "},{"title":"Comparison operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#comparison-operators","content":"!=, &lt;, &lt;=, =, &gt;, &gt;=, between,  "},{"title":"Containers-related operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#containers-related-operators","content":"-, ::, +, accumulate, all_match, among, at, cartesian_product, collect, contains, contains_all, contains_any, contains_key, count, empty, every, first, first_with, get, group_by, in, index_by, inter, interleave, internal_integrated_value, last, last_with, length, max, max_of, mean, mean_of, median, min, min_of, mul, none_matches, one_matches, one_of, product_of, range, remove_duplicates, reverse, shuffle, sort_by, split, split_in, split_using, sum, sum_of, union, variance_of, where, with_max_of, with_min_of,  "},{"title":"Date-related operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#date-related-operators","content":"-, !=, +, &lt;, &lt;=, =, &gt;, &gt;=, after, before, between, every, milliseconds_between, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_weeks, minus_years, months_between, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_weeks, plus_years, since, to, until, years_between,  "},{"title":"Dates​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#dates","content":" "},{"title":"Displays​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#displays","content":"horizontal, stack, vertical,  "},{"title":"edge​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#edge","content":"edge_between, strahler,  "},{"title":"EDP-related operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#edp-related-operators","content":"diff, diff2,  "},{"title":"Files-related operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#files-related-operators","content":"copy_file, crs, csv_file, delete_file, dxf_file, evaluate_sub_model, file_exists, folder, folder_exists, gaml_file, geojson_file, get, gif_file, gml_file, graph6_file, graphdimacs_file, graphdot_file, graphgexf_file, graphgml_file, graphml_file, graphtsplib_file, grid_file, image_file, is_csv, is_dxf, is_gaml, is_geojson, is_gif, is_gml, is_graph6, is_graphdimacs, is_graphdot, is_graphgexf, is_graphgml, is_graphml, is_graphtsplib, is_grid, is_image, is_json, is_obj, is_osm, is_pgm, is_property, is_saved_simulation, is_shape, is_svg, is_text, is_threeds, is_xml, json_file, new_folder, obj_file, osm_file, pgm_file, property_file, read, rename_file, saved_simulation_file, shape_file, step_sub_model, svg_file, text_file, threeds_file, unzip, writable, xml_file, zip,  "},{"title":"FIPA-related operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#fipa-related-operators","content":"conversation, message,  "},{"title":"GamaMaterialType​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#gamamaterialtype","content":"material,  "},{"title":"GamaMetaType​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#gamametatype","content":"type_of,  "},{"title":"Gen*​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#gen","content":"add_attribute, add_census_file, add_mapper, add_marginals, add_range_attribute, with_generation_algo,  "},{"title":"Graphs-related operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#graphs-related-operators","content":"add_edge, add_node, adjacency, agent_from_geometry, all_pairs_shortest_path, alpha_index, as_distance_graph, as_edge_graph, as_intersection_graph, as_path, as_spatial_graph, beta_index, betweenness_centrality, biggest_cliques_of, connected_components_of, connectivity_index, contains_edge, contains_vertex, degree_of, directed, edge, edge_between, edge_betweenness, edges, gamma_index, generate_barabasi_albert, generate_complete_graph, generate_random_graph, generate_watts_strogatz, girvan_newman_clustering, grid_cells_to_graph, in_degree_of, in_edges_of, k_spanning_tree_clustering, label_propagation_clustering, layout_circle, layout_force, layout_force_FR, layout_force_FR_indexed, layout_grid, load_shortest_paths, main_connected_component, max_flow_between, maximal_cliques_of, nb_cycles, neighbors_of, node, nodes, out_degree_of, out_edges_of, path_between, paths_between, predecessors_of, remove_node_from, rewire_n, source_of, spatial_graph, strahler, successors_of, sum, target_of, undirected, use_cache, weight_of, with_k_shortest_path_algorithm, with_shortest_path_algorithm, with_weights,  "},{"title":"Grid-related operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#grid-related-operators","content":"as_4_grid, as_grid, as_hexagonal_grid, cell_at, cells_in, cells_overlapping, field, grid_at, neighbors_of, path_between, points_in, values_in,  "},{"title":"Iterator operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#iterator-operators","content":"accumulate, all_match, as_map, collect, count, create_map, first_with, frequency_of, group_by, index_by, last_with, max_of, mean_of, min_of, none_matches, one_matches, product_of, sort_by, sum_of, variance_of, where, where, where, with_max_of, with_min_of,  "},{"title":"List-related operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#list-related-operators","content":"all_indexes_of, copy_between, index_of, last_index_of,  "},{"title":"Logical operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#logical-operators","content":":, !, ?, add_3Dmodel, add_geometry, add_icon, and, or, xor,  "},{"title":"Map comparaison operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#map-comparaison-operators","content":"fuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,  "},{"title":"Map-related operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#map-related-operators","content":"as_map, create_map, index_of, last_index_of,  "},{"title":"Matrix-related operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#matrix-related-operators","content":"-, /, ., *, +, append_horizontally, append_vertically, column_at, columns_list, determinant, eigenvalues, index_of, inverse, last_index_of, row_at, rows_list, shuffle, trace, transpose,  "},{"title":"multicriteria operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#multicriteria-operators","content":"electre_DM, evidence_theory_DM, fuzzy_choquet_DM, promethee_DM, weighted_means_DM,  "},{"title":"Path-related operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#path-related-operators","content":"agent_from_geometry, all_pairs_shortest_path, as_path, load_shortest_paths, max_flow_between, path_between, path_to, paths_between, use_cache,  "},{"title":"Points-related operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#points-related-operators","content":"-, /, *, +, &lt;, &lt;=, &gt;, &gt;=, add_point, angle_between, any_location_in, centroid, closest_points_with, farthest_point_to, grid_at, norm, points_along, points_at, points_on,  "},{"title":"Random operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#random-operators","content":"binomial, flip, gamma_density, gamma_rnd, gamma_trunc_rnd, gauss, generate_terrain, lognormal_density, lognormal_rnd, lognormal_trunc_rnd, poisson, rnd, rnd_choice, sample, shuffle, skew_gauss, truncated_gauss, weibull_density, weibull_rnd, weibull_trunc_rnd,  "},{"title":"ReverseOperators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#reverseoperators","content":"restore_simulation, restore_simulation_from_file, save_simulation, serialize, serialize_agent,  "},{"title":"Shape​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#shape","content":"arc, box, circle, cone, cone3D, cross, cube, curve, cylinder, ellipse, elliptical_arc, envelope, geometry_collection, hexagon, line, link, plan, polygon, polyhedron, pyramid, rectangle, sphere, square, squircle, teapot, triangle,  "},{"title":"Spatial operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#spatial-operators","content":"-, *, +, add_point, agent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, angle_between, any_location_in, arc, around, as_4_grid, as_driving_graph, as_grid, as_hexagonal_grid, at_distance, at_location, box, centroid, circle, clean, clean_network, closest_points_with, closest_to, closest_tob, cone, cone3D, convex_hull, covering, covers, cross, crosses, crossing, crs, CRS_transform, cube, curve, cylinder, direction_between, disjoint_from, distance_between, distance_to, ellipse, elliptical_arc, envelope, farthest_point_to, farthest_to, geometry_collection, gini, hexagon, hierarchical_clustering, IDW, inside, inter, intersects, inverse_rotation, line, link, masked_by, moran, neighbors_at, neighbors_of, normalized_rotation, overlapping, overlaps, partially_overlapping, partially_overlaps, path_between, path_to, plan, points_along, points_at, points_on, polygon, polyhedron, pyramid, rectangle, rotated_by, rotation_composition, round, scaled_to, set_z, simple_clustering_by_distance, simplification, skeletonize, smooth, sphere, split_at, split_geometry, split_lines, square, squircle, teapot, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, touches, touching, towards, transformed_by, translated_by, triangle, triangulate, union, using, voronoi, with_precision, without_holes,  "},{"title":"Spatial properties operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#spatial-properties-operators","content":"covers, crosses, intersects, partially_overlaps, touches,  "},{"title":"Spatial queries operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#spatial-queries-operators","content":"agent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, at_distance, closest_to, covering, crossing, farthest_to, inside, neighbors_at, neighbors_of, overlapping, partially_overlapping, touching,  "},{"title":"Spatial relations operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#spatial-relations-operators","content":"direction_between, distance_between, distance_to, path_between, path_to, towards,  "},{"title":"Spatial statistical operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#spatial-statistical-operators","content":"hierarchical_clustering, simple_clustering_by_distance,  "},{"title":"Spatial transformations operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#spatial-transformations-operators","content":"-, *, +, as_4_grid, as_grid, as_hexagonal_grid, at_location, clean, clean_network, convex_hull, CRS_transform, inverse_rotation, normalized_rotation, rotated_by, rotation_composition, scaled_to, simplification, skeletonize, smooth, split_geometry, split_lines, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, transformed_by, translated_by, triangulate, voronoi, with_precision, without_holes,  "},{"title":"Species-related operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#species-related-operators","content":"index_of, last_index_of, of_generic_species, of_species,  "},{"title":"Statistical operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#statistical-operators","content":"auto_correlation, beta, binomial_coeff, binomial_complemented, binomial_sum, build, chi_square, chi_square_complemented, correlation, covariance, dbscan, distribution_of, distribution2d_of, dtw, durbin_watson, frequency_of, gamma, gamma_distribution, gamma_distribution_complemented, geometric_mean, gini, harmonic_mean, hierarchical_clustering, incomplete_beta, incomplete_gamma, incomplete_gamma_complement, kmeans, kurtosis, log_gamma, max, mean, mean_deviation, median, min, moment, moran, mul, normal_area, normal_density, normal_inverse, predict, pValue_for_fStat, pValue_for_tStat, quantile, quantile_inverse, rank_interpolated, rms, simple_clustering_by_distance, skewness, split, split_in, split_using, standard_deviation, student_area, student_t_inverse, sum, t_test, variance,  "},{"title":"Strings-related operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#strings-related-operators","content":"+, &lt;, &lt;=, &gt;, &gt;=, at, char, contains, contains_all, contains_any, copy_between, date, empty, first, in, indented_by, index_of, is_number, last, last_index_of, length, lower_case, regex_matches, replace, replace_regex, reverse, sample, shuffle, split_with, string, upper_case,  "},{"title":"SubModel​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#submodel","content":"load_sub_model,  "},{"title":"System​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#system","content":"., choose, command, copy, copy_to_clipboard, dead, enter, eval_gaml, every, is_error, is_reachable, is_warning, user_confirm, user_input_dialog, wizard, wizard_page,  "},{"title":"Time-related operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#time-related-operators","content":"date, string,  "},{"title":"Types-related operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#types-related-operators","content":"action, agent, attributes, BDIPlan, bool, container, directory, emotion, file, float, gaml_type, gen_population_generator, gen_range, geometry, graph, int, kml, list, map, matrix, mental_state, Norm, pair, path, point, predicate, regression, rgb, Sanction, skill, social_link, topology, unknown,  "},{"title":"User control operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#user-control-operators","content":"choose, enter, user_confirm, user_input_dialog, wizard, wizard_page,  "},{"title":"Operators​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#operators","content":" "},{"title":"BDIPlan​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#bdiplan","content":"Possible uses:​ BDIPlan (any) ---&gt; BDIPlan  Result:​ casts the operand in a BDIPlan object.  "},{"title":"before​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#before","content":"Possible uses:​ before (date) ---&gt; boolany expression before date ---&gt; boolbefore (any expression , date) ---&gt; bool  Result:​ Returns true if the current_date of the model is strictly before the date passed in argument. Synonym of 'current_date &lt; argument' Examples:​ reflex when: before(starting_date) {} // this reflex will never be run   "},{"title":"beta​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#beta","content":"Possible uses:​ float beta float ---&gt; floatbeta (float , float) ---&gt; float  Result:​ Returns the beta function with arguments a, b. Comment:​ Checked on R. beta(4,5) Examples:​ float var0 &lt;- beta(4,5) with_precision(4); // var0 equals 0.0036   "},{"title":"beta_index​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#beta_index","content":"Possible uses:​ beta_index (graph) ---&gt; float  Result:​ returns the beta index of the graph (Measures the level of connectivity in a graph and is expressed by the relationship between the number of links (e) over the number of nodes (v) : beta = e/v. Examples:​ graph graphEpidemio &lt;- graph([]); float var1 &lt;- beta_index(graphEpidemio); // var1 equals the beta index of the graph  See also: alpha_index, gamma_index, nb_cycles, connectivity_index,  "},{"title":"between​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#between","content":"Possible uses:​ date between date ---&gt; boolbetween (date , date) ---&gt; boolbetween (any expression, date, date) ---&gt; boolbetween (float, float, float) ---&gt; boolbetween (int, int, int) ---&gt; boolbetween (date, date, date) ---&gt; bool  Result:​ returns true the first operand is bigger than the second operand and smaller than the third operand Special cases:​ With only 2 date operands, it returns true if the current_date is between the 2 date operands.  bool var2 &lt;- between(date('2000-01-01'), date('2020-02-02')); // var2 equals false  returns true if the first operand is between the two dates passed in arguments (both exclusive). Can be combined with 'every' to express a frequency between two dates  bool var3 &lt;- (date('2016-01-01') between(date('2000-01-01'), date('2020-02-02'))); // var3 equals true // will return true every new day between these two dates, taking the first one as the starting point every(#day between(date('2000-01-01'), date('2020-02-02')))  Examples:​ bool var0 &lt;- between(5.0, 1.0, 10.0); // var0 equals true bool var1 &lt;- between(5, 1, 10); // var1 equals true   "},{"title":"betweenness_centrality​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#betweenness_centrality","content":"Possible uses:​ betweenness_centrality (graph) ---&gt; map  Result:​ returns a map containing for each vertex (key), its betweenness centrality (value): number of shortest paths passing through each vertex Examples:​ graph graphEpidemio &lt;- graph([]); map var1 &lt;- betweenness_centrality(graphEpidemio); // var1 equals the betweenness centrality index of the graph   "},{"title":"biggest_cliques_of​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#biggest_cliques_of","content":"Possible uses:​ biggest_cliques_of (graph) ---&gt; list&amp;lt;list&gt;  Result:​ returns the biggest cliques of a graph using the Bron-Kerbosch clique detection algorithm Examples:​ graph my_graph &lt;- graph([]); list&amp;lt;list&gt; var1 &lt;- biggest_cliques_of (my_graph); // var1 equals the list of the biggest cliques as list  See also: maximal_cliques_of,  "},{"title":"binomial​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#binomial","content":"Possible uses:​ int binomial float ---&gt; intbinomial (int , float) ---&gt; int  Result:​ A value from a random variable following a binomial distribution. The operands represent the number of experiments n and the success probability p. Comment:​ The binomial distribution is the discrete probability distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields success with probability p, cf. Binomial distribution on Wikipedia. Examples:​ int var0 &lt;- binomial(15,0.6); // var0 equals a random positive integer  See also: gamma_rnd, gauss_rnd, lognormal_rnd, poisson, rnd, skew_gauss, truncated_gauss, weibull_rnd,  "},{"title":"binomial_coeff​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#binomial_coeff","content":"Possible uses:​ int binomial_coeff int ---&gt; floatbinomial_coeff (int , int) ---&gt; float  Result:​ Returns n choose k as a double. Note the integerization of the double return value. Examples:​ float var0 &lt;- binomial_coeff(10,2); // var0 equals 45   "},{"title":"binomial_complemented​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#binomial_complemented","content":"Possible uses:​ binomial_complemented (int, int, float) ---&gt; float  Result:​ Returns the sum of the terms k+1 through n of the Binomial probability density, where n is the number of trials and P is the probability of success in the range 0 to 1. Examples:​ float var0 &lt;- binomial_complemented(10,5,0.5) with_precision(2); // var0 equals 0.38   "},{"title":"binomial_sum​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#binomial_sum","content":"Possible uses:​ binomial_sum (int, int, float) ---&gt; float  Result:​ Returns the sum of the terms 0 through k of the Binomial probability density, where n is the number of trials and p is the probability of success in the range 0 to 1. Examples:​ float var0 &lt;- binomial_sum(5,10,0.5) with_precision(2); // var0 equals 0.62   "},{"title":"blend​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#blend","content":"Possible uses:​ rgb blend rgb ---&gt; rgbblend (rgb , rgb) ---&gt; rgbblend (rgb, rgb, float) ---&gt; rgb  Result:​ Blend two colors with an optional ratio (c1 * r + c2 * (1 - r)) between 0 and 1 Special cases:​ If the ratio is omitted, an even blend is done  rgb var1 &lt;- blend(#red, #blue); // var1 equals to a color very close to the purple  Examples:​ rgb var0 &lt;- blend(#red, #blue, 0.3); // var0 equals to a color between the purple and the blue  See also: rgb, hsb,  "},{"title":"bool​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#bool","content":"Possible uses:​ bool (any) ---&gt; bool  Result:​ casts the operand in a bool object.  "},{"title":"box​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#box","content":"Possible uses:​ box (point) ---&gt; geometrybox (float, float, float) ---&gt; geometry  Result:​ A box geometry which side sizes are given by the operands. Comment:​ the center of the box is by default the location of the current agent in which has been called this operator.the center of the box is by default the location of the current agent in which has been called this operator. Special cases:​ returns nil if the operand is nil. returns nil if the operand is nil. Examples:​ geometry var0 &lt;- box(10, 5 , 5); // var0 equals a geometry as a rectangle with width = 10, height = 5 depth= 5. geometry var1 &lt;- box({10, 5 , 5}); // var1 equals a geometry as a rectangle with width = 10, height = 5 depth= 5. float var2 &lt;- (box({10, 10 , 5}) at_location point(50,50,0)).location.y; // var2 equals 50.0  See also: around, circle, sphere, cone, line, link, norm, point, polygon, polyline, square, cube, triangle,  "},{"title":"brewer_colors​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#brewer_colors","content":"Possible uses:​ brewer_colors (string) ---&gt; list&amp;lt;rgb&gt;string brewer_colors int ---&gt; list&amp;lt;rgb&gt;brewer_colors (string , int) ---&gt; list&amp;lt;rgb&gt;  Result:​ Build a list of colors of a given type (see website http://colorbrewer2.org/). The list of palettes can be obtained by calling brewer_palettes. This list can be safely modified afterwards (adding or removing colors) Build a list of colors of a given type (see website http://colorbrewer2.org/) with a given number of classes Examples:​ list&amp;lt;rgb&gt; var0 &lt;- list&amp;lt;rgb&gt; colors &lt;- brewer_colors(&quot;OrRd&quot;);; // var0 equals a list of 6 blue colors list&amp;lt;rgb&gt; var1 &lt;- list&amp;lt;rgb&gt; colors &lt;- brewer_colors(&quot;Pastel1&quot;, 5);; // var1 equals a list of 5 sequential colors in the palette named 'Pastel1'. The list of palettes can be obtained by calling brewer_palettes  See also: brewer_palettes,  "},{"title":"brewer_palettes​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#brewer_palettes","content":"Possible uses:​ brewer_palettes (int) ---&gt; list&amp;lt;string&gt;int brewer_palettes int ---&gt; list&amp;lt;string&gt;brewer_palettes (int , int) ---&gt; list&amp;lt;string&gt;  Result:​ returns the list a palette with a given min number of classes) returns the list a palette with a given min number of classes and max number of classes) Examples:​ list&amp;lt;string&gt; var0 &lt;- list&amp;lt;string&gt; palettes &lt;- brewer_palettes(3);; // var0 equals a list of palettes that are composed of a min of 3 colors list&amp;lt;string&gt; var1 &lt;- list&amp;lt;string&gt; palettes &lt;- brewer_palettes(5,10);; // var1 equals a list of palettes that are composed of a min of 5 colors and a max of 10 colors  See also: brewer_colors,  "},{"title":"buffer​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#buffer","content":"Same signification as +  "},{"title":"build​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#build","content":"Possible uses:​ build (matrix) ---&gt; regression  Result:​ returns the regression build from the matrix data (a row = an instance, the last value of each line is the y value) while using the given ordinary least squares method. Usage: build(data) Examples:​ build(matrix([[1.0,2.0,3.0,4.0],[2.0,3.0,4.0,2.0]]))   "},{"title":"cartesian_product​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#cartesian_product","content":"Possible uses:​ cartesian_product (list) ---&gt; unknown  "},{"title":"ceil​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#ceil","content":"Possible uses:​ ceil (float) ---&gt; float  Result:​ Maps the operand to the smallest following integer, i.e. the smallest integer not less than x. Examples:​ float var0 &lt;- ceil(3); // var0 equals 3.0 float var1 &lt;- ceil(3.5); // var1 equals 4.0 float var2 &lt;- ceil(-4.7); // var2 equals -4.0  See also: floor, round,  "},{"title":"cell_at​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#cell_at","content":"Possible uses:​ field cell_at point ---&gt; geometrycell_at (field , point) ---&gt; geometrycell_at (field, int, int) ---&gt; geometry  "},{"title":"cells_in​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#cells_in","content":"Possible uses:​ field cells_in geometry ---&gt; list&amp;lt;geometry&gt;cells_in (field , geometry) ---&gt; list&amp;lt;geometry&gt;  "},{"title":"cells_overlapping​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#cells_overlapping","content":"Possible uses:​ field cells_overlapping geometry ---&gt; list&amp;lt;geometry&gt;cells_overlapping (field , geometry) ---&gt; list&amp;lt;geometry&gt;  "},{"title":"centroid​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#centroid","content":"Possible uses:​ centroid (geometry) ---&gt; point  Result:​ Centroid (weighted sum of the centroids of a decomposition of the area into triangles) of the operand-geometry. Can be different to the location of the geometry Examples:​ point var0 &lt;- centroid(world); // var0 equals the centroid of the square, for example : {50.0,50.0}.  See also: any_location_in, closest_points_with, farthest_point_to, points_at,  "},{"title":"char​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#char","content":"Possible uses:​ char (int) ---&gt; string Special cases:​ converts ACSII integer value to character  string var0 &lt;- char (34); // var0 equals '&quot;'   "},{"title":"chi_square​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#chi_square","content":"Possible uses:​ float chi_square float ---&gt; floatchi_square (float , float) ---&gt; float  Result:​ Returns the area under the left hand tail (from 0 to x) of the Chi square probability density function with df degrees of freedom. Examples:​ float var0 &lt;- chi_square(20.0,10) with_precision(3); // var0 equals 0.971   "},{"title":"chi_square_complemented​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#chi_square_complemented","content":"Possible uses:​ float chi_square_complemented float ---&gt; floatchi_square_complemented (float , float) ---&gt; float  Result:​ Returns the area under the right hand tail (from x to infinity) of the Chi square probability density function with df degrees of freedom. Examples:​ float var0 &lt;- chi_square_complemented(2,10) with_precision(3); // var0 equals 0.996   "},{"title":"choose​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#choose","content":"Possible uses:​ choose (string, any GAML type, unknown, list) ---&gt; unknown  Result:​ Allows the user to choose a value by specifying a title, a type, and a list of possible values  "},{"title":"circle​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#circle","content":"Possible uses:​ circle (float) ---&gt; geometryfloat circle point ---&gt; geometrycircle (float , point) ---&gt; geometry  Result:​ A circle geometry which radius is equal to the operand. Comment:​ the center of the circle is by default the location of the current agent in which has been called this operator. Special cases:​ returns a point if the radius operand is lower or equal to 0. When circle is used with 2 operands, the second one is the center of the created circle.  geometry var1 &lt;- circle(10,{80,30}); // var1 equals a geometry as a circle of radius 10, the center will be in the location {80,30}.  Examples:​ geometry var0 &lt;- circle(10); // var0 equals a geometry as a circle of radius 10.  See also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,  "},{"title":"clean​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#clean","content":"Possible uses:​ clean (geometry) ---&gt; geometry  Result:​ A geometry corresponding to the cleaning of the operand (geometry, agent, point) Comment:​ The cleaning corresponds to a buffer with a distance of 0.0 Examples:​ geometry var0 &lt;- clean(self); // var0 equals returns the geometry resulting from the cleaning of the geometry of the agent applying the operator.   "},{"title":"clean_network​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#clean_network","content":"Possible uses:​ clean_network (list&amp;lt;geometry&gt;, float, bool, bool) ---&gt; list&amp;lt;geometry&gt;  Result:​ A list of polylines corresponding to the cleaning of the first operand (list of polyline geometry or agents), considering the tolerance distance given by the second operand; the third operator is used to define if the operator should as well split the lines at their intersections(true to split the lines); the last operandis used to specify if the operator should as well keep only the main connected component of the network. Usage: clean_network(lines:list of geometries or agents, tolerance: float, split_lines: bool, keepMainConnectedComponent: bool) Comment:​ The cleaned set of polylines Examples:​ list&amp;lt;geometry&gt; var0 &lt;- clean_network(my_road_shapefile.contents, 1.0, true, false); // var0 equals returns the list of polulines resulting from the cleaning of the geometry of the agent applying the operator with a tolerance of 1m, and splitting the lines at their intersections. list&amp;lt;geometry&gt; var1 &lt;- clean_network([line({10,10}, {20,20}), line({10,20},{20,10})],3.0,true,false); // var1 equals [line({10.0,20.0,0.0},{15.0,15.0,0.0}),line({15.0,15.0,0.0},{20.0,10.0,0.0}), line({10.0,10.0,0.0},{15.0,15.0,0.0}), line({15.0,15.0,0.0},{20.0,20.0,0.0})]   "},{"title":"closest_points_with​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#closest_points_with","content":"Possible uses:​ geometry closest_points_with geometry ---&gt; list&amp;lt;point&gt;closest_points_with (geometry , geometry) ---&gt; list&amp;lt;point&gt;  Result:​ A list of two closest points between the two geometries. Examples:​ list&amp;lt;point&gt; var0 &lt;- geom1 closest_points_with(geom2); // var0 equals [pt1, pt2] with pt1 the closest point of geom1 to geom2 and pt1 the closest point of geom2 to geom1  See also: any_location_in, any_point_in, farthest_point_to, points_at,  "},{"title":"closest_to​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#closest_to","content":"Possible uses:​ container&amp;lt;unknown,geometry&gt; closest_to geometry ---&gt; geometryclosest_to (container&amp;lt;unknown,geometry&gt; , geometry) ---&gt; geometryclosest_to (container&amp;lt;unknown,geometry&gt;, geometry, int) ---&gt; list&amp;lt;geometry&gt;  Result:​ The N agents or geometries among the left-operand list of agents, species or meta-population (addition of species), that are the closest to the operand (casted as a geometry). An agent or a geometry among the left-operand list of agents, species or meta-population (addition of species), the closest to the operand (casted as a geometry). Comment:​ the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology. Examples:​ list&amp;lt;geometry&gt; var0 &lt;- [ag1, ag2, ag3] closest_to(self, 2); // var0 equals return the 2 closest agents among ag1, ag2 and ag3 to the agent applying the operator. (species1 + species2) closest_to (self, 5) geometry var2 &lt;- [ag1, ag2, ag3] closest_to(self); // var2 equals return the closest agent among ag1, ag2 and ag3 to the agent applying the operator. (species1 + species2) closest_to self  See also: neighbors_at, neighbors_of, inside, overlapping, agents_overlapping, agents_inside, agent_closest_to,  "},{"title":"closest_tob​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#closest_tob","content":"Possible uses:​ container&amp;lt;unknown,geometry&gt; closest_tob geometry ---&gt; geometryclosest_tob (container&amp;lt;unknown,geometry&gt; , geometry) ---&gt; geometry  Result:​ Return the closest agent from a point !! Special cases:​ Return the closest agent from a point !! Examples:​ geometry var0 &lt;- closest_tob(population, point) or list closest_tob geometry; // var0 equals Return the closest agent from a point !!   "},{"title":"collect​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#collect","content":"Possible uses:​ container collect any expression ---&gt; listcollect (container , any expression) ---&gt; list  Result:​ returns a new list, in which each element is the evaluation of the right-hand operand. Comment:​ collect is similar to accumulate except that accumulate always produces flat lists if the right-hand operand returns a list.In addition, collect can be applied to any container. Special cases:​ if the left-hand operand is nil, collect throws an error Examples:​ list var0 &lt;- [1,2,4] collect (each *2); // var0 equals [2,4,8] list var1 &lt;- [1,2,4] collect ([2,4]); // var1 equals [[2,4],[2,4],[2,4]] list var2 &lt;- [1::2, 3::4, 5::6] collect (each + 2); // var2 equals [4,6,8] list var3 &lt;- (list(node) collect (node(each).location.x * 2); // var3 equals the list of nodes with their x multiplied by 2  See also: accumulate,  "},{"title":"column_at​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#column_at","content":"Possible uses:​ matrix&amp;lt;unknown&gt; column_at int ---&gt; list&amp;lt;unknown&gt;column_at (matrix&amp;lt;unknown&gt; , int) ---&gt; list&amp;lt;unknown&gt;  Result:​ returns the column at a num_col (right-hand operand) Examples:​ list&amp;lt;unknown&gt; var0 &lt;- matrix([[&quot;el11&quot;,&quot;el12&quot;,&quot;el13&quot;],[&quot;el21&quot;,&quot;el22&quot;,&quot;el23&quot;],[&quot;el31&quot;,&quot;el32&quot;,&quot;el33&quot;]]) column_at 2; // var0 equals [&quot;el31&quot;,&quot;el32&quot;,&quot;el33&quot;]  See also: row_at, rows_list,  "},{"title":"columns_list​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#columns_list","content":"Possible uses:​ columns_list (matrix&amp;lt;unknown&gt;) ---&gt; list&amp;lt;list&amp;lt;unknown&gt;&gt;  Result:​ returns a list of the columns of the matrix, with each column as a list of elements Examples:​ list&amp;lt;list&amp;lt;unknown&gt;&gt; var0 &lt;- columns_list(matrix([[&quot;el11&quot;,&quot;el12&quot;,&quot;el13&quot;],[&quot;el21&quot;,&quot;el22&quot;,&quot;el23&quot;],[&quot;el31&quot;,&quot;el32&quot;,&quot;el33&quot;]])); // var0 equals [[&quot;el11&quot;,&quot;el12&quot;,&quot;el13&quot;],[&quot;el21&quot;,&quot;el22&quot;,&quot;el23&quot;],[&quot;el31&quot;,&quot;el32&quot;,&quot;el33&quot;]]  See also: rows_list,  "},{"title":"command​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#command","content":"Possible uses:​ command (string) ---&gt; stringstring command string ---&gt; stringcommand (string , string) ---&gt; stringcommand (string, string, map&amp;lt;string,string&gt;) ---&gt; string  Result:​ command allows GAMA to issue a system command using the system terminal or shell and to receive a string containing the outcome of the command or script executed. By default, commands are blocking the agent calling them, unless the sequence ' &amp;' is used at the end. In this case, the result of the operator is an empty string. The basic form with only one string in argument uses the directory of the model and does not set any environment variables. Two other forms (with a directory and a map&lt;string, string&gt; of environment variables) are available.  "},{"title":"cone​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#cone","content":"Possible uses:​ cone (point) ---&gt; geometryint cone int ---&gt; geometrycone (int , int) ---&gt; geometry  Result:​ A cone geometry which min and max angles are given by the operands. Comment:​ the center of the cone is by default the location of the current agent in which has been called this operator. Special cases:​ returns nil if the operand is nil. Examples:​ geometry var0 &lt;- cone(0, 45); // var0 equals a geometry as a cone with min angle is 0 and max angle is 45. geometry var1 &lt;- cone({0, 45}); // var1 equals a geometry as a cone with min angle is 0 and max angle is 45.  See also: around, circle, line, link, norm, point, polygon, polyline, rectangle, square, triangle,  "},{"title":"cone3D​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#cone3d","content":"Possible uses:​ float cone3D float ---&gt; geometrycone3D (float , float) ---&gt; geometry  Result:​ A cone geometry which base radius size is equal to the first operand, and which the height is equal to the second operand. Comment:​ the center of the cone is by default the location of the current agent in which has been called this operator. Special cases:​ returns a point if the operand is lower or equal to 0. Examples:​ geometry var0 &lt;- cone3D(10.0,5.0); // var0 equals a geometry as a cone with a base circle of radius 10 and a height of 5.  See also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,  "},{"title":"connected_components_of​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#connected_components_of","content":"Possible uses:​ connected_components_of (graph) ---&gt; list&amp;lt;list&gt;graph connected_components_of bool ---&gt; list&amp;lt;list&gt;connected_components_of (graph , bool) ---&gt; list&amp;lt;list&gt;  Result:​ returns the connected components of a graph, i.e. the list of all vertices that are in the maximally connected component together with the specified vertex. returns the connected components of a graph, i.e. the list of all edges (if the boolean is true) or vertices (if the boolean is false) that are in the connected components. Examples:​ graph my_graph &lt;- graph([]); list&amp;lt;list&gt; var1 &lt;- connected_components_of (my_graph); // var1 equals the list of all the components as list graph my_graph2 &lt;- graph([]); list&amp;lt;list&gt; var3 &lt;- connected_components_of (my_graph2, true); // var3 equals the list of all the components as list  See also: alpha_index, connectivity_index, nb_cycles,  "},{"title":"connectivity_index​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#connectivity_index","content":"Possible uses:​ connectivity_index (graph) ---&gt; float  Result:​ returns a simple connectivity index. This number is estimated through the number of nodes (v) and of sub-graphs (p) : IC = (v - p) /(v - 1). Examples:​ graph graphEpidemio &lt;- graph([]); float var1 &lt;- connectivity_index(graphEpidemio); // var1 equals the connectivity index of the graph  See also: alpha_index, beta_index, gamma_index, nb_cycles,  "},{"title":"container​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#container","content":"Possible uses:​ container (any) ---&gt; container  Result:​ casts the operand in a container object.  "},{"title":"contains​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#contains","content":"Possible uses:​ string contains string ---&gt; boolcontains (string , string) ---&gt; boolcontainer&amp;lt;KeyType,ValueType&gt; contains unknown ---&gt; boolcontains (container&amp;lt;KeyType,ValueType&gt; , unknown) ---&gt; bool  Result:​ true, if the container contains the right operand, false otherwise. 'contains' can also be written 'contains_value'. On graphs, it is equivalent to calling 'contains_edge' Comment:​ the contains operator behavior depends on the nature of the operand Special cases:​ if both operands are strings, returns true if the right-hand operand contains the right-hand pattern; if it is a map, contains, which can also be written 'contains_value', returns true if the operand is a value of the map if it is a pair, contains_key returns true if the operand is equal to the value of the pair if it is a file, contains returns true it the operand is contained in the file content if it is a population, contains returns true if the operand is an agent of the population, false otherwise if it is a graph, contains can be written 'contains_edge' and returns true if the operand is an edge of the graph, false otherwise (use 'contains_node' for testing the presence of a node) if it is a list or a matrix, contains returns true if the list or matrix contains the right operand  bool var1 &lt;- [1, 2, 3] contains 2; // var1 equals true bool var2 &lt;- [{1,2}, {3,4}, {5,6}] contains {3,4}; // var2 equals true  Examples:​ bool var0 &lt;- 'abcded' contains 'bc'; // var0 equals true  See also: contains_all, contains_any, contains_key,  "},{"title":"contains_all​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#contains_all","content":"Possible uses:​ string contains_all list ---&gt; boolcontains_all (string , list) ---&gt; boolcontainer contains_all container ---&gt; boolcontains_all (container , container) ---&gt; bool  Result:​ true if the left operand contains all the elements of the right operand, false otherwise Comment:​ the definition of contains depends on the container Special cases:​ if the right operand is nil or empty, contains_all returns true if the left-operand is a string, test whether the string contains all the element of the list;  bool var0 &lt;- &quot;abcabcabc&quot; contains_all [&quot;ca&quot;,&quot;xy&quot;]; // var0 equals false  Examples:​ bool var1 &lt;- [1,2,3,4,5,6] contains_all [2,4]; // var1 equals true bool var2 &lt;- [1,2,3,4,5,6] contains_all [2,8]; // var2 equals false bool var3 &lt;- [1::2, 3::4, 5::6] contains_all [1,3]; // var3 equals false bool var4 &lt;- [1::2, 3::4, 5::6] contains_all [2,4]; // var4 equals true  See also: contains, contains_any,  "},{"title":"contains_any​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#contains_any","content":"Possible uses:​ container contains_any container ---&gt; boolcontains_any (container , container) ---&gt; boolstring contains_any list ---&gt; boolcontains_any (string , list) ---&gt; bool  Result:​ true if the left operand contains one of the elements of the right operand, false otherwise Comment:​ the definition of contains depends on the container Special cases:​ if the right operand is nil or empty, contains_any returns false Examples:​ bool var0 &lt;- [1,2,3,4,5,6] contains_any [2,4]; // var0 equals true bool var1 &lt;- [1,2,3,4,5,6] contains_any [2,8]; // var1 equals true bool var2 &lt;- [1::2, 3::4, 5::6] contains_any [1,3]; // var2 equals false bool var3 &lt;- [1::2, 3::4, 5::6] contains_any [2,4]; // var3 equals true bool var4 &lt;- &quot;abcabcabc&quot; contains_any [&quot;ca&quot;,&quot;xy&quot;]; // var4 equals true  See also: contains, contains_all,  "},{"title":"contains_edge​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#contains_edge","content":"Possible uses:​ graph contains_edge unknown ---&gt; boolcontains_edge (graph , unknown) ---&gt; boolgraph contains_edge pair ---&gt; boolcontains_edge (graph , pair) ---&gt; bool  Result:​ returns true if the graph(left-hand operand) contains the given edge (righ-hand operand), false otherwise Special cases:​ if the left-hand operand is nil, returns false if the right-hand operand is a pair, returns true if it exists an edge between the two elements of the pair in the graph  bool var2 &lt;- graphEpidemio contains_edge (node(0)::node(3)); // var2 equals true  Examples:​ graph graphFromMap &lt;- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); bool var1 &lt;- graphFromMap contains_edge link({1,5},{12,45}); // var1 equals true  See also: contains_vertex,  "},{"title":"contains_key​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#contains_key","content":"Possible uses:​ container&amp;lt;KeyType,ValueType&gt; contains_key unknown ---&gt; boolcontains_key (container&amp;lt;KeyType,ValueType&gt; , unknown) ---&gt; bool  Result:​ true, if the left-hand operand -- the container -- contains a key -- or an index -- equal to the right-hand operand, false otherwise. On graphs, 'contains_key' is equivalent to calling 'contains_vertex' Comment:​ the behavior of contains_key depends on the nature of the container Special cases:​ if it is a map, contains_key returns true if the operand is a key of the map if it is a pair, contains_key returns true if the operand is equal to the key of the pair if it is a matrix, contains_key returns true if the point operand is a valid index of the matrix (i.e. &gt;= {0,0} and &lt; {rows, col}) if it is a file, contains_key is applied to the file contents -- a container if it is a graph, contains_key returns true if the graph contains the corresponding vertex if it is a list, contains_key returns true if the right-hand operand is an integer and if it is a valid index (i.e. &gt;= 0 and &lt; length)  bool var0 &lt;- [1, 2, 3] contains_key 3; // var0 equals false bool var1 &lt;- [{1,2}, {3,4}, {5,6}] contains_key 0; // var1 equals true  See also: contains_all, contains, contains_any,  "},{"title":"contains_node​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#contains_node","content":"Same signification as contains_key  "},{"title":"contains_value​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#contains_value","content":"Same signification as contains  "},{"title":"contains_vertex​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#contains_vertex","content":"Possible uses:​ graph contains_vertex unknown ---&gt; boolcontains_vertex (graph , unknown) ---&gt; bool  Result:​ returns true if the graph(left-hand operand) contains the given vertex (righ-hand operand), false otherwise Special cases:​ if the left-hand operand is nil, returns false Examples:​ graph graphFromMap&lt;- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); bool var1 &lt;- graphFromMap contains_vertex {1,5}; // var1 equals true  See also: contains_edge,  "},{"title":"conversation​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#conversation","content":"Possible uses:​ conversation (unknown) ---&gt; conversation  "},{"title":"convex_hull​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#convex_hull","content":"Possible uses:​ convex_hull (geometry) ---&gt; geometry  Result:​ A geometry corresponding to the convex hull of the operand. Examples:​ geometry var0 &lt;- convex_hull(self); // var0 equals the convex hull of the geometry of the agent applying the operator   "},{"title":"copy​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#copy","content":"Possible uses:​ copy (unknown) ---&gt; unknown  Result:​ returns a copy of the operand.  "},{"title":"copy_between​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#copy_between","content":"Possible uses:​ copy_between (string, int, int) ---&gt; stringcopy_between (list, int, int) ---&gt; list  Result:​ Returns a copy of the first operand between the indexes determined by the second (inclusive) and third operands (exclusive) Special cases:​ If the first operand is empty, returns an empty object of the same type If the second operand is greater than or equal to the third operand, return an empty object of the same type If the first operand is nil, raises an error Examples:​ string var0 &lt;- copy_between(&quot;abcabcabc&quot;, 2,6); // var0 equals &quot;cabc&quot; list var1 &lt;- copy_between ([4, 1, 6, 9 ,7], 1, 3); // var1 equals [1, 6]   "},{"title":"copy_file​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#copy_file","content":"Possible uses:​ string copy_file string ---&gt; boolcopy_file (string , string) ---&gt; boolcopy_file (string, string, bool) ---&gt; bool  Result:​ copy a file or a folder copy a file or a folder Examples:​ bool copy_file_ok &lt;- copy_file(&quot;../includes/my_folder&quot;,&quot;../includes/my_new_folder&quot;,true); bool copy_file_ok &lt;- copy_file(&quot;../includes/my_folder&quot;,&quot;../includes/my_new_folder&quot;);   "},{"title":"copy_to_clipboard​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#copy_to_clipboard","content":"Possible uses:​ copy_to_clipboard (string) ---&gt; bool  Result:​ Tries to copy the text in parameter to the clipboard and returns whether it has been correctly copied or not (for instance it might be impossible in a headless environment) Examples:​ bool copied &lt;- copy_to_clipboard('text to copy');   "},{"title":"correlation​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#correlation","content":"Possible uses:​ container correlation container ---&gt; floatcorrelation (container , container) ---&gt; float  Result:​ Returns the correlation of two data sequences (having the same size) Examples:​ float var0 &lt;- correlation([1,2,1,3,1,2], [1,2,1,3,1,2]) with_precision(4); // var0 equals 1.2 float var1 &lt;- correlation([13,2,1,4,1,2], [1,2,1,3,1,2]) with_precision(2); // var1 equals -0.21   "},{"title":"cos​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#cos","content":"Possible uses:​ cos (int) ---&gt; floatcos (float) ---&gt; float  Result:​ Returns the value (in [-1,1]) of the cosinus of the operand (in decimal degrees). The argument is casted to an int before being evaluated. Special cases:​ Operand values out of the range [0-359] are normalized. Examples:​ float var0 &lt;- cos (0); // var0 equals 1.0 float var1 &lt;- cos(360); // var1 equals 1.0 float var2 &lt;- cos(-720); // var2 equals 1.0 float var3 &lt;- cos (0.0); // var3 equals 1.0 float var4 &lt;- cos(360.0); // var4 equals 1.0 float var5 &lt;- cos(-720.0); // var5 equals 1.0  See also: sin, tan,  "},{"title":"cos_rad​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#cos_rad","content":"Possible uses:​ cos_rad (float) ---&gt; float  Result:​ Returns the value (in [-1,1]) of the cosinus of the operand (in radians). Special cases:​ Operand values out of the range [0-359] are normalized. Examples:​ float var0 &lt;- cos_rad(0.0); // var0 equals 1.0 float var1 &lt;- cos_rad(#pi); // var1 equals -1.0  See also: sin, tan,  "},{"title":"count​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#count","content":"Possible uses:​ container count any expression ---&gt; intcount (container , any expression) ---&gt; int  Result:​ returns an int, equal to the number of elements of the left-hand operand that make the right-hand operand evaluate to true. Comment:​ in the right-hand operand, the keyword each can be used to represent, in turn, each of the elements. Special cases:​ if the left-hand operand is nil, count throws an error Examples:​ int var0 &lt;- [1,2,3,4,5,6,7,8] count (each &gt; 3); // var0 equals 5 // Number of nodes of graph g2 without any out edge graph g2 &lt;- graph([]); int var3 &lt;- g2 count (length(g2 out_edges_of each) = 0 ) ; // var3 equals the total number of out edges // Number of agents node with x &gt; 32 int n &lt;- (list(node) count (round(node(each).location.x) &gt; 32); int var6 &lt;- [1::2, 3::4, 5::6] count (each &gt; 4); // var6 equals 1  See also: group_by,  "},{"title":"covariance​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#covariance","content":"Possible uses:​ container covariance container ---&gt; floatcovariance (container , container) ---&gt; float  Result:​ Returns the covariance of two data sequences Examples:​ float var0 &lt;- covariance([13,2,1,4,1,2], [1,2,1,3,1,2]) with_precision(2); // var0 equals -0.67   "},{"title":"covering​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#covering","content":"Possible uses:​ container&amp;lt;unknown,geometry&gt; covering geometry ---&gt; list&amp;lt;geometry&gt;covering (container&amp;lt;unknown,geometry&gt; , geometry) ---&gt; list&amp;lt;geometry&gt;  Result:​ A list of agents or geometries among the left-operand list, species or meta-population (addition of species), covering the operand (casted as a geometry). Examples:​ list&amp;lt;geometry&gt; var0 &lt;- [ag1, ag2, ag3] covering(self); // var0 equals the agents among ag1, ag2 and ag3 that cover the shape of the right-hand argument. list&amp;lt;geometry&gt; var1 &lt;- (species1 + species2) covering (self); // var1 equals the agents among species species1 and species2 that covers the shape of the right-hand argument.  See also: neighbors_at, neighbors_of, closest_to, overlapping, agents_overlapping, inside, agents_inside, agent_closest_to,  "},{"title":"covers​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#covers","content":"Possible uses:​ geometry covers geometry ---&gt; boolcovers (geometry , geometry) ---&gt; bool  Result:​ A boolean, equal to true if the left-geometry (or agent/point) covers the right-geometry (or agent/point). Special cases:​ if one of the operand is null, returns false. Examples:​ bool var0 &lt;- square(5) covers square(2); // var0 equals true  See also: disjoint_from, crosses, overlaps, partially_overlaps, touches,  "},{"title":"create_map​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#create_map","content":"Possible uses:​ list create_map list ---&gt; mapcreate_map (list , list) ---&gt; map  Result:​ returns a new map using the left operand as keys for the right operand Special cases:​ if the left operand contains duplicates, create_map throws an error. if both operands have different lengths, choose the minimum length between the two operandsfor the size of the map Examples:​ map&amp;lt;int,string&gt; var0 &lt;- create_map([0,1,2],['a','b','c']); // var0 equals [0::'a',1::'b',2::'c'] map&amp;lt;int,float&gt; var1 &lt;- create_map([0,1],[0.1,0.2,0.3]); // var1 equals [0::0.1,1::0.2] map&amp;lt;string,float&gt; var2 &lt;- create_map(['a','b','c','d'],[1.0,2.0,3.0]); // var2 equals ['a'::1.0,'b'::2.0,'c'::3.0]   "},{"title":"cross​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#cross","content":"Possible uses:​ cross (float) ---&gt; geometryfloat cross float ---&gt; geometrycross (float , float) ---&gt; geometry  Result:​ A cross, which radius is equal to the first operand (and eventually the width of the lines for the second) Examples:​ geometry var0 &lt;- cross(10); // var0 equals a geometry as a cross of radius 10 geometry var1 &lt;- cross(10,2); // var1 equals a geometry as a cross of radius 10, and with a width of 2 for the lines  See also: around, cone, line, link, norm, point, polygon, polyline, super_ellipse, rectangle, square, circle, ellipse, triangle,  "},{"title":"crosses​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#crosses","content":"Possible uses:​ geometry crosses geometry ---&gt; boolcrosses (geometry , geometry) ---&gt; bool  Result:​ A boolean, equal to true if the left-geometry (or agent/point) crosses the right-geometry (or agent/point). Special cases:​ if one of the operand is null, returns false. if one operand is a point, returns false. Examples:​ bool var0 &lt;- polyline([{10,10},{20,20}]) crosses polyline([{10,20},{20,10}]); // var0 equals true bool var1 &lt;- polyline([{10,10},{20,20}]) crosses {15,15}; // var1 equals true bool var2 &lt;- polyline([{0,0},{25,25}]) crosses polygon([{10,10},{10,20},{20,20},{20,10}]); // var2 equals true  See also: disjoint_from, intersects, overlaps, partially_overlaps, touches,  "},{"title":"crossing​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#crossing","content":"Possible uses:​ container&amp;lt;unknown,geometry&gt; crossing geometry ---&gt; list&amp;lt;geometry&gt;crossing (container&amp;lt;unknown,geometry&gt; , geometry) ---&gt; list&amp;lt;geometry&gt;  Result:​ A list of agents or geometries among the left-operand list, species or meta-population (addition of species), crossing the operand (casted as a geometry). Examples:​ list&amp;lt;geometry&gt; var0 &lt;- [ag1, ag2, ag3] crossing(self); // var0 equals the agents among ag1, ag2 and ag3 that cross the shape of the right-hand argument. list&amp;lt;geometry&gt; var1 &lt;- (species1 + species2) crossing (self); // var1 equals the agents among species species1 and species2 that cross the shape of the right-hand argument.  See also: neighbors_at, neighbors_of, closest_to, overlapping, agents_overlapping, inside, agents_inside, agent_closest_to,  "},{"title":"crs​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#crs","content":"Possible uses:​ crs (file) ---&gt; string  Result:​ the Coordinate Reference System (CRS) of the GIS file Examples:​ string var0 &lt;- crs(my_shapefile); // var0 equals the crs of the shapefile   "},{"title":"CRS_transform​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#crs_transform","content":"Possible uses:​ CRS_transform (geometry) ---&gt; geometrygeometry CRS_transform string ---&gt; geometryCRS_transform (geometry , string) ---&gt; geometryCRS_transform (geometry, string, string) ---&gt; geometry Special cases:​ returns the geometry corresponding to the transformation of the given geometry from the first CRS to the second CRS (Coordinate Reference System)  geometry var0 &lt;- {8.35,47.22} CRS_transform(&quot;EPSG:4326&quot;,&quot;EPSG:4326&quot;); // var0 equals {929517.7481238344,5978057.894895313,0.0}  returns the geometry corresponding to the transformation of the given geometry by the current CRS (Coordinate Reference System), the one corresponding to the world's agent one  geometry var1 &lt;- CRS_transform(shape); // var1 equals a geometry corresponding to the agent geometry transformed into the current CRS  returns the geometry corresponding to the transformation of the given geometry by the left operand CRS (Coordinate Reference System)  geometry var2 &lt;- shape CRS_transform(&quot;EPSG:4326&quot;); // var2 equals a geometry corresponding to the agent geometry transformed into the EPSG:4326 CRS   "},{"title":"csv_file​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#csv_file","content":"Possible uses:​ csv_file (string) ---&gt; filestring csv_file bool ---&gt; filecsv_file (string , bool) ---&gt; filestring csv_file string ---&gt; filecsv_file (string , string) ---&gt; filestring csv_file matrix&amp;lt;unknown&gt; ---&gt; filecsv_file (string , matrix&amp;lt;unknown&gt;) ---&gt; filecsv_file (string, string, bool) ---&gt; filecsv_file (string, string, any GAML type) ---&gt; filecsv_file (string, string, string, bool) ---&gt; filecsv_file (string, string, string, any GAML type) ---&gt; filecsv_file (string, string, any GAML type, bool) ---&gt; filecsv_file (string, string, any GAML type, point) ---&gt; file  Result:​ Constructs a file of type csv. Allowed extensions are limited to csv, tsv Special cases:​ csv_file(string): This file constructor allows to read a CSV file with the default separator (coma), no header, and no assumption on the type of data. No text qualifier will be used  csv_file f &lt;- csv_file(&quot;file.csv&quot;);  csv_file(string,bool): This file constructor allows to read a CSV file with the default separator (coma), with specifying if the model has a header or not (boolean), and no assumption on the type of data. No text qualifier will be used  csv_file f &lt;- csv_file(&quot;file.csv&quot;,true);  csv_file(string,string): This file constructor allows to read a CSV file and specify the separator used, without making any assumption on the type of data. Headers should be detected automatically if they exist. No text qualifier will be used  csv_file f &lt;- csv_file(&quot;file.csv&quot;, &quot;;&quot;);  csv_file(string,string,bool): This file constructor allows to read a CSV file and specify (1) the separator used; (2) if the model has a header or not, without making any assumption on the type of data. No text qualifier will be used  csv_file f &lt;- csv_file(&quot;file.csv&quot;, &quot;;&quot;,true);  csv_file(string,string,string,bool): This file constructor allows to read a CSV file and specify (1) the separator used; (2) the text qualifier used; (3) if the model has a header or not, without making any assumption on the type of data  csv_file f &lt;- csv_file(&quot;file.csv&quot;, ';', '&quot;', true);  csv_file(string,string,any GAML type): This file constructor allows to read a CSV file with a given separator, no header, and the type of data. No text qualifier will be used  csv_file f &lt;- csv_file(&quot;file.csv&quot;, &quot;;&quot;,int);  csv_file(string,string,string,any GAML type): This file constructor allows to read a CSV file and specify the separator, text qualifier to use, and the type of data to read. Headers should be detected automatically if they exist.  csv_file f &lt;- csv_file(&quot;file.csv&quot;, ';', '&quot;', int);  csv_file(string,string,any GAML type,bool): This file constructor allows to read a CSV file with a given separator, the type of data, with specifying if the model has a header or not (boolean). No text qualifier will be used  csv_file f &lt;- csv_file(&quot;file.csv&quot;, &quot;;&quot;,int,true);  csv_file(string,string,any GAML type,point): This file constructor allows to read a CSV file with a given separator, the type of data, with specifying the number of cols and rows taken into account. No text qualifier will be used  csv_file f &lt;- csv_file(&quot;file.csv&quot;, &quot;;&quot;,int,true, {5, 100});  csv_file(string,matrix&lt;unknown&gt;): This file constructor allows to store a matrix in a CSV file (it does not save it - just store it in memory),  csv_file f &lt;- csv_file(&quot;file.csv&quot;, matrix([10,10],[10,10]));  See also: is_csv,  "},{"title":"cube​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#cube","content":"Possible uses:​ cube (float) ---&gt; geometry  Result:​ A cube geometry which side size is equal to the operand. Comment:​ the center of the cube is by default the location of the current agent in which has been called this operator. Special cases:​ returns nil if the operand is nil. Examples:​ geometry var0 &lt;- cube(10); // var0 equals a geometry as a square of side size 10.  See also: around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, triangle,  "},{"title":"curve​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#curve","content":"Possible uses:​ curve (point, point, point) ---&gt; geometrycurve (point, point, float) ---&gt; geometrycurve (point, point, point, int) ---&gt; geometrycurve (point, point, point, point) ---&gt; geometrycurve (point, point, float, float) ---&gt; geometrycurve (point, point, float, bool) ---&gt; geometrycurve (point, point, point, point, int) ---&gt; geometrycurve (point, point, float, bool, int) ---&gt; geometrycurve (point, point, float, int, float) ---&gt; geometrycurve (point, point, float, int, float, float) ---&gt; geometrycurve (point, point, float, bool, int, float) ---&gt; geometry  Result:​ The operator computes a Bezier curve geometry between the given operators, with 10 or a given number of points, and from left to rigth or right to left. Special cases:​ if one of the operand is nil, returns nil When used with 2 points, a float coefficient, a boolean, an integer number of points, a float proportion, and a float angle, it computes a cubic Bezier curve geometry built from the two given points with the given coefficient for the radius and composed of the given number of points, considering the given inflection point (between 0.0 and 1.0 - default 0.5), and the given rotation angle (90 = along the z axis).  geometry var0 &lt;- curve({0,0},{10,10}, 0.5, 100, 0.8, 90); // var0 equals a cubic Bezier curve geometry composed of 100 points from p0 to p1 at the right side.  When used with 2 points, a float coefficient, a boolean, an integer number of points, and a float proportion, it computes a cubic Bezier curve geometry built from the two given points with the given coefficient for the radius and composed of the given number of points - the boolean is used to specified if it is the right side and the last value to indicate where is the inflection point (between 0.0 and 1.0 - default 0.5).  geometry var1 &lt;- curve({0,0},{10,10}, 0.5, false, 100, 0.8); // var1 equals a cubic Bezier curve geometry composed of 100 points from p0 to p1 at the right side.  When used with 3 points and an integer, it computes a quadratic Bezier curve geometry built from the three given points. If the last operand (number of points) is inferior to 2, returns nil  geometry var2 &lt;- curve({0,0}, {0,10}, {10,10}, 20); // var2 equals a quadratic Bezier curve geometry composed of 20 points from p0 to p2.  When used with 3 points, it computes a quadratic Bezier curve geometry built from the three given points and composed of 10 points.  geometry var3 &lt;- curve({0,0}, {0,10}, {10,10}); // var3 equals a quadratic Bezier curve geometry composed of 10 points from p0 to p2.  When used with 4 points, it computes, it computes a cubic Bezier curve geometry built from the four given points and composed of 10 points.  geometry var4 &lt;- curve({0,0}, {0,10}, {10,10}); // var4 equals a cubic Bezier curve geometry composed of 10 points from p0 to p3.  When used with 2 points, a float coefficient, and a float angle, it computes a cubic Bezier curve geometry built from the two given points with the given coefficient for the radius considering the given rotation angle (90 = along the z axis).  geometry var5 &lt;- curve({0,0},{10,10}, 0.5, 90); // var5 equals a cubic Bezier curve geometry composed of 100 points from p0 to p1 at the right side.  When used with 4 points and an integer number of points, it computes a cubic Bezier curve geometry built from the four given points composed of a given number of points. If the number of points is lower than 2, it returns nil.  geometry var6 &lt;- curve({0,0}, {0,10}, {10,10}); // var6 equals a cubic Bezier curve geometry composed of 10 points from p0 to p3.  When used with 2 points, a float coefficient, a boolean, and an integer number of points, it computes a cubic Bezier curve geometry built from the two given points with the given coefficient for the radius and composed of the given number of points - the boolean is used to specified if it is the right side.  geometry var7 &lt;- curve({0,0},{10,10}, 0.5, false, 100); // var7 equals a cubic Bezier curve geometry composed of 100 points from p0 to p1 at the right side.  When used with 2 points, a float coefficient, a boolean, an integer number of points, and a float angle, it computes a cubic Bezier curve geometry built from the two given points with the given coefficient for the radius and composed of the given number of points, considering the given rotation angle (90 = along the z axis).  geometry var8 &lt;- curve({0,0},{10,10}, 0.5, 100, 90); // var8 equals a cubic Bezier curve geometry composed of 100 points from p0 to p1 at the right side.  When used with 2 points and a float coefficient, it computes a cubic Bezier curve geometry built from the two given points with the given coefficient for the radius and composed of 10 points.  geometry var9 &lt;- curve({0,0},{10,10}, 0.5); // var9 equals a cubic Bezier curve geometry composed of 10 points from p0 to p1.  When used with 2 points, a float coefficient and a boolean, it computes a cubic Bezier curve geometry built from the two given points with the given coefficient for the radius and composed of 10 points. The last boolean is used to specified if it is the right side.  geometry var10 &lt;- curve({0,0},{10,10}, 0.5, false); // var10 equals a cubic Bezier curve geometry composed of 10 points from p0 to p1 at the left side.  See also: around, circle, cone, link, norm, point, polygone, rectangle, square, triangle, line,  "},{"title":"cylinder​","type":1,"pageTitle":"Operators (B to C)","url":"wiki/OperatorsBC#cylinder","content":"Possible uses:​ float cylinder float ---&gt; geometrycylinder (float , float) ---&gt; geometry  Result:​ A cylinder geometry which radius is equal to the operand. Comment:​ the center of the cylinder is by default the location of the current agent in which has been called this operator. Special cases:​ returns a point if the operand is lower or equal to 0. Examples:​ geometry var0 &lt;- cylinder(10,10); // var0 equals a geometry as a circle of radius 10.  See also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle, "},{"title":"Operators (A to A)","type":0,"sectionRef":"#","url":"wiki/OperatorsAA","content":"","keywords":""},{"title":"Definition​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#definition","content":"Operators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function. Most of them use a classical prefixed functional syntax (i.e. operator_name(operand1, operand2, operand3), see below), with the exception of arithmetic (e.g. +, /), logical (and, or), comparison (e.g. &gt;, &lt;), access (., [..]) and pair (::) operators, which require an infixed notation (i.e. operand1 operator_symbol operand1). The ternary functional if-else operator, ? :, uses a special infixed syntax composed with two symbols (e.g. operand1 ? operand2 : operand3). Two unary operators (- and !) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g. - 10, ! (operand1 or operand2)). Finally, special constructor operators ({...} for constructing points, [...] for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. {1,2,3}, [operand1, operand2, ..., operandn] or [key1::value1, key2::value2... keyn::valuen]). With the exception of these special cases above, the following rules apply to the syntax of operators: if they only have one operand, the functional prefixed syntax is mandatory (e.g. operator_name(operand1))if they have two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2)) or the infixed syntax (e.g. operand1 operator_name operand2) can be used.if they have more than two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2, ..., operand)) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. operand1 operator_name(operand2, ..., operand)) can be used. All of these alternative syntaxes are completely equivalent. Operators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.  "},{"title":"Priority between operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#priority-between-operators","content":"The priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first. GAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely: the constructor operators, like ::, used to compose pairs of operands, have the lowest priority of all operators (e.g. a &gt; b :: b &gt; c will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, [a &gt; 10, b &gt; 5] will return a list of boolean values.it is followed by the ?: operator, the functional if-else (e.g. a &gt; b ? a + 10 : a - 10 will return the result of the if-else).next are the logical operators, and and or (e.g. a &gt; b or b &gt; c will return the value of the test)next are the comparison operators (i.e. &gt;, &lt;, &lt;=, &gt;=, =, !=)next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)next the unary operators - and !next the access operators . and [] (e.g. {1,2,3}.x &gt; 20 + {4,5,6}.y will return the result of the comparison between the x and y ordinates of the two points)and finally the functional operators, which have the highest priority of all.  "},{"title":"Using actions as operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#using-actions-as-operators","content":"Actions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand. For instance, if the following species is defined: species spec1 { int min(int x, int y) { return x &gt; y ? x : y; } }  Any agent instance of spec1 can use min as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable: global { init { create spec1; spec1 my_agent &lt;- spec1[0]; int the_min &lt;- my_agent min(10,20); // or min(my_agent, 10, 20); } }  If the action doesn't have any operands, the syntax to use is my_agent the_action(). Finally, if it does not return a value, it might still be used but is considering as returning a value of type unknown (e.g. unknown result &lt;- my_agent the_action(op1, op2);). Note that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).  "},{"title":"Table of Contents​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#table-of-contents","content":" "},{"title":"Operators by categories​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#operators-by-categories","content":" "},{"title":"3D​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#3d","content":"box, cone3D, cube, cylinder, hexagon, pyramid, set_z, sphere, teapot,  "},{"title":"Arithmetic operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#arithmetic-operators","content":"-, /, ^, *, +, abs, acos, asin, atan, atan2, ceil, cos, cos_rad, div, even, exp, fact, floor, hypot, is_finite, is_number, ln, log, mod, round, signum, sin, sin_rad, sqrt, tan, tan_rad, tanh, with_precision,  "},{"title":"BDI​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#bdi","content":"add_values, and, eval_when, get_about, get_agent, get_agent_cause, get_belief_op, get_belief_with_name_op, get_beliefs_op, get_beliefs_with_name_op, get_current_intention_op, get_decay, get_desire_op, get_desire_with_name_op, get_desires_op, get_desires_with_name_op, get_dominance, get_familiarity, get_ideal_op, get_ideal_with_name_op, get_ideals_op, get_ideals_with_name_op, get_intensity, get_intention_op, get_intention_with_name_op, get_intentions_op, get_intentions_with_name_op, get_lifetime, get_liking, get_modality, get_obligation_op, get_obligation_with_name_op, get_obligations_op, get_obligations_with_name_op, get_plan_name, get_predicate, get_solidarity, get_strength, get_super_intention, get_trust, get_truth, get_uncertainties_op, get_uncertainties_with_name_op, get_uncertainty_op, get_uncertainty_with_name_op, get_values, has_belief_op, has_belief_with_name_op, has_desire_op, has_desire_with_name_op, has_ideal_op, has_ideal_with_name_op, has_intention_op, has_intention_with_name_op, has_obligation_op, has_obligation_with_name_op, has_uncertainty_op, has_uncertainty_with_name_op, new_emotion, new_mental_state, new_predicate, new_social_link, not, or, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_lifetime, set_liking, set_modality, set_predicate, set_solidarity, set_strength, set_trust, set_truth, with_values,  "},{"title":"Casting operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#casting-operators","content":"as, as_int, as_matrix, font, is, is_skill, list_with, matrix_with, species, to_gaml, topology,  "},{"title":"Color-related operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#color-related-operators","content":"-, /, *, +, blend, brewer_colors, brewer_palettes, gradient, grayscale, hsb, mean, median, palette, rgb, rnd_color, scale, sum,  "},{"title":"Comparison operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#comparison-operators","content":"!=, &lt;, &lt;=, =, &gt;, &gt;=, between,  "},{"title":"Containers-related operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#containers-related-operators","content":"-, ::, +, accumulate, all_match, among, at, cartesian_product, collect, contains, contains_all, contains_any, contains_key, count, empty, every, first, first_with, get, group_by, in, index_by, inter, interleave, internal_integrated_value, last, last_with, length, max, max_of, mean, mean_of, median, min, min_of, mul, none_matches, one_matches, one_of, product_of, range, remove_duplicates, reverse, shuffle, sort_by, split, split_in, split_using, sum, sum_of, union, variance_of, where, with_max_of, with_min_of,  "},{"title":"Date-related operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#date-related-operators","content":"-, !=, +, &lt;, &lt;=, =, &gt;, &gt;=, after, before, between, every, milliseconds_between, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_weeks, minus_years, months_between, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_weeks, plus_years, since, to, until, years_between,  "},{"title":"Dates​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#dates","content":" "},{"title":"Displays​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#displays","content":"horizontal, stack, vertical,  "},{"title":"edge​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#edge","content":"edge_between, strahler,  "},{"title":"EDP-related operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#edp-related-operators","content":"diff, diff2,  "},{"title":"Files-related operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#files-related-operators","content":"copy_file, crs, csv_file, delete_file, dxf_file, evaluate_sub_model, file_exists, folder, folder_exists, gaml_file, geojson_file, get, gif_file, gml_file, graph6_file, graphdimacs_file, graphdot_file, graphgexf_file, graphgml_file, graphml_file, graphtsplib_file, grid_file, image_file, is_csv, is_dxf, is_gaml, is_geojson, is_gif, is_gml, is_graph6, is_graphdimacs, is_graphdot, is_graphgexf, is_graphgml, is_graphml, is_graphtsplib, is_grid, is_image, is_json, is_obj, is_osm, is_pgm, is_property, is_saved_simulation, is_shape, is_svg, is_text, is_threeds, is_xml, json_file, new_folder, obj_file, osm_file, pgm_file, property_file, read, rename_file, saved_simulation_file, shape_file, step_sub_model, svg_file, text_file, threeds_file, unzip, writable, xml_file, zip,  "},{"title":"FIPA-related operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#fipa-related-operators","content":"conversation, message,  "},{"title":"GamaMaterialType​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#gamamaterialtype","content":"material,  "},{"title":"GamaMetaType​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#gamametatype","content":"type_of,  "},{"title":"Gen*​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#gen","content":"add_attribute, add_census_file, add_mapper, add_marginals, add_range_attribute, with_generation_algo,  "},{"title":"Graphs-related operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#graphs-related-operators","content":"add_edge, add_node, adjacency, agent_from_geometry, all_pairs_shortest_path, alpha_index, as_distance_graph, as_edge_graph, as_intersection_graph, as_path, as_spatial_graph, beta_index, betweenness_centrality, biggest_cliques_of, connected_components_of, connectivity_index, contains_edge, contains_vertex, degree_of, directed, edge, edge_between, edge_betweenness, edges, gamma_index, generate_barabasi_albert, generate_complete_graph, generate_random_graph, generate_watts_strogatz, girvan_newman_clustering, grid_cells_to_graph, in_degree_of, in_edges_of, k_spanning_tree_clustering, label_propagation_clustering, layout_circle, layout_force, layout_force_FR, layout_force_FR_indexed, layout_grid, load_shortest_paths, main_connected_component, max_flow_between, maximal_cliques_of, nb_cycles, neighbors_of, node, nodes, out_degree_of, out_edges_of, path_between, paths_between, predecessors_of, remove_node_from, rewire_n, source_of, spatial_graph, strahler, successors_of, sum, target_of, undirected, use_cache, weight_of, with_k_shortest_path_algorithm, with_shortest_path_algorithm, with_weights,  "},{"title":"Grid-related operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#grid-related-operators","content":"as_4_grid, as_grid, as_hexagonal_grid, cell_at, cells_in, cells_overlapping, field, grid_at, neighbors_of, path_between, points_in, values_in,  "},{"title":"Iterator operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#iterator-operators","content":"accumulate, all_match, as_map, collect, count, create_map, first_with, frequency_of, group_by, index_by, last_with, max_of, mean_of, min_of, none_matches, one_matches, product_of, sort_by, sum_of, variance_of, where, where, where, with_max_of, with_min_of,  "},{"title":"List-related operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#list-related-operators","content":"all_indexes_of, copy_between, index_of, last_index_of,  "},{"title":"Logical operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#logical-operators","content":":, !, ?, add_3Dmodel, add_geometry, add_icon, and, or, xor,  "},{"title":"Map comparaison operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#map-comparaison-operators","content":"fuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,  "},{"title":"Map-related operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#map-related-operators","content":"as_map, create_map, index_of, last_index_of,  "},{"title":"Matrix-related operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#matrix-related-operators","content":"-, /, ., *, +, append_horizontally, append_vertically, column_at, columns_list, determinant, eigenvalues, index_of, inverse, last_index_of, row_at, rows_list, shuffle, trace, transpose,  "},{"title":"multicriteria operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#multicriteria-operators","content":"electre_DM, evidence_theory_DM, fuzzy_choquet_DM, promethee_DM, weighted_means_DM,  "},{"title":"Path-related operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#path-related-operators","content":"agent_from_geometry, all_pairs_shortest_path, as_path, load_shortest_paths, max_flow_between, path_between, path_to, paths_between, use_cache,  "},{"title":"Points-related operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#points-related-operators","content":"-, /, *, +, &lt;, &lt;=, &gt;, &gt;=, add_point, angle_between, any_location_in, centroid, closest_points_with, farthest_point_to, grid_at, norm, points_along, points_at, points_on,  "},{"title":"Random operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#random-operators","content":"binomial, flip, gamma_density, gamma_rnd, gamma_trunc_rnd, gauss, generate_terrain, lognormal_density, lognormal_rnd, lognormal_trunc_rnd, poisson, rnd, rnd_choice, sample, shuffle, skew_gauss, truncated_gauss, weibull_density, weibull_rnd, weibull_trunc_rnd,  "},{"title":"ReverseOperators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#reverseoperators","content":"restore_simulation, restore_simulation_from_file, save_simulation, serialize, serialize_agent,  "},{"title":"Shape​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#shape","content":"arc, box, circle, cone, cone3D, cross, cube, curve, cylinder, ellipse, elliptical_arc, envelope, geometry_collection, hexagon, line, link, plan, polygon, polyhedron, pyramid, rectangle, sphere, square, squircle, teapot, triangle,  "},{"title":"Spatial operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#spatial-operators","content":"-, *, +, add_point, agent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, angle_between, any_location_in, arc, around, as_4_grid, as_driving_graph, as_grid, as_hexagonal_grid, at_distance, at_location, box, centroid, circle, clean, clean_network, closest_points_with, closest_to, closest_tob, cone, cone3D, convex_hull, covering, covers, cross, crosses, crossing, crs, CRS_transform, cube, curve, cylinder, direction_between, disjoint_from, distance_between, distance_to, ellipse, elliptical_arc, envelope, farthest_point_to, farthest_to, geometry_collection, gini, hexagon, hierarchical_clustering, IDW, inside, inter, intersects, inverse_rotation, line, link, masked_by, moran, neighbors_at, neighbors_of, normalized_rotation, overlapping, overlaps, partially_overlapping, partially_overlaps, path_between, path_to, plan, points_along, points_at, points_on, polygon, polyhedron, pyramid, rectangle, rotated_by, rotation_composition, round, scaled_to, set_z, simple_clustering_by_distance, simplification, skeletonize, smooth, sphere, split_at, split_geometry, split_lines, square, squircle, teapot, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, touches, touching, towards, transformed_by, translated_by, triangle, triangulate, union, using, voronoi, with_precision, without_holes,  "},{"title":"Spatial properties operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#spatial-properties-operators","content":"covers, crosses, intersects, partially_overlaps, touches,  "},{"title":"Spatial queries operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#spatial-queries-operators","content":"agent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, at_distance, closest_to, covering, crossing, farthest_to, inside, neighbors_at, neighbors_of, overlapping, partially_overlapping, touching,  "},{"title":"Spatial relations operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#spatial-relations-operators","content":"direction_between, distance_between, distance_to, path_between, path_to, towards,  "},{"title":"Spatial statistical operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#spatial-statistical-operators","content":"hierarchical_clustering, simple_clustering_by_distance,  "},{"title":"Spatial transformations operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#spatial-transformations-operators","content":"-, *, +, as_4_grid, as_grid, as_hexagonal_grid, at_location, clean, clean_network, convex_hull, CRS_transform, inverse_rotation, normalized_rotation, rotated_by, rotation_composition, scaled_to, simplification, skeletonize, smooth, split_geometry, split_lines, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, transformed_by, translated_by, triangulate, voronoi, with_precision, without_holes,  "},{"title":"Species-related operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#species-related-operators","content":"index_of, last_index_of, of_generic_species, of_species,  "},{"title":"Statistical operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#statistical-operators","content":"auto_correlation, beta, binomial_coeff, binomial_complemented, binomial_sum, build, chi_square, chi_square_complemented, correlation, covariance, dbscan, distribution_of, distribution2d_of, dtw, durbin_watson, frequency_of, gamma, gamma_distribution, gamma_distribution_complemented, geometric_mean, gini, harmonic_mean, hierarchical_clustering, incomplete_beta, incomplete_gamma, incomplete_gamma_complement, kmeans, kurtosis, log_gamma, max, mean, mean_deviation, median, min, moment, moran, mul, normal_area, normal_density, normal_inverse, predict, pValue_for_fStat, pValue_for_tStat, quantile, quantile_inverse, rank_interpolated, rms, simple_clustering_by_distance, skewness, split, split_in, split_using, standard_deviation, student_area, student_t_inverse, sum, t_test, variance,  "},{"title":"Strings-related operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#strings-related-operators","content":"+, &lt;, &lt;=, &gt;, &gt;=, at, char, contains, contains_all, contains_any, copy_between, date, empty, first, in, indented_by, index_of, is_number, last, last_index_of, length, lower_case, regex_matches, replace, replace_regex, reverse, sample, shuffle, split_with, string, upper_case,  "},{"title":"SubModel​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#submodel","content":"load_sub_model,  "},{"title":"System​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#system","content":"., choose, command, copy, copy_to_clipboard, dead, enter, eval_gaml, every, is_error, is_reachable, is_warning, user_confirm, user_input_dialog, wizard, wizard_page,  "},{"title":"Time-related operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#time-related-operators","content":"date, string,  "},{"title":"Types-related operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#types-related-operators","content":"action, agent, attributes, BDIPlan, bool, container, directory, emotion, file, float, gaml_type, gen_population_generator, gen_range, geometry, graph, int, kml, list, map, matrix, mental_state, Norm, pair, path, point, predicate, regression, rgb, Sanction, skill, social_link, topology, unknown,  "},{"title":"User control operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#user-control-operators","content":"choose, enter, user_confirm, user_input_dialog, wizard, wizard_page,  "},{"title":"Operators​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#operators","content":" "},{"title":"-​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#-","content":"Possible uses:​ - (point) ---&gt; point- (float) ---&gt; float- (int) ---&gt; intrgb - int ---&gt; rgb- (rgb , int) ---&gt; rgbmatrix&amp;lt;unknown&gt; - matrix ---&gt; matrix- (matrix&amp;lt;unknown&gt; , matrix) ---&gt; matrixcontainer - container ---&gt; list- (container , container) ---&gt; listrgb - rgb ---&gt; rgb- (rgb , rgb) ---&gt; rgbpoint - int ---&gt; point- (point , int) ---&gt; pointdate - date ---&gt; float- (date , date) ---&gt; floatfloat - float ---&gt; float- (float , float) ---&gt; floatlist - unknown ---&gt; list- (list , unknown) ---&gt; listint - matrix ---&gt; matrix- (int , matrix) ---&gt; matrixfloat - matrix ---&gt; matrix- (float , matrix) ---&gt; matrixint - float ---&gt; float- (int , float) ---&gt; floatfield - float ---&gt; field- (field , float) ---&gt; fielddate - float ---&gt; date- (date , float) ---&gt; datepoint - float ---&gt; point- (point , float) ---&gt; pointfield - int ---&gt; field- (field , int) ---&gt; fieldgeometry - container&amp;lt;unknown,geometry&gt; ---&gt; geometry- (geometry , container&amp;lt;unknown,geometry&gt;) ---&gt; geometrymap - map ---&gt; map- (map , map) ---&gt; mapint - int ---&gt; int- (int , int) ---&gt; intfield - matrix ---&gt; field- (field , matrix) ---&gt; fieldmatrix&amp;lt;unknown&gt; - float ---&gt; matrix- (matrix&amp;lt;unknown&gt; , float) ---&gt; matrixgeometry - geometry ---&gt; geometry- (geometry , geometry) ---&gt; geometryfloat - int ---&gt; float- (float , int) ---&gt; floatpoint - point ---&gt; point- (point , point) ---&gt; pointdate - int ---&gt; date- (date , int) ---&gt; datespecies - agent ---&gt; list- (species , agent) ---&gt; listmap - pair ---&gt; map- (map , pair) ---&gt; mapgeometry - float ---&gt; geometry- (geometry , float) ---&gt; geometrymatrix&amp;lt;unknown&gt; - int ---&gt; matrix- (matrix&amp;lt;unknown&gt; , int) ---&gt; matrix  Result:​ Returns the difference of the two operands. If it is used as an unary operator, it returns the opposite of the operand. Comment:​ The behavior of the operator depends on the type of the operands. Special cases:​ if both operands are containers and the right operand is empty, - returns the left operand if the left operand is a species and the right operand is an agent of the species, - returns a list containing all the agents of the species minus this agent if one operand is a color and the other an integer, returns a new color resulting from the subtraction of each component of the color with the right operand  rgb var18 &lt;- rgb([255, 128, 32]) - 3; // var18 equals rgb([252,125,29])  if both operands are containers, returns a new list in which all the elements of the right operand have been removed from the left one  list&amp;lt;int&gt; var19 &lt;- [1,2,3,4,5,6] - [2,4,9]; // var19 equals [1,3,5,6] list&amp;lt;int&gt; var20 &lt;- [1,2,3,4,5,6] - [0,8]; // var20 equals [1,2,3,4,5,6]  if both operands are colors, returns a new color resulting from the subtraction of the two operands, component by component  rgb var21 &lt;- rgb([255, 128, 32]) - rgb('red'); // var21 equals rgb([0,128,32])  if both operands are dates, returns the duration in seconds between date2 and date1. To obtain a more precise duration, in milliseconds, use milliseconds_between(date1, date2)  float var22 &lt;- date('2000-01-02') - date('2000-01-01'); // var22 equals 86400  if the left operand is a list and the right operand is an object of any type (except list), - returns a list containing the elements of the left operand minus the first occurence of this object  list&amp;lt;int&gt; var23 &lt;- [1,2,3,4,5,6,2] - 2; // var23 equals [1,3,4,5,6,2] list&amp;lt;int&gt; var24 &lt;- [1,2,3,4,5,6] - 0; // var24 equals [1,2,3,4,5,6]  if one operand is a matrix and the other a number (float or int), performs a normal arithmetic difference of the number with each element of the matrix (results are float if the number is a float.  matrix var25 &lt;- 3.5 - matrix([[2,5],[3,4]]); // var25 equals matrix([[1.5,-1.5],[0.5,-0.5]])  if left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the difference of the operand coordinate with this number.  point var26 &lt;- {1, 2} - 4.5; // var26 equals {-3.5, -2.5, -4.5} point var27 &lt;- {1, 2} - 4; // var27 equals {-3.0,-2.0,-4.0}  if the right-operand is a list of points, geometries or agents, returns the geometry resulting from the difference between the left-geometry and all of the right-geometries  geometry var28 &lt;- rectangle(10,10) - [circle(2), square(2)]; // var28 equals rectangle(10,10) - (circle(2) + square(2))  if both operands are numbers, performs a normal arithmetic difference and returns a float if one of them is a float.  int var29 &lt;- 1 - 1; // var29 equals 0  if both operands are a point, a geometry or an agent, returns the geometry resulting from the difference between both geometries  geometry var30 &lt;- geom1 - geom2; // var30 equals a geometry corresponding to difference between geom1 and geom2  if both operands are points, returns their difference (coordinates per coordinates).  point var31 &lt;- {1, 2} - {4, 5}; // var31 equals {-3.0, -3.0}  if one of the operands is a date and the other a number, returns a date corresponding to the date minus the given number as duration (in seconds)  date var32 &lt;- date('2000-01-01') - 86400; // var32 equals date('1999-12-31')  if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) reduced by the right-hand operand distance  geometry var33 &lt;- shape - 5; // var33 equals a geometry corresponding to the geometry of the agent applying the operator reduced by a distance of 5  Examples:​ point var0 &lt;- -{3.0,5.0}; // var0 equals {-3.0,-5.0} point var1 &lt;- -{1.0,6.0,7.0}; // var1 equals {-1.0,-6.0,-7.0} point var2 &lt;- {2.0,3.0,4.0} - 1; // var2 equals {1.0,2.0,3.0} float var3 &lt;- 1.0 - 1.0; // var3 equals 0.0 float var4 &lt;- 3.7 - 1.2; // var4 equals 2.5 float var5 &lt;- 3.0 - 1.2; // var5 equals 1.8 matrix var6 &lt;- (10.0 - (3.0 as_matrix({2,3}))); // var6 equals matrix([[7.0,7.0,7.0],[7.0,7.0,7.0]]) float var7 &lt;- 1 - 1.0; // var7 equals 0.0 float var8 &lt;- 3 - 1.2; // var8 equals 1.8 date var9 &lt;- date('2000-01-01') - 86400; // var9 equals date('1999-12-31') map var10 &lt;- ['a'::1,'b'::2] - ['b'::2]; // var10 equals ['a'::1] map var11 &lt;- ['a'::1,'b'::2] - ['b'::2,'c'::3]; // var11 equals ['a'::1] int var12 &lt;- - (-56); // var12 equals 56 float var13 &lt;- 1.0 - 1; // var13 equals 0.0 float var14 &lt;- 3.7 - 1; // var14 equals 2.7 float var15 &lt;- 3.0 - 1; // var15 equals 2.0 map var16 &lt;- ['a'::1,'b'::2] - ('b'::2); // var16 equals ['a'::1] map var17 &lt;- ['a'::1,'b'::2] - ('c'::3); // var17 equals ['a'::1,'b'::2]  See also: +, milliseconds_between, -, *, /,  "},{"title":":","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA##","content":"Possible uses:​ unknown : unknown ---&gt; unknown: (unknown , unknown) ---&gt; unknown  Result:​ It is used in combination with the ? operator. If the left-hand of ? operand evaluates to true, returns the value of the left-hand operand of the :, otherwise that of the right-hand operand of the : Examples:​ list&amp;lt;string&gt; var0 &lt;- [10, 19, 43, 12, 7, 22] collect ((each &gt; 20) ? 'above' : 'below'); // var0 equals ['below', 'below', 'above', 'below', 'below', 'above']  See also: ?,  "},{"title":"::​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#-1","content":"Possible uses:​ any expression :: any expression ---&gt; pair:: (any expression , any expression) ---&gt; pair  Result:​ produces a new pair combining the left and the right operands Special cases:​ nil is not acceptable as a key (although it is as a value). If such a case happens, :: will throw an appropriate error  "},{"title":"!​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#-2","content":"Possible uses:​ ! (bool) ---&gt; bool  Result:​ opposite boolean value. Special cases:​ if the parameter is not boolean, it is casted to a boolean value. Examples:​ bool var0 &lt;- ! (true); // var0 equals false  See also: bool, and, or,  "},{"title":"!=​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#-3","content":"Possible uses:​ date != date ---&gt; bool!= (date , date) ---&gt; boolint != float ---&gt; bool!= (int , float) ---&gt; boolfloat != float ---&gt; bool!= (float , float) ---&gt; boolfloat != int ---&gt; bool!= (float , int) ---&gt; boolunknown != unknown ---&gt; bool!= (unknown , unknown) ---&gt; bool  Result:​ true if both operands are different, false otherwise Examples:​ bool var0 &lt;- #now != #now minus_hours 1; // var0 equals true bool var1 &lt;- 3 != 3.0; // var1 equals false bool var2 &lt;- 4 != 4.7; // var2 equals true bool var3 &lt;- 3.0 != 3.0; // var3 equals false bool var4 &lt;- 4.0 != 4.7; // var4 equals true bool var5 &lt;- 3.0 != 3; // var5 equals false bool var6 &lt;- 4.7 != 4; // var6 equals true bool var7 &lt;- [2,3] != [2,3]; // var7 equals false bool var8 &lt;- [2,4] != [2,3]; // var8 equals true  See also: =, &gt;, &lt;, &gt;=, &lt;=,  "},{"title":"?​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#-4","content":"Possible uses:​ bool ? any expression ---&gt; unknown? (bool , any expression) ---&gt; unknown  Result:​ It is used in combination with the : operator: if the left-hand operand evaluates to true, returns the value of the left-hand operand of the :, otherwise that of the right-hand operand of the : Comment:​ These functional tests can be combined together. Examples:​ list&amp;lt;string&gt; var0 &lt;- [10, 19, 43, 12, 7, 22] collect ((each &gt; 20) ? 'above' : 'below'); // var0 equals ['below', 'below', 'above', 'below', 'below', 'above'] rgb col &lt;- (flip(0.3) ? #red : (flip(0.9) ? #blue : #green));  See also: :,  "},{"title":"/​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#-5","content":"Possible uses:​ rgb / int ---&gt; rgb/ (rgb , int) ---&gt; rgbfloat / float ---&gt; float/ (float , float) ---&gt; floatpoint / float ---&gt; point/ (point , float) ---&gt; pointfield / float ---&gt; field/ (field , float) ---&gt; fieldpoint / int ---&gt; point/ (point , int) ---&gt; pointint / int ---&gt; float/ (int , int) ---&gt; floatmatrix&amp;lt;unknown&gt; / int ---&gt; matrix/ (matrix&amp;lt;unknown&gt; , int) ---&gt; matrixfield / int ---&gt; field/ (field , int) ---&gt; fieldint / float ---&gt; float/ (int , float) ---&gt; floatfloat / int ---&gt; float/ (float , int) ---&gt; floatmatrix&amp;lt;unknown&gt; / float ---&gt; matrix/ (matrix&amp;lt;unknown&gt; , float) ---&gt; matrixrgb / float ---&gt; rgb/ (rgb , float) ---&gt; rgbmatrix&amp;lt;unknown&gt; / matrix ---&gt; matrix/ (matrix&amp;lt;unknown&gt; , matrix) ---&gt; matrix  Result:​ Returns the division of the two operands. Special cases:​ if the right-hand operand is equal to zero, raises a &quot;Division by zero&quot; exception if one operand is a color and the other an integer, returns a new color resulting from the division of each component of the color by the right operand  rgb var0 &lt;- rgb([255, 128, 32]) / 2; // var0 equals rgb([127,64,16])  if the left operand is a point, returns a new point with coordinates divided by the right operand  point var1 &lt;- {5, 7.5} / 2.5; // var1 equals {2, 3} point var2 &lt;- {2,5} / 4; // var2 equals {0.5,1.25}  if both operands are numbers (float or int), performs a normal arithmetic division and returns a float.  float var3 &lt;- 3 / 5.0; // var3 equals 0.6  if one operand is a color and the other a double, returns a new color resulting from the division of each component of the color by the right operand. The result on each component is then truncated.  rgb var4 &lt;- rgb([255, 128, 32]) / 2.5; // var4 equals rgb([102,51,13])  See also: *, +, -,  "},{"title":".​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#-6","content":"Possible uses:​ agent . any expression ---&gt; unknown. (agent , any expression) ---&gt; unknown  Result:​ It has two different uses: it can be the dot product between 2 matrices or return an evaluation of the expression (right-hand operand) in the scope the given agent. Special cases:​ if the agent is nil or dead, throws an exception if the left operand is an agent, it evaluates of the expression (right-hand operand) in the scope the given agent  unknown var0 &lt;- agent1.location; // var0 equals the location of the agent agent1   "},{"title":".​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#-7","content":"Possible uses:​ matrix . matrix ---&gt; matrix. (matrix , matrix) ---&gt; matrix Special cases:​ if both operands are matrix, returns the dot product of them  matrix var0 &lt;- matrix([[1,1],[1,2]]) . matrix([[1,1],[1,2]]); // var0 equals matrix([[2,3],[3,5]])   "},{"title":"^​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#-8","content":"Possible uses:​ int ^ int ---&gt; float^ (int , int) ---&gt; floatint ^ float ---&gt; float^ (int , float) ---&gt; floatfloat ^ int ---&gt; float^ (float , int) ---&gt; floatfloat ^ float ---&gt; float^ (float , float) ---&gt; float  Result:​ Returns the value (always a float) of the left operand raised to the power of the right operand. Special cases:​ if the right-hand operand is equal to 0, returns 1 if it is equal to 1, returns the left-hand operand. Various examples of power  float var0 &lt;- 2 ^ 3; // var0 equals 8.0  Examples:​ float var1 &lt;- 4.84 ^ 0.5; // var1 equals 2.2  See also: *, sqrt,  "},{"title":"@​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#-9","content":"Same signification as at  "},{"title":"*​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#-10","content":"Possible uses:​ matrix&amp;lt;unknown&gt; * float ---&gt; matrix* (matrix&amp;lt;unknown&gt; , float) ---&gt; matrixgeometry * float ---&gt; geometry* (geometry , float) ---&gt; geometryfloat * matrix ---&gt; matrix* (float , matrix) ---&gt; matrixmatrix&amp;lt;unknown&gt; * matrix ---&gt; matrix* (matrix&amp;lt;unknown&gt; , matrix) ---&gt; matrixint * int ---&gt; int* (int , int) ---&gt; intfield * float ---&gt; field* (field , float) ---&gt; fieldrgb * int ---&gt; rgb* (rgb , int) ---&gt; rgbrgb * float ---&gt; rgb* (rgb , float) ---&gt; rgbint * matrix ---&gt; matrix* (int , matrix) ---&gt; matrixmatrix&amp;lt;unknown&gt; * int ---&gt; matrix* (matrix&amp;lt;unknown&gt; , int) ---&gt; matrixpoint * point ---&gt; float* (point , point) ---&gt; floatgeometry * point ---&gt; geometry* (geometry , point) ---&gt; geometryint * float ---&gt; float* (int , float) ---&gt; floatfloat * int ---&gt; float* (float , int) ---&gt; floatpoint * float ---&gt; point* (point , float) ---&gt; pointpoint * int ---&gt; point* (point , int) ---&gt; pointfloat * float ---&gt; float* (float , float) ---&gt; floatfield * int ---&gt; field* (field , int) ---&gt; field  Result:​ Returns the product of the two operands. Special cases:​ if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) scaled by the right-hand operand coefficient  geometry var1 &lt;- circle(10) * 2; // var1 equals circle(20) geometry var2 &lt;- (circle(10) * 2).location with_precision 9; // var2 equals (circle(20)).location with_precision 9 float var3 &lt;- (circle(10) * 2).height with_precision 9; // var3 equals (circle(20)).height with_precision 9  if both operands are numbers (float or int), performs a normal arithmetic product and returns a float if one of them is a float.  int var4 &lt;- 1 * 1; // var4 equals 1  if one operand is a color and the other an integer, returns a new color resulting from the product of each component of the color with the right operand (with a maximum value at 255)  rgb var5 &lt;- rgb([255, 128, 32]) * 2; // var5 equals rgb([255,255,64])  if one operand is a color and the other a float, returns a new color resulting from the product of each component of the color with the right operand (with a maximum value at 255)  rgb var6 &lt;- rgb([255, 128, 32]) * 2.0; // var6 equals rgb([255,255,64])  if one operand is a matrix and the other a number (float or int), performs a normal arithmetic product of the number with each element of the matrix (results are float if the number is a float.  matrix var7 &lt;- 2 * matrix([[2,5],[3,4]]); // var7 equals matrix([[4,10],[6,8]])  if both operands are points, returns their scalar product  float var8 &lt;- {2,5} * {4.5, 5}; // var8 equals 34.0  if the left-hand operand is a geometry and the right-hand operand a point, returns a geometry corresponding to the left-hand operand (geometry, agent, point) scaled by the right-hand operand coefficients in the 3 dimensions  geometry var9 &lt;- shape * {0.5,0.5,2}; // var9 equals a geometry corresponding to the geometry of the agent applying the operator scaled by a coefficient of 0.5 in x, 0.5 in y and 2 in z  if the left-hand operator is a point and the right-hand a number, returns a point with coordinates multiplied by the number  point var10 &lt;- {2,5} * 4; // var10 equals {8.0, 20.0} point var11 &lt;- {2, 4} * 2.5; // var11 equals {5.0, 10.0}  Examples:​ float var0 &lt;- 2.5 * 2; // var0 equals 5.0  See also: +, -, /,  "},{"title":"+​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#-11","content":"Possible uses:​ field + matrix ---&gt; field+ (field , matrix) ---&gt; fieldfield + int ---&gt; field+ (field , int) ---&gt; fieldpoint + int ---&gt; point+ (point , int) ---&gt; pointstring + unknown ---&gt; string+ (string , unknown) ---&gt; stringmap + map ---&gt; map+ (map , map) ---&gt; mapgeometry + geometry ---&gt; geometry+ (geometry , geometry) ---&gt; geometrycontainer + unknown ---&gt; list+ (container , unknown) ---&gt; listmatrix&amp;lt;unknown&gt; + int ---&gt; matrix+ (matrix&amp;lt;unknown&gt; , int) ---&gt; matrixfloat + float ---&gt; float+ (float , float) ---&gt; floatmatrix&amp;lt;unknown&gt; + matrix ---&gt; matrix+ (matrix&amp;lt;unknown&gt; , matrix) ---&gt; matrixpoint + point ---&gt; point+ (point , point) ---&gt; pointrgb + int ---&gt; rgb+ (rgb , int) ---&gt; rgbrgb + rgb ---&gt; rgb+ (rgb , rgb) ---&gt; rgbgeometry + float ---&gt; geometry+ (geometry , float) ---&gt; geometryfield + float ---&gt; field+ (field , float) ---&gt; fieldint + float ---&gt; float+ (int , float) ---&gt; floatpoint + float ---&gt; point+ (point , float) ---&gt; pointstring + string ---&gt; string+ (string , string) ---&gt; stringint + int ---&gt; int+ (int , int) ---&gt; intcontainer + container ---&gt; container+ (container , container) ---&gt; containerfloat + int ---&gt; float+ (float , int) ---&gt; floatdate + float ---&gt; date+ (date , float) ---&gt; datefloat + matrix ---&gt; matrix+ (float , matrix) ---&gt; matrixint + matrix ---&gt; matrix+ (int , matrix) ---&gt; matrixdate + int ---&gt; date+ (date , int) ---&gt; datemap + pair ---&gt; map+ (map , pair) ---&gt; mapmatrix&amp;lt;unknown&gt; + float ---&gt; matrix+ (matrix&amp;lt;unknown&gt; , float) ---&gt; matrixdate + string ---&gt; string+ (date , string) ---&gt; string+ (geometry, float, int) ---&gt; geometry+ (geometry, float, bool) ---&gt; geometry+ (geometry, float, int, int) ---&gt; geometry+ (geometry, float, int, int, bool) ---&gt; geometry  Result:​ Returns the sum, union or concatenation of the two operands. Special cases:​ if one of the operands is nil, + throws an error if both operands are species, returns a special type of list called meta-population if the left-hand operand is a geometry and the right-hand operands a float, an integer, one of #round, #square or #flat and a boolean, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the first right-hand operand (distance), using a number of segments equal to the second right-hand operand and a flat, square or round end cap style and single sided is the boolean is true  geometry var9 &lt;- line([{10,10}, {50,50}]) + (5,32,#round, true); // var9 equals A ploygon corresponding to the buffer generated  if the left-hand operand is a string, returns the concatenation of the two operands (the left-hand one beind casted into a string)  string var10 &lt;- &quot;hello &quot; + 12; // var10 equals &quot;hello 12&quot;  if the right-operand is a point, a geometry or an agent, returns the geometry resulting from the union between both geometries  geometry var11 &lt;- geom1 + geom2; // var11 equals a geometry corresponding to union between geom1 and geom2  if the right operand is an object of any type (except a container), + returns a list of the elements of the left operand, to which this object has been added  list&amp;lt;int&gt; var12 &lt;- [1,2,3,4,5,6] + 2; // var12 equals [1,2,3,4,5,6,2] list&amp;lt;int&gt; var13 &lt;- [1,2,3,4,5,6] + 0; // var13 equals [1,2,3,4,5,6,0]  if both operands are points, returns their sum.  point var14 &lt;- {1, 2} + {4, 5}; // var14 equals {5.0, 7.0}  if one operand is a color and the other an integer, returns a new color resulting from the sum of each component of the color with the right operand  rgb var15 &lt;- rgb([255, 128, 32]) + 3; // var15 equals rgb([255,131,35])  if both operands are colors, returns a new color resulting from the sum of the two operands, component by component  rgb var16 &lt;- rgb([255, 128, 32]) + rgb('red'); // var16 equals rgb([255,128,32])  if the left-hand operand is a geometry and the right-hand operands a float and an integer, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the first right-hand operand (distance), using a number of segments equal to the second right-hand operand  geometry var17 &lt;- circle(5) + (5,32); // var17 equals circle(10)  if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the right-hand operand distance. The number of segments used by default is 8 and the end cap style is #round  geometry var18 &lt;- circle(5) + 5; // var18 equals circle(10)  if the left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the sum of the operand coordinate with this number.  point var19 &lt;- {1, 2} + 4.5; // var19 equals {5.5, 6.5,4.5}  if the left-hand and right-hand operand are a string, returns the concatenation of the two operands  string var20 &lt;- &quot;hello &quot; + &quot;World&quot;; // var20 equals &quot;hello World&quot;  if the left-hand operand is a geometry and the right-hand operands a float, an integer and one of #round, #square or #flat, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the first right-hand operand (distance), using a number of segments equal to the second right-hand operand and a flat, square or round end cap style  geometry var21 &lt;- circle(5) + (5,32,#round); // var21 equals circle(10)  if both operands are numbers (float or int), performs a normal arithmetic sum and returns a float if one of them is a float.  int var22 &lt;- 1 + 1; // var22 equals 2  if both operands are list, +returns the concatenation of both lists.  list&amp;lt;int&gt; var23 &lt;- [1,2,3,4,5,6] + [2,4,9]; // var23 equals [1,2,3,4,5,6,2,4,9] list&amp;lt;int&gt; var24 &lt;- [1,2,3,4,5,6] + [0,8]; // var24 equals [1,2,3,4,5,6,0,8]  if one operand is a matrix and the other a number (float or int), performs a normal arithmetic sum of the number with each element of the matrix (results are float if the number is a float.  matrix var25 &lt;- 3.5 + matrix([[2,5],[3,4]]); // var25 equals matrix([[5.5,8.5],[6.5,7.5]])  if one of the operands is a date and the other a number, returns a date corresponding to the date plus the given number as duration (in seconds)  date var26 &lt;- date('2000-01-01') + 86400; // var26 equals date('2000-01-02')  if the left-hand operand is a geometry and the right-hand operands a float and a boolean, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the first right-hand operand (distance), single sided is the boolean is true  geometry var27 &lt;- line([{10,10}, {50,50}]) + (5, true); // var27 equals A ploygon corresponding to the buffer generated  Examples:​ point var0 &lt;- {1, 2} + 4; // var0 equals {5.0, 6.0,4.0} map var1 &lt;- ['a'::1,'b'::2] + ['c'::3]; // var1 equals ['a'::1,'b'::2,'c'::3] map var2 &lt;- ['a'::1,'b'::2] + [5::3.0]; // var2 equals ['a'::1,'b'::2,5::3.0] float var3 &lt;- 1.0 + 1; // var3 equals 2.0 float var4 &lt;- 1.0 + 2.5; // var4 equals 3.5 date var5 &lt;- date('2016-01-01 00:00:01') + 86400; // var5 equals date('2016-01-02 00:00:01') map var6 &lt;- ['a'::1,'b'::2] + ('c'::3); // var6 equals ['a'::1,'b'::2,'c'::3] map var7 &lt;- ['a'::1,'b'::2] + ('c'::3); // var7 equals ['a'::1,'b'::2,'c'::3] string var8 &lt;- date('2000-01-01 00:00:00') + '_Test'; // var8 equals '2000-01-01 00:00:00_Test'  See also: -, *, /,  "},{"title":"<​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#-12","content":"Possible uses:​ string &lt; string ---&gt; bool&lt; (string , string) ---&gt; booldate &lt; date ---&gt; bool&lt; (date , date) ---&gt; boolpoint &lt; point ---&gt; bool&lt; (point , point) ---&gt; boolint &lt; float ---&gt; bool&lt; (int , float) ---&gt; boolfloat &lt; int ---&gt; bool&lt; (float , int) ---&gt; boolfloat &lt; float ---&gt; bool&lt; (float , float) ---&gt; boolint &lt; int ---&gt; bool&lt; (int , int) ---&gt; bool  Result:​ true if the left-hand operand is less than the right-hand operand, false otherwise. Special cases:​ if one of the operands is nil, returns false if both operands are String, uses a lexicographic comparison of two strings  bool var0 &lt;- 'abc' &lt; 'aeb'; // var0 equals true  if both operands are points, returns true if and only if the left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.  bool var1 &lt;- {5,7} &lt; {4,6}; // var1 equals false bool var2 &lt;- {5,7} &lt; {4,8}; // var2 equals false  Examples:​ bool var3 &lt;- #now &lt; #now minus_hours 1; // var3 equals false bool var4 &lt;- 3 &lt; 2.5; // var4 equals false bool var5 &lt;- 3.5 &lt; 7; // var5 equals true bool var6 &lt;- 3.5 &lt; 7.6; // var6 equals true bool var7 &lt;- 3 &lt; 7; // var7 equals true  See also: &gt;, &gt;=, &lt;=, =, !=,  "},{"title":"<=​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#-13","content":"Possible uses:​ float &lt;= float ---&gt; bool&lt;= (float , float) ---&gt; boolstring &lt;= string ---&gt; bool&lt;= (string , string) ---&gt; boolfloat &lt;= int ---&gt; bool&lt;= (float , int) ---&gt; boolint &lt;= float ---&gt; bool&lt;= (int , float) ---&gt; boolpoint &lt;= point ---&gt; bool&lt;= (point , point) ---&gt; booldate &lt;= date ---&gt; bool&lt;= (date , date) ---&gt; boolint &lt;= int ---&gt; bool&lt;= (int , int) ---&gt; bool  Result:​ true if the left-hand operand is less or equal than the right-hand operand, false otherwise. Special cases:​ if one of the operands is nil, returns false if both operands are String, uses a lexicographic comparison of two strings  bool var0 &lt;- 'abc' &lt;= 'aeb'; // var0 equals true  if both operands are points, returns true if and only if the left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.  bool var1 &lt;- {5,7} &lt;= {4,6}; // var1 equals false bool var2 &lt;- {5,7} &lt;= {4,8}; // var2 equals false  Examples:​ bool var3 &lt;- 3.5 &lt;= 3.5; // var3 equals true bool var4 &lt;- 7.0 &lt;= 7; // var4 equals true bool var5 &lt;- 3 &lt;= 2.5; // var5 equals false bool var6 &lt;- (#now &lt;= (#now minus_hours 1)); // var6 equals false bool var7 &lt;- 3 &lt;= 7; // var7 equals true  See also: &gt;, &lt;, &gt;=, =, !=,  "},{"title":"=​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#-14","content":"Possible uses:​ date = date ---&gt; bool= (date , date) ---&gt; boolfloat = int ---&gt; bool= (float , int) ---&gt; boolint = int ---&gt; bool= (int , int) ---&gt; boolfloat = float ---&gt; bool= (float , float) ---&gt; boolunknown = unknown ---&gt; bool= (unknown , unknown) ---&gt; boolint = float ---&gt; bool= (int , float) ---&gt; bool  Result:​ returns true if both operands are equal, false otherwise returns true if both operands are equal, false otherwise Special cases:​ if both operands are any kind of objects, returns true if they are identical (i.e., the same object) or equal (comparisons between nil values are permitted)  bool var0 &lt;- [2,3] = [2,3]; // var0 equals true  Examples:​ bool var1 &lt;- #now = #now minus_hours 1; // var1 equals false bool var2 &lt;- 4.7 = 4; // var2 equals false bool var3 &lt;- 4 = 5; // var3 equals false bool var4 &lt;- 4.5 = 4.7; // var4 equals false bool var5 &lt;- 3 = 3.0; // var5 equals true bool var6 &lt;- 4 = 4.7; // var6 equals false  See also: !=, &gt;, &lt;, &gt;=, &lt;=,  "},{"title":">​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#-15","content":"Possible uses:​ string &gt; string ---&gt; bool&gt; (string , string) ---&gt; boolint &gt; int ---&gt; bool&gt; (int , int) ---&gt; boolint &gt; float ---&gt; bool&gt; (int , float) ---&gt; boolfloat &gt; float ---&gt; bool&gt; (float , float) ---&gt; boolpoint &gt; point ---&gt; bool&gt; (point , point) ---&gt; booldate &gt; date ---&gt; bool&gt; (date , date) ---&gt; boolfloat &gt; int ---&gt; bool&gt; (float , int) ---&gt; bool  Result:​ true if the left-hand operand is greater than the right-hand operand, false otherwise. Special cases:​ if one of the operands is nil, returns false if both operands are String, uses a lexicographic comparison of two strings  bool var0 &lt;- 'abc' &gt; 'aeb'; // var0 equals false  if both operands are points, returns true if and only if the left component (x) of the left operand if greater than x of the right one and if the right component (y) of the left operand is greater than y of the right one.  bool var1 &lt;- {5,7} &gt; {4,6}; // var1 equals true bool var2 &lt;- {5,7} &gt; {4,8}; // var2 equals false  Examples:​ bool var3 &lt;- 13.0 &gt; 7.0; // var3 equals true bool var4 &lt;- 3 &gt; 2.5; // var4 equals true bool var5 &lt;- 3.5 &gt; 7.6; // var5 equals false bool var6 &lt;- (#now &gt; (#now minus_hours 1)); // var6 equals true bool var7 &lt;- 3.5 &gt; 7; // var7 equals false  See also: &lt;, &gt;=, &lt;=, =, !=,  "},{"title":">=​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#-16","content":"Possible uses:​ string &gt;= string ---&gt; bool&gt;= (string , string) ---&gt; boolfloat &gt;= int ---&gt; bool&gt;= (float , int) ---&gt; booldate &gt;= date ---&gt; bool&gt;= (date , date) ---&gt; boolint &gt;= int ---&gt; bool&gt;= (int , int) ---&gt; boolpoint &gt;= point ---&gt; bool&gt;= (point , point) ---&gt; boolint &gt;= float ---&gt; bool&gt;= (int , float) ---&gt; boolfloat &gt;= float ---&gt; bool&gt;= (float , float) ---&gt; bool  Result:​ true if the left-hand operand is greater or equal than the right-hand operand, false otherwise. Special cases:​ if one of the operands is nil, returns false if both operands are string, uses a lexicographic comparison of the two strings  bool var0 &lt;- 'abc' &gt;= 'aeb'; // var0 equals false bool var1 &lt;- 'abc' &gt;= 'abc'; // var1 equals true  if both operands are points, returns true if and only if the left component (x) of the left operand if greater or equal than x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.  bool var2 &lt;- {5,7} &gt;= {4,6}; // var2 equals true bool var3 &lt;- {5,7} &gt;= {4,8}; // var3 equals false  Examples:​ bool var4 &lt;- 3.5 &gt;= 7; // var4 equals false bool var5 &lt;- #now &gt;= #now minus_hours 1; // var5 equals true bool var6 &lt;- 3 &gt;= 7; // var6 equals false bool var7 &lt;- 3 &gt;= 2.5; // var7 equals true bool var8 &lt;- 3.5 &gt;= 3.5; // var8 equals true  See also: &gt;, &lt;, &lt;=, =, !=,  "},{"title":"abs​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#abs","content":"Possible uses:​ abs (float) ---&gt; floatabs (int) ---&gt; int  Result:​ Returns the absolute value of the operand (so a positive int or float depending on the type of the operand). Examples:​ float var0 &lt;- abs (200 * -1 + 0.5); // var0 equals 199.5 int var1 &lt;- abs (-10); // var1 equals 10 int var2 &lt;- abs (10); // var2 equals 10   "},{"title":"accumulate​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#accumulate","content":"Possible uses:​ container accumulate any expression ---&gt; listaccumulate (container , any expression) ---&gt; list  Result:​ returns a new flat list, in which each element is the evaluation of the right-hand operand. If this evaluation returns a list, the elements of this result are added directly to the list returned Comment:​ accumulate is dedicated to the application of a same computation on each element of a container (and returns a list). In the right-hand operand, the keyword each can be used to represent, in turn, each of the left-hand operand elements. Examples:​ list var0 &lt;- [a1,a2,a3] accumulate (each neighbors_at 10); // var0 equals a flat list of all the neighbors of these three agents list&amp;lt;int&gt; var1 &lt;- [1,2,4] accumulate ([2,4]); // var1 equals [2,4,2,4,2,4] list&amp;lt;int&gt; var2 &lt;- [1,2,4] accumulate (each * 2); // var2 equals [2,4,8]  See also: collect,  "},{"title":"acos​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#acos","content":"Possible uses:​ acos (float) ---&gt; floatacos (int) ---&gt; float  Result:​ Returns the value (in the interval [0,180], in decimal degrees) of the arccos of the operand (which should be in [-1,1]). Special cases:​ if the right-hand operand is outside of the [-1,1] interval, returns NaN Examples:​ float var0 &lt;- acos (0); // var0 equals 90.0  See also: asin, atan, cos,  "},{"title":"action​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#action","content":"Possible uses:​ action (any) ---&gt; action  Result:​ casts the operand in a action object.  "},{"title":"add_3Dmodel​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#add_3dmodel","content":"Possible uses:​ add_3Dmodel (kml, point, float, float, string) ---&gt; kmladd_3Dmodel (kml, point, float, float, string, date, date) ---&gt; kml  Result:​ the kml export manager with new 3D model: specify the 3D model (collada) to add to the kml See also: add_geometry, add_icon, add_label,  "},{"title":"add_attribute​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#add_attribute","content":"Possible uses:​ add_attribute (gen_population_generator, string, any GAML type, list) ---&gt; gen_population_generatoradd_attribute (gen_population_generator, string, any GAML type, list, bool) ---&gt; gen_population_generatoradd_attribute (gen_population_generator, string, any GAML type, list, string, any GAML type) ---&gt; gen_population_generatoradd_attribute (gen_population_generator, string, any GAML type, list, bool, string, any GAML type) ---&gt; gen_population_generator  Result:​ add an attribute defined by its name (string), its datatype (type), its list of values (list) to a population_generator add an attribute defined by its name (string), its datatype (type), its list of values (list) and attributeType name (type of the attribute among &quot;range&quot; and &quot;unique&quot;) to a population_generator add an attribute defined by its name (string), its datatype (type), its list of values (list) and record name (name of the attribute to record) to a population_generator add an attribute defined by its name (string), its datatype (type), its list of values (list) to a population_generator Examples:​ add_attribute(pop_gen, &quot;Sex&quot;, string,[&quot;Man&quot;, &quot;Woman&quot;]) add_attribute(pop_gen, &quot;iris&quot;, string, liste_iris, &quot;unique&quot;) add_attribute(pop_gen, &quot;iris&quot;, string,liste_iris, &quot;unique&quot;, &quot;P13_POP&quot;) add_attribute(pop_gen, &quot;Sex&quot;, string,[&quot;Man&quot;, &quot;Woman&quot;])   "},{"title":"add_census_file​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#add_census_file","content":"Possible uses:​ add_census_file (gen_population_generator, string, string, string, int, int) ---&gt; gen_population_generator  Result:​ add a census data file defined by its path (string), its type (&quot;ContingencyTable&quot;, &quot;GlobalFrequencyTable&quot;, &quot;LocalFrequencyTable&quot; or &quot;Sample&quot;), its separator (string), the index of the first row of data (int) and the index of the first column of data (int) to a population_generator Examples:​ add_census_file(pop_gen, &quot;../data/Age_Couple.csv&quot;, &quot;ContingencyTable&quot;, &quot;;&quot;, 1, 1)   "},{"title":"add_days​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#add_days","content":"Same signification as plus_days  "},{"title":"add_edge​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#add_edge","content":"Possible uses:​ graph add_edge pair ---&gt; graphadd_edge (graph , pair) ---&gt; graph  Result:​ add an edge between a source vertex and a target vertex (resp. the left and the right element of the pair operand) Comment:​ WARNING / side effect: this operator modifies the operand and does not create a new graph. If the edge already exists, the graph is unchanged Examples:​ graph &lt;- graph add_edge (source::target);  See also: add_node, graph,  "},{"title":"add_geometry​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#add_geometry","content":"Possible uses:​ add_geometry (kml, geometry, float, rgb) ---&gt; kmladd_geometry (kml, geometry, rgb, rgb) ---&gt; kmladd_geometry (kml, geometry, float, rgb, rgb) ---&gt; kmladd_geometry (kml, geometry, float, rgb, rgb, date) ---&gt; kmladd_geometry (kml, geometry, float, rgb, rgb, date, date) ---&gt; kml  Result:​ Define the kml export manager with new geometry See also: add_3Dmodel, add_icon, add_label,  "},{"title":"add_hours​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#add_hours","content":"Same signification as plus_hours  "},{"title":"add_icon​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#add_icon","content":"Possible uses:​ add_icon (kml, point, float, float, string) ---&gt; kmladd_icon (kml, point, float, float, string, date, date) ---&gt; kml  Result:​ Define the kml export manager with new icons See also: add_geometry, add_icon,  "},{"title":"add_mapper​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#add_mapper","content":"Possible uses:​ add_mapper (gen_population_generator, string, any GAML type, map) ---&gt; gen_population_generatoradd_mapper (gen_population_generator, string, any GAML type, map, bool) ---&gt; gen_population_generator  Result:​ add a mapper between source of data for a attribute to a population_generator. A mapper is defined by the name of the attribute, the datatype of attribute (type), the corresponding value (map&lt;list,list&gt;) and the type of attribute (&quot;unique&quot; or &quot;range&quot;) add a mapper between source of data for a attribute to a population_generator. A mapper is defined by the name of the attribute, the datatype of attribute (type), the corresponding value (map&lt;list,list&gt;) and the type of attribute (&quot;unique&quot; or &quot;range&quot;) Examples:​  add_mapper(pop_gen, &quot;Age&quot;, int, [[&quot;0 to 18&quot;]::[&quot;1 to 10&quot;,&quot;11 to 18&quot;], [&quot;18 to 100&quot;]::[&quot;18 to 50&quot;,&quot;51 to 100&quot;] , &quot;range&quot;); add_mapper(pop_gen, &quot;Age&quot;, int, [[&quot;0 to 18&quot;]::[&quot;1 to 10&quot;,&quot;11 to 18&quot;], [&quot;18 to 100&quot;]::[&quot;18 to 50&quot;,&quot;51 to 100&quot;] , &quot;range&quot;);   "},{"title":"add_marginals​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#add_marginals","content":"Possible uses:​ gen_population_generator add_marginals list ---&gt; gen_population_generatoradd_marginals (gen_population_generator , list) ---&gt; gen_population_generator  Result:​ add a list of marginals (name of the attributes) to fit the population with, in any CO based algorithm Examples:​ add_marginals(pop_gen, [&quot;gender&quot;,&quot;age&quot;])   "},{"title":"add_minutes​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#add_minutes","content":"Same signification as plus_minutes  "},{"title":"add_months​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#add_months","content":"Same signification as plus_months  "},{"title":"add_ms​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#add_ms","content":"Same signification as plus_ms  "},{"title":"add_node​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#add_node","content":"Possible uses:​ graph add_node geometry ---&gt; graphadd_node (graph , geometry) ---&gt; graph  Result:​ adds a node in a graph. Comment:​ WARNING / side effect: this operator modifies the operand and does not create a new graph Examples:​ graph var0 &lt;- graph add_node node(0) ; // var0 equals the graph, to which node(0) has been added  See also: add_edge, graph,  "},{"title":"add_point​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#add_point","content":"Possible uses:​ geometry add_point point ---&gt; geometryadd_point (geometry , point) ---&gt; geometry  Result:​ A new geometry resulting from the addition of the right point (coordinate) to the left-hand geometry. Note that adding a point to a line or polyline will always return a closed contour. Also note that the position at which the added point will appear in the geometry is not necessarily the last one, as points are always ordered in a clockwise fashion in geometries Examples:​ geometry var0 &lt;- polygon([{10,10},{10,20},{20,20}]) add_point {20,10}; // var0 equals polygon([{10,10},{10,20},{20,20},{20,10}])   "},{"title":"add_range_attribute​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#add_range_attribute","content":"Possible uses:​ add_range_attribute (gen_population_generator, string, list, int, int) ---&gt; gen_population_generator  Result:​ add a rangee attribute defined by its name (string), the list of ranges (list) to a population_generator Examples:​ add_attribute(pop_gen, &quot;Sex&quot;, string,[&quot;Man&quot;, &quot;Woman&quot;])   "},{"title":"add_seconds​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#add_seconds","content":"Same signification as +  "},{"title":"add_values​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#add_values","content":"Possible uses:​ predicate add_values map ---&gt; predicateadd_values (predicate , map) ---&gt; predicate  Result:​ add a new value to the map of the given predicate Examples:​ predicate add_values [&quot;time&quot;::10]   "},{"title":"add_weeks​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#add_weeks","content":"Same signification as plus_weeks  "},{"title":"add_years​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#add_years","content":"Same signification as plus_years  "},{"title":"adjacency​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#adjacency","content":"Possible uses:​ adjacency (graph) ---&gt; matrix&amp;lt;float&gt;  Result:​ adjacency matrix of the given graph.  "},{"title":"after​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#after","content":"Possible uses:​ after (date) ---&gt; boolany expression after date ---&gt; boolafter (any expression , date) ---&gt; bool  Result:​ Returns true if the current_date of the model is strictly after the date passed in argument. Synonym of 'current_date &gt; argument'. Can be used in its composed form with 2 arguments to express the lower boundary for the computation of a frequency. Note that only dates strictly after this one will be tested against the frequency Examples:​ reflex when: after(starting_date) {} // this reflex will always be run after the first step reflex when: false after(starting date + #10days) {} // This reflex will not be run after this date. Better to use 'until' or 'before' in that case every(2#days) after (starting_date + 1#day) // the computation will return true every two days (using the starting_date of the model as the starting point) only for the dates strictly after this starting_date + 1#day   "},{"title":"agent​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#agent","content":"Possible uses:​ agent (any) ---&gt; agent  Result:​ casts the operand in a agent object.  "},{"title":"agent_closest_to​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#agent_closest_to","content":"Possible uses:​ agent_closest_to (unknown) ---&gt; agent  Result:​ An agent, the closest to the operand (casted as a geometry). Comment:​ the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology. Examples:​ agent var0 &lt;- agent_closest_to(self); // var0 equals the closest agent to the agent applying the operator.  See also: neighbors_at, neighbors_of, agents_inside, agents_overlapping, closest_to, inside, overlapping,  "},{"title":"agent_farthest_to​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#agent_farthest_to","content":"Possible uses:​ agent_farthest_to (unknown) ---&gt; agent  Result:​ An agent, the farthest to the operand (casted as a geometry). Comment:​ the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology. Examples:​ agent var0 &lt;- agent_farthest_to(self); // var0 equals the farthest agent to the agent applying the operator.  See also: neighbors_at, neighbors_of, agents_inside, agents_overlapping, closest_to, inside, overlapping, agent_closest_to, farthest_to,  "},{"title":"agent_from_geometry​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#agent_from_geometry","content":"Possible uses:​ path agent_from_geometry geometry ---&gt; agentagent_from_geometry (path , geometry) ---&gt; agent  Result:​ returns the agent corresponding to given geometry (right-hand operand) in the given path (left-hand operand). Special cases:​ if the left-hand operand is nil, returns nil Examples:​ geometry line &lt;- one_of(path_followed.segments); road ag &lt;- road(path_followed agent_from_geometry line);  See also: path,  "},{"title":"agent_intersecting​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#agent_intersecting","content":"Same signification as agents_overlapping  "},{"title":"agents_at_distance​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#agents_at_distance","content":"Possible uses:​ agents_at_distance (float) ---&gt; list  Result:​ A list of agents situated at a distance lower than the right argument. Examples:​ list var0 &lt;- agents_at_distance(20); // var0 equals all the agents (excluding the caller) which distance to the caller is lower than 20  See also: neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, overlapping, at_distance,  "},{"title":"agents_covering​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#agents_covering","content":"Possible uses:​ agents_covering (unknown) ---&gt; list&amp;lt;agent&gt;  Result:​ A list of agents covered by the operand (casted as a geometry). Examples:​ list&amp;lt;agent&gt; var0 &lt;- agents_covering(self); // var0 equals the agents that cover the shape of the agent applying the operator.  See also: agent_closest_to, agents_overlapping, closest_to, inside, overlapping,  "},{"title":"agents_crossing​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#agents_crossing","content":"Possible uses:​ agents_crossing (unknown) ---&gt; list&amp;lt;agent&gt;  Result:​ A list of agents cross the operand (casted as a geometry). Examples:​ list&amp;lt;agent&gt; var0 &lt;- agents_crossing(self); // var0 equals the agents that crossing the shape of the agent applying the operator.  See also: agent_closest_to, agents_overlapping, closest_to, inside, overlapping,  "},{"title":"agents_inside​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#agents_inside","content":"Possible uses:​ agents_inside (unknown) ---&gt; list&amp;lt;agent&gt;  Result:​ A list of agents covered by the operand (casted as a geometry). Examples:​ list&amp;lt;agent&gt; var0 &lt;- agents_inside(self); // var0 equals the agents that are covered by the shape of the agent applying the operator.  See also: agent_closest_to, agents_overlapping, closest_to, inside, overlapping,  "},{"title":"agents_overlapping​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#agents_overlapping","content":"Possible uses:​ agents_overlapping (unknown) ---&gt; list&amp;lt;agent&gt;  Result:​ A list of agents overlapping the operand (casted as a geometry). Examples:​ list&amp;lt;agent&gt; var0 &lt;- agents_overlapping(self); // var0 equals the agents that overlap the shape of the agent applying the operator.  See also: neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, overlapping, at_distance,  "},{"title":"agents_partially_overlapping​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#agents_partially_overlapping","content":"Possible uses:​ agents_partially_overlapping (unknown) ---&gt; list&amp;lt;agent&gt;  Result:​ A list of agents that partially overlap the operand (casted as a geometry). Examples:​ list&amp;lt;agent&gt; var0 &lt;- agents_partially_overlapping(self); // var0 equals the agents that partially overlap the shape of the agent applying the operator.  See also: agent_closest_to, agents_overlapping, closest_to, inside, overlapping,  "},{"title":"agents_touching​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#agents_touching","content":"Possible uses:​ agents_touching (unknown) ---&gt; list&amp;lt;agent&gt;  Result:​ A list of agents touching the operand (casted as a geometry). Examples:​ list&amp;lt;agent&gt; var0 &lt;- agents_touching(self); // var0 equals the agents that touch the shape of the agent applying the operator.  See also: agent_closest_to, agents_overlapping, closest_to, inside, overlapping,  "},{"title":"all_indexes_of​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#all_indexes_of","content":"Possible uses:​ list all_indexes_of unknown ---&gt; listall_indexes_of (list , unknown) ---&gt; list  Result:​ all the index of all the occurences of the right operand in the left operand container Comment:​ The definition of all_indexes_of and the type of the index depend on the container Special cases:​ if the left operand is a list, all_indexes_of returns a list of all the indexes as integers  list var0 &lt;- [1,2,3,1,2,3] all_indexes_of 1; // var0 equals [0,3] list var1 &lt;- [1,2,3,1,2,3] all_indexes_of 4; // var1 equals []  See also: index_of, last_index_of,  "},{"title":"all_match​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#all_match","content":"Possible uses:​ container all_match any expression ---&gt; boolall_match (container , any expression) ---&gt; bool  Result:​ Returns true if all the elements of the left-hand operand make the right-hand operand evaluate to true. Returns true if the left-hand operand is empty. 'c all_match each.property' is strictly equivalent to '(c count each.property) = length(c)' but faster in most cases (as it is a shortcircuited operator) Comment:​ in the right-hand operand, the keyword each can be used to represent, in turn, each of the elements. Special cases:​ if the left-hand operand is nil, all_match throws an error Examples:​ bool var0 &lt;- [1,2,3,4,5,6,7,8] all_match (each &gt; 3); // var0 equals false bool var1 &lt;- [1::2, 3::4, 5::6] all_match (each &gt; 4); // var1 equals false  See also: none_matches, one_matches, count,  "},{"title":"all_pairs_shortest_path​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#all_pairs_shortest_path","content":"Possible uses:​ all_pairs_shortest_path (graph) ---&gt; matrix&amp;lt;int&gt;  Result:​ returns the successor matrix of shortest paths between all node pairs (rows: source, columns: target): a cell (i,j) will thus contains the next node in the shortest path between i and j. Examples:​ matrix&amp;lt;int&gt; var0 &lt;- all_pairs_shortest_paths(my_graph); // var0 equals shortest_paths_matrix will contain all pairs of shortest paths   "},{"title":"all_verify​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#all_verify","content":"Same signification as all_match  "},{"title":"alpha_index​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#alpha_index","content":"Possible uses:​ alpha_index (graph) ---&gt; float  Result:​ returns the alpha index of the graph (measure of connectivity which evaluates the number of cycles in a graph in comparison with the maximum number of cycles. The higher the alpha index, the more a network is connected: alpha = nb_cycles / (2*S-5) - planar graph) Examples:​ float var1 &lt;- alpha_index(graphEpidemio); // var1 equals the alpha index of the graph  See also: beta_index, gamma_index, nb_cycles, connectivity_index,  "},{"title":"among​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#among","content":"Possible uses:​ int among container ---&gt; listamong (int , container) ---&gt; list  Result:​ Returns a list of length the value of the left-hand operand, containing random elements from the right-hand operand. As of GAMA 1.6, the order in which the elements are returned can be different than the order in which they appear in the right-hand container Special cases:​ if the right-hand operand is empty, among returns a new empty list. If it is nil, it throws an error. if the left-hand operand is greater than the length of the right-hand operand, among returns the right-hand operand (converted as a list). If it is smaller or equal to zero, it returns an empty list Examples:​ list&amp;lt;int&gt; var0 &lt;- 3 among [1,2,4,3,5,7,6,8]; // var0 equals [1,2,8] (for example) list var1 &lt;- 3 among g2; // var1 equals [node6,node11,node7] list var2 &lt;- 3 among list(node); // var2 equals [node1,node11,node4] list&amp;lt;int&gt; var3 &lt;- 1 among [1::2,3::4]; // var3 equals 2 or 4   "},{"title":"and​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#and","content":"Possible uses:​ bool and any expression ---&gt; booland (bool , any expression) ---&gt; bool  Result:​ a bool value, equal to the logical and between the left-hand operand and the right-hand operand. Comment:​ both operands are always casted to bool before applying the operator. Thus, an expression like (1 and 0) is accepted and returns false. Examples:​ bool var0 &lt;- true and false; // var0 equals false bool var1 &lt;- false and false; // var1 equals false bool var2 &lt;- false and true; // var2 equals false bool var3 &lt;- true and true; // var3 equals true int a &lt;-3 ; int b &lt;- 4; int c &lt;- 7; bool var5 &lt;- ((a+b) = c ) and ((a+b) &gt; c ); // var5 equals false  See also: bool, or, !,  "},{"title":"and​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#and-1","content":"Possible uses:​ predicate and predicate ---&gt; predicateand (predicate , predicate) ---&gt; predicate  Result:​ create a new predicate from two others by including them as subintentions Examples:​ predicate1 and predicate2   "},{"title":"angle_between​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#angle_between","content":"Possible uses:​ angle_between (point, point, point) ---&gt; float  Result:​ the angle between vectors P0P1 and P0P2 (P0, P1, P2 being the three point operands) Examples:​ float var0 &lt;- angle_between({5,5},{10,5},{5,10}); // var0 equals 90   "},{"title":"any​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#any","content":"Same signification as one_of  "},{"title":"any_location_in​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#any_location_in","content":"Possible uses:​ any_location_in (geometry) ---&gt; point  Result:​ A point inside (or touching) the operand-geometry. Examples:​ point var0 &lt;- any_location_in(square(5)); // var0 equals a point in the square, for example : {3,4.6}.  See also: closest_points_with, farthest_point_to, points_at,  "},{"title":"any_point_in​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#any_point_in","content":"Same signification as any_location_in  "},{"title":"append_horizontally​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#append_horizontally","content":"Possible uses:​ matrix append_horizontally matrix ---&gt; matrixappend_horizontally (matrix , matrix) ---&gt; matrix  Result:​ A matrix resulting from the concatenation of the rows of the two given matrices.  "},{"title":"append_vertically​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#append_vertically","content":"Possible uses:​ matrix append_vertically matrix ---&gt; matrixappend_vertically (matrix , matrix) ---&gt; matrix  Result:​ A matrix resulting from the concatenation of the columns of the two given matrices. Examples:​ matrix var0 &lt;- matrix([[1,2],[3,4]]) append_vertically matrix([[1,2],[3,4]]); // var0 equals matrix([[1,2,1,2],[3,4,3,4]])   "},{"title":"arc​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#arc","content":"Possible uses:​ arc (float, float, float) ---&gt; geometryarc (float, float, float, bool) ---&gt; geometry  Result:​ An arc, which radius is equal to the first operand, heading to the second, amplitude to the third and a boolean indicating whether to return a linestring or a polygon to the fourth Comment:​ the center of the arc is by default the location of the current agent in which has been called this operator.the center of the arc is by default the location of the current agent in which has been called this operator. This operator returns a polygon by default. Special cases:​ returns a point if the radius operand is lower or equal to 0. returns a point if the radius operand is lower or equal to 0. Examples:​ geometry var0 &lt;- arc(4,45,90, false); // var0 equals a geometry as an arc of radius 4, in a direction of 45° and an amplitude of 90°, which only contains the points on the arc geometry var1 &lt;- arc(4,45,90); // var1 equals a geometry as an arc of radius 4, in a direction of 45° and an amplitude of 90°  See also: around, cone, line, link, norm, point, polygon, polyline, super_ellipse, rectangle, square, circle, ellipse, triangle,  "},{"title":"around​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#around","content":"Possible uses:​ float around unknown ---&gt; geometryaround (float , unknown) ---&gt; geometry  Result:​ A geometry resulting from the difference between a buffer around the right-operand casted in geometry at a distance left-operand (right-operand buffer left-operand) and the right-operand casted as geometry. Special cases:​ returns a circle geometry of radius right-operand if the left-operand is nil Examples:​ geometry var0 &lt;- 10 around circle(5); // var0 equals the ring geometry between 5 and 10.  See also: circle, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,  "},{"title":"as​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#as","content":"Possible uses:​ unknown as any GAML type ---&gt; unknownas (unknown , any GAML type) ---&gt; unknown  Result:​ casting of the first argument into a given type Comment:​ It is equivalent to the application of the type operator on the left operand. Examples:​ int var0 &lt;- 3.5 as int; // var0 equals int(3.5)   "},{"title":"as_4_grid​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#as_4_grid","content":"Possible uses:​ geometry as_4_grid point ---&gt; matrixas_4_grid (geometry , point) ---&gt; matrix  Result:​ A matrix of square geometries (grid with 4-neighborhood) with dimension given by the right-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent) Examples:​ matrix var0 &lt;- self as_4_grid {10, 5}; // var0 equals the matrix of square geometries (grid with 4-neighborhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.  See also: as_grid, as_hexagonal_grid,  "},{"title":"as_distance_graph​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#as_distance_graph","content":"Possible uses:​ container as_distance_graph float ---&gt; graphas_distance_graph (container , float) ---&gt; graphas_distance_graph (container, float, species) ---&gt; graph  Result:​ creates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices close enough (less than a distance, right-hand operand). Comment:​ as_distance_graph is more efficient for a list of points than as_intersection_graph. Examples:​ list(ant) as_distance_graph 3.0  See also: as_intersection_graph, as_edge_graph,  "},{"title":"as_driving_graph​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#as_driving_graph","content":"Possible uses:​ container as_driving_graph container ---&gt; graphas_driving_graph (container , container) ---&gt; graph  Result:​ creates a graph from the list/map of edges given as operand and connect the node to the edge Examples:​ as_driving_graph(road, node) --: build a graph while using the road agents as edges and the node agents as nodes  See also: as_intersection_graph, as_distance_graph, as_edge_graph,  "},{"title":"as_edge_graph​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#as_edge_graph","content":"Possible uses:​ as_edge_graph (map) ---&gt; graphas_edge_graph (container) ---&gt; graphcontainer as_edge_graph container ---&gt; graphas_edge_graph (container , container) ---&gt; graphcontainer as_edge_graph float ---&gt; graphas_edge_graph (container , float) ---&gt; graph  Result:​ creates a graph from the list/map of edges given as operand Special cases:​ if the operand is a list and a tolerance (max distance in meters to consider that 2 points are the same node) is given, the graph will be built with elements of the list as edges and two edges will be connected by a node if the distance between their extremity (first or last points) are at distance lower or equal to the tolerance  graph var0 &lt;- as_edge_graph([line([{1,5},{12,45}]),line([{13,45},{34,56}])],1); // var0 equals a graph with two edges and three vertices  if the operand is a map, the graph will be built by creating edges from pairs of the map  graph var1 &lt;- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); // var1 equals a graph with these three vertices and two edges  if the operand is a list, the graph will be built with elements of the list as edges  graph var2 &lt;- as_edge_graph([line([{1,5},{12,45}]),line([{12,45},{34,56}])]); // var2 equals a graph with two edges and three vertices  See also: as_intersection_graph, as_distance_graph,  "},{"title":"as_grid​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#as_grid","content":"Possible uses:​ geometry as_grid point ---&gt; matrixas_grid (geometry , point) ---&gt; matrix  Result:​ A matrix of square geometries (grid with 8-neighborhood) with dimension given by the right-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent) Examples:​ matrix var0 &lt;- self as_grid {10, 5}; // var0 equals a matrix of square geometries (grid with 8-neighborhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.  See also: as_4_grid, as_hexagonal_grid,  "},{"title":"as_hexagonal_grid​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#as_hexagonal_grid","content":"Possible uses:​ geometry as_hexagonal_grid point ---&gt; list&amp;lt;geometry&gt;as_hexagonal_grid (geometry , point) ---&gt; list&amp;lt;geometry&gt;  Result:​ A list of geometries (hexagonal) corresponding to the hexagonal tesselation of the first operand geometry Examples:​ list&amp;lt;geometry&gt; var0 &lt;- self as_hexagonal_grid {10, 5}; // var0 equals list of geometries (hexagonal) corresponding to the hexagonal tesselation of the first operand geometry  See also: as_4_grid, as_grid,  "},{"title":"as_int​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#as_int","content":"Possible uses:​ string as_int int ---&gt; intas_int (string , int) ---&gt; int  Result:​ parses the string argument as a signed integer in the radix specified by the second argument. Special cases:​ if the left operand is nil or empty, as_int returns 0 if the left operand does not represent an integer in the specified radix, as_int throws an exception  Examples:​ int var0 &lt;- '20' as_int 10; // var0 equals 20 int var1 &lt;- '20' as_int 8; // var1 equals 16 int var2 &lt;- '20' as_int 16; // var2 equals 32 int var3 &lt;- '1F' as_int 16; // var3 equals 31 int var4 &lt;- 'hello' as_int 32; // var4 equals 18306744  See also: int,  "},{"title":"as_intersection_graph​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#as_intersection_graph","content":"Possible uses:​ container as_intersection_graph float ---&gt; graphas_intersection_graph (container , float) ---&gt; graphas_intersection_graph (container, float, species) ---&gt; graph  Result:​ creates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices with an intersection (with a given tolerance). creates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices with an intersection (with a given tolerance). Comment:​ as_intersection_graph is more efficient for a list of geometries (but less accurate) than as_distance_graph. Examples:​ list(ant) as_intersection_graph 0.5  See also: as_distance_graph, as_edge_graph,  "},{"title":"as_map​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#as_map","content":"Possible uses:​ container as_map any expression ---&gt; mapas_map (container , any expression) ---&gt; map  Result:​ produces a new map from the evaluation of the right-hand operand for each element of the left-hand operand Comment:​ the right-hand operand should be a pair Special cases:​ if the left-hand operand is nil, as_map throws an error. Examples:​ map&amp;lt;int,int&gt; var0 &lt;- [1,2,3,4,5,6,7,8] as_map (each::(each * 2)); // var0 equals [1::2, 2::4, 3::6, 4::8, 5::10, 6::12, 7::14, 8::16] map&amp;lt;int,int&gt; var1 &lt;- [1::2,3::4,5::6] as_map (each::(each * 2)); // var1 equals [2::4, 4::8, 6::12]   "},{"title":"as_matrix​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#as_matrix","content":"Possible uses:​ unknown as_matrix point ---&gt; matrixas_matrix (unknown , point) ---&gt; matrix  Result:​ casts the left operand into a matrix with right operand as preferred size Comment:​ This operator is very useful to cast a file containing raster data into a matrix.Note that both components of the right operand point should be positive, otherwise an exception is raised.The operator as_matrix creates a matrix of preferred size. It fills in it with elements of the left operand until the matrix is full If the size is to short, some elements will be omitted. Matrix remaining elements will be filled in by nil. Special cases:​ if the right operand is nil, as_matrix is equivalent to the matrix operator  See also: matrix,  "},{"title":"as_path​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#as_path","content":"Possible uses:​ list&amp;lt;geometry&gt; as_path graph ---&gt; pathas_path (list&amp;lt;geometry&gt; , graph) ---&gt; path  Result:​ create a graph path from the list of shape Examples:​ path var0 &lt;- [road1,road2,road3] as_path my_graph; // var0 equals a path road1-&gt;road2-&gt;road3 of my_graph   "},{"title":"as_spatial_graph​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#as_spatial_graph","content":"Possible uses:​ as_spatial_graph (graph) ---&gt; msi.gama.metamodel.topology.graph.ISpatialGraph  Result:​ Creates a spatial graph out of an arbitrary graph. If the argument is already a spatial graph, returns it unchanged. If it contains geometrical nodes or edges, they are kept unchanged  "},{"title":"asin​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#asin","content":"Possible uses:​ asin (float) ---&gt; floatasin (int) ---&gt; float  Result:​ the arcsin of the operand Special cases:​ if the right-hand operand is outside of the [-1,1] interval, returns NaN Examples:​ float var0 &lt;- asin (0); // var0 equals 0.0 float var1 &lt;- asin (90); // var1 equals #nan  See also: acos, atan, sin,  "},{"title":"at​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#at","content":"Possible uses:​ string at int ---&gt; stringat (string , int) ---&gt; stringlist at int ---&gt; unknownat (list , int) ---&gt; unknownmatrix at point ---&gt; unknownat (matrix , point) ---&gt; unknownspecies at int ---&gt; agentat (species , int) ---&gt; agentcontainer at unknown ---&gt; unknownat (container , unknown) ---&gt; unknown  Result:​ the element at the right operand index of the container Comment:​ The first element of the container is located at the index 0. In addition, if the user tries to get the element at an index higher or equals than the length of the container, he will get an IndexOutOfBoundException.The at operator behavior depends on the nature of the operand Special cases:​ if it is a file, at returns the element of the file content at the index specified by the right operand if it is a population, at returns the agent at the index specified by the right operand if it is a graph and if the right operand is a node, at returns the in and out edges corresponding to that node if it is a graph and if the right operand is an edge, at returns the pair node_out::node_in of the edge if it is a graph and if the right operand is a pair node1::node2, at returns the edge from node1 to node2 in the graph if it is a list or a matrix, at returns the element at the index specified by the right operand  int var1 &lt;- [1, 2, 3] at 2; // var1 equals 3 point var2 &lt;- [{1,2}, {3,4}, {5,6}] at 0; // var2 equals {1.0,2.0}  Examples:​ string var0 &lt;- 'abcdef' at 0; // var0 equals 'a'  See also: contains_all, contains_any,  "},{"title":"at_distance​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#at_distance","content":"Possible uses:​ container&amp;lt;unknown,geometry&gt; at_distance float ---&gt; list&amp;lt;geometry&gt;at_distance (container&amp;lt;unknown,geometry&gt; , float) ---&gt; list&amp;lt;geometry&gt;  Result:​ A list of agents or geometries among the left-operand list that are located at a distance &lt;= the right operand from the caller agent (in its topology) Examples:​ list&amp;lt;geometry&gt; var0 &lt;- [ag1, ag2, ag3] at_distance 20; // var0 equals the agents of the list located at a distance &lt;= 20 from the caller agent (in the same order).  See also: neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, overlapping,  "},{"title":"at_location​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#at_location","content":"Possible uses:​ geometry at_location point ---&gt; geometryat_location (geometry , point) ---&gt; geometry  Result:​ A geometry resulting from the tran of a translation to the right-hand operand point of the left-hand operand (geometry, agent, point) Examples:​ geometry var0 &lt;- self at_location {10, 20}; // var0 equals the geometry resulting from a translation to the location {10, 20} of the left-hand geometry (or agent). float var1 &lt;- (box({10, 10 , 5}) at_location point(50,50,0)).location.x; // var1 equals 50.0   "},{"title":"atan​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#atan","content":"Possible uses:​ atan (float) ---&gt; floatatan (int) ---&gt; float  Result:​ Returns the value (in the interval [-90,90], in decimal degrees) of the arctan of the operand (which can be any real number). Examples:​ float var0 &lt;- atan (1); // var0 equals 45.0  See also: acos, asin, tan,  "},{"title":"atan2​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#atan2","content":"Possible uses:​ float atan2 float ---&gt; floatatan2 (float , float) ---&gt; float  Result:​ the atan2 value of the two operands. Comment:​ The function atan2 is the arctangent function with two arguments. The purpose of using two arguments instead of one is to gather information on the signs of the inputs in order to return the appropriate quadrant of the computed angle, which is not possible for the single-argument arctangent function. Examples:​ float var0 &lt;- atan2 (0,0); // var0 equals 0.0  See also: atan, acos, asin,  "},{"title":"attributes​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#attributes","content":"Possible uses:​ attributes (any) ---&gt; attributes  Result:​ casts the operand in a attributes object.  "},{"title":"auto_correlation​","type":1,"pageTitle":"Operators (A to A)","url":"wiki/OperatorsAA#auto_correlation","content":"Possible uses:​ container auto_correlation int ---&gt; floatauto_correlation (container , int) ---&gt; float  Result:​ Returns the auto-correlation of a data sequence given some lag Examples:​ float var0 &lt;- auto_correlation([1,0,1,0,1,0],2); // var0 equals 1 float var1 &lt;- auto_correlation([1,0,1,0,1,0],1); // var1 equals -1  "},{"title":"Operators (D to H)","type":0,"sectionRef":"#","url":"wiki/OperatorsDH","content":"","keywords":""},{"title":"Definition​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#definition","content":"Operators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function. Most of them use a classical prefixed functional syntax (i.e. operator_name(operand1, operand2, operand3), see below), with the exception of arithmetic (e.g. +, /), logical (and, or), comparison (e.g. &gt;, &lt;), access (., [..]) and pair (::) operators, which require an infixed notation (i.e. operand1 operator_symbol operand1). The ternary functional if-else operator, ? :, uses a special infixed syntax composed with two symbols (e.g. operand1 ? operand2 : operand3). Two unary operators (- and !) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g. - 10, ! (operand1 or operand2)). Finally, special constructor operators ({...} for constructing points, [...] for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. {1,2,3}, [operand1, operand2, ..., operandn] or [key1::value1, key2::value2... keyn::valuen]). With the exception of these special cases above, the following rules apply to the syntax of operators: if they only have one operand, the functional prefixed syntax is mandatory (e.g. operator_name(operand1))if they have two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2)) or the infixed syntax (e.g. operand1 operator_name operand2) can be used.if they have more than two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2, ..., operand)) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. operand1 operator_name(operand2, ..., operand)) can be used. All of these alternative syntaxes are completely equivalent. Operators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.  "},{"title":"Priority between operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#priority-between-operators","content":"The priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first. GAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely: the constructor operators, like ::, used to compose pairs of operands, have the lowest priority of all operators (e.g. a &gt; b :: b &gt; c will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, [a &gt; 10, b &gt; 5] will return a list of boolean values.it is followed by the ?: operator, the functional if-else (e.g. a &gt; b ? a + 10 : a - 10 will return the result of the if-else).next are the logical operators, and and or (e.g. a &gt; b or b &gt; c will return the value of the test)next are the comparison operators (i.e. &gt;, &lt;, &lt;=, &gt;=, =, !=)next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)next the unary operators - and !next the access operators . and [] (e.g. {1,2,3}.x &gt; 20 + {4,5,6}.y will return the result of the comparison between the x and y ordinates of the two points)and finally the functional operators, which have the highest priority of all.  "},{"title":"Using actions as operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#using-actions-as-operators","content":"Actions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand. For instance, if the following species is defined: species spec1 { int min(int x, int y) { return x &gt; y ? x : y; } }  Any agent instance of spec1 can use min as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable: global { init { create spec1; spec1 my_agent &lt;- spec1[0]; int the_min &lt;- my_agent min(10,20); // or min(my_agent, 10, 20); } }  If the action doesn't have any operands, the syntax to use is my_agent the_action(). Finally, if it does not return a value, it might still be used but is considering as returning a value of type unknown (e.g. unknown result &lt;- my_agent the_action(op1, op2);). Note that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).  "},{"title":"Table of Contents​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#table-of-contents","content":" "},{"title":"Operators by categories​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#operators-by-categories","content":" "},{"title":"3D​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#3d","content":"box, cone3D, cube, cylinder, hexagon, pyramid, set_z, sphere, teapot,  "},{"title":"Arithmetic operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#arithmetic-operators","content":"-, /, ^, *, +, abs, acos, asin, atan, atan2, ceil, cos, cos_rad, div, even, exp, fact, floor, hypot, is_finite, is_number, ln, log, mod, round, signum, sin, sin_rad, sqrt, tan, tan_rad, tanh, with_precision,  "},{"title":"BDI​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#bdi","content":"add_values, and, eval_when, get_about, get_agent, get_agent_cause, get_belief_op, get_belief_with_name_op, get_beliefs_op, get_beliefs_with_name_op, get_current_intention_op, get_decay, get_desire_op, get_desire_with_name_op, get_desires_op, get_desires_with_name_op, get_dominance, get_familiarity, get_ideal_op, get_ideal_with_name_op, get_ideals_op, get_ideals_with_name_op, get_intensity, get_intention_op, get_intention_with_name_op, get_intentions_op, get_intentions_with_name_op, get_lifetime, get_liking, get_modality, get_obligation_op, get_obligation_with_name_op, get_obligations_op, get_obligations_with_name_op, get_plan_name, get_predicate, get_solidarity, get_strength, get_super_intention, get_trust, get_truth, get_uncertainties_op, get_uncertainties_with_name_op, get_uncertainty_op, get_uncertainty_with_name_op, get_values, has_belief_op, has_belief_with_name_op, has_desire_op, has_desire_with_name_op, has_ideal_op, has_ideal_with_name_op, has_intention_op, has_intention_with_name_op, has_obligation_op, has_obligation_with_name_op, has_uncertainty_op, has_uncertainty_with_name_op, new_emotion, new_mental_state, new_predicate, new_social_link, not, or, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_lifetime, set_liking, set_modality, set_predicate, set_solidarity, set_strength, set_trust, set_truth, with_values,  "},{"title":"Casting operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#casting-operators","content":"as, as_int, as_matrix, font, is, is_skill, list_with, matrix_with, species, to_gaml, topology,  "},{"title":"Color-related operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#color-related-operators","content":"-, /, *, +, blend, brewer_colors, brewer_palettes, gradient, grayscale, hsb, mean, median, palette, rgb, rnd_color, scale, sum,  "},{"title":"Comparison operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#comparison-operators","content":"!=, &lt;, &lt;=, =, &gt;, &gt;=, between,  "},{"title":"Containers-related operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#containers-related-operators","content":"-, ::, +, accumulate, all_match, among, at, cartesian_product, collect, contains, contains_all, contains_any, contains_key, count, empty, every, first, first_with, get, group_by, in, index_by, inter, interleave, internal_integrated_value, last, last_with, length, max, max_of, mean, mean_of, median, min, min_of, mul, none_matches, one_matches, one_of, product_of, range, remove_duplicates, reverse, shuffle, sort_by, split, split_in, split_using, sum, sum_of, union, variance_of, where, with_max_of, with_min_of,  "},{"title":"Date-related operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#date-related-operators","content":"-, !=, +, &lt;, &lt;=, =, &gt;, &gt;=, after, before, between, every, milliseconds_between, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_weeks, minus_years, months_between, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_weeks, plus_years, since, to, until, years_between,  "},{"title":"Dates​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#dates","content":" "},{"title":"Displays​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#displays","content":"horizontal, stack, vertical,  "},{"title":"edge​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#edge","content":"edge_between, strahler,  "},{"title":"EDP-related operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#edp-related-operators","content":"diff, diff2,  "},{"title":"Files-related operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#files-related-operators","content":"copy_file, crs, csv_file, delete_file, dxf_file, evaluate_sub_model, file_exists, folder, folder_exists, gaml_file, geojson_file, get, gif_file, gml_file, graph6_file, graphdimacs_file, graphdot_file, graphgexf_file, graphgml_file, graphml_file, graphtsplib_file, grid_file, image_file, is_csv, is_dxf, is_gaml, is_geojson, is_gif, is_gml, is_graph6, is_graphdimacs, is_graphdot, is_graphgexf, is_graphgml, is_graphml, is_graphtsplib, is_grid, is_image, is_json, is_obj, is_osm, is_pgm, is_property, is_saved_simulation, is_shape, is_svg, is_text, is_threeds, is_xml, json_file, new_folder, obj_file, osm_file, pgm_file, property_file, read, rename_file, saved_simulation_file, shape_file, step_sub_model, svg_file, text_file, threeds_file, unzip, writable, xml_file, zip,  "},{"title":"FIPA-related operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#fipa-related-operators","content":"conversation, message,  "},{"title":"GamaMaterialType​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#gamamaterialtype","content":"material,  "},{"title":"GamaMetaType​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#gamametatype","content":"type_of,  "},{"title":"Gen*​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#gen","content":"add_attribute, add_census_file, add_mapper, add_marginals, add_range_attribute, with_generation_algo,  "},{"title":"Graphs-related operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#graphs-related-operators","content":"add_edge, add_node, adjacency, agent_from_geometry, all_pairs_shortest_path, alpha_index, as_distance_graph, as_edge_graph, as_intersection_graph, as_path, as_spatial_graph, beta_index, betweenness_centrality, biggest_cliques_of, connected_components_of, connectivity_index, contains_edge, contains_vertex, degree_of, directed, edge, edge_between, edge_betweenness, edges, gamma_index, generate_barabasi_albert, generate_complete_graph, generate_random_graph, generate_watts_strogatz, girvan_newman_clustering, grid_cells_to_graph, in_degree_of, in_edges_of, k_spanning_tree_clustering, label_propagation_clustering, layout_circle, layout_force, layout_force_FR, layout_force_FR_indexed, layout_grid, load_shortest_paths, main_connected_component, max_flow_between, maximal_cliques_of, nb_cycles, neighbors_of, node, nodes, out_degree_of, out_edges_of, path_between, paths_between, predecessors_of, remove_node_from, rewire_n, source_of, spatial_graph, strahler, successors_of, sum, target_of, undirected, use_cache, weight_of, with_k_shortest_path_algorithm, with_shortest_path_algorithm, with_weights,  "},{"title":"Grid-related operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#grid-related-operators","content":"as_4_grid, as_grid, as_hexagonal_grid, cell_at, cells_in, cells_overlapping, field, grid_at, neighbors_of, path_between, points_in, values_in,  "},{"title":"Iterator operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#iterator-operators","content":"accumulate, all_match, as_map, collect, count, create_map, first_with, frequency_of, group_by, index_by, last_with, max_of, mean_of, min_of, none_matches, one_matches, product_of, sort_by, sum_of, variance_of, where, where, where, with_max_of, with_min_of,  "},{"title":"List-related operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#list-related-operators","content":"all_indexes_of, copy_between, index_of, last_index_of,  "},{"title":"Logical operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#logical-operators","content":":, !, ?, add_3Dmodel, add_geometry, add_icon, and, or, xor,  "},{"title":"Map comparaison operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#map-comparaison-operators","content":"fuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,  "},{"title":"Map-related operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#map-related-operators","content":"as_map, create_map, index_of, last_index_of,  "},{"title":"Matrix-related operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#matrix-related-operators","content":"-, /, ., *, +, append_horizontally, append_vertically, column_at, columns_list, determinant, eigenvalues, index_of, inverse, last_index_of, row_at, rows_list, shuffle, trace, transpose,  "},{"title":"multicriteria operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#multicriteria-operators","content":"electre_DM, evidence_theory_DM, fuzzy_choquet_DM, promethee_DM, weighted_means_DM,  "},{"title":"Path-related operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#path-related-operators","content":"agent_from_geometry, all_pairs_shortest_path, as_path, load_shortest_paths, max_flow_between, path_between, path_to, paths_between, use_cache,  "},{"title":"Points-related operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#points-related-operators","content":"-, /, *, +, &lt;, &lt;=, &gt;, &gt;=, add_point, angle_between, any_location_in, centroid, closest_points_with, farthest_point_to, grid_at, norm, points_along, points_at, points_on,  "},{"title":"Random operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#random-operators","content":"binomial, flip, gamma_density, gamma_rnd, gamma_trunc_rnd, gauss, generate_terrain, lognormal_density, lognormal_rnd, lognormal_trunc_rnd, poisson, rnd, rnd_choice, sample, shuffle, skew_gauss, truncated_gauss, weibull_density, weibull_rnd, weibull_trunc_rnd,  "},{"title":"ReverseOperators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#reverseoperators","content":"restore_simulation, restore_simulation_from_file, save_simulation, serialize, serialize_agent,  "},{"title":"Shape​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#shape","content":"arc, box, circle, cone, cone3D, cross, cube, curve, cylinder, ellipse, elliptical_arc, envelope, geometry_collection, hexagon, line, link, plan, polygon, polyhedron, pyramid, rectangle, sphere, square, squircle, teapot, triangle,  "},{"title":"Spatial operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#spatial-operators","content":"-, *, +, add_point, agent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, angle_between, any_location_in, arc, around, as_4_grid, as_driving_graph, as_grid, as_hexagonal_grid, at_distance, at_location, box, centroid, circle, clean, clean_network, closest_points_with, closest_to, closest_tob, cone, cone3D, convex_hull, covering, covers, cross, crosses, crossing, crs, CRS_transform, cube, curve, cylinder, direction_between, disjoint_from, distance_between, distance_to, ellipse, elliptical_arc, envelope, farthest_point_to, farthest_to, geometry_collection, gini, hexagon, hierarchical_clustering, IDW, inside, inter, intersects, inverse_rotation, line, link, masked_by, moran, neighbors_at, neighbors_of, normalized_rotation, overlapping, overlaps, partially_overlapping, partially_overlaps, path_between, path_to, plan, points_along, points_at, points_on, polygon, polyhedron, pyramid, rectangle, rotated_by, rotation_composition, round, scaled_to, set_z, simple_clustering_by_distance, simplification, skeletonize, smooth, sphere, split_at, split_geometry, split_lines, square, squircle, teapot, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, touches, touching, towards, transformed_by, translated_by, triangle, triangulate, union, using, voronoi, with_precision, without_holes,  "},{"title":"Spatial properties operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#spatial-properties-operators","content":"covers, crosses, intersects, partially_overlaps, touches,  "},{"title":"Spatial queries operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#spatial-queries-operators","content":"agent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, at_distance, closest_to, covering, crossing, farthest_to, inside, neighbors_at, neighbors_of, overlapping, partially_overlapping, touching,  "},{"title":"Spatial relations operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#spatial-relations-operators","content":"direction_between, distance_between, distance_to, path_between, path_to, towards,  "},{"title":"Spatial statistical operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#spatial-statistical-operators","content":"hierarchical_clustering, simple_clustering_by_distance,  "},{"title":"Spatial transformations operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#spatial-transformations-operators","content":"-, *, +, as_4_grid, as_grid, as_hexagonal_grid, at_location, clean, clean_network, convex_hull, CRS_transform, inverse_rotation, normalized_rotation, rotated_by, rotation_composition, scaled_to, simplification, skeletonize, smooth, split_geometry, split_lines, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, transformed_by, translated_by, triangulate, voronoi, with_precision, without_holes,  "},{"title":"Species-related operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#species-related-operators","content":"index_of, last_index_of, of_generic_species, of_species,  "},{"title":"Statistical operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#statistical-operators","content":"auto_correlation, beta, binomial_coeff, binomial_complemented, binomial_sum, build, chi_square, chi_square_complemented, correlation, covariance, dbscan, distribution_of, distribution2d_of, dtw, durbin_watson, frequency_of, gamma, gamma_distribution, gamma_distribution_complemented, geometric_mean, gini, harmonic_mean, hierarchical_clustering, incomplete_beta, incomplete_gamma, incomplete_gamma_complement, kmeans, kurtosis, log_gamma, max, mean, mean_deviation, median, min, moment, moran, mul, normal_area, normal_density, normal_inverse, predict, pValue_for_fStat, pValue_for_tStat, quantile, quantile_inverse, rank_interpolated, rms, simple_clustering_by_distance, skewness, split, split_in, split_using, standard_deviation, student_area, student_t_inverse, sum, t_test, variance,  "},{"title":"Strings-related operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#strings-related-operators","content":"+, &lt;, &lt;=, &gt;, &gt;=, at, char, contains, contains_all, contains_any, copy_between, date, empty, first, in, indented_by, index_of, is_number, last, last_index_of, length, lower_case, regex_matches, replace, replace_regex, reverse, sample, shuffle, split_with, string, upper_case,  "},{"title":"SubModel​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#submodel","content":"load_sub_model,  "},{"title":"System​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#system","content":"., choose, command, copy, copy_to_clipboard, dead, enter, eval_gaml, every, is_error, is_reachable, is_warning, user_confirm, user_input_dialog, wizard, wizard_page,  "},{"title":"Time-related operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#time-related-operators","content":"date, string,  "},{"title":"Types-related operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#types-related-operators","content":"action, agent, attributes, BDIPlan, bool, container, directory, emotion, file, float, gaml_type, gen_population_generator, gen_range, geometry, graph, int, kml, list, map, matrix, mental_state, Norm, pair, path, point, predicate, regression, rgb, Sanction, skill, social_link, topology, unknown,  "},{"title":"User control operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#user-control-operators","content":"choose, enter, user_confirm, user_input_dialog, wizard, wizard_page,  "},{"title":"Operators​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#operators","content":" "},{"title":"date​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#date","content":"Possible uses:​ string date string ---&gt; datedate (string , string) ---&gt; datedate (string, string, string) ---&gt; date  Result:​ converts a string to a date following a custom pattern. The pattern can use &quot;%Y %M %N %D %E %h %m %s %z&quot; for outputting years, months, name of month, days, name of days, hours, minutes, seconds and the time-zone. A null or empty pattern will parse the date using one of the ISO date &amp; time formats (similar to date('...') in that case). The pattern can also follow the pattern definition found here, which gives much more control over what will be parsed: https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns. Different patterns are available by default as constant: #iso_local, #iso_simple, #iso_offset, #iso_zoned and #custom, which can be changed in the preferences Special cases:​ In addition to the date and pattern string operands, a specific locale (e.g. 'fr', 'en'...) can be added.  date d &lt;- date(&quot;1999-january-30&quot;, 'yyyy-MMMM-dd', 'en');  Examples:​ date den &lt;- date(&quot;1999-12-30&quot;, 'yyyy-MM-dd');   "},{"title":"dbscan​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#dbscan","content":"Possible uses:​ dbscan (list, float, int) ---&gt; list&amp;lt;list&gt;  Result:​ returns the list of clusters (list of instance indices) computed with the dbscan (density-based spatial clustering of applications with noise) algorithm from the first operand data according to the maximum radius of the neighborhood to be considered (eps) and the minimum number of points needed for a cluster (minPts). Usage: dbscan(data,eps,minPoints) Special cases:​ if the lengths of two vectors in the right-hand aren't equal, returns 0 Examples:​ list&amp;lt;list&gt; var0 &lt;- dbscan ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],10,2); // var0 equals [[0,1,2,3]]   "},{"title":"dead​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#dead","content":"Possible uses:​ dead (agent) ---&gt; bool  Result:​ true if the agent is dead (or null), false otherwise. Examples:​ bool var0 &lt;- dead(agent_A); // var0 equals true or false   "},{"title":"degree_of​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#degree_of","content":"Possible uses:​ graph degree_of unknown ---&gt; intdegree_of (graph , unknown) ---&gt; int  Result:​ returns the degree (in+out) of a vertex (right-hand operand) in the graph given as left-hand operand. Examples:​ int var1 &lt;- graphFromMap degree_of (node(3)); // var1 equals 3  See also: in_degree_of, out_degree_of,  "},{"title":"delete_file​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#delete_file","content":"Possible uses:​ delete_file (string) ---&gt; bool  Result:​ delete a file or a folder Examples:​ bool delete_file_ok &lt;- delete_file([&quot;../includes/my_folder&quot;];   "},{"title":"det​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#det","content":"Same signification as determinant  "},{"title":"determinant​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#determinant","content":"Possible uses:​ determinant (matrix) ---&gt; float  Result:​ The determinant of the given matrix Examples:​ float var0 &lt;- determinant(matrix([[1,2],[3,4]])); // var0 equals -2   "},{"title":"diff​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#diff","content":"Possible uses:​ float diff float ---&gt; floatdiff (float , float) ---&gt; float  Result:​ A placeholder function for expressing equations  "},{"title":"diff2​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#diff2","content":"Possible uses:​ float diff2 float ---&gt; floatdiff2 (float , float) ---&gt; float  Result:​ A placeholder function for expressing equations  "},{"title":"directed​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#directed","content":"Possible uses:​ directed (graph) ---&gt; graph  Result:​ the operand graph becomes a directed graph. Comment:​ WARNING / side effect: this operator modifies the operand and does not create a new graph. See also: undirected,  "},{"title":"direction_between​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#direction_between","content":"Possible uses:​ topology direction_between container&amp;lt;unknown,geometry&gt; ---&gt; floatdirection_between (topology , container&amp;lt;unknown,geometry&gt;) ---&gt; float  Result:​ A direction (in degree) between a list of two geometries (geometries, agents, points) considering a topology. Examples:​ float var0 &lt;- my_topology direction_between [ag1, ag2]; // var0 equals the direction between ag1 and ag2 considering the topology my_topology  See also: towards, direction_to, distance_to, distance_between, path_between, path_to,  "},{"title":"direction_to​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#direction_to","content":"Same signification as towards  "},{"title":"directory​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#directory","content":"Possible uses:​ directory (any) ---&gt; directory  Result:​ casts the operand in a directory object.  "},{"title":"disjoint_from​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#disjoint_from","content":"Possible uses:​ geometry disjoint_from geometry ---&gt; booldisjoint_from (geometry , geometry) ---&gt; bool  Result:​ A boolean, equal to true if the left-geometry (or agent/point) is disjoints from the right-geometry (or agent/point). Special cases:​ if one of the operand is null, returns true. if one operand is a point, returns false if the point is included in the geometry. Examples:​ bool var0 &lt;- polyline([{10,10},{20,20}]) disjoint_from polyline([{15,15},{25,25}]); // var0 equals false bool var1 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{15,15},{15,25},{25,25},{25,15}]); // var1 equals false bool var2 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from {25,25}; // var2 equals true bool var3 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{35,35},{35,45},{45,45},{45,35}]); // var3 equals true  See also: intersects, crosses, overlaps, partially_overlaps, touches,  "},{"title":"distance_between​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#distance_between","content":"Possible uses:​ topology distance_between container&amp;lt;unknown,geometry&gt; ---&gt; floatdistance_between (topology , container&amp;lt;unknown,geometry&gt;) ---&gt; float  Result:​ A distance between a list of geometries (geometries, agents, points) considering a topology. Examples:​ float var0 &lt;- my_topology distance_between [ag1, ag2, ag3]; // var0 equals the distance between ag1, ag2 and ag3 considering the topology my_topology  See also: towards, direction_to, distance_to, direction_between, path_between, path_to,  "},{"title":"distance_to​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#distance_to","content":"Possible uses:​ point distance_to point ---&gt; floatdistance_to (point , point) ---&gt; floatgeometry distance_to geometry ---&gt; floatdistance_to (geometry , geometry) ---&gt; float  Result:​ A distance between two geometries (geometries, agents or points) considering the topology of the agent applying the operator. Examples:​ float var0 &lt;- ag1 distance_to ag2; // var0 equals the distance between ag1 and ag2 considering the topology of the agent applying the operator  See also: towards, direction_to, distance_between, direction_between, path_between, path_to,  "},{"title":"distinct​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#distinct","content":"Same signification as remove_duplicates  "},{"title":"distribution_of​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#distribution_of","content":"Possible uses:​ distribution_of (container) ---&gt; mapcontainer distribution_of int ---&gt; mapdistribution_of (container , int) ---&gt; mapdistribution_of (container, int, float, float) ---&gt; map  Result:​ Discretize a list of values into n bins (computes the bins from a numerical variable into n (default 10) bins. Returns a distribution map with the values (values key), the interval legends (legend key), the distribution parameters (params keys, for cumulative charts). Parameters can be (list), (list, nbbins) or (list,nbbins,valmin,valmax) Examples:​ map var0 &lt;- distribution_of([1,1,2,12.5]); // var0 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]]) map var1 &lt;- distribution_of([1,1,2,12.5],10); // var1 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]]) map var2 &lt;- distribution_of([1,1,2,12.5]); // var2 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])  See also: as_map,  "},{"title":"distribution2d_of​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#distribution2d_of","content":"Possible uses:​ container distribution2d_of container ---&gt; mapdistribution2d_of (container , container) ---&gt; mapdistribution2d_of (container, container, int, int) ---&gt; mapdistribution2d_of (container, container, int, float, float, int, float, float) ---&gt; map  Result:​ Discretize two lists of values into n bins (computes the bins from a numerical variable into n (default 10) bins. Returns a distribution map with the values (values key), the interval legends (legend key), the distribution parameters (params keys, for cumulative charts). Parameters can be (list), (list, nbbins) or (list,nbbins,valmin,valmax) Examples:​ map var0 &lt;- distribution2d_of([1,1,2,12.5],10); // var0 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]]) map var1 &lt;- distribution2d_of([1,1,2,12.5],10); // var1 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]]) map var2 &lt;- distribution2d_of([1,1,2,12.5]); // var2 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])  See also: as_map,  "},{"title":"div​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#div","content":"Possible uses:​ float div float ---&gt; intdiv (float , float) ---&gt; intfloat div int ---&gt; intdiv (float , int) ---&gt; intint div int ---&gt; intdiv (int , int) ---&gt; intint div float ---&gt; intdiv (int , float) ---&gt; int  Result:​ Returns the truncation of the division of the left-hand operand by the right-hand operand. Special cases:​ if the right-hand operand is equal to zero, raises an exception. Examples:​ int var0 &lt;- 40.1 div 4.5; // var0 equals 8 int var1 &lt;- 40.5 div 3; // var1 equals 13 int var2 &lt;- 40 div 3; // var2 equals 13 int var3 &lt;- 40 div 4.1; // var3 equals 9  See also: mod,  "},{"title":"dnorm​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#dnorm","content":"Same signification as normal_density  "},{"title":"dtw​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#dtw","content":"Possible uses:​ list dtw list ---&gt; floatdtw (list , list) ---&gt; floatdtw (list, list, int) ---&gt; float  Result:​ returns the dynamic time warping between the two series of values (step pattern used: symetric1) returns the dynamic time warping between the two series of values (step pattern used: symetric1) with Sakoe-Chiba band (radius: the window width of Sakoe-Chiba band) Examples:​ float var0 &lt;- dtw([32.0,5.0,1.0,3.0],[1.0,10.0,5.0,1.0]); // var0 equals 38.0 float var1 &lt;- dtw([10.0,5.0,1.0, 3.0],[1.0,10.0,5.0,1.0], 2); // var1 equals 11.0   "},{"title":"durbin_watson​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#durbin_watson","content":"Possible uses:​ durbin_watson (container) ---&gt; float  Result:​ Durbin-Watson computation Examples:​ float var0 &lt;- durbin_watson([13,2,1,4,1,2]) with_precision(4); // var0 equals 0.7231   "},{"title":"dxf_file​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#dxf_file","content":"Possible uses:​ dxf_file (string) ---&gt; filestring dxf_file float ---&gt; filedxf_file (string , float) ---&gt; file  Result:​ Constructs a file of type dxf. Allowed extensions are limited to dxf Special cases:​ dxf_file(string): This file constructor allows to read a dxf (.dxf) file  file f &lt;- dxf_file(&quot;file.dxf&quot;);  dxf_file(string,float): This file constructor allows to read a dxf (.dxf) file and specify the unit (meter by default)  file f &lt;- dxf_file(&quot;file.dxf&quot;,#m);  See also: is_dxf,  "},{"title":"edge​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#edge-1","content":"Possible uses:​ edge (unknown) ---&gt; unknownedge (pair) ---&gt; unknownunknown edge int ---&gt; unknownedge (unknown , int) ---&gt; unknownunknown edge unknown ---&gt; unknownedge (unknown , unknown) ---&gt; unknownpair edge float ---&gt; unknownedge (pair , float) ---&gt; unknownpair edge int ---&gt; unknownedge (pair , int) ---&gt; unknownunknown edge float ---&gt; unknownedge (unknown , float) ---&gt; unknownedge (unknown, unknown, float) ---&gt; unknownedge (pair, unknown, float) ---&gt; unknownedge (unknown, unknown, int) ---&gt; unknownedge (unknown, unknown, unknown) ---&gt; unknownedge (pair, unknown, int) ---&gt; unknownedge (unknown, unknown, unknown, int) ---&gt; unknownedge (unknown, unknown, unknown, float) ---&gt; unknown  Result:​ Allows to create a wrapper (of type unknown) that wraps two objects and indicates they should be considered as the source and the target of a new edge of a graph. The third (omissible) parameter indicates which weight this edge should have in the graph Comment:​ Useful only in graph-related operations (addition, removal of edges, creation of graphs)  "},{"title":"edge_between​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#edge_between","content":"Possible uses:​ graph edge_between pair ---&gt; unknownedge_between (graph , pair) ---&gt; unknown  Result:​ returns the edge linking two nodes Examples:​ unknown var0 &lt;- graphFromMap edge_between node1::node2; // var0 equals edge1  See also: out_edges_of, in_edges_of,  "},{"title":"edge_betweenness​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#edge_betweenness","content":"Possible uses:​ edge_betweenness (graph) ---&gt; map  Result:​ returns a map containing for each edge (key), its betweenness centrality (value): number of shortest paths passing through each edge Examples:​ graph graphEpidemio &lt;- graph([]); map var1 &lt;- edge_betweenness(graphEpidemio); // var1 equals the edge betweenness index of the graph   "},{"title":"edges​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#edges","content":"Possible uses:​ edges (container) ---&gt; container  Result:​ Allows to create a wrapper (of type list) that wraps a list of objects and indicates they should be considered as edges of a graph  "},{"title":"eigenvalues​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#eigenvalues","content":"Possible uses:​ eigenvalues (matrix) ---&gt; list&amp;lt;float&gt;  Result:​ The list of the eigen values of the given matrix Examples:​ list&amp;lt;float&gt; var0 &lt;- eigenvalues(matrix([[5,-3],[6,-4]])); // var0 equals [2.0000000000000004,-0.9999999999999998]   "},{"title":"electre_DM​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#electre_dm","content":"Possible uses:​ electre_DM (list&amp;lt;list&gt;, list&amp;lt;map&amp;lt;string,unknown&gt;&gt;, float) ---&gt; int  Result:​ The index of the best candidate according to a method based on the ELECTRE methods. The principle of the ELECTRE methods is to compare the possible candidates by pair. These methods analyses the possible outranking relation existing between two candidates. An candidate outranks another if this one is at least as good as the other one. The ELECTRE methods are based on two concepts: the concordance and the discordance. The concordance characterizes the fact that, for an outranking relation to be validated, a sufficient majority of criteria should be in favor of this assertion. The discordance characterizes the fact that, for an outranking relation to be validated, none of the criteria in the minority should oppose too strongly this assertion. These two conditions must be true for validating the outranking assertion. More information about the ELECTRE methods can be found in [http://www.springerlink.com/content/g367r44322876223/ Figueira, J., Mousseau, V., Roy, B.: ELECTRE Methods. In: Figueira, J., Greco, S., and Ehrgott, M., (Eds.), Multiple Criteria Decision Analysis: State of the Art Surveys, Springer, New York, 133--162 (2005)]. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains fives elements: a name, a weight, a preference value (p), an indifference value (q) and a veto value (v). The preference value represents the threshold from which the difference between two criterion values allows to prefer one vector of values over another. The indifference value represents the threshold from which the difference between two criterion values is considered significant. The veto value represents the threshold from which the difference between two criterion values disqualifies the candidate that obtained the smaller value; the last operand is the fuzzy cut. Special cases:​ returns -1 is the list of candidates is nil or empty Examples:​ int var0 &lt;- electre_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[&quot;name&quot;::&quot;utility&quot;, &quot;weight&quot; :: 2.0,&quot;p&quot;::0.5, &quot;q&quot;::0.0, &quot;s&quot;::1.0, &quot;maximize&quot; :: true],[&quot;name&quot;::&quot;price&quot;, &quot;weight&quot; :: 1.0,&quot;p&quot;::0.5, &quot;q&quot;::0.0, &quot;s&quot;::1.0, &quot;maximize&quot; :: false]],0.7); // var0 equals 0  See also: weighted_means_DM, promethee_DM, evidence_theory_DM,  "},{"title":"ellipse​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#ellipse","content":"Possible uses:​ float ellipse float ---&gt; geometryellipse (float , float) ---&gt; geometry  Result:​ An ellipse geometry which x-radius is equal to the first operand and y-radius is equal to the second operand Comment:​ the center of the ellipse is by default the location of the current agent in which has been called this operator. Special cases:​ returns a point if both operands are lower or equal to 0, a line if only one is. Examples:​ geometry var0 &lt;- ellipse(10, 10); // var0 equals a geometry as an ellipse of width 10 and height 10.  See also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, circle, squircle, triangle,  "},{"title":"elliptical_arc​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#elliptical_arc","content":"Possible uses:​ elliptical_arc (point, point, float, int) ---&gt; geometry  Result:​ An elliptical arc from the first operand (point) to the second operand (point), which radius is equal to the third operand, and a int giving the number of points to use as a last operand Examples:​ geometry var0 &lt;- elliptical_arc({0,0},{10,10},5.0, 20); // var0 equals a geometry from {0,0} to {10,10} considering a radius of 5.0 built using 20 points  See also: arc, around, cone, line, link, norm, point, polygon, polyline, super_ellipse, rectangle, square, circle, ellipse, triangle,  "},{"title":"emotion​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#emotion","content":"Possible uses:​ emotion (any) ---&gt; emotion  Result:​ casts the operand in a emotion object.  "},{"title":"empty​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#empty","content":"Possible uses:​ empty (container&amp;lt;KeyType,ValueType&gt;) ---&gt; boolempty (string) ---&gt; bool  Result:​ true if the operand is empty, false otherwise. Comment:​ the empty operator behavior depends on the nature of the operand Special cases:​ if it is a map, empty returns true if the map contains no key-value mappings, and false otherwise if it is a file, empty returns true if the content of the file (that is also a container) is empty, and false otherwise if it is a population, empty returns true if there is no agent in the population, and false otherwise if it is a graph, empty returns true if it contains no vertex and no edge, and false otherwise if it is a matrix of int, float or object, it will return true if all elements are respectively 0, 0.0 or null, and false otherwise if it is a matrix of geometry, it will return true if the matrix contains no cell, and false otherwise if it is a list, empty returns true if there is no element in the list, and false otherwise  bool var0 &lt;- empty([]); // var0 equals true  if it is a string, empty returns true if the string does not contain any character, and false otherwise  bool var1 &lt;- empty ('abced'); // var1 equals false   "},{"title":"enlarged_by​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#enlarged_by","content":"Same signification as +  "},{"title":"enter​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#enter","content":"Possible uses:​ string enter bool ---&gt; unknownenter (string , bool) ---&gt; unknownstring enter any GAML type ---&gt; unknownenter (string , any GAML type) ---&gt; unknownstring enter float ---&gt; unknownenter (string , float) ---&gt; unknownstring enter unknown ---&gt; unknownenter (string , unknown) ---&gt; unknownstring enter string ---&gt; unknownenter (string , string) ---&gt; unknownstring enter int ---&gt; unknownenter (string , int) ---&gt; unknownenter (string, any GAML type, unknown) ---&gt; unknownenter (string, int, int, int) ---&gt; unknownenter (string, float, float, float) ---&gt; unknownenter (string, float, float, float, float) ---&gt; unknownenter (string, int, int, int, int) ---&gt; unknown  Result:​ Allows the user to enter a string by specifying a title and an initial value Special cases:​ When the second operand is the boolean type or a boolean value, the GUI is then a switch  map&amp;lt;string,unknown&gt; m &lt;- user_input(enter(&quot;Title&quot;,true)); map&amp;lt;string,unknown&gt; m2 &lt;- user_input(enter(&quot;Title&quot;,bool));  The GUI is then a slider when an init value, a min (int or float), a max (int or float) (and eventually a step (int or float) ) operands.  map resMinMax &lt;- user_input([enter(&quot;Title&quot;,5,0)]) map resMinMax &lt;- user_input([enter(&quot;Title&quot;,5,0,10)]) map resMMStepFF &lt;- user_input([enter(&quot;Title&quot;,5,0.1,10.1,0.5)]);   "},{"title":"envelope​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#envelope","content":"Possible uses:​ envelope (unknown) ---&gt; geometry  Result:​ A 3D geometry that represents the box that surrounds the geometries or the surface described by the arguments. More general than geometry(arguments).envelope, as it allows to pass int, double, point, image files, shape files, asc files, or any list combining these arguments, in which case the envelope will be correctly expanded. If an envelope cannot be determined from the arguments, a default one of dimensions (0,100, 0, 100, 0, 100) is returned Special cases:​ This operator is often used to define the environment of simulation Examples:​ file road_shapefile &lt;- file(&quot;../includes/roads.shp&quot;); geometry shape &lt;- envelope(road_shapefile); // shape is the system variable of the environment geometry var3 &lt;- polygon([{0,0}, {20,0}, {10,10}, {10,0}]); // var3 equals create a polygon to get the envolpe float var4 &lt;- envelope(polygon([{0,0}, {20,0}, {10,10}, {10,0}])).area; // var4 equals 200.0   "},{"title":"eval_gaml​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#eval_gaml","content":"Possible uses:​ eval_gaml (string) ---&gt; unknown  Result:​ evaluates the given GAML string. Examples:​ unknown var0 &lt;- eval_gaml(&quot;2+3&quot;); // var0 equals 5   "},{"title":"eval_when​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#eval_when","content":"Possible uses:​ eval_when (BDIPlan) ---&gt; bool  Result:​ evaluate the facet when of a given plan Examples:​ eval_when(plan1)   "},{"title":"evaluate_sub_model​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#evaluate_sub_model","content":"Possible uses:​ agent evaluate_sub_model string ---&gt; unknownevaluate_sub_model (agent , string) ---&gt; unknown  Result:​ Load a submodel Comment:​ loaded submodel  "},{"title":"even​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#even","content":"Possible uses:​ even (int) ---&gt; bool  Result:​ Returns true if the operand is even and false if it is odd. Special cases:​ if the operand is equal to 0, it returns true. if the operand is a float, it is truncated before Examples:​ bool var0 &lt;- even (3); // var0 equals false bool var1 &lt;- even(-12); // var1 equals true   "},{"title":"every​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#every","content":"Possible uses:​ every (int) ---&gt; boolevery (any expression) ---&gt; boollist every int ---&gt; listevery (list , int) ---&gt; listlist every any expression ---&gt; list&amp;lt;date&gt;every (list , any expression) ---&gt; list&amp;lt;date&gt;  Result:​ Retrieves elements from the first argument every step (second argument) elements. Raises an error if the step is negative or equal to zero true every operand * cycle, false otherwise applies a step to an interval of dates defined by 'date1 to date2' expects a frequency (expressed in seconds of simulated time) as argument. Will return true every time the current_date matches with this frequency Comment:​ the value of the every operator depends on the cycle. It can be used to do something every x cycle.Used to do something at regular intervals of time. Can be used in conjunction with 'since', 'after', 'before', 'until' or 'between', so that this computation only takes place in the temporal segment defined by these operators. In all cases, the starting_date of the model is used as a reference starting point Examples:​ if every(2#cycle) {write &quot;the cycle number is even&quot;;} else {write &quot;the cycle number is odd&quot;;} (date('2000-01-01') to date('2010-01-01')) every (#month) // builds an interval between these two dates which contains all the monthly dates starting from the beginning of the interval reflex when: every(2#days) since date('2000-01-01') { .. } state a { transition to: b when: every(2#mn);} state b { transition to: a when: every(30#s);} // This oscillatory behavior will use the starting_date of the model as its starting point in time  See also: to, since, after,  "},{"title":"every_cycle​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#every_cycle","content":"Same signification as every  "},{"title":"evidence_theory_DM​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#evidence_theory_dm","content":"Possible uses:​ list&amp;lt;list&gt; evidence_theory_DM list&amp;lt;map&amp;lt;string,unknown&gt;&gt; ---&gt; intevidence_theory_DM (list&amp;lt;list&gt; , list&amp;lt;map&amp;lt;string,unknown&gt;&gt;) ---&gt; intevidence_theory_DM (list&amp;lt;list&gt;, list&amp;lt;map&amp;lt;string,unknown&gt;&gt;, bool) ---&gt; int  Result:​ The index of the best candidate according to a method based on the Evidence theory. This theory, which was proposed by Shafer ([http://www.glennshafer.com/books/amte.html Shafer G (1976) A mathematical theory of evidence, Princeton University Press]), is based on the work of Dempster ([http://projecteuclid.org/DPubS?service=UI&amp;version=1.0&amp;verb=Display&amp;handle=euclid.aoms/1177698950 Dempster A (1967) Upper and lower probabilities induced by multivalued mapping. Annals of Mathematical Statistics, vol. 38, pp. 325--339]) on lower and upper probability distributions. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains seven elements: a name, a first threshold s1, a second threshold s2, a value for the assertion &quot;this candidate is the best&quot; at threshold s1 (v1p), a value for the assertion &quot;this candidate is the best&quot; at threshold s2 (v2p), a value for the assertion &quot;this candidate is not the best&quot; at threshold s1 (v1c), a value for the assertion &quot;this candidate is not the best&quot; at threshold s2 (v2c). v1p, v2p, v1c and v2c have to been defined in order that: v1p + v1c &lt;= 1.0; v2p + v2c &lt;= 1.0.; the last operand allows to use a simple version of this multi-criteria decision making method (simple if true) Special cases:​ returns -1 is the list of candidates is nil or empty if the operator is used with only 2 operands (the candidates and the criteria), the last parameter (use simple method) is set to true Examples:​ int var0 &lt;- evidence_theory_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[&quot;name&quot;::&quot;utility&quot;, &quot;s1&quot; :: 0.0,&quot;s2&quot;::1.0, &quot;v1p&quot;::0.0, &quot;v2p&quot;::1.0, &quot;v1c&quot;::0.0, &quot;v2c&quot;::0.0, &quot;maximize&quot; :: true],[&quot;name&quot;::&quot;price&quot;, &quot;s1&quot; :: 0.0,&quot;s2&quot;::1.0, &quot;v1p&quot;::0.0, &quot;v2p&quot;::1.0, &quot;v1c&quot;::0.0, &quot;v2c&quot;::0.0, &quot;maximize&quot; :: true]], false); // var0 equals 0 int var1 &lt;- evidence_theory_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[&quot;name&quot;::&quot;utility&quot;, &quot;s1&quot; :: 0.0,&quot;s2&quot;::1.0, &quot;v1p&quot;::0.0, &quot;v2p&quot;::1.0, &quot;v1c&quot;::0.0, &quot;v2c&quot;::0.0, &quot;maximize&quot; :: true],[&quot;name&quot;::&quot;price&quot;, &quot;s1&quot; :: 0.0,&quot;s2&quot;::1.0, &quot;v1p&quot;::0.0, &quot;v2p&quot;::1.0, &quot;v1c&quot;::0.0, &quot;v2c&quot;::0.0, &quot;maximize&quot; :: true]]); // var1 equals 0  See also: weighted_means_DM, electre_DM,  "},{"title":"exp​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#exp","content":"Possible uses:​ exp (float) ---&gt; floatexp (int) ---&gt; float  Result:​ Returns Euler's number e raised to the power of the operand. Special cases:​ the operand is casted to a float before being evaluated. Examples:​ float var0 &lt;- exp (0.0); // var0 equals 1.0  See also: ln,  "},{"title":"fact​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#fact","content":"Possible uses:​ fact (int) ---&gt; float  Result:​ Returns the factorial of the operand. Special cases:​ if the operand is less than 0, fact returns 0. Examples:​ float var0 &lt;- fact(4); // var0 equals 24   "},{"title":"farthest_point_to​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#farthest_point_to","content":"Possible uses:​ geometry farthest_point_to point ---&gt; pointfarthest_point_to (geometry , point) ---&gt; point  Result:​ the farthest point of the left-operand to the left-point. Examples:​ point var0 &lt;- geom farthest_point_to(pt); // var0 equals the farthest point of geom to pt  See also: any_location_in, any_point_in, closest_points_with, points_at,  "},{"title":"farthest_to​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#farthest_to","content":"Possible uses:​ container&amp;lt;unknown,geometry&gt; farthest_to geometry ---&gt; geometryfarthest_to (container&amp;lt;unknown,geometry&gt; , geometry) ---&gt; geometry  Result:​ An agent or a geometry among the left-operand list of agents, species or meta-population (addition of species), the farthest to the operand (casted as a geometry). Comment:​ the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology. Examples:​ geometry var0 &lt;- [ag1, ag2, ag3] closest_to(self); // var0 equals return the farthest agent among ag1, ag2 and ag3 to the agent applying the operator. (species1 + species2) closest_to self  See also: neighbors_at, neighbors_of, inside, overlapping, agents_overlapping, agents_inside, agent_closest_to, closest_to, agent_farthest_to,  "},{"title":"field​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#field","content":"Possible uses:​ unknown field float ---&gt; fieldfield (unknown , float) ---&gt; fieldint field int ---&gt; fieldfield (int , int) ---&gt; fieldfield (int, int, float) ---&gt; fieldfield (int, int, float, float) ---&gt; field  "},{"title":"file​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#file","content":"Possible uses:​ file (any) ---&gt; file  Result:​ casts the operand in a file object.  "},{"title":"file_exists​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#file_exists","content":"Possible uses:​ file_exists (string) ---&gt; bool  Result:​ Test whether the parameter is the path to an existing file. False if it does not exist of if it is a folder Examples:​ string file_name &lt;-&quot;../includes/buildings.shp&quot;; if file_exists(file_name){ write &quot;File exists in the computer&quot;; }   "},{"title":"first​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#first","content":"Possible uses:​ first (string) ---&gt; stringfirst (container&amp;lt;KeyType,ValueType&gt;) ---&gt; ValueTypeint first container ---&gt; listfirst (int , container) ---&gt; list  Result:​ the first value of the operand Comment:​ the first operator behavior depends on the nature of the operand Special cases:​ if it is a map, first returns the first value of the first pair (in insertion order) if it is a file, first returns the first element of the content of the file (that is also a container) if it is a population, first returns the first agent of the population if it is a graph, first returns the first edge (in creation order) if it is a matrix, first returns the element at {0,0} in the matrix for a matrix of int or float, it will return 0 if the matrix is empty for a matrix of object or geometry, it will return nil if the matrix is empty if it is a string, first returns a string composed of its first character  string var0 &lt;- first ('abce'); // var0 equals 'a'  if it is a list, first returns the first element of the list, or nil if the list is empty  int var1 &lt;- first ([1, 2, 3]); // var1 equals 1  See also: last,  "},{"title":"first_of​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#first_of","content":"Same signification as first  "},{"title":"first_with​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#first_with","content":"Possible uses:​ container first_with any expression ---&gt; unknownfirst_with (container , any expression) ---&gt; unknown  Result:​ the first element of the left-hand operand that makes the right-hand operand evaluate to true. Comment:​ in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. Special cases:​ if the left-hand operand is nil, first_with throws an error. If there is no element that satisfies the condition, it returns nil if the left-operand is a map, the keyword each will contain each value  int var4 &lt;- [1::2, 3::4, 5::6] first_with (each &gt;= 4); // var4 equals 4 pair var5 &lt;- [1::2, 3::4, 5::6].pairs first_with (each.value &gt;= 4); // var5 equals (3::4)  Examples:​ unknown var0 &lt;- [1,2,3,4,5,6,7,8] first_with (each &gt; 3); // var0 equals 4 unknown var2 &lt;- g2 first_with (length(g2 out_edges_of each) = 0); // var2 equals node9 unknown var3 &lt;- (list(node) first_with (round(node(each).location.x) &gt; 32); // var3 equals node2  See also: group_by, last_with, where,  "},{"title":"flip​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#flip","content":"Possible uses:​ flip (float) ---&gt; bool  Result:​ true or false given the probability represented by the operand Special cases:​ flip 0 always returns false, flip 1 true Examples:​ bool var0 &lt;- flip (0.66666); // var0 equals 2/3 chances to return true.  See also: rnd,  "},{"title":"float​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#float","content":"Possible uses:​ float (any) ---&gt; float  Result:​ casts the operand in a float object.  "},{"title":"floor​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#floor","content":"Possible uses:​ floor (float) ---&gt; float  Result:​ Maps the operand to the largest previous following integer, i.e. the largest integer not greater than x. Examples:​ float var0 &lt;- floor(3); // var0 equals 3.0 float var1 &lt;- floor(3.5); // var1 equals 3.0 float var2 &lt;- floor(-4.7); // var2 equals -5.0  See also: ceil, round,  "},{"title":"folder​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#folder","content":"Possible uses:​ folder (string) ---&gt; file  Result:​ opens an existing repository Special cases:​ If the specified string does not refer to an existing repository, an exception is risen. Examples:​ file dirT &lt;- folder(&quot;../includes/&quot;); // dirT represents the repository &quot;../includes/&quot; // dirT.contents here contains the list of the names of included files  See also: file, new_folder,  "},{"title":"folder_exists​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#folder_exists","content":"Possible uses:​ folder_exists (string) ---&gt; boolstring folder_exists list&amp;lt;string&gt; ---&gt; boolfolder_exists (string , list&amp;lt;string&gt;) ---&gt; bool  Result:​ Test whether the parameter is the path to an existing folder. False if it doesnt exist or if it is a file Test whether the parameter is the path to an existing folder. False if it doesnt exist or if it is a file Examples:​ string file_name &lt;-&quot;../includes/&quot;; if folder_exists(file_name){ write &quot;Folder exists in the computer&quot;; } string file_name &lt;-&quot;../includes/&quot;; if folder_exists(file_name){ write &quot;Folder exists in the computer&quot;; }   "},{"title":"font​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#font","content":"Possible uses:​ string font int ---&gt; fontfont (string , int) ---&gt; fontfont (string, int, int) ---&gt; font  Result:​ Creates a new font, by specifying its name (either a font face name like 'Lucida Grande Bold' or 'Helvetica', or a logical name like 'Dialog', 'SansSerif', 'Serif', etc.), a size in points and a style, either #bold, #italic or #plain or a combination (addition) of them. Examples:​ font var0 &lt;- font ('Helvetica Neue',12, #bold + #italic); // var0 equals a bold and italic face of the Helvetica Neue family   "},{"title":"frequency_of​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#frequency_of","content":"Possible uses:​ container frequency_of any expression ---&gt; mapfrequency_of (container , any expression) ---&gt; map  Result:​ Returns a map with keys equal to the application of the right-hand argument (like collect) and values equal to the frequency of this key (i.e. how many times it has been obtained) Examples:​ map var0 &lt;- [1, 2, 3, 3, 4, 4, 5, 3, 3, 4] frequency_of each; // var0 equals map([1::1,2::1,3::4,4::3,5::1])   "},{"title":"from​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#from","content":"Same signification as since  "},{"title":"fuzzy_choquet_DM​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#fuzzy_choquet_dm","content":"Possible uses:​ fuzzy_choquet_DM (list&amp;lt;list&gt;, list&amp;lt;string&gt;, map) ---&gt; int  Result:​ The index of the candidate that maximizes the Fuzzy Choquet Integral value. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion (list of string); the third operand the weights of each sub-set of criteria (map with list for key and float for value) Special cases:​ returns -1 is the list of candidates is nil or empty Examples:​ int var0 &lt;- fuzzy_choquet_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [&quot;utility&quot;, &quot;price&quot;, &quot;size&quot;],[[&quot;utility&quot;]::0.5,[&quot;size&quot;]::0.1,[&quot;price&quot;]::0.4,[&quot;utility&quot;, &quot;price&quot;]::0.55]); // var0 equals 0  See also: promethee_DM, electre_DM, evidence_theory_DM,  "},{"title":"fuzzy_kappa​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#fuzzy_kappa","content":"Possible uses:​ fuzzy_kappa (list&amp;lt;agent&gt;, list&amp;lt;unknown&gt;, list&amp;lt;unknown&gt;, list&amp;lt;float&gt;, list&amp;lt;unknown&gt;, matrix&amp;lt;float&gt;, float) ---&gt; floatfuzzy_kappa (list&amp;lt;agent&gt;, list&amp;lt;unknown&gt;, list&amp;lt;unknown&gt;, list&amp;lt;float&gt;, list&amp;lt;unknown&gt;, matrix&amp;lt;float&gt;, float, list&amp;lt;unknown&gt;) ---&gt; float  Result:​ fuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling &amp; Software, 21 fuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance, weights). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling &amp; Software, 21 Examples:​ fuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2) fuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2, [1.0,3.0,2.0,2.0,4.0])   "},{"title":"fuzzy_kappa_sim​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#fuzzy_kappa_sim","content":"Possible uses:​ fuzzy_kappa_sim (list&amp;lt;agent&gt;, list&amp;lt;unknown&gt;, list&amp;lt;unknown&gt;, list&amp;lt;unknown&gt;, list&amp;lt;float&gt;, list&amp;lt;unknown&gt;, matrix&amp;lt;float&gt;, float) ---&gt; floatfuzzy_kappa_sim (list&amp;lt;agent&gt;, list&amp;lt;unknown&gt;, list&amp;lt;unknown&gt;, list&amp;lt;unknown&gt;, list&amp;lt;float&gt;, list&amp;lt;unknown&gt;, matrix&amp;lt;float&gt;, float, list&amp;lt;unknown&gt;) ---&gt; float  Result:​ fuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance, weights). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800, fuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800, Examples:​ fuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2,[1.0,3.0,2.0,2.0,4.0]) fuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2)   "},{"title":"gaml_file​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#gaml_file","content":"Possible uses:​ gaml_file (string) ---&gt; filegaml_file (string, string, string) ---&gt; file  Result:​ Constructs a file of type gaml. Allowed extensions are limited to gaml, experiment Special cases:​ gaml_file(string): This file constructor allows to read a gaml file (.gaml)  file f &lt;- gaml_file(&quot;file.gaml&quot;);  gaml_file(string,string,string): This file constructor allows to compile a gaml file and run an experiment  file f &lt;- gaml_file(&quot;file.gaml&quot;, &quot;my_experiment&quot;, &quot;my_model&quot;);  See also: is_gaml,  "},{"title":"gaml_type​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#gaml_type","content":"Possible uses:​ gaml_type (any) ---&gt; gaml_type  Result:​ casts the operand in a gaml_type object.  "},{"title":"gamma​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#gamma","content":"Possible uses:​ gamma (float) ---&gt; float  Result:​ Returns the value of the Gamma function at x. Examples:​ float var0 &lt;- gamma(5); // var0 equals 24.0   "},{"title":"gamma_density​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#gamma_density","content":"Possible uses:​ gamma_density (float, float, float) ---&gt; float  Result:​ gamma_density(x,shape,scale) returns the probability density function (PDF) at the specified point x of the Gamma distribution with the given shape and scale. Examples:​ float var0 &lt;- gamma_density(1,9,0.5); // var0 equals 0.731  See also: binomial, gauss_rnd, lognormal_rnd, poisson, rnd, skew_gauss, truncated_gauss, weibull_rnd, weibull_density, lognormal_density,  "},{"title":"gamma_distribution​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#gamma_distribution","content":"Possible uses:​ gamma_distribution (float, float, float) ---&gt; float  Result:​ Returns the integral from zero to x of the gamma probability density function. Comment:​ incomplete_gamma(a,x) is equal to pgamma(a,1,x). Examples:​ float var0 &lt;- gamma_distribution(2,3,0.9) with_precision(3); // var0 equals 0.269   "},{"title":"gamma_distribution_complemented​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#gamma_distribution_complemented","content":"Possible uses:​ gamma_distribution_complemented (float, float, float) ---&gt; float  Result:​ Returns the integral from x to infinity of the gamma probability density function. Examples:​ float var0 &lt;- gamma_distribution_complemented(2,3,0.9) with_precision(3); // var0 equals 0.731   "},{"title":"gamma_index​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#gamma_index","content":"Possible uses:​ gamma_index (graph) ---&gt; float  Result:​ returns the gamma index of the graph (A measure of connectivity that considers the relationship between the number of observed links and the number of possible links: gamma = e/(3 * (v - 2)) - for planar graph. Examples:​ graph graphEpidemio &lt;- graph([]); float var1 &lt;- gamma_index(graphEpidemio); // var1 equals the gamma index of the graph  See also: alpha_index, beta_index, nb_cycles, connectivity_index,  "},{"title":"gamma_rnd​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#gamma_rnd","content":"Possible uses:​ float gamma_rnd float ---&gt; floatgamma_rnd (float , float) ---&gt; float  Result:​ returns a random value from a gamma distribution with specified values of the shape and scale parameters Examples:​ float var0 &lt;- gamma_rnd(9,0.5); // var0 equals 0.731  See also: binomial, gauss_rnd, lognormal_rnd, poisson, rnd, skew_gauss, truncated_gauss, weibull_rnd, gamma_trunc_rnd,  "},{"title":"gamma_trunc_rnd​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#gamma_trunc_rnd","content":"Possible uses:​ gamma_trunc_rnd (float, float, float, bool) ---&gt; floatgamma_trunc_rnd (float, float, float, float) ---&gt; float  Result:​ returns a random value from a truncated gamma distribution (in a range or given only one boundary) with specified values of the shape and scale parameters. Special cases:​ when 1 float and a boolean (isMax) operands are specified, the float value represents the single boundary (max if the boolean is true, min otherwise),  gamma_trunc_rnd(2,3,5,true)  when 2 float operands are specified, they are taken as mininimum and maximum values for the result  gamma_trunc_rnd(2,3,0,5)  See also: gamma_rnd, weibull_trunc_rnd, lognormal_trunc_rnd, truncated_gauss,  "},{"title":"gauss​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#gauss","content":"Possible uses:​ gauss (point) ---&gt; floatfloat gauss float ---&gt; floatgauss (float , float) ---&gt; float  Result:​ A value from a normally distributed random variable with expected value (mean as first operand) and variance (standardDeviation as second operand). The probability density function of such a variable is a Gaussian. The operator can be used with an operand of type point {meand,standardDeviation}. Special cases:​ when standardDeviation value is 0.0, it always returns the mean value when the operand is a point, it is read as {mean, standardDeviation} Examples:​ float var0 &lt;- gauss(0,0.3); // var0 equals 0.22354 float var1 &lt;- gauss({0,0.3}); // var1 equals 0.22354  See also: binomial, gamma_rnd, lognormal_rnd, poisson, rnd, skew_gauss, truncated_gauss, weibull_rnd,  "},{"title":"gauss_rnd​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#gauss_rnd","content":"Same signification as gauss  "},{"title":"gen_population_generator​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#gen_population_generator","content":"Possible uses:​ gen_population_generator (any) ---&gt; gen_population_generator  Result:​ casts the operand in a gen_population_generator object.  "},{"title":"gen_range​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#gen_range","content":"Possible uses:​ gen_range (any) ---&gt; gen_range  Result:​ casts the operand in a gen_range object.  "},{"title":"generate_barabasi_albert​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#generate_barabasi_albert","content":"Possible uses:​ generate_barabasi_albert (int, int, int, bool) ---&gt; graphgenerate_barabasi_albert (int, int, int, bool, species) ---&gt; graphgenerate_barabasi_albert (int, int, int, bool, species, species) ---&gt; graph  Result:​ returns a random scale-free network (following Barabasi-Albert (BA) model). returns a random scale-free network (following Barabasi-Albert (BA) model). returns a random scale-free network (following Barabasi-Albert (BA) model). Comment:​ The Barabasi-Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:The Barabasi-Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:The Barabasi-Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements: Special cases:​ &quot;nbInitNodes&quot;: number of initial nodes; &quot;nbEdgesAdded&quot;: number of edges of each new node added during the network growth; &quot;nbNodes&quot;: final number of nodes; &quot;directed&quot;: is the graph directed or not;  graph&amp;lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_watts_strogatz( 60, 1, 100, true);  &quot;nbInitNodes&quot;: number of initial nodes; &quot;nbEdgesAdded&quot;: number of edges of each new node added during the network growth; &quot;nbNodes&quot;: final number of nodes; &quot;directed&quot;: is the graph directed or not; &quot;node_species&quot;: the species of vertices; &quot;edges_species&quot;: the species of edges  graph&amp;lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_watts_strogatz( 60, 1, 100, true, myVertexSpecies, myEdgeSpecies);  &quot;nbInitNodes&quot;: number of initial nodes; &quot;nbEdgesAdded&quot;: number of edges of each new node added during the network growth; &quot;nbNodes&quot;: final number of nodes; &quot;directed&quot;: is the graph directed or not; &quot;node_species&quot;: the species of vertices; &quot;edges_species&quot;: the species of edges  graph&amp;lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_watts_strogatz( 60, 1, 100, true, myVertexSpecies);  See also: generate_watts_strogatz,  "},{"title":"generate_complete_graph​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#generate_complete_graph","content":"Possible uses:​ bool generate_complete_graph list ---&gt; graphgenerate_complete_graph (bool , list) ---&gt; graphint generate_complete_graph bool ---&gt; graphgenerate_complete_graph (int , bool) ---&gt; graphgenerate_complete_graph (bool, list, species) ---&gt; graphgenerate_complete_graph (int, bool, species) ---&gt; graphgenerate_complete_graph (int, bool, species, species) ---&gt; graph  Result:​ returns a fully connected graph. returns a fully connected graph. returns a fully connected graph. returns a fully connected graph. returns a fully connected graph. Special cases:​ &quot;directed&quot;: is the graph has to be directed or not;&quot;nodes&quot;: the list of existing nodes  graph&amp;lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_complete_graph( true, nodes);  &quot;nbNodes&quot;: number of nodes to created;&quot;directed&quot;: is the graph has to be directed or not  graph myGraph &lt;- generate_complete_graph( 100, true);  &quot;directed&quot;: is the graph has to be directed or not;&quot;nodes&quot;: the list of existing nodes; &quot;edges_species&quot;: the species of edges  graph&amp;lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_complete_graph( true, nodes, edge_species);  &quot;nbNodes&quot;: number of nodes to created;&quot;directed&quot;: is the graph has to be directed or not;&quot;node_species&quot;: the species of nodes  graph myGraph &lt;- generate_complete_graph( 100, true, node_species);  &quot;nbNodes&quot;: number of nodes to created;&quot;directed&quot;: is the graph has to be directed or not;&quot;node_species&quot;: the species of nodes; &quot;edges_species&quot;: the species of edges  graph&amp;lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_complete_graph( 100, true, node_species, edge_species);  See also: generate_barabasi_albert, generate_watts_strogatz,  "},{"title":"generate_random_graph​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#generate_random_graph","content":"Possible uses:​ generate_random_graph (int, int, bool) ---&gt; graphgenerate_random_graph (int, int, bool, species) ---&gt; graphgenerate_random_graph (int, int, bool, species, species) ---&gt; graph  Result:​ returns a random graph. returns a random graph. returns a random graph. Special cases:​ &quot;nbNodes&quot;: number of nodes to created;&quot;nbEdges&quot;: number of edges to created;&quot;directed&quot;: is the graph has to be directed or not  graph myGraph &lt;- generate_random_graph( 50, 100, true);  &quot;nbNodes&quot;: number of nodes to created;&quot;nbEdges&quot;: number of edges to created;&quot;directed&quot;: is the graph has to be directed or not;&quot;node_species&quot;: the species of nodes; &quot;edges_species&quot;: the species of edges  graph&amp;lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_random_graph( 50, 100, true, node_species, edge_species);  &quot;nbNodes&quot;: number of nodes to created;&quot;nbEdges&quot;: number of edges to created;&quot;directed&quot;: is the graph has to be directed or not;&quot;node_species&quot;: the species of nodes  graph myGraph &lt;- generate_random_graph( 50, 100, true, node_species);  See also: generate_barabasi_albert, generate_watts_strogatz,  "},{"title":"generate_terrain​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#generate_terrain","content":"Possible uses:​ generate_terrain (int, int, int, float, float, float) ---&gt; field  Result:​ This operator allows to generate a pseudo-terrain using a simplex noise generator. Its usage is kept simple: it takes first a seed (random or not), then the dimensions (width and height) of the field to generate, then a level (between 0 and 1) of details (which actually determines the number of passes to make), then the value (between 0 and 1) of smoothess, with 0 being completely rought and 1 super smooth, and finally the value (between 0 and 1) of scattering, with 0 building maps in 'one piece' and 1 completely scattered ones.  "},{"title":"generate_watts_strogatz​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#generate_watts_strogatz","content":"Possible uses:​ generate_watts_strogatz (int, float, int, bool) ---&gt; graphgenerate_watts_strogatz (int, float, int, bool, species) ---&gt; graphgenerate_watts_strogatz (int, float, int, bool, species, species) ---&gt; graph  Result:​ returns a random small-world network (following Watts-Strogatz model). returns a random small-world network (following Watts-Strogatz model). returns a random small-world network (following Watts-Strogatz model). Comment:​ The Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:The Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:The Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements: Special cases:​ &quot;nbNodes&quot;: the graph will contain (size + 1) nodes (size must be greater than k); &quot;p&quot;: probability to &quot;rewire&quot; an edge (so it must be between 0 and 1, the parameter is often called beta in the literature); &quot;k&quot;: the base degree of each node (k must be greater than 2 and even); &quot;directed&quot;: is the graph directed or not  graph&amp;lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_watts_strogatz( 100, 0.3, 5, true);  &quot;nbNodes&quot;: the graph will contain (size + 1) nodes (size must be greater than k); &quot;p&quot;: probability to &quot;rewire&quot; an edge (so it must be between 0 and 1, the parameter is often called beta in the literature); &quot;k&quot;: the base degree of each node (k must be greater than 2 and even); &quot;directed&quot;: is the graph directed or not; &quot;node_species&quot;: the species of vertices  graph&amp;lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_watts_strogatz( 100, 0.3, 5, true, myVertexSpecies);  &quot;nbNodes&quot;: the graph will contain (size + 1) nodes (size must be greater than k); &quot;p&quot;: probability to &quot;rewire&quot; an edge (so it must be between 0 and 1, the parameter is often called beta in the literature); &quot;k&quot;: the base degree of each node (k must be greater than 2 and even); &quot;directed&quot;: is the graph directed or not; &quot;node_species&quot;: the species of vertices; &quot;edges_species&quot;: the species of edges  graph&amp;lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_watts_strogatz( 100, 0.3, 5, true, myVertexSpecies, myEdgeSpecies);  See also: generate_barabasi_albert,  "},{"title":"geojson_file​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#geojson_file","content":"Possible uses:​ geojson_file (string) ---&gt; filestring geojson_file int ---&gt; filegeojson_file (string , int) ---&gt; filestring geojson_file string ---&gt; filegeojson_file (string , string) ---&gt; filestring geojson_file bool ---&gt; filegeojson_file (string , bool) ---&gt; filegeojson_file (string, int, bool) ---&gt; filegeojson_file (string, string, bool) ---&gt; file  Result:​ Constructs a file of type geojson. Allowed extensions are limited to json, geojson, geo.json Special cases:​ geojson_file(string): This file constructor allows to read a geojson file (https://geojson.org/)  file f &lt;- geojson_file(&quot;file.json&quot;);  geojson_file(string,int): This file constructor allows to read a geojson file and specifying the coordinates system code, as an int  file f &lt;- geojson_file(&quot;file.json&quot;, 32648);  geojson_file(string,string): This file constructor allows to read a geojson file and specifying the coordinates system code (epg,...,), as a string  file f &lt;- geojson_file(&quot;file.json&quot;, &quot;EPSG:32648&quot;);  geojson_file(string,bool): This file constructor allows to read a geojson file and take a potential z value (not taken in account by default)  file f &lt;- geojson_file(&quot;file.json&quot;, true);  geojson_file(string,int,bool): This file constructor allows to read a geojson file, specifying the coordinates system code, as an int and take a potential z value (not taken in account by default)  file f &lt;- geojson_file(&quot;file.json&quot;,32648, true);  geojson_file(string,string,bool): This file constructor allows to read a geojson file, specifying the coordinates system code (epg,...,), as a string and take a potential z value (not taken in account by default  file f &lt;- geojson_file(&quot;file.json&quot;, &quot;EPSG:32648&quot;,true);  See also: is_geojson,  "},{"title":"geometric_mean​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#geometric_mean","content":"Possible uses:​ geometric_mean (container) ---&gt; float  Result:​ the geometric mean of the elements of the operand. See Geometric_mean for more details. Comment:​ The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded. Examples:​ float var0 &lt;- geometric_mean ([4.5, 3.5, 5.5, 7.0]); // var0 equals 4.962326343467649  See also: mean, median, harmonic_mean,  "},{"title":"geometry​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#geometry","content":"Possible uses:​ geometry (any) ---&gt; geometry  Result:​ casts the operand in a geometry object.  "},{"title":"geometry_collection​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#geometry_collection","content":"Possible uses:​ geometry_collection (container&amp;lt;unknown,geometry&gt;) ---&gt; geometry  Result:​ A geometry collection (multi-geometry) composed of the given list of geometries. Special cases:​ if the operand is nil, returns the point geometry {0,0} if the operand is composed of a single geometry, returns a copy of the geometry. Examples:​ geometry var0 &lt;- geometry_collection([{0,0}, {0,10}, {10,10}, {10,0}]); // var0 equals a geometry composed of the 4 points (multi-point).  See also: around, circle, cone, link, norm, point, polygone, rectangle, square, triangle, line,  "},{"title":"get​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get","content":"Same signification as read Possible uses:​ agent get string ---&gt; unknownget (agent , string) ---&gt; unknowngeometry get string ---&gt; unknownget (geometry , string) ---&gt; unknown  Result:​ Reads an attribute of the specified agent (or geometry) (left operand). The attribute name is specified by the right operand. Special cases:​ Reading the attribute of another agent  string agent_name &lt;- an_agent get('name'); // reads then 'name' attribute of an_agent then assigns the returned value to the agent_name variable  Reading the attribute of a geometry  string geom_area &lt;- a_geometry get('area'); // reads then 'area' attribute of 'a_geometry' variable then assigns the returned value to the geom_area variable   "},{"title":"get_about​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_about","content":"Possible uses:​ get_about (emotion) ---&gt; predicate  Result:​ get the about value of the given emotion Examples:​ get_about(emotion)   "},{"title":"get_agent​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_agent","content":"Possible uses:​ get_agent (social_link) ---&gt; agent  Result:​ get the agent value of the given social link Examples:​ get_agent(social_link1)   "},{"title":"get_agent_cause​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_agent_cause","content":"Possible uses:​ get_agent_cause (predicate) ---&gt; agentget_agent_cause (emotion) ---&gt; agent  Result:​ evaluate the agent_cause value of a predicate get the agent cause value of the given emotion Examples:​ get_agent_cause(pred1) get_agent_cause(emotion)   "},{"title":"get_belief_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_belief_op","content":"Possible uses:​ agent get_belief_op predicate ---&gt; mental_stateget_belief_op (agent , predicate) ---&gt; mental_state  Result:​ get the belief in the belief base with the given predicate. Examples:​ mental_state var0 &lt;- get_belief_op(self,predicate(&quot;has_water&quot;)); // var0 equals nil   "},{"title":"get_belief_with_name_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_belief_with_name_op","content":"Possible uses:​ agent get_belief_with_name_op string ---&gt; mental_stateget_belief_with_name_op (agent , string) ---&gt; mental_state  Result:​ get the belief in the belief base with the given name. Examples:​ mental_state var0 &lt;- get_belief_with_name_op(self,&quot;has_water&quot;); // var0 equals nil   "},{"title":"get_beliefs_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_beliefs_op","content":"Possible uses:​ agent get_beliefs_op predicate ---&gt; list&amp;lt;mental_state&gt;get_beliefs_op (agent , predicate) ---&gt; list&amp;lt;mental_state&gt;  Result:​ get the beliefs in the belief base with the given predicate. Examples:​ get_beliefs_op(self,predicate(&quot;has_water&quot;))   "},{"title":"get_beliefs_with_name_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_beliefs_with_name_op","content":"Possible uses:​ agent get_beliefs_with_name_op string ---&gt; list&amp;lt;mental_state&gt;get_beliefs_with_name_op (agent , string) ---&gt; list&amp;lt;mental_state&gt;  Result:​ get the list of beliefs in the belief base which predicate has the given name. Examples:​ get_beliefs_with_name_op(self,&quot;has_water&quot;)   "},{"title":"get_current_intention_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_current_intention_op","content":"Possible uses:​ get_current_intention_op (agent) ---&gt; mental_state  Result:​ get the current intention. Examples:​ mental_state var0 &lt;- get_current_intention_op(self); // var0 equals nil   "},{"title":"get_decay​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_decay","content":"Possible uses:​ get_decay (emotion) ---&gt; float  Result:​ get the decay value of the given emotion Examples:​ get_decay(emotion)   "},{"title":"get_desire_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_desire_op","content":"Possible uses:​ agent get_desire_op predicate ---&gt; mental_stateget_desire_op (agent , predicate) ---&gt; mental_state  Result:​ get the desire in the desire base with the given predicate. Examples:​ mental_state var0 &lt;- get_belief_op(self,predicate(&quot;has_water&quot;)); // var0 equals nil   "},{"title":"get_desire_with_name_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_desire_with_name_op","content":"Possible uses:​ agent get_desire_with_name_op string ---&gt; mental_stateget_desire_with_name_op (agent , string) ---&gt; mental_state  Result:​ get the desire in the desire base with the given name. Examples:​ mental_state var0 &lt;- get_desire_with_name_op(self,&quot;has_water&quot;); // var0 equals nil   "},{"title":"get_desires_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_desires_op","content":"Possible uses:​ agent get_desires_op predicate ---&gt; list&amp;lt;mental_state&gt;get_desires_op (agent , predicate) ---&gt; list&amp;lt;mental_state&gt;  Result:​ get the desires in the desire base with the given predicate. Examples:​ get_desires_op(self,predicate(&quot;has_water&quot;))   "},{"title":"get_desires_with_name_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_desires_with_name_op","content":"Possible uses:​ agent get_desires_with_name_op string ---&gt; list&amp;lt;mental_state&gt;get_desires_with_name_op (agent , string) ---&gt; list&amp;lt;mental_state&gt;  Result:​ get the list of desires in the desire base which predicate has the given name. Examples:​ get_desires_with_name_op(self,&quot;has_water&quot;)   "},{"title":"get_dominance​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_dominance","content":"Possible uses:​ get_dominance (social_link) ---&gt; float  Result:​ get the dominance value of the given social link Examples:​ get_dominance(social_link1)   "},{"title":"get_familiarity​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_familiarity","content":"Possible uses:​ get_familiarity (social_link) ---&gt; float  Result:​ get the familiarity value of the given social link Examples:​ get_familiarity(social_link1)   "},{"title":"get_ideal_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_ideal_op","content":"Possible uses:​ agent get_ideal_op predicate ---&gt; mental_stateget_ideal_op (agent , predicate) ---&gt; mental_state  Result:​ get the ideal in the ideal base with the given name. Examples:​ mental_state var0 &lt;- get_ideal_op(self,predicate(&quot;has_water&quot;)); // var0 equals nil   "},{"title":"get_ideal_with_name_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_ideal_with_name_op","content":"Possible uses:​ agent get_ideal_with_name_op string ---&gt; mental_stateget_ideal_with_name_op (agent , string) ---&gt; mental_state  Result:​ get the ideal in the ideal base with the given name. Examples:​ mental_state var0 &lt;- get_ideal_with_name_op(self,&quot;has_water&quot;); // var0 equals nil   "},{"title":"get_ideals_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_ideals_op","content":"Possible uses:​ agent get_ideals_op predicate ---&gt; list&amp;lt;mental_state&gt;get_ideals_op (agent , predicate) ---&gt; list&amp;lt;mental_state&gt;  Result:​ get the ideal in the ideal base with the given name. Examples:​ get_ideals_op(self,predicate(&quot;has_water&quot;))   "},{"title":"get_ideals_with_name_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_ideals_with_name_op","content":"Possible uses:​ agent get_ideals_with_name_op string ---&gt; list&amp;lt;mental_state&gt;get_ideals_with_name_op (agent , string) ---&gt; list&amp;lt;mental_state&gt;  Result:​ get the list of ideals in the ideal base which predicate has the given name. Examples:​ get_ideals_with_name_op(self,&quot;has_water&quot;)   "},{"title":"get_intensity​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_intensity","content":"Possible uses:​ get_intensity (emotion) ---&gt; float  Result:​ get the intensity value of the given emotion Examples:​ get_intensity(emo1)   "},{"title":"get_intention_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_intention_op","content":"Possible uses:​ agent get_intention_op predicate ---&gt; mental_stateget_intention_op (agent , predicate) ---&gt; mental_state  Result:​ get the intention in the intention base with the given predicate. Examples:​ get_intention_op(self,predicate(&quot;has_water&quot;))   "},{"title":"get_intention_with_name_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_intention_with_name_op","content":"Possible uses:​ agent get_intention_with_name_op string ---&gt; mental_stateget_intention_with_name_op (agent , string) ---&gt; mental_state  Result:​ get the intention in the intention base with the given name. Examples:​ get_intention_with_name_op(self,&quot;has_water&quot;)   "},{"title":"get_intentions_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_intentions_op","content":"Possible uses:​ agent get_intentions_op predicate ---&gt; list&amp;lt;mental_state&gt;get_intentions_op (agent , predicate) ---&gt; list&amp;lt;mental_state&gt;  Result:​ get the intentions in the intention base with the given predicate. Examples:​ get_intentions_op(self,predicate(&quot;has_water&quot;))   "},{"title":"get_intentions_with_name_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_intentions_with_name_op","content":"Possible uses:​ agent get_intentions_with_name_op string ---&gt; list&amp;lt;mental_state&gt;get_intentions_with_name_op (agent , string) ---&gt; list&amp;lt;mental_state&gt;  Result:​ get the list of intentions in the intention base which predicate has the given name. Examples:​ get_intentions_with_name_op(self,&quot;has_water&quot;)   "},{"title":"get_lifetime​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_lifetime","content":"Possible uses:​ get_lifetime (mental_state) ---&gt; int  Result:​ get the lifetime value of the given mental state Examples:​ get_lifetime(mental_state1)   "},{"title":"get_liking​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_liking","content":"Possible uses:​ get_liking (social_link) ---&gt; float  Result:​ get the liking value of the given social link Examples:​ get_liking(social_link1)   "},{"title":"get_modality​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_modality","content":"Possible uses:​ get_modality (mental_state) ---&gt; string  Result:​ get the modality value of the given mental state Examples:​ get_modality(mental_state1)   "},{"title":"get_obligation_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_obligation_op","content":"Possible uses:​ agent get_obligation_op predicate ---&gt; mental_stateget_obligation_op (agent , predicate) ---&gt; mental_state  Result:​ get the obligation in the obligation base with the given predicate. Examples:​ mental_state var0 &lt;- get_obligation_op(self,predicate(&quot;has_water&quot;)); // var0 equals nil   "},{"title":"get_obligation_with_name_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_obligation_with_name_op","content":"Possible uses:​ agent get_obligation_with_name_op string ---&gt; mental_stateget_obligation_with_name_op (agent , string) ---&gt; mental_state  Result:​ get the obligation in the obligation base with the given name. Examples:​ mental_state var0 &lt;- get_obligation_with_name_op(self,&quot;has_water&quot;); // var0 equals nil   "},{"title":"get_obligations_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_obligations_op","content":"Possible uses:​ agent get_obligations_op predicate ---&gt; list&amp;lt;mental_state&gt;get_obligations_op (agent , predicate) ---&gt; list&amp;lt;mental_state&gt;  Result:​ get the obligations in the obligation base with the given predicate. Examples:​ get_obligations_op(self,predicate(&quot;has_water&quot;))   "},{"title":"get_obligations_with_name_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_obligations_with_name_op","content":"Possible uses:​ agent get_obligations_with_name_op string ---&gt; list&amp;lt;mental_state&gt;get_obligations_with_name_op (agent , string) ---&gt; list&amp;lt;mental_state&gt;  Result:​ get the list of obligations in the obligation base which predicate has the given name. Examples:​ get_obligations_with_name_op(self,&quot;has_water&quot;)   "},{"title":"get_plan_name​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_plan_name","content":"Possible uses:​ get_plan_name (BDIPlan) ---&gt; string  Result:​ get the name of a given plan Examples:​ get_plan_name(agent.current_plan)   "},{"title":"get_predicate​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_predicate","content":"Possible uses:​ get_predicate (mental_state) ---&gt; predicate  Result:​ get the predicate value of the given mental state Examples:​ get_predicate(mental_state1)   "},{"title":"get_solidarity​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_solidarity","content":"Possible uses:​ get_solidarity (social_link) ---&gt; float  Result:​ get the solidarity value of the given social link Examples:​ get_solidarity(social_link1)   "},{"title":"get_strength​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_strength","content":"Possible uses:​ get_strength (mental_state) ---&gt; float  Result:​ get the strength value of the given mental state Examples:​ get_strength(mental_state1)   "},{"title":"get_super_intention​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_super_intention","content":"Possible uses:​ get_super_intention (predicate) ---&gt; mental_state  Result:​ get the super intention linked to a mental state Examples:​ get_super_intention(get_belief(pred1))   "},{"title":"get_trust​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_trust","content":"Possible uses:​ get_trust (social_link) ---&gt; float  Result:​ get the familiarity value of the given social link Examples:​ get_familiarity(social_link1)   "},{"title":"get_truth​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_truth","content":"Possible uses:​ get_truth (predicate) ---&gt; bool  Result:​ evaluate the truth value of a predicate Examples:​ get_truth(pred1)   "},{"title":"get_uncertainties_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_uncertainties_op","content":"Possible uses:​ agent get_uncertainties_op predicate ---&gt; list&amp;lt;mental_state&gt;get_uncertainties_op (agent , predicate) ---&gt; list&amp;lt;mental_state&gt;  Result:​ get the uncertainties in the uncertainty base with the given predicate. Examples:​ get_uncertainties_op(self,predicate(&quot;has_water&quot;))   "},{"title":"get_uncertainties_with_name_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_uncertainties_with_name_op","content":"Possible uses:​ agent get_uncertainties_with_name_op string ---&gt; list&amp;lt;mental_state&gt;get_uncertainties_with_name_op (agent , string) ---&gt; list&amp;lt;mental_state&gt;  Result:​ get the list of uncertainties in the uncertainty base which predicate has the given name. Examples:​ get_uncertainties_with_name_op(self,&quot;has_water&quot;)   "},{"title":"get_uncertainty_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_uncertainty_op","content":"Possible uses:​ agent get_uncertainty_op predicate ---&gt; mental_stateget_uncertainty_op (agent , predicate) ---&gt; mental_state  Result:​ get the uncertainty in the uncertainty base with the given predicate. Examples:​ mental_state var0 &lt;- get_uncertainty_op(self,predicate(&quot;has_water&quot;)); // var0 equals nil   "},{"title":"get_uncertainty_with_name_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_uncertainty_with_name_op","content":"Possible uses:​ agent get_uncertainty_with_name_op string ---&gt; mental_stateget_uncertainty_with_name_op (agent , string) ---&gt; mental_state  Result:​ get the uncertainty in the uncertainty base with the given name. Examples:​ mental_state var0 &lt;- get_uncertainty_with_name_op(self,&quot;has_water&quot;); // var0 equals nil   "},{"title":"get_values​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#get_values","content":"Possible uses:​ get_values (predicate) ---&gt; map&amp;lt;string,unknown&gt;  Result:​ return the map values of a predicate Examples:​ get_values(pred1)   "},{"title":"gif_file​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#gif_file","content":"Possible uses:​ gif_file (string) ---&gt; filestring gif_file matrix&amp;lt;int&gt; ---&gt; filegif_file (string , matrix&amp;lt;int&gt;) ---&gt; file  Result:​ Constructs a file of type gif. Allowed extensions are limited to gif Special cases:​ gif_file(string): This file constructor allows to read a gif file  gif_file f &lt;- gif_file(&quot;file.gif&quot;);  gif_file(string,matrix&lt;int&gt;): This file constructor allows to store a matrix in a gif file (it does not save it - just store it in memory)  gif_file f &lt;- gif_file(&quot;file.gif&quot;,matrix([10,10],[10,10]));  See also: is_gif,  "},{"title":"gini​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#gini","content":"Possible uses:​ gini (list&amp;lt;float&gt;) ---&gt; float Special cases:​ return the Gini Index of the given list of values (list of floats)  float var0 &lt;- gini([1.0, 0.5, 2.0]); // var0 equals the gini index computed i.e. 0.2857143   "},{"title":"girvan_newman_clustering​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#girvan_newman_clustering","content":"Possible uses:​ graph girvan_newman_clustering int ---&gt; listgirvan_newman_clustering (graph , int) ---&gt; list  Result:​ The Girvan�Newman algorithm is a hierarchical method used to detect communities. It detects communities by progressively removing edges from the original network.It returns a list of list of vertices and takes as operand the graph and the number of clusters  "},{"title":"gml_file​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#gml_file","content":"Possible uses:​ gml_file (string) ---&gt; filestring gml_file int ---&gt; filegml_file (string , int) ---&gt; filestring gml_file string ---&gt; filegml_file (string , string) ---&gt; filestring gml_file bool ---&gt; filegml_file (string , bool) ---&gt; filegml_file (string, int, bool) ---&gt; filegml_file (string, string, bool) ---&gt; file  Result:​ Constructs a file of type gml. Allowed extensions are limited to gml Special cases:​ gml_file(string): This file constructor allows to read a gml file  file f &lt;- gml_file(&quot;file.gml&quot;);  gml_file(string,int): This file constructor allows to read a gml file and specifying the coordinates system code, as an int (epsg code)  file f &lt;- gml_file(&quot;file.gml&quot;, 32648);  gml_file(string,string): This file constructor allows to read a gml file and specifying the coordinates system code (epg,...,), as a string  file f &lt;- gml_file(&quot;file.gml&quot;, &quot;EPSG:32648&quot;);  gml_file(string,bool): This file constructor allows to read a gml file and take a potential z value (not taken in account by default)  file f &lt;- gml_file(&quot;file.gml&quot;, true);  gml_file(string,int,bool): This file constructor allows to read a gml file, specifying the coordinates system code, as an int (epsg code) and take a potential z value (not taken in account by default)  file f &lt;- gml_file(&quot;file.gml&quot;, 32648, true);  gml_file(string,string,bool): This file constructor allows to read a gml file, specifying the coordinates system code (epg,...,), as a string and take a potential z value (not taken in account by default  file f &lt;- gml_file(&quot;file.gml&quot;, &quot;EPSG:32648&quot;,true);  See also: is_gml,  "},{"title":"gradient​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#gradient","content":"Possible uses:​ gradient (map&amp;lt;rgb,float&gt;) ---&gt; map&amp;lt;rgb,float&gt;gradient (list&amp;lt;rgb&gt;) ---&gt; map&amp;lt;rgb,float&gt;rgb gradient rgb ---&gt; map&amp;lt;rgb,float&gt;gradient (rgb , rgb) ---&gt; map&amp;lt;rgb,float&gt;gradient (rgb, rgb, float) ---&gt; map&amp;lt;rgb,float&gt;  Result:​ returns the definition of a linear gradient between n colors provided with their positions on a scale between 0 and 1. A similar color map is returned, in the same color order, with all the positions normalized (so that they are shifted and scaled to fit between 0 and 1). Throws an error if the number of colors is less than 2 or if the positions are not strictly ordered returns the definition of a linear gradient between two colors, with a ratio (between 0 and 1, otherwise clamped) represented internally as a color map [start::0.0,(startr+stop(1-r))::r, stop::1.0]returns the definition of a linear gradient between n colors, represented internally as a color map [c1::1/n,c2::1/n, ... cn::1/n]returns the definition of a linear gradient between two colors, represented internally as a color map [start::0.0,stop::1.0]  "},{"title":"graph​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#graph","content":"Possible uses:​ graph (any) ---&gt; graph  Result:​ casts the operand in a graph object.  "},{"title":"graph6_file​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#graph6_file","content":"Possible uses:​ graph6_file (string) ---&gt; filestring graph6_file species ---&gt; filegraph6_file (string , species) ---&gt; filegraph6_file (string, species, species) ---&gt; file  Result:​ Constructs a file of type graph6. Allowed extensions are limited to graph6 Special cases:​ graph6_file(string): References a graph6 file by its filename graph6_file(string,species): References a graph6 file by its filename and the species to use to instantiate the nodes graph6_file(string,species,species): References a graph6 file by its filename and the species to use to instantiate the nodes and the edges  See also: is_graph6,  "},{"title":"graphdimacs_file​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#graphdimacs_file","content":"Possible uses:​ graphdimacs_file (string) ---&gt; filestring graphdimacs_file species ---&gt; filegraphdimacs_file (string , species) ---&gt; filegraphdimacs_file (string, species, species) ---&gt; file  Result:​ Constructs a file of type graphdimacs. Allowed extensions are limited to dimacs Special cases:​ graphdimacs_file(string): References a dimacs file by its filename graphdimacs_file(string,species): References a dimacs file by its filename and the species to use to instantiate the nodes graphdimacs_file(string,species,species): References a dimacs file by its filename and the species to use to instantiate the nodes and the edges  See also: is_graphdimacs,  "},{"title":"graphdot_file​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#graphdot_file","content":"Possible uses:​ graphdot_file (string) ---&gt; filestring graphdot_file species ---&gt; filegraphdot_file (string , species) ---&gt; filegraphdot_file (string, species, species) ---&gt; file  Result:​ Constructs a file of type graphdot. Allowed extensions are limited to dot Special cases:​ graphdot_file(string): References a dot graph file by its filename graphdot_file(string,species): References a dot graph file by its filename and the species to use to instantiate the nodes graphdot_file(string,species,species): References a dot graph file by its filename and the 2 species to use to instantiate the nodes and the edges  See also: is_graphdot,  "},{"title":"graphgexf_file​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#graphgexf_file","content":"Possible uses:​ graphgexf_file (string) ---&gt; filestring graphgexf_file species ---&gt; filegraphgexf_file (string , species) ---&gt; filegraphgexf_file (string, species, species) ---&gt; file  Result:​ Constructs a file of type graphgexf. Allowed extensions are limited to gexf Special cases:​ graphgexf_file(string): References a gexf graph file by its filename graphgexf_file(string,species): References a gexf graph file by its filename and the species to use to instantiate the nodes graphgexf_file(string,species,species): References a gexf graph file by its filename and the 2 species to use to instantiate the nodes and the edges  See also: is_graphgexf,  "},{"title":"graphgml_file​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#graphgml_file","content":"Possible uses:​ graphgml_file (string) ---&gt; filestring graphgml_file species ---&gt; filegraphgml_file (string , species) ---&gt; filegraphgml_file (string, species, species) ---&gt; file  Result:​ Constructs a file of type graphgml. Allowed extensions are limited to gml Special cases:​ graphgml_file(string): References a gml graph file by its filename graphgml_file(string,species): References a gml graph file by its filename and the species to use to instantiate the nodes graphgml_file(string,species,species): References a gml graph file by its filename and the 2 species to use to instantiate the nodes and the edges  See also: is_graphgml,  "},{"title":"graphml_file​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#graphml_file","content":"Possible uses:​ graphml_file (string) ---&gt; filestring graphml_file species ---&gt; filegraphml_file (string , species) ---&gt; filegraphml_file (string, species, species) ---&gt; file  Result:​ Constructs a file of type graphml. Allowed extensions are limited to graphml Special cases:​ graphml_file(string): References a graphml graph file by its filename graphml_file(string,species): References a graphml graph file by its filename and the species to use to instantiate the nodes graphml_file(string,species,species): References a graphml graph file by its filename and the 2 species to use to instantiate the nodes and the edges  See also: is_graphml,  "},{"title":"graphtsplib_file​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#graphtsplib_file","content":"Possible uses:​ graphtsplib_file (string) ---&gt; filestring graphtsplib_file species ---&gt; filegraphtsplib_file (string , species) ---&gt; filegraphtsplib_file (string, species, species) ---&gt; file  Result:​ Constructs a file of type graphtsplib. Allowed extensions are limited to tsplib Special cases:​ graphtsplib_file(string): References a tsplib graph file by its filename graphtsplib_file(string,species): References a tsplib graph file by its filename and the species to use to instantiate the nodes graphtsplib_file(string,species,species): References a tsplib graph file by its filename and the 2 species to use to instantiate the nodes and the edges  See also: is_graphtsplib,  "},{"title":"grayscale​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#grayscale","content":"Possible uses:​ grayscale (rgb) ---&gt; rgb  Result:​ Converts rgb color to grayscale value Comment:​ r=red, g=green, b=blue. Between 0 and 255 and gray = 0.299 * red + 0.587 * green + 0.114 * blue (Photoshop value) Examples:​ rgb var0 &lt;- grayscale (rgb(255,0,0)); // var0 equals to a dark grey  See also: rgb, hsb,  "},{"title":"grid_at​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#grid_at","content":"Possible uses:​ species grid_at point ---&gt; agentgrid_at (species , point) ---&gt; agent  Result:​ returns the cell of the grid (right-hand operand) at the position given by the right-hand operand Comment:​ If the left-hand operand is a point of floats, it is used as a point of ints. Special cases:​ if the left-hand operand is not a grid cell species, returns nil Examples:​ agent var0 &lt;- grid_cell grid_at {1,2}; // var0 equals the agent grid_cell with grid_x=1 and grid_y = 2   "},{"title":"grid_cells_to_graph​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#grid_cells_to_graph","content":"Possible uses:​ grid_cells_to_graph (container) ---&gt; graphcontainer grid_cells_to_graph species ---&gt; graphgrid_cells_to_graph (container , species) ---&gt; graph  Result:​ creates a graph from a list of cells (operand). An edge is created between neighbors. Examples:​ my_cell_graph&lt;-grid_cells_to_graph(cells_list)  See also: as_intersection_graph, as_edge_graph,  "},{"title":"grid_file​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#grid_file","content":"Possible uses:​ grid_file (string) ---&gt; filestring grid_file bool ---&gt; filegrid_file (string , bool) ---&gt; filestring grid_file int ---&gt; filegrid_file (string , int) ---&gt; filestring grid_file string ---&gt; filegrid_file (string , string) ---&gt; filestring grid_file field ---&gt; filegrid_file (string , field) ---&gt; file  Result:​ Constructs a file of type grid. Allowed extensions are limited to asc, tif Special cases:​ grid_file(string): This file constructor allows to read a asc file or a tif (geotif) file  file f &lt;- grid_file(&quot;file.asc&quot;);  grid_file(string,bool): This file constructor allows to read a asc file or a tif (geotif) file, but without converting it into shapes. Only a matrix of float values is created  file f &lt;- grid_file(&quot;file.asc&quot;, false);  grid_file(string,int): This file constructor allows to read a asc file or a tif (geotif) file specifying the coordinates system code, as an int (epsg code)  file f &lt;- grid_file(&quot;file.asc&quot;, 32648);  grid_file(string,string): This file constructor allows to read a asc file or a tif (geotif) file specifying the coordinates system code (epg,...,), as a string  file f &lt;- grid_file(&quot;file.asc&quot;,&quot;EPSG:32648&quot;);  grid_file(string,field): This allows to build a writable grid file from the values of a field  file f &lt;- grid_file(&quot;file.tif&quot;,my_field); save f;  See also: is_grid,  "},{"title":"group_by​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#group_by","content":"Possible uses:​ container group_by any expression ---&gt; mapgroup_by (container , any expression) ---&gt; map  Result:​ Returns a map, where the keys take the possible values of the right-hand operand and the map values are the list of elements of the left-hand operand associated to the key value Comment:​ in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. Special cases:​ if the left-hand operand is nil, group_by throws an error Examples:​ map var0 &lt;- [1,2,3,4,5,6,7,8] group_by (each &gt; 3); // var0 equals [false::[1, 2, 3], true::[4, 5, 6, 7, 8]] map var1 &lt;- g2 group_by (length(g2 out_edges_of each) ); // var1 equals [ 0::[node9, node7, node10, node8, node11], 1::[node6], 2::[node5], 3::[node4]] map var2 &lt;- (list(node) group_by (round(node(each).location.x)); // var2 equals [32::[node5], 21::[node1], 4::[node0], 66::[node2], 96::[node3]] map&amp;lt;bool,list&gt; var3 &lt;- [1::2, 3::4, 5::6] group_by (each &gt; 4); // var3 equals [false::[2, 4], true::[6]]  See also: first_with, last_with, where,  "},{"title":"harmonic_mean​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#harmonic_mean","content":"Possible uses:​ harmonic_mean (container) ---&gt; float  Result:​ the harmonic mean of the elements of the operand. See Harmonic_mean for more details. Comment:​ The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded. Examples:​ float var0 &lt;- harmonic_mean ([4.5, 3.5, 5.5, 7.0]); // var0 equals 4.804159445407279  See also: mean, median, geometric_mean,  "},{"title":"has_belief_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#has_belief_op","content":"Possible uses:​ agent has_belief_op predicate ---&gt; boolhas_belief_op (agent , predicate) ---&gt; bool  Result:​ indicates if there already is a belief about the given predicate. Examples:​ bool var0 &lt;- has_belief_op(self,predicate(&quot;has_water&quot;)); // var0 equals false   "},{"title":"has_belief_with_name_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#has_belief_with_name_op","content":"Possible uses:​ agent has_belief_with_name_op string ---&gt; boolhas_belief_with_name_op (agent , string) ---&gt; bool  Result:​ indicates if there already is a belief about the given name. Examples:​ bool var0 &lt;- has_belief_with_name_op(self,&quot;has_water&quot;); // var0 equals false   "},{"title":"has_desire_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#has_desire_op","content":"Possible uses:​ agent has_desire_op predicate ---&gt; boolhas_desire_op (agent , predicate) ---&gt; bool  Result:​ indicates if there already is a desire about the given predicate. Examples:​ bool var0 &lt;- has_desire_op(self,predicate(&quot;has_water&quot;)); // var0 equals false   "},{"title":"has_desire_with_name_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#has_desire_with_name_op","content":"Possible uses:​ agent has_desire_with_name_op string ---&gt; boolhas_desire_with_name_op (agent , string) ---&gt; bool  Result:​ indicates if there already is a desire about the given name. Examples:​ bool var0 &lt;- has_desire_with_name_op(self,&quot;has_water&quot;); // var0 equals false   "},{"title":"has_ideal_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#has_ideal_op","content":"Possible uses:​ agent has_ideal_op predicate ---&gt; boolhas_ideal_op (agent , predicate) ---&gt; bool  Result:​ indicates if there already is an ideal about the given predicate. Examples:​ bool var0 &lt;- has_ideal_op(self,predicate(&quot;has_water&quot;)); // var0 equals false   "},{"title":"has_ideal_with_name_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#has_ideal_with_name_op","content":"Possible uses:​ agent has_ideal_with_name_op string ---&gt; boolhas_ideal_with_name_op (agent , string) ---&gt; bool  Result:​ indicates if there already is an ideal about the given name. Examples:​ bool var0 &lt;- has_ideal_with_name_op(self,&quot;has_water&quot;); // var0 equals false   "},{"title":"has_intention_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#has_intention_op","content":"Possible uses:​ agent has_intention_op predicate ---&gt; boolhas_intention_op (agent , predicate) ---&gt; bool  Result:​ indicates if there already is an intention about the given predicate. Examples:​ bool var0 &lt;- has_intention_op(self,predicate(&quot;has_water&quot;)); // var0 equals false   "},{"title":"has_intention_with_name_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#has_intention_with_name_op","content":"Possible uses:​ agent has_intention_with_name_op string ---&gt; boolhas_intention_with_name_op (agent , string) ---&gt; bool  Result:​ indicates if there already is an intention about the given name. Examples:​ bool var0 &lt;- has_intention_with_name_op(self,&quot;has_water&quot;); // var0 equals false   "},{"title":"has_obligation_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#has_obligation_op","content":"Possible uses:​ agent has_obligation_op predicate ---&gt; boolhas_obligation_op (agent , predicate) ---&gt; bool  Result:​ indicates if there already is an obligation about the given predicate. Examples:​ bool var0 &lt;- has_obligation_op(self,predicate(&quot;has_water&quot;)); // var0 equals false   "},{"title":"has_obligation_with_name_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#has_obligation_with_name_op","content":"Possible uses:​ agent has_obligation_with_name_op string ---&gt; boolhas_obligation_with_name_op (agent , string) ---&gt; bool  Result:​ indicates if there already is an obligation about the given name. Examples:​ bool var0 &lt;- has_obligation_with_name_op(self,&quot;has_water&quot;); // var0 equals false   "},{"title":"has_uncertainty_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#has_uncertainty_op","content":"Possible uses:​ agent has_uncertainty_op predicate ---&gt; boolhas_uncertainty_op (agent , predicate) ---&gt; bool  Result:​ indicates if there already is an uncertainty about the given predicate. Examples:​ bool var0 &lt;- has_uncertainty_op(self,predicate(&quot;has_water&quot;)); // var0 equals false   "},{"title":"has_uncertainty_with_name_op​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#has_uncertainty_with_name_op","content":"Possible uses:​ agent has_uncertainty_with_name_op string ---&gt; boolhas_uncertainty_with_name_op (agent , string) ---&gt; bool  Result:​ indicates if there already is an uncertainty about the given name. Examples:​ bool var0 &lt;- has_uncertainty_with_name_op(self,&quot;has_water&quot;); // var0 equals false   "},{"title":"hexagon​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#hexagon","content":"Possible uses:​ hexagon (point) ---&gt; geometryhexagon (float) ---&gt; geometryfloat hexagon float ---&gt; geometryhexagon (float , float) ---&gt; geometry  Result:​ A hexagon geometry which the given with and height Comment:​ the center of the hexagon is by default the location of the current agent in which has been called this operator. Special cases:​ returns nil if the operand is nil. Examples:​ geometry var0 &lt;- hexagon(10,5); // var0 equals a geometry as a hexagon of width of 10 and height of 5. geometry var1 &lt;- hexagon({10,5}); // var1 equals a geometry as a hexagon of width of 10 and height of 5. geometry var2 &lt;- hexagon(10); // var2 equals a geometry as a hexagon of width of 10 and height of 10.  See also: around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, triangle,  "},{"title":"hierarchical_clustering​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#hierarchical_clustering","content":"Possible uses:​ container&amp;lt;unknown,agent&gt; hierarchical_clustering float ---&gt; listhierarchical_clustering (container&amp;lt;unknown,agent&gt; , float) ---&gt; list  Result:​ A tree (list of list) contained groups of agents clustered by distance considering a distance min between two groups. Comment:​ use of hierarchical clustering with Minimum for linkage criterion between two groups of agents. Examples:​ list var0 &lt;- [ag1, ag2, ag3, ag4, ag5] hierarchical_clustering 20.0; // var0 equals for example, can return [[[ag1],[ag3]], [ag2], [[[ag4],[ag5]],[ag6]]  See also: simple_clustering_by_distance,  "},{"title":"horizontal​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#horizontal","content":"Possible uses:​ horizontal (map&amp;lt;unknown,int&gt;) ---&gt; unknown&amp;lt;string&gt;  Result:​ Creates a horizontal layout node (a sash). Sashes can contain any number (&gt; 1) of other elements: stacks, horizontal or vertical sashes, or display indices. Each element is represented by a pair in the map, where the key is the element and the value its weight within the sash  "},{"title":"hsb​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#hsb","content":"Possible uses:​ hsb (float, float, float) ---&gt; rgbhsb (float, float, float, int) ---&gt; rgbhsb (float, float, float, float) ---&gt; rgb  Result:​ Converts hsb (h=hue, s=saturation, b=brightness) value to Gama color Comment:​ h,s and b components should be floating-point values between 0.0 and 1.0 and when used alpha should be an integer (between 0 and 255) or a float (between 0 and 1) . Examples: Red=(0.0,1.0,1.0), Yellow=(0.16,1.0,1.0), Green=(0.33,1.0,1.0), Cyan=(0.5,1.0,1.0), Blue=(0.66,1.0,1.0), Magenta=(0.83,1.0,1.0) Examples:​ rgb var0 &lt;- hsb (0.5,1.0,1.0,0.0); // var0 equals rgb(&quot;cyan&quot;,0) rgb var1 &lt;- hsb (0.0,1.0,1.0); // var1 equals rgb(&quot;red&quot;)  See also: rgb,  "},{"title":"hypot​","type":1,"pageTitle":"Operators (D to H)","url":"wiki/OperatorsDH#hypot","content":"Possible uses:​ hypot (float, float, float, float) ---&gt; float  Result:​ Returns sqrt(x2 +y2) without intermediate overflow or underflow. Special cases:​ If either argument is infinite, then the result is positive infinity. If either argument is NaN and neither argument is infinite, then the result is NaN. Examples:​ float var0 &lt;- hypot(0,1,0,1); // var0 equals sqrt(2)  "},{"title":"Operators (I to M)","type":0,"sectionRef":"#","url":"wiki/OperatorsIM","content":"","keywords":""},{"title":"Definition​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#definition","content":"Operators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function. Most of them use a classical prefixed functional syntax (i.e. operator_name(operand1, operand2, operand3), see below), with the exception of arithmetic (e.g. +, /), logical (and, or), comparison (e.g. &gt;, &lt;), access (., [..]) and pair (::) operators, which require an infixed notation (i.e. operand1 operator_symbol operand1). The ternary functional if-else operator, ? :, uses a special infixed syntax composed with two symbols (e.g. operand1 ? operand2 : operand3). Two unary operators (- and !) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g. - 10, ! (operand1 or operand2)). Finally, special constructor operators ({...} for constructing points, [...] for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. {1,2,3}, [operand1, operand2, ..., operandn] or [key1::value1, key2::value2... keyn::valuen]). With the exception of these special cases above, the following rules apply to the syntax of operators: if they only have one operand, the functional prefixed syntax is mandatory (e.g. operator_name(operand1))if they have two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2)) or the infixed syntax (e.g. operand1 operator_name operand2) can be used.if they have more than two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2, ..., operand)) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. operand1 operator_name(operand2, ..., operand)) can be used. All of these alternative syntaxes are completely equivalent. Operators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.  "},{"title":"Priority between operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#priority-between-operators","content":"The priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first. GAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely: the constructor operators, like ::, used to compose pairs of operands, have the lowest priority of all operators (e.g. a &gt; b :: b &gt; c will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, [a &gt; 10, b &gt; 5] will return a list of boolean values.it is followed by the ?: operator, the functional if-else (e.g. a &gt; b ? a + 10 : a - 10 will return the result of the if-else).next are the logical operators, and and or (e.g. a &gt; b or b &gt; c will return the value of the test)next are the comparison operators (i.e. &gt;, &lt;, &lt;=, &gt;=, =, !=)next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)next the unary operators - and !next the access operators . and [] (e.g. {1,2,3}.x &gt; 20 + {4,5,6}.y will return the result of the comparison between the x and y ordinates of the two points)and finally the functional operators, which have the highest priority of all.  "},{"title":"Using actions as operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#using-actions-as-operators","content":"Actions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand. For instance, if the following species is defined: species spec1 { int min(int x, int y) { return x &gt; y ? x : y; } }  Any agent instance of spec1 can use min as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable: global { init { create spec1; spec1 my_agent &lt;- spec1[0]; int the_min &lt;- my_agent min(10,20); // or min(my_agent, 10, 20); } }  If the action doesn't have any operands, the syntax to use is my_agent the_action(). Finally, if it does not return a value, it might still be used but is considering as returning a value of type unknown (e.g. unknown result &lt;- my_agent the_action(op1, op2);). Note that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).  "},{"title":"Table of Contents​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#table-of-contents","content":" "},{"title":"Operators by categories​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#operators-by-categories","content":" "},{"title":"3D​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#3d","content":"box, cone3D, cube, cylinder, hexagon, pyramid, set_z, sphere, teapot,  "},{"title":"Arithmetic operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#arithmetic-operators","content":"-, /, ^, *, +, abs, acos, asin, atan, atan2, ceil, cos, cos_rad, div, even, exp, fact, floor, hypot, is_finite, is_number, ln, log, mod, round, signum, sin, sin_rad, sqrt, tan, tan_rad, tanh, with_precision,  "},{"title":"BDI​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#bdi","content":"add_values, and, eval_when, get_about, get_agent, get_agent_cause, get_belief_op, get_belief_with_name_op, get_beliefs_op, get_beliefs_with_name_op, get_current_intention_op, get_decay, get_desire_op, get_desire_with_name_op, get_desires_op, get_desires_with_name_op, get_dominance, get_familiarity, get_ideal_op, get_ideal_with_name_op, get_ideals_op, get_ideals_with_name_op, get_intensity, get_intention_op, get_intention_with_name_op, get_intentions_op, get_intentions_with_name_op, get_lifetime, get_liking, get_modality, get_obligation_op, get_obligation_with_name_op, get_obligations_op, get_obligations_with_name_op, get_plan_name, get_predicate, get_solidarity, get_strength, get_super_intention, get_trust, get_truth, get_uncertainties_op, get_uncertainties_with_name_op, get_uncertainty_op, get_uncertainty_with_name_op, get_values, has_belief_op, has_belief_with_name_op, has_desire_op, has_desire_with_name_op, has_ideal_op, has_ideal_with_name_op, has_intention_op, has_intention_with_name_op, has_obligation_op, has_obligation_with_name_op, has_uncertainty_op, has_uncertainty_with_name_op, new_emotion, new_mental_state, new_predicate, new_social_link, not, or, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_lifetime, set_liking, set_modality, set_predicate, set_solidarity, set_strength, set_trust, set_truth, with_values,  "},{"title":"Casting operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#casting-operators","content":"as, as_int, as_matrix, font, is, is_skill, list_with, matrix_with, species, to_gaml, topology,  "},{"title":"Color-related operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#color-related-operators","content":"-, /, *, +, blend, brewer_colors, brewer_palettes, gradient, grayscale, hsb, mean, median, palette, rgb, rnd_color, scale, sum,  "},{"title":"Comparison operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#comparison-operators","content":"!=, &lt;, &lt;=, =, &gt;, &gt;=, between,  "},{"title":"Containers-related operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#containers-related-operators","content":"-, ::, +, accumulate, all_match, among, at, cartesian_product, collect, contains, contains_all, contains_any, contains_key, count, empty, every, first, first_with, get, group_by, in, index_by, inter, interleave, internal_integrated_value, last, last_with, length, max, max_of, mean, mean_of, median, min, min_of, mul, none_matches, one_matches, one_of, product_of, range, remove_duplicates, reverse, shuffle, sort_by, split, split_in, split_using, sum, sum_of, union, variance_of, where, with_max_of, with_min_of,  "},{"title":"Date-related operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#date-related-operators","content":"-, !=, +, &lt;, &lt;=, =, &gt;, &gt;=, after, before, between, every, milliseconds_between, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_weeks, minus_years, months_between, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_weeks, plus_years, since, to, until, years_between,  "},{"title":"Dates​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#dates","content":" "},{"title":"Displays​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#displays","content":"horizontal, stack, vertical,  "},{"title":"edge​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#edge","content":"edge_between, strahler,  "},{"title":"EDP-related operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#edp-related-operators","content":"diff, diff2,  "},{"title":"Files-related operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#files-related-operators","content":"copy_file, crs, csv_file, delete_file, dxf_file, evaluate_sub_model, file_exists, folder, folder_exists, gaml_file, geojson_file, get, gif_file, gml_file, graph6_file, graphdimacs_file, graphdot_file, graphgexf_file, graphgml_file, graphml_file, graphtsplib_file, grid_file, image_file, is_csv, is_dxf, is_gaml, is_geojson, is_gif, is_gml, is_graph6, is_graphdimacs, is_graphdot, is_graphgexf, is_graphgml, is_graphml, is_graphtsplib, is_grid, is_image, is_json, is_obj, is_osm, is_pgm, is_property, is_saved_simulation, is_shape, is_svg, is_text, is_threeds, is_xml, json_file, new_folder, obj_file, osm_file, pgm_file, property_file, read, rename_file, saved_simulation_file, shape_file, step_sub_model, svg_file, text_file, threeds_file, unzip, writable, xml_file, zip,  "},{"title":"FIPA-related operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#fipa-related-operators","content":"conversation, message,  "},{"title":"GamaMaterialType​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#gamamaterialtype","content":"material,  "},{"title":"GamaMetaType​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#gamametatype","content":"type_of,  "},{"title":"Gen*​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#gen","content":"add_attribute, add_census_file, add_mapper, add_marginals, add_range_attribute, with_generation_algo,  "},{"title":"Graphs-related operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#graphs-related-operators","content":"add_edge, add_node, adjacency, agent_from_geometry, all_pairs_shortest_path, alpha_index, as_distance_graph, as_edge_graph, as_intersection_graph, as_path, as_spatial_graph, beta_index, betweenness_centrality, biggest_cliques_of, connected_components_of, connectivity_index, contains_edge, contains_vertex, degree_of, directed, edge, edge_between, edge_betweenness, edges, gamma_index, generate_barabasi_albert, generate_complete_graph, generate_random_graph, generate_watts_strogatz, girvan_newman_clustering, grid_cells_to_graph, in_degree_of, in_edges_of, k_spanning_tree_clustering, label_propagation_clustering, layout_circle, layout_force, layout_force_FR, layout_force_FR_indexed, layout_grid, load_shortest_paths, main_connected_component, max_flow_between, maximal_cliques_of, nb_cycles, neighbors_of, node, nodes, out_degree_of, out_edges_of, path_between, paths_between, predecessors_of, remove_node_from, rewire_n, source_of, spatial_graph, strahler, successors_of, sum, target_of, undirected, use_cache, weight_of, with_k_shortest_path_algorithm, with_shortest_path_algorithm, with_weights,  "},{"title":"Grid-related operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#grid-related-operators","content":"as_4_grid, as_grid, as_hexagonal_grid, cell_at, cells_in, cells_overlapping, field, grid_at, neighbors_of, path_between, points_in, values_in,  "},{"title":"Iterator operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#iterator-operators","content":"accumulate, all_match, as_map, collect, count, create_map, first_with, frequency_of, group_by, index_by, last_with, max_of, mean_of, min_of, none_matches, one_matches, product_of, sort_by, sum_of, variance_of, where, where, where, with_max_of, with_min_of,  "},{"title":"List-related operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#list-related-operators","content":"all_indexes_of, copy_between, index_of, last_index_of,  "},{"title":"Logical operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#logical-operators","content":":, !, ?, add_3Dmodel, add_geometry, add_icon, and, or, xor,  "},{"title":"Map comparaison operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#map-comparaison-operators","content":"fuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,  "},{"title":"Map-related operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#map-related-operators","content":"as_map, create_map, index_of, last_index_of,  "},{"title":"Matrix-related operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#matrix-related-operators","content":"-, /, ., *, +, append_horizontally, append_vertically, column_at, columns_list, determinant, eigenvalues, index_of, inverse, last_index_of, row_at, rows_list, shuffle, trace, transpose,  "},{"title":"multicriteria operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#multicriteria-operators","content":"electre_DM, evidence_theory_DM, fuzzy_choquet_DM, promethee_DM, weighted_means_DM,  "},{"title":"Path-related operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#path-related-operators","content":"agent_from_geometry, all_pairs_shortest_path, as_path, load_shortest_paths, max_flow_between, path_between, path_to, paths_between, use_cache,  "},{"title":"Points-related operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#points-related-operators","content":"-, /, *, +, &lt;, &lt;=, &gt;, &gt;=, add_point, angle_between, any_location_in, centroid, closest_points_with, farthest_point_to, grid_at, norm, points_along, points_at, points_on,  "},{"title":"Random operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#random-operators","content":"binomial, flip, gamma_density, gamma_rnd, gamma_trunc_rnd, gauss, generate_terrain, lognormal_density, lognormal_rnd, lognormal_trunc_rnd, poisson, rnd, rnd_choice, sample, shuffle, skew_gauss, truncated_gauss, weibull_density, weibull_rnd, weibull_trunc_rnd,  "},{"title":"ReverseOperators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#reverseoperators","content":"restore_simulation, restore_simulation_from_file, save_simulation, serialize, serialize_agent,  "},{"title":"Shape​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#shape","content":"arc, box, circle, cone, cone3D, cross, cube, curve, cylinder, ellipse, elliptical_arc, envelope, geometry_collection, hexagon, line, link, plan, polygon, polyhedron, pyramid, rectangle, sphere, square, squircle, teapot, triangle,  "},{"title":"Spatial operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#spatial-operators","content":"-, *, +, add_point, agent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, angle_between, any_location_in, arc, around, as_4_grid, as_driving_graph, as_grid, as_hexagonal_grid, at_distance, at_location, box, centroid, circle, clean, clean_network, closest_points_with, closest_to, closest_tob, cone, cone3D, convex_hull, covering, covers, cross, crosses, crossing, crs, CRS_transform, cube, curve, cylinder, direction_between, disjoint_from, distance_between, distance_to, ellipse, elliptical_arc, envelope, farthest_point_to, farthest_to, geometry_collection, gini, hexagon, hierarchical_clustering, IDW, inside, inter, intersects, inverse_rotation, line, link, masked_by, moran, neighbors_at, neighbors_of, normalized_rotation, overlapping, overlaps, partially_overlapping, partially_overlaps, path_between, path_to, plan, points_along, points_at, points_on, polygon, polyhedron, pyramid, rectangle, rotated_by, rotation_composition, round, scaled_to, set_z, simple_clustering_by_distance, simplification, skeletonize, smooth, sphere, split_at, split_geometry, split_lines, square, squircle, teapot, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, touches, touching, towards, transformed_by, translated_by, triangle, triangulate, union, using, voronoi, with_precision, without_holes,  "},{"title":"Spatial properties operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#spatial-properties-operators","content":"covers, crosses, intersects, partially_overlaps, touches,  "},{"title":"Spatial queries operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#spatial-queries-operators","content":"agent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, at_distance, closest_to, covering, crossing, farthest_to, inside, neighbors_at, neighbors_of, overlapping, partially_overlapping, touching,  "},{"title":"Spatial relations operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#spatial-relations-operators","content":"direction_between, distance_between, distance_to, path_between, path_to, towards,  "},{"title":"Spatial statistical operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#spatial-statistical-operators","content":"hierarchical_clustering, simple_clustering_by_distance,  "},{"title":"Spatial transformations operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#spatial-transformations-operators","content":"-, *, +, as_4_grid, as_grid, as_hexagonal_grid, at_location, clean, clean_network, convex_hull, CRS_transform, inverse_rotation, normalized_rotation, rotated_by, rotation_composition, scaled_to, simplification, skeletonize, smooth, split_geometry, split_lines, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, transformed_by, translated_by, triangulate, voronoi, with_precision, without_holes,  "},{"title":"Species-related operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#species-related-operators","content":"index_of, last_index_of, of_generic_species, of_species,  "},{"title":"Statistical operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#statistical-operators","content":"auto_correlation, beta, binomial_coeff, binomial_complemented, binomial_sum, build, chi_square, chi_square_complemented, correlation, covariance, dbscan, distribution_of, distribution2d_of, dtw, durbin_watson, frequency_of, gamma, gamma_distribution, gamma_distribution_complemented, geometric_mean, gini, harmonic_mean, hierarchical_clustering, incomplete_beta, incomplete_gamma, incomplete_gamma_complement, kmeans, kurtosis, log_gamma, max, mean, mean_deviation, median, min, moment, moran, mul, normal_area, normal_density, normal_inverse, predict, pValue_for_fStat, pValue_for_tStat, quantile, quantile_inverse, rank_interpolated, rms, simple_clustering_by_distance, skewness, split, split_in, split_using, standard_deviation, student_area, student_t_inverse, sum, t_test, variance,  "},{"title":"Strings-related operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#strings-related-operators","content":"+, &lt;, &lt;=, &gt;, &gt;=, at, char, contains, contains_all, contains_any, copy_between, date, empty, first, in, indented_by, index_of, is_number, last, last_index_of, length, lower_case, regex_matches, replace, replace_regex, reverse, sample, shuffle, split_with, string, upper_case,  "},{"title":"SubModel​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#submodel","content":"load_sub_model,  "},{"title":"System​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#system","content":"., choose, command, copy, copy_to_clipboard, dead, enter, eval_gaml, every, is_error, is_reachable, is_warning, user_confirm, user_input_dialog, wizard, wizard_page,  "},{"title":"Time-related operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#time-related-operators","content":"date, string,  "},{"title":"Types-related operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#types-related-operators","content":"action, agent, attributes, BDIPlan, bool, container, directory, emotion, file, float, gaml_type, gen_population_generator, gen_range, geometry, graph, int, kml, list, map, matrix, mental_state, Norm, pair, path, point, predicate, regression, rgb, Sanction, skill, social_link, topology, unknown,  "},{"title":"User control operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#user-control-operators","content":"choose, enter, user_confirm, user_input_dialog, wizard, wizard_page,  "},{"title":"Operators​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#operators","content":" "},{"title":"IDW​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#idw","content":"Possible uses:​ IDW (container&amp;lt;unknown,geometry&gt;, map, int) ---&gt; map&amp;lt;geometry,float&gt;  Result:​ Inverse Distance Weighting (IDW) is a type of deterministic method for multivariate interpolation with a known scattered set of points. The assigned values to each geometry are calculated with a weighted average of the values available at the known points. See: http://en.wikipedia.org/wiki/Inverse_distance_weighting Usage: IDW (list of geometries, map of points (key: point, value: value), power parameter) Examples:​ map&amp;lt;geometry,float&gt; var0 &lt;- IDW([ag1, ag2, ag3, ag4, ag5],[{10,10}::25.0, {10,80}::10.0, {100,10}::15.0], 2); // var0 equals for example, can return [ag1::12.0, ag2::23.0,ag3::12.0,ag4::14.0,ag5::17.0]   "},{"title":"image_file​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#image_file","content":"Possible uses:​ image_file (string) ---&gt; filestring image_file matrix&amp;lt;int&gt; ---&gt; fileimage_file (string , matrix&amp;lt;int&gt;) ---&gt; file  Result:​ Constructs a file of type image. Allowed extensions are limited to tiff, jpg, jpeg, png, pict, bmp Special cases:​ image_file(string): This file constructor allows to read an image file (tiff, jpg, jpeg, png, pict, bmp)  file f &lt;-image_file(&quot;file.png&quot;);  image_file(string,matrix&lt;int&gt;): This file constructor allows to store a matrix in a image file (it does not save it - just store it in memory)  file f &lt;-image_file(&quot;file.png&quot;);  See also: is_image,  "},{"title":"in​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#in","content":"Possible uses:​ string in string ---&gt; boolin (string , string) ---&gt; boolunknown in container ---&gt; boolin (unknown , container) ---&gt; bool  Result:​ true if the right operand contains the left operand, false otherwise Comment:​ the definition of in depends on the container Special cases:​ if both operands are strings, returns true if the left-hand operand patterns is included in to the right-hand string; if the right operand is nil or empty, in returns false Examples:​ bool var0 &lt;- 'bc' in 'abcded'; // var0 equals true bool var1 &lt;- 2 in [1,2,3,4,5,6]; // var1 equals true bool var2 &lt;- 7 in [1,2,3,4,5,6]; // var2 equals false bool var3 &lt;- 3 in [1::2, 3::4, 5::6]; // var3 equals false bool var4 &lt;- 6 in [1::2, 3::4, 5::6]; // var4 equals true  See also: contains,  "},{"title":"in_degree_of​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#in_degree_of","content":"Possible uses:​ graph in_degree_of unknown ---&gt; intin_degree_of (graph , unknown) ---&gt; int  Result:​ returns the in degree of a vertex (right-hand operand) in the graph given as left-hand operand. Examples:​ int var1 &lt;- graphFromMap in_degree_of (node(3)); // var1 equals 2  See also: out_degree_of, degree_of,  "},{"title":"in_edges_of​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#in_edges_of","content":"Possible uses:​ graph in_edges_of unknown ---&gt; listin_edges_of (graph , unknown) ---&gt; list  Result:​ returns the list of the in-edges of a vertex (right-hand operand) in the graph given as left-hand operand. Examples:​ list var1 &lt;- graphFromMap in_edges_of node({12,45}); // var1 equals [LineString]  See also: out_edges_of,  "},{"title":"incomplete_beta​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#incomplete_beta","content":"Possible uses:​ incomplete_beta (float, float, float) ---&gt; float  Result:​ Returns the regularized integral of the beta function with arguments a and b, from zero to x. Examples:​ float var0 &lt;- incomplete_beta(2,3,0.9) with_precision(3); // var0 equals 0.996   "},{"title":"incomplete_gamma​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#incomplete_gamma","content":"Possible uses:​ float incomplete_gamma float ---&gt; floatincomplete_gamma (float , float) ---&gt; float  Result:​ Returns the regularized integral of the Gamma function with argument a to the integration end point x. Examples:​ float var0 &lt;- incomplete_gamma(1,5.3) with_precision(3); // var0 equals 0.995   "},{"title":"incomplete_gamma_complement​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#incomplete_gamma_complement","content":"Possible uses:​ float incomplete_gamma_complement float ---&gt; floatincomplete_gamma_complement (float , float) ---&gt; float  Result:​ Returns the complemented regularized incomplete Gamma function of the argument a and integration start point x. Comment:​ Is the complement to 1 of incomplete_gamma. Examples:​ float var0 &lt;- incomplete_gamma_complement(1,5.3) with_precision(3); // var0 equals 0.005   "},{"title":"indented_by​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#indented_by","content":"Possible uses:​ string indented_by int ---&gt; stringindented_by (string , int) ---&gt; string  Result:​ Converts a (possibly multiline) string by indenting it by a number -- specified by the second operand -- of tabulations to the right Examples:​ string var0 &lt;- &quot;my&quot; + indented_by(&quot;text&quot;, 1); // var0 equals &quot;my text&quot;   "},{"title":"index_by​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#index_by","content":"Possible uses:​ container index_by any expression ---&gt; mapindex_by (container , any expression) ---&gt; map  Result:​ produces a new map from the evaluation of the right-hand operand for each element of the left-hand operand Special cases:​ if the left-hand operand is nil, index_by throws an error. If the operation results in duplicate keys, only the first value corresponding to the key is kept Examples:​ map var0 &lt;- [1,2,3,4,5,6,7,8] index_by (each - 1); // var0 equals [0::1, 1::2, 2::3, 3::4, 4::5, 5::6, 6::7, 7::8]   "},{"title":"index_of​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#index_of","content":"Possible uses:​ string index_of string ---&gt; intindex_of (string , string) ---&gt; intmatrix index_of unknown ---&gt; pointindex_of (matrix , unknown) ---&gt; pointlist index_of unknown ---&gt; intindex_of (list , unknown) ---&gt; intspecies index_of unknown ---&gt; intindex_of (species , unknown) ---&gt; intmap&amp;lt;unknown,unknown&gt; index_of unknown ---&gt; unknownindex_of (map&amp;lt;unknown,unknown&gt; , unknown) ---&gt; unknown  Result:​ the index of the first occurence of the right operand in the left operand container Comment:​ The definition of index_of and the type of the index depend on the container Special cases:​ if the left operator is a species, returns the index of an agent in a species. If the argument is not an agent of this species, returns -1. Use int(agent) instead if the left operand is a map, index_of returns the index of a value or nil if the value is not mapped if both operands are strings, returns the index within the left-hand string of the first occurrence of the given right-hand string  int var0 &lt;- &quot;abcabcabc&quot; index_of &quot;ca&quot;; // var0 equals 2  if the left operand is a matrix, index_of returns the index as a point  point var1 &lt;- matrix([[1,2,3],[4,5,6]]) index_of 4; // var1 equals {1.0,0.0}  if the left operand is a list, index_of returns the index as an integer  int var2 &lt;- [1,2,3,4,5,6] index_of 4; // var2 equals 3 int var3 &lt;- [4,2,3,4,5,4] index_of 4; // var3 equals 0  Examples:​ unknown var4 &lt;- [1::2, 3::4, 5::6] index_of 4; // var4 equals 3  See also: at, last_index_of,  "},{"title":"inside​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#inside","content":"Possible uses:​ container&amp;lt;unknown,geometry&gt; inside geometry ---&gt; list&amp;lt;geometry&gt;inside (container&amp;lt;unknown,geometry&gt; , geometry) ---&gt; list&amp;lt;geometry&gt;  Result:​ A list of agents or geometries among the left-operand list, species or meta-population (addition of species), covered by the operand (casted as a geometry). Examples:​ list&amp;lt;geometry&gt; var0 &lt;- [ag1, ag2, ag3] inside(self); // var0 equals the agents among ag1, ag2 and ag3 that are covered by the shape of the right-hand argument. list&amp;lt;geometry&gt; var1 &lt;- (species1 + species2) inside (self); // var1 equals the agents among species species1 and species2 that are covered by the shape of the right-hand argument.  See also: neighbors_at, neighbors_of, closest_to, overlapping, agents_overlapping, agents_inside, agent_closest_to,  "},{"title":"int​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#int","content":"Possible uses:​ int (any) ---&gt; int  Result:​ casts the operand in a int object.  "},{"title":"inter​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#inter","content":"Possible uses:​ container inter container ---&gt; listinter (container , container) ---&gt; listgeometry inter geometry ---&gt; geometryinter (geometry , geometry) ---&gt; geometry  Result:​ the intersection of the two operands A geometry resulting from the intersection between the two geometries Comment:​ both containers are transformed into sets (so without duplicated element, cf. remove_deplicates operator) before the set intersection is computed. Special cases:​ if an operand is a graph, it will be transformed into the set of its nodes returns nil if one of the operands is nil if an operand is a map, it will be transformed into the set of its values  list var0 &lt;- [1::2, 3::4, 5::6] inter [2,4]; // var0 equals [2,4] list var1 &lt;- [1::2, 3::4, 5::6] inter [1,3]; // var1 equals []  if an operand is a matrix, it will be transformed into the set of the lines  list var2 &lt;- matrix([[3,2,1],[4,5,4]]) inter [3,4]; // var2 equals [3,4]  Examples:​ list var3 &lt;- [1,2,3,4,5,6] inter [2,4]; // var3 equals [2,4] list var4 &lt;- [1,2,3,4,5,6] inter [0,8]; // var4 equals [] geometry var5 &lt;- square(10) inter circle(5); // var5 equals circle(5)  See also: remove_duplicates, union, +, -,  "},{"title":"interleave​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#interleave","content":"Possible uses:​ interleave (container) ---&gt; list  Result:​ Returns a new list containing the interleaved elements of the containers contained in the operand Comment:​ the operand should be a list of lists of elements. The result is a list of elements. Examples:​ list var0 &lt;- interleave([1,2,4,3,5,7,6,8]); // var0 equals [1,2,4,3,5,7,6,8] list var1 &lt;- interleave([['e11','e12','e13'],['e21','e22','e23'],['e31','e32','e33']]); // var1 equals ['e11','e21','e31','e12','e22','e32','e13','e23','e33']   "},{"title":"internal_integrated_value​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#internal_integrated_value","content":"Possible uses:​ any expression internal_integrated_value any expression ---&gt; listinternal_integrated_value (any expression , any expression) ---&gt; list  Result:​ For internal use only. Corresponds to the implementation, for agents, of the access to containers with [index]  "},{"title":"intersecting​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#intersecting","content":"Same signification as overlapping  "},{"title":"intersection​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#intersection","content":"Same signification as inter  "},{"title":"intersects​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#intersects","content":"Possible uses:​ geometry intersects geometry ---&gt; boolintersects (geometry , geometry) ---&gt; bool  Result:​ A boolean, equal to true if the left-geometry (or agent/point) intersects the right-geometry (or agent/point). Special cases:​ if one of the operand is null, returns false. Examples:​ bool var0 &lt;- square(5) intersects {10,10}; // var0 equals false  See also: disjoint_from, crosses, overlaps, partially_overlaps, touches,  "},{"title":"inverse​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#inverse","content":"Possible uses:​ inverse (matrix) ---&gt; matrix&amp;lt;float&gt;  Result:​ The inverse matrix of the given matrix. If no inverse exists, returns a matrix that has properties that resemble that of an inverse. Examples:​ matrix&amp;lt;float&gt; var0 &lt;- inverse(matrix([[4,3],[3,2]])); // var0 equals matrix([[-2.0,3.0],[3.0,-4.0]])   "},{"title":"inverse_distance_weighting​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#inverse_distance_weighting","content":"Same signification as IDW  "},{"title":"inverse_rotation​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#inverse_rotation","content":"Possible uses:​ inverse_rotation (pair&amp;lt;float,point&gt;) ---&gt; pair&amp;lt;float,point&gt;  Result:​ The inverse rotation. It is a rotation around the same axis with the opposite angle. Examples:​ pair&amp;lt;float,point&gt; var0 &lt;- inverse_rotation(38.0::{1,1,1}); // var0 equals -38.0::{1,1,1}  See also: [rotation_composition, normalized_rotation](OperatorsSZ#rotation_composition, normalized_rotation),  "},{"title":"is​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is","content":"Possible uses:​ unknown is any expression ---&gt; boolis (unknown , any expression) ---&gt; bool  Result:​ returns true if the left operand is of the right operand type, false otherwise Examples:​ bool var0 &lt;- 0 is int; // var0 equals true bool var1 &lt;- an_agent is node; // var1 equals true bool var2 &lt;- 1 is float; // var2 equals false   "},{"title":"is_csv​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_csv","content":"Possible uses:​ is_csv (any) ---&gt; bool  Result:​ Tests whether the operand is a csv file. See also: csv_file,  "},{"title":"is_dxf​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_dxf","content":"Possible uses:​ is_dxf (any) ---&gt; bool  Result:​ Tests whether the operand is a dxf file. See also: dxf_file,  "},{"title":"is_error​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_error","content":"Possible uses:​ is_error (any expression) ---&gt; bool  Result:​ Returns whether or not the argument raises an error when evaluated  "},{"title":"is_finite​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_finite","content":"Possible uses:​ is_finite (float) ---&gt; bool  Result:​ Returns whether the argument is a finite number or not Examples:​ bool var0 &lt;- is_finite(4.66); // var0 equals true bool var1 &lt;- is_finite(#infinity); // var1 equals false   "},{"title":"is_gaml​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_gaml","content":"Possible uses:​ is_gaml (any) ---&gt; bool  Result:​ Tests whether the operand is a gaml file. See also: gaml_file,  "},{"title":"is_geojson​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_geojson","content":"Possible uses:​ is_geojson (any) ---&gt; bool  Result:​ Tests whether the operand is a geojson file. See also: geojson_file,  "},{"title":"is_gif​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_gif","content":"Possible uses:​ is_gif (any) ---&gt; bool  Result:​ Tests whether the operand is a gif file. See also: gif_file,  "},{"title":"is_gml​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_gml","content":"Possible uses:​ is_gml (any) ---&gt; bool  Result:​ Tests whether the operand is a gml file. See also: gml_file,  "},{"title":"is_graph6​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_graph6","content":"Possible uses:​ is_graph6 (any) ---&gt; bool  Result:​ Tests whether the operand is a graph6 file. See also: graph6_file,  "},{"title":"is_graphdimacs​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_graphdimacs","content":"Possible uses:​ is_graphdimacs (any) ---&gt; bool  Result:​ Tests whether the operand is a graphdimacs file. See also: graphdimacs_file,  "},{"title":"is_graphdot​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_graphdot","content":"Possible uses:​ is_graphdot (any) ---&gt; bool  Result:​ Tests whether the operand is a graphdot file. See also: graphdot_file,  "},{"title":"is_graphgexf​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_graphgexf","content":"Possible uses:​ is_graphgexf (any) ---&gt; bool  Result:​ Tests whether the operand is a graphgexf file. See also: graphgexf_file,  "},{"title":"is_graphgml​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_graphgml","content":"Possible uses:​ is_graphgml (any) ---&gt; bool  Result:​ Tests whether the operand is a graphgml file. See also: graphgml_file,  "},{"title":"is_graphml​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_graphml","content":"Possible uses:​ is_graphml (any) ---&gt; bool  Result:​ Tests whether the operand is a graphml file. See also: graphml_file,  "},{"title":"is_graphtsplib​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_graphtsplib","content":"Possible uses:​ is_graphtsplib (any) ---&gt; bool  Result:​ Tests whether the operand is a graphtsplib file. See also: graphtsplib_file,  "},{"title":"is_grid​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_grid","content":"Possible uses:​ is_grid (any) ---&gt; bool  Result:​ Tests whether the operand is a grid file. See also: grid_file,  "},{"title":"is_image​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_image","content":"Possible uses:​ is_image (any) ---&gt; bool  Result:​ Tests whether the operand is a image file. See also: image_file,  "},{"title":"is_json​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_json","content":"Possible uses:​ is_json (any) ---&gt; bool  Result:​ Tests whether the operand is a json file. See also: json_file,  "},{"title":"is_number​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_number","content":"Possible uses:​ is_number (float) ---&gt; boolis_number (string) ---&gt; bool  Result:​ Returns whether the argument is a real number or not tests whether the operand represents a numerical value Comment:​ Note that the symbol . should be used for a float value (a string with , will not be considered as a numeric value). Symbols e and E are also accepted. A hexadecimal value should begin with #. Examples:​ bool var0 &lt;- is_number(4.66); // var0 equals true bool var1 &lt;- is_number(#infinity); // var1 equals true bool var2 &lt;- is_number(#nan); // var2 equals false bool var3 &lt;- is_number(&quot;test&quot;); // var3 equals false bool var4 &lt;- is_number(&quot;123.56&quot;); // var4 equals true bool var5 &lt;- is_number(&quot;-1.2e5&quot;); // var5 equals true bool var6 &lt;- is_number(&quot;1,2&quot;); // var6 equals false bool var7 &lt;- is_number(&quot;#12FA&quot;); // var7 equals true   "},{"title":"is_obj​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_obj","content":"Possible uses:​ is_obj (any) ---&gt; bool  Result:​ Tests whether the operand is a obj file. See also: obj_file,  "},{"title":"is_osm​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_osm","content":"Possible uses:​ is_osm (any) ---&gt; bool  Result:​ Tests whether the operand is a osm file. See also: osm_file,  "},{"title":"is_pgm​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_pgm","content":"Possible uses:​ is_pgm (any) ---&gt; bool  Result:​ Tests whether the operand is a pgm file. See also: pgm_file,  "},{"title":"is_property​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_property","content":"Possible uses:​ is_property (any) ---&gt; bool  Result:​ Tests whether the operand is a property file. See also: property_file,  "},{"title":"is_reachable​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_reachable","content":"Possible uses:​ string is_reachable int ---&gt; boolis_reachable (string , int) ---&gt; boolis_reachable (string, int, int) ---&gt; bool  Result:​ Returns whether or not the given web address is reachable or not before a time_out time in milliseconds Examples:​ write sample(is_reachable(&quot;www.google.com&quot;, 200));   "},{"title":"is_saved_simulation​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_saved_simulation","content":"Possible uses:​ is_saved_simulation (any) ---&gt; bool  Result:​ Tests whether the operand is a saved_simulation file. See also: saved_simulation_file,  "},{"title":"is_shape​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_shape","content":"Possible uses:​ is_shape (any) ---&gt; bool  Result:​ Tests whether the operand is a shape file. See also: shape_file,  "},{"title":"is_skill​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_skill","content":"Possible uses:​ unknown is_skill string ---&gt; boolis_skill (unknown , string) ---&gt; bool  Result:​ returns true if the left operand is an agent whose species implements the right-hand skill name Examples:​ bool var0 &lt;- agentA is_skill 'moving'; // var0 equals true   "},{"title":"is_svg​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_svg","content":"Possible uses:​ is_svg (any) ---&gt; bool  Result:​ Tests whether the operand is a svg file. See also: svg_file,  "},{"title":"is_text​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_text","content":"Possible uses:​ is_text (any) ---&gt; bool  Result:​ Tests whether the operand is a text file. See also: text_file,  "},{"title":"is_threeds​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_threeds","content":"Possible uses:​ is_threeds (any) ---&gt; bool  Result:​ Tests whether the operand is a threeds file. See also: threeds_file,  "},{"title":"is_warning​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_warning","content":"Possible uses:​ is_warning (any expression) ---&gt; bool  Result:​ Returns whether or not the argument raises a warning when evaluated  "},{"title":"is_xml​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#is_xml","content":"Possible uses:​ is_xml (any) ---&gt; bool  Result:​ Tests whether the operand is a xml file. See also: xml_file,  "},{"title":"json_file​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#json_file","content":"Possible uses:​ json_file (string) ---&gt; filestring json_file map&amp;lt;string,unknown&gt; ---&gt; filejson_file (string , map&amp;lt;string,unknown&gt;) ---&gt; file  Result:​ Constructs a file of type json. Allowed extensions are limited to json Special cases:​ json_file(string): This file constructor allows to read a json file  file f &lt;-json_file(&quot;file.json&quot;);  json_file(string,map&lt;string,unknown&gt;): This constructor allows to store a map in a json file (it does not save it). The file can then be saved later using the save statement  file f &lt;-json_file(&quot;file.json&quot;, map([&quot;var1&quot;::1.0, &quot;var2&quot;::3.0]));  See also: is_json,  "},{"title":"k_spanning_tree_clustering​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#k_spanning_tree_clustering","content":"Possible uses:​ graph k_spanning_tree_clustering int ---&gt; listk_spanning_tree_clustering (graph , int) ---&gt; list  Result:​ The algorithm finds a minimum spanning tree T using Prim's algorithm, then executes Kruskal's algorithm only on the edges of T until k trees are formed. The resulting trees are the final clusters.It returns a list of list of vertices and takes as operand the graph and the number of clusters  "},{"title":"kappa​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#kappa","content":"Possible uses:​ kappa (list&amp;lt;unknown&gt;, list&amp;lt;unknown&gt;, list&amp;lt;unknown&gt;) ---&gt; floatkappa (list&amp;lt;unknown&gt;, list&amp;lt;unknown&gt;, list&amp;lt;unknown&gt;, list&amp;lt;unknown&gt;) ---&gt; float  Result:​ kappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20. kappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories, weights). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20. Examples:​ kappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3]) float var1 &lt;- kappa([1,3,5,1,5],[1,1,1,1,5],[1,3,5]); // var1 equals 0.3333333333333334 float var2 &lt;- kappa([1,1,1,1,5],[1,1,1,1,5],[1,3,5]); // var2 equals 1.0 float var3 &lt;- kappa([&quot;cat1&quot;,&quot;cat3&quot;,&quot;cat2&quot;,&quot;cat1&quot;,&quot;cat3&quot;],[&quot;cat1&quot;,&quot;cat3&quot;,&quot;cat2&quot;,&quot;cat3&quot;,&quot;cat1&quot;],[&quot;cat1&quot;,&quot;cat2&quot;,&quot;cat3&quot;], [1.0, 2.0, 3.0, 1.0, 5.0]); // var3 equals 0.29411764705882354   "},{"title":"kappa_sim​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#kappa_sim","content":"Possible uses:​ kappa_sim (list&amp;lt;unknown&gt;, list&amp;lt;unknown&gt;, list&amp;lt;unknown&gt;, list&amp;lt;unknown&gt;) ---&gt; floatkappa_sim (list&amp;lt;unknown&gt;, list&amp;lt;unknown&gt;, list&amp;lt;unknown&gt;, list&amp;lt;unknown&gt;, list&amp;lt;unknown&gt;) ---&gt; float  Result:​ kappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories). Reference: van Vliet, J., Bregt, A.K. &amp; Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8). Special cases:​ kappa_sim can be used with an additional weights operand  float var0 &lt;- kappa_sim([&quot;cat1&quot;,&quot;cat1&quot;,&quot;cat2&quot;,&quot;cat2&quot;,&quot;cat2&quot;],[&quot;cat1&quot;,&quot;cat3&quot;,&quot;cat2&quot;,&quot;cat1&quot;,&quot;cat3&quot;],[&quot;cat1&quot;,&quot;cat3&quot;,&quot;cat2&quot;,&quot;cat3&quot;,&quot;cat1&quot;],[&quot;cat1&quot;,&quot;cat2&quot;,&quot;cat3&quot;], [1.0, 2.0, 3.0, 1.0, 5.0]); // var0 equals 0.2702702702702703  Examples:​ float var1 &lt;- kappa_sim([&quot;cat1&quot;,&quot;cat1&quot;,&quot;cat2&quot;,&quot;cat2&quot;,&quot;cat2&quot;],[&quot;cat1&quot;,&quot;cat3&quot;,&quot;cat2&quot;,&quot;cat1&quot;,&quot;cat3&quot;],[&quot;cat1&quot;,&quot;cat3&quot;,&quot;cat2&quot;,&quot;cat3&quot;,&quot;cat1&quot;],[&quot;cat1&quot;,&quot;cat2&quot;,&quot;cat3&quot;]); // var1 equals 0.3333333333333335   "},{"title":"kmeans​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#kmeans","content":"Possible uses:​ list kmeans int ---&gt; list&amp;lt;list&gt;kmeans (list , int) ---&gt; list&amp;lt;list&gt;kmeans (list, int, int) ---&gt; list&amp;lt;list&gt;  Result:​ returns the list of clusters (list of instance indices) computed with the kmeans++ algorithm from the first operand data according to the number of clusters to split the data into (k) and the maximum number of iterations to run the algorithm.(If negative, no maximum will be used) (maxIt). Usage: kmeans(data,k,maxit) Special cases:​ The maximum number of (third operand) can be omitted.  list&amp;lt;list&gt; var1 &lt;- kmeans ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],2); // var1 equals [[0,2,3],[1]]  Examples:​ list&amp;lt;list&gt; var0 &lt;- kmeans ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],2,10); // var0 equals [[0,2,3],[1]]   "},{"title":"kml​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#kml","content":"Possible uses:​ kml (any) ---&gt; kml  Result:​ casts the operand in a kml object.  "},{"title":"kurtosis​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#kurtosis","content":"Possible uses:​ kurtosis (list) ---&gt; floatfloat kurtosis float ---&gt; floatkurtosis (float , float) ---&gt; float  Result:​ Returns the kurtosis from a moment and a standard deviation Returns the kurtosis (aka excess) of a list of values (kurtosis = { [n(n+1) / (n -1)(n - 2)(n-3)] sum[(x_i - mean)^4] / std^4 } - [3(n-1)^2 / (n-2)(n-3)]) Special cases:​ if the length of the list is lower than 3, returns NaN Examples:​ float var0 &lt;- kurtosis(3,12) with_precision(4); // var0 equals -2.9999 float var1 &lt;- kurtosis ([1,2,3,4,5]); // var1 equals -1.200000000000002 float var2 &lt;- kurtosis([13,2,1,4,1,2]) with_precision(4); // var2 equals 4.8083   "},{"title":"label_propagation_clustering​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#label_propagation_clustering","content":"Possible uses:​ graph label_propagation_clustering int ---&gt; listlabel_propagation_clustering (graph , int) ---&gt; list  Result:​ The algorithm is a near linear time algorithm capable of discovering communities in large graphs. It is described in detail in the following: Raghavan, U. N., Albert, R., and Kumara, S. (2007). Near linear time algorithm to detect community structures in large-scale networks. Physical review E, 76(3), 036106.It returns a list of list of vertices and takes as operand the graph and maximal number of iteration  "},{"title":"last​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#last","content":"Possible uses:​ last (string) ---&gt; stringlast (container&amp;lt;KeyType,ValueType&gt;) ---&gt; ValueTypeint last container ---&gt; listlast (int , container) ---&gt; list  Result:​ the last element of the operand Comment:​ the last operator behavior depends on the nature of the operand Special cases:​ if it is a map, last returns the value of the last pair (in insertion order) if it is a file, last returns the last element of the content of the file (that is also a container) if it is a population, last returns the last agent of the population if it is a graph, last returns a list containing the last edge created if it is a matrix, last returns the element at {length-1,length-1} in the matrix for a matrix of int or float, it will return 0 if the matrix is empty for a matrix of object or geometry, it will return nil if the matrix is empty if it is a string, last returns a string composed of its last character, or an empty string if the operand is empty  string var0 &lt;- last ('abce'); // var0 equals 'e'  if it is a list, last returns the last element of the list, or nil if the list is empty  int var1 &lt;- last ([1, 2, 3]); // var1 equals 3  See also: first,  "},{"title":"last_index_of​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#last_index_of","content":"Possible uses:​ map&amp;lt;unknown,unknown&gt; last_index_of unknown ---&gt; unknownlast_index_of (map&amp;lt;unknown,unknown&gt; , unknown) ---&gt; unknownmatrix last_index_of unknown ---&gt; pointlast_index_of (matrix , unknown) ---&gt; pointstring last_index_of string ---&gt; intlast_index_of (string , string) ---&gt; intspecies last_index_of unknown ---&gt; intlast_index_of (species , unknown) ---&gt; intlist last_index_of unknown ---&gt; intlast_index_of (list , unknown) ---&gt; int  Result:​ the index of the last occurence of the right operand in the left operand container Comment:​ The definition of last_index_of and the type of the index depend on the container Special cases:​ if the left operand is a species, the last index of an agent is the same as its index if the left operand is a map, last_index_of returns the index as an int (the key of the pair)  unknown var0 &lt;- [1::2, 3::4, 5::4] last_index_of 4; // var0 equals 5  if the left operand is a matrix, last_index_of returns the index as a point  point var1 &lt;- matrix([[1,2,3],[4,5,4]]) last_index_of 4; // var1 equals {1.0,2.0}  if both operands are strings, returns the index within the left-hand string of the rightmost occurrence of the given right-hand string  int var2 &lt;- &quot;abcabcabc&quot; last_index_of &quot;ca&quot;; // var2 equals 5  if the left operand is a list, last_index_of returns the index as an integer  int var3 &lt;- [1,2,3,4,5,6] last_index_of 4; // var3 equals 3 int var4 &lt;- [4,2,3,4,5,4] last_index_of 4; // var4 equals 5  See also: at, index_of, last_index_of,  "},{"title":"last_of​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#last_of","content":"Same signification as last  "},{"title":"last_with​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#last_with","content":"Possible uses:​ container last_with any expression ---&gt; unknownlast_with (container , any expression) ---&gt; unknown  Result:​ the last element of the left-hand operand that makes the right-hand operand evaluate to true. Comment:​ in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. Special cases:​ if the left-hand operand is nil, last_with throws an error. If there is no element that satisfies the condition, it returns nil if the left-operand is a map, the keyword each will contain each value  unknown var4 &lt;- [1::2, 3::4, 5::6] last_with (each &gt;= 4); // var4 equals 6 unknown var5 &lt;- [1::2, 3::4, 5::6].pairs last_with (each.value &gt;= 4); // var5 equals (5::6)  Examples:​ int var0 &lt;- [1,2,3,4,5,6,7,8] last_with (each &gt; 3); // var0 equals 8 unknown var2 &lt;- g2 last_with (length(g2 out_edges_of each) = 0 ); // var2 equals a node unknown var3 &lt;- (list(node) last_with (round(node(each).location.x) &gt; 32); // var3 equals node3  See also: group_by, first_with, where,  "},{"title":"layout_circle​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#layout_circle","content":"Possible uses:​ layout_circle (graph, geometry, bool) ---&gt; graph  Result:​ layouts a Gama graph on a circle with equidistance between nodes. For now there is no optimization on node ordering. Special cases:​ Usage: layoutCircle(graph, bound, shuffle) =&gt; graph : the graph to layout, bound : the geometry to display the graph within, shuffle : if true shuffle the nodes, then render same ordering Examples:​ layout_circle(graph, world.shape, false);   "},{"title":"layout_force​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#layout_force","content":"Possible uses:​ layout_force (graph, geometry, float, float, int) ---&gt; graphlayout_force (graph, geometry, float, float, int, float) ---&gt; graph  Result:​ layouts a GAMA graph using Force model (in a given spatial bound and given coeff_force, cooling_rate, max_iteration, and equilibirum criterion parameters). Special cases:​ usage: layoutForce(graph, bounds, coeff_force, cooling_rate, max_iteration). graph is the graph to which applied the layout; bounds is the shape (geometry) in which the graph should be located; coeff_force is the coefficient used to compute the force, typical value is 0.4; cooling rate is the decreasing coefficient of the temperature, typical value is 0.01; max_iteration is the maximal number of iterationsdistance of displacement for a vertice to be considered as in equilibrium usage: layoutForce(graph, bounds, coeff_force, cooling_rate, max_iteration, equilibirum criterion). graph is the graph to which applied the layout; bounds is the shape (geometry) in which the graph should be located; coeff_force is the coefficien use to compute the force, typical value is 0.4; cooling rate is the decreasing coefficient of the temperature, typical value is 0.01; max_iteration is the maximal number of iterations; equilibirum criterion is the maximaldistance of displacement for a vertice to be considered as in equilibrium  "},{"title":"layout_force_FR​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#layout_force_fr","content":"Possible uses:​ layout_force_FR (graph, geometry, float, int) ---&gt; graph  Result:​ layouts a GAMA graph using Fruchterman and Reingold Force-Directed Placement Algorithm (in a given spatial bound, normalization factor and max_iteration parameters). Special cases:​ usage: layoutForce(graph, bounds, normalization_factor, max_iteration, equilibirum criterion). graph is the graph to which applied the layout; bounds is the shape (geometry) in which the graph should be located; normalization_factor is the normalization factor for the optimal distance, typical value is 1.0; max_iteration is the maximal number of iterations  "},{"title":"layout_force_FR_indexed​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#layout_force_fr_indexed","content":"Possible uses:​ layout_force_FR_indexed (graph, geometry, float, float, int) ---&gt; graph  Result:​ layouts a GAMA graph using Fruchterman and Reingold Force-Directed Placement Algorithm with The Barnes-Hut indexing technique(in a given spatial bound, theta, normalization factor and max_iteration parameters). Special cases:​ usage: layoutForce(graph, bounds, normalization_factor, max_iteration, equilibirum criterion). graph is the graph to which applied the layout; bounds is the shape (geometry) in which the graph should be located; theta value for approximation using the Barnes-Hut technique, typical value is 0.5; normalization_factor is the normalization factor for the optimal distance, typical value is 1.0; max_iteration is the maximal number of iterations  "},{"title":"layout_grid​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#layout_grid","content":"Possible uses:​ layout_grid (graph, geometry, float) ---&gt; graph  Result:​ layouts a Gama graph based on a grid latice. usage: layoutForce(graph, bounds, coeff_nb_cells). graph is the graph to which &quot;  + &quot;applied the layout; bounds is the shape (geometry) in which the graph should be located; coeff_nb_cellsthe coefficient for the number of cells to locate the vertices (nb of places = coeff_nb_cells * nb of vertices).  Examples:​ layout_grid(graph, world.shape);   "},{"title":"length​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#length","content":"Possible uses:​ length (container&amp;lt;KeyType,ValueType&gt;) ---&gt; intlength (string) ---&gt; int  Result:​ the number of elements contained in the operand Comment:​ the length operator behavior depends on the nature of the operand Special cases:​ if it is a population, length returns number of agents of the population if it is a graph, length returns the number of vertexes or of edges (depending on the way it was created) if it is a list or a map, length returns the number of elements in the list or map  int var0 &lt;- length([12,13]); // var0 equals 2 int var1 &lt;- length([]); // var1 equals 0  if it is a matrix, length returns the number of cells  int var2 &lt;- length(matrix([[&quot;c11&quot;,&quot;c12&quot;,&quot;c13&quot;],[&quot;c21&quot;,&quot;c22&quot;,&quot;c23&quot;]])); // var2 equals 6  if it is a string, length returns the number of characters  int var3 &lt;- length ('I am an agent'); // var3 equals 13   "},{"title":"lgamma​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#lgamma","content":"Same signification as log_gamma  "},{"title":"line​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#line","content":"Possible uses:​ line (container&amp;lt;unknown,geometry&gt;) ---&gt; geometrycontainer&amp;lt;unknown,geometry&gt; line float ---&gt; geometryline (container&amp;lt;unknown,geometry&gt; , float) ---&gt; geometry  Result:​ A polyline geometry from the given list of points. Special cases:​ if the points list operand is nil, returns the point geometry {0,0} if the points list operand is composed of a single point, returns a point geometry. if a radius is added, the given list of points represented as a cylinder of radius r  geometry var0 &lt;- polyline([{0,0}, {0,10}, {10,10}, {10,0}],0.2); // var0 equals a polyline geometry composed of the 4 points.  Examples:​ geometry var1 &lt;- polyline([{0,0}, {0,10}, {10,10}]); // var1 equals a polyline geometry composed of the 3 points. geometry var2 &lt;- line([{10,10}, {10,0}]); // var2 equals a line from 2 points. string var3 &lt;- string(polyline([{0,0}, {0,10}, {10,10}])+line([{10,10}, {10,0}])); // var3 equals &quot;MULTILINESTRING ((0 0, 0 10, 10 10), (10 10, 10 0))&quot;  See also: around, circle, cone, link, norm, point, polygone, rectangle, square, triangle,  "},{"title":"link​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#link","content":"Possible uses:​ geometry link geometry ---&gt; geometrylink (geometry , geometry) ---&gt; geometry  Result:​ A dynamic line geometry between the location of the two operands Comment:​ The geometry of the link is a line between the locations of the two operands, which is built and maintained dynamically Special cases:​ if one of the operands is nil, link returns a point geometry at the location of the other. If both are null, it returns a point geometry at {0,0} Examples:​ geometry var0 &lt;- link (geom1,geom2); // var0 equals a link geometry between geom1 and geom2.  See also: around, circle, cone, line, norm, point, polygon, polyline, rectangle, square, triangle,  "},{"title":"list​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#list","content":"Possible uses:​ list (any) ---&gt; list  Result:​ casts the operand in a list object.  "},{"title":"list_with​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#list_with","content":"Possible uses:​ int list_with any expression ---&gt; listlist_with (int , any expression) ---&gt; list  Result:​ creates a list with a size provided by the first operand, and filled with the second operand Comment:​ Note that the first operand should be positive, and that the second one is evaluated for each position in the list. Examples:​ list var0 &lt;- list_with(5,2); // var0 equals [2,2,2,2,2]  See also: list,  "},{"title":"ln​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#ln","content":"Possible uses:​ ln (int) ---&gt; floatln (float) ---&gt; float  Result:​ Returns the natural logarithm (base e) of the operand. Special cases:​ an exception is raised if the operand is less than zero. Examples:​ float var0 &lt;- ln(1); // var0 equals 0.0 float var1 &lt;- ln(exp(1)); // var1 equals 1.0  See also: exp,  "},{"title":"load_shortest_paths​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#load_shortest_paths","content":"Possible uses:​ graph load_shortest_paths matrix ---&gt; graphload_shortest_paths (graph , matrix) ---&gt; graph  Result:​ put in the graph cache the computed shortest paths contained in the matrix (rows: source, columns: target) Examples:​ graph var0 &lt;- load_shortest_paths(shortest_paths_matrix); // var0 equals return my_graph with all the shortest paths computed   "},{"title":"load_sub_model​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#load_sub_model","content":"Possible uses:​ string load_sub_model string ---&gt; agentload_sub_model (string , string) ---&gt; agent  Result:​ Load a submodel Comment:​ loaded submodel  "},{"title":"log​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#log","content":"Possible uses:​ log (float) ---&gt; floatlog (int) ---&gt; float  Result:​ Returns the logarithm (base 10) of the operand. Special cases:​ an exception is raised if the operand is equals or less than zero. Examples:​ float var0 &lt;- log(10); // var0 equals 1.0 float var1 &lt;- log(1); // var1 equals 0.0  See also: ln,  "},{"title":"log_gamma​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#log_gamma","content":"Possible uses:​ log_gamma (float) ---&gt; float  Result:​ Returns the log of the value of the Gamma function at x. Examples:​ float var0 &lt;- log_gamma(0.6) with_precision(4); // var0 equals 0.3982   "},{"title":"lognormal_density​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#lognormal_density","content":"Possible uses:​ lognormal_density (float, float, float) ---&gt; float  Result:​ lognormal_density(x,shape,scale) returns the probability density function (PDF) at the specified point x of the logNormal distribution with the given shape and scale. Examples:​ float var0 &lt;- lognormal_density(1,2,3) ; // var0 equals 0.731  See also: binomial, gamma_rnd, gauss_rnd, poisson, rnd, skew_gauss, truncated_gauss, weibull_rnd, weibull_density, gamma_density,  "},{"title":"lognormal_rnd​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#lognormal_rnd","content":"Possible uses:​ float lognormal_rnd float ---&gt; floatlognormal_rnd (float , float) ---&gt; float  Result:​ returns a random value from a Log-Normal distribution with specified values of the shape (alpha) and scale (beta) parameters. See https://en.wikipedia.org/wiki/Log-normal_distribution for more details. Examples:​ float var0 &lt;- lognormal_rnd(2,3) ; // var0 equals 0.731  See also: binomial, gamma_rnd, gauss_rnd, poisson, rnd, skew_gauss, truncated_gauss, weibull_rnd, lognormal_trunc_rnd,  "},{"title":"lognormal_trunc_rnd​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#lognormal_trunc_rnd","content":"Possible uses:​ lognormal_trunc_rnd (float, float, float, bool) ---&gt; floatlognormal_trunc_rnd (float, float, float, float) ---&gt; float  Result:​ returns a random value from a truncated Log-Normal distribution (in a range or given only one boundary) with specified values of the shape (alpha) and scale (beta) parameters. See https://en.wikipedia.org/wiki/Log-normal_distribution for more details. Special cases:​ when 1 float and a boolean (isMax) operands are specified, the float value represents the single boundary (max if the boolean is true, min otherwise),  lognormal_trunc_rnd(2,3,5,true)  when 2 float operands are specified, they are taken as mininimum and maximum values for the result  lognormal_trunc_rnd(2,3,0,5)  See also: lognormal_rnd, gamma_trunc_rnd, weibull_trunc_rnd, truncated_gauss,  "},{"title":"lower_case​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#lower_case","content":"Possible uses:​ lower_case (string) ---&gt; string  Result:​ Converts all of the characters in the string operand to lower case Examples:​ string var0 &lt;- lower_case(&quot;Abc&quot;); // var0 equals 'abc'  See also: upper_case,  "},{"title":"main_connected_component​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#main_connected_component","content":"Possible uses:​ main_connected_component (graph) ---&gt; graph  Result:​ returns the sub-graph corresponding to the main connected components of the graph Examples:​ graph var0 &lt;- main_connected_component(my_graph); // var0 equals the sub-graph corresponding to the main connected components of the graph  See also: connected_components_of,  "},{"title":"map​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#map","content":"Possible uses:​ map (any) ---&gt; map  Result:​ casts the operand in a map object.  "},{"title":"masked_by​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#masked_by","content":"Possible uses:​ geometry masked_by container&amp;lt;unknown,geometry&gt; ---&gt; geometrymasked_by (geometry , container&amp;lt;unknown,geometry&gt;) ---&gt; geometrymasked_by (geometry, container&amp;lt;unknown,geometry&gt;, int) ---&gt; geometry Examples:​ geometry var0 &lt;- perception_geom masked_by obstacle_list; // var0 equals the geometry representing the part of perception_geom visible from the agent position considering the list of obstacles obstacle_list. geometry var1 &lt;- perception_geom masked_by obstacle_list; // var1 equals the geometry representing the part of perception_geom visible from the agent position considering the list of obstacles obstacle_list.   "},{"title":"material​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#material","content":"Possible uses:​ float material float ---&gt; materialmaterial (float , float) ---&gt; material  Result:​ Returns a material defined by a given damper and reflectivity  "},{"title":"matrix​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#matrix","content":"Possible uses:​ matrix (any) ---&gt; matrix  Result:​ casts the operand in a matrix object.  "},{"title":"matrix_with​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#matrix_with","content":"Possible uses:​ point matrix_with any expression ---&gt; matrixmatrix_with (point , any expression) ---&gt; matrix  Result:​ creates a matrix with a size provided by the first operand, and filled with the second operand Comment:​ Note that both components of the right operand point should be positive, otherwise an exception is raised. See also: matrix, as_matrix,  "},{"title":"max​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#max","content":"Possible uses:​ max (container) ---&gt; unknown  Result:​ the maximum element found in the operand Comment:​ the max operator behavior depends on the nature of the operand Special cases:​ if it is a population of a list of other type: max transforms all elements into integer and returns the maximum of them if it is a map, max returns the maximum among the list of all elements value if it is a file, max returns the maximum of the content of the file (that is also a container) if it is a graph, max returns the maximum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph) if it is a matrix of int, float or object, max returns the maximum of all the numerical elements (thus all elements for integer and float matrices) if it is a matrix of geometry, max returns the maximum of the list of the geometries if it is a matrix of another type, max returns the maximum of the elements transformed into float if it is a list of int of float, max returns the maximum of all the elements  unknown var0 &lt;- max ([100, 23.2, 34.5]); // var0 equals 100.0  if it is a list of points: max returns the maximum of all points as a point (i.e. the point with the greatest coordinate on the x-axis, in case of equality the point with the greatest coordinate on the y-axis is chosen. If all the points are equal, the first one is returned. )  unknown var1 &lt;- max([{1.0,3.0},{3.0,5.0},{9.0,1.0},{7.0,8.0}]); // var1 equals {9.0,1.0}  See also: min,  "},{"title":"max_flow_between​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#max_flow_between","content":"Possible uses:​ max_flow_between (graph, unknown, unknown) ---&gt; map&amp;lt;unknown,float&gt;  Result:​ The max flow (map&lt;edge,flow&gt; in a graph between the source and the sink using Edmonds-Karp algorithm Examples:​ max_flow_between(my_graph, vertice1, vertice2)   "},{"title":"max_of​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#max_of","content":"Possible uses:​ container max_of any expression ---&gt; unknownmax_of (container , any expression) ---&gt; unknown  Result:​ the maximum value of the right-hand expression evaluated on each of the elements of the left-hand operand Comment:​ in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. Special cases:​ As of GAMA 1.6, if the left-hand operand is nil or empty, max_of throws an error if the left-operand is a map, the keyword each will contain each value  unknown var4 &lt;- [1::2, 3::4, 5::6] max_of (each + 3); // var4 equals 9  Examples:​ unknown var0 &lt;- [1,2,4,3,5,7,6,8] max_of (each * 100 ); // var0 equals 800 graph g2 &lt;- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); unknown var2 &lt;- g2.vertices max_of (g2 degree_of( each )); // var2 equals 2 unknown var3 &lt;- (list(node) max_of (round(node(each).location.x)); // var3 equals 96  See also: min_of,  "},{"title":"maximal_cliques_of​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#maximal_cliques_of","content":"Possible uses:​ maximal_cliques_of (graph) ---&gt; list&amp;lt;list&gt;  Result:​ returns the maximal cliques of a graph using the Bron-Kerbosch clique detection algorithm: A clique is maximal if it is impossible to enlarge it by adding another vertex from the graph. Note that a maximal clique is not necessarily the biggest clique in the graph. Examples:​ graph my_graph &lt;- graph([]); list&amp;lt;list&gt; var1 &lt;- maximal_cliques_of (my_graph); // var1 equals the list of all the maximal cliques as list  See also: biggest_cliques_of,  "},{"title":"mean​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#mean","content":"Possible uses:​ mean (container) ---&gt; unknown  Result:​ the mean of all the elements of the operand Comment:​ the elements of the operand are summed (see sum for more details about the sum of container elements ) and then the sum value is divided by the number of elements. Special cases:​ if the container contains points, the result will be a point. If the container contains rgb values, the result will be a rgb color Examples:​ unknown var0 &lt;- mean ([4.5, 3.5, 5.5, 7.0]); // var0 equals 5.125  See also: sum,  "},{"title":"mean_deviation​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#mean_deviation","content":"Possible uses:​ mean_deviation (container) ---&gt; float  Result:​ the deviation from the mean of all the elements of the operand. See Mean_deviation for more details. Comment:​ The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded. Examples:​ float var0 &lt;- mean_deviation ([4.5, 3.5, 5.5, 7.0]); // var0 equals 1.125  See also: mean, standard_deviation,  "},{"title":"mean_of​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#mean_of","content":"Possible uses:​ container mean_of any expression ---&gt; unknownmean_of (container , any expression) ---&gt; unknown  Result:​ the mean of the right-hand expression evaluated on each of the elements of the left-hand operand Comment:​ in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. Special cases:​ if the left-operand is a map, the keyword each will contain each value  unknown var1 &lt;- [1::2, 3::4, 5::6] mean_of (each); // var1 equals 4  Examples:​ unknown var0 &lt;- [1,2] mean_of (each * 10 ); // var0 equals 15  See also: min_of, max_of, sum_of, product_of,  "},{"title":"median​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#median","content":"Possible uses:​ median (container) ---&gt; unknown  Result:​ the median of all the elements of the operand. Special cases:​ if the container contains points, the result will be a point. If the container contains rgb values, the result will be a rgb color Examples:​ unknown var0 &lt;- median ([4.5, 3.5, 5.5, 3.4, 7.0]); // var0 equals 4.5  See also: mean,  "},{"title":"mental_state​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#mental_state","content":"Possible uses:​ mental_state (any) ---&gt; mental_state  Result:​ casts the operand in a mental_state object.  "},{"title":"message​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#message","content":"Possible uses:​ message (unknown) ---&gt; message  Result:​ defines a new message that will be exchanged between agents.  "},{"title":"milliseconds_between​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#milliseconds_between","content":"Possible uses:​ date milliseconds_between date ---&gt; floatmilliseconds_between (date , date) ---&gt; float  Result:​ Provide the exact number of milliseconds between two dates. This number can be positive or negative (if the second operand is smaller than the first one) Examples:​ float var0 &lt;- milliseconds_between(date('2000-01-01'), date('2000-02-01')); // var0 equals 2.6784E9   "},{"title":"min​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#min","content":"Possible uses:​ min (container) ---&gt; unknown  Result:​ the minimum element found in the operand. Comment:​ the min operator behavior depends on the nature of the operand Special cases:​ if it is a list of points: min returns the minimum of all points as a point (i.e. the point with the smallest coordinate on the x-axis, in case of equality the point with the smallest coordinate on the y-axis is chosen. If all the points are equal, the first one is returned. ) if it is a population of a list of other types: min transforms all elements into integer and returns the minimum of them if it is a map, min returns the minimum among the list of all elements value if it is a file, min returns the minimum of the content of the file (that is also a container) if it is a graph, min returns the minimum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph) if it is a matrix of int, float or object, min returns the minimum of all the numerical elements (thus all elements for integer and float matrices) if it is a matrix of geometry, min returns the minimum of the list of the geometries if it is a matrix of another type, min returns the minimum of the elements transformed into float if it is a list of int or float: min returns the minimum of all the elements  unknown var0 &lt;- min ([100, 23.2, 34.5]); // var0 equals 23.2  See also: max,  "},{"title":"min_of​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#min_of","content":"Possible uses:​ container min_of any expression ---&gt; unknownmin_of (container , any expression) ---&gt; unknown  Result:​ the minimum value of the right-hand expression evaluated on each of the elements of the left-hand operand Comment:​ in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. Special cases:​ if the left-hand operand is nil or empty, min_of throws an error if the left-operand is a map, the keyword each will contain each value  unknown var4 &lt;- [1::2, 3::4, 5::6] min_of (each + 3); // var4 equals 5  Examples:​ unknown var0 &lt;- [1,2,4,3,5,7,6,8] min_of (each * 100 ); // var0 equals 100 graph g2 &lt;- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); unknown var2 &lt;- g2 min_of (length(g2 out_edges_of each) ); // var2 equals 0 unknown var3 &lt;- (list(node) min_of (round(node(each).location.x)); // var3 equals 4  See also: max_of,  "},{"title":"minus_days​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#minus_days","content":"Possible uses:​ date minus_days int ---&gt; dateminus_days (date , int) ---&gt; date  Result:​ Subtract a given number of days from a date Examples:​ date var0 &lt;- date('2000-01-01') minus_days 20; // var0 equals date('1999-12-12')   "},{"title":"minus_hours​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#minus_hours","content":"Possible uses:​ date minus_hours int ---&gt; dateminus_hours (date , int) ---&gt; date  Result:​ Remove a given number of hours from a date Examples:​ // equivalent to date1 - 15 #h date var1 &lt;- date('2000-01-01') minus_hours 15 ; // var1 equals date('1999-12-31 09:00:00')   "},{"title":"minus_minutes​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#minus_minutes","content":"Possible uses:​ date minus_minutes int ---&gt; dateminus_minutes (date , int) ---&gt; date  Result:​ Subtract a given number of minutes from a date Examples:​ // date('2000-01-01') to date1 - 5#mn date var1 &lt;- date('2000-01-01') minus_minutes 5 ; // var1 equals date('1999-12-31 23:55:00')   "},{"title":"minus_months​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#minus_months","content":"Possible uses:​ date minus_months int ---&gt; dateminus_months (date , int) ---&gt; date  Result:​ Subtract a given number of months from a date Examples:​ date var0 &lt;- date('2000-01-01') minus_months 5; // var0 equals date('1999-08-01')   "},{"title":"minus_ms​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#minus_ms","content":"Possible uses:​ date minus_ms int ---&gt; dateminus_ms (date , int) ---&gt; date  Result:​ Remove a given number of milliseconds from a date Examples:​ // equivalent to date1 - 15 #ms date var1 &lt;- date('2000-01-01') minus_ms 1000 ; // var1 equals date('1999-12-31 23:59:59')   "},{"title":"minus_seconds​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#minus_seconds","content":"Same signification as -  "},{"title":"minus_weeks​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#minus_weeks","content":"Possible uses:​ date minus_weeks int ---&gt; dateminus_weeks (date , int) ---&gt; date  Result:​ Subtract a given number of weeks from a date Examples:​ date var0 &lt;- date('2000-01-01') minus_weeks 15; // var0 equals date('1999-09-18')   "},{"title":"minus_years​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#minus_years","content":"Possible uses:​ date minus_years int ---&gt; dateminus_years (date , int) ---&gt; date  Result:​ Subtract a given number of year from a date Examples:​ date var0 &lt;- date('2000-01-01') minus_years 3; // var0 equals date('1997-01-01')   "},{"title":"mod​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#mod","content":"Possible uses:​ int mod int ---&gt; intmod (int , int) ---&gt; int  Result:​ Returns the remainder of the integer division of the left-hand operand by the right-hand operand. Special cases:​ if operands are float, they are truncated if the right-hand operand is equal to zero, raises an exception. Examples:​ int var0 &lt;- 40 mod 3; // var0 equals 1  See also: div,  "},{"title":"moment​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#moment","content":"Possible uses:​ moment (container, int, float) ---&gt; float  Result:​ Returns the moment of k-th order with constant c of a data sequence Examples:​ float var0 &lt;- moment([13,2,1,4,1,2], 2, 1.2) with_precision(4); // var0 equals 24.74   "},{"title":"months_between​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#months_between","content":"Possible uses:​ date months_between date ---&gt; intmonths_between (date , date) ---&gt; int  Result:​ Provide the exact number of months between two dates. This number can be positive or negative (if the second operand is smaller than the first one) Examples:​ int var0 &lt;- months_between(date('2000-01-01'), date('2000-02-01')); // var0 equals 1   "},{"title":"moran​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#moran","content":"Possible uses:​ list&amp;lt;float&gt; moran matrix&amp;lt;float&gt; ---&gt; floatmoran (list&amp;lt;float&gt; , matrix&amp;lt;float&gt;) ---&gt; float Special cases:​ return the Moran Index of the given list of interest points (list of floats) and the weight matrix (matrix of float)  float var0 &lt;- moran([1.0, 0.5, 2.0], weight_matrix); // var0 equals the Moran index is computed   "},{"title":"mul​","type":1,"pageTitle":"Operators (I to M)","url":"wiki/OperatorsIM#mul","content":"Possible uses:​ mul (container) ---&gt; unknown  Result:​ the product of all the elements of the operand Comment:​ the mul operator behavior depends on the nature of the operand Special cases:​ if it is a list of points: mul returns the product of all points as a point (each coordinate is the product of the corresponding coordinate of each element) if it is a list of other types: mul transforms all elements into integer and multiplies them if it is a map, mul returns the product of the value of all elements if it is a file, mul returns the product of the content of the file (that is also a container) if it is a graph, mul returns the product of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph) if it is a matrix of int, float or object, mul returns the product of all the numerical elements (thus all elements for integer and float matrices) if it is a matrix of geometry, mul returns the product of the list of the geometries if it is a matrix of other types: mul transforms all elements into float and multiplies them if it is a list of int or float: mul returns the product of all the elements  unknown var0 &lt;- mul ([100, 23.2, 34.5]); // var0 equals 80040.0  See also: sum, "},{"title":"Operators (N to R)","type":0,"sectionRef":"#","url":"wiki/OperatorsNR","content":"","keywords":""},{"title":"Definition​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#definition","content":"Operators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function. Most of them use a classical prefixed functional syntax (i.e. operator_name(operand1, operand2, operand3), see below), with the exception of arithmetic (e.g. +, /), logical (and, or), comparison (e.g. &gt;, &lt;), access (., [..]) and pair (::) operators, which require an infixed notation (i.e. operand1 operator_symbol operand1). The ternary functional if-else operator, ? :, uses a special infixed syntax composed with two symbols (e.g. operand1 ? operand2 : operand3). Two unary operators (- and !) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g. - 10, ! (operand1 or operand2)). Finally, special constructor operators ({...} for constructing points, [...] for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. {1,2,3}, [operand1, operand2, ..., operandn] or [key1::value1, key2::value2... keyn::valuen]). With the exception of these special cases above, the following rules apply to the syntax of operators: if they only have one operand, the functional prefixed syntax is mandatory (e.g. operator_name(operand1))if they have two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2)) or the infixed syntax (e.g. operand1 operator_name operand2) can be used.if they have more than two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2, ..., operand)) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. operand1 operator_name(operand2, ..., operand)) can be used. All of these alternative syntaxes are completely equivalent. Operators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.  "},{"title":"Priority between operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#priority-between-operators","content":"The priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first. GAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely: the constructor operators, like ::, used to compose pairs of operands, have the lowest priority of all operators (e.g. a &gt; b :: b &gt; c will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, [a &gt; 10, b &gt; 5] will return a list of boolean values.it is followed by the ?: operator, the functional if-else (e.g. a &gt; b ? a + 10 : a - 10 will return the result of the if-else).next are the logical operators, and and or (e.g. a &gt; b or b &gt; c will return the value of the test)next are the comparison operators (i.e. &gt;, &lt;, &lt;=, &gt;=, =, !=)next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)next the unary operators - and !next the access operators . and [] (e.g. {1,2,3}.x &gt; 20 + {4,5,6}.y will return the result of the comparison between the x and y ordinates of the two points)and finally the functional operators, which have the highest priority of all.  "},{"title":"Using actions as operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#using-actions-as-operators","content":"Actions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand. For instance, if the following species is defined: species spec1 { int min(int x, int y) { return x &gt; y ? x : y; } }  Any agent instance of spec1 can use min as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable: global { init { create spec1; spec1 my_agent &lt;- spec1[0]; int the_min &lt;- my_agent min(10,20); // or min(my_agent, 10, 20); } }  If the action doesn't have any operands, the syntax to use is my_agent the_action(). Finally, if it does not return a value, it might still be used but is considering as returning a value of type unknown (e.g. unknown result &lt;- my_agent the_action(op1, op2);). Note that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).  "},{"title":"Table of Contents​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#table-of-contents","content":" "},{"title":"Operators by categories​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#operators-by-categories","content":" "},{"title":"3D​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#3d","content":"box, cone3D, cube, cylinder, hexagon, pyramid, set_z, sphere, teapot,  "},{"title":"Arithmetic operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#arithmetic-operators","content":"-, /, ^, *, +, abs, acos, asin, atan, atan2, ceil, cos, cos_rad, div, even, exp, fact, floor, hypot, is_finite, is_number, ln, log, mod, round, signum, sin, sin_rad, sqrt, tan, tan_rad, tanh, with_precision,  "},{"title":"BDI​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#bdi","content":"add_values, and, eval_when, get_about, get_agent, get_agent_cause, get_belief_op, get_belief_with_name_op, get_beliefs_op, get_beliefs_with_name_op, get_current_intention_op, get_decay, get_desire_op, get_desire_with_name_op, get_desires_op, get_desires_with_name_op, get_dominance, get_familiarity, get_ideal_op, get_ideal_with_name_op, get_ideals_op, get_ideals_with_name_op, get_intensity, get_intention_op, get_intention_with_name_op, get_intentions_op, get_intentions_with_name_op, get_lifetime, get_liking, get_modality, get_obligation_op, get_obligation_with_name_op, get_obligations_op, get_obligations_with_name_op, get_plan_name, get_predicate, get_solidarity, get_strength, get_super_intention, get_trust, get_truth, get_uncertainties_op, get_uncertainties_with_name_op, get_uncertainty_op, get_uncertainty_with_name_op, get_values, has_belief_op, has_belief_with_name_op, has_desire_op, has_desire_with_name_op, has_ideal_op, has_ideal_with_name_op, has_intention_op, has_intention_with_name_op, has_obligation_op, has_obligation_with_name_op, has_uncertainty_op, has_uncertainty_with_name_op, new_emotion, new_mental_state, new_predicate, new_social_link, not, or, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_lifetime, set_liking, set_modality, set_predicate, set_solidarity, set_strength, set_trust, set_truth, with_values,  "},{"title":"Casting operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#casting-operators","content":"as, as_int, as_matrix, font, is, is_skill, list_with, matrix_with, species, to_gaml, topology,  "},{"title":"Color-related operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#color-related-operators","content":"-, /, *, +, blend, brewer_colors, brewer_palettes, gradient, grayscale, hsb, mean, median, palette, rgb, rnd_color, scale, sum,  "},{"title":"Comparison operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#comparison-operators","content":"!=, &lt;, &lt;=, =, &gt;, &gt;=, between,  "},{"title":"Containers-related operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#containers-related-operators","content":"-, ::, +, accumulate, all_match, among, at, cartesian_product, collect, contains, contains_all, contains_any, contains_key, count, empty, every, first, first_with, get, group_by, in, index_by, inter, interleave, internal_integrated_value, last, last_with, length, max, max_of, mean, mean_of, median, min, min_of, mul, none_matches, one_matches, one_of, product_of, range, remove_duplicates, reverse, shuffle, sort_by, split, split_in, split_using, sum, sum_of, union, variance_of, where, with_max_of, with_min_of,  "},{"title":"Date-related operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#date-related-operators","content":"-, !=, +, &lt;, &lt;=, =, &gt;, &gt;=, after, before, between, every, milliseconds_between, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_weeks, minus_years, months_between, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_weeks, plus_years, since, to, until, years_between,  "},{"title":"Dates​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#dates","content":" "},{"title":"Displays​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#displays","content":"horizontal, stack, vertical,  "},{"title":"edge​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#edge","content":"edge_between, strahler,  "},{"title":"EDP-related operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#edp-related-operators","content":"diff, diff2,  "},{"title":"Files-related operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#files-related-operators","content":"copy_file, crs, csv_file, delete_file, dxf_file, evaluate_sub_model, file_exists, folder, folder_exists, gaml_file, geojson_file, get, gif_file, gml_file, graph6_file, graphdimacs_file, graphdot_file, graphgexf_file, graphgml_file, graphml_file, graphtsplib_file, grid_file, image_file, is_csv, is_dxf, is_gaml, is_geojson, is_gif, is_gml, is_graph6, is_graphdimacs, is_graphdot, is_graphgexf, is_graphgml, is_graphml, is_graphtsplib, is_grid, is_image, is_json, is_obj, is_osm, is_pgm, is_property, is_saved_simulation, is_shape, is_svg, is_text, is_threeds, is_xml, json_file, new_folder, obj_file, osm_file, pgm_file, property_file, read, rename_file, saved_simulation_file, shape_file, step_sub_model, svg_file, text_file, threeds_file, unzip, writable, xml_file, zip,  "},{"title":"FIPA-related operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#fipa-related-operators","content":"conversation, message,  "},{"title":"GamaMaterialType​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#gamamaterialtype","content":"material,  "},{"title":"GamaMetaType​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#gamametatype","content":"type_of,  "},{"title":"Gen*​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#gen","content":"add_attribute, add_census_file, add_mapper, add_marginals, add_range_attribute, with_generation_algo,  "},{"title":"Graphs-related operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#graphs-related-operators","content":"add_edge, add_node, adjacency, agent_from_geometry, all_pairs_shortest_path, alpha_index, as_distance_graph, as_edge_graph, as_intersection_graph, as_path, as_spatial_graph, beta_index, betweenness_centrality, biggest_cliques_of, connected_components_of, connectivity_index, contains_edge, contains_vertex, degree_of, directed, edge, edge_between, edge_betweenness, edges, gamma_index, generate_barabasi_albert, generate_complete_graph, generate_random_graph, generate_watts_strogatz, girvan_newman_clustering, grid_cells_to_graph, in_degree_of, in_edges_of, k_spanning_tree_clustering, label_propagation_clustering, layout_circle, layout_force, layout_force_FR, layout_force_FR_indexed, layout_grid, load_shortest_paths, main_connected_component, max_flow_between, maximal_cliques_of, nb_cycles, neighbors_of, node, nodes, out_degree_of, out_edges_of, path_between, paths_between, predecessors_of, remove_node_from, rewire_n, source_of, spatial_graph, strahler, successors_of, sum, target_of, undirected, use_cache, weight_of, with_k_shortest_path_algorithm, with_shortest_path_algorithm, with_weights,  "},{"title":"Grid-related operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#grid-related-operators","content":"as_4_grid, as_grid, as_hexagonal_grid, cell_at, cells_in, cells_overlapping, field, grid_at, neighbors_of, path_between, points_in, values_in,  "},{"title":"Iterator operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#iterator-operators","content":"accumulate, all_match, as_map, collect, count, create_map, first_with, frequency_of, group_by, index_by, last_with, max_of, mean_of, min_of, none_matches, one_matches, product_of, sort_by, sum_of, variance_of, where, where, where, with_max_of, with_min_of,  "},{"title":"List-related operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#list-related-operators","content":"all_indexes_of, copy_between, index_of, last_index_of,  "},{"title":"Logical operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#logical-operators","content":":, !, ?, add_3Dmodel, add_geometry, add_icon, and, or, xor,  "},{"title":"Map comparaison operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#map-comparaison-operators","content":"fuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,  "},{"title":"Map-related operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#map-related-operators","content":"as_map, create_map, index_of, last_index_of,  "},{"title":"Matrix-related operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#matrix-related-operators","content":"-, /, ., *, +, append_horizontally, append_vertically, column_at, columns_list, determinant, eigenvalues, index_of, inverse, last_index_of, row_at, rows_list, shuffle, trace, transpose,  "},{"title":"multicriteria operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#multicriteria-operators","content":"electre_DM, evidence_theory_DM, fuzzy_choquet_DM, promethee_DM, weighted_means_DM,  "},{"title":"Path-related operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#path-related-operators","content":"agent_from_geometry, all_pairs_shortest_path, as_path, load_shortest_paths, max_flow_between, path_between, path_to, paths_between, use_cache,  "},{"title":"Points-related operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#points-related-operators","content":"-, /, *, +, &lt;, &lt;=, &gt;, &gt;=, add_point, angle_between, any_location_in, centroid, closest_points_with, farthest_point_to, grid_at, norm, points_along, points_at, points_on,  "},{"title":"Random operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#random-operators","content":"binomial, flip, gamma_density, gamma_rnd, gamma_trunc_rnd, gauss, generate_terrain, lognormal_density, lognormal_rnd, lognormal_trunc_rnd, poisson, rnd, rnd_choice, sample, shuffle, skew_gauss, truncated_gauss, weibull_density, weibull_rnd, weibull_trunc_rnd,  "},{"title":"ReverseOperators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#reverseoperators","content":"restore_simulation, restore_simulation_from_file, save_simulation, serialize, serialize_agent,  "},{"title":"Shape​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#shape","content":"arc, box, circle, cone, cone3D, cross, cube, curve, cylinder, ellipse, elliptical_arc, envelope, geometry_collection, hexagon, line, link, plan, polygon, polyhedron, pyramid, rectangle, sphere, square, squircle, teapot, triangle,  "},{"title":"Spatial operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#spatial-operators","content":"-, *, +, add_point, agent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, angle_between, any_location_in, arc, around, as_4_grid, as_driving_graph, as_grid, as_hexagonal_grid, at_distance, at_location, box, centroid, circle, clean, clean_network, closest_points_with, closest_to, closest_tob, cone, cone3D, convex_hull, covering, covers, cross, crosses, crossing, crs, CRS_transform, cube, curve, cylinder, direction_between, disjoint_from, distance_between, distance_to, ellipse, elliptical_arc, envelope, farthest_point_to, farthest_to, geometry_collection, gini, hexagon, hierarchical_clustering, IDW, inside, inter, intersects, inverse_rotation, line, link, masked_by, moran, neighbors_at, neighbors_of, normalized_rotation, overlapping, overlaps, partially_overlapping, partially_overlaps, path_between, path_to, plan, points_along, points_at, points_on, polygon, polyhedron, pyramid, rectangle, rotated_by, rotation_composition, round, scaled_to, set_z, simple_clustering_by_distance, simplification, skeletonize, smooth, sphere, split_at, split_geometry, split_lines, square, squircle, teapot, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, touches, touching, towards, transformed_by, translated_by, triangle, triangulate, union, using, voronoi, with_precision, without_holes,  "},{"title":"Spatial properties operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#spatial-properties-operators","content":"covers, crosses, intersects, partially_overlaps, touches,  "},{"title":"Spatial queries operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#spatial-queries-operators","content":"agent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, at_distance, closest_to, covering, crossing, farthest_to, inside, neighbors_at, neighbors_of, overlapping, partially_overlapping, touching,  "},{"title":"Spatial relations operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#spatial-relations-operators","content":"direction_between, distance_between, distance_to, path_between, path_to, towards,  "},{"title":"Spatial statistical operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#spatial-statistical-operators","content":"hierarchical_clustering, simple_clustering_by_distance,  "},{"title":"Spatial transformations operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#spatial-transformations-operators","content":"-, *, +, as_4_grid, as_grid, as_hexagonal_grid, at_location, clean, clean_network, convex_hull, CRS_transform, inverse_rotation, normalized_rotation, rotated_by, rotation_composition, scaled_to, simplification, skeletonize, smooth, split_geometry, split_lines, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, transformed_by, translated_by, triangulate, voronoi, with_precision, without_holes,  "},{"title":"Species-related operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#species-related-operators","content":"index_of, last_index_of, of_generic_species, of_species,  "},{"title":"Statistical operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#statistical-operators","content":"auto_correlation, beta, binomial_coeff, binomial_complemented, binomial_sum, build, chi_square, chi_square_complemented, correlation, covariance, dbscan, distribution_of, distribution2d_of, dtw, durbin_watson, frequency_of, gamma, gamma_distribution, gamma_distribution_complemented, geometric_mean, gini, harmonic_mean, hierarchical_clustering, incomplete_beta, incomplete_gamma, incomplete_gamma_complement, kmeans, kurtosis, log_gamma, max, mean, mean_deviation, median, min, moment, moran, mul, normal_area, normal_density, normal_inverse, predict, pValue_for_fStat, pValue_for_tStat, quantile, quantile_inverse, rank_interpolated, rms, simple_clustering_by_distance, skewness, split, split_in, split_using, standard_deviation, student_area, student_t_inverse, sum, t_test, variance,  "},{"title":"Strings-related operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#strings-related-operators","content":"+, &lt;, &lt;=, &gt;, &gt;=, at, char, contains, contains_all, contains_any, copy_between, date, empty, first, in, indented_by, index_of, is_number, last, last_index_of, length, lower_case, regex_matches, replace, replace_regex, reverse, sample, shuffle, split_with, string, upper_case,  "},{"title":"SubModel​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#submodel","content":"load_sub_model,  "},{"title":"System​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#system","content":"., choose, command, copy, copy_to_clipboard, dead, enter, eval_gaml, every, is_error, is_reachable, is_warning, user_confirm, user_input_dialog, wizard, wizard_page,  "},{"title":"Time-related operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#time-related-operators","content":"date, string,  "},{"title":"Types-related operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#types-related-operators","content":"action, agent, attributes, BDIPlan, bool, container, directory, emotion, file, float, gaml_type, gen_population_generator, gen_range, geometry, graph, int, kml, list, map, matrix, mental_state, Norm, pair, path, point, predicate, regression, rgb, Sanction, skill, social_link, topology, unknown,  "},{"title":"User control operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#user-control-operators","content":"choose, enter, user_confirm, user_input_dialog, wizard, wizard_page,  "},{"title":"Operators​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#operators","content":" "},{"title":"nb_cycles​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#nb_cycles","content":"Possible uses:​ nb_cycles (graph) ---&gt; int  Result:​ returns the maximum number of independent cycles in a graph. This number (u) is estimated through the number of nodes (v), links (e) and of sub-graphs (p): u = e - v + p. Examples:​ graph graphEpidemio &lt;- graph([]); int var1 &lt;- nb_cycles(graphEpidemio); // var1 equals the number of cycles in the graph  See also: alpha_index, beta_index, gamma_index, connectivity_index,  "},{"title":"neighbors_at​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#neighbors_at","content":"Possible uses:​ geometry neighbors_at float ---&gt; listneighbors_at (geometry , float) ---&gt; list  Result:​ a list, containing all the agents of the same species than the left argument (if it is an agent) located at a distance inferior or equal to the right-hand operand to the left-hand operand (geometry, agent, point). Comment:​ The topology used to compute the neighborhood is the one of the left-operand if this one is an agent; otherwise the one of the agent applying the operator. Examples:​ list var0 &lt;- (self neighbors_at (10)); // var0 equals all the agents located at a distance lower or equal to 10 to the agent applying the operator.  See also: neighbors_of, closest_to, overlapping, agents_overlapping, agents_inside, agent_closest_to, at_distance,  "},{"title":"neighbors_of​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#neighbors_of","content":"Possible uses:​ topology neighbors_of agent ---&gt; listneighbors_of (topology , agent) ---&gt; listgraph neighbors_of unknown ---&gt; listneighbors_of (graph , unknown) ---&gt; listfield neighbors_of point ---&gt; list&amp;lt;point&gt;neighbors_of (field , point) ---&gt; list&amp;lt;point&gt;neighbors_of (topology, geometry, float) ---&gt; list  Result:​ a list, containing all the agents of the same species than the argument (if it is an agent) located at a distance inferior or equal to 1 to the right-hand operand agent considering the left-hand operand topology. Special cases:​ a list, containing all the agents of the same species than the left argument (if it is an agent) located at a distance inferior or equal to the third argument to the second argument (agent, geometry or point) considering the first operand topology.  list var0 &lt;- neighbors_of (topology(self), self,10); // var0 equals all the agents located at a distance lower or equal to 10 to the agent applying the operator considering its topology.  Examples:​ list var1 &lt;- topology(self) neighbors_of self; // var1 equals returns all the agents located at a distance lower or equal to 1 to the agent applying the operator considering its topology. list var2 &lt;- graphEpidemio neighbors_of (node(3)); // var2 equals [node0,node2] list var3 &lt;- graphFromMap neighbors_of node({12,45}); // var3 equals [{1.0,5.0},{34.0,56.0}]  See also: neighbors_at, closest_to, overlapping, agents_overlapping, agents_inside, agent_closest_to, predecessors_of, successors_of,  "},{"title":"new_emotion​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#new_emotion","content":"Possible uses:​ new_emotion (string) ---&gt; emotionstring new_emotion float ---&gt; emotionnew_emotion (string , float) ---&gt; emotionstring new_emotion predicate ---&gt; emotionnew_emotion (string , predicate) ---&gt; emotionstring new_emotion agent ---&gt; emotionnew_emotion (string , agent) ---&gt; emotionnew_emotion (string, float, float) ---&gt; emotionnew_emotion (string, predicate, agent) ---&gt; emotionnew_emotion (string, float, agent) ---&gt; emotionnew_emotion (string, float, predicate) ---&gt; emotionnew_emotion (string, float, predicate, float) ---&gt; emotionnew_emotion (string, float, predicate, agent) ---&gt; emotionnew_emotion (string, float, float, agent) ---&gt; emotionnew_emotion (string, float, predicate, float, agent) ---&gt; emotion  Result:​ a new emotion with the given properties (at least its name, and eventually intensity, parameters...) Special cases:​ A decay value value can be added to define a new emotion.  new_emotion(&quot;joy&quot;,12.3,4.0)  a new emotion with a name and an initial intensity:  new_emotion(&quot;joy&quot;,12.3)  a new emotion with a given name and the predicate it is about  new_emotion(&quot;joy&quot;,estFood) new_emotion(&quot;joy&quot;,agent1)  a new emotion with a given name and the agent which has caused this emotion  new_emotion(&quot;joy&quot;,agent1)  Various combinations are possible to create the emotion: (name,intensity,about), (name,about,cause), (name,intensity,cause)...  new_emotion(&quot;joy&quot;,12.3,eatFood) new_emotion(&quot;joy&quot;,eatFood,agent1) new_emotion(&quot;joy&quot;,12.3,agent1)  Examples:​ new_emotion(&quot;joy&quot;,12.3,eatFood,4.0) new_emotion(&quot;joy&quot;,12.3,eatFood,agent1) new_emotion(&quot;joy&quot;) emotion(&quot;joy&quot;, 12.3, 4, agent1) emotion(&quot;joy&quot;,12.3,eatFood,4,agent1)   "},{"title":"new_folder​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#new_folder","content":"Possible uses:​ new_folder (string) ---&gt; file  Result:​ opens an existing repository or create a new folder if it does not exist. Special cases:​ If the specified string does not refer to an existing repository, the repository is created. If the string refers to an existing file, an exception is risen. Examples:​ file dirNewT &lt;- new_folder(&quot;incl/&quot;); // dirNewT represents the repository &quot;../incl/&quot; // eventually creates the directory ../incl  See also: folder, file, folder_exists,  "},{"title":"new_mental_state​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#new_mental_state","content":"Possible uses:​ new_mental_state (string) ---&gt; mental_statestring new_mental_state predicate ---&gt; mental_statenew_mental_state (string , predicate) ---&gt; mental_statestring new_mental_state mental_state ---&gt; mental_statenew_mental_state (string , mental_state) ---&gt; mental_statestring new_mental_state emotion ---&gt; mental_statenew_mental_state (string , emotion) ---&gt; mental_statenew_mental_state (string, mental_state, int) ---&gt; mental_statenew_mental_state (string, emotion, float) ---&gt; mental_statenew_mental_state (string, mental_state, float) ---&gt; mental_statenew_mental_state (string, predicate, float) ---&gt; mental_statenew_mental_state (string, emotion, int) ---&gt; mental_statenew_mental_state (string, mental_state, agent) ---&gt; mental_statenew_mental_state (string, emotion, agent) ---&gt; mental_statenew_mental_state (string, predicate, int) ---&gt; mental_statenew_mental_state (string, predicate, agent) ---&gt; mental_statenew_mental_state (string, emotion, int, agent) ---&gt; mental_statenew_mental_state (string, predicate, float, int) ---&gt; mental_statenew_mental_state (string, predicate, int, agent) ---&gt; mental_statenew_mental_state (string, mental_state, float, int) ---&gt; mental_statenew_mental_state (string, mental_state, float, agent) ---&gt; mental_statenew_mental_state (string, emotion, float, int) ---&gt; mental_statenew_mental_state (string, mental_state, int, agent) ---&gt; mental_statenew_mental_state (string, emotion, float, agent) ---&gt; mental_statenew_mental_state (string, predicate, float, agent) ---&gt; mental_statenew_mental_state (string, predicate, float, int, agent) ---&gt; mental_statenew_mental_state (string, emotion, float, int, agent) ---&gt; mental_statenew_mental_state (string, mental_state, float, int, agent) ---&gt; mental_state  Result:​ creates a new mental state with a given modality (e.g. belief or desire) and various properties (a predicate it is about, a strength, a lifetime, an ower agent and an emotion it is about Examples:​ new_mental_state(&quot;belief&quot;, my_joy, 10, agent1) new_mental_state(&quot;belief&quot;, mental_state1, 10) new_mental_state(&quot;belief&quot;) new_mental_state(&quot;belief&quot;, my_joy, 12.3) new_mental_state(&quot;belief&quot;, mental_state1, 12.3) new_mental_state(&quot;belief&quot;, raining) new_mental_state(&quot;belief&quot;, raining, 12.4, 10) new_mental_state(&quot;belief&quot;, raining, 10, agent1) new_mental_state(&quot;belief&quot;, raining, 0.5) new_mental_state(&quot;belief&quot;, mental_state1, 12.3, 10) new_mental_state(&quot;belief&quot;, my_joy, 10) new_mental_state(&quot;belief&quot;, mental_state1, 12.2, agent1) new_mental_state(&quot;belief&quot;, my_joy, 12.3, 10) new_mental_state(&quot;belief&quot;, mental_state1, agent1) new_mental_state(&quot;belief&quot;, my_joy, agent1) new_mental_state(&quot;belief&quot;, mental_state1, 10, agent1) new_mental_state(&quot;belief&quot;, my_joy, 12.3, agent1) new_mental_state(&quot;belief&quot;, raining, 10) new_mental_state(&quot;belief&quot;, mental_state1) new_mental_state(&quot;belief&quot;,raining, 12.3, 10, agent1) new_mental_state(&quot;belief&quot;, my_joy, 12.3, 10, agent1) new_mental_state(&quot;belief&quot;, my_joy) new_mental_state(&quot;belief&quot;, raining, agent1) new_mental_state(&quot;belief&quot;, mental_state1, 12.3, 10, agent1) new_mental_state(&quot;belief&quot;, raining, 12.3, agent1)   "},{"title":"new_predicate​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#new_predicate","content":"Possible uses:​ new_predicate (string) ---&gt; predicatestring new_predicate agent ---&gt; predicatenew_predicate (string , agent) ---&gt; predicatestring new_predicate map ---&gt; predicatenew_predicate (string , map) ---&gt; predicatestring new_predicate bool ---&gt; predicatenew_predicate (string , bool) ---&gt; predicatenew_predicate (string, map, bool) ---&gt; predicatenew_predicate (string, map, agent) ---&gt; predicatenew_predicate (string, map, bool, agent) ---&gt; predicate  Result:​ creates a new predicate with a given name and adidtional properties (values, agent causing the predicate, whether it is true...) Examples:​ new_predicate(&quot;people to meet&quot;, [&quot;time&quot;::10], true) new_predicate(&quot;people to meet&quot;, agent1) new_predicate(&quot;people to meet&quot;, [&quot;time&quot;::10], true, agentA) new_predicate(&quot;people to meet&quot;, map([&quot;val1&quot;::23]) ) new_predicate(&quot;hasWater&quot;, true) new_predicate(&quot;people to meet&quot;) new_predicate(&quot;people to meet&quot;, [&quot;time&quot;::10], agentA)   "},{"title":"new_social_link​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#new_social_link","content":"Possible uses:​ new_social_link (agent) ---&gt; social_linknew_social_link (agent, float, float, float, float) ---&gt; social_link  Result:​ creates a new social link with another agent (eventually given additional parameters such as the appreciation, dominance, solidarity, and familiarity values). Examples:​ new_social_link(agentA,0.0,-0.1,0.2,0.1) new_social_link(agentA)   "},{"title":"node​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#node","content":"Possible uses:​ node (unknown) ---&gt; unknownunknown node float ---&gt; unknownnode (unknown , float) ---&gt; unknown  Result:​ Allows to create a wrapper (of type unknown) that wraps an actual object and indicates it should be considered as a node of a graph. The second (optional) parameter indicates which weight the node should have in the graph Comment:​ Useful only in graph-related operations (addition, removal of nodes, creation of graphs)  "},{"title":"nodes​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#nodes","content":"Possible uses:​ nodes (container) ---&gt; container  Result:​ Allows to create a wrapper (of type list) that wraps a list of objects and indicates they should be considered as nodes of a graph  "},{"title":"none_matches​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#none_matches","content":"Possible uses:​ container none_matches any expression ---&gt; boolnone_matches (container , any expression) ---&gt; bool  Result:​ Returns true if none of the elements of the left-hand operand make the right-hand operand evaluate to true. 'c none_matches each.property' is strictly equivalent to '(c count each.property) = 0' Comment:​ In the right-hand operand, the keyword each can be used to represent, in turn, each of the elements. Special cases:​ If the left-hand operand is nil, none_matches throws an error. If the left-hand operand is empty, none_matches returns true. Examples:​ bool var0 &lt;- [1,2,3,4,5,6,7,8] none_matches (each &gt; 3); // var0 equals false bool var1 &lt;- [1::2, 3::4, 5::6] none_matches (each &gt; 4); // var1 equals false  See also: one_matches, all_match, count,  "},{"title":"none_verifies​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#none_verifies","content":"Same signification as none_matches  "},{"title":"norm​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#norm","content":"Possible uses:​ norm (point) ---&gt; float  Result:​ the norm of the vector with the coordinates of the point operand. Examples:​ float var0 &lt;- norm({3,4}); // var0 equals 5.0   "},{"title":"Norm​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#norm-1","content":"Possible uses:​ Norm (any) ---&gt; Norm  Result:​ casts the operand in a Norm object.  "},{"title":"normal_area​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#normal_area","content":"Possible uses:​ normal_area (float, float, float) ---&gt; float  Result:​ Returns the area to the left of x in the normal distribution with the given mean and standard deviation. Examples:​ float var0 &lt;- normal_area(0.9,0,1) with_precision(3); // var0 equals 0.816   "},{"title":"normal_density​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#normal_density","content":"Possible uses:​ normal_density (float, float, float) ---&gt; float  Result:​ Returns the probability of x in the normal distribution with the given mean and standard deviation. Examples:​ float var0 &lt;- (normal_density(2,1,1)*100) with_precision 2; // var0 equals 24.2   "},{"title":"normal_inverse​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#normal_inverse","content":"Possible uses:​ normal_inverse (float, float, float) ---&gt; float  Result:​ Returns the x in the normal distribution with the given mean and standard deviation, to the left of which lies the given area. normal. Examples:​ float var0 &lt;- normal_inverse(0.98,0,1) with_precision(2); // var0 equals 2.05   "},{"title":"normalized_rotation​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#normalized_rotation","content":"Possible uses:​ normalized_rotation (pair) ---&gt; pair&amp;lt;float,point&gt;  Result:​ The rotation normalized according to Euler formalism with a positive angle, such that each rotation has a unique set of parameters (positive angle, normalize axis rotation). Examples:​ pair&amp;lt;float,point&gt; var0 &lt;- normalized_rotation(-38.0::{1,1,1}); // var0 equals 38.0::{-0.5773502691896258,-0.5773502691896258,-0.5773502691896258}  See also: [rotation_composition, inverse_rotation](OperatorsSZ#rotation_composition, inverse_rotation),  "},{"title":"not​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#not","content":"Same signification as !  "},{"title":"not​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#not-1","content":"Possible uses:​ not (predicate) ---&gt; predicate  Result:​ create a new predicate with the inverse truth value Examples:​ not predicate1   "},{"title":"obj_file​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#obj_file","content":"Possible uses:​ obj_file (string) ---&gt; filestring obj_file pair&amp;lt;float,point&gt; ---&gt; fileobj_file (string , pair&amp;lt;float,point&gt;) ---&gt; filestring obj_file string ---&gt; fileobj_file (string , string) ---&gt; fileobj_file (string, string, pair&amp;lt;float,point&gt;) ---&gt; file  Result:​ Constructs a file of type obj. Allowed extensions are limited to obj, OBJ Special cases:​ obj_file(string): This file constructor allows to read an obj file. The associated mlt file have to have the same name as the file to be read.  file f &lt;- obj_file(&quot;file.obj&quot;);  obj_file(string,pair&lt;float,point&gt;): This file constructor allows to read an obj file and apply an init rotation to it. The rotationis a pair angle::rotation vector. The associated mlt file have to have the same name as the file to be read.  file f &lt;- obj_file(&quot;file.obj&quot;, 90.0::{-1,0,0});  obj_file(string,string): This file constructor allows to read an obj file, using a specific mlt file  file f &lt;- obj_file(&quot;file.obj&quot;,&quot;file.mlt&quot;);  obj_file(string,string,pair&lt;float,point&gt;): This file constructor allows to read an obj file, using a specific mlt file, and apply an init rotation to it. The rotationis a pair angle::rotation vector  file f &lt;- obj_file(&quot;file.obj&quot;,&quot;file.mlt&quot;, 90.0::{-1,0,0});  See also: is_obj,  "},{"title":"of​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#of","content":"Same signification as .  "},{"title":"of_generic_species​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#of_generic_species","content":"Possible uses:​ container of_generic_species species ---&gt; listof_generic_species (container , species) ---&gt; list  Result:​ a list, containing the agents of the left-hand operand whose species is that denoted by the right-hand operand and whose species extends the right-hand operand species Examples:​ // species speciesA {} // species sub_speciesA parent: speciesA {} list var2 &lt;- [sub_speciesA(0),sub_speciesA(1),speciesA(2),speciesA(3)] of_generic_species speciesA; // var2 equals [sub_speciesA0,sub_speciesA1,speciesA0,speciesA1] list var3 &lt;- [sub_speciesA(0),sub_speciesA(1),speciesA(2),speciesA(3)] of_generic_species sous_test; // var3 equals [sub_speciesA0,sub_speciesA1] list var4 &lt;- [sub_speciesA(0),sub_speciesA(1),speciesA(2),speciesA(3)] of_species speciesA; // var4 equals [speciesA0,speciesA1] list var5 &lt;- [sub_speciesA(0),sub_speciesA(1),speciesA(2),speciesA(3)] of_species sous_test; // var5 equals [sub_speciesA0,sub_speciesA1]  See also: of_species,  "},{"title":"of_species​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#of_species","content":"Possible uses:​ container of_species species ---&gt; listof_species (container , species) ---&gt; list  Result:​ a list, containing the agents of the left-hand operand whose species is the one denoted by the right-hand operand.The expression agents of_species (species self) is equivalent to agents where (species each = species self); however, the advantage of using the first syntax is that the resulting list is correctly typed with the right species, whereas, in the second syntax, the parser cannot determine the species of the agents within the list (resulting in the need to cast it explicitly if it is to be used in an ask statement, for instance). Special cases:​ if the right operand is nil, of_species returns the right operand Examples:​ list var0 &lt;- (self neighbors_at 10) of_species (species (self)); // var0 equals all the neighboring agents of the same species. list var1 &lt;- [test(0),test(1),node(1),node(2)] of_species test; // var1 equals [test0,test1]  See also: of_generic_species,  "},{"title":"one_matches​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#one_matches","content":"Possible uses:​ container one_matches any expression ---&gt; boolone_matches (container , any expression) ---&gt; bool  Result:​ Returns true if at least one of the elements of the left-hand operand make the right-hand operand evaluate to true. Returns false if the left-hand operand is empty. 'c one_matches each.property' is strictly equivalent to '(c count each.property) &gt; 0' but faster in most cases (as it is a shortcircuited operator) Comment:​ in the right-hand operand, the keyword each can be used to represent, in turn, each of the elements. Special cases:​ if the left-hand operand is nil, one_matches throws an error Examples:​ bool var0 &lt;- [1,2,3,4,5,6,7,8] one_matches (each &gt; 3); // var0 equals true bool var1 &lt;- [1::2, 3::4, 5::6] one_matches (each &gt; 4); // var1 equals true  See also: none_matches, all_match, count,  "},{"title":"one_of​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#one_of","content":"Possible uses:​ one_of (container&amp;lt;KeyType,ValueType&gt;) ---&gt; ValueType  Result:​ one of the values stored in this container at a random key Comment:​ the one_of operator behavior depends on the nature of the operand Special cases:​ if the operand is empty, one_of returns nil if it is a graph, one_of returns one of the lists of edges if it is a file, one_of returns one of the elements of the content of the file (that is also a container) if it is a list or a matrix, one_of returns one of the values of the list or of the matrix  i &lt;- any ([1,2,3]); //i equals 1, 2 or 3 string sMat &lt;- one_of(matrix([[&quot;c11&quot;,&quot;c12&quot;,&quot;c13&quot;],[&quot;c21&quot;,&quot;c22&quot;,&quot;c23&quot;]])); // sMat equals &quot;c11&quot;,&quot;c12&quot;,&quot;c13&quot;, &quot;c21&quot;,&quot;c22&quot; or &quot;c23&quot;  if it is a map, one_of returns one the value of a random pair of the map  int im &lt;- one_of ([2::3, 4::5, 6::7]); // im equals 3, 5 or 7 bool var3 &lt;- [2::3, 4::5, 6::7].values contains im; // var3 equals true  if it is a population, one_of returns one of the agents of the population  bug b &lt;- one_of(bug); // Given a previously defined species bug, b is one of the created bugs, e.g. bug3  See also: contains,  "},{"title":"one_verifies​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#one_verifies","content":"Same signification as one_matches  "},{"title":"or​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#or","content":"Possible uses:​ bool or any expression ---&gt; boolor (bool , any expression) ---&gt; bool  Result:​ a bool value, equal to the logical or between the left-hand operand and the right-hand operand. Comment:​ both operands are always casted to bool before applying the operator. Thus, an expression like 1 or 0 is accepted and returns true. Examples:​ bool var0 &lt;- true or false; // var0 equals true int a &lt;-3 ; int b &lt;- 4; int c &lt;- 7; bool var2 &lt;- ((a+b) = c ) or ((a+b) &gt; c ); // var2 equals true  See also: bool, and, !,  "},{"title":"or​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#or-1","content":"Possible uses:​ predicate or predicate ---&gt; predicateor (predicate , predicate) ---&gt; predicate  Result:​ create a new predicate from two others by including them as subintentions. It's an exclusive &quot;or&quot; Examples:​ predicate1 or predicate2   "},{"title":"osm_file​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#osm_file","content":"Possible uses:​ osm_file (string) ---&gt; filestring osm_file map&amp;lt;string,list&gt; ---&gt; fileosm_file (string , map&amp;lt;string,list&gt;) ---&gt; file  Result:​ Constructs a file of type osm. Allowed extensions are limited to osm, pbf, bz2, gz Special cases:​ osm_file(string): This file constructor allows to read a osm (.osm, .pbf, .bz2, .gz) file (using WGS84 coordinate system for the data)  file f &lt;- osm_file(&quot;file&quot;);  osm_file(string,map&lt;string,list&gt;): This file constructor allows to read an osm (.osm, .pbf, .bz2, .gz) file (using WGS84 coordinate system for the data)The map is used to filter the objects in the file according their attributes: for each key (string) of the map, only the objects that have a value for the attribute contained in the value set are kept. For an exhaustive list of the attibute of OSM data, see: http://wiki.openstreetmap.org/wiki/Map_Features  void var1 &lt;- file f &lt;- osm_file(&quot;file&quot;, map([&quot;highway&quot;::[&quot;primary&quot;, &quot;secondary&quot;], &quot;building&quot;::[&quot;yes&quot;], &quot;amenity&quot;::[]]));; // var1 equals f will contain all the objects of file that have the attibute 'highway' with the value 'primary' or 'secondary', and the objects that have the attribute 'building' with the value 'yes', and all the objects that have the attribute 'aminity' (whatever the value).  See also: is_osm,  "},{"title":"out_degree_of​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#out_degree_of","content":"Possible uses:​ graph out_degree_of unknown ---&gt; intout_degree_of (graph , unknown) ---&gt; int  Result:​ returns the out degree of a vertex (right-hand operand) in the graph given as left-hand operand. Examples:​ int var1 &lt;- graphFromMap out_degree_of (node(3)); // var1 equals 4  See also: in_degree_of, degree_of,  "},{"title":"out_edges_of​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#out_edges_of","content":"Possible uses:​ graph out_edges_of unknown ---&gt; listout_edges_of (graph , unknown) ---&gt; list  Result:​ returns the list of the out-edges of a vertex (right-hand operand) in the graph given as left-hand operand. Examples:​ list var1 &lt;- graphFromMap out_edges_of (node(3)); // var1 equals 3  See also: in_edges_of,  "},{"title":"overlapping​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#overlapping","content":"Possible uses:​ container&amp;lt;unknown,geometry&gt; overlapping geometry ---&gt; list&amp;lt;geometry&gt;overlapping (container&amp;lt;unknown,geometry&gt; , geometry) ---&gt; list&amp;lt;geometry&gt;  Result:​ A list of agents or geometries among the left-operand list, species or meta-population (addition of species), overlapping the operand (casted as a geometry). Examples:​ list&amp;lt;geometry&gt; var0 &lt;- [ag1, ag2, ag3] overlapping(self); // var0 equals return the agents among ag1, ag2 and ag3 that overlap the shape of the agent applying the operator. (species1 + species2) overlapping self  See also: neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, agents_overlapping,  "},{"title":"overlaps​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#overlaps","content":"Possible uses:​ geometry overlaps geometry ---&gt; booloverlaps (geometry , geometry) ---&gt; bool  Result:​ A boolean, equal to true if the left-geometry (or agent/point) overlaps the right-geometry (or agent/point). Special cases:​ if one of the operand is null, returns false. if one operand is a point, returns true if the point is included in the geometry Examples:​ bool var0 &lt;- polyline([{10,10},{20,20}]) overlaps polyline([{15,15},{25,25}]); // var0 equals true bool var1 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); // var1 equals true bool var2 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polyline([{10,10},{20,20}]); // var2 equals true bool var3 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps {15,15}; // var3 equals true  See also: disjoint_from, crosses, intersects, partially_overlaps, touches,  "},{"title":"pair​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#pair","content":"Possible uses:​ pair (any) ---&gt; pair  Result:​ casts the operand in a pair object.  "},{"title":"palette​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#palette","content":"Possible uses:​ palette (list&amp;lt;rgb&gt;) ---&gt; list&amp;lt;rgb&gt;map&amp;lt;rgb,float&gt; palette int ---&gt; list&amp;lt;rgb&gt;palette (map&amp;lt;rgb,float&gt; , int) ---&gt; list&amp;lt;rgb&gt;  Result:​ transforms a list of n colors into a palette (necessary for some layers) returns a list of n colors chosen in the gradient provided. Colors are chosen by interpolating the stops of the gradient (the colors) using their weight, in the order described in the gradient. In case the map&lt;rgb, float&gt; passed in argument is not a gradient but a scale, the colors will be chosen in the set of colors and might appear duplicated in the palette  "},{"title":"partially_overlapping​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#partially_overlapping","content":"Possible uses:​ container&amp;lt;unknown,geometry&gt; partially_overlapping geometry ---&gt; list&amp;lt;geometry&gt;partially_overlapping (container&amp;lt;unknown,geometry&gt; , geometry) ---&gt; list&amp;lt;geometry&gt;  Result:​ A list of agents or geometries among the left-operand list, species or meta-population (addition of species), partially_overlapping the operand (casted as a geometry). Examples:​ list&amp;lt;geometry&gt; var0 &lt;- [ag1, ag2, ag3] partially_overlapping(self); // var0 equals the agents among ag1, ag2 and ag3 that partially_overlap the shape of the right-hand argument. list&amp;lt;geometry&gt; var1 &lt;- (species1 + species2) partially_overlapping (self); // var1 equals the agents among species species1 and species2 that partially_overlap the shape of the right-hand argument.  See also: neighbors_at, neighbors_of, closest_to, overlapping, agents_overlapping, inside, agents_inside, agent_closest_to,  "},{"title":"partially_overlaps​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#partially_overlaps","content":"Possible uses:​ geometry partially_overlaps geometry ---&gt; boolpartially_overlaps (geometry , geometry) ---&gt; bool  Result:​ A boolean, equal to true if the left-geometry (or agent/point) partially overlaps the right-geometry (or agent/point). Comment:​ if one geometry operand fully covers the other geometry operand, returns false (contrarily to the overlaps operator). Special cases:​ if one of the operand is null, returns false. Examples:​ bool var0 &lt;- polyline([{10,10},{20,20}]) partially_overlaps polyline([{15,15},{25,25}]); // var0 equals true bool var1 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); // var1 equals true bool var2 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps {25,25}; // var2 equals false bool var3 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polyline([{10,10},{20,20}]); // var3 equals false  See also: disjoint_from, crosses, overlaps, intersects, touches,  "},{"title":"path​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#path","content":"Possible uses:​ path (any) ---&gt; path  Result:​ casts the operand in a path object. Special cases:​ if the operand is a path, returns this path if the operand is a geometry of an agent, returns a path from the list of points of the geometry if the operand is a list, cast each element of the list as a point and create a path from these points  path p &lt;- path([{12,12},{30,30},{50,50}]);   "},{"title":"path_between​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#path_between","content":"Possible uses:​ map&amp;lt;agent,unknown&gt; path_between container&amp;lt;unknown,geometry&gt; ---&gt; pathpath_between (map&amp;lt;agent,unknown&gt; , container&amp;lt;unknown,geometry&gt;) ---&gt; pathtopology path_between container&amp;lt;unknown,geometry&gt; ---&gt; pathpath_between (topology , container&amp;lt;unknown,geometry&gt;) ---&gt; pathlist&amp;lt;agent&gt; path_between container&amp;lt;unknown,geometry&gt; ---&gt; pathpath_between (list&amp;lt;agent&gt; , container&amp;lt;unknown,geometry&gt;) ---&gt; pathpath_between (list&amp;lt;agent&gt;, geometry, geometry) ---&gt; pathpath_between (graph, geometry, geometry) ---&gt; pathpath_between (map&amp;lt;agent,unknown&gt;, geometry, geometry) ---&gt; pathpath_between (topology, geometry, geometry) ---&gt; path  Result:​ The shortest path between several objects according to set of cells with corresponding weights The shortest path between two objects according to set of cells The shortest path between a list of two objects in a graph The shortest path between several objects according to set of cells The shortest path between two objects according to set of cells with corresponding weights Examples:​ path var0 &lt;- path_between (cell_grid as_map (each::each.is_obstacle ? 9999.0 : 1.0), [ag1, ag2, ag3]); // var0 equals A path between ag1 and ag2 and ag3 passing through the given cell_grid agents with minimal cost path var1 &lt;- path_between (cell_grid where each.is_free, ag1, ag2); // var1 equals A path between ag1 and ag2 passing through the given cell_grid agents path var2 &lt;- path_between (my_graph, ag1, ag2); // var2 equals A path between ag1 and ag2 path var3 &lt;- my_topology path_between [ag1, ag2]; // var3 equals A path between ag1 and ag2 path var4 &lt;- path_between (cell_grid where each.is_free, [ag1, ag2, ag3]); // var4 equals A path between ag1 and ag2 and ag3 passing through the given cell_grid agents path var5 &lt;- path_between (cell_grid as_map (each::each.is_obstacle ? 9999.0 : 1.0), ag1, ag2); // var5 equals A path between ag1 and ag2 passing through the given cell_grid agents with a minimal cost path var6 &lt;- my_topology path_between (ag1, ag2); // var6 equals A path between ag1 and ag2  See also: towards, direction_to, distance_between, direction_between, path_to, distance_to,  "},{"title":"path_to​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#path_to","content":"Possible uses:​ point path_to point ---&gt; pathpath_to (point , point) ---&gt; pathgeometry path_to geometry ---&gt; pathpath_to (geometry , geometry) ---&gt; path  Result:​ A path between two geometries (geometries, agents or points) considering the topology of the agent applying the operator. Examples:​ path var0 &lt;- ag1 path_to ag2; // var0 equals the path between ag1 and ag2 considering the topology of the agent applying the operator  See also: towards, direction_to, distance_between, direction_between, path_between, distance_to,  "},{"title":"paths_between​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#paths_between","content":"Possible uses:​ paths_between (graph, pair, int) ---&gt; list&amp;lt;path&gt;  Result:​ The K shortest paths between a list of two objects in a graph Examples:​ list&amp;lt;path&gt; var0 &lt;- paths_between(my_graph, ag1:: ag2, 2); // var0 equals the 2 shortest paths (ordered by length) between ag1 and ag2   "},{"title":"pbinom​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#pbinom","content":"Same signification as binomial_sum  "},{"title":"pchisq​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#pchisq","content":"Same signification as chi_square  "},{"title":"percent_absolute_deviation​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#percent_absolute_deviation","content":"Possible uses:​ list&amp;lt;float&gt; percent_absolute_deviation list&amp;lt;float&gt; ---&gt; floatpercent_absolute_deviation (list&amp;lt;float&gt; , list&amp;lt;float&gt;) ---&gt; float  Result:​ percent absolute deviation indicator for 2 series of values: percent_absolute_deviation(list_vals_observe,list_vals_sim) Examples:​ float var0 &lt;- percent_absolute_deviation([200,300,150,150,200],[250,250,100,200,200]); // var0 equals 20.0   "},{"title":"percentile​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#percentile","content":"Same signification as quantile_inverse  "},{"title":"pgamma​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#pgamma","content":"Same signification as gamma_distribution  "},{"title":"pgm_file​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#pgm_file","content":"Possible uses:​ pgm_file (string) ---&gt; file  Result:​ Constructs a file of type pgm. Allowed extensions are limited to pgm Special cases:​ pgm_file(string): This file constructor allows to read a pgm file  file f &lt;-pgm_file(&quot;file.pgm&quot;);  See also: is_pgm,  "},{"title":"plan​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#plan","content":"Possible uses:​ container&amp;lt;unknown,geometry&gt; plan float ---&gt; geometryplan (container&amp;lt;unknown,geometry&gt; , float) ---&gt; geometry  Result:​ A polyline geometry from the given list of points. Special cases:​ if the operand is nil, returns the point geometry {0,0} if the operand is composed of a single point, returns a point geometry. Examples:​ geometry var0 &lt;- polyplan([{0,0}, {0,10}, {10,10}, {10,0}],10); // var0 equals a polyline geometry composed of the 4 points with a depth of 10.  See also: around, circle, cone, link, norm, point, polygone, rectangle, square, triangle,  "},{"title":"plus_days​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#plus_days","content":"Possible uses:​ date plus_days int ---&gt; dateplus_days (date , int) ---&gt; date  Result:​ Add a given number of days to a date Examples:​ date var0 &lt;- date('2000-01-01') plus_days 12; // var0 equals date('2000-01-13')   "},{"title":"plus_hours​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#plus_hours","content":"Possible uses:​ date plus_hours int ---&gt; dateplus_hours (date , int) ---&gt; date  Result:​ Add a given number of hours to a date Examples:​ // equivalent to date1 + 15 #h date var1 &lt;- date('2000-01-01') plus_hours 24; // var1 equals date('2000-01-02')   "},{"title":"plus_minutes​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#plus_minutes","content":"Possible uses:​ date plus_minutes int ---&gt; dateplus_minutes (date , int) ---&gt; date  Result:​ Add a given number of minutes to a date Examples:​ // equivalent to date1 + 5 #mn date var1 &lt;- date('2000-01-01') plus_minutes 5 ; // var1 equals date('2000-01-01 00:05:00')   "},{"title":"plus_months​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#plus_months","content":"Possible uses:​ date plus_months int ---&gt; dateplus_months (date , int) ---&gt; date  Result:​ Add a given number of months to a date Examples:​ date var0 &lt;- date('2000-01-01') plus_months 5; // var0 equals date('2000-06-01')   "},{"title":"plus_ms​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#plus_ms","content":"Possible uses:​ date plus_ms int ---&gt; dateplus_ms (date , int) ---&gt; date  Result:​ Add a given number of milliseconds to a date Examples:​ // equivalent to date('2000-01-01') + 15 #ms date var1 &lt;- date('2000-01-01') plus_ms 1000 ; // var1 equals date('2000-01-01 00:00:01')   "},{"title":"plus_seconds​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#plus_seconds","content":"Same signification as +  "},{"title":"plus_weeks​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#plus_weeks","content":"Possible uses:​ date plus_weeks int ---&gt; dateplus_weeks (date , int) ---&gt; date  Result:​ Add a given number of weeks to a date Examples:​ date var0 &lt;- date('2000-01-01') plus_weeks 15; // var0 equals date('2000-04-15')   "},{"title":"plus_years​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#plus_years","content":"Possible uses:​ date plus_years int ---&gt; dateplus_years (date , int) ---&gt; date  Result:​ Add a given number of years to a date Examples:​ date var0 &lt;- date('2000-01-01') plus_years 15; // var0 equals date('2015-01-01')   "},{"title":"pnorm​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#pnorm","content":"Same signification as normal_area  "},{"title":"point​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#point","content":"Possible uses:​ point (any) ---&gt; point  Result:​ casts the operand in a point object.  "},{"title":"points_along​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#points_along","content":"Possible uses:​ geometry points_along list&amp;lt;float&gt; ---&gt; listpoints_along (geometry , list&amp;lt;float&gt;) ---&gt; list  Result:​ A list of points along the operand-geometry given its location in terms of rate of distance from the starting points of the geometry. Examples:​ list var0 &lt;- line([{10,10},{80,80}]) points_along ([0.3, 0.5, 0.9]); // var0 equals the list of following points: [{31.0,31.0,0.0},{45.0,45.0,0.0},{73.0,73.0,0.0}]  See also: closest_points_with, farthest_point_to, points_at, points_on,  "},{"title":"points_at​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#points_at","content":"Possible uses:​ int points_at float ---&gt; list&amp;lt;point&gt;points_at (int , float) ---&gt; list&amp;lt;point&gt;  Result:​ A list of left-operand number of points located at a the right-operand distance to the agent location. Examples:​ list&amp;lt;point&gt; var0 &lt;- 3 points_at(20.0); // var0 equals returns [pt1, pt2, pt3] with pt1, pt2 and pt3 located at a distance of 20.0 to the agent location  See also: any_location_in, any_point_in, closest_points_with, farthest_point_to,  "},{"title":"points_in​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#points_in","content":"Possible uses:​ field points_in geometry ---&gt; list&amp;lt;point&gt;points_in (field , geometry) ---&gt; list&amp;lt;point&gt;  "},{"title":"points_on​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#points_on","content":"Possible uses:​ geometry points_on float ---&gt; listpoints_on (geometry , float) ---&gt; list  Result:​ A list of points of the operand-geometry distant from each other to the float right-operand . Examples:​ list var0 &lt;- square(5) points_on(2); // var0 equals a list of points belonging to the exterior ring of the square distant from each other of 2.  See also: closest_points_with, farthest_point_to, points_at,  "},{"title":"poisson​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#poisson","content":"Possible uses:​ poisson (float) ---&gt; int  Result:​ A value from a random variable following a Poisson distribution (with the positive expected number of occurence lambda as operand). Comment:​ The Poisson distribution is a discrete probability distribution that expresses the probability of a given number of events occurring in a fixed interval of time and/or space if these events occur with a known average rate and independently of the time since the last event, cf. Poisson distribution on Wikipedia. Examples:​ int var0 &lt;- poisson(3.5); // var0 equals a random positive integer  See also: binomial, gamma_rnd, gauss_rnd, lognormal_rnd, rnd, skew_gauss, truncated_gauss, weibull_rnd,  "},{"title":"polygon​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#polygon","content":"Possible uses:​ polygon (container&amp;lt;unknown,geometry&gt;) ---&gt; geometry  Result:​ A polygon geometry from the given list of points. Special cases:​ if the operand is nil, returns the point geometry {0,0} if the operand is composed of a single point, returns a point geometry if the operand is composed of 2 points, returns a polyline geometry. Examples:​ geometry var0 &lt;- polygon([{0,0}, {0,10}, {10,10}, {10,0}]); // var0 equals a polygon geometry composed of the 4 points. float var1 &lt;- polygon([{0,0}, {0,10}, {10,10}, {10,0}]).area; // var1 equals 100.0 point var2 &lt;- polygon([{0,0}, {0,10}, {10,10}, {10,0}]).location; // var2 equals point(5.0,5.0,0.0)  See also: around, circle, cone, line, link, norm, point, polyline, rectangle, square, triangle,  "},{"title":"polyhedron​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#polyhedron","content":"Possible uses:​ container&amp;lt;unknown,geometry&gt; polyhedron float ---&gt; geometrypolyhedron (container&amp;lt;unknown,geometry&gt; , float) ---&gt; geometry  Result:​ A polyhedron geometry from the given list of points. Special cases:​ if the operand is nil, returns the point geometry {0,0} if the operand is composed of a single point, returns a point geometry if the operand is composed of 2 points, returns a polyline geometry. Examples:​ geometry var0 &lt;- polyhedron([{0,0}, {0,10}, {10,10}, {10,0}],10); // var0 equals a polygon geometry composed of the 4 points and of depth 10.  See also: around, circle, cone, line, link, norm, point, polyline, rectangle, square, triangle,  "},{"title":"polyline​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#polyline","content":"Same signification as line  "},{"title":"polyplan​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#polyplan","content":"Same signification as plan  "},{"title":"predecessors_of​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#predecessors_of","content":"Possible uses:​ graph predecessors_of unknown ---&gt; listpredecessors_of (graph , unknown) ---&gt; list  Result:​ returns the list of predecessors (i.e. sources of in edges) of the given vertex (right-hand operand) in the given graph (left-hand operand) Examples:​ list var1 &lt;- graphEpidemio predecessors_of ({1,5}); // var1 equals [] list var2 &lt;- graphEpidemio predecessors_of node({34,56}); // var2 equals [{12;45}]  See also: neighbors_of, successors_of,  "},{"title":"predicate​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#predicate","content":"Possible uses:​ predicate (any) ---&gt; predicate  Result:​ casts the operand in a predicate object.  "},{"title":"predict​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#predict","content":"Possible uses:​ regression predict list ---&gt; floatpredict (regression , list) ---&gt; float  Result:​ returns the value predicted by the regression parameters for a given instance. Usage: predict(regression, instance) Examples:​ predict(my_regression, [1,2,3])   "},{"title":"product​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#product","content":"Same signification as mul  "},{"title":"product_of​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#product_of","content":"Possible uses:​ container product_of any expression ---&gt; unknownproduct_of (container , any expression) ---&gt; unknown  Result:​ the product of the right-hand expression evaluated on each of the elements of the left-hand operand Comment:​ in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. Special cases:​ if the left-operand is a map, the keyword each will contain each value  unknown var1 &lt;- [1::2, 3::4, 5::6] product_of (each); // var1 equals 48  Examples:​ unknown var0 &lt;- [1,2] product_of (each * 10 ); // var0 equals 200  See also: min_of, max_of, sum_of, mean_of,  "},{"title":"promethee_DM​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#promethee_dm","content":"Possible uses:​ list&amp;lt;list&gt; promethee_DM list&amp;lt;map&amp;lt;string,unknown&gt;&gt; ---&gt; intpromethee_DM (list&amp;lt;list&gt; , list&amp;lt;map&amp;lt;string,unknown&gt;&gt;) ---&gt; int  Result:​ The index of the best candidate according to the Promethee II method. This method is based on a comparison per pair of possible candidates along each criterion: all candidates are compared to each other by pair and ranked. More information about this method can be found in [http://www.sciencedirect.com/science?_ob=ArticleURL&amp;_udi=B6VCT-4VF56TV-1&amp;_user=10&amp;_coverDate=01%2F01%2F2010&amp;_rdoc=1&amp;_fmt=high&amp;_orig=search&amp;_sort=d&amp;_docanchor=&amp;view=c&amp;_searchStrId=1389284642&amp;_rerunOrigin=google&amp;_acct=C000050221&amp;_version=1&amp;_urlVersion=0&amp;_userid=10&amp;md5=d334de2a4e0d6281199a39857648cd36 Behzadian, M., Kazemzadeh, R., Albadvi, A., M., A.: PROMETHEE: A comprehensive literature review on methodologies and applications. European Journal of Operational Research(2009)]. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains fours elements: a name, a weight, a preference value (p) and an indifference value (q). The preference value represents the threshold from which the difference between two criterion values allows to prefer one vector of values over another. The indifference value represents the threshold from which the difference between two criterion values is considered significant. Special cases:​ returns -1 is the list of candidates is nil or empty Examples:​ int var0 &lt;- promethee_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[&quot;name&quot;::&quot;utility&quot;, &quot;weight&quot; :: 2.0,&quot;p&quot;::0.5, &quot;q&quot;::0.0, &quot;s&quot;::1.0, &quot;maximize&quot; :: true],[&quot;name&quot;::&quot;price&quot;, &quot;weight&quot; :: 1.0,&quot;p&quot;::0.5, &quot;q&quot;::0.0, &quot;s&quot;::1.0, &quot;maximize&quot; :: false]]); // var0 equals 1  See also: weighted_means_DM, electre_DM, evidence_theory_DM,  "},{"title":"property_file​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#property_file","content":"Possible uses:​ property_file (string) ---&gt; filestring property_file map&amp;lt;string,string&gt; ---&gt; fileproperty_file (string , map&amp;lt;string,string&gt;) ---&gt; file  Result:​ Constructs a file of type property. Allowed extensions are limited to properties Special cases:​ property_file(string): This file constructor allows to read a property file (.properties)  file f &lt;-property_file(&quot;file.properties&quot;);  property_file(string,map&lt;string,string&gt;): This file constructor allows to store a map in a property file (it does not save it - just store it in memory)  file f &lt;-property_file(&quot;file.properties&quot;, map([&quot;param1&quot;::1.0,&quot;param3&quot;::10.0 ]));  See also: is_property,  "},{"title":"pValue_for_fStat​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#pvalue_for_fstat","content":"Possible uses:​ pValue_for_fStat (float, int, int) ---&gt; float  Result:​ Returns the P value of F statistic fstat with numerator degrees of freedom dfn and denominator degress of freedom dfd. Uses the incomplete Beta function. Examples:​ float var0 &lt;- pValue_for_fStat(1.9,10,12) with_precision(3); // var0 equals 0.145   "},{"title":"pValue_for_tStat​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#pvalue_for_tstat","content":"Possible uses:​ float pValue_for_tStat int ---&gt; floatpValue_for_tStat (float , int) ---&gt; float  Result:​ Returns the P value of the T statistic tstat with df degrees of freedom. This is a two-tailed test so we just double the right tail which is given by studentT of -|tstat|. Examples:​ float var0 &lt;- pValue_for_tStat(0.9,10) with_precision(3); // var0 equals 0.389   "},{"title":"pyramid​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#pyramid","content":"Possible uses:​ pyramid (float) ---&gt; geometry  Result:​ A square geometry which side size is given by the operand. Comment:​ the center of the pyramid is by default the location of the current agent in which has been called this operator. Special cases:​ returns nil if the operand is nil. Examples:​ geometry var0 &lt;- pyramid(5); // var0 equals a geometry as a square with side_size = 5.  See also: around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, square,  "},{"title":"quantile​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#quantile","content":"Possible uses:​ container quantile float ---&gt; floatquantile (container , float) ---&gt; float  Result:​ Returns the phi-quantile; that is, an element elem for which holds that phi percent of data elements are less than elem. The quantile does not need necessarily to be contained in the data sequence, it can be a linear interpolation. Note that the container holding the values must be sorted first Examples:​ float var0 &lt;- quantile([1,3,5,6,9,11,12,13,19,21,22,32,35,36,45,44,55,68,79,80,81,88,90,91,92,100], 0.5); // var0 equals 35.5   "},{"title":"quantile_inverse​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#quantile_inverse","content":"Possible uses:​ container quantile_inverse float ---&gt; floatquantile_inverse (container , float) ---&gt; float  Result:​ Returns how many percent of the elements contained in the receiver are &lt;= element. Does linear interpolation if the element is not contained but lies in between two contained elements. Note that the container holding the values must be sorted first Examples:​ float var0 &lt;- quantile_inverse([1,3,5,6,9,11,12,13,19,21,22,32,35,36,45,44,55,68,79,80,81,88,90,91,92,100], 35.5) with_precision(2); // var0 equals 0.52   "},{"title":"range​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#range","content":"Possible uses:​ range (int) ---&gt; listint range int ---&gt; listrange (int , int) ---&gt; listrange (int, int, int) ---&gt; list  Result:​ builds a list of int representing all contiguous values from zero to the argument. The range can be increasing or decreasing. Special cases:​ Passing 0 will return a singleton list with 0. When used with 2 operands, it returns the list of int representing all contiguous values from the first to the second argument. Passing the same value for both will return a singleton list with this value  list var0 &lt;- range(0,2); // var0 equals [0,1,2]  When used with 3 operands, it returns a list of int representing all contiguous values from the first to the second argument, using the step represented by the third argument. The range can be increasing or decreasing. Passing the same value for both will return a singleton list with this value. Passing a step of 0 will result in an exception. Attempting to build infinite ranges (e.g. end &gt; start with a negative step) will similarly not be accepted and yield an exception  list var1 &lt;- range(0,6,2); // var1 equals [0,2,4,6]   "},{"title":"rank_interpolated​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#rank_interpolated","content":"Possible uses:​ container rank_interpolated float ---&gt; floatrank_interpolated (container , float) ---&gt; float  Result:​ Returns the linearly interpolated number of elements in a list less or equal to a given element. The rank is the number of elements &lt;= element. Ranks are of the form {0, 1, 2,..., sortedList.size()}. If no element is &lt;= element, then the rank is zero. If the element lies in between two contained elements, then linear interpolation is used and a non integer value is returned. Note that the container holding the values must be sorted first Examples:​ float var0 &lt;- rank_interpolated([1,3,5,6,9,11,12,13,19,21,22,32,35,36,45,44,55,68,79,80,81,88,90,91,92,100], 35); // var0 equals 13.0   "},{"title":"read​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#read","content":"Possible uses:​ read (string) ---&gt; unknown  Result:​ Reads an attribute of the agent. The attribute's name is specified by the operand. Examples:​ agent_name &lt;- read ('name'); //agent_name equals reads the 'name' variable of agent then assigns the returned value to the 'agent_name' variable.   "},{"title":"rectangle​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#rectangle","content":"Possible uses:​ rectangle (point) ---&gt; geometrypoint rectangle point ---&gt; geometryrectangle (point , point) ---&gt; geometryfloat rectangle float ---&gt; geometryrectangle (float , float) ---&gt; geometry  Result:​ A rectangle geometry, computed from the operands values (e.g. the 2 side sizes). Comment:​ the center of the rectangle is by default the location of the current agent in which has been called this operator.the center of the rectangle is by default the location of the current agent in which has been called this operator. Special cases:​ returns nil if the operand is nil. Examples:​ geometry var0 &lt;- rectangle({0.0,0.0}, {10.0,10.0}); // var0 equals a geometry as a rectangle with {1.0,1.0} as the upper-left corner, {10.0,10.0} as the lower-right corner. geometry var1 &lt;- rectangle({10, 5}); // var1 equals a geometry as a rectangle with width = 10 and height = 5. geometry var2 &lt;- rectangle(10, 5); // var2 equals a geometry as a rectangle with width = 10 and height = 5.  See also: around, circle, cone, line, link, norm, point, polygon, polyline, square, triangle,  "},{"title":"reduced_by​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#reduced_by","content":"Same signification as -  "},{"title":"regex_matches​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#regex_matches","content":"Possible uses:​ string regex_matches string ---&gt; list&amp;lt;string&gt;regex_matches (string , string) ---&gt; list&amp;lt;string&gt;  Result:​ Returns the list of sub-strings of the first operand that match the regular expression provided in the second operand Examples:​ list&amp;lt;string&gt; var0 &lt;- regex_matches(&quot;colour, color&quot;, &quot;colou?r&quot;); // var0 equals ['colour','color']  See also: replace_regex,  "},{"title":"regression​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#regression","content":"Possible uses:​ regression (any) ---&gt; regression  Result:​ casts the operand in a regression object.  "},{"title":"remove_duplicates​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#remove_duplicates","content":"Possible uses:​ remove_duplicates (container) ---&gt; list  Result:​ produces a set from the elements of the operand (i.e. a list without duplicated elements) Special cases:​ if the operand is a graph, remove_duplicates returns the set of nodes if the operand is empty, remove_duplicates returns an empty list  list var1 &lt;- remove_duplicates([]); // var1 equals []  if the operand is a map, remove_duplicates returns the set of values without duplicate  list var2 &lt;- remove_duplicates([1::3,2::4,3::3,5::7]); // var2 equals [3,4,7]  if the operand is a matrix, remove_duplicates returns a list containing all the elments with duplicated.  list var3 &lt;- remove_duplicates([[&quot;c11&quot;,&quot;c12&quot;,&quot;c13&quot;,&quot;c13&quot;],[&quot;c21&quot;,&quot;c22&quot;,&quot;c23&quot;,&quot;c23&quot;]]); // var3 equals [[&quot;c11&quot;,&quot;c12&quot;,&quot;c13&quot;,&quot;c21&quot;,&quot;c22&quot;,&quot;c23&quot;]]  Examples:​ list var0 &lt;- remove_duplicates([3,2,5,1,2,3,5,5,5]); // var0 equals [3,2,5,1]   "},{"title":"remove_node_from​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#remove_node_from","content":"Possible uses:​ geometry remove_node_from graph ---&gt; graphremove_node_from (geometry , graph) ---&gt; graph  Result:​ removes a node from a graph. Comment:​ WARNING / side effect: this operator modifies the operand and does not create a new graph. All the edges containing this node are also removed. Examples:​ graph var0 &lt;- node(0) remove_node_from graphEpidemio; // var0 equals the graph without node(0)   "},{"title":"rename_file​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#rename_file","content":"Possible uses:​ string rename_file string ---&gt; boolrename_file (string , string) ---&gt; bool  Result:​ rename/move a file or a folder Examples:​ bool rename_file_ok &lt;- rename_file(&quot;../includes/my_folder&quot;,&quot;../includes/my_new_folder&quot;);   "},{"title":"replace​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#replace","content":"Possible uses:​ replace (string, string, string) ---&gt; string  Result:​ Returns the string obtained by replacing by the third operand, in the first operand, all the sub-strings equal to the second operand Examples:​ string var0 &lt;- replace('to be or not to be,that is the question','to', 'do'); // var0 equals 'do be or not do be,that is the question'  See also: replace_regex,  "},{"title":"replace_regex​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#replace_regex","content":"Possible uses:​ replace_regex (string, string, string) ---&gt; string  Result:​ Returns the string obtained by replacing by the third operand, in the first operand, all the sub-strings that match the regular expression of the second operand Examples:​ string var0 &lt;- replace_regex(&quot;colour, color&quot;, &quot;colou?r&quot;, &quot;col&quot;); // var0 equals 'col, col'  See also: replace,  "},{"title":"restore_simulation​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#restore_simulation","content":"Possible uses:​ restore_simulation (string) ---&gt; int  Result:​ restores a simulation from a string value containing a serialized simulation. Comment:​ This operator should be used in a reflex of an experiment and it will remove the current simulation and replace it by the new restored simulation See also: restore_simulation_from_file,  "},{"title":"restore_simulation_from_file​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#restore_simulation_from_file","content":"Possible uses:​ restore_simulation_from_file (file) ---&gt; int  Result:​ Restores a simulation from a saved simulation file. Comment:​ This operator should be used in a reflex of an experiment and it will remove the current simulation and replace it by the new restored simulation See also: restore_simulation,  "},{"title":"reverse​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#reverse","content":"Possible uses:​ reverse (map&amp;lt;K,V&gt;) ---&gt; mapreverse (container&amp;lt;KeyType,ValueType&gt;) ---&gt; container&amp;lt;unknown,unknown&gt;reverse (string) ---&gt; string  Result:​ the operand elements in the reversed order in a copy of the operand. Comment:​ the reverse operator behavior depends on the nature of the operand Special cases:​ if it is a file, reverse returns a copy of the file with a reversed content if it is a population, reverse returns a copy of the population with elements in the reversed order if it is a graph, reverse returns a copy of the graph (with all edges and vertexes), with all of the edges reversed if it is a list, reverse returns a copy of the operand list with elements in the reversed order  list&amp;lt;int&gt; var2 &lt;- reverse ([10,12,14]); // var2 equals [14, 12, 10]  if it is a map, reverse returns a copy of the operand map with each pair in the reversed order (i.e. all keys become values and values become keys)  map&amp;lt;int,string&gt; var3 &lt;- reverse (['k1'::44, 'k2'::32, 'k3'::12]); // var3 equals [44::'k1', 32::'k2', 12::'k3']  if it is a matrix, reverse returns a new matrix containing the transpose of the operand.  matrix&amp;lt;string&gt; var4 &lt;- reverse(matrix([[&quot;c11&quot;,&quot;c12&quot;,&quot;c13&quot;],[&quot;c21&quot;,&quot;c22&quot;,&quot;c23&quot;]])); // var4 equals matrix([[&quot;c11&quot;,&quot;c21&quot;],[&quot;c12&quot;,&quot;c22&quot;],[&quot;c13&quot;,&quot;c23&quot;]])  if it is a string, reverse returns a new string with characters in the reversed order  string var5 &lt;- reverse ('abcd'); // var5 equals 'dcba'  Examples:​ map&amp;lt;int,int&gt; m &lt;- [1::111,2::222, 3::333, 4::444]; map var1 &lt;- reverse(m); // var1 equals map([111::1,222::2,333::3,444::4])   "},{"title":"rewire_n​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#rewire_n","content":"Possible uses:​ graph rewire_n int ---&gt; graphrewire_n (graph , int) ---&gt; graph  Result:​ rewires the given count of edges. Comment:​ WARNING / side effect: this operator modifies the operand and does not create a new graph. If there are too many edges, all the edges will be rewired. Examples:​ graph var1 &lt;- graphEpidemio rewire_n 10; // var1 equals the graph with 3 edges rewired   "},{"title":"rgb​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#rgb","content":"Possible uses:​ rgb rgb int ---&gt; rgbrgb (rgb , int) ---&gt; rgbstring rgb int ---&gt; rgbrgb (string , int) ---&gt; rgbrgb rgb float ---&gt; rgbrgb (rgb , float) ---&gt; rgbrgb (int, int, int) ---&gt; rgbrgb (int, int, int, int) ---&gt; rgbrgb (int, int, int, float) ---&gt; rgb  Result:​ Returns a color defined by red, green, blue components and an alpha blending value. Special cases:​ It can be used with a color and an alpha between 0 and 255 It can be used with a name of color and alpha (between 0 and 255) It can be used with r=red, g=green, b=blue (each between 0 and 255), a=alpha (between 0 and 255) It can be used with r=red, g=green, b=blue, each between 0 and 255 It can be used with a color and an alpha between 0 and 1 It can be used with r=red, g=green, b=blue (each between 0 and 255), a=alpha (between 0.0 and 1.0) Examples:​ rgb var0 &lt;- rgb(rgb(255,0,0),125); // var0 equals a light red color rgb var1 &lt;- rgb (&quot;red&quot;); // var1 equals rgb(255,0,0) rgb var2 &lt;- rgb (255,0,0,125); // var2 equals a light red color rgb var3 &lt;- rgb (255,0,0); // var3 equals #red rgb var4 &lt;- rgb(rgb(255,0,0),0.5); // var4 equals a light red color rgb var5 &lt;- rgb (255,0,0,0.5); // var5 equals a light red color  See also: hsb,  "},{"title":"rgb​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#rgb-1","content":"Possible uses:​ rgb (any) ---&gt; rgb  Result:​ casts the operand in a rgb object.  "},{"title":"rms​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#rms","content":"Possible uses:​ int rms float ---&gt; floatrms (int , float) ---&gt; float  Result:​ Returns the RMS (Root-Mean-Square) of a data sequence. The RMS of data sequence is the square-root of the mean of the squares of the elements in the data sequence. It is a measure of the average size of the elements of a data sequence. Examples:​  list&amp;lt;float&gt; data_sequence &lt;- [6.0, 7.0, 8.0, 9.0]; list&amp;lt;float&gt; squares &lt;- data_sequence collect (each*each); float var2 &lt;- rms(length(data_sequence),sum(squares)) with_precision(4) ; // var2 equals 7.5829   "},{"title":"rnd​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#rnd","content":"Possible uses:​ rnd (float) ---&gt; floatrnd (int) ---&gt; intrnd (point) ---&gt; pointint rnd int ---&gt; intrnd (int , int) ---&gt; intfloat rnd float ---&gt; floatrnd (float , float) ---&gt; floatpoint rnd point ---&gt; pointrnd (point , point) ---&gt; pointrnd (float, float, float) ---&gt; floatrnd (point, point, float) ---&gt; pointrnd (int, int, int) ---&gt; int  Result:​ returns a random value in a range (the type value depends on the operand type): when called with an integer, it returns a random integer in the interval [0, operand] Comment:​ to obtain a probability between 0 and 1, use the expression (rnd n) / n, where n is used to indicate the precision Special cases:​ if the operand is a float, returns an uniformly distributed float random number in [0.0, to] if the operand is a point, returns a point with three random float ordinates, each in the interval [0, ordinate of argument] Examples:​ int var0 &lt;- rnd (2, 4); // var0 equals 2, 3 or 4 float var1 &lt;- rnd(3.4); // var1 equals a random float between 0.0 and 3.4 float var2 &lt;- rnd (2.0, 4.0, 0.5); // var2 equals a float number between 2.0 and 4.0 every 0.5 int var3 &lt;- rnd (2); // var3 equals 0, 1 or 2 point var4 &lt;- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}, 1); // var4 equals a point with x = 2.0, y equal to 2.0, 3.0 or 4.0 and z between 0.0 and 10.0 every 1.0 float var5 &lt;- rnd (2.0, 4.0); // var5 equals a float number between 2.0 and 4.0 point var6 &lt;- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}); // var6 equals a point with x = 2.0, y between 2.0 and 4.0 and z between 0.0 and 10.0 int var7 &lt;- rnd (2, 12, 4); // var7 equals 2, 6 or 10 point var8 &lt;- rnd ({2.5,3, 0.0}); // var8 equals {x,y} with x in [0.0,2.0], y in [0.0,3.0], z = 0.0  See also: binomial, gamma_rnd, gauss_rnd, lognormal_rnd, poisson, skew_gauss, truncated_gauss, weibull_rnd,  "},{"title":"rnd_choice​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#rnd_choice","content":"Possible uses:​ rnd_choice (map&amp;lt;unknown,unknown&gt;) ---&gt; unknownrnd_choice (list) ---&gt; int  Result:​ returns a key from the map with a probability following the (normalized) distribution described in map values (a form of lottery) returns an index of the given list with a probability following the (normalized) distribution described in the list (a form of lottery) Examples:​ unknown var0 &lt;- rnd_choice([&quot;toto&quot;::0.2,\\&quot;tata\\&quot;::0.5,\\&quot;tonton\\&quot;::0.3]); // var0 equals 2/10 chances to return &quot;toto&quot;, 5/10 chances to return &quot;tata&quot;, 3/10 chances to return &quot;tonton&quot; int var1 &lt;- rnd_choice([0.2,0.5,0.3]); // var1 equals 2/10 chances to return 0, 5/10 chances to return 1, 3/10 chances to return 2  See also: rnd,  "},{"title":"rnd_color​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#rnd_color","content":"Possible uses:​ rnd_color (int) ---&gt; rgbint rnd_color int ---&gt; rgbrnd_color (int , int) ---&gt; rgb  Result:​ Return a random color equivalent to rgb(rnd(first_op, last_op),rnd(first_op, last_op),rnd(first_op, last_op)) rgb color Comment:​ Return a random color equivalent to rgb(rnd(operand),rnd(operand),rnd(operand)) Examples:​ rgb var0 &lt;- rnd_color(100, 200); // var0 equals a random color, equivalent to rgb(rnd(100, 200),rnd(100, 200),rnd(100, 200)) rgb var1 &lt;- rnd_color(255); // var1 equals a random color, equivalent to rgb(rnd(255),rnd(255),rnd(255))  See also: rgb, hsb,  "},{"title":"rotated_by​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#rotated_by","content":"Possible uses:​ point rotated_by pair ---&gt; pointrotated_by (point , pair) ---&gt; pointgeometry rotated_by int ---&gt; geometryrotated_by (geometry , int) ---&gt; geometrygeometry rotated_by float ---&gt; geometryrotated_by (geometry , float) ---&gt; geometrygeometry rotated_by pair ---&gt; geometryrotated_by (geometry , pair) ---&gt; geometryrotated_by (geometry, float, point) ---&gt; geometry  Result:​ A geometry resulting from the application of a rotation by the right-hand operand angle (degree) to the left-hand operand (geometry, agent, point) A geometry resulting from the application of a rotation by the operand angles (degree) along the operand axis (last operand) to the left-hand operand (geometry, agent, point) Special cases:​ When used with a point and a pair angle::point, it returns a point resulting from the application of the right-hand rotation operand (angles in degree) to the left-hand operand point the right-hand operand representing the angle can be a float or an integer Examples:​ geometry var0 &lt;- self rotated_by 45; // var0 equals the geometry resulting from a 45 degrees rotation to the geometry of the agent applying the operator. geometry var1 &lt;- rotated_by(pyramid(10),45.0::{1,0,0}); // var1 equals the geometry resulting from a 45 degrees rotation along the {1,0,0} vector to the geometry of the agent applying the operator. geometry var2 &lt;- rotated_by(pyramid(10),45.0, {1,0,0}); // var2 equals the geometry resulting from a 45 degrees rotation along the {1,0,0} vector to the geometry of the agent applying the operator.  See also: transformed_by, translated_by,  "},{"title":"rotation_composition​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#rotation_composition","content":"Possible uses:​ rotation_composition (list&amp;lt;pair&gt;) ---&gt; pair&amp;lt;float,point&gt;  Result:​ The rotation resulting from the composition of the rotations in the list, from left to right. Angles are in degrees. Examples:​ pair&amp;lt;float,point&gt; var0 &lt;- rotation_composition([38.0::{1,1,1},90.0::{1,0,0}]); // var0 equals 115.22128507898108::{0.9491582126366207,0.31479943993669307,-0.0}  See also: inverse_rotation,  "},{"title":"round​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#round","content":"Possible uses:​ round (float) ---&gt; intround (point) ---&gt; pointround (int) ---&gt; int  Result:​ Returns the rounded value of the operand. Special cases:​ if the operand is an int, round returns it Examples:​ int var0 &lt;- round (0.51); // var0 equals 1 int var1 &lt;- round (100.2); // var1 equals 100 int var2 &lt;- round(-0.51); // var2 equals -1 point var3 &lt;- {12345.78943, 12345.78943, 12345.78943} with_precision 2; // var3 equals {12345.79,12345.79,12345.79}  See also: int, with_precision, round,  "},{"title":"row_at​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#row_at","content":"Possible uses:​ matrix&amp;lt;unknown&gt; row_at int ---&gt; list&amp;lt;unknown&gt;row_at (matrix&amp;lt;unknown&gt; , int) ---&gt; list&amp;lt;unknown&gt;  Result:​ returns the row at a num_line (right-hand operand) Examples:​ list&amp;lt;unknown&gt; var0 &lt;- matrix([[&quot;el11&quot;,&quot;el12&quot;,&quot;el13&quot;],[&quot;el21&quot;,&quot;el22&quot;,&quot;el23&quot;],[&quot;el31&quot;,&quot;el32&quot;,&quot;el33&quot;]]) row_at 2; // var0 equals [&quot;el13&quot;,&quot;el23&quot;,&quot;el33&quot;]  See also: column_at, columns_list,  "},{"title":"rows_list​","type":1,"pageTitle":"Operators (N to R)","url":"wiki/OperatorsNR#rows_list","content":"Possible uses:​ rows_list (matrix&amp;lt;unknown&gt;) ---&gt; list&amp;lt;list&amp;lt;unknown&gt;&gt;  Result:​ returns a list of the rows of the matrix, with each row as a list of elements Examples:​ list&amp;lt;list&amp;lt;unknown&gt;&gt; var0 &lt;- rows_list(matrix([[&quot;el11&quot;,&quot;el12&quot;,&quot;el13&quot;],[&quot;el21&quot;,&quot;el22&quot;,&quot;el23&quot;],[&quot;el31&quot;,&quot;el32&quot;,&quot;el33&quot;]])); // var0 equals [[&quot;el11&quot;,&quot;el21&quot;,&quot;el31&quot;],[&quot;el12&quot;,&quot;el22&quot;,&quot;el32&quot;],[&quot;el13&quot;,&quot;el23&quot;,&quot;el33&quot;]]  See also: columns_list, "},{"title":"Optimizing Models","type":0,"sectionRef":"#","url":"wiki/OptimizingModels","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Optimizing Models","url":"wiki/OptimizingModels#table-of-contents","content":"BenchmarkingSchedulingGrid Optimization Facets use_regular_agentsuse_individual_shapes Operators List operators first_withwhere / count Spatial operators container of agents in closest_to, at_distance, overlapping, insideAccelerate with a first spatial filtering Displays shapecircle vs square / sphere vs cubeOpenGL refresh facets "},{"title":"Benchmarking​","type":1,"pageTitle":"Optimizing Models","url":"wiki/OptimizingModels#benchmarking","content":"In order to optimize a model, it is important to exactly know which part of the model take times. It is thus possible to benchmark the global execution of the model using the benchmark facet of the experiment statement: it will produce a global report on the number of times any keyword has been used and how long has been spent to execute them. experiment Benchmarking type: gui benchmark: true { }  benchmark is also a statement that can be used on a block of codes to evaluate its execution. In addition, it provides the possibility to run the block of code several times to get more accurate results. global { init { create people number: 300; } reflex neighboorhood { benchmark &quot;Benchmark of closest_to operator&quot; repeat: 100 { ask people { do get_closest_people; } } } }  Finally the manual way to evaluate the execution of a code could be using the machine_time built-in global variable that gives the current time in milliseconds. Then to compute the time taken by a statement, a possible way is to write: float t &lt;- machine_time; // here a block of instructions that you consider as &quot;critical&quot; // ... write &quot;duration of the last instructions: &quot; + (machine_time - t);  "},{"title":"Scheduling​","type":1,"pageTitle":"Optimizing Models","url":"wiki/OptimizingModels#scheduling","content":"If you have a species of agents that, once created, are not supposed to do anything more (i.e. no behavior, no reflex, their actions triggered by other agents, their attributes being simply read and written by other agents), such as a &quot;data&quot; grid, or agents representing a &quot;background&quot; (from a shape file, etc.), consider using the schedules: [] facet on the definition of their species. This trick allows to tell GAMA to not schedule any of these agents. grid my_grid height: 100 width: 100 schedules: [] { ... }  The schedules facet is dynamically computed (even if the agents are not scheduled), so, if you happen to define agents that only need to be scheduled every x cycles, or depending on a condition, you can also write schedules to implement this. For instance, the following species will see its instances scheduled every 10 steps and only if a certain condition is met: species my_species schedules: (every 10) ? (condition ? my_species : []) : [] { ... }  In the same way, modelers can use the frequency facet to define when the agents of a species are going to be activated. By setting this facet to 0, the agents are never activated. species my_species frequency: 0 { ... }  "},{"title":"Grid​","type":1,"pageTitle":"Optimizing Models","url":"wiki/OptimizingModels#grid","content":""},{"title":"Optimization Facets​","type":1,"pageTitle":"Optimizing Models","url":"wiki/OptimizingModels#optimization-facets","content":"In this section, we present some facets that allow to optimize the use of grid (in particular in terms of memories). Note that all these facet can be combined (see the Life model from the Models library). use_regular_agents​ If false, then a special class of agents is used. This special class of agents used less memories but has some limitation: the agents cannot inherit from a &quot;normal&quot; species, they cannot have sub-populations, their name cannot be modified, etc. grid cell width: 50 height: 50 use_regular_agents: false ;  use_individual_shapes​ If false, then only one geometry is used for all agents. This facet allows to gain a lot of memory, but should not be used if the geometries of the agents are often activated (for instance, by an aspect). grid cell width: 50 height: 50 use_individual_shapes: false ;  "},{"title":"Parallel execution​","type":1,"pageTitle":"Optimizing Models","url":"wiki/OptimizingModels#parallel-execution","content":"The grid statement can also specify whether the agents of the grid are computed in parallel, using the facet parallel. This could increase (depending on the computation) the execution time. "},{"title":"Operators​","type":1,"pageTitle":"Optimizing Models","url":"wiki/OptimizingModels#operators","content":""},{"title":"List operators​","type":1,"pageTitle":"Optimizing Models","url":"wiki/OptimizingModels#list-operators","content":"first_with​ It is sometimes necessary to randomly select an element of a list that verifies a given condition. Many modelers use the one\\_of and the where operators to do this: bug one_big_bug &lt;- one_of (bug where (each.size &gt; 10));  Whereas it is often more optimized to use the shuffle operator to shuffle the list, then the first\\_with operator to select the first element that verifies the condition: bug one_big_bug &lt;- shuffle(bug) first_with (each.size &gt; 10);  where / count​ It is quite common to want to count the number of elements of a list or a container that verify a condition. The obvious to do it is: int n &lt;- length(my_container where (each.size &gt; 10));  This will however create an intermediary list before counting it, and this operation can be time consuming if the number of elements is important. To alleviate this problem, GAMA includes an operator called count that will count the elements that verify the condition by iterating directly on the container (no useless list created): int n &lt;- my_container count (each.size &gt; 10);  "},{"title":"Spatial operators​","type":1,"pageTitle":"Optimizing Models","url":"wiki/OptimizingModels#spatial-operators","content":"container of agents in closest\\_to, at\\_distance, overlapping, inside​ Several spatial query operators (such as closest_to, at_distance, overlapping or inside) allow to restrict the agents being queried to a container of agents. For instance, one can write: agent closest_agent &lt;- a_container_containing_agents closest_to self;  This expression is formally equivalent to : agent closest_agent &lt;- a_container_containing_agent with_min_of (each distance_to self);  But it is much faster if your container is large, as it will query the agents using a spatial index (instead of browsing through the whole container). Note that in some cases, when you have a small number of agents, the first syntax will be faster. The same applies to the other operators. Now consider a very common case: you need to restrict the agents being queried, not to a container, but to a species (which, actually, acts as a container in most cases). For instance, you want to know which predator is the closest to the current agent. If we apply the pattern above, we would write: predator closest_predator &lt;- predator with_min_of (each distance_to self);  or predator closest_predator &lt;- list(predator) closest_to self;  But these two operators can be painfully slow if your species has many instances (even in the second form). In that case, always prefer using directly the species as the left member: predator closest_ predator &lt;- predator closest_to self;  Not only is the syntax clearer, but the speed gain can be phenomenal because, in that case, the list of instances is not used (we just check if the agent is an instance of the left species). However, what happens if one wants to query instances belonging to 2 or more species? If we follow our reasoning, the immediate way to write it would be (if predator 1 and predator 2 are two species): agent closest_agent &lt;- (list(predator1) + list(predator2)) closest_to self;  or, more simply: agent closest_agent &lt;- (predator1 + predator2) closest_to self;  The first syntax suffers from the same problem than the previous syntax: GAMA has to browse through the list (created by the concatenation of the species populations) to filter agents. The solution, then, is again to use directly the species, as GAMA is clever enough to create a temporary &quot;fake&quot; population out of the concatenation of several species, which can be used exactly like a list of agents, but provides the advantages of a species population (no iteration made during filtering). Accelerate closest_to with a first spatial filtering​ The closest_to operator can sometimes be slow if numerous agents are concerned by this query. If the modeler is just interested in a small subset of agents, it is possible to apply a first spatial filtering on the agent list by using the at_distance operator. For example, if the modeler wants first to do a spatial filtering of 10m: agent closest_agent &lt;- (predator1 at_distance 10) closest_to self;  To be sure to find an agent, the modeler can use a test statement: agent closest_agent &lt;- (predator1 at_distance 10) closest_to self; if (closest_agent = nil) {closest_agent &lt;- predator1 closest_to self;}  "},{"title":"Displays​","type":1,"pageTitle":"Optimizing Models","url":"wiki/OptimizingModels#displays","content":""},{"title":"shape​","type":1,"pageTitle":"Optimizing Models","url":"wiki/OptimizingModels#shape","content":"It is quite common to want to display an agent as a circle or a square. A common mistake is to mix up the shape to draw and the geometry of the agent in the model. If the modeler just wants to display a particular shape, he/she should not modify the agent geometry (i.e. its shape attribute, which is a point by default), but just specify the shape to draw in the agent aspect. species bug { int size &lt;- rnd(100); aspect circle { draw circle(2) color: #blue; } }  "},{"title":"circle vs square / sphere vs cube​","type":1,"pageTitle":"Optimizing Models","url":"wiki/OptimizingModels#circle-vs-square--sphere-vs-cube","content":"Note that in OpenGL and Java2D (the two rendering subsystems used in GAMA), creating and drawing a circle geometry is more time consuming than creating and drawing a square (or a rectangle). In the same way, drawing a sphere is more time consuming than drawing a cube. Hence, if you want to optimize your model displays and if the rendering does not explicitly need &quot;rounded&quot; agents, try to use squares/cubes rather than circles/spheres. "},{"title":"OpenGL refresh facets​","type":1,"pageTitle":"Optimizing Models","url":"wiki/OptimizingModels#opengl-refresh-facets","content":"In OpenGL display, it is possible to specify that it is not necessary to refresh a layer with the facet refresh. If a species of agents is never modified in terms of visualization (location, shape or color), you can set refresh to false. Example: display city_display_opengl type: opengl{ species building aspect: base refresh: false; species road aspect: base refresh: false; species people aspect: base; }  "},{"title":"Optimizing Models","type":0,"sectionRef":"#","url":"wiki/OptimizingModelsSection","content":"Optimizing Models Now you are becoming more comfortable with GAML, it is time to think about how the runtime works, to be able to run some more optimized models. Indeed, if you already tried to write some models by yourself using GAML, you could have noticed that the execution time depends a lot of how you implemented your model! We will first present you in this part some runtime concepts (and present you the species facet scheduler), and we will then show you some tips to optimize your models (how to increase performances using scheduler, grids, displays and how to choose your operators).","keywords":""},{"title":"Introduction","type":0,"sectionRef":"#","url":"wiki/Overview","content":"","keywords":""},{"title":"Documentation​","type":1,"pageTitle":"Introduction","url":"wiki/Overview#documentation","content":"The documentation of GAMA is available online on the wiki of the project. It is organized around a few central activities (installing GAMA, writing models, running experiments, developing new extensions to the platform) and provides complete references on both the GAML language, the platform itself, and the scientific aspects of our work (with a complete bibliography). Several tutorials are also provided in the documentation in order to minimize the learning curve, allowing users to build, step by step, the models corresponding to these tutorials, which are of course shipped with the platform. The documentation can be accessed from the sidebar of this page. A good starting point for new users is the installation page. A standalone version of the documentation, in PDF format, can be directly downloaded here "},{"title":"Source Code​","type":1,"pageTitle":"Introduction","url":"wiki/Overview#source-code","content":"GAMA can be downloaded as a regular application or built from source, which is necessary if you want to contribute to the platform. The source code is available from this GITHub repository: https://github.com/gama-platform/gama  Which you can also browse from the web here. It is, in any case, recommended to follow the instructions on this page in order to build GAMA from source. "},{"title":"Copyright Information​","type":1,"pageTitle":"Introduction","url":"wiki/Overview#copyright-information","content":"This is a free software (distributed under the GNU GPL v3 license), so you can have access to the code, edit it and redistribute it under the same terms. Independently of the licensing issues, if you plan on reusing part of our code, we would be glad to know it ! "},{"title":"Developers​","type":1,"pageTitle":"Introduction","url":"wiki/Overview#developers","content":"GAMA is being designed, developed and maintained by an active group of researchers coming from different institutions in France and Vietnam. Please find below a short introduction to each of them and a summary of their contributions to the platform: Alexis Drogoul, Senior Researcher at the IRD, member of the UMMISCO International Research Unit. Mostly working on agent-based modeling and simulation. Has contributed and still contributes to the original design of the platform, including the GAML language (from the meta-model to the editor) and simulation facilities like Java2D displays.Patrick Taillandier, Senior Researcher at INRAE, member of the MIAT Research Unit. Contributes since 2008 to the spatial and graph features (GIS integration, spatial operators), graphical modeling, human behavior modeling, model exploration and traffic simulation. Benoit Gaudou, Associate Professor at the University Toulouse 1 Capitole, member of the IRIT CNRS Mixed Research Unit. Contributes since 2010 to documentation and unit test generation and coupling mathematical (ODE and PDE) and agent paradigms.Arnaud Grignard, Computer Scientist at Université de Lyon as a Marie Curie Fellowship and research associate at the MIT Media Lab CityScience, software engineer and PhD fellow (PDI-MSC) at SU. Contributes since 2011 to the development of new features related to visualization, interaction, online analysis and tangible interfaces.Huynh Quang Nghi, software engineering lecturer at CTU and PhD fellow (PDI-MSC) at SU. Contributes since 2012 to the development of new features related to GAML parser, coupling formalisms in EBM-ABM and ABM-ABM.Truong Minh Thai, software engineering lecturer at CTU and PhD fellow (PRJ322-MOET) at IRIT-UT1. Contributes since 2012 to the development of new features related to data management and analysis.Nicolas Marilleau, Researcher at the IRD, member of the UMMISCO International Research Unit and associate researcher at DISC team of FEMTO-ST institute. Contributes since 2010 to the development of headless mode and the high performance computing module.Philippe Caillou, Associate professor at the University Paris Sud 11, member of the LRI and INRIA project-team TAO. Contributes since 2012 and actually working on charts, simulation analysis and BDI agents.Vo Duc An, Post-doctoral Researcher, working on synthetic population generation in agent-based modelling, at the UMMISCO International Research Unit of the IRD. Has contributed to bringing the platform to the Eclipse RCP environment and to the development of several features (e.g., the FIPA-compliant agent communication capability, the multi-level architecture).Truong Xuan Viet, software engineering lecturer at CTU and PhD fellow (PDI-MSC) at SU. Contributes since 2011 to the development of new features related to R caller, online GIS (OPENGIS: Web Map Service - WMS, Web Feature Services - WMS, Google map, etc).Jean-Daniel.Zucker, Senior Researcher at the IRD, member and director of the UMMISCO International Research Unit. Mostly working on Machine Learning and also optimization using agent-based modeling and simulation. Has contributed to different models and advised different students on GAMA since its beginning. "},{"title":"Citing GAMA​","type":1,"pageTitle":"Introduction","url":"wiki/Overview#citing-gama","content":"If you use GAMA in your research and want to cite it (in a paper, presentation, whatever), please use this reference: Taillandier, P., Gaudou, B., Grignard, A., Huynh, Q.N., Marilleau, N., Caillou, P., Philippon, D., Drogoul, A. (2018), Building, composing and experimenting complex spatial models with the GAMA platform. In Geoinformatica, Springer, https://doi.org/10.1007/s10707-018-00339-6. or you can choose to cite the website instead: GAMA Platform website, http://gama-platform.org A complete list of references (papers and PhD theses on or using GAMA) is available on the references page. "},{"title":"Contact Us​","type":1,"pageTitle":"Introduction","url":"wiki/Overview#contact-us","content":"To get in touch with the GAMA developers team, please sign in for the gama-platform@googlegroups.com mailing list. If you wish to contribute to the platform, you might want, instead or in addition, to sign in for the gama-dev@googlegroups.com mailing list. On both lists, we generally answer quite quickly to requests. Finally, to report bugs in GAMA or ask for a new feature, please refer to these instructions to do so.   This page is licensed under a Creative Commons Attribution 4.0 International License . "},{"title":"Parameters View","type":0,"sectionRef":"#","url":"wiki/ParametersView","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Parameters View","url":"wiki/ParametersView#table-of-contents","content":"Parameters View Parameters ViewModification of parameters values "},{"title":"Parameters View​","type":1,"pageTitle":"Parameters View","url":"wiki/ParametersView#parameters-view","content":"The modeler can define parameters that can be displayed in the GUI and that are sorted by categories. Note that the interface will depend on the data type of the parameter: e.g. for string parameters, a simple text box will be displayed whereas a color selector will be available for color parameters. It can also depend on the way the parameter is defined: an integer or a float parameter will be displayed with a slider if its min and max values are defined, and a simple text field otherwise. The parameter's value displayed is the initial value provided to the variables associated with the parameters in the model.  The above parameters view is generated from the following code: global { int i; float f; string s; list l; matrix m; pair p; rgb c; } experiment maths type: gui { parameter &quot;my_integer&quot; var: i &lt;- 0 category:&quot;Simple types&quot;; parameter &quot;my_float&quot; var: f &lt;- 0.0 category:&quot;Simple types&quot;; parameter &quot;my_string&quot; var: s &lt;- &quot;&quot; category:&quot;Simple types&quot;; parameter &quot;my_list&quot; var: l &lt;- [] category:&quot;Complex types&quot;; parameter &quot;my_matrix&quot; var: m &lt;- matrix([[1,2],[3,4]]) category:&quot;Complex types&quot;; parameter &quot;my_pair&quot; var: p &lt;- 3::5 category:&quot;Complex types&quot;; parameter &quot;my_color&quot; var: c &lt;- #green category:&quot;Complex types&quot;; output {} }  Click on Edit button in case of list or map parameters or the color or matrix will open an additional window to modify the parameter value. The model Library models &gt; Visualization and User Interaction &gt; GUI Design &gt; Interactive Elements.gaml exemplifies all the possible way of displaying parameters (and other interactive elements). Even interactive elements (buttons or parameters will a behavior associated with a value change) can be added to the Parameter View.  "},{"title":"Modification of parameters values​","type":1,"pageTitle":"Parameters View","url":"wiki/ParametersView#modification-of-parameters-values","content":"The modeler can modify the parameter values. After modifying the parameter values, you can reload the simulation by clicking on the top-right circular arrow button. It is important to understand that modification of a parameter value is immediately taken into account in the simulation: the value of the variable in the model is modified. BUT the effect on the simulation will depend on the use of this variable in the model: if the variable is used at initialization of the simulation (e.g. it contains the number of agents to be created), then a change of its value will not be visible in the simulation running as it is not used,if the variable is used during the simulation (e.g. the pheromones evaporation rate in ants models), a change in the parameter view will have an impact on the simulation behavior. You can also add a new simulation to the old one, using those new parameters, by clicking on the top-right plus symbol button. If he wants to come back to the initial value of parameters, he can click on the top-right red curved arrow of the parameters view.  "},{"title":"Operators (S to Z)","type":0,"sectionRef":"#","url":"wiki/OperatorsSZ","content":"","keywords":""},{"title":"Definition​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#definition","content":"Operators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function. Most of them use a classical prefixed functional syntax (i.e. operator_name(operand1, operand2, operand3), see below), with the exception of arithmetic (e.g. +, /), logical (and, or), comparison (e.g. &gt;, &lt;), access (., [..]) and pair (::) operators, which require an infixed notation (i.e. operand1 operator_symbol operand1). The ternary functional if-else operator, ? :, uses a special infixed syntax composed with two symbols (e.g. operand1 ? operand2 : operand3). Two unary operators (- and !) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g. - 10, ! (operand1 or operand2)). Finally, special constructor operators ({...} for constructing points, [...] for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. {1,2,3}, [operand1, operand2, ..., operandn] or [key1::value1, key2::value2... keyn::valuen]). With the exception of these special cases above, the following rules apply to the syntax of operators: if they only have one operand, the functional prefixed syntax is mandatory (e.g. operator_name(operand1))if they have two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2)) or the infixed syntax (e.g. operand1 operator_name operand2) can be used.if they have more than two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2, ..., operand)) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. operand1 operator_name(operand2, ..., operand)) can be used. All of these alternative syntaxes are completely equivalent. Operators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.  "},{"title":"Priority between operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#priority-between-operators","content":"The priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first. GAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely: the constructor operators, like ::, used to compose pairs of operands, have the lowest priority of all operators (e.g. a &gt; b :: b &gt; c will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, [a &gt; 10, b &gt; 5] will return a list of boolean values.it is followed by the ?: operator, the functional if-else (e.g. a &gt; b ? a + 10 : a - 10 will return the result of the if-else).next are the logical operators, and and or (e.g. a &gt; b or b &gt; c will return the value of the test)next are the comparison operators (i.e. &gt;, &lt;, &lt;=, &gt;=, =, !=)next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)next the unary operators - and !next the access operators . and [] (e.g. {1,2,3}.x &gt; 20 + {4,5,6}.y will return the result of the comparison between the x and y ordinates of the two points)and finally the functional operators, which have the highest priority of all.  "},{"title":"Using actions as operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#using-actions-as-operators","content":"Actions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand. For instance, if the following species is defined: species spec1 { int min(int x, int y) { return x &gt; y ? x : y; } }  Any agent instance of spec1 can use min as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable: global { init { create spec1; spec1 my_agent &lt;- spec1[0]; int the_min &lt;- my_agent min(10,20); // or min(my_agent, 10, 20); } }  If the action doesn't have any operands, the syntax to use is my_agent the_action(). Finally, if it does not return a value, it might still be used but is considering as returning a value of type unknown (e.g. unknown result &lt;- my_agent the_action(op1, op2);). Note that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).  "},{"title":"Table of Contents​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#table-of-contents","content":" "},{"title":"Operators by categories​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#operators-by-categories","content":" "},{"title":"3D​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#3d","content":"box, cone3D, cube, cylinder, hexagon, pyramid, set_z, sphere, teapot,  "},{"title":"Arithmetic operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#arithmetic-operators","content":"-, /, ^, *, +, abs, acos, asin, atan, atan2, ceil, cos, cos_rad, div, even, exp, fact, floor, hypot, is_finite, is_number, ln, log, mod, round, signum, sin, sin_rad, sqrt, tan, tan_rad, tanh, with_precision,  "},{"title":"BDI​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#bdi","content":"add_values, and, eval_when, get_about, get_agent, get_agent_cause, get_belief_op, get_belief_with_name_op, get_beliefs_op, get_beliefs_with_name_op, get_current_intention_op, get_decay, get_desire_op, get_desire_with_name_op, get_desires_op, get_desires_with_name_op, get_dominance, get_familiarity, get_ideal_op, get_ideal_with_name_op, get_ideals_op, get_ideals_with_name_op, get_intensity, get_intention_op, get_intention_with_name_op, get_intentions_op, get_intentions_with_name_op, get_lifetime, get_liking, get_modality, get_obligation_op, get_obligation_with_name_op, get_obligations_op, get_obligations_with_name_op, get_plan_name, get_predicate, get_solidarity, get_strength, get_super_intention, get_trust, get_truth, get_uncertainties_op, get_uncertainties_with_name_op, get_uncertainty_op, get_uncertainty_with_name_op, get_values, has_belief_op, has_belief_with_name_op, has_desire_op, has_desire_with_name_op, has_ideal_op, has_ideal_with_name_op, has_intention_op, has_intention_with_name_op, has_obligation_op, has_obligation_with_name_op, has_uncertainty_op, has_uncertainty_with_name_op, new_emotion, new_mental_state, new_predicate, new_social_link, not, or, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_lifetime, set_liking, set_modality, set_predicate, set_solidarity, set_strength, set_trust, set_truth, with_values,  "},{"title":"Casting operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#casting-operators","content":"as, as_int, as_matrix, font, is, is_skill, list_with, matrix_with, species, to_gaml, topology,  "},{"title":"Color-related operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#color-related-operators","content":"-, /, *, +, blend, brewer_colors, brewer_palettes, gradient, grayscale, hsb, mean, median, palette, rgb, rnd_color, scale, sum,  "},{"title":"Comparison operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#comparison-operators","content":"!=, &lt;, &lt;=, =, &gt;, &gt;=, between,  "},{"title":"Containers-related operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#containers-related-operators","content":"-, ::, +, accumulate, all_match, among, at, cartesian_product, collect, contains, contains_all, contains_any, contains_key, count, empty, every, first, first_with, get, group_by, in, index_by, inter, interleave, internal_integrated_value, last, last_with, length, max, max_of, mean, mean_of, median, min, min_of, mul, none_matches, one_matches, one_of, product_of, range, remove_duplicates, reverse, shuffle, sort_by, split, split_in, split_using, sum, sum_of, union, variance_of, where, with_max_of, with_min_of,  "},{"title":"Date-related operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#date-related-operators","content":"-, !=, +, &lt;, &lt;=, =, &gt;, &gt;=, after, before, between, every, milliseconds_between, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_weeks, minus_years, months_between, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_weeks, plus_years, since, to, until, years_between,  "},{"title":"Dates​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#dates","content":" "},{"title":"Displays​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#displays","content":"horizontal, stack, vertical,  "},{"title":"edge​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#edge","content":"edge_between, strahler,  "},{"title":"EDP-related operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#edp-related-operators","content":"diff, diff2,  "},{"title":"Files-related operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#files-related-operators","content":"copy_file, crs, csv_file, delete_file, dxf_file, evaluate_sub_model, file_exists, folder, folder_exists, gaml_file, geojson_file, get, gif_file, gml_file, graph6_file, graphdimacs_file, graphdot_file, graphgexf_file, graphgml_file, graphml_file, graphtsplib_file, grid_file, image_file, is_csv, is_dxf, is_gaml, is_geojson, is_gif, is_gml, is_graph6, is_graphdimacs, is_graphdot, is_graphgexf, is_graphgml, is_graphml, is_graphtsplib, is_grid, is_image, is_json, is_obj, is_osm, is_pgm, is_property, is_saved_simulation, is_shape, is_svg, is_text, is_threeds, is_xml, json_file, new_folder, obj_file, osm_file, pgm_file, property_file, read, rename_file, saved_simulation_file, shape_file, step_sub_model, svg_file, text_file, threeds_file, unzip, writable, xml_file, zip,  "},{"title":"FIPA-related operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#fipa-related-operators","content":"conversation, message,  "},{"title":"GamaMaterialType​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#gamamaterialtype","content":"material,  "},{"title":"GamaMetaType​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#gamametatype","content":"type_of,  "},{"title":"Gen*​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#gen","content":"add_attribute, add_census_file, add_mapper, add_marginals, add_range_attribute, with_generation_algo,  "},{"title":"Graphs-related operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#graphs-related-operators","content":"add_edge, add_node, adjacency, agent_from_geometry, all_pairs_shortest_path, alpha_index, as_distance_graph, as_edge_graph, as_intersection_graph, as_path, as_spatial_graph, beta_index, betweenness_centrality, biggest_cliques_of, connected_components_of, connectivity_index, contains_edge, contains_vertex, degree_of, directed, edge, edge_between, edge_betweenness, edges, gamma_index, generate_barabasi_albert, generate_complete_graph, generate_random_graph, generate_watts_strogatz, girvan_newman_clustering, grid_cells_to_graph, in_degree_of, in_edges_of, k_spanning_tree_clustering, label_propagation_clustering, layout_circle, layout_force, layout_force_FR, layout_force_FR_indexed, layout_grid, load_shortest_paths, main_connected_component, max_flow_between, maximal_cliques_of, nb_cycles, neighbors_of, node, nodes, out_degree_of, out_edges_of, path_between, paths_between, predecessors_of, remove_node_from, rewire_n, source_of, spatial_graph, strahler, successors_of, sum, target_of, undirected, use_cache, weight_of, with_k_shortest_path_algorithm, with_shortest_path_algorithm, with_weights,  "},{"title":"Grid-related operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#grid-related-operators","content":"as_4_grid, as_grid, as_hexagonal_grid, cell_at, cells_in, cells_overlapping, field, grid_at, neighbors_of, path_between, points_in, values_in,  "},{"title":"Iterator operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#iterator-operators","content":"accumulate, all_match, as_map, collect, count, create_map, first_with, frequency_of, group_by, index_by, last_with, max_of, mean_of, min_of, none_matches, one_matches, product_of, sort_by, sum_of, variance_of, where, where, where, with_max_of, with_min_of,  "},{"title":"List-related operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#list-related-operators","content":"all_indexes_of, copy_between, index_of, last_index_of,  "},{"title":"Logical operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#logical-operators","content":":, !, ?, add_3Dmodel, add_geometry, add_icon, and, or, xor,  "},{"title":"Map comparaison operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#map-comparaison-operators","content":"fuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,  "},{"title":"Map-related operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#map-related-operators","content":"as_map, create_map, index_of, last_index_of,  "},{"title":"Matrix-related operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#matrix-related-operators","content":"-, /, ., *, +, append_horizontally, append_vertically, column_at, columns_list, determinant, eigenvalues, index_of, inverse, last_index_of, row_at, rows_list, shuffle, trace, transpose,  "},{"title":"multicriteria operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#multicriteria-operators","content":"electre_DM, evidence_theory_DM, fuzzy_choquet_DM, promethee_DM, weighted_means_DM,  "},{"title":"Path-related operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#path-related-operators","content":"agent_from_geometry, all_pairs_shortest_path, as_path, load_shortest_paths, max_flow_between, path_between, path_to, paths_between, use_cache,  "},{"title":"Points-related operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#points-related-operators","content":"-, /, *, +, &lt;, &lt;=, &gt;, &gt;=, add_point, angle_between, any_location_in, centroid, closest_points_with, farthest_point_to, grid_at, norm, points_along, points_at, points_on,  "},{"title":"Random operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#random-operators","content":"binomial, flip, gamma_density, gamma_rnd, gamma_trunc_rnd, gauss, generate_terrain, lognormal_density, lognormal_rnd, lognormal_trunc_rnd, poisson, rnd, rnd_choice, sample, shuffle, skew_gauss, truncated_gauss, weibull_density, weibull_rnd, weibull_trunc_rnd,  "},{"title":"ReverseOperators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#reverseoperators","content":"restore_simulation, restore_simulation_from_file, save_simulation, serialize, serialize_agent,  "},{"title":"Shape​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#shape","content":"arc, box, circle, cone, cone3D, cross, cube, curve, cylinder, ellipse, elliptical_arc, envelope, geometry_collection, hexagon, line, link, plan, polygon, polyhedron, pyramid, rectangle, sphere, square, squircle, teapot, triangle,  "},{"title":"Spatial operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#spatial-operators","content":"-, *, +, add_point, agent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, angle_between, any_location_in, arc, around, as_4_grid, as_driving_graph, as_grid, as_hexagonal_grid, at_distance, at_location, box, centroid, circle, clean, clean_network, closest_points_with, closest_to, closest_tob, cone, cone3D, convex_hull, covering, covers, cross, crosses, crossing, crs, CRS_transform, cube, curve, cylinder, direction_between, disjoint_from, distance_between, distance_to, ellipse, elliptical_arc, envelope, farthest_point_to, farthest_to, geometry_collection, gini, hexagon, hierarchical_clustering, IDW, inside, inter, intersects, inverse_rotation, line, link, masked_by, moran, neighbors_at, neighbors_of, normalized_rotation, overlapping, overlaps, partially_overlapping, partially_overlaps, path_between, path_to, plan, points_along, points_at, points_on, polygon, polyhedron, pyramid, rectangle, rotated_by, rotation_composition, round, scaled_to, set_z, simple_clustering_by_distance, simplification, skeletonize, smooth, sphere, split_at, split_geometry, split_lines, square, squircle, teapot, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, touches, touching, towards, transformed_by, translated_by, triangle, triangulate, union, using, voronoi, with_precision, without_holes,  "},{"title":"Spatial properties operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#spatial-properties-operators","content":"covers, crosses, intersects, partially_overlaps, touches,  "},{"title":"Spatial queries operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#spatial-queries-operators","content":"agent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, at_distance, closest_to, covering, crossing, farthest_to, inside, neighbors_at, neighbors_of, overlapping, partially_overlapping, touching,  "},{"title":"Spatial relations operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#spatial-relations-operators","content":"direction_between, distance_between, distance_to, path_between, path_to, towards,  "},{"title":"Spatial statistical operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#spatial-statistical-operators","content":"hierarchical_clustering, simple_clustering_by_distance,  "},{"title":"Spatial transformations operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#spatial-transformations-operators","content":"-, *, +, as_4_grid, as_grid, as_hexagonal_grid, at_location, clean, clean_network, convex_hull, CRS_transform, inverse_rotation, normalized_rotation, rotated_by, rotation_composition, scaled_to, simplification, skeletonize, smooth, split_geometry, split_lines, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, transformed_by, translated_by, triangulate, voronoi, with_precision, without_holes,  "},{"title":"Species-related operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#species-related-operators","content":"index_of, last_index_of, of_generic_species, of_species,  "},{"title":"Statistical operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#statistical-operators","content":"auto_correlation, beta, binomial_coeff, binomial_complemented, binomial_sum, build, chi_square, chi_square_complemented, correlation, covariance, dbscan, distribution_of, distribution2d_of, dtw, durbin_watson, frequency_of, gamma, gamma_distribution, gamma_distribution_complemented, geometric_mean, gini, harmonic_mean, hierarchical_clustering, incomplete_beta, incomplete_gamma, incomplete_gamma_complement, kmeans, kurtosis, log_gamma, max, mean, mean_deviation, median, min, moment, moran, mul, normal_area, normal_density, normal_inverse, predict, pValue_for_fStat, pValue_for_tStat, quantile, quantile_inverse, rank_interpolated, rms, simple_clustering_by_distance, skewness, split, split_in, split_using, standard_deviation, student_area, student_t_inverse, sum, t_test, variance,  "},{"title":"Strings-related operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#strings-related-operators","content":"+, &lt;, &lt;=, &gt;, &gt;=, at, char, contains, contains_all, contains_any, copy_between, date, empty, first, in, indented_by, index_of, is_number, last, last_index_of, length, lower_case, regex_matches, replace, replace_regex, reverse, sample, shuffle, split_with, string, upper_case,  "},{"title":"SubModel​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#submodel","content":"load_sub_model,  "},{"title":"System​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#system","content":"., choose, command, copy, copy_to_clipboard, dead, enter, eval_gaml, every, is_error, is_reachable, is_warning, user_confirm, user_input_dialog, wizard, wizard_page,  "},{"title":"Time-related operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#time-related-operators","content":"date, string,  "},{"title":"Types-related operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#types-related-operators","content":"action, agent, attributes, BDIPlan, bool, container, directory, emotion, file, float, gaml_type, gen_population_generator, gen_range, geometry, graph, int, kml, list, map, matrix, mental_state, Norm, pair, path, point, predicate, regression, rgb, Sanction, skill, social_link, topology, unknown,  "},{"title":"User control operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#user-control-operators","content":"choose, enter, user_confirm, user_input_dialog, wizard, wizard_page,  "},{"title":"Operators​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#operators","content":" "},{"title":"sample​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#sample","content":"Possible uses:​ sample (any expression) ---&gt; stringstring sample any expression ---&gt; stringsample (string , any expression) ---&gt; stringsample (list, int, bool) ---&gt; listsample (list, int, bool, list) ---&gt; list  Result:​ takes a sample of the specified size from the elements of x using either with or without replacement with given weights takes a sample of the specified size from the elements of x using either with or without replacement Examples:​ list var0 &lt;- sample([2,10,1],2,false,[0.1,0.7,0.2]); // var0 equals [10,2] list var1 &lt;- sample([2,10,1],2,false); // var1 equals [10,1]   "},{"title":"Sanction​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#sanction","content":"Possible uses:​ Sanction (any) ---&gt; Sanction  Result:​ casts the operand in a Sanction object.  "},{"title":"save_simulation​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#save_simulation","content":"Possible uses:​ save_simulation (string) ---&gt; int  Result:​ saves the current simulation in a given file Comment:​ About to be deprecated, the save statement should be used instead.  "},{"title":"saved_simulation_file​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#saved_simulation_file","content":"Possible uses:​ saved_simulation_file (string) ---&gt; filestring saved_simulation_file list&amp;lt;agent&gt; ---&gt; filesaved_simulation_file (string , list&amp;lt;agent&gt;) ---&gt; filestring saved_simulation_file bool ---&gt; filesaved_simulation_file (string , bool) ---&gt; file  Result:​ Constructs a file of type saved_simulation. Allowed extensions are limited to gsim, gasim Special cases:​ saved_simulation_file(string): Constructor for saved simulation files: read the metadata and content. saved_simulation_file(string,list&lt;agent&gt;): Constructor for saved simulation files from a list of agents: it is used with aim of saving a simulation agent. saved_simulation_file(string,bool): Constructor for saved simulation files: read the metadata. If and only if the boolean operand is true, the content of the file is read.  See also: is_saved_simulation,  "},{"title":"scale​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#scale","content":"Possible uses:​ scale (map&amp;lt;rgb,unknown&gt;) ---&gt; map&amp;lt;float,rgb&gt;scale (map&amp;lt;rgb,unknown&gt;, float, float) ---&gt; map&amp;lt;float,rgb&gt;  Result:​ Expects a gradient, i.e. a map&lt;rgb,float&gt;, where values represent the different stops of the colors. First normalizes the passed gradient, and then applies the resulting weights to the interval represented by min and max, so as to return a scale (i.e. absolute values instead of the stops Similar to gradient(map&lt;rgb, float&gt;) but reorders the colors based on their weight and does not normalize them, so as to effectively represent a color scale (i.e. a correspondance between a range of value and a color that implicitly begins with the lowest value)For instance scale([#red::10, #green::0, #blue::30]) would produce the reverse map and associate #green to the interval 0-10, #red to 10-30, and #blue above 30. The main difference in usages is that, for instance in the definition of a mesh to display, a gradient will produce interpolated colors to accomodate for the intermediary values, while a scale will stick to the colors defined. See also: gradient,  "},{"title":"scaled_by​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#scaled_by","content":"Same signification as *  "},{"title":"scaled_to​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#scaled_to","content":"Possible uses:​ geometry scaled_to point ---&gt; geometryscaled_to (geometry , point) ---&gt; geometry  Result:​ allows to restrict the size of a geometry so that it fits in the envelope {width, height, depth} defined by the second operand Examples:​ geometry var0 &lt;- shape scaled_to {10,10}; // var0 equals a geometry corresponding to the geometry of the agent applying the operator scaled so that it fits a square of 10x10   "},{"title":"select​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#select","content":"Same signification as where  "},{"title":"serialize​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#serialize","content":"Possible uses:​ serialize (unknown) ---&gt; string  Result:​ It serializes any object, i.e.transforms it into a string. See also: serialize_agent,  "},{"title":"serialize_agent​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#serialize_agent","content":"Possible uses:​ serialize_agent (agent) ---&gt; string  Result:​ searializes an agent (i.e. transforms into a string value). Comment:​ As a simulation is a particular agent, it can be used to serialize a simulation and save it. See also: serialize,  "},{"title":"set_about​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#set_about","content":"Possible uses:​ emotion set_about predicate ---&gt; emotionset_about (emotion , predicate) ---&gt; emotion  Result:​ change the about value of the given emotion Examples:​ emotion set_about predicate1   "},{"title":"set_agent​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#set_agent","content":"Possible uses:​ social_link set_agent agent ---&gt; social_linkset_agent (social_link , agent) ---&gt; social_link  Result:​ change the agent value of the given social link Examples:​ social_link set_agent agentA   "},{"title":"set_agent_cause​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#set_agent_cause","content":"Possible uses:​ emotion set_agent_cause agent ---&gt; emotionset_agent_cause (emotion , agent) ---&gt; emotionpredicate set_agent_cause agent ---&gt; predicateset_agent_cause (predicate , agent) ---&gt; predicate  Result:​ change the agentCause value of the given emotion change the agentCause value of the given predicate Examples:​ new_emotion set_agent_cause agentA predicate set_agent_cause agentA   "},{"title":"set_decay​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#set_decay","content":"Possible uses:​ emotion set_decay float ---&gt; emotionset_decay (emotion , float) ---&gt; emotion  Result:​ change the decay value of the given emotion Examples:​ emotion set_decay 12   "},{"title":"set_dominance​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#set_dominance","content":"Possible uses:​ social_link set_dominance float ---&gt; social_linkset_dominance (social_link , float) ---&gt; social_link  Result:​ change the dominance value of the given social link Examples:​ social_link set_dominance 0.4   "},{"title":"set_familiarity​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#set_familiarity","content":"Possible uses:​ social_link set_familiarity float ---&gt; social_linkset_familiarity (social_link , float) ---&gt; social_link  Result:​ change the familiarity value of the given social link Examples:​ social_link set_familiarity 0.4   "},{"title":"set_intensity​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#set_intensity","content":"Possible uses:​ emotion set_intensity float ---&gt; emotionset_intensity (emotion , float) ---&gt; emotion  Result:​ change the intensity value of the given emotion Examples:​ emotion set_intensity 12   "},{"title":"set_lifetime​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#set_lifetime","content":"Possible uses:​ mental_state set_lifetime int ---&gt; mental_stateset_lifetime (mental_state , int) ---&gt; mental_state  Result:​ change the lifetime value of the given mental state Examples:​ mental state set_lifetime 1   "},{"title":"set_liking​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#set_liking","content":"Possible uses:​ social_link set_liking float ---&gt; social_linkset_liking (social_link , float) ---&gt; social_link  Result:​ change the liking value of the given social link Examples:​ social_link set_liking 0.4   "},{"title":"set_modality​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#set_modality","content":"Possible uses:​ mental_state set_modality string ---&gt; mental_stateset_modality (mental_state , string) ---&gt; mental_state  Result:​ change the modality value of the given mental state Examples:​ mental state set_modality belief   "},{"title":"set_predicate​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#set_predicate","content":"Possible uses:​ mental_state set_predicate predicate ---&gt; mental_stateset_predicate (mental_state , predicate) ---&gt; mental_state  Result:​ change the predicate value of the given mental state Examples:​ mental state set_predicate pred1   "},{"title":"set_solidarity​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#set_solidarity","content":"Possible uses:​ social_link set_solidarity float ---&gt; social_linkset_solidarity (social_link , float) ---&gt; social_link  Result:​ change the solidarity value of the given social link Examples:​ social_link set_solidarity 0.4   "},{"title":"set_strength​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#set_strength","content":"Possible uses:​ mental_state set_strength float ---&gt; mental_stateset_strength (mental_state , float) ---&gt; mental_state  Result:​ change the strength value of the given mental state Examples:​ mental state set_strength 1.0   "},{"title":"set_trust​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#set_trust","content":"Possible uses:​ social_link set_trust float ---&gt; social_linkset_trust (social_link , float) ---&gt; social_link  Result:​ change the trust value of the given social link Examples:​ social_link set_familiarity 0.4   "},{"title":"set_truth​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#set_truth","content":"Possible uses:​ predicate set_truth bool ---&gt; predicateset_truth (predicate , bool) ---&gt; predicate  Result:​ change the is_true value of the given predicate Examples:​ predicate set_truth false   "},{"title":"set_z​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#set_z","content":"Possible uses:​ geometry set_z container&amp;lt;unknown,float&gt; ---&gt; geometryset_z (geometry , container&amp;lt;unknown,float&gt;) ---&gt; geometryset_z (geometry, int, float) ---&gt; geometry  Result:​ Sets the z ordinate of the n-th point of a geometry to the value provided by the third argument Examples:​ set_z (triangle(3), 1, 3.0) triangle(3) set_z [5,10,14]   "},{"title":"shape_file​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#shape_file","content":"Possible uses:​ shape_file (string) ---&gt; filestring shape_file int ---&gt; fileshape_file (string , int) ---&gt; filestring shape_file string ---&gt; fileshape_file (string , string) ---&gt; filestring shape_file bool ---&gt; fileshape_file (string , bool) ---&gt; fileshape_file (string, int, bool) ---&gt; fileshape_file (string, string, bool) ---&gt; file  Result:​ Constructs a file of type shape. Allowed extensions are limited to shp Special cases:​ shape_file(string): This file constructor allows to read a shapefile (.shp) file  file f &lt;- shape_file(&quot;file.shp&quot;);  shape_file(string,int): This file constructor allows to read a shapefile (.shp) file and specifying the coordinates system code, as an int (epsg code)  file f &lt;- shape_file(&quot;file.shp&quot;, &quot;32648&quot;);  shape_file(string,string): This file constructor allows to read a shapefile (.shp) file and specifying the coordinates system code (epg,...,), as a string  file f &lt;- shape_file(&quot;file.shp&quot;, &quot;EPSG:32648&quot;);  shape_file(string,bool): This file constructor allows to read a shapefile (.shp) file and take a potential z value (not taken in account by default)  file f &lt;- shape_file(&quot;file.shp&quot;, true);  shape_file(string,int,bool): This file constructor allows to read a shapefile (.shp) file and specifying the coordinates system code, as an int (epsg code) and take a potential z value (not taken in account by default)  file f &lt;- shape_file(&quot;file.shp&quot;, &quot;32648&quot;, true);  shape_file(string,string,bool): This file constructor allows to read a shapefile (.shp) file and specifying the coordinates system code (epg,...,), as a string and take a potential z value (not taken in account by default)  file f &lt;- shape_file(&quot;file.shp&quot;, &quot;EPSG:32648&quot;,true);  See also: is_shape,  "},{"title":"shuffle​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#shuffle","content":"Possible uses:​ shuffle (string) ---&gt; stringshuffle (container) ---&gt; listshuffle (matrix) ---&gt; matrix  Result:​ The elements of the operand in random order. Special cases:​ if the operand is empty, returns an empty list (or string, matrix) Examples:​ string var0 &lt;- shuffle ('abc'); // var0 equals 'bac' (for example) list var1 &lt;- shuffle ([12, 13, 14]); // var1 equals [14,12,13] (for example) matrix var2 &lt;- shuffle (matrix([[&quot;c11&quot;,&quot;c12&quot;,&quot;c13&quot;],[&quot;c21&quot;,&quot;c22&quot;,&quot;c23&quot;]])); // var2 equals matrix([[&quot;c12&quot;,&quot;c21&quot;,&quot;c11&quot;],[&quot;c13&quot;,&quot;c22&quot;,&quot;c23&quot;]]) (for example)  See also: reverse,  "},{"title":"signum​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#signum","content":"Possible uses:​ signum (float) ---&gt; int  Result:​ Returns -1 if the argument is negative, +1 if it is positive, 0 if it is equal to zero or not a number Examples:​ int var0 &lt;- signum(-12); // var0 equals -1 int var1 &lt;- signum(14); // var1 equals 1 int var2 &lt;- signum(0); // var2 equals 0   "},{"title":"simple_clustering_by_distance​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#simple_clustering_by_distance","content":"Possible uses:​ container&amp;lt;unknown,agent&gt; simple_clustering_by_distance float ---&gt; list&amp;lt;list&amp;lt;agent&gt;&gt;simple_clustering_by_distance (container&amp;lt;unknown,agent&gt; , float) ---&gt; list&amp;lt;list&amp;lt;agent&gt;&gt;  Result:​ A list of agent groups clustered by distance considering a distance min between two groups. Examples:​ list&amp;lt;list&amp;lt;agent&gt;&gt; var0 &lt;- [ag1, ag2, ag3, ag4, ag5] simpleClusteringByDistance 20.0; // var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]  See also: hierarchical_clustering,  "},{"title":"simple_clustering_by_envelope_distance​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#simple_clustering_by_envelope_distance","content":"Same signification as simple_clustering_by_distance  "},{"title":"simplification​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#simplification","content":"Possible uses:​ geometry simplification float ---&gt; geometrysimplification (geometry , float) ---&gt; geometry  Result:​ A geometry corresponding to the simplification of the operand (geometry, agent, point) considering a tolerance distance. Comment:​ The algorithm used for the simplification is Douglas-Peucker Examples:​ geometry var0 &lt;- self simplification 0.1; // var0 equals the geometry resulting from the application of the Douglas-Peuker algorithm on the geometry of the agent applying the operator with a tolerance distance of 0.1.   "},{"title":"sin​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#sin","content":"Possible uses:​ sin (float) ---&gt; floatsin (int) ---&gt; float  Result:​ Returns the value (in [-1,1]) of the sinus of the operand (in decimal degrees). The argument is casted to an int before being evaluated. Special cases:​ Operand values out of the range [0-359] are normalized. Examples:​ float var0 &lt;- sin(360) with_precision 10 with_precision 10; // var0 equals 0.0 float var1 &lt;- sin (0); // var1 equals 0.0  See also: cos, tan,  "},{"title":"sin_rad​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#sin_rad","content":"Possible uses:​ sin_rad (float) ---&gt; float  Result:​ Returns the value (in [-1,1]) of the sinus of the operand (in radians). Examples:​ float var0 &lt;- sin_rad(0); // var0 equals 0.0 float var1 &lt;- sin_rad(#pi/2); // var1 equals 1.0  See also: cos_rad, tan_rad,  "},{"title":"since​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#since","content":"Possible uses:​ since (date) ---&gt; boolany expression since date ---&gt; boolsince (any expression , date) ---&gt; bool  Result:​ Returns true if the current_date of the model is after (or equal to) the date passed in argument. Synonym of 'current_date &gt;= argument'. Can be used, like 'after', in its composed form with 2 arguments to express the lowest boundary of the computation of a frequency. However, contrary to 'after', there is a subtle difference: the lowest boundary will be tested against the frequency as well Examples:​ reflex when: since(starting_date) {} // this reflex will always be run every(2#days) since (starting_date + 1#day) // the computation will return true 1 day after the starting date and every two days after this reference date   "},{"title":"skeletonize​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#skeletonize","content":"Possible uses:​ skeletonize (geometry) ---&gt; list&amp;lt;geometry&gt;geometry skeletonize float ---&gt; list&amp;lt;geometry&gt;skeletonize (geometry , float) ---&gt; list&amp;lt;geometry&gt;skeletonize (geometry, float, float) ---&gt; list&amp;lt;geometry&gt;skeletonize (geometry, float, float, bool) ---&gt; list&amp;lt;geometry&gt;  Result:​ A list of geometries (polylines) corresponding to the skeleton of the operand geometry (geometry, agent) Special cases:​ It can be used with 2 additional float operands: the tolerances for the clipping and for the triangulation It can be used with 1 additional float operand: the tolerance for the clipping. It can be used with 3 additional float operands: the tolerance for the clipping, the tolerance for the triangulation, and the approximation for the clipping. Examples:​ list&amp;lt;geometry&gt; var0 &lt;- skeletonize(self); // var0 equals the list of geometries corresponding to the skeleton of the geometry of the agent applying the operator.   "},{"title":"skew​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#skew","content":"Same signification as skewness  "},{"title":"skew_gauss​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#skew_gauss","content":"Possible uses:​ skew_gauss (float, float, float, float) ---&gt; float  Result:​ A value from a skew normally distributed random variable with min value (the minimum skewed value possible), max value (the maximum skewed value possible), skew (the degree to which the values cluster around the mode of the distribution; higher values mean tighter clustering) and bias (the tendency of the mode to approach the min, max or midpoint value; positive values bias toward max, negative values toward min).The algorithm was taken from http://stackoverflow.com/questions/5853187/skewing-java-random-number-generation-toward-a-certain-number Examples:​ float var0 &lt;- skew_gauss(0.0, 1.0, 0.7,0.1); // var0 equals 0.1729218460343077  See also: binomial, gamma_rnd, gauss_rnd, lognormal_rnd, poisson, rnd, truncated_gauss, weibull_rnd,  "},{"title":"skewness​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#skewness","content":"Possible uses:​ skewness (list) ---&gt; float  Result:​ returns skewness value computed from the operand list of values Special cases:​ if the length of the list is lower than 3, returns NaN Examples:​ float var0 &lt;- skewness ([1,2,3,4,5]); // var0 equals 0.0   "},{"title":"skill​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#skill","content":"Possible uses:​ skill (any) ---&gt; skill  Result:​ casts the operand in a skill object.  "},{"title":"smooth​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#smooth","content":"Possible uses:​ geometry smooth float ---&gt; geometrysmooth (geometry , float) ---&gt; geometry  Result:​ Returns a 'smoothed' geometry, where straight lines are replaces by polynomial (bicubic) curves. The first parameter is the original geometry, the second is the 'fit' parameter which can be in the range 0 (loose fit) to 1 (tightest fit). Examples:​ geometry var0 &lt;- smooth(square(10), 0.0); // var0 equals a 'rounded' square   "},{"title":"social_link​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#social_link","content":"Possible uses:​ social_link (any) ---&gt; social_link  Result:​ casts the operand in a social_link object.  "},{"title":"solid​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#solid","content":"Same signification as without_holes  "},{"title":"sort​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#sort","content":"Same signification as sort_by  "},{"title":"sort_by​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#sort_by","content":"Possible uses:​ container sort_by any expression ---&gt; listsort_by (container , any expression) ---&gt; list  Result:​ Returns a list, containing the elements of the left-hand operand sorted in ascending order by the value of the right-hand operand when it is evaluated on them. Comment:​ the left-hand operand is casted to a list before applying the operator. In the right-hand operand, the keyword each can be used to represent, in turn, each of the elements. Special cases:​ if the left-hand operand is nil, sort_by throws an error. If the sorting function returns values that cannot be compared, an error will be thrown as well Examples:​ list var0 &lt;- [1,2,4,3,5,7,6,8] sort_by (each); // var0 equals [1,2,3,4,5,6,7,8] list var2 &lt;- g2 sort_by (length(g2 out_edges_of each) ); // var2 equals [node9, node7, node10, node8, node11, node6, node5, node4] list var3 &lt;- (list(node) sort_by (round(node(each).location.x)); // var3 equals [node5, node1, node0, node2, node3] list var4 &lt;- [1::2, 5::6, 3::4] sort_by (each); // var4 equals [2, 4, 6]  See also: group_by,  "},{"title":"source_of​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#source_of","content":"Possible uses:​ graph source_of unknown ---&gt; unknownsource_of (graph , unknown) ---&gt; unknown  Result:​ returns the source of the edge (right-hand operand) contained in the graph given in left-hand operand. Special cases:​ if the lef-hand operand (the graph) is nil, throws an Exception Examples:​ graph graphEpidemio &lt;- generate_barabasi_albert( [&quot;edges_species&quot;::edge,&quot;vertices_specy&quot;::node,&quot;size&quot;::3,&quot;m&quot;::5] ); unknown var1 &lt;- graphEpidemio source_of(edge(3)); // var1 equals node1 graph graphFromMap &lt;- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); point var3 &lt;- graphFromMap source_of(link({1,5},{12,45})); // var3 equals {1,5}  See also: target_of,  "},{"title":"spatial_graph​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#spatial_graph","content":"Possible uses:​ spatial_graph (container) ---&gt; graph  Result:​ allows to create a spatial graph from a container of vertices, without trying to wire them. The container can be empty. Emits an error if the contents of the container are not geometries, points or agents See also: graph,  "},{"title":"species​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#species","content":"Possible uses:​ species (unknown) ---&gt; species  Result:​ casting of the operand to a species. Special cases:​ if the operand is nil, returns nil; if the operand is an agent, returns its species; if the operand is a string, returns the species with this name (nil if not found); otherwise, returns nil Examples:​ species var0 &lt;- species(self); // var0 equals the species of the current agent species var1 &lt;- species('node'); // var1 equals node species var2 &lt;- species([1,5,9,3]); // var2 equals nil species var3 &lt;- species(node1); // var3 equals node   "},{"title":"species_of​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#species_of","content":"Same signification as species  "},{"title":"sphere​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#sphere","content":"Possible uses:​ sphere (float) ---&gt; geometry  Result:​ A sphere geometry which radius is equal to the operand. Comment:​ the centre of the sphere is by default the location of the current agent in which has been called this operator. Special cases:​ returns a point if the operand is lower or equal to 0. Examples:​ geometry var0 &lt;- sphere(10); // var0 equals a geometry as a circle of radius 10 but displays a sphere.  See also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,  "},{"title":"split​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#split","content":"Possible uses:​ split (list&amp;lt;unknown&gt;) ---&gt; list&amp;lt;list&amp;lt;unknown&gt;&gt;  Result:​ Splits a list of numbers into n=(1+3.3*log10(elements)) bins. The splitting is strict (i.e. elements are in the ith bin if they are strictly smaller than the ith bound) Examples:​ list&amp;lt;list&amp;lt;unknown&gt;&gt; var0 &lt;- split([1.0,2.0,1.0,3.0,1.0,2.0]); // var0 equals [[1.0,1.0,1.0],[2.0,2.0],[3.0]]  See also: split_in, split_using,  "},{"title":"split_at​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#split_at","content":"Possible uses:​ geometry split_at point ---&gt; list&amp;lt;geometry&gt;split_at (geometry , point) ---&gt; list&amp;lt;geometry&gt;  Result:​ The two part of the left-operand lines split at the given right-operand point Special cases:​ if the left-operand is a point or a polygon, returns an empty list Examples:​ list&amp;lt;geometry&gt; var0 &lt;- polyline([{1,2},{4,6}]) split_at {7,6}; // var0 equals [polyline([{1.0,2.0},{7.0,6.0}]), polyline([{7.0,6.0},{4.0,6.0}])]   "},{"title":"split_geometry​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#split_geometry","content":"Possible uses:​ geometry split_geometry point ---&gt; list&amp;lt;geometry&gt;split_geometry (geometry , point) ---&gt; list&amp;lt;geometry&gt;geometry split_geometry float ---&gt; list&amp;lt;geometry&gt;split_geometry (geometry , float) ---&gt; list&amp;lt;geometry&gt;split_geometry (geometry, int, int) ---&gt; list&amp;lt;geometry&gt;  Result:​ A list of geometries that result from the decomposition of the geometry by square cells of the given side size (geometry, size). It can be used to split in rectangles by giving a point or 2 integer values as operand. Examples:​ list&amp;lt;geometry&gt; var0 &lt;- to_rectangles(self, {10.0, 15.0}); // var0 equals the list of the geometries corresponding to the decomposition of the geometry by rectangles of size 10.0, 15.0 list&amp;lt;geometry&gt; var1 &lt;- to_rectangles(self, 10,20); // var1 equals the list of the geometries corresponding to the decomposition of the geometry of the agent applying the operator list&amp;lt;geometry&gt; var2 &lt;- to_squares(self, 10.0); // var2 equals the list of the geometries corresponding to the decomposition of the geometry by squares of side size 10.0   "},{"title":"split_in​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#split_in","content":"Possible uses:​ list&amp;lt;unknown&gt; split_in int ---&gt; list&amp;lt;list&amp;lt;unknown&gt;&gt;split_in (list&amp;lt;unknown&gt; , int) ---&gt; list&amp;lt;list&amp;lt;unknown&gt;&gt;split_in (list&amp;lt;unknown&gt;, int, bool) ---&gt; list&amp;lt;list&amp;lt;unknown&gt;&gt;  Result:​ Splits a list of numbers into n bins defined by n-1 bounds between the minimum and maximum values found in the first argument. The splitting is strict (i.e. elements are in the ith bin if they are strictly smaller than the ith bound) Splits a list of numbers into n bins defined by n-1 bounds between the minimum and maximum values found in the first argument. The boolean argument controls whether or not the splitting is strict (if true, elements are in the ith bin if they are strictly smaller than the ith bound) Examples:​ list&amp;lt;float&gt; li &lt;- [1.0,3.1,5.2,6.0,9.2,11.1,12.0,13.0,19.9,35.9,40.0]; list&amp;lt;list&amp;lt;unknown&gt;&gt; var1 &lt;- split_in(li,3); // var1 equals [[1.0,3.1,5.2,6.0,9.2,11.1,12.0,13.0],[19.9],[35.9,40.0]] list&amp;lt;float&gt; l &lt;- [1.0,3.1,5.2,6.0,9.2,11.1,12.0,13.0,19.9,35.9,40.0]; list&amp;lt;list&amp;lt;unknown&gt;&gt; var3 &lt;- split_in(l,3, true); // var3 equals [[1.0,3.1,5.2,6.0,9.2,11.1,12.0,13.0],[19.9],[35.9,40.0]]  See also: split, split_using,  "},{"title":"split_lines​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#split_lines","content":"Possible uses:​ split_lines (container&amp;lt;unknown,geometry&gt;) ---&gt; list&amp;lt;geometry&gt;container&amp;lt;unknown,geometry&gt; split_lines bool ---&gt; list&amp;lt;geometry&gt;split_lines (container&amp;lt;unknown,geometry&gt; , bool) ---&gt; list&amp;lt;geometry&gt;  Result:​ A list of geometries resulting after cutting the lines at their intersections. A list of geometries resulting after cutting the lines at their intersections. if the last boolean operand is set to true, the split lines will import the attributes of the initial lines Examples:​ list&amp;lt;geometry&gt; var0 &lt;- split_lines([line([{0,10}, {20,10}]), line([{0,10}, {20,10}])]); // var0 equals a list of four polylines: line([{0,10}, {10,10}]), line([{10,10}, {20,10}]), line([{10,0}, {10,10}]) and line([{10,10}, {10,20}]) list&amp;lt;geometry&gt; var1 &lt;- split_lines([line([{0,10}, {20,10}]), line([{0,10}, {20,10}])]); // var1 equals a list of four polylines: line([{0,10}, {10,10}]), line([{10,10}, {20,10}]), line([{10,0}, {10,10}]) and line([{10,10}, {10,20}])   "},{"title":"split_using​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#split_using","content":"Possible uses:​ list&amp;lt;unknown&gt; split_using list&amp;lt;unknown&gt; ---&gt; list&amp;lt;list&amp;lt;unknown&gt;&gt;split_using (list&amp;lt;unknown&gt; , list&amp;lt;unknown&gt;) ---&gt; list&amp;lt;list&amp;lt;unknown&gt;&gt;split_using (list&amp;lt;unknown&gt;, list&amp;lt;unknown&gt;, bool) ---&gt; list&amp;lt;list&amp;lt;unknown&gt;&gt;  Result:​ Splits a list of numbers into n+1 bins using a set of n bounds passed as the second argument. The splitting is strict (i.e. elements are in the ith bin if they are strictly smaller than the ith bound), when no boolean attribute is specified. Examples:​ list&amp;lt;float&gt; li &lt;- [1.0,3.1,5.2,6.0,9.2,11.1,12.0,13.0,19.9,35.9,40.0]; list&amp;lt;list&amp;lt;unknown&gt;&gt; var1 &lt;- split_using(li,[1.0,3.0,4.2]); // var1 equals [[],[1.0],[3.1],[5.2,6.0,9.2,11.1,12.0,13.0,19.9,35.9,40.0]] list&amp;lt;float&gt; l &lt;- [1.0,3.1,5.2,6.0,9.2,11.1,12.0,13.0,19.9,35.9,40.0]; list&amp;lt;list&amp;lt;unknown&gt;&gt; var3 &lt;- split_using(l,[1.0,3.0,4.2], true); // var3 equals [[],[1.0],[3.1],[5.2,6.0,9.2,11.1,12.0,13.0,19.9,35.9,40.0]]  See also: split, split_in,  "},{"title":"split_with​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#split_with","content":"Possible uses:​ string split_with string ---&gt; listsplit_with (string , string) ---&gt; listsplit_with (string, string, bool) ---&gt; list  Result:​ Returns a list containing the sub-strings (tokens) of the left-hand operand delimited by each of the characters of the right-hand operand. Comment:​ Delimiters themselves are excluded from the resulting list. Special cases:​ when used with an additional boolean operand, it returns a list containing the sub-strings (tokens) of the left-hand operand delimited either by each of the characters of the right-hand operand (false) or by the whole right-hand operand (true). Examples:​ list var0 &lt;- 'to be or not to be,that is the question' split_with ' ,'; // var0 equals ['to','be','or','not','to','be','that','is','the','question'] list var1 &lt;- 'aa::bb:cc' split_with ('::', true); // var1 equals ['aa','bb:cc'] list var2 &lt;- 'aa::bb:cc' split_with ('::', false); // var2 equals ['aa','bb','cc']   "},{"title":"sqrt​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#sqrt","content":"Possible uses:​ sqrt (float) ---&gt; floatsqrt (int) ---&gt; float  Result:​ Returns the square root of the operand. Special cases:​ if the operand is negative, an exception is raised Examples:​ float var0 &lt;- sqrt(4); // var0 equals 2.0 float var1 &lt;- sqrt(4); // var1 equals 2.0   "},{"title":"square​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#square","content":"Possible uses:​ square (float) ---&gt; geometry  Result:​ A square geometry which side size is equal to the operand. Comment:​ the centre of the square is by default the location of the current agent in which has been called this operator. Special cases:​ returns nil if the operand is nil. Examples:​ geometry var0 &lt;- square(10); // var0 equals a geometry as a square of side size 10. float var1 &lt;- var0.area; // var1 equals 100.0  See also: around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, triangle,  "},{"title":"squircle​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#squircle","content":"Possible uses:​ float squircle float ---&gt; geometrysquircle (float , float) ---&gt; geometry  Result:​ A mix of square and circle geometry (see : http://en.wikipedia.org/wiki/Squircle), which side size is equal to the first operand and power is equal to the second operand Comment:​ the center of the ellipse is by default the location of the current agent in which has been called this operator. Special cases:​ returns a point if the side operand is lower or equal to 0. Examples:​ geometry var0 &lt;- squircle(4,4); // var0 equals a geometry as a squircle of side 4 with a power of 4.  See also: around, cone, line, link, norm, point, polygon, polyline, super_ellipse, rectangle, square, circle, ellipse, triangle,  "},{"title":"stack​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#stack","content":"Possible uses:​ stack (list&amp;lt;int&gt;) ---&gt; unknown&amp;lt;string&gt;  Result:​ Creates a stack layout node. Stacks can only contain one or several indices of displays (without weight)  "},{"title":"standard_deviation​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#standard_deviation","content":"Possible uses:​ standard_deviation (container) ---&gt; float  Result:​ the standard deviation on the elements of the operand. See Standard_deviation for more details. Comment:​ The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded. Examples:​ float var0 &lt;- standard_deviation ([4.5, 3.5, 5.5, 7.0]); // var0 equals 1.2930100540985752  See also: mean, mean_deviation,  "},{"title":"step_sub_model​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#step_sub_model","content":"Possible uses:​ step_sub_model (agent) ---&gt; int  Result:​ Load a submodel Comment:​ loaded submodel  "},{"title":"strahler​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#strahler","content":"Possible uses:​ strahler (graph) ---&gt; map  Result:​ retur for each edge, its strahler number  "},{"title":"string​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#string","content":"Possible uses:​ date string string ---&gt; stringstring (date , string) ---&gt; stringstring (date, string, string) ---&gt; string  Result:​ converts a date to astring following a custom pattern. The pattern can use &quot;%Y %M %N %D %E %h %m %s %z&quot; for outputting years, months, name of month, days, name of days, hours, minutes, seconds and the time-zone. A null or empty pattern will return the complete date as defined by the ISO date &amp; time format. The pattern can also follow the pattern definition found here, which gives much more control over the format of the date: https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns. Different patterns are available by default as constants: #iso_local, #iso_simple, #iso_offset, #iso_zoned and #custom, which can be changed in the preferences Examples:​ string(#now, 'yyyy-MM-dd', 'en') string(#now, 'yyyy-MM-dd')   "},{"title":"student_area​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#student_area","content":"Possible uses:​ float student_area int ---&gt; floatstudent_area (float , int) ---&gt; float  Result:​ Returns the area to the left of x in the Student T distribution with the given degrees of freedom. Examples:​ float var0 &lt;- student_area(1.64,3) with_precision(2); // var0 equals 0.9   "},{"title":"student_t_inverse​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#student_t_inverse","content":"Possible uses:​ float student_t_inverse int ---&gt; floatstudent_t_inverse (float , int) ---&gt; float  Result:​ Returns the value, t, for which the area under the Student-t probability density function (integrated from minus infinity to t) is equal to x. Examples:​ float var0 &lt;- student_t_inverse(0.9,3) with_precision(2); // var0 equals 1.64   "},{"title":"subtract_days​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#subtract_days","content":"Same signification as minus_days  "},{"title":"subtract_hours​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#subtract_hours","content":"Same signification as minus_hours  "},{"title":"subtract_minutes​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#subtract_minutes","content":"Same signification as minus_minutes  "},{"title":"subtract_months​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#subtract_months","content":"Same signification as minus_months  "},{"title":"subtract_ms​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#subtract_ms","content":"Same signification as minus_ms  "},{"title":"subtract_seconds​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#subtract_seconds","content":"Same signification as -  "},{"title":"subtract_weeks​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#subtract_weeks","content":"Same signification as minus_weeks  "},{"title":"subtract_years​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#subtract_years","content":"Same signification as minus_years  "},{"title":"successors_of​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#successors_of","content":"Possible uses:​ graph successors_of unknown ---&gt; listsuccessors_of (graph , unknown) ---&gt; list  Result:​ returns the list of successors (i.e. targets of out edges) of the given vertex (right-hand operand) in the given graph (left-hand operand) Examples:​ list var1 &lt;- graphEpidemio successors_of ({1,5}); // var1 equals [{12,45}] list var2 &lt;- graphEpidemio successors_of node({34,56}); // var2 equals []  See also: predecessors_of, neighbors_of,  "},{"title":"sum​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#sum","content":"Possible uses:​ sum (container) ---&gt; unknownsum (graph) ---&gt; float  Result:​ the sum of all the elements of the operand Comment:​ the behavior depends on the nature of the operand Special cases:​ if it is a population or a list of other types: sum transforms all elements into float and sums them if it is a map, sum returns the sum of the value of all elements if it is a file, sum returns the sum of the content of the file (that is also a container) if it is a graph, sum returns the total weight of the graph if it is a matrix of int, float or object, sum returns the sum of all the numerical elements (i.e. all elements for integer and float matrices) if it is a matrix of other types: sum transforms all elements into float and sums them if it is a list of colors: sum will sum them and return the blended resulting color if it is a list of int or float: sum returns the sum of all the elements  int var0 &lt;- sum ([12,10,3]); // var0 equals 25  if it is a list of points: sum returns the sum of all points as a point (each coordinate is the sum of the corresponding coordinate of each element)  unknown var1 &lt;- sum([{1.0,3.0},{3.0,5.0},{9.0,1.0},{7.0,8.0}]); // var1 equals {20.0,17.0}  See also: mul,  "},{"title":"sum_of​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#sum_of","content":"Possible uses:​ container sum_of any expression ---&gt; unknownsum_of (container , any expression) ---&gt; unknown  Result:​ the sum of the right-hand expression evaluated on each of the elements of the left-hand operand Comment:​ in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. Special cases:​ if the left-operand is a map, the keyword each will contain each value  unknown var1 &lt;- [1::2, 3::4, 5::6] sum_of (each + 3); // var1 equals 21  Examples:​ unknown var0 &lt;- [1,2] sum_of (each * 100 ); // var0 equals 300  See also: min_of, max_of, product_of, mean_of,  "},{"title":"svg_file​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#svg_file","content":"Possible uses:​ svg_file (string) ---&gt; filestring svg_file point ---&gt; filesvg_file (string , point) ---&gt; file  Result:​ Constructs a file of type svg. Allowed extensions are limited to svg Special cases:​ svg_file(string): This file constructor allows to read a svg file  file f &lt;-svg_file(&quot;file.svg&quot;);  svg_file(string,point): This file constructor allows to read a svg file, specifying the size of the bounding box  file f &lt;-svg_file(&quot;file.svg&quot;, {10,10});  See also: is_svg,  "},{"title":"t_test​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#t_test","content":"Possible uses:​ list t_test list ---&gt; floatt_test (list , list) ---&gt; float  Result:​ Returns the observed significance level, or p-value, associated with a two-sample, two-tailed t-test comparing the means of the two input lists.The number returned is the smallest significance level at which one can reject the null hypothesis Examples:​ float var0 &lt;- t_test([10.0,5.0,1.0, 3.0],[1.0,10.0,5.0,1.0]); // var0 equals 0.01   "},{"title":"tan​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#tan","content":"Possible uses:​ tan (int) ---&gt; floattan (float) ---&gt; float  Result:​ Returns the value (in [-1,1]) of the trigonometric tangent of the operand (in decimal degrees). Special cases:​ Operand values out of the range [0-359] are normalized. Notice that tan(360) does not return 0.0 but -2.4492935982947064E-16 The tangent is only defined for any real number except 90 + k * 180 (k an positive or negative integer). Nevertheless notice that tan(90) returns 1.633123935319537E16 (whereas we could except infinity). Examples:​ float var0 &lt;- tan (0); // var0 equals 0.0 float var1 &lt;- tan(90); // var1 equals 1.633123935319537E16  See also: cos, sin,  "},{"title":"tan_rad​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#tan_rad","content":"Possible uses:​ tan_rad (float) ---&gt; float  Result:​ Returns the value (in [-1,1]) of the trigonometric tangent of the operand (in radians). Examples:​ float var0 &lt;- tan_rad(0); // var0 equals 0.0  See also: cos_rad, sin_rad,  "},{"title":"tanh​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#tanh","content":"Possible uses:​ tanh (float) ---&gt; floattanh (int) ---&gt; float  Result:​ Returns the value (in the interval [-1,1]) of the hyperbolic tangent of the operand (which can be any real number, expressed in decimal degrees). Examples:​ float var0 &lt;- tanh(0); // var0 equals 0.0 float var1 &lt;- tanh(100); // var1 equals 1.0   "},{"title":"target_of​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#target_of","content":"Possible uses:​ graph target_of unknown ---&gt; unknowntarget_of (graph , unknown) ---&gt; unknown  Result:​ returns the target of the edge (right-hand operand) contained in the graph given in left-hand operand. Special cases:​ if the lef-hand operand (the graph) is nil, returns nil Examples:​ graph graphEpidemio &lt;- generate_barabasi_albert( [&quot;edges_species&quot;::edge,&quot;vertices_specy&quot;::node,&quot;size&quot;::3,&quot;m&quot;::5] ); unknown var1 &lt;- graphEpidemio source_of(edge(3)); // var1 equals node1 graph graphFromMap &lt;- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); unknown var3 &lt;- graphFromMap target_of(link({1,5},{12,45})); // var3 equals {12,45}  See also: source_of,  "},{"title":"teapot​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#teapot","content":"Possible uses:​ teapot (float) ---&gt; geometry  Result:​ A teapot geometry which radius is equal to the operand. Comment:​ the centre of the teapot is by default the location of the current agent in which has been called this operator. Special cases:​ returns a point if the operand is lower or equal to 0. Examples:​ geometry var0 &lt;- teapot(10); // var0 equals a geometry as a circle of radius 10 but displays a teapot.  See also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,  "},{"title":"text_file​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#text_file","content":"Possible uses:​ text_file (string) ---&gt; filestring text_file list&amp;lt;string&gt; ---&gt; filetext_file (string , list&amp;lt;string&gt;) ---&gt; file  Result:​ Constructs a file of type text. Allowed extensions are limited to txt, data, text Special cases:​ text_file(string): This file constructor allows to read a text file (.txt, .data, .text)  file f &lt;-text_file(&quot;file.txt&quot;);  text_file(string,list&lt;string&gt;): This file constructor allows to store a list of string in a text file (it does not save it - just store it in memory)  file f &lt;-text_file(&quot;file.txt&quot;, [&quot;item1&quot;,&quot;item2&quot;,&quot;item3&quot;]);  See also: is_text,  "},{"title":"TGauss​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#tgauss","content":"Same signification as truncated_gauss  "},{"title":"threeds_file​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#threeds_file","content":"Possible uses:​ threeds_file (string) ---&gt; file  Result:​ Constructs a file of type threeds. Allowed extensions are limited to 3ds, max Special cases:​ threeds_file(string): This file constructor allows to read a 3DS Max file. Only loads vertices and faces  threeds_file f &lt;- threeds_file(&quot;file&quot;);  See also: is_threeds,  "},{"title":"to​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#to","content":"Possible uses:​ date to date ---&gt; list&amp;lt;date&gt;to (date , date) ---&gt; list&amp;lt;date&gt;  Result:​ builds an interval between two dates (the first inclusive and the second exclusive, which behaves like a read-only list of dates. The default step between two dates is the step of the model Comment:​ The default step can be overruled by using the every operator applied to this interval Examples:​ date('2000-01-01') to date('2010-01-01') // builds an interval between these two dates (date('2000-01-01') to date('2010-01-01')) every (#month) // builds an interval between these two dates which contains all the monthly dates starting from the beginning of the interval  See also: every,  "},{"title":"to_GAMA_CRS​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#to_gama_crs","content":"Possible uses:​ to_GAMA_CRS (geometry) ---&gt; geometrygeometry to_GAMA_CRS string ---&gt; geometryto_GAMA_CRS (geometry , string) ---&gt; geometry Special cases:​ returns the geometry corresponding to the transformation of the given geometry to the GAMA CRS (Coordinate Reference System) assuming the given geometry is referenced by given CRS  geometry var0 &lt;- to_GAMA_CRS({121,14}, &quot;EPSG:4326&quot;); // var0 equals a geometry corresponding to the agent geometry transformed into the GAMA CRS  returns the geometry corresponding to the transformation of the given geometry to the GAMA CRS (Coordinate Reference System) assuming the given geometry is referenced by the current CRS, the one corresponding to the world's agent one  geometry var1 &lt;- to_GAMA_CRS({121,14}); // var1 equals a geometry corresponding to the agent geometry transformed into the GAMA CRS   "},{"title":"to_gaml​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#to_gaml","content":"Possible uses:​ to_gaml (unknown) ---&gt; string  Result:​ returns the literal description of an expression or description -- action, behavior, species, aspect, even model -- in gaml Examples:​ string var0 &lt;- to_gaml(0); // var0 equals '0' string var1 &lt;- to_gaml(3.78); // var1 equals '3.78' string var2 &lt;- to_gaml({23, 4.0}); // var2 equals '{23.0,4.0,0.0}' string var3 &lt;- to_gaml(rgb(255,0,125)); // var3 equals 'rgb (255, 0, 125,255)' string var4 &lt;- to_gaml('hello'); // var4 equals &quot;'hello'&quot; string var5 &lt;- to_gaml(a_graph); // var5 equals ([((1 as node)::(3 as node))::(5 as edge),((0 as node)::(3 as node))::(3 as edge),((1 as node)::(2 as node))::(1 as edge),((0 as node)::(2 as node))::(2 as edge),((0 as node)::(1 as node))::(0 as edge),((2 as node)::(3 as node))::(4 as edge)] as map ) as graph string var6 &lt;- to_gaml(node1); // var6 equals 1 as node   "},{"title":"to_rectangles​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#to_rectangles","content":"Same signification as split_geometry Possible uses:​ to_rectangles (geometry, point, bool) ---&gt; list&amp;lt;geometry&gt;to_rectangles (geometry, int, int, bool) ---&gt; list&amp;lt;geometry&gt;  Result:​ A list of rectangles of the size corresponding to the given dimension that result from the decomposition of the geometry into rectangles (geometry, dimension, overlaps), if overlaps = true, add the rectangles that overlap the border of the geometry Examples:​ list&amp;lt;geometry&gt; var0 &lt;- to_rectangles(self, 5, 20, true); // var0 equals the list of rectangles corresponding to the discretization by a grid of 5 columns and 20 rows into rectangles of the geometry of the agent applying the operator. The rectangles overlapping the border of the geometry are kept list&amp;lt;geometry&gt; var1 &lt;- to_rectangles(self, {10.0, 15.0}, true); // var1 equals the list of rectangles of size {10.0, 15.0} corresponding to the discretization into rectangles of the geometry of the agent applying the operator. The rectangles overlapping the border of the geometry are kept   "},{"title":"to_segments​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#to_segments","content":"Possible uses:​ to_segments (geometry) ---&gt; list&amp;lt;geometry&gt;  Result:​ A list of a segments resulting from the decomposition of the geometry (or its contours for polygons) into sgements Examples:​ list&amp;lt;geometry&gt; var0 &lt;- to_segments(line([{10,10},{80,10},{80,80}])); // var0 equals [line([{10,10},{80,10}]), line([{80,10},{80,80}])]   "},{"title":"to_squares​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#to_squares","content":"Possible uses:​ to_squares (geometry, float, bool) ---&gt; list&amp;lt;geometry&gt;to_squares (geometry, int, bool) ---&gt; list&amp;lt;geometry&gt;to_squares (geometry, int, bool, float) ---&gt; list&amp;lt;geometry&gt;  Result:​ A list of a given number of squares from the decomposition of the geometry into squares (geometry, nb_square, overlaps, precision_coefficient), if overlaps = true, add the squares that overlap the border of the geometry, coefficient_precision should be close to 1.0 A list of squares of the size corresponding to the given size that result from the decomposition of the geometry into squares (geometry, size, overlaps), if overlaps = true, add the squares that overlap the border of the geometry A list of a given number of squares from the decomposition of the geometry into squares (geometry, nb_square, overlaps), if overlaps = true, add the squares that overlap the border of the geometry Examples:​ list&amp;lt;geometry&gt; var0 &lt;- to_squares(self, 10, true, 0.99); // var0 equals the list of 10 squares corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept list&amp;lt;geometry&gt; var1 &lt;- to_squares(self, 10.0, true); // var1 equals the list of squares of side size 10.0 corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept list&amp;lt;geometry&gt; var2 &lt;- to_squares(self, 10, true); // var2 equals the list of 10 squares corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept   "},{"title":"to_sub_geometries​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#to_sub_geometries","content":"Possible uses:​ geometry to_sub_geometries list&amp;lt;float&gt; ---&gt; list&amp;lt;geometry&gt;to_sub_geometries (geometry , list&amp;lt;float&gt;) ---&gt; list&amp;lt;geometry&gt;to_sub_geometries (geometry, list&amp;lt;float&gt;, float) ---&gt; list&amp;lt;geometry&gt;  Result:​ A list of geometries resulting after spliting the geometry into sub-geometries. Examples:​ list&amp;lt;geometry&gt; var0 &lt;- to_sub_geometries(rectangle(10, 50), [0.1, 0.5, 0.4], 1.0); // var0 equals a list of three geometries corresponding to 3 sub-geometries using cubes of 1m size list&amp;lt;geometry&gt; var1 &lt;- to_sub_geometries(rectangle(10, 50), [0.1, 0.5, 0.4]); // var1 equals a list of three geometries corresponding to 3 sub-geometries   "},{"title":"to_triangles​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#to_triangles","content":"Same signification as triangulate  "},{"title":"tokenize​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#tokenize","content":"Same signification as split_with  "},{"title":"topology​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#topology","content":"Possible uses:​ topology (unknown) ---&gt; topology  Result:​ casting of the operand to a topology. Special cases:​ if the operand is a topology, returns the topology itself; if the operand is a spatial graph, returns the graph topology associated; if the operand is a population, returns the topology of the population; if the operand is a shape or a geometry, returns the continuous topology bounded by the geometry; if the operand is a matrix, returns the grid topology associated if the operand is another kind of container, returns the multiple topology associated to the container otherwise, casts the operand to a geometry and build a topology from it. Examples:​ topology var0 &lt;- topology(0); // var0 equals nil topology(a_graph) --: Multiple topology in POLYGON ((24.712119771887785 7.867357373616512, 24.712119771887785 61.283226839310565, 82.4013676510046 7.867357373616512)) at location[53.556743711446195;34.57529210646354]  See also: geometry,  "},{"title":"topology​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#topology-1","content":"Possible uses:​ topology (any) ---&gt; topology  Result:​ casts the operand in a topology object.  "},{"title":"touches​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#touches","content":"Possible uses:​ geometry touches geometry ---&gt; booltouches (geometry , geometry) ---&gt; bool  Result:​ A boolean, equal to true if the left-geometry (or agent/point) touches the right-geometry (or agent/point). Comment:​ returns true when the left-operand only touches the right-operand. When one geometry covers partially (or fully) the other one, it returns false. Special cases:​ if one of the operand is null, returns false. Examples:​ bool var0 &lt;- {15,15} touches {15,15}; // var0 equals false bool var1 &lt;- polyline([{10,10},{20,20}]) touches {10,10}; // var1 equals true bool var2 &lt;- polyline([{10,10},{20,20}]) touches polyline([{10,10},{5,5}]); // var2 equals true bool var3 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{15,15},{15,25},{25,25},{25,15}]); // var3 equals false bool var4 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) touches {10,15}; // var4 equals true  See also: disjoint_from, crosses, overlaps, partially_overlaps, intersects,  "},{"title":"touching​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#touching","content":"Possible uses:​ container&amp;lt;unknown,geometry&gt; touching geometry ---&gt; list&amp;lt;geometry&gt;touching (container&amp;lt;unknown,geometry&gt; , geometry) ---&gt; list&amp;lt;geometry&gt;  Result:​ A list of agents or geometries among the left-operand list, species or meta-population (addition of species), touching the operand (casted as a geometry). Examples:​ list&amp;lt;geometry&gt; var0 &lt;- [ag1, ag2, ag3] toucing(self); // var0 equals the agents among ag1, ag2 and ag3 that touch the shape of the right-hand argument. list&amp;lt;geometry&gt; var1 &lt;- (species1 + species2) touching (self); // var1 equals the agents among species species1 and species2 that touch the shape of the right-hand argument.  See also: neighbors_at, neighbors_of, closest_to, overlapping, agents_overlapping, inside, agents_inside, agent_closest_to,  "},{"title":"towards​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#towards","content":"Possible uses:​ geometry towards geometry ---&gt; floattowards (geometry , geometry) ---&gt; float  Result:​ The direction (in degree) between the two geometries (geometries, agents, points) considering the topology of the agent applying the operator. Examples:​ float var0 &lt;- ag1 towards ag2; // var0 equals the direction between ag1 and ag2 and ag3 considering the topology of the agent applying the operator  See also: distance_between, distance_to, direction_between, path_between, path_to,  "},{"title":"trace​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#trace","content":"Possible uses:​ trace (matrix) ---&gt; float  Result:​ The trace of the given matrix (the sum of the elements on the main diagonal). Examples:​ float var0 &lt;- trace(matrix([[1,2],[3,4]])); // var0 equals 5   "},{"title":"transformed_by​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#transformed_by","content":"Possible uses:​ geometry transformed_by point ---&gt; geometrytransformed_by (geometry , point) ---&gt; geometry  Result:​ A geometry resulting from the application of a rotation and a scaling (right-operand : point {angle(degree), scale factor} of the left-hand operand (geometry, agent, point) Examples:​ geometry var0 &lt;- self transformed_by {45, 0.5}; // var0 equals the geometry resulting from 45 degrees rotation and 50% scaling of the geometry of the agent applying the operator.  See also: rotated_by, translated_by,  "},{"title":"translated_by​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#translated_by","content":"Possible uses:​ geometry translated_by point ---&gt; geometrytranslated_by (geometry , point) ---&gt; geometry  Result:​ A geometry resulting from the application of a translation by the right-hand operand distance to the left-hand operand (geometry, agent, point) Examples:​ geometry var0 &lt;- self translated_by {10,10,10}; // var0 equals the geometry resulting from applying the translation to the left-hand geometry (or agent).  See also: rotated_by, transformed_by,  "},{"title":"translated_to​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#translated_to","content":"Same signification as at_location  "},{"title":"transpose​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#transpose","content":"Possible uses:​ transpose (matrix) ---&gt; matrix  Result:​ The transposition of the given matrix Examples:​ matrix var0 &lt;- transpose(matrix([[5,-3],[6,-4]])); // var0 equals matrix([[5,6],[-3,-4]])   "},{"title":"triangle​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#triangle","content":"Possible uses:​ triangle (float) ---&gt; geometryfloat triangle float ---&gt; geometrytriangle (float , float) ---&gt; geometry  Result:​ A triangle geometry which side size is given by the operand. A triangle geometry which the base and height size are given by the operand. Comment:​ the center of the triangle is by default the location of the current agent in which has been called this operator.the center of the triangle is by default the location of the current agent in which has been called this operator. Special cases:​ returns nil if the operand is nil. returns nil if one of the operand is nil. Examples:​ geometry var0 &lt;- triangle(5); // var0 equals a geometry as a triangle with side_size = 5. geometry var1 &lt;- triangle(5, 10); // var1 equals a geometry as a triangle with a base of 5m and a height of 10m.  See also: around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, square,  "},{"title":"triangulate​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#triangulate","content":"Possible uses:​ triangulate (list&amp;lt;geometry&gt;) ---&gt; list&amp;lt;geometry&gt;triangulate (geometry) ---&gt; list&amp;lt;geometry&gt;geometry triangulate float ---&gt; list&amp;lt;geometry&gt;triangulate (geometry , float) ---&gt; list&amp;lt;geometry&gt;triangulate (geometry, float, float) ---&gt; list&amp;lt;geometry&gt;triangulate (geometry, float, float, bool) ---&gt; list&amp;lt;geometry&gt;  Result:​ A list of geometries (triangles) corresponding to the Delaunay triangulation computed from the list of polylines A list of geometries (triangles) corresponding to the Delaunay triangulation of the operand geometry (geometry, agent, point, use_approx_clipping) with the given tolerance for the clipping and for the triangulation with using an approximate clipping is the last operand is true A list of geometries (triangles) corresponding to the Delaunay triangulation of the operand geometry (geometry, agent, point) A list of geometries (triangles) corresponding to the Delaunay triangulation of the operand geometry (geometry, agent, point) with the given tolerance for the clipping A list of geometries (triangles) corresponding to the Delaunay triangulation of the operand geometry (geometry, agent, point) with the given tolerance for the clipping and for the triangulation Examples:​ list&amp;lt;geometry&gt; var0 &lt;- triangulate([line([{0,50},{100,50}]), line([{50,0},{50,100}])); // var0 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator. list&amp;lt;geometry&gt; var1 &lt;- triangulate(self,0.1, 1.0, true); // var1 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator. list&amp;lt;geometry&gt; var2 &lt;- triangulate(self); // var2 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator. list&amp;lt;geometry&gt; var3 &lt;- triangulate(self, 0.1); // var3 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator. list&amp;lt;geometry&gt; var4 &lt;- triangulate(self,0.1, 1.0); // var4 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator.   "},{"title":"truncated_gauss​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#truncated_gauss","content":"Possible uses:​ truncated_gauss (list) ---&gt; floattruncated_gauss (point) ---&gt; float  Result:​ A random value from a normally distributed random variable in the interval ]mean - standardDeviation; mean + standardDeviation[. Special cases:​ if the operand is a list, only the two first elements are taken into account as [mean, standardDeviation] when truncated_gauss is called with a list of only one element mean, it will always return 0.0 when the operand is a point, it is read as {mean, standardDeviation} Examples:​ float var0 &lt;- truncated_gauss ([0.5, 0.0]); // var0 equals 0.5 float var1 &lt;- truncated_gauss ({0, 0.3}); // var1 equals a float between -0.3 and 0.3  See also: binomial, gamma_rnd, gauss_rnd, lognormal_rnd, poisson, rnd, skew_gauss, weibull_rnd, gamma_trunc_rnd, weibull_trunc_rnd, lognormal_trunc_rnd,  "},{"title":"type_of​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#type_of","content":"Possible uses:​ type_of (unknown) ---&gt; any GAML type&amp;lt;unknown&gt;  Result:​ Returns the GAML type of the operand Examples:​ string var0 &lt;- string(type_of(&quot;a string&quot;)); // var0 equals &quot;string&quot; string var1 &lt;- string(type_of([1,2,3,4,5])); // var1 equals &quot;list&amp;lt;int&gt;&quot; geometry g0 &lt;- to_GAMA_CRS({121,14}, &quot;EPSG:4326&quot;); string var3 &lt;- string(type_of(g0)); // var3 equals &quot;point&quot;   "},{"title":"undirected​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#undirected","content":"Possible uses:​ undirected (graph) ---&gt; graph  Result:​ the operand graph becomes an undirected graph. Comment:​ WARNING / side effect: this operator modifies the operand and does not create a new graph. See also: directed,  "},{"title":"union​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#union","content":"Same signification as + Possible uses:​ union (container&amp;lt;unknown,geometry&gt;) ---&gt; geometrycontainer union container ---&gt; listunion (container , container) ---&gt; list  Result:​ returns a new list containing all the elements of both containers without duplicated elements. Special cases:​ if the left or right operand is nil, union throws an error if the right-operand is a container of points, geometries or agents, returns the geometry resulting from the union all the geometries Examples:​ list var0 &lt;- [1,2,3,4,5,6] union [2,4,9]; // var0 equals [1,2,3,4,5,6,9] list var1 &lt;- [1,2,3,4,5,6] union [0,8]; // var1 equals [1,2,3,4,5,6,0,8] list var2 &lt;- [1,3,2,4,5,6,8,5,6] union [0,8]; // var2 equals [1,3,2,4,5,6,8,0] geometry var3 &lt;- union([geom1, geom2, geom3]); // var3 equals a geometry corresponding to union between geom1, geom2 and geom3  See also: inter, +,  "},{"title":"unknown​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#unknown","content":"Possible uses:​ unknown (any) ---&gt; unknown  Result:​ casts the operand in a unknown object.  "},{"title":"until​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#until","content":"Possible uses:​ until (date) ---&gt; boolany expression until date ---&gt; booluntil (any expression , date) ---&gt; bool  Result:​ Returns true if the current_date of the model is before (or equel to) the date passed in argument. Synonym of 'current_date &lt;= argument' Examples:​ reflex when: until(starting_date) {} // This reflex will be run only once at the beginning of the simulation   "},{"title":"unzip​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#unzip","content":"Possible uses:​ string unzip string ---&gt; boolunzip (string , string) ---&gt; bool  Result:​ Unzip a given zip file into a given folder. Returns true if the file is well unzipped Examples:​ bool unzip_ok &lt;- unzip([&quot;../includes/my_folder&quot;], &quot;folder.zip&quot;;   "},{"title":"upper_case​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#upper_case","content":"Possible uses:​ upper_case (string) ---&gt; string  Result:​ Converts all of the characters in the string operand to upper case Examples:​ string var0 &lt;- upper_case(&quot;Abc&quot;); // var0 equals 'ABC'  See also: lower_case,  "},{"title":"use_cache​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#use_cache","content":"Possible uses:​ graph use_cache bool ---&gt; graphuse_cache (graph , bool) ---&gt; graph  Result:​ if the second operand is true, the operand graph will store in a cache all the previously computed shortest path (the cache be cleared if the graph is modified). Comment:​ WARNING / side effect: this operator modifies the operand and does not create a new graph. See also: path_between,  "},{"title":"user_confirm​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#user_confirm","content":"Possible uses:​ string user_confirm string ---&gt; booluser_confirm (string , string) ---&gt; bool  Result:​ Asks the user to confirm a choice. The two string are used to specify the title and the message of the dialog box. Examples:​ bool confirm &lt;- user_confirm(&quot;Confirm&quot;,&quot;Please confirm&quot;;   "},{"title":"user_input_dialog​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#user_input_dialog","content":"Possible uses:​ user_input_dialog (list) ---&gt; map&amp;lt;string,unknown&gt;string user_input_dialog list ---&gt; map&amp;lt;string,unknown&gt;user_input_dialog (string , list) ---&gt; map&amp;lt;string,unknown&gt;user_input_dialog (string, list, font) ---&gt; map&amp;lt;string,unknown&gt;user_input_dialog (string, list, font, rgb) ---&gt; map&amp;lt;string,unknown&gt;  Result:​ Asks the user for some values and returns a map containing these values. Takes a string and a list of calls to the enter() or choose() operators as arguments. The string is used to specify the message of the dialog box. The list is used to specify the parameters the user can enter. Finally, the font of the title can be specified Asks the user for some values and returns a map containing these values. Takes a string and a list of calls to the enter() or choose() operators as arguments. The string is used to specify the message of the dialog box. The list is used to specify the parameters the user can enter. Finally, the font of the title can be specified Asks the user for some values and returns a map containing these values. Takes a string and a list of calls to the enter() or choose() operators as arguments. The string is used to specify the message of the dialog box. The list is to specify the parameters the user can enter Examples:​ map&amp;lt;string,unknown&gt; values2 &lt;- user_input_dialog('Enter number of agents and locations',[enter('Number',100), enter('Location',point, {10, 10})], font('Helvetica', 18)); create bug number: int(values2 at &quot;Number&quot;) with: [location:: (point(values2 at &quot;Location&quot;))]; map&amp;lt;string,unknown&gt; values_no_title &lt;- user_input_dialog([enter('Number',100), enter('Location',point, {10, 10})]); create bug number: int(values2 at &quot;Number&quot;) with: [location:: (point(values2 at &quot;Location&quot;))]; map&amp;lt;string,unknown&gt; values2 &lt;- user_input_dialog('Enter number of agents and locations',[enter('Number',100), enter('Location',point, {10, 10})], font('Helvetica', 18)); create bug number: int(values2 at &quot;Number&quot;) with: [location:: (point(values2 at &quot;Location&quot;))]; map&amp;lt;string,unknown&gt; values2 &lt;- user_input_dialog('Enter number of agents and locations',[enter('Number',100), enter('Location',point, {10, 10})]); create bug number: int(values2 at &quot;Number&quot;) with: [location:: (point(values2 at &quot;Location&quot;))];   "},{"title":"using​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#using","content":"Possible uses:​ any expression using topology ---&gt; unknownusing (any expression , topology) ---&gt; unknown  Result:​ Allows to specify in which topology a spatial computation should take place. Special cases:​ has no effect if the topology passed as a parameter is nil Examples:​ unknown var0 &lt;- (agents closest_to self) using topology(world); // var0 equals the closest agent to self (the caller) in the continuous topology of the world   "},{"title":"values_in​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#values_in","content":"Possible uses:​ field values_in geometry ---&gt; list&amp;lt;float&gt;values_in (field , geometry) ---&gt; list&amp;lt;float&gt;  "},{"title":"variance​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#variance","content":"Possible uses:​ variance (container) ---&gt; floatvariance (float) ---&gt; floatvariance (int, float, float) ---&gt; float  Result:​ Returns the variance of a data sequence. That is (sumOfSquares - mean*sum) / size with mean = sum/size. the variance of the elements of the operand. See Variance for more details. Returns the variance from a standard deviation. Comment:​ In the example we consider variance of [1,3,5,7]. The size is 4, the sum is 1+3+5+7=16 and the sum of squares is 84.The variance is (84- 16^2/4)/4. CQFD.The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded. Examples:​ int var0 &lt;- int(variance(4,16,84)); // var0 equals 5 float var1 &lt;- variance ([4.5, 3.5, 5.5, 7.0]); // var1 equals 1.671875 int var2 &lt;- int(variance([1,3,5,6,9,11,12,13])); // var2 equals 17  See also: mean, median,  "},{"title":"variance_of​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#variance_of","content":"Possible uses:​ container variance_of any expression ---&gt; unknownvariance_of (container , any expression) ---&gt; unknown  Result:​ the variance of the right-hand expression evaluated on each of the elements of the left-hand operand Comment:​ in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. Examples:​ float var0 &lt;- [1,2,3,4,5,6] variance_of each with_precision 2; // var0 equals 2.92  See also: min_of, max_of, sum_of, product_of,  "},{"title":"vertical​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#vertical","content":"Possible uses:​ vertical (map&amp;lt;unknown,int&gt;) ---&gt; unknown&amp;lt;string&gt;  Result:​ Creates a vertical layout node (a sash). Sashes can contain any number (&gt; 1) of other elements: stacks, horizontal or vertical sashes, or display indices. Each element is represented by a pair in the map, where the key is the element and the value its weight within the sash  "},{"title":"voronoi​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#voronoi","content":"Possible uses:​ voronoi (list&amp;lt;point&gt;) ---&gt; list&amp;lt;geometry&gt;list&amp;lt;point&gt; voronoi geometry ---&gt; list&amp;lt;geometry&gt;voronoi (list&amp;lt;point&gt; , geometry) ---&gt; list&amp;lt;geometry&gt;  Result:​ A list of geometries corresponding to the Voronoi diagram built from the list of points (with eventually a given clip). Examples:​ list&amp;lt;geometry&gt; var0 &lt;- voronoi([{10,10},{50,50},{90,90},{10,90},{90,10}]); // var0 equals the list of geometries corresponding to the Voronoi Diagram built from the list of points. list&amp;lt;geometry&gt; var1 &lt;- voronoi([{10,10},{50,50},{90,90},{10,90},{90,10}], square(300)); // var1 equals the list of geometries corresponding to the Voronoi Diagram built from the list of points with a square of 300m side size as clip.   "},{"title":"weibull_density​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#weibull_density","content":"Possible uses:​ weibull_density (float, float, float) ---&gt; float  Result:​ weibull_density(x,shape,scale) returns the probability density function (PDF) at the specified point x of the Weibull distribution with the given shape and scale. Examples:​ float var0 &lt;- weibull_rnd(1,2,3) ; // var0 equals 0.731  See also: binomial, gamma_rnd, gauss_rnd, lognormal_rnd, poisson, rnd, skew_gauss, lognormal_density, gamma_density,  "},{"title":"weibull_rnd​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#weibull_rnd","content":"Possible uses:​ float weibull_rnd float ---&gt; floatweibull_rnd (float , float) ---&gt; float  Result:​ returns a random value from a Weibull distribution with specified values of the shape (alpha) and scale (beta) parameters. See https://mathworld.wolfram.com/WeibullDistribution.html for more details (equations 1 and 2). Examples:​ float var0 &lt;- weibull_rnd(2,3) ; // var0 equals 0.731  See also: binomial, gamma_rnd, gauss_rnd, lognormal_rnd, poisson, rnd, skew_gauss, truncated_gauss, weibull_trunc_rnd,  "},{"title":"weibull_trunc_rnd​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#weibull_trunc_rnd","content":"Possible uses:​ weibull_trunc_rnd (float, float, float, bool) ---&gt; floatweibull_trunc_rnd (float, float, float, float) ---&gt; float  Result:​ returns a random value from a truncated Weibull distribution (in a range or given only one boundary) with specified values of the shape (alpha) and scale (beta) parameters. See https://mathworld.wolfram.com/WeibullDistribution.html for more details (equations 1 and 2). Special cases:​ when 1 float and a boolean (isMax) operands are specified, the float value represents the single boundary (max if the boolean is true, min otherwise),  weibull_trunc_rnd(2,3,5,true)  when 2 float operands are specified, they are taken as mininimum and maximum values for the result  weibull_trunc_rnd(2,3,0.0,5.0)  See also: weibull_rnd, gamma_trunc_rnd, lognormal_trunc_rnd, truncated_gauss,  "},{"title":"weight_of​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#weight_of","content":"Possible uses:​ graph weight_of unknown ---&gt; floatweight_of (graph , unknown) ---&gt; float  Result:​ returns the weight of the given edge (right-hand operand) contained in the graph given in right-hand operand. Comment:​ In a localized graph, an edge has a weight by default (the distance between both vertices). Special cases:​ if the left-operand (the graph) is nil, returns nil if the right-hand operand is not an edge of the given graph, weight_of checks whether it is a node of the graph and tries to return its weight if the right-hand operand is neither a node, nor an edge, returns 1. Examples:​ graph graphFromMap &lt;- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); float var1 &lt;- graphFromMap weight_of(link({1,5},{12,45})); // var1 equals 1.0   "},{"title":"weighted_means_DM​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#weighted_means_dm","content":"Possible uses:​ list&amp;lt;list&gt; weighted_means_DM list&amp;lt;map&amp;lt;string,unknown&gt;&gt; ---&gt; intweighted_means_DM (list&amp;lt;list&gt; , list&amp;lt;map&amp;lt;string,unknown&gt;&gt;) ---&gt; int  Result:​ The index of the candidate that maximizes the weighted mean of its criterion values. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion (list of map) Special cases:​ returns -1 is the list of candidates is nil or empty Examples:​ int var0 &lt;- weighted_means_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[&quot;name&quot;::&quot;utility&quot;, &quot;weight&quot; :: 2.0],[&quot;name&quot;::&quot;price&quot;, &quot;weight&quot; :: 1.0]]); // var0 equals 1  See also: promethee_DM, electre_DM, evidence_theory_DM,  "},{"title":"where​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#where","content":"Possible uses:​ list where any expression ---&gt; listwhere (list , any expression) ---&gt; listcontainer where any expression ---&gt; listwhere (container , any expression) ---&gt; listspecies where any expression ---&gt; listwhere (species , any expression) ---&gt; list  Result:​ a list containing all the elements of the left-hand operand that make the right-hand operand evaluate to true. Comment:​ in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. Special cases:​ if the left-hand operand is nil, where throws an error if the left-operand is a map, the keyword each will contain each value  list var4 &lt;- [1::2, 3::4, 5::6] where (each &gt;= 4); // var4 equals [4, 6]  Examples:​ list var0 &lt;- [1,2,3,4,5,6,7,8] where (each &gt; 3); // var0 equals [4, 5, 6, 7, 8] list var2 &lt;- g2 where (length(g2 out_edges_of each) = 0 ); // var2 equals [node9, node7, node10, node8, node11] list var3 &lt;- (list(node) where (round(node(each).location.x) &gt; 32); // var3 equals [node2, node3]  See also: first_with, last_with,  "},{"title":"with_generation_algo​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#with_generation_algo","content":"Possible uses:​ gen_population_generator with_generation_algo string ---&gt; gen_population_generatorwith_generation_algo (gen_population_generator , string) ---&gt; gen_population_generator  Result:​ define the algorithm used for the population generation among: IS (independant hypothesis Algorothm) and simple_draw (simple draw of entities in a sample) Examples:​ my_pop_generator with_generation_algo &quot;simple_draw&quot;   "},{"title":"with_k_shortest_path_algorithm​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#with_k_shortest_path_algorithm","content":"Possible uses:​ graph with_k_shortest_path_algorithm string ---&gt; graphwith_k_shortest_path_algorithm (graph , string) ---&gt; graph  Result:​ changes the K shortest paths computation algorithm of the given graph Comment:​ the right-hand operand can be Yen, Bhandari, Eppstein, Suurballe to use the associated algorithm. Examples:​ graphEpidemio &lt;- graphEpidemio with_optimizer_type &quot;static&quot;;   "},{"title":"with_max_of​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#with_max_of","content":"Possible uses:​ container with_max_of any expression ---&gt; unknownwith_max_of (container , any expression) ---&gt; unknown  Result:​ one of elements of the left-hand operand that maximizes the value of the right-hand operand Comment:​ in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. Special cases:​ if the left-hand operand is nil, with_max_of returns the default value of the right-hand operand Examples:​ unknown var0 &lt;- [1,2,3,4,5,6,7,8] with_max_of (each ); // var0 equals 8 unknown var2 &lt;- g2 with_max_of (length(g2 out_edges_of each) ) ; // var2 equals node4 unknown var3 &lt;- (list(node) with_max_of (round(node(each).location.x)); // var3 equals node3 unknown var4 &lt;- [1::2, 3::4, 5::6] with_max_of (each); // var4 equals 6  See also: where, with_min_of,  "},{"title":"with_min_of​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#with_min_of","content":"Possible uses:​ container with_min_of any expression ---&gt; unknownwith_min_of (container , any expression) ---&gt; unknown  Result:​ one of elements of the left-hand operand that minimizes the value of the right-hand operand Comment:​ in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. Special cases:​ if the left-hand operand is nil, with_max_of returns the default value of the right-hand operand Examples:​ unknown var0 &lt;- [1,2,3,4,5,6,7,8] with_min_of (each ); // var0 equals 1 unknown var2 &lt;- g2 with_min_of (length(g2 out_edges_of each) ); // var2 equals node11 unknown var3 &lt;- (list(node) with_min_of (round(node(each).location.x)); // var3 equals node0 unknown var4 &lt;- [1::2, 3::4, 5::6] with_min_of (each); // var4 equals 2  See also: where, with_max_of,  "},{"title":"with_precision​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#with_precision","content":"Possible uses:​ float with_precision int ---&gt; floatwith_precision (float , int) ---&gt; floatpoint with_precision int ---&gt; pointwith_precision (point , int) ---&gt; pointgeometry with_precision int ---&gt; geometrywith_precision (geometry , int) ---&gt; geometry  Result:​ Rounds off the value of left-hand operand to the precision given by the value of right-hand operand Rounds off the ordinates of the left-hand point to the precision given by the value of right-hand operand A geometry corresponding to the rounding of points of the operand considering a given precison. Examples:​ float var0 &lt;- 12345.78943 with_precision 2; // var0 equals 12345.79 float var1 &lt;- 123 with_precision 2; // var1 equals 123.00 point var2 &lt;- {12345.78943, 12345.78943, 12345.78943} with_precision 2 ; // var2 equals {12345.79, 12345.79, 12345.79} geometry var3 &lt;- self with_precision 2; // var3 equals the geometry resulting from the rounding of points of the geometry with a precision of 0.1.  See also: round,  "},{"title":"with_shortest_path_algorithm​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#with_shortest_path_algorithm","content":"Possible uses:​ graph with_shortest_path_algorithm string ---&gt; graphwith_shortest_path_algorithm (graph , string) ---&gt; graph  Result:​ changes the shortest path computation algorithm of the given graph Comment:​ the right-hand operand can be Djikstra, BidirectionalDijkstra, BellmannFord, FloydWarshall, Astar, NBAStar, NBAStarApprox, DeltaStepping, CHBidirectionalDijkstra, TransitNodeRouting to use the associated algorithm. Examples:​ road_network &lt;- road_network with_shortestpath_algorithm TransitNodeRouting;   "},{"title":"with_values​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#with_values","content":"Possible uses:​ predicate with_values map ---&gt; predicatewith_values (predicate , map) ---&gt; predicate  Result:​ change the parameters of the given predicate Examples:​ predicate with_values [&quot;time&quot;::10]   "},{"title":"with_weights​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#with_weights","content":"Possible uses:​ graph with_weights map ---&gt; graphwith_weights (graph , map) ---&gt; graphgraph with_weights list ---&gt; graphwith_weights (graph , list) ---&gt; graph  Result:​ returns the graph (left-hand operand) with weight given in the map (right-hand operand). Comment:​ WARNING / side effect: this operator modifies the operand and does not create a new graph. It also re-initializes the path finder Special cases:​ if the right-hand operand is a list, assigns the n elements of the list to the n first edges. Note that the ordering of edges may change overtime, which can create some problems... if the left-hand operand is a map, the map should contains pairs such as: vertex/edge::double  graph_from_edges (list(ant) as_map each::one_of (list(ant))) with_weights (list(ant) as_map each::each.food)   "},{"title":"without_holes​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#without_holes","content":"Possible uses:​ without_holes (geometry) ---&gt; geometry  Result:​ A geometry corresponding to the operand geometry (geometry, agent, point) without its holes Examples:​ geometry var0 &lt;- solid(self); // var0 equals the geometry corresponding to the geometry of the agent applying the operator without its holes. float var1 &lt;- without_holes(polygon([{0,50}, {0,0}, {50,0}, {50,50}, {0,50}]) - square(10) at_location {10,10}).area; // var1 equals 2500.0   "},{"title":"wizard​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#wizard","content":"Possible uses:​ string wizard list&amp;lt;map&amp;lt;string,unknown&gt;&gt; ---&gt; map&amp;lt;string,map&amp;lt;string,unknown&gt;&gt;wizard (string , list&amp;lt;map&amp;lt;string,unknown&gt;&gt;) ---&gt; map&amp;lt;string,map&amp;lt;string,unknown&gt;&gt;wizard (string, action, list&amp;lt;map&amp;lt;string,unknown&gt;&gt;) ---&gt; map&amp;lt;string,map&amp;lt;string,unknown&gt;&gt;  Result:​ Build a wizard and return the values enter by the user as a map of map [&quot;title page 1&quot;::[&quot;var1&quot;::1,&quot;var2&quot;::2]]. Takes a string, a list of calls to the wizard_page() operator. The first string is used to specify the title. The list is to specify the wizard pages. Build a wizard and return the values enter by the user as a map of map [&quot;title page 1&quot;::[&quot;var1&quot;::1,&quot;var2&quot;::2]]. Takes a string, an action and a list of calls to the wizard_page() operator. The first string is used to specify the title. The action to describe when the wizard is supposed to be finished. A classic way of defining the action is bool eval_finish(map&lt;string,map&gt; input_map) {return input_map[&quot;page1&quot;][&quot;file&quot;] != nil;}. The list is to specify the wizard pages. Examples:​ map results &lt;- wizard(&quot;My wizard&quot;,[wizard_page(&quot;page1&quot;,&quot;enter info&quot; ,[enter(&quot;var1&quot;,string)], font(&quot;Arial&quot;, 10))]); map results &lt;- wizard(&quot;My wizard&quot;,eval_finish, [wizard_page(&quot;page1&quot;,&quot;enter info&quot; ,[enter(&quot;var1&quot;,string)], font(&quot;Arial&quot;, 10))]);   "},{"title":"wizard_page​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#wizard_page","content":"Possible uses:​ wizard_page (string, string, list) ---&gt; map&amp;lt;string,unknown&gt;wizard_page (string, string, list, font) ---&gt; map&amp;lt;string,unknown&gt;  Result:​ Build a wizard page. Takes two strings and a list of calls to the enter() or choose() operators. The first string is used to specify the title, the second the description of the dialog box. The list is to specify the parameters the user can enter Build a wizard page. Takes two strings, a list of calls to the enter() or choose() operators and a font as arguments. The first string is used to specify the title, the second the description of the dialog box. The list is to specify the parameters the user can enter. The font is used to specify the font Examples:​ map results &lt;- wizard(&quot;My wizard&quot;,[wizard_page(&quot;page1&quot;,&quot;enter info&quot; ,[enter(&quot;var1&quot;,string)])]); map results &lt;- wizard(&quot;My wizard&quot;,[wizard_page(&quot;page1&quot;,&quot;enter info&quot; ,[enter(&quot;var1&quot;,string)], font(&quot;Arial&quot;, 10))]);   "},{"title":"writable​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#writable","content":"Possible uses:​ file writable bool ---&gt; filewritable (file , bool) ---&gt; file  Result:​ Marks the file as read-only or not, depending on the second boolean argument, and returns the first argument Comment:​ A file is created using its native flags. This operator can change them. Beware that this change is system-wide (and not only restrained to GAMA): changing a file to read-only mode (e.g. &quot;writable(f, false)&quot;) Examples:​ file var0 &lt;- shape_file(&quot;../images/point_eau.shp&quot;) writable false; // var0 equals returns a file in read-only mode  See also: file,  "},{"title":"xml_file​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#xml_file","content":"Possible uses:​ xml_file (string) ---&gt; file  Result:​ Constructs a file of type xml. Allowed extensions are limited to xml Special cases:​ xml_file(string): This file constructor allows to read a xml file  file f &lt;-xml_file(&quot;file.xml&quot;);  See also: is_xml,  "},{"title":"xor​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#xor","content":"Possible uses:​ bool xor bool ---&gt; boolxor (bool , bool) ---&gt; bool  Result:​ a bool value, equal to the logical xor between the left-hand operand and the right-hand operand. False when they are equal Comment:​ both operands are always casted to bool before applying the operator. Thus, an expression like 1 xor 0 is accepted and returns true. Examples:​ bool var0 &lt;- xor(true,false); // var0 equals true bool var1 &lt;- xor(false,false); // var1 equals false bool var2 &lt;- xor(false,true); // var2 equals true bool var3 &lt;- xor(true,true); // var3 equals false bool var4 &lt;- true xor true; // var4 equals false  See also: or, and, !,  "},{"title":"years_between​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#years_between","content":"Possible uses:​ date years_between date ---&gt; intyears_between (date , date) ---&gt; int  Result:​ Provide the exact number of years between two dates. This number can be positive or negative (if the second operand is smaller than the first one) Examples:​ int var0 &lt;- years_between(date('2000-01-01'), date('2010-01-01')); // var0 equals 10   "},{"title":"zip​","type":1,"pageTitle":"Operators (S to Z)","url":"wiki/OperatorsSZ#zip","content":"Possible uses:​ list&amp;lt;string&gt; zip string ---&gt; boolzip (list&amp;lt;string&gt; , string) ---&gt; bool  Result:​ Zip a given list of files or folders. Returns true if the files are well zipped Examples:​ bool zip_ok &lt;- zip([&quot;../includes/my_folder&quot;], &quot;folder.zip&quot;;  "},{"title":"Some pedagogical materials","type":0,"sectionRef":"#","url":"wiki/Pedagogical-Materials","content":"","keywords":""},{"title":"Initiation to algorithms with Scratch​","type":1,"pageTitle":"Some pedagogical materials","url":"wiki/Pedagogical-Materials#initiation-to-algorithms-with-scratch","content":"A set of exercises for your first step to algorithms using the graphical tool Scratch: PDF. "},{"title":"Memo GAML​","type":1,"pageTitle":"Some pedagogical materials","url":"wiki/Pedagogical-Materials#memo-gaml","content":"A summary of the organization of a GAML model, its main parts, and the main keywords, statements: PDF. "},{"title":"Class materials​","type":1,"pageTitle":"Some pedagogical materials","url":"wiki/Pedagogical-Materials#class-materials","content":"This is a set of slides used to introduce GAMA in a practical way to master students in Computer Science. (Only PDF files are provided as the sources can be very heavy. Do not hesitate to ask them if needed). Introduction to Agent-Based Modeling and simulation Introduction to the GAMA PlatformA modeling process cycleFirst steps in GAMA with the Schelling model A correction: gama project Introduction of grids in GAMA models with the ChouChevLoup model Data file: Environment asc file Introduction of GIS data in GAMA models, using a traffic model Data files: Environment filesA correction: gama project Application exercise: Evacuation of the Phuc Xa district of Hanoi Data files: Environment files "},{"title":"First Exercices (*)​","type":1,"pageTitle":"Some pedagogical materials","url":"wiki/Pedagogical-Materials#first-exercices-","content":"A set of exercises going from the building of simple models (opinion diffusion) to training exercises about specific modeling aspects (iterators on containers, scheduling...) Keywords: grid, displays, plot, containers, iterators, scheduling.Subject: PDFA correction: gaml files "},{"title":"Exercice (*): Firefly synchronization​","type":1,"pageTitle":"Some pedagogical materials","url":"wiki/Pedagogical-Materials#exercice--firefly-synchronization","content":"From UML diagram, implement a GAMA model simulating the synchronization of fireflies. Keywords: grid, displays, plot, synchronization.Subject: PDFA correction: gaml file "},{"title":"Exercice (*): Firefighter model​","type":1,"pageTitle":"Some pedagogical materials","url":"wiki/Pedagogical-Materials#exercice--firefighter-model","content":"Implement the model given in the model description file. The guide file helps you to separate the implementation of the structure of the model, its initialization, its dynamics, and ways to visualize it. Keywords: grid, inheritance, displays, plot, 3D.Model description: PDFGuide: PDFA correction: gaml file "},{"title":"Exercice (**): Wolves, Goats, Cabbages model​","type":1,"pageTitle":"Some pedagogical materials","url":"wiki/Pedagogical-Materials#exercice--wolves-goats-cabbages-model","content":"Implement an extended version of the Prey-Predator model. It allows you to manipulate grids and inheritance. Keywords: grid, inheritance, displays, plot, prey-predator model.Detailed model description: PDFData file: Environment asc fileA correction: gaml file "},{"title":"Exercice (**): Schelling model​","type":1,"pageTitle":"Some pedagogical materials","url":"wiki/Pedagogical-Materials#exercice--schelling-model","content":"Implement the segregation Schelling model on an environment (either a grid or a shafile). Keywords: grid, GIS data, displays, plot, Graphical modeling, Schelling model.Subject: PDFData file: Environment filesA correction: gaml file "},{"title":"Exercice (**): Traffic model​","type":1,"pageTitle":"Some pedagogical materials","url":"wiki/Pedagogical-Materials#exercice--traffic-model","content":"Keywords: GIS data, graph, skills, moving skill, displays, plot, mobility model.Subject: PDFData file: Environment filesA correction: gaml file "},{"title":"Exercice (***): Shortest path on a grid by distance diffusion​","type":1,"pageTitle":"Some pedagogical materials","url":"wiki/Pedagogical-Materials#exercice--shortest-path-on-a-grid-by-distance-diffusion","content":"An algorithm-oriented exercise to compute shortest paths on a grid. Keywords: grid, move, displays, diffusion model, algorithm.Subject: PDFA model: gaml file "},{"title":"Predator Prey","type":0,"sectionRef":"#","url":"wiki/PredatorPrey","content":"","keywords":""},{"title":"Content​","type":1,"pageTitle":"Predator Prey","url":"wiki/PredatorPrey#content","content":""},{"title":"Model Overview​","type":1,"pageTitle":"Predator Prey","url":"wiki/PredatorPrey#model-overview","content":"In this model, three types of entities are considered: preys, predators and vegetation cells. Preys eat grass on the vegetation cells and predators eat preys. At each simulation step, grass grows on the vegetation cells. Concerning the predators and preys, at each simulation step, they move (to a neighbor cell), eat, die if they do not have enough energy, and eventually reproduce.  "},{"title":"Step List​","type":1,"pageTitle":"Predator Prey","url":"wiki/PredatorPrey#step-list","content":"This tutorial is composed of 12 incremental steps corresponding to 12 models. For each step, we present its purpose, an explicit formulation and the corresponding GAML code of the model. Basic model (prey agents)Dynamic of the vegetation (grid)Behavior of the prey agentUse of Inspectors/monitorsPredator agents (parent species)Breeding of prey and predator agentsAgent display (aspect)Complex behaviors for the preys and predatorsAdding of a stopping conditionDefinition of chartsWriting filesImage loading (raster data)Exploration of the model "},{"title":"Platform","type":0,"sectionRef":"#","url":"wiki/PlatformDocumentation","content":"Platform GAMA consists of a single application that is based on the RCP architecture provided by Eclipse. Within this single application software, often referred to as a platform, users can undertake, without the need of additional third-parties softwares, most of the activities related to modeling and simulation, namely editing models and simulating, visualizing and exploring them using dedicated tools. First-time users may however be intimidated by the apparent complexity of the platform, so this part of the documentation has been designed to ease their first contact with it, by clearly identifying tasks of interest to modelers and how they can be accomplished within GAMA. It is accomplished by firstly providing some background about important notions found throughout the platform, especially those of workspace and projects and explaining how to organize and navigate through models. Then we take a look at the edition of models and its various tools and components (dedicated editors and related tools, of course, but also validators). Finally, we show how to run experiments on these models and what support the user interface can provide to users in this task.","keywords":""},{"title":"10. Charts","type":0,"sectionRef":"#","url":"wiki/PredatorPrey_step10","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"10. Charts","url":"wiki/PredatorPrey_step10#formulation","content":"Addition of a new display to visualize: One chart representing the evolution of the quantity of prey and predator agents over time.Two histograms representing the energy distribution of the prey and predator agents. "},{"title":"Model Definition​","type":1,"pageTitle":"10. Charts","url":"wiki/PredatorPrey_step10#model-definition","content":""},{"title":"output​","type":1,"pageTitle":"10. Charts","url":"wiki/PredatorPrey_step10#output","content":"GAMA can display various chart types: Time seriesPie chartsHistograms A chart must be defined in a display: it behaves exactly like any other layer. Definition of a chart: chart chart_name type: chart_type { [data] }  The data to draw are defined inside the chart block as follow, using the data statement: data data_legend value: data_value  We add a new display called Population_information that refreshes every 5 simulation steps. Inside this display, we define 3 charts: one of type series (i.e. time series chart), two of type histogram: &quot;Species evolution&quot;; background: white; size: {1, 0.5}; position: {0, 0} data1: nb_preys; color : bluedata2: nb_predators; color : red &quot;Prey Energy Distribution&quot;; background: lightGray; size: {0.5, 0.5}; position: {0, 0.5} data &quot;]0;0.25]&quot;: number of preys with (each.energy &lt;= 0.25) ;data &quot;]0.25;0.5]&quot;: number of preys with ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) ;data &quot;]0.5;0.75]&quot;: number of preys with ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) ;data &quot;]0.75;1]&quot;: number of preys with (each.energy &gt; 0.75) ; &quot;Predator Energy Distribution&quot;; background: lightGray; size: {0.5, 0.5}; position: {0.5, 0.5} data &quot;]0;0.25]&quot;: number of predators with (each.energy &lt;= 0.25) ;data &quot;]0.25;0.5]&quot;: number of predators with ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) ;data &quot;]0.5;0.75]&quot;: number of predators with ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) ;data &quot;]0.75;1]&quot;: number of predators with (each.energy &gt; 0.75) ; To evaluate the value of the data of the two histogram, we use the operator list count condition that returns the number of elements of list for which the condition is true. display Population_information refresh:every(5#cycles) { chart &quot;Species evolution&quot; type: series size: {1,0.5} position: {0, 0} { data &quot;number_of_preys&quot; value: nb_preys color: #blue ; data &quot;number_of_predator&quot; value: nb_predators color: #red ; } chart &quot;Prey Energy Distribution&quot; type: histogram background: #lightgray size: {0.5,0.5} position: {0, 0.5} { data &quot;]0;0.25]&quot; value: prey count (each.energy &lt;= 0.25) color:#blue; data &quot;]0.25;0.5]&quot; value: prey count ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) color:#blue; data &quot;]0.5;0.75]&quot; value: prey count ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) color:#blue; data &quot;]0.75;1]&quot; value: prey count (each.energy &gt; 0.75) color:#blue; } chart &quot;Predator Energy Distribution&quot; type: histogram background: #lightgray size: {0.5,0.5} position: {0.5, 0.5} { data &quot;]0;0.25]&quot; value: predator count (each.energy &lt;= 0.25) color: #red ; data &quot;]0.25;0.5]&quot; value: predator count ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) color: #red ; data &quot;]0.5;0.75]&quot; value: predator count ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) color: #red ; data &quot;]0.75;1]&quot; value: predator count (each.energy &gt; 0.75) color: #red; } }  "},{"title":"Complete Model​","type":1,"pageTitle":"10. Charts","url":"wiki/PredatorPrey_step10#complete-model","content":"msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2010.gaml loading... See full example on GitHub "},{"title":"1. Basic Model","type":0,"sectionRef":"#","url":"wiki/PredatorPrey_step1","content":"","keywords":""},{"title":"Content​","type":1,"pageTitle":"1. Basic Model","url":"wiki/PredatorPrey_step1#content","content":"This first step Illustrates how to write a model in GAMA. In particular, it describes how to structure a model and how to define species - that are the key components of GAMA models. "},{"title":"Formulation​","type":1,"pageTitle":"1. Basic Model","url":"wiki/PredatorPrey_step1#formulation","content":"Definition of the prey speciesDefinition of a nb_preys_init parameterCreation of nb_preys_init prey agents randomly located in the environment (size: 100x100) "},{"title":"Model Definition​","type":1,"pageTitle":"1. Basic Model","url":"wiki/PredatorPrey_step1#model-definition","content":""},{"title":"Model structure​","type":1,"pageTitle":"1. Basic Model","url":"wiki/PredatorPrey_step1#model-structure","content":"A GAMA model is composed of three types of sections: global: this section, that is unique, defines the &quot;world&quot; agent, a special agent of a GAMA model. It represents all that is global to the model: dynamics, variables, actions. In addition, it allows to initialize the simulation (init block).species and grid: these sections define the species of agents composing the model. Grid is defined in the following model step &quot;vegetation dynamic&quot;;experiment: these sections define the execution context of the simulations. In particular, it defines the input (parameters) and output (displays, files...) of a model. More details about the different sections of a GAMA model can be found here. "},{"title":"Species​","type":1,"pageTitle":"1. Basic Model","url":"wiki/PredatorPrey_step1#species","content":"A species represents a &quot;prototype&quot; of agents: it defines their common properties. A species definition requires the definition of three different elements: the internal state of its agents (attributes)their behaviorhow they are displayed (aspects) Internal state​ An attribute is defined as follows: the type of the attribute and name. Numerous types of attributes are available: int (integer), float (floating-point number), string, bool (boolean, true or false), point (coordinates), list, pair, map, file, matrix, species of agents, rgb (color), graph, path... Optional facets: &lt;- (initial value), update (value recomputed at each step of the simulation), function:{..} (value computed each time the variable is used), min, max In addition to the attributes the modeler explicitly defines, species &quot;inherits&quot; other attributes called &quot;built-in&quot; variables: A name (name): the identifier of the species.A shape (shape): the default shape of the agents to be constructed after the species. It can be a point, a polygon, etc..A location (location): the centroid of its shape. Behavior​ In this first model, we define one species of agents: the prey species. For the moment, the agents of this species will not have any particular behavior, they will just exist and be displayed. Display​ An agent aspects have to be defined. An aspect is a way to display the agents of a species: aspect aspect_name {...}. In the block of an aspect, it is possible to draw: A geometry: for instance, the shape of the agent (but it may be a different one, for instance, a disk instead of a complex polygon)An image: to draw iconsA text: to draw a text In order to display our prey agents we define two attributes: size of type float, with for initial value:1.0color of type rgb, with for initial value: #blue. It is possible to get a color value by using the symbol # + color name: e.g. #blue, #red, #white, #yellow, #magenta, #pink... Prey species code​ For the moment, we only define an aspect for this species. We want to display for each prey agent a circle of radius size and color color. We then use the statement draw with a circle shape. species prey { float size &lt;- 1.0 ; rgb color &lt;- #blue; aspect base { draw circle(size) color: color ; } }  "},{"title":"global section​","type":1,"pageTitle":"1. Basic Model","url":"wiki/PredatorPrey_step1#global-section","content":"The global section represents a specific agent, called world. Defining this agent follows the same principle as any agent and is, thus, defined after a species. The world agent represents everything that is global to the model: dynamics, variables... It allows to initialize simulations (init block): the world is always created and initialized first when a simulation is launched (before any other agents). The geometry (shape) of the world agent is by default a square with 100m for side size, but can be redefined if necessary (see the Road traffic tutorial). global attributes​ In the current model, we will only have a certain number of preys thus we need to hold this number in a global or world's variable of type integer (int) which can be done as follows: global { int nb_preys_init &lt;- 200; }  Model initialization​ The init section of the global block allows initializing the model which is executing certain commands, here we will create nb_preys_init number of prey agents. We use the statement create to create agents of a specific species: create species_name + : number: number of agents to create (int, 1 by default)from: GIS file to use to create the agents (optional, string or file)returns: list of created agents (list) Definition of the init block in order to create nb_preys_init prey agents: init { create prey number: nb_preys_init ; }  "},{"title":"experiment​","type":1,"pageTitle":"1. Basic Model","url":"wiki/PredatorPrey_step1#experiment","content":"An experiment block defines how a model can be simulated (executed). Several experiments can be defined for a given model. They are defined using : experiment exp_name type: gui/batch { [input] [output]} gui: experiment with a graphical interface, which displays its input parameters and outputs.batch: Allows to set up a series of simulations (w/o graphical interface). In our model, we define a gui experiment called prey_predator : experiment prey_predator type: gui { }  input​ Experiments can define (input) parameters. A parameter definition allows to make the value of a global variable definable by the user through the graphic interface. A parameter is defined as follows: parameter title var: global_var category: cat;  title: string to displayvar: reference to a global variable (defined in the global section)category: string used to «store» the operators on the UI - optional&lt;-: init value - optionalmin: min value - optionalmax: min value - optional Note that the init, min and max values can be defined in the global variable definition. In the experiment, the definition of a parameter from the global variable nb_preys_init: experiment prey_predator type: gui { parameter &quot;Initial number of preys: &quot; var: nb_preys_init min: 1 max: 1000 category: &quot;Prey&quot; ; }  output​ Output blocks are defined in an experiment and define how to visualize a simulation (with one or more display blocks that define separate windows). Each display can be refreshed independently by defining the facet refresh nb (int) (the display will be refreshed every nb steps of the simulation). Each display can include different layers (like in a GIS): Agents species: species my_species aspect: my_aspect;Agents lists: agents layer_name value: agents_list aspect: my_aspect;Images: image image_file;Charts: see later. Note that it is possible to define a opengl display (for 3D display) by using the facet type: opengl. In our model, we define a display to draw the prey agents. output { display main_display { species prey aspect: base ; } }  "},{"title":"Complete Model​","type":1,"pageTitle":"1. Basic Model","url":"wiki/PredatorPrey_step1#complete-model","content":"msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2001.gaml loading... See full example on GitHub "},{"title":"11. Writing Files","type":0,"sectionRef":"#","url":"wiki/PredatorPrey_step11","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"11. Writing Files","url":"wiki/PredatorPrey_step11#formulation","content":"At each simulation step, write in a text file: The time stepThe number of prey and predator agentsThe min and max energy of the prey and predator agents "},{"title":"Model Definition​","type":1,"pageTitle":"11. Writing Files","url":"wiki/PredatorPrey_step11#model-definition","content":""},{"title":"global section​","type":1,"pageTitle":"11. Writing Files","url":"wiki/PredatorPrey_step11#global-section","content":"The main way to write data inside a file is to use the save statement: save my_data type: file_type to: file_name;  With: my_data: depends on the data to save and of the type of filefile_type : stringfile_name : string There are 3 main possible types: shp (shapefile - GIS data): in that case, my_data is treated as a list of agents or geometries: all their geometries are saved in the file (with some variables as attributes),txt (text): in that case, my_data is treated as a string, which is written directly in the file,csv: in that case, my_data is treated as a list of values: [val1, val2, val3], that will be written in the file, separated by the , separator. We use this statement (in a global reflex called save_result) to write: The cycle step: use of the cycle keyword that returns the current simulation step.The number of prey and predator agents: use of nb_preys and nb_predators variables.The min and max energy of the prey and predator agents: use of list min_of expression and list max_of expression keywords.  reflex save_result when: (nb_preys &gt; 0) and (nb_predators &gt; 0){ save (&quot;cycle: &quot;+ cycle + &quot;; nbPreys: &quot; + nb_preys + &quot;; minEnergyPreys: &quot; + (prey min_of each.energy) + &quot;; maxSizePreys: &quot; + (prey max_of each.energy) + &quot;; nbPredators: &quot; + nb_predators + &quot;; minEnergyPredators: &quot; + (predator min_of each.energy) + &quot;; maxSizePredators: &quot; + (predator max_of each.energy)) to: &quot;results.txt&quot; type: &quot;text&quot; rewrite: (cycle = 0) ? true : false; }  "},{"title":"Complete Model​","type":1,"pageTitle":"11. Writing Files","url":"wiki/PredatorPrey_step11#complete-model","content":"msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2011.gaml loading... See full example on GitHub "},{"title":"12. Image loading","type":0,"sectionRef":"#","url":"wiki/PredatorPrey_step12","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"12. Image loading","url":"wiki/PredatorPrey_step12#formulation","content":"Building of the initial environment (food and food_prod of the cells) from an image file. "},{"title":"Model Definition​","type":1,"pageTitle":"12. Image loading","url":"wiki/PredatorPrey_step12#model-definition","content":""},{"title":"global variable​","type":1,"pageTitle":"12. Image loading","url":"wiki/PredatorPrey_step12#global-variable","content":"We add a new global variable to store the image data: file map_init &lt;- image_file(&quot;../includes/data/raster_map.png&quot;);  The image file is here:  You have to copy it in your project folder: includes/data/. "},{"title":"Model initialization​","type":1,"pageTitle":"12. Image loading","url":"wiki/PredatorPrey_step12#model-initialization","content":"In order to have a more complex environment, we want to use this image as the initialization of the environment. The food level available in a vegetation_cell will be based on the green level of the corresponding pixel in the image. You will be able to use such a process to represent an existing real environment in your model. We modify the global init of the model in order to cast the image file in a matrix. First of all, when the variable map_init is defined from an image file (or a csv file), it can be manipulated directly as a matrix, with the dimensions of the image (here it is a 50x50 image, which matches with the grid size). In the case we need to resize the image, we can use the file as_matrix {nb_cols, nb_lines} operator that allows converting a file (image, csv) to a matrix composed of nb_cols columns and nb_lines lines. Concerning the manipulation of a matrix, it is possible to obtain the element [i,j] of a matrix by using my_matrix [i,j]. A grid can be view as a spatial matrix: each cell of a grid has two built-in variables grid_x and grid_y that represent the column and line indexes of the cell. init { create prey number: nb_preys_init ; create predator number: nb_predators_init ; ask vegetation_cell { color &lt;- rgb (map_init at {grid_x,grid_y}) ; food &lt;- 1 - (((color as list) at 0) / 255) ; food_prod &lt;- food / 100 ; } }  "},{"title":"Complete Model​","type":1,"pageTitle":"12. Image loading","url":"wiki/PredatorPrey_step12#complete-model","content":"msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2012.gaml loading... See full example on GitHub "},{"title":"2. Vegetation Dynamic","type":0,"sectionRef":"#","url":"wiki/PredatorPrey_step2","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"2. Vegetation Dynamic","url":"wiki/PredatorPrey_step2#formulation","content":"Definition of a grid (for the vegetation)Definition of a dynamic for each cell (food production)Display of the cell color according to the quantity of foodLocalization of the prey agents on the cells (at its center) "},{"title":"Model Definition​","type":1,"pageTitle":"2. Vegetation Dynamic","url":"wiki/PredatorPrey_step2#model-definition","content":""},{"title":"grid​","type":1,"pageTitle":"2. Vegetation Dynamic","url":"wiki/PredatorPrey_step2#grid","content":"In GAMA, grids are specific agent species with a particular topology. First, a grid allows yet constrains the movement of other (moving) agents but they can have variables and behaviors. A grid is defined as follows: grid grid_name width: nb_cols height: nb_lines neighbors: 4/6/8 { ... }  With: width: number of cells along the x-axisheight: number of cells along the y-axisneighbors: neighborhood type (4 - Von Neumann, 6 - hexagon or 8 - Moore) In our model, we define a grid species, called vegetation_cell composed of 50x50 cells and with a Von Neumann neighborhood. In order for each grid agents (or cell of the grid) to represent the vegetation, we provide them with four variables: max_food: maximum food that a cell can contain -&gt; type: float ; init value: 1.0.food_prod: food produced at each simulation step -&gt; type: float ; init value: random number between 0 and 0.01.food: current quantity of food -&gt; type: float ; init value: random number between 0 and 1.0; at each simulation step: food &lt;- food + food_prod.color: color of the cell -&gt; type: rgb ; init value: color computed according to the food value: more the food value is close to 1.0, greener the color is, more the food value is close to 0, whiter the color is; update: computation of the new color depending on the current level of food (at each simulation step). The update facet allows to give a behavior to the agents. Indeed, at each simulation step, each agent is activated (by default, in its creation order) and first applies for each dynamic variable (in their definition order) its update expression. In the present case, it allows us to link the displayed color of the cell to its food level. grid vegetation_cell width: 50 height: 50 neighbors: 4 { float max_food &lt;- 1.0 ; float food_prod &lt;- rnd(0.01) ; float food &lt;- rnd(1.0) max: max_food update: food + food_prod; rgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) ; }  There are several ways to define colors in GAML: the simplest way consists in using the symbol # + the color name (for a limited set of colors): #blue, #red...Another way consists in defining the 3 RGB integer values: rgb(red, green, blue) with red, green and blue between 0 and 255 (as we used in the current model): rgb(0,0,0) for black, rgb(255,255,255) for white, rgb(255,0,0) for red, rgb(0,255,0) for green, or rgb(0,0,255) for blue. "},{"title":"prey agents​","type":1,"pageTitle":"2. Vegetation Dynamic","url":"wiki/PredatorPrey_step2#prey-agents","content":"In order to relate our prey agents to the vegetation cell grid, we add them with one new attribute: my_cell of type vegetation_cell and for init value one of the vegetation_cell (chosen randomly). species prey { ... vegetation_cell my_cell &lt;- one_of (vegetation_cell) ; }  It is possible to obtain the list of all agents of a given species by using the name of the species while one_of to pick one element randomly from this list. We linked each prey agent to a vegetation_cell but we need to locate them onto the cell. To do so, we set the prey location as equals to the location of the vegetation cell (i.e. its centroid), we use in the init block the &lt;- statement that allows to modify the value of a variable: species prey { ... init { location &lt;- my_cell.location; } }  "},{"title":"display​","type":1,"pageTitle":"2. Vegetation Dynamic","url":"wiki/PredatorPrey_step2#display","content":"In order to visualize the vegetation, we need to add it to the display. We use for that the statement grid with the optional facet border to draw the border of the cells. Note that grid agents have built-in aspect thus it is not necessary to define one: it is a square with the color attribute as value.  output { display main_display { grid vegetation_cell border: #black; species prey aspect: base ; } }  Note that the layers in a display work like layers in a GIS; the drawing order will be respected. In our model, the prey agents will be drawn above the vegetation_cell grid thus they need to be declared afterward. "},{"title":"Complete Model​","type":1,"pageTitle":"2. Vegetation Dynamic","url":"wiki/PredatorPrey_step2#complete-model","content":"msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2002.gaml loading... See full example on GitHub "},{"title":"13. Model exploration","type":0,"sectionRef":"#","url":"wiki/PredatorPrey_step13","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"13. Model exploration","url":"wiki/PredatorPrey_step13#formulation","content":"Addition of a new experiment of type batch.Definition of the parameters to be explored.Definition of the exploration method. "},{"title":"Model Definition​","type":1,"pageTitle":"13. Model exploration","url":"wiki/PredatorPrey_step13#model-definition","content":"The model itself (the global and the various species) will be modified. We will simply add a new experiment to define a new way of launching the simulation. "},{"title":"batch experiment​","type":1,"pageTitle":"13. Model exploration","url":"wiki/PredatorPrey_step13#batch-experiment","content":"We will thus add a new experiment in the file. The specificity of this experiment will be its type: we will define a batch experiment, instead of a gui (as done until now). This experiment will not manage any display but will run several simulations to explore the parameter space (depending on the exploration method). experiment Optimization type: batch repeat: 2 keep_seed: true until: ( time &gt; 200 ) { ... }  A batch experiment comes with more facets: repeat: the number of simulations to launch for a single parameter configuration,keep_seed: set whether the seed of the random number generator is the same for each first replication (the first simulation run for a given parameter configuration),until: define the simulation stop condition. "},{"title":"Parameters definition​","type":1,"pageTitle":"13. Model exploration","url":"wiki/PredatorPrey_step13#parameters-definition","content":"We now need to define the parameters to explore: similarly to gui experiment, parameters are taken among the global variables. In a batch experiment, it is necessary to define their value range (using the among facet or the min, max, and step ones). parameter &quot;Prey max transfer:&quot; var: prey_max_transfer min: 0.05 max: 0.5 step: 0.05 ; parameter &quot;Prey energy reproduce:&quot; var: prey_energy_reproduce min: 0.05 max: 0.75 step: 0.05; parameter &quot;Predator energy transfer:&quot; var: predator_energy_transfer min: 0.1 max: 1.0 step: 0.1 ; parameter &quot;Predator energy reproduce:&quot; var: predator_energy_reproduce min: 0.1 max: 1.0 step: 0.1;  "},{"title":"Exploration method​","type":1,"pageTitle":"13. Model exploration","url":"wiki/PredatorPrey_step13#exploration-method","content":"Finally, the exploration method has to be specified (the default method is exhaustive exploration). GAMA provides several methods, detailed in this page. We choose here the Tabu search method, defined by: method tabu maximize: nb_preys + nb_predators iter_max: 10 tabu_list_size: 3;  "},{"title":"Save exploration results​","type":1,"pageTitle":"13. Model exploration","url":"wiki/PredatorPrey_step13#save-exploration-results","content":"In a previous step, we introduced the save of results at each step of a simulation. When exploring a model, it could be interesting to save results after each simulation. To this purpose, we will use again the save statement but in a reflex of the experiment and not a reflex of the model. In a batch experiment, the reflexes are executed after all the replications for a single parameter configuration. The built-in simulations variable contains all the simulations; we can thus ask them the results we want to save. In addition, we save the parameter values to keep track. We will use the save statement to save the results as a csv file (as it is easier to manipulate by analysis software, such as R). We can thus save a list of values: reflex save_results_explo { ask simulations { save [int(self),prey_max_transfer,prey_energy_reproduce,predator_energy_transfer,predator_energy_reproduce,self.nb_predators,self.nb_preys] to: &quot;results.csv&quot; type: &quot;csv&quot; rewrite: (int(self) = 0) ? true : false header: true; } }  This saved for each simulation its self.nb_predators and self.nb_preys. Note that self here is mandatory! "},{"title":"Deal with the simulation stop​","type":1,"pageTitle":"13. Model exploration","url":"wiki/PredatorPrey_step13#deal-with-the-simulation-stop","content":"An issue we will have with the model is that it already has a stop condition: it pauses when either the number of preys or the number of predators become zero. We will introduce a new global variable is_batch to specify whether the simulation is in batch mode or not. In batch mode, the reflex stop_simulation should not be executed. global { ... bool is_batch &lt;- false; ... reflex stop_simulation when: ((nb_preys = 0) or (nb_predators = 0)) and !is_batch { do pause ; } }  This variable should thus now be initialized by default to false (so in the init block of the model) and in the batch experiment to true. experiment Optimization type: batch repeat: 2 keep_seed: true until: ( time &gt; 200 ) { ... parameter &quot;Batch mode:&quot; var: is_batch &lt;- true; ... }  "},{"title":"Conclusion​","type":1,"pageTitle":"13. Model exploration","url":"wiki/PredatorPrey_step13#conclusion","content":"Congratulations, you have completed your first GAMA models! Now, you have enough knowledge to create many models that includes: dynamic grid-based environment, moving and interacting agents and the needed visualization to make good use of your simulation. Feel free to use this knowledge to create your very own models! Or perhaps you want to continue your study with the more advanced tutorials? "},{"title":"Complete Model​","type":1,"pageTitle":"13. Model exploration","url":"wiki/PredatorPrey_step13#complete-model","content":"https://github.com/gama-platform/gama/blob/GAMA_1.8.2/msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2013.gaml  "},{"title":"4. Inspectors and Monitors","type":0,"sectionRef":"#","url":"wiki/PredatorPrey_step4","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"4. Inspectors and Monitors","url":"wiki/PredatorPrey_step4#formulation","content":"Adding of a monitor to follow the evolution of the number of prey agents "},{"title":"Model Definition​","type":1,"pageTitle":"4. Inspectors and Monitors","url":"wiki/PredatorPrey_step4#model-definition","content":""},{"title":"global variable​","type":1,"pageTitle":"4. Inspectors and Monitors","url":"wiki/PredatorPrey_step4#global-variable","content":"We add a new global variable: nb_preys: returns, each time it is called, the current number of (live) prey agents To do so we use the -&gt;{expression} facet which returns the value of expression, each time it is called. We use as well the operator length that returns the number of elements in a list. Thus, in the global section, we add the nb_preys global variable: int nb_preys -&gt; {length (prey)};  "},{"title":"monitor​","type":1,"pageTitle":"4. Inspectors and Monitors","url":"wiki/PredatorPrey_step4#monitor","content":"A monitor allows users to follow the value of an arbitrary expression in GAML. It has to be defined in an output section. A monitor is defined as follows: monitor monitor_name value: an_expression refresh: every(nb_steps);  With: value: mandatory, that value will be displayed in the monitor.refresh: bool, optional: if the expression is true, compute (default is true). In this model, we define a monitor to follow the value of the variable nb_preys: monitor &quot;number of preys&quot; value: nb_preys;  "},{"title":"inspector​","type":1,"pageTitle":"4. Inspectors and Monitors","url":"wiki/PredatorPrey_step4#inspector","content":"Inspectors allow to obtain information about a species or an agent. There are two kinds of agent information features: Species browser: provides information about all the agents of a species. Available in the Agents menu.  Agent inspector: provides information about one specific agent. Also allows to change the values of its variables during the simulation. Available from the Agents menu, by right_clicking on a display, in the species inspector, or when inspecting another agent. It provides also the possibility to «highlight» the inspected agent.  "},{"title":"Complete Model​","type":1,"pageTitle":"4. Inspectors and Monitors","url":"wiki/PredatorPrey_step4#complete-model","content":"msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2004.gaml loading... See full example on GitHub "},{"title":"3. Prey Agent Behavior","type":0,"sectionRef":"#","url":"wiki/PredatorPrey_step3","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"3. Prey Agent Behavior","url":"wiki/PredatorPrey_step3#formulation","content":"Random movement of the prey agents to a distance of 2 cells (Von Neumann neighborhood).At each step, the prey agents loss energy.At each step, the prey agents eat food if there is food on the cell on which they are localized (with a max of max_transfer) and gain energy.If a prey agent has no more energy, it dies. "},{"title":"Model Definition​","type":1,"pageTitle":"3. Prey Agent Behavior","url":"wiki/PredatorPrey_step3#model-definition","content":""},{"title":"Parameters​","type":1,"pageTitle":"3. Prey Agent Behavior","url":"wiki/PredatorPrey_step3#parameters","content":"To define the behavior for the prey agents, we add to them three new parameters: The max energy of the prey agents.The maximum energy that can a prey agent consume from vegetation per step.The energy used by a prey agent at each time step. As we consider these parameters to be global to all preys, we define them in the global section as follows: float prey_max_energy &lt;- 1.0; float prey_max_transfer &lt;- 0.1; float prey_energy_consum &lt;- 0.05;  Yet we may allow the user to change their values through the user interface. To do so, we add the following definition of parameters within the experiment section: parameter &quot;Prey max energy: &quot; var: prey_max_energy category: &quot;Prey&quot; ; parameter &quot;Prey max transfer: &quot; var: prey_max_transfer category: &quot;Prey&quot; ; parameter &quot;Prey energy consumption: &quot; var: prey_energy_consum category: &quot;Prey&quot; ;  "},{"title":"vegetation_cell grid​","type":1,"pageTitle":"3. Prey Agent Behavior","url":"wiki/PredatorPrey_step3#vegetation_cell-grid","content":"We add a new variable for the vegetation_cell grid called neighbors2, that contains for each vegetation cell the list of the neighbor vegetation cells (at a distance of 2 - Von Neumann neighborhood). We will use these neighbors list for the movement of the prey. Note that the attribute neighbors is a built-in attribute of any grid agent (it contains the agents of the grid at a distance 1). grid vegetation_cell width: 50 height: 50 neighbors: 4 { ... list&amp;lt;vegetation_cell&gt; neighbors2 &lt;- self neighbors_at 2; }  Note that the result of the operator neighbors_at dist depends on the type of topology of the agent applying this operator: For a grid topology (grid species), the operator returns the neighbor cells (with a Von Neumann or Moore neighborhood).For a continuous topology, the operator returns the list of agents of which the shape is located at a distance equals or inferior dist meters to the agent shape.Inside a graph topology, it returns the agents separated by only one edge from the calling agent (independently of their spatial location). Also, note the use of the self pseudo-variable which is a reference to the agent currently executing the statement. "},{"title":"Prey agents​","type":1,"pageTitle":"3. Prey Agent Behavior","url":"wiki/PredatorPrey_step3#prey-agents","content":"We copy the values of the three global parameters into the prey species in order for it to be available for each agent and possibly modified locally. species prey { ... float max_energy &lt;- prey_max_energy ; float max_transfer &lt;- prey_max_transfer ; float energy_consum &lt;- prey_energy_consum ; ... }  The energy used by each prey at each timestep is randomly computed initially (within ]0;max_energy]). species prey { ... float energy &lt;- rnd(max_energy) update: energy - energy_consum max: max_energy ; ... }  In order to define the movement behavior of preys, we will add a reflex. A reflex is a block of statements (that can be defined in global or any species) that will be automatically executed at each simulation step if its condition is true, it is defined as follows: reflex reflex_name when: condition {...}  The when facet is optional: when it is omitted, the reflex is activated at each time step. Note that if several reflexes are defined for a species, the reflexes will be activated following their definition order. We define a first reflex called basic_move that allows the prey agents to choose (randomly) a new vegetation_cell in the neighborhood of my_cell and to move to this cell. species prey { ... reflex basic_move { my_cell &lt;- one_of (my_cell.neighbors2) ; location &lt;- my_cell.location ; } }  We define a second reflex called eat that will only be activated when there is food in my_cell and that will allow the prey agents to eat food and gain energy. In order to store the energy gain by the eating (that equals to the minimum between the max_transfer value and the quantity of food available in my_cell), we define a local variable called energy_transfer. A local variable is a variable that will only exist within this block: once it has been executed, the variable is forgotten. To define it, we have to use the following statement: var_type var_name &lt;- value;  Thus, the reflex eat is defined by: species prey { ... reflex eat when: my_cell.food &gt; 0 { float energy_transfer &lt;- min([max_transfer, my_cell.food]) ; my_cell.food &lt;- my_cell.food - energy_transfer ; energy &lt;- energy + energy_transfer ; } }  We define a third reflex for the prey agent: when the agent has no more energy, it dies (application of the built-in die action): species prey { ... reflex die when: energy &lt;= 0 { do die ; } }  Note that an action is a capability available to the agents of a species (what they can do). It is a block of statements that can be used and reused whenever needed. Some actions, called primitives, are directly coded in Java: for instance, the die action defined for all the agents. An action can accept arguments. For instance, write takes an argument called message.An action can return a result. There are two ways to call an action: using a statement or as part of an expression for actions that do not return a result: do action_name arg1: v1 arg2: v2;  for actions that return a result: my_var &lt;- self action_name (arg1:v1, arg2:v2);  "},{"title":"Complete Model​","type":1,"pageTitle":"3. Prey Agent Behavior","url":"wiki/PredatorPrey_step3#complete-model","content":"msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2003.gaml loading... See full example on GitHub "},{"title":"5. Predator Agent","type":0,"sectionRef":"#","url":"wiki/PredatorPrey_step5","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"5. Predator Agent","url":"wiki/PredatorPrey_step5#formulation","content":"Definition of a new generic species: generic_species.Definition of a new species: predator.predator agents move randomly.At each simulation step, a predator agent can eat a prey that is localized at its grid cell. "},{"title":"Model Definition​","type":1,"pageTitle":"5. Predator Agent","url":"wiki/PredatorPrey_step5#model-definition","content":""},{"title":"parameters​","type":1,"pageTitle":"5. Predator Agent","url":"wiki/PredatorPrey_step5#parameters","content":"We add four new parameters related to predator agents: The init number of predator agents.The max energy of the predator agents.The energy gained by a predator agent while eating a prey agent.The energy consumed by a predator agent at each time step. We define four new global variables in the global section: global { ... int nb_predators_init &lt;- 20; float predator_max_energy &lt;- 1.0; float predator_energy_transfer &lt;- 0.5; float predator_energy_consum &lt;- 0.02; }  We define then the four corresponding parameters in the experiment: parameter &quot;Initial number of predators: &quot; var: nb_predators_init min: 0 max: 200 category: &quot;Predator&quot; ; parameter &quot;Predator max energy: &quot; var: predator_max_energy category: &quot;Predator&quot; ; parameter &quot;Predator energy transfer: &quot; var: predator_energy_transfer category: &quot;Predator&quot; ; parameter &quot;Predator energy consumption: &quot; var: predator_energy_consum category: &quot;Predator&quot; ;  "},{"title":"parent species​","type":1,"pageTitle":"5. Predator Agent","url":"wiki/PredatorPrey_step5#parent-species","content":"A species can have a parent species: it automatically gets all the variables, skill and actions/reflex of the parent species. We define a species called generic_species that is the parent of the species prey and predator:  This species integrates all of the common feature between the prey and predator species: the variables: sizecolormax_energymax_transferenergy_consummy_cellenergy the behaviors: basic_move reflexeat reflexdie reflex the actions: energy_from_eat action the aspect: base aspect As the eat behavior depends on the species (prey eats on vegetation_cell, whereas predator agents eat prey agents), we introduce an action energy_from_eat that will be redefined in each child species. Each species will implement its own eating behavior, returning the amount of energy it gets from this action. We remind that an action is a capability available to the agents (what they can do). It is a block of statements that can be used and reused whenever needed. An action can accept arguments.An action can return a result (statement return). There are two ways of calling an action: using a statement do or as part of an expression: for actions that do not return a result: do action_name (arg1: v1 arg2: v2); do action_name (v1, v2);  for actions that return a result (which is stored in my_var): my_var &lt;- action_name (arg1:v1, arg2:v2); my_var &lt;- action_name (v1, v2);  Thus the generic_species will have the following code. Note that the action energy_from_eat is also defined in this species, but with a default result (return 0.0). species generic_species { float size &lt;- 1.0; rgb color ; float max_energy; float max_transfer; float energy_consum; vegetation_cell my_cell &lt;- one_of (vegetation_cell) ; float energy &lt;- rnd(max_energy) update: energy - energy_consum max: max_energy ; init { location &lt;- my_cell.location; } reflex basic_move { my_cell &lt;- one_of (my_cell.neighbors2) ; location &lt;- my_cell.location ; } reflex eat { energy &lt;- energy + energy_from_eat(); } reflex die when: energy &lt;= 0 { do die; } float energy_from_eat { return 0.0; } aspect base { draw circle(size) color: color ; } }  "},{"title":"prey species​","type":1,"pageTitle":"5. Predator Agent","url":"wiki/PredatorPrey_step5#prey-species","content":"We specialize the prey species from the generic_species species: definition of the initial value of the agent variables.definition of the specific eat action: if the current cell contains some food, the prey agent will take either all this food or the max_transfer value (if the amount of food is greater than the maximum value the prey can take). species prey parent: generic_species { rgb color &lt;- #blue; float max_energy &lt;- prey_max_energy ; float max_transfer &lt;- prey_max_transfer ; float energy_consum &lt;- prey_energy_consum ; float energy_from_eat { float energy_transfer &lt;- 0.0; if(my_cell.food &gt; 0) { energy_transfer &lt;- min([max_transfer, my_cell.food]); my_cell.food &lt;- my_cell.food - energy_transfer; } return energy_transfer; } }  "},{"title":"predator species​","type":1,"pageTitle":"5. Predator Agent","url":"wiki/PredatorPrey_step5#predator-species","content":"As done for the prey species, we specialize the predator species from the generic_species species: definition of the initial value of the agent variables.definition of the specific eat action: first, the agent computes the list of prey agents contained by my_cell (reachable_preys variable); if it is not empty, it chooses one of the elements of this list, it kills it (i.e. asks it to die) and returns the energy_transfer variable (that will be added to its own energy). species predator parent: generic_species { rgb color &lt;- #red ; float max_energy &lt;- predator_max_energy ; float energy_transfer &lt;- predator_energy_transfer ; float energy_consum &lt;- predator_energy_consum ; float energy_from_eat { list&amp;lt;prey&gt; reachable_preys &lt;- prey inside (my_cell); if(! empty(reachable_preys)) { ask one_of (reachable_preys) { do die; } return energy_transfer; } return 0.0; } }  Note that we used the ask statement. This statement allows to make a remote agent executes a list of statements. Use of the ask statement as follows: ask one_agent { }  or ask agents_list { }  We used as well the species/agent list inside geometry/agent operator. This operator returns all the agents of the specified species (or from the specified agent list) that are inside the given geometry or agent geometry. "},{"title":"global init block​","type":1,"pageTitle":"5. Predator Agent","url":"wiki/PredatorPrey_step5#global-init-block","content":"Like in the previous model, in the init block of the model, we create nb_predators_init. global { ... init { create prey number: nb_preys_init ; create predator number: nb_predators_init ; } }  "},{"title":"monitor​","type":1,"pageTitle":"5. Predator Agent","url":"wiki/PredatorPrey_step5#monitor","content":"Like in the previous model, we define a monitor to display the number of predator agents. Definition of a global variable nb_predator that returns the current number of predator agents: global { ... int nb_predators -&gt; {length (predator)}; ... }  Definition of the corresponding monitor: monitor &quot;number of predators&quot; value: nb_predators ;  "},{"title":"display​","type":1,"pageTitle":"5. Predator Agent","url":"wiki/PredatorPrey_step5#display","content":"Also, do not forget to add the line to display predators in your simulation display main_display { ... species predator aspect: base ; }  "},{"title":"Complete Model​","type":1,"pageTitle":"5. Predator Agent","url":"wiki/PredatorPrey_step5#complete-model","content":"msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2005.gaml loading... See full example on GitHub "},{"title":"6. Breeding","type":0,"sectionRef":"#","url":"wiki/PredatorPrey_step6","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"6. Breeding","url":"wiki/PredatorPrey_step6#formulation","content":"Adding of a reproduce behavior for the prey and predator species: When an agent has enough energy, it has a certain probability to have a certain number of offspring.The energy of the offspring is equal to the parent energy divided by the number of offspring.The parent gets the same energy as its offspring. "},{"title":"Model Definition​","type":1,"pageTitle":"6. Breeding","url":"wiki/PredatorPrey_step6#model-definition","content":""},{"title":"parameters​","type":1,"pageTitle":"6. Breeding","url":"wiki/PredatorPrey_step6#parameters","content":"We add six new parameters related to breeding: The reproduction probability for prey agentsThe max number of offspring for prey agentsThe minimum energy to reproduce for prey agentsThe reproduction probability for predator agentsThe max number of offspring for predator agentsThe minimum energy to reproduce for predator agents We define six new global variables in the global section: global { ... float prey_proba_reproduce &lt;- 0.01; int prey_nb_max_offsprings &lt;- 5; float prey_energy_reproduce &lt;- 0.5; float predator_proba_reproduce &lt;- 0.01; int predator_nb_max_offsprings &lt;- 3; float predator_energy_reproduce &lt;- 0.5; ... }  We define then the six corresponding parameters in the experiment: parameter &quot;Prey probability reproduce: &quot; var: prey_proba_reproduce category: &quot;Prey&quot; ; parameter &quot;Prey nb max offsprings: &quot; var: prey_nb_max_offsprings category: &quot;Prey&quot; ; parameter &quot;Prey energy reproduce: &quot; var: prey_energy_reproduce category: &quot;Prey&quot; ; parameter &quot;Predator probability reproduce: &quot; var: predator_proba_reproduce category: &quot;Predator&quot; ; parameter &quot;Predator nb max offsprings: &quot; var: predator_nb_max_offsprings category: &quot;Predator&quot; ; parameter &quot;Predator energy reproduce: &quot; var: predator_energy_reproduce category: &quot;Predator&quot; ;  "},{"title":"parent species​","type":1,"pageTitle":"6. Breeding","url":"wiki/PredatorPrey_step6#parent-species","content":"The reproduction dynamics is the same for both prey and predator species, it can thus be implemented only once inside the parent species. But the values of the parameters will depend on the species, and thus have to be set with different values inside each of them. We add three new variables for the generic_species: proba_reproducenb_max_offspringsenergy_reproduce We add as well a new reflex called reproduce: this reflex is activated only when: The energy of the agent is greater or equals to energy_reproduceAND according to the probability proba_reproduce: for this second condition, we use the flip(proba) operator that returns true according to the probability proba (false otherwise). this reflex creates nb_offsprings (random number between 1 and nb_max_offsprings) new agents of the species of the agent using the create statement: we use a species casting operator on the current agent. the created agents are initialized as follows: my_cell: my_cell of the agent creating the agents,location: location of my_cell,energy: energy of the agent creating the agents (use of keyword myself) divided by the number of offsprings. after the agent creation, the reflex updates the energy value of the current agent with the value: energy / nb_offsprings. species generic_species { ... float proba_reproduce ; int nb_max_offsprings; float energy_reproduce; ... reflex reproduce when: (energy &gt;= energy_reproduce) and (flip(proba_reproduce)) { int nb_offsprings &lt;- rnd(1, nb_max_offsprings); create species(self) number: nb_offsprings { myCell &lt;- myself.myCell ; location &lt;- myCell.location ; energy &lt;- myself.energy / nb_offsprings ; } energy &lt;- energy / nb_offsprings ; } }  Note that two keywords (pseudo-variables) can be used to make explicit references to some agents: The agent that is currently executing the statements inside the block (for example a newly created agent): selfThe agent that is executing the statement that contains this block (for instance, the agent that has called the create statement): myself "},{"title":"prey species​","type":1,"pageTitle":"6. Breeding","url":"wiki/PredatorPrey_step6#prey-species","content":"We specialize the prey species from the generic_species species as follows: definition of the initial value of the agent variables  species prey parent: generic_species { ... float proba_reproduce &lt;- prey_proba_reproduce ; int nb_max_offsprings &lt;- prey_nb_max_offsprings ; float energy_reproduce &lt;- prey_energy_reproduce ; ... }  "},{"title":"predator species​","type":1,"pageTitle":"6. Breeding","url":"wiki/PredatorPrey_step6#predator-species","content":"As done for the prey species, we specialize the predator species from the generic_species species: definition of the initial value of the agent variables:  species predator parent: generic_species { ... float proba_reproduce &lt;- predator_proba_reproduce ; int nb_max_offsprings &lt;- predator_nb_max_offsprings ; float energy_reproduce &lt;- predator_energy_reproduce ; ... }  "},{"title":"Complete Model​","type":1,"pageTitle":"6. Breeding","url":"wiki/PredatorPrey_step6#complete-model","content":"msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2006.gaml loading... See full example on GitHub "},{"title":"8. Complex Behavior","type":0,"sectionRef":"#","url":"wiki/PredatorPrey_step8","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"8. Complex Behavior","url":"wiki/PredatorPrey_step8#formulation","content":"Definition of more complex behaviors for prey and predator agents: The preys agents are moving to the cell containing the highest quantity of food.The predator agents are moving if possible to a cell that contains preys, otherwise to a random cell. "},{"title":"Model Definition​","type":1,"pageTitle":"8. Complex Behavior","url":"wiki/PredatorPrey_step8#model-definition","content":""},{"title":"parent species​","type":1,"pageTitle":"8. Complex Behavior","url":"wiki/PredatorPrey_step8#parent-species","content":"We modify the basic_move reflex of the generic_species in order to give the prey and predator more complex behaviors: instead of choosing a random vegetation cell in the neighborhood, the agents will choose a vegetation cell (still in the neighborhood) thanks to a choose_cell action. This action will return an empty (nil) value in the parent species and will be specialized for each species. species generic_species { ... reflex basic_move { my_cell &lt;- choose_cell(); location &lt;- my_cell.location; } vegetation_cell choose_cell { return nil; } ... }  "},{"title":"prey species​","type":1,"pageTitle":"8. Complex Behavior","url":"wiki/PredatorPrey_step8#prey-species","content":"We specialize the choose_cell action for the prey species: the agent will choose the vegetation cell of the neighborhood (list my_cell.neighbors2) that maximizes the quantity of food. Note that GAMA offers numerous operators to manipulate lists and containers: Unary operators: min, max, sum...Binary operators: where: returns a sub-list where all the elements verify the condition defined in the right operand.first_with: returns the first element of the list that verifies the condition defined in the right operand.... In the case of binary operators, each element (of the first operand list) can be accessed with the pseudo-variable each. Thus the choose_cell action of the prey species is defined by: species prey parent: generic_species { ... vegetation_cell choose_cell { return (my_cell.neighbors2) with_max_of (each.food); } ... }  "},{"title":"predator species​","type":1,"pageTitle":"8. Complex Behavior","url":"wiki/PredatorPrey_step8#predator-species","content":"We specialize the choose_cell species for the predator species: the agent will choose, if possible, a vegetation cell of the neighborhood (list my_cell.neighbors2) that contains at least a prey agent; otherwise it will choose a random cell. We use for this action the first_with operator on the list of neighbor vegetation cells (my_cell.neighbors2) with the following condition: the list of prey agents contained in the cell is not empty. Note that we use the shuffle operator to randomize the order of the list of the neighbor cells. If all the neighbor cells are empty, then the agent chooses a random cell in the neighborhood (one_of (my_cell.neighbors2)). GAMA contains statements that allow executing blocks depending on some conditions: if condition1 {...} else if condition2{...} ... else {...}  This statement means that if condition1 = true then the first block is executed; otherwise, if condition2 = true, then it is the second block, etc. When no conditions are satisfied and an else block is defined (it is optional), this latter is executed. We then write the choose_cell action as follows: species predator parent: generic_species { ... vegetation_cell choose_cell { vegetation_cell my_cell_tmp &lt;- shuffle(my_cell.neighbors2) first_with (!(empty (prey inside (each)))); if my_cell_tmp != nil { return my_cell_tmp; } else { return one_of (my_cell.neighbors2); } } ... }  Note there is ternary operator allowing to directly use a conditioned structure to evaluate a variable: condition ? value1 : value2  if condition is true, then returns value1; otherwise, returns value2. "},{"title":"Complete Model​","type":1,"pageTitle":"8. Complex Behavior","url":"wiki/PredatorPrey_step8#complete-model","content":"msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2008.gaml loading... See full example on GitHub "},{"title":"7. Agent Aspect","type":0,"sectionRef":"#","url":"wiki/PredatorPrey_step7","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"7. Agent Aspect","url":"wiki/PredatorPrey_step7#formulation","content":"Definition of two new aspects for the prey and predator agents: A iconA square with information about the agent energy Use of the icon aspect as default aspect for the prey and predator agents. "},{"title":"Model Definition​","type":1,"pageTitle":"7. Agent Aspect","url":"wiki/PredatorPrey_step7#model-definition","content":""},{"title":"parent species​","type":1,"pageTitle":"7. Agent Aspect","url":"wiki/PredatorPrey_step7#parent-species","content":"We add a new variable of type image_file (a particular kind of file) called my_icon to the generic_species. We define as well two new aspects: icon: draw the image given by the variable my_icon,info: draw a square of side size size and color color and draw as a text the energy of the agent (with a precision of 2 digits). species generic_species { ... image_file my_icon; ... aspect base { draw circle(size) color: color ; } aspect icon { draw my_icon size: 2 * size ; } aspect info { draw square(size) color: color ; draw string(energy with_precision 2) size: 3 color: #black ; } }  "},{"title":"prey species​","type":1,"pageTitle":"7. Agent Aspect","url":"wiki/PredatorPrey_step7#prey-species","content":"We specialize the prey species from the generic_species species as follows: definition of the initial value of the agent variables: species prey parent: generic_species { ... image_file my_icon &lt;- image_file(&quot;../includes/data/sheep.png&quot;) ; ... }  The image file is here: . You have to copy it in your project folder: includes/data/. "},{"title":"predator species​","type":1,"pageTitle":"7. Agent Aspect","url":"wiki/PredatorPrey_step7#predator-species","content":"As done for the prey species, we specialize the predator species from the generic_species species: definition of the initial value of the agent variables: species predator parent: generic_species { ... image_file my_icon &lt;- image_file(&quot;../includes/data/wolf.png&quot;) ; ... }  The image file is here: . You have to copy it in your project folder: includes/data/. "},{"title":"display​","type":1,"pageTitle":"7. Agent Aspect","url":"wiki/PredatorPrey_step7#display","content":"We change the default aspect of the prey and predator agents to icon aspect. output { display main_display { grid vegetation_cell lines: #black ; species prey aspect: icon ; species predator aspect: icon ; } }  We define a new display called info_display that displays the prey and predator agents with the info aspect. output { display info_display { grid vegetation_cell lines: #black ; species prey aspect: info; species predator aspect: info; } }  "},{"title":"Complete Model​","type":1,"pageTitle":"7. Agent Aspect","url":"wiki/PredatorPrey_step7#complete-model","content":"msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2007.gaml loading... See full example on GitHub "},{"title":"9. Stopping condition","type":0,"sectionRef":"#","url":"wiki/PredatorPrey_step9","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"9. Stopping condition","url":"wiki/PredatorPrey_step9#formulation","content":"Addition of a stopping condition for the simulation: when there is no more prey or predator agents, the simulation stops "},{"title":"Model Definition​","type":1,"pageTitle":"9. Stopping condition","url":"wiki/PredatorPrey_step9#model-definition","content":"We add a new reflex that stops the simulation if the number of preys or the number of predators is zero. global { ... reflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) { do pause ; } }  "},{"title":"Complete Model​","type":1,"pageTitle":"9. Stopping condition","url":"wiki/PredatorPrey_step9#complete-model","content":"msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2009.gaml loading... See full example on GitHub "},{"title":"Projects","type":0,"sectionRef":"#","url":"wiki/Projects","content":"","keywords":""},{"title":"Publications​","type":1,"pageTitle":"Projects","url":"wiki/Projects#publications","content":"This page is an attempt to list the projects using the GAMA platform as a modeling and simulation platform. Interesting readers can also have a look at the page listing the Ph.D. theses and articles related to and/or using GAMA platform. "},{"title":"Projects​","type":1,"pageTitle":"Projects","url":"wiki/Projects#projects","content":""},{"title":"SWITCH: Simulating the transition of transport Infrastructures Toward smart and sustainable Cities (ANR 2019- )​","type":1,"pageTitle":"Projects","url":"wiki/Projects#switch-simulating-the-transition-of-transport-infrastructures-toward-smart-and-sustainable-cities-anr-2019--","content":"Description: Transport infrastructures play a large part in defining the city of the future, which should be smart, sustainable and resilient. Their management will need to deal with the emergence of novel technologies (i.e. autonomous cars, Internet of Things) and the increase of novel modalities and practices (increase of multi-modality, electric bicycles, shared cars). The SwITCh project aims at supporting decision-making for urban planning by simulating the gradual introduction of disruptive innovations on technology, usage and behaviour of infrastructure. It requires providing a model that is able to assess the impact of these innovations on several key indicators on mobility, user satisfaction and security, economic costs and air pollution. SwITCh integrates a large variety of urban transport modalities (private car, walk, tramway, etc.) and associated infrastructures (pavement, bicycle path, etc.). It uses agent- based modelling (ABM) and participatory simulation as a unifying framework that allows coupling different models and taking into account both temporal and spatial scales in order to build a holistic model. The resulting interactive simulator and serious game will be used by the city planners to explore the potential impact of innovations in various contexts, test and assess different alternatives and situations in two case studies: Bordeaux Metropole and the Urban Community of Dijon. Website: https://www6.inrae.fr/switch Contact: Franck Taillandier "},{"title":"COMOKIT (2020- )​","type":1,"pageTitle":"Projects","url":"wiki/Projects#comokit-2020--","content":"Description: Since its emergence in China, the COVID-19 pandemic has spread rapidly around the world. Faced with this unknown disease, public health authorities were forced to experiment, in a short period of time, with various combinations of interventions at different scales. However, as the pandemic progresses, there is an urgent need for tools and methodologies to quickly analyze the effectiveness of responses against COVID-19 in different communities and contexts. In this perspective, computer modelling appears to be an invaluable lever as it allows for the in silico exploration of a range of intervention strategies prior to the potential field implementation phase. More specifically, we argue that, in order to take into account important dimensions of policy actions, such as the heterogeneity of the individual response or the spatial aspect of containment strategies, the branch of computer modeling known as agent-based modelling is of immense interest. We present in this paper an agent-based modelling framework called COVID-19 Modelling Kit (COMOKIT), designed to be generic, scalable, and thus portable in a variety of social and geographical contexts. COMOKIT combines models of person-to-person and environmental transmission, a model of individual epidemiological status evolution, an agenda-based one-hour time step model of human mobility, and an intervention model. It is designed to be modular and flexible enough to allow modellers and users to represent different strategies and study their impacts in multiple social, epidemiological or economic scenarios. COMOKIT aims at supporting deciders in answering the most pressing of these questions using an integrated model that combines: A sub-model of individual clinical dynamics and epidemiological statusA sub-model of direct transmission of the infection from agent to agentA sub-model of environmental transmission through the built environmentA sub-model of policy and interventions design and implementationAn agenda-based model of people activities at a one-hour time step Website: https://comokit.org/ Contact: Alexis Drogoul  "},{"title":"CITYSCOPE (2016- )​","type":1,"pageTitle":"Projects","url":"wiki/Projects#cityscope-2016--","content":"Description: City Science researchers at the MIT Media Lab are developing CityScope, a tangible and digital platform dedicated to solving spatial design and urban planning challenges. The tools developed range from simulations that quantify the impact of disruptive interventions in cities to communicable collaboration applications. The team develop and deploy these tools around the world in a so-called CityScience Network and maintain open source repositories for the majority of deployments. &quot;CityScope&quot; is a concept for shared, interactive computation for urban planning. In this context GAMA has been used in different applications and projects since 2016, as one of the main agent-based simulation platform for research project aiming at understanding behavioural patterns towards housing and mobility mode in urban policy design. Since 2021, this project is being co-developed between France, Vietnam and USA as part of the EU-funded Marie Curie FellowShip Project, ReAgent  Website: https://www.media.mit.edu/projects/cityscope/overview/ Contact: Arnaud Grignard "},{"title":"TSH-system project (2021-)​","type":1,"pageTitle":"Projects","url":"wiki/Projects#tsh-system-project-2021-","content":"Description:The main objective of the project is to develop decision-making tools to support urban Transport-Spaces-Humans system planning and design. The project aims to assist in: analysing the interdependence between the urban transportation system, public space system, and their users both qualitatively and quantitatively at multiple spatial dimensions;quantifying the impact of architecture layouts and transport-land use plans;predicting the usage of different land uses, activity supports, automobile travel demands, active travel demands, and transport mode choice;supporting the selection of plan scenarios. Publication: Website: https://nmyangliu.wixsite.com/tsh-system Contact: Liu Yang (Research Fellow in the School of Architecture, Southeast University (Nanjing, China)) "},{"title":"LittoSIM / LittoGEN / LittoKong (2015-)​","type":1,"pageTitle":"Projects","url":"wiki/Projects#littosim--littogen--littokong-2015-","content":"Description: LittoSIM is a participatory simulation platform for local actors. The serious game is presented in the form of a simulation integrating both a model of marine submersion, the modeling of actors acting on the territory (defense association, State services, etc.), and game actions performed in situ by elected officials and technicians (municipalities and inter-municipal authorities). The simulation focuses on the southwestern tip of the island of Oléron and offers a reflection on the effects of types of land use planning on the management of the risk of submersion (frontal defenses, modes of urbanization, soft defenses, withdrawal strategic). The game aims to explore different scenarios for managing the risks of submersion, the course of which is induced both by the players' layout choices and by the simulation as such, thus constraining the trajectories of the game. This companion modeling is an opportunity to provide testimony on the learning effects that the game allows for elected officials and managers, and therefore on the apprehension of space and territory in situ by the actors of the development. The LittoSIM project has been extended on several other case studies in France (through the LittoGEN project) and in Vietnam (through the LittoKONG project). Publication: Becu, N., Amalric, M., Anselme, B., Beck, E., Bertin, X., Delay, E., Long, N., Marilleau, N., Pignon-Mussaud, C., Rousseaux, F., 2017. Participatory simulation to foster social learning on coastal flooding prevention. Environ. Model. Softw. 98, 1–11. https://doi.org/10.1016/j.envsoft.2017.09.003 Website: https://littosim.hypotheses.org/ Contact: Nicolas Bécu and Marion Amalric "},{"title":"ESCAPE: Exploring by Simulation Cities Awareness on Population Evacuation (ANR 2016-2020)​","type":1,"pageTitle":"Projects","url":"wiki/Projects#escape-exploring-by-simulation-cities-awareness-on-population-evacuation-anr-2016-2020","content":"Description: A summary is available on the ANR website. Publication: Daudé, E., Chapuis, K., Taillandier, P., Tranouez, P., Caron, C., Drogoul, A., Gaudou, B., Rey-Coyrehourq, S., Saval, A., Zucker, J. D., 2019. ESCAPE: Exploring by Simulation Cities Awareness on Population Evacuation. In ISCRAM 2019 conference, Valencia, Spain. Contact: Eric Daudé  "},{"title":"HoanKiemAir (French Embassy 2019-2020)​","type":1,"pageTitle":"Projects","url":"wiki/Projects#hoankiemair-french-embassy--2019-2020","content":"Description: The development of permanent or temporary pedestrian areas, whether for leisure or to decrease air pollution, has become an integral part of urban planning in numerous cities around the world. Hanoi, the capital of Vietnam, began to implement its first area, around the iconic Hoan Kiem lake, a few years ago. In most cases, however, a road closure is likely to deport traffic to nearby neighborhoods with the consequences of intensifying congestion and, possibly, increasing air pollution in these areas. Because this outcome might appear counter-intuitive to most stakeholders, it is becoming more and more necessary to analyze, assess, and share the impacts of these developments in terms of traffic and pollution shifts before implementing them. In the HoanKiemAir project, we used the GAMA platform to build an agent-based model that simulates the traffic, its emissions of air pollutants, and the diffusion of these pollutants in the district of Hoan Kiem. This simulation has been designed so as to serve either as a decision support tool for local authorities or as an awareness-raising tool for the general public: thanks to its display on a physical 3D model of the district, people can effectively and very naturally interact with it at public venues. Although still in progress, the simulation is already able to reflect traffic and air pollution peaks during rush hours, allowing residents and developers to understand the impact of pedestrianization on air quality in different scenarios. Publication: Duc, P.M., Chapuis, K., Drogoul, A., Gaudou, B., Grignard, A., Marilleau, N. and Nguyen-Huu, T., 2020. HoanKiemAir: simulating impacts of urban management practices on traffic and air pollution using a tangible agent-based model. In 2020 RIVF International Conference on Computing and Communication Technologies (RIVF) (pp. 1-7). IEEE. Contact: Benoit Gaudou  "},{"title":"ACTEUR: Cognitive Territorial Agents for the Study of Urban Dynamics and Risks (ANR 2014-2018)​","type":1,"pageTitle":"Projects","url":"wiki/Projects#acteur-cognitive-territorial-agents-for-the-study-of-urban-dynamics-and-risks-anr-2014-2018","content":"Description: Every year, the number of urban residents is growing. Diverse questions related to sustainability are rise from this growth. For example, for large and attractive territories, which urban planning policies to implement? How to manage and prevent technological or environmental hazards? Decision-makers have to take all of these issues into account when defining their urban planning policies. Unfortunately, the assessment of the impacts of possible policies is difficult due to the complex and stochastic interplay between society and infrastructure. One of the most promising approaches to face this difficulty is agent-based modeling. This approach consists in modeling the studied system as a collection of interacting decision-making entities called agents. An agent-based model can provide relevant information about the dynamics of the real-world urban system it represents. Moreover, it can allow them to be used as a virtual laboratory to test new urban planning policies. The use of agent-based models to study urban systems is booming for the last ten years. Another tendency is the development of more and more realist models. However, if models have to make a lot of progress concerning the integration of geographical and statistical data, the agents used to represent the different actors influencing the dynamic of the system (inhabitants, decision-makers...) are often simplistic (reactive agents). Yet, for some urban models, being able to integrate these cognitive agents, i.e. agents able to make complex reasoning such as planning to achieve their goals, is mandatory to improve the realism of models and test new scenarios. Unfortunately, developing large-scale models that integrate cognitive agents requires high-level programming skills. Indeed, if there are nowadays several software platforms that propose to help modelers to define their agent-based models through a dedicated modeling language (Netlogo, GAMA...) or through a graphical interface (Starlogo TNG, Modelling4All, Repast Symphony, MAGéo...), none of them are adapted to the development of such models by modelers with low-level programming skills: either they are too complex to use (Repast, GAMA) or too limited (Netlogo, Starlogo TNG, Modelling4All, Repast Symphony, MAGéo). As a result, geographers and urban planners that have no programming skills have to rely on computer scientists to develop models, which slows the development and the use of complex and realist spatial agent-based models. The objective of the ACTEUR project is to develop to help modelers, in particular geographers and urban planners, to design and calibrate through a graphical language cognitive agents able to act in a complex spatial environment. The platform has also for ambition to be used as a support of model discussion -participatory modeling- between the different actors concerned by a model (geographers, sociologists, urban planners, decision-makers, representatives...). These tools will be integrated into the GAMA platform that enables us to build large-scale models with thousands of hundreds of agents and that was already used to develop models with cognitive agents. In order to illustrate the utility and the importance of the developed tools, we will use them in two case studies. The first concerns the urban evolution of La Réunion island. The second case study will focus on the adaption to industrial hazards in Rouen. These two case studies are part of funded projects carried out by partners of the ACTEUR project. Website: Contact: Patrick Taillandier "},{"title":"Genstar (ANR 2014-2016)​","type":1,"pageTitle":"Projects","url":"wiki/Projects#genstar--anr-2014-2016","content":"Description: The Gen* project has the ambition to propose tools and methods to generate realistic synthetic populations for agent-based social simulation: it aims at combining applied mathematics and computer science approaches in order to incorporate arbitrary data and to generate statistically valid populations of artificial agents. Publication: Chapuis, K., Taillandier, P., Renaud, M., Drogoul, A. (2018) &quot;Gen*: a generic toolkit to generate spatially explicit synthetic populations&quot;. International Journal of Geographical Information Science 32 (6), 1194-1210 Website: http://www.irit.fr/genstar/ Contact: Alexis Drogoul &amp; Kevin Chapuis  "},{"title":"MAELIA​","type":1,"pageTitle":"Projects","url":"wiki/Projects#maelia","content":"Description: Maelia is a multi-agent platform for integrated assessment and modeling of agricultural territories (landscape) and territorial bioeconomy systems. It enables to assess the environmental, economic and social impacts of the combined changes in agricultural activities, transformation and recycling of biomass, natural resource management strategies (e.g. water) and global (demography, dynamics of land cover and climate changes). Currently, this platform allows to handle at fine spatio-temporal scales the interactions between agricultural activities (rotation and crop management strategies within each production system), the hydrology of the different water resources (based on the SWAT® model's formalisms) and the water resources management (water withdrawals, restrictions, choices between resources). It is currently used to assess the impacts of scenarios (i) of distribution of agro-ecological cropping systems on green and blue water, nitrogen and carbon flows in watersheds, and (ii) of production exchanges between arable and livestock farmers on individual and collective environmental and socio-economic performances. Publication: Gaudou, B., Sibertin-Blanc, C., Thérond, O., Amblard, F., Auda, Y., Arcangeli, J.-P., Balestrat, M., Charron-Moirez, M.-H., Gondet, E., Hong, Y., Lardy, R., Louail, T., Mayor, E., Panzoli, D., Sauvage, S., Sanchez-Perez, J., Taillandier, P., Nguyen, V. B., Vavasseur, M., Mazzega, P. (2014). The MAELIA multi-agent platform for integrated assessment of low-water management issues. In: International Workshop on Multi-Agent-Based Simulation (MABS 2013), Saint-Paul, MN, USA, 06/05/2013-07/05/2013, Vol. 8235, Shah Jamal Alam, H. Van Dyke Parunak, (Eds.), Springer, Lecture Notes in Computer Science, p. 85-110. Website: http://maelia-platform.inra.fr/ Contact: Olivier Thérond  "},{"title":"Preferences","type":0,"sectionRef":"#","url":"wiki/Preferences","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Preferences","url":"wiki/Preferences#table-of-contents","content":"Preferences Opening PreferencesInterfaceEditorsExecutionDisplays Data and OperatorsManage preferences in GAMLAdvanced Preferences "},{"title":"Opening Preferences​","type":1,"pageTitle":"Preferences","url":"wiki/Preferences#opening-preferences","content":"To open the preferences dialog of GAMA, either click on the small &quot;form&quot; button on the top-left corner of the window or select &quot;Preferences...&quot; from the Gama, &quot;Help&quot; or &quot;Views&quot; menu depending on your OS.  "},{"title":"Interface​","type":1,"pageTitle":"Preferences","url":"wiki/Preferences#interface","content":"The Interface pane gathers all the preferences related to the appearance and behavior of the elements of the Graphical User Interface of GAMA.  Startup Display welcome page: if true, and if no editors are opened, the welcome page is displayed when opening GAMA.Maximize GAMA window: if true, the GAMA window is open with the maximal dimensions at startup.Maintain the state of the navigator across sessions: if true, the context of the navigator (project opened, file selected...) will be saved when GAMA is closed and reloaded next start. Menus Break down agents in menu every: when inspecting a large number of agents, this preference sets how many should be displayed before the decision is made to separate the population in sub-menus.Sort operators menu by: among [category, name], this preference sets how the operators should be displayed in the menu &quot;Model&quot; &gt; &quot;Operators&quot; (available only in Modeling perspective, when a model editor is active).Sort colors menu by: among [RGB value, Name, Brightness, Luminescence], this sets how are sorted the colors in the menu &quot;Model&quot; &gt; &quot;Colors&quot; (available only in Modeling perspective, when a model editor is active).Reverse order: if true, reverse the sort order of colors sets above. Group colors: if true, the colors in the previous menu are displays in several sub-menus. Console Max. number of characters to display in the console (-1 means no limit)Max. number of characters to keep when paused (-1 means no limit)Wrap long lines (can slow down output) Simulations Append the name of simulations to their outputs: if true, the name of the simulation is added after the name of the display or monitor (interesting in case of multi-simulations).Color of Simulation X in the UI (console, view tabs): each simulation has a specific color. This is particularly interesting in case of a multi-simulations experiment to identify the displays of each simulation and its console messages. Appearance Highlight in yellow the title of value editors when they changeShapefile viewer fill colorShapefile viewer line colorImage viewer background color: Background color for the image viewer (when you select an image from the model explorer for example)Font of buttons and dialogsDisplay metadata in navigator: if true, GAMA provides some metadata (orange, in parenthesis) after the name of files in the navigator: for a GAML model, it is the number of experiments; for data files, it depends on the kind of data: (for shapefiles) number of objects, CRS and dimensions of the bounding box, (for csv) the dimensions of the table, the delimiter, the data type ... "},{"title":"Editors​","type":1,"pageTitle":"Preferences","url":"wiki/Preferences#editors","content":"Most of the settings and preferences regarding editors can also be found in the advanced preferences.  Options Show warning markers in the editor: if false, the warning will only be available from the Validation View.Show information markers in the editor: if false, the information will only be available from the Validation View.Save all editors when switching perspectivesHide editors when switching to simulation perspectives (can be overridden in the 'layout' statement)Applying formatting on save: if true, every time a model file is saved, its code is formatted.Save all model files before launching an experimentDrag files and resources as references in GAML files: a GAML model file is dropped in another file as an import and other resources as the definition of a variable accessing to this resource. Ask before saving each file Edition Close curly brackets ({)Close square brackets (])Close parenthesesTurn on colorization of code sections: if true, it activates the colorization of code blocks in order to improve the visual understanding of the code structure.Font of editorsBackground color of editorsMark occurrences of symbols: if true, when a symbol is selected, all its other occurrences are also highlighted. Syntax coloring: this section allows the modeler to set the font and color of each GAML keyword kind in the syntax coloring (in any GAMA editor). "},{"title":"Execution​","type":1,"pageTitle":"Preferences","url":"wiki/Preferences#execution","content":"This pane gathers all the preferences related to the execution of experiments, memory management, the errors management, and the parallelism.  Experiments: various settings regarding the execution of experiments. Auto-run experiments when they are launched: see this page.Ask to close the previous simulation before launching a new one: if false, previous simulations (if any) will be closed without warning.Ask to go to fullscreen mode: if true, ask the modeler before switching to the fullscreen mode.Synchronize outputs with the simulation: if true, simulation cycles will wait for the displays to have finished their rendering before passing to the next cycle (this setting can be changed on an individual basis dynamically here). Tests Sorts the results of tests by severityRun tests at each start of the platformInclude user-defined tests in the tests suiteOnly display (in the UI and in headless runs) failed and aborted tests Memory: a given amount of memory (RAM) is allocated to the execution of GAMA (it has to be set in the Gama.ini file). The allocated memory size should be chosen in accordance with the requirements of the model that is developed and the other applications running in your OS. Monitor memory and emit a warning if it is low: a warning will appear during an experiment run when the memory is low.Trigger warnings when the percentage of available memory is belowInterval (in seconds) at which memory should be monitoredIf true, when running out of memory, GAMA will try to close the experiment, otherwise it exits Runtime errors: how to manage and consider simulation errors. Show execution errors: whether errors should be displayed or not.Show errors thrown in displays and outputs: the code defined inside the aspect block of a species will be executed each time the agents are repainted in a display. In particular, when the displays are not synchronized, some errors can occur due to some inconsistency between the model and the display (e.g. drawing a dead agent). As a consequence, the code executed inside an aspect should be limited as much as possible.Number of errors to display: how many errors should be displayed at onceDisplay most recent first: errors will be sorted in the inverse chronological order if true.Stop simulation at first error: if false, the simulations will display the errors and continue (or try to).Treat warnings as errors: if true, no more distinction is made between warnings (which do not stop the simulation) and errors (which can potentially stop it).Automatically open an editor and point at the faulty part of the model if an error or a warning is thrownText color of errorsText color of warnings Parallelism: various settings regarding the parallel execution of experiments. Make experiments run simulations in parallel: if true, in the case of a multi-simulations experiment, the simulation will be executed in parallel (note that the number of simulations that can be executed in parallel will depend on the number of threads to use).Make grids schedule their agents in parallel: the agents of grid species will be executed in parallel. Depending on the model, this could increase the simulation speed, but the modeler cannot have any control over the execution order of the agents.Make species schedule their agents in parallelNumber under which agents are executed sequentiallyMax. number of threads to use (available processors: 8) "},{"title":"Displays​","type":1,"pageTitle":"Preferences","url":"wiki/Preferences#displays","content":" Presentation and Behavior of Graphical Display Views Default layout of display views: among [None, stacked, Split, Horizontal, Vertical]. When an experiment defines several displays, they are by default (layout None) opened in the same View. This preference can set automatically this layout. A layout statement can also be used in experiment to redefine programmatically the layout of display views.Display a border around display viewsContinue to draw displays when in Modeling perspective: if true, when the simulation is running and the modeler chooses to switch to the Modeling perspective the displays are still updated. This is particularly relevant for displays showing plots of data over time.Enable fast snapshots (uncomplete when the display is obscured but much faster)Show the display top toolbar: this could also be configured manually for each display (cf displays related page).Show the display bottom overlay: this could also be configured manually for each display (cf displays related page). Charts Preferences Display 'flat' histograms: if false, the histograms are displayed in a 3D style.Keep values in memory (to save them as csv)Display grid lines: in charts (and in particular series), if true, a grid is displayed in background. Default Rendering Properties: various properties of displays Default rendering method (JavaED fro 2D, OpenGL for 3D): use either 'Java2D' or 'OpenGL' if nothing is specified in the declaration of a display.Apply antialiasing: if true, displays are drawn using antialiasing, which is slower but renders a better quality of image and text (this setting can be changed on an individual basis dynamically here).Default background color: indicates which color to use when none is specified in the declaration of a display.Default highlight color: indicates which color to use for highlighting agents in the displays.Default shape of agents: a choice between shape (which represents the actual geometrical shape of the agent) and geometrical operators (circle, square, triangle, point, cube, sphere etc.) as default shape to display agents when no aspect is defined. Default size of agents: what size to use. This expression must be constant.Default color of agents: what color to use.Default font to use in 'draw' Advanced: Only display visible agents (faster, may create visual oddities)Disable acceleration for Java2D (necessary on some configurations) OpenGL Rendering Properties: various properties specific to OpenGL-based displays Draw 3D axes: if true, the shape of the world and the 3 axes are drawnDraw rotation axes: if true, a sphere appears when rotating the scene to illustrate the rotations.Default line width (facet width of draw): the value is used in draw statement that draws a line without specifying the width facet.Number of slices of circular geometries: when a circular geometry (circle, sphere, cylinder) is displayed, it needs to be discretized in a given number of slices.Set the zoom factor (0 for slow, 1 fast): this determines the speed of the zoom (in and out), and thus its precision.Max. number of frames per secondForces textures dimension to a power of 2 (e.g. 16x16. Necessary on some configurations)Use OpenGL tesselator (false is more precise, but more CPU intensive)Use Numeric Keypad (2,4,6,8) for camera interaction: use these numeric keys to make quick rotations. "},{"title":"Data and Operators​","type":1,"pageTitle":"Preferences","url":"wiki/Preferences#data-and-operators","content":"These preferences pertain to the use of external libraries or data with GAMA.  Http connections Connection timeout (in ms): set the connection timeout when the model tries to access a resource on the web. This value is used to decide when to give up the connection try to an HTTP server in case of response absence.Read timeout (in ms): similar to connection timeout, but related to the time GAMA will wait for a response in case of reading demand.Number of times to retry if connection cannot be establishedEmpty the local cache of files downloaded from the web: if true, after having downloaded the files and used them in the model, the files will be deleted. Random Number Generation: all the options pertaining to generating random numbers in simulations Default random number generator: the name of the generator to use by default (if none is specified in the model).Define a default seed: whether or not a default seed should be used if none is specified in the model (otherwise it is chosen randomly by GAMA)Default seed value (0 is undefined): the value of this default seedInclude in the parameter: whether the choice of generator and seed is included by default in the parameters views of experiments or not. Optimizations Optimize constant expressions (experimental): whether expressions considered as constants should be computed and replaced by their value when compiling models. Allows to save memory and speed, but may cause some problems with complex expressions.Optimize agents memory: whether the memory used by agents is reduced (or not) when their structure appears to be simple: no sub-agents, for instance, because no sub-species is defined. Optimize the 'at_distance' operator: an optimisation that considers the number of elements on each side and changes the loop to consider the fastest case.Optimize the path computation operators and goto action (but with possible 'jump' issues): when an agent is not already on a path, simplifies its choice of the closest segment to choose and makes it jump directly on it rather than letting it move towards the segment. Optimize spatial queries: add agents only when necessary in the quadtree (still experimental): if no queries is conducted against a species of agents, then it is not necessary to maintain them in the global quad tree. Forces the spatial index to synchronize its operations. Useful for interactive models where the user may interfere.: when true, forces the quadtree to use concurrent data structures and to synchronize reads and writes, allowing users to interact with the simulation without raising concurrent modification errors.Use object pooling to reduce memory usage (still experimental): when true, tries to reuse the same common objects (lists, maps, etc.) over and over rather than creating new ones. Tolerance for the comparison of points: depending on the way they are computed, 2 points who should be the same, could not be equal. This preference allows to be more tolerant in the way points are compared. External libraries support Path to Spatialite (http://www.gaia-gis.it/gaia-sins/): the path toward the spatial extension for the SQLite database. Path to JRI library ($R_HOME/library/rJava/jri/libjri.jnilib) (http://www.r-project.org): when we need to couple GAMA and R, we need to set properly the path toward this file. GIS Coordinate Reference Systems (http://spatialreference.org/ref/epsg/ for EPSG codes): settings about CRS to use when loading or saving GIS files Let GAMA decide which CRS to use to project GIS data: if true, GAMA will decide which CRS, based on input, should be used to project GIS data. Default is true (i.e. GAMA will always try to find the relevant CRS, and, if none can be found, will fall back one the one provided below)...or use the following CRS (EPSG code): choose a CRS that will be applied to all GIS data when projected in the models. Please refer to http://spatialreference.org/ref/epsg/ for a list of EPSG codes. If the option above is false, then the use of this CRS will be enforced in all models.Otherwise, GAMA will first try to find the most relevant CRS and then fall back on this one. When no .prj file or CRS is supplied, consider GIS data to be already projected in the CRS: if true, GIS data that is not accompanied by a CRS information will be considered as projected using the above code....or use the following CRS (EPSG code): choose a CRS that will represent the default code for loading uninformed GIS data.When no CRS is provided, save the GIS data with the current CRS: if true, saving GIS data will use the projected CRS unless a CRS is provided....or use the following CRS (EPSG code): otherwise, you might enter a CRS to use to save files. Management of dates: some preferences for default values related to the dates in GAMA. Custom date pattern (https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimerFormatter.html#patterns)Default date pattern for writing dates (i.e. string(date1))Default starting date of models: set the default value of the global variable starting_date.Default time step of models: define the default duration of a simulation step, i.e. the value of the variable step (by default, it is set to 1s). "},{"title":"Manage preferences in GAML​","type":1,"pageTitle":"Preferences","url":"wiki/Preferences#manage-preferences-in-gaml","content":"All these preferences can be accessed (set or read) directly in a GAML model. To share your preferences with others (e.g. when you report an issue), you can simply export your preferences in a GAML model. Importing preferences will set your preferences from an external GAML file.  When you export your preferences, the GAML file will look like the following code. It contains 2 experiments: one to display all the preferences in the console and the other one to set your preferences will the values written in the model. model preferences experiment 'Display Preferences' type: gui { init { //Append the name of simulations to their outputs write sample(gama.pref_append_simulation_name); //Display grid lines write sample(gama.pref_chart_display_gridlines); //Monitor memory and emit a warning if it is low write sample(gama.pref_check_memory); //Max. number of characters to keep when paused (-1 = unlimited) write sample(gama.pref_console_buffer); //Max. number of characters to display (-1 = unlimited) write sample(gama.pref_console_size); //Wrap long lines (can slow down output) write sample(gama.pref_console_wrap); //Custom date pattern (https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns) write sample(gama.pref_date_custom_formatter); // ...  "},{"title":"Advanced Preferences​","type":1,"pageTitle":"Preferences","url":"wiki/Preferences#advanced-preferences","content":"The set of preferences described above are specific to GAMA. But there are other preferences or settings that are inherited from the Eclipse underpinnings of GAMA, which concern either the &quot;core&quot; of the platform (workspace, editors, updates, etc.) or plugins (like SVN, for instance) that are part of the distribution of GAMA. These &quot;advanced&quot; preferences are accessible by clicking on the &quot;Advanced...&quot; button in the Preferences view.  Depending on what is installed, the second view that appears will contain a tree of options on the left and preference pages on the right. Contrary to the first set of preferences, please note that these preferences will be saved in the current workspace, which means that changing workspace will revert them to their default values. It is, however, possible to import them in the new workspace using of the wizards provided in the standard &quot;Import...&quot; command (see here).  "},{"title":"Pseudo-variables","type":0,"sectionRef":"#","url":"wiki/PseudoVariables","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Pseudo-variables","url":"wiki/PseudoVariables#table-of-contents","content":"Pseudo-variables selfmyselfeachsuper "},{"title":"self​","type":1,"pageTitle":"Pseudo-variables","url":"wiki/PseudoVariables#self","content":"The pseudo-variable self always holds a reference to the agent executing the current statement. Example (sets the friend attribute of another random agent of the same species to self and conversely): friend potential_friend &lt;- one_of (species(self) - self); if potential_friend != nil { potential_friend.friend &lt;- self; friend &lt;- potential_friend; }  "},{"title":"super​","type":1,"pageTitle":"Pseudo-variables","url":"wiki/PseudoVariables#super","content":"The pseudo-variable super behaves exactly in the same way as self except when calling an action, in which case it represents an indirection to the parent species. It is mainly used for allowing to call inherited actions within redefined ones. For instance: species parent { int add(int a, int b) { return a + b; } } species child parent: parent { int add(int a, int b) { // Calls the action defined in 'parent' with modified arguments return super.add(a + 20, b + 20); } }  "},{"title":"myself​","type":1,"pageTitle":"Pseudo-variables","url":"wiki/PseudoVariables#myself","content":"myself plays the same role as self but in remotely-executed code (ask, create, capture and release statements), where it represents the calling agent when the code is executed by the remote agent. Example (asks the first agent of my species to set its color to my color): ask first (species (self)){ color &lt;- myself.color; }  Example (create 10 new agents of the species of my species, share the energy between them, turn them towards me, and make them move 4 times to get closer to me): create species (self) number: 10 { energy &lt;- myself.energy / 10.0; loop times: 4 { heading &lt;- towards (myself); do move; } }  "},{"title":"each​","type":1,"pageTitle":"Pseudo-variables","url":"wiki/PseudoVariables#each","content":"each is available only in the right-hand argument of iterators. It is a pseudo-variable that represents, in turn, each of the elements of the left-hand container. It can then take any type depending on the context. Example:  list&amp;lt;string&gt; names &lt;- my_species collect each.name; // each is of type my_species int max &lt;- max(['aa', 'bbb', 'cccc'] collect length(each)); // each is of type string  "},{"title":"Recipes","type":0,"sectionRef":"#","url":"wiki/Recipes","content":"Recipes Understanding the structure of models in GAML and gaining some insight of the language is required, but is usually not sufficient to build correct models or models that need to deal with specific approaches (like equation-based modeling). This section is intended to provide readers with practical &quot;how to&quot;s on various subjects, ranging from the use of database access to the design of agent communication languages. It is by no means exhaustive, and will progressively be extended with more &quot;recipes&quot; in the future, depending on the concrete questions asked by users.","keywords":""},{"title":"Regular species","type":0,"sectionRef":"#","url":"wiki/RegularSpecies","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"Regular species","url":"wiki/RegularSpecies#index","content":"DeclarationBuilt-in AttributesSpecies built-in AttributesBuilt-in ActionsThe init statementThe aspect statementInstantiate an agent "},{"title":"Declaration​","type":1,"pageTitle":"Regular species","url":"wiki/RegularSpecies#declaration","content":"The regular species declaration starts with the keyword species followed by the name (or followed by the facet name:) : species my_specie { }  Directly in the &quot;species&quot; scope, you have to declare all your attributes (or &quot;member&quot; in OOP). You declare them exactly the way you declare basic variables. Those attributes are accessible wherever you want inside the species scope. species my_specie { int variableA; }  "},{"title":"Built-in attributes​","type":1,"pageTitle":"Regular species","url":"wiki/RegularSpecies#built-in-attributes","content":"As for the global species, some attributes exist already by default in a regular species. Here is the list of built-in attributes: name (type: string) is used to name your agent. By default, the name is equal to the name of your species + an incremental number. This name is the one visible on the species inspector.location (type: point) is used to control the position of your agent. It refers to the center of the envelope of the shape associated with the agent.shape (type: geometry) is used to describe the geometry of your agent. If you want to use some intersection operator between agents, for instance, it is this geometry that is computed (nb: it can be totally different from the aspect you want to display for your agent!). By default, the shape is a point.host (type: agent) is used when your agent is part of another agent. We will see this concept a bit further, in the topic multi-level architecture.members (type: list of agents) contain the agents for the population(s) of which the receiver agent is a direct host. All those built-in attributes can be accessed in both reading and writing very easily: species my_species { init { name &lt;- &quot;custom_name&quot;; location &lt;- {0,1}; shape &lt;- rectangle(5,1); } }  All those built-in attributes are attributes of an agent (an instance of a species). Notice that the world agent is also an agent! It has all the built-in attributes declared above. The world agent is defined inside the global scope. From the global scope then, you can for example access to the center of the envelope of the world shape: global { init { write location; // writes {50.0,50.0,0.0} } }  "},{"title":"Species built-in Attributes​","type":1,"pageTitle":"Regular species","url":"wiki/RegularSpecies#species-built-in-attributes","content":"Species have also their own attributes, which can be accessed with the following syntax (read-only) : name_of_your_species.attribute_you_want  Here is the list of those attributes: name: (type: string) returns the name of your species.attributes: (type: list of string) returns the list of the names of the attributes of your species.actions: (type: list of string) returns the list of the names of the actions defined in your species.aspects: (type: list of string) returns the list of the names of the aspects defined in your species.population: (type: list) returns the list of agents that belong to this species.subspecies: (type: list of string) returns the list of species that inherit directly from this species (we will talk about the concept of inheritance later)parent (type: species) returns its parent species if it belongs to the model, or nil otherwise (we will talk about the concept of inheritance later) As an example, the following code illustrates all these attributes: model NewModel global { init { create my_species ; } } species my_species { int att1; init { create my_micro_species; write species(self).name; // write in the console: my_species write species(self).attributes; // write in the console: ['name','shape','location','peers','host','agents','members','att1','my_micro_species'] write species(self).actions; // write in the console: ['a1','a2','die','debug','_step_','tell','_init_','error','write'] write species(self).aspects; // write in the console: ['asp1] write species(self).population; // write in the console: [my_species(0)] write species(self).subspecies; // write in the console: [] write species(self).microspecies; // write in the console: [my_micro_species] write species(self).parent; // write in the console: nil } reflex r1 {} reflex r2 {} action a1 {} action a2 {} species my_micro_species {} aspect asp1 {} } experiment name type: gui {}  "},{"title":"Built-in actions​","type":1,"pageTitle":"Regular species","url":"wiki/RegularSpecies#built-in-actions","content":"Some actions are defined by default for a minimal agent. We already saw quickly the action write, used to display a message in the console. Another very useful built-in action is the action die, used to destroy an agent. species my_species{ reflex being_killed { do debug(&quot;I will disappear from the simulation&quot;); do die; } }  Here is the list of the other built-in actions which you can find in the documentation: debug, tell, _init_, and _step_. The 2 actions _init_and _step_ are very important, as they allow the modeler to change totally the agents' dynamics: when the action _init_ is defined in a species, it will be called instead of the init block.when the action _step_ is defined in a species, it will be called at each simulation step instead of the species' behaviors (e.g. instead of the reflexes blocks). "},{"title":"The init statement​","type":1,"pageTitle":"Regular species","url":"wiki/RegularSpecies#the-init-statement","content":"After declaring all the attributes of your species, you can define an initial state (before launching the simulation). It can be seen as the &quot;constructor of the class&quot; in OOP. species my_species { int variableA; init { variableA &lt;- 5; } }  "},{"title":"The aspect statement​","type":1,"pageTitle":"Regular species","url":"wiki/RegularSpecies#the-aspect-statement","content":"Inside each species, you can define one or several aspects. This block allows you to define how you want your species to be represented in the simulation. Each aspect has a special name (so that they can be called from the experiment). Once again, you can name your aspect by using the facet name:, or simply by naming it just after the aspect keyword. species my_species { aspect standard_aspect { } }  You can then define your aspect by using the statement draw. You can then choose a geometry for your aspect, an image, a text (facet text), and its color (facet color)... It is common to have several draw statement in an aspect to enrich its display. We invite you to read the documentation about the draw statement to know more about. species my_species { aspect standard_aspect { draw circle(1) color:#blue border: #black; } }  In the experiment block, you have to tell the program to display a particular species with a particular aspect (nb: you can also choose to display your species with several aspects in the same display). experiment my_experiment type: gui { output{ display my_display { species my_species aspect:standard_aspect; } } }  Now there is only one thing missing to display our agent: we have to instantiate them. "},{"title":"Instantiate an agent​","type":1,"pageTitle":"Regular species","url":"wiki/RegularSpecies#instantiate-an-agent","content":"As already said quickly in the last session, the instantiation of the agents is most often in the init scope of the global species (this is not mandatory of course. You can instantiate your agents from an action/behavior of any species). Use the statement create to instantiate an agent: The first element given to the create statement (i.e. the facet species) is used to specify which species you want to instantiate. The facet number is used to tell how many agents you want to create. The facet with is used to specify some default values for some attributes of your instance. For example, you can specify the location. global { init{ create my_species number: 1 with: (location:{0,0},vA:8); } } species my_species { int vA; }  Here is an example of a model that displays an agent with a circle aspect in the center of the environment: model display_one_agent global{ float worldDimension &lt;- 50#m; geometry shape &lt;- square(worldDimension); init{ point center &lt;- {worldDimension/2,worldDimension/2}; create my_species number: 1 with: (location:center); } } species my_species { aspect standard_aspect { draw circle(1#m); } } experiment my_experiment type:gui { output{ display myDisplay { species my_species aspect:standard_aspect; } } }  "},{"title":"Scientific References","type":0,"sectionRef":"#","url":"wiki/References","content":"","keywords":""},{"title":"Table of Contents​","type":1,"pageTitle":"Scientific References","url":"wiki/References#table-of-contents","content":"Papers about GAMAHDR thesesPhD thesesPhD theses that use GAMA as modeling/simulation supportMaster theses that use GAMA as modeling/simulation supportResearch papers that use GAMA as modeling/simulation support "},{"title":"Papers about GAMA​","type":1,"pageTitle":"Scientific References","url":"wiki/References#papers-about-gama","content":"Taillandier, P., Grignard, A., Marilleau, N., Philippon, D., Huynh Q.N., Gaudou, B., Drogoul, A. (2019) &quot;Participatory Modeling and Simulation with the GAMA Platform&quot;. Journal of Artificial Societies and Social Simulation 22 (2), 1-3. DOI: 10.18564/jasss.3964Caillou, P., Gaudou, B., Grignard, A., Truong, C.Q., Taillandier, P. (2017) A Simple-to-Use BDI Architecture for Agent-Based Modeling and Simulation, in: Advances in Social Simulation 2015. Springer, Cham, pp. 15–28. doi:10.1007/978-3-319-47253-9_2Chapuis, K., Taillandier, P., Renaud, M., Drogoul, A. (2018) &quot;Gen*: a generic toolkit to generate spatially explicit synthetic populations&quot;. International Journal of Geographical Information Science 32 (6), 1194-1210Taillandier, Patrick, Arnaud Grignard, Benoit Gaudou, and Alexis Drogoul. &quot;Des données géographiques à la simulation à base d’agents: application de la plate-forme GAMA.&quot; Cybergeo: European Journal of Geography (2014).Grignard, A., Taillandier, P., Gaudou, B., Vo, D-A., Huynh, Q.N., Drogoul, A. (2013) GAMA 1.6: Advancing the Art of Complex Agent-Based Modeling and Simulation. In ‘PRIMA 2013: Principles and Practice of Multi-Agent Systems', Lecture Notes in Computer Science, Vol. 8291, Springer, pp. 117-131.Grignard, A., Drogoul, A., Zucker, J.D. (2013) Online analysis and visualization of agent based models, Computational Science and Its Applications–ICCSA 2013. Springer Berlin Heidelberg, 2013. 662-672. Taillandier, P., Drogoul, A., Vo, D.A. and Amouroux, E. (2012) GAMA: a simulation platform that integrates geographical information data, agent-based modeling and multi-scale control, in 'The 13th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA)', India, Volume 7057/2012, pp 242-258.Taillandier, P., Drogoul, A. (2011) From Grid Environment to Geographic Vector Agents, Modeling with the GAMA simulation platform. In ‘25th Conference of the International Cartographic Association’, Paris, France.Taillandier, P., Drogoul A., Vo D.A., Amouroux, E. (2010) GAMA : bringing GIS and multi-level capabilities to multi-agent simulation, in 'the 8th European Workshop on Multi-Agent Systems', Paris, France.Amouroux, E., Taillandier, P. &amp; Drogoul, A. (2010) Complex environment representation in epidemiology ABM: application on H5N1 propagation. In ‘the 3rd International Conference on Theories and Applications of Computer Science’ (ICTACS'10).Amouroux, E., Chu, T.Q., Boucher, A. and Drogoul, A. (2007) GAMA: an environment for implementing and running spatially explicit multi-agent simulations. In ‘Pacific Rim International Workshop on Multi-Agents', Bangkok, Thailand, pp. 359--371. "},{"title":"HDR theses​","type":1,"pageTitle":"Scientific References","url":"wiki/References#hdr-theses","content":"Patrick Taillandier, &quot;Vers une meilleure intégration des dimensions spatiales, comportementales et participatives en simulation à base d'agents&quot;, University Toulouse 1 Capitole, France 2019.Benoit Gaudou, &quot;Toward complex models of complex systems - One step further in the art of Agent-Based Modelling&quot;, University Toulouse 1 Capitole, France 2016.Nicolas Marilleau, &quot;Distributed Approaches based on Agent Based Systems to model and simulate complex systems with a space&quot;, Pierre and Marie Curie University, Paris, France 2016. "},{"title":"PhD theses​","type":1,"pageTitle":"Scientific References","url":"wiki/References#phd-theses","content":"Mathieu Bourgais, &quot;Vers des agents cognitifs, affectifs et sociaux dans la simulation&quot;, Normandie Université, defended November 30th, 2018.Huynh Quang Nghi, &quot;CoModels, engineering dynamic compositions of coupled models to support the simulation of complex systems&quot;, University of Paris 6, defended December 5th, 2016.Truong Chi Quang, &quot;Integrating cognitive models of human decision-makingin agent-based models : an application to land useplanning under climate change in the Mekong river delta&quot;, University of Paris 6 &amp; Can Tho University, defended December 7th, 2016.Arnaud Grignard, &quot;Modèles de visualisation à base d'agents&quot;, University of Paris 6, defended October 2nd, 2015.Truong Minh Thai, &quot;To Develop a Database Management Tool for Multi-Agent Simulation Platform&quot;, 'Université Toulouse 1 Capitole, defended February 11th, 2015.Truong Xuan Viet, &quot;Optimization by Simulation of an Environmental Surveillance Network: Application to the Fight against Rice Pests in the Mekong Delta (Vietnam)&quot;, University of Paris 6 &amp; Ho Chi Minh University of Technology, defended June 24th, 2014.Nguyen Nhi Gia Vinh, &quot;Designing multi-scale models to support environmental decision: application to the control of Brown Plant Hopper invasions in the Mekong Delta (Vietnam)&quot;, University of Paris 6, defended Oct. 31st, 2013.Vo Duc An, &quot;An operational architecture to handle multiple levels of representation in agent-based models&quot;, University of Paris 6, defended Nov. 30th 2012.Edouard Amouroux, &quot;KIMONO: a descriptive agent-based modeling methodology for the exploration of complex systems: an application to epidemiology&quot;, University of Paris 6, defended Sept. 30th, 2011.Chu Thanh Quang, &quot;Using agent-based models and machine learning to enhance spatial decision support systems: Application to resource allocation in situations of urban catastrophes&quot;, University of Paris 6, defended July 1st, 2011.Nguyen Ngoc Doanh, &quot;Coupling Equation-Based and Individual-Based Models in the Study of Complex Systems: A Case Study in Theoretical Population Ecology&quot;, University of Paris 6, defended Dec. 14th, 2010. "},{"title":"PhD theses that use GAMA as modeling/simulation support​","type":1,"pageTitle":"Scientific References","url":"wiki/References#phd-theses-that-use-gama-as-modelingsimulation-support","content":"Robin Cura, &quot;Modéliser des systèmes de peuplement en interdisciplinarité. Co-construction et exploration visuelle d'un modèle de simulation&quot;, Université Paris 1 Panthéon-Sorbonne, defended March 6th, 2020.Alice Micolier, &quot;Development of a methodology for a consistent and integrated evaluation of the health, energy and environmental performance of residential building design solutions&quot;, Université de Bordeaux, defended December 13th,2019.Dimitrios Panagiotis Chapizanis, &quot;Exposomic analysis: emerging methodologies for environmental exposure measurements&quot;, Aristotle University of Thessaloniki, 2019.Julius Bañgate, &quot;Multi-Agent Modelling of seismic crisis&quot;, Université Grenoble Alpes, defended December 18th, 2019.Johan Arcile, &quot;Conception, modélisation et vérification formelle d’un système temps-réel d’agents coopératifs Application aux véhicules autonomes communicants&quot;, Université Paris-Saclay, defended December 13th, 2019.Mélodie DUBOIS, &quot;Effets combinés de la pêche et des perturbations naturelles sur la dynamique des écosystèmes coralliens&quot;, Université de recherche Paris Sciences et Lettres, defended Mai 24th, 2019.Allan Lao, &quot;Agent-Based Mesoscopic Pedestrian Modeling and Simulation&quot;, University of the Cordilleras, defended in February, 2019.Jérémy Sobieraj, Méthodes et outils pour la conception de Systèmes de Transport Intelligents Coopératifs, Université Paris-Saclay; Université d’Evry-Val-d’Essonne, defended November 7th, 2018.Myriam Grillot, Modélisation multi-agents et pluri-niveaux de la réorganisation du cycle de l’azote dans des systèmes agro-sylvo-pastoraux en transition : Le cas du bassin arachidier au Sénégal, IRD, defended March 16th, 2018.Mahefa Rakotoarisoa, Les risques hydrologiques dans les bassins versants sous contrôle anthropique : modélisation de l'aléa, de la vulnérabilité et des conséquences sur les sociétés. : Cas de la région Sud-ouest de Madagascar, Univeristé d'Angers et Université de Tuléa, defended in December, 2017.Justin Emery, La ville sous électrodes : de la mesure à l'évaluation de la pollution atmosphérique automobile. : vers une simulation multi-agents du trafic routier en milieu urbain, Université de Bourgogne-Franche-Comté, defended December 16th, 2016.Hugo Thierry, &quot;Élaboration d'un modèle spatialisé pour favoriser le contrôle biologique de ravageurs de cultures par gestion du paysage agricole&quot;, INPT, defended November 11th, 2015. Inès Hassoumi, Approche multi-agents de couplage de modèles pour la modélisation des systèmes complexes spatiaux. Application à l'aménagement urbain de la ville de Métouia, Université Pierre et Marie Curie – Paris VI et université de Tunis, defended December, 2014. "},{"title":"Master theses that use GAMA as modeling/simulation support​","type":1,"pageTitle":"Scientific References","url":"wiki/References#master-theses-that-use-gama-as-modelingsimulation-support","content":""},{"title":"2020​","type":1,"pageTitle":"Scientific References","url":"wiki/References#2020","content":"Claerhoudt, X. &quot;How opinion leaders can manipulate opinion dynamics in hierarchical social networks&quot;, Master's thesis, Ghent University, 2020.Doelman, V. J. &quot;An agent-based approach to the assessment of carrying capacity in Amsterdam&quot;, Master's thesis, GIMA program, Utrecht University, 2020.de Maat, N.B., 2020. &quot;Improving traffic system performance by combining tolling and intention-based prediction: an agent-based model&quot;, Master's thesis, GIMA program, Utrecht University, 2020. "},{"title":"Research papers that use GAMA as modeling/simulation support​","type":1,"pageTitle":"Scientific References","url":"wiki/References#research-papers-that-use-gama-as-modelingsimulation-support","content":""},{"title":"2021​","type":1,"pageTitle":"Scientific References","url":"wiki/References#2021","content":"Bhowmick, D., Winter, S., Stevenson, M. and Vortisch, P., 2021. Exploring the viability of walk-sharing in outdoor urban spaces. Computers, Environment and Urban Systems, 88, p.101635.Polanco, L.D. and Siller, M., 2021. Crowd management COVID-19. Annual Reviews in Control.Taillandier, P., Salliou, N. and Thomopoulos, R., 2021. Introducing the Argumentation Framework Within Agent-Based Models to Better Simulate Agents' Cognition in Opinion Dynamics: Application to Vegetarian Diet Diffusion. Journal of Artificial Societies and Social Simulation, 24(2).Kaziyeva, D., Loidl, M. and Wallentin, G., 2021. Simulating Spatio-Temporal Patterns of Bicycle Flows with an Agent-Based Model. ISPRS International Journal of Geo-Information, 10(2), p.88.Ramos Corchado, F.F., López Fraga, A.C., Salazar Salazar, R., Ramos Corchado, M.A. and Begovich Mendoza, O., 2021. Cognitive Pervasive Service Composition Applied to Predatory Crime Deterrence. Applied Sciences, 11(4), p.1803.Salze, P., Sajous, P. and Bertelle, C., 2021. EM3: A Model to Explore the Effects of Ecomobility Policies on an Urban Area. In Complex Systems, Smart Territories and Mobility (pp. 233-256). Springer, Cham.Zaatour, W., Marilleau, N., Giraudoux, P., Martiny, N., Amara, A.B.H. and Miled, S.B., 2021. An agent-based model of a cutaneous leishmaniasis reservoir host, Meriones shawi. Ecological Modelling, 443, p.109455.Catarino, R., Therond, O., Berthomier, J., Miara, M., Mérot, E., Misslin, R., Vanhove, P., Villerd, J. and Angevin, F., 2021. Fostering local crop-livestock integration via legume exchanges using an innovative integrated assessment and modelling approach based on the MAELIA platform. Agricultural Systems, 189, p.103066.Chapizanis, D., Karakitsios, S., Gotti, A. and Sarigiannis, D.A., 2021. Assessing personal exposure using Agent Based Modelling informed by sensors technology. Environmental Research, Volume 192, p.110141.Hutzler G., Klaudel H., Sali A. (2021) Filtering Distributed Information to Build a Plausible Scene for Autonomous and Connected Vehicles. In: Dong Y., Herrera-Viedma E., Matsui K., Omatsu S., González Briones A., Rodríguez González S. (eds) Distributed Computing and Artificial Intelligence, 17th International Conference. DCAI 2020. Advances in Intelligent Systems and Computing, vol 1237. Springer, Cham. "},{"title":"2020​","type":1,"pageTitle":"Scientific References","url":"wiki/References#2020-1","content":"Callejas, E., Inostrosa-Psijas, A., Moreno, F., Oyarzún, M. and Carvajal-Schiaffino, R., 2020, November. COVID-19 Transmission During a Tsunami Evacuation in a Lockdown City. In 2020 39th International Conference of the Chilean Computer Science Society (SCCC) (pp. 1-8). IEEE.Barthelemy, J., Amirghasemi, M., Arshad, B., Fay, C., Forehead, H., Hutchison, N., Iqbal, U., Li, Y., Qian, Y. and Perez, P., 2020. Problem-Driven and Technology-Enabled Solutions for Safer Communities: The case of stormwater management in the Illawarra-Shoalhaven region (NSW, Australia). Handbook of Smart Cities, pp.1-28.Zhong, J. and Hattori, H., 2020. Generation of Traffic Flows in Multi-Agent Traffic Simulation with Agent Behavior Model based on Deep Reinforcement Learning. arXiv preprint arXiv:2101.03230.Dang-Huu, T., Gaudou, B., Nguyen-Ngoc, D. and Lê, N.C., 2020, November. An agent-based model for mixed traffic in Vietnam based on virtual local lanes. In 2020 12th International Conference on Knowledge and Systems Engineering (KSE) (pp. 147-152). IEEE.Grignard, A., Nguyen-Huu, T., Gaudou, B., Nguyen-Ngoc, D., Brugière, A., Dang-Huu, T., Nghi, H.Q., Khanh, N.T. and Larson, K., 2020, November. CityScope Hanoi: interactive simulation for water management in the Bac Hung Hai irrigation system. In 2020 12th International Conference on Knowledge and Systems Engineering (KSE) (pp. 153-158). IEEE.da Silva Rodrigues, L., Oliveira, S.G.M., Lopez, L.F. and Sichman, J.S., 2019, May. Agent Based Simulation of the Dengue Virus Propagation. In International Workshop on Multi-Agent Systems and Agent-Based Simulation (pp. 100-111). Springer, Cham.Prudhomme, C., Cruz, C. and Cherifi, H., 2020, An Agent based model for the transmission and control of the COVID-19 in Dijon. In Proc. of The 11th Conference on Network Modeling and Analysis MARAMI, October 14 - 15, 2020Taj, F., Klein, M. and van Halteren, A., 2020, October. An Agent-Based Framework for Persuasive Health Behavior Change Intervention. In International Conference on Health Information Science (pp. 157-168). Springer, Cham.Gaudou, B., Huynh, N.Q., Philippon, D., Brugière, A., Chapuis, K., Taillandier, P., Larmande, P. and Drogoul, A., 2020. COMOKIT: a modeling kit to understand, analyze and compare the impacts of mitigation policies against the COVID-19 epidemic at the scale of a city. Frontiers in Public Health, 8, p.587.Drogoul, A., Taillandier, P., Gaudou, B., Choisy, M., Chapuis, K., Huynh, Q.N., Nguyen, N.D., Philippon, D., Brugière, A. and Larmande, P., Designing social simulation to (seriously) support decision-making: COMOKIT, an agent-based modelling toolkit to analyse and compare the impacts of public health interventions against COVID-19. Review of Artificial Societies and Social Simulation, 27th April 2020.Bucchiarone, A., De Sanctis, M. and Bencomo, N., 2020. Agent-Based Framework for Self-Organization of Collective and Autonomous Shuttle Fleets. IEEE Transactions on Intelligent Transportation Systems.Iskandar, R., Allaw, K., Dugdale, J., Beck, E., Adjizian-Gérard, J., Cornou, C., Harb, J., Lacroix, P., Badaro-Saliba, N., Cartier, S. and Zaarour, R., 2020, Agent-Based simulation of pedestrians’earthquake evacuation; application to Beirut, Lebanon. In 17th World Conference on Earthquake Engineering, 17WCEE, Sendai, JapanLee, L.W.F. and Mohd, M.H., 2020, October. Stochastic modelling of the biodiversity effect on sin nombre virus (SNV) prevalence. In AIP Conference Proceedings (Vol. 2266, No. 1, p. 050017). AIP Publishing LLC.Ngom, B., Diallo, M. and Marilleau, N., 2020, September. MEDART-MAS: MEta-model of Data Assimilation on Real-Time Multi-Agent Simulation. In 2020 IEEE/ACM 24th International Symposium on Distributed Simulation and Real Time Applications (DS-RT) (pp. 1-7). IEEE.Alonso Vicario, S., Mazzoleni, M., Bhamidipati, S., Gharesifard, M., Ridolfi, E., Pandolfo, C., Alfonso, L., 2020. Unravelling the influence of human behaviour on reducing casualties during flood evacuation. Hydrological Sciences Journal.Tannier C., Cura R., Leturcq S. and Zadora-Rio E., 2020. An agent-based model for exploring the combined effects of social and demographic changes on the concentration and hierarchy of rural settlement patterns in North-Western Europe during the Middle Ages (800–1200 CE). Journal of Anthropological Archaeology, vol. 59.Wallentin, G., Kaziyeva, D., Reibersdorfer-Adelsberger, E., 2020. COVID-19 Intervention Scenarios for a Long-term Disease Management, International Journal of Health Policy and Management, (), pp. -.Duc, P.M., Chapuis, K., Drogoul, A., Gaudou, B., Grignard, A., Marilleau, N. and Nguyen-Huu, T., 2020. HoanKiemAir: simulating impacts of urban management practices on traffic and air pollution using a tangible agent-based model. In 2020 RIVF International Conference on Computing and Communication Technologies (RIVF) (pp. 1-7). IEEE.Laatabi, A., Becu, N., Marilleau, N., Pignon-Mussaud, C., Amalric, M., Bertin, X., Anselme, B. and Beck, E., 2020. Mapping and Describing Geospatial Data to Generalize Complex Models: The Case of LittoSIM-GEN. International Journal of Geospatial and Environmental Research, 7(1), p.6.Farias, G., Leitzke, B., Born, M., Aguiar, M. and Adamatti, D., 2020. Water Resources Analysis: An Approach based on Agent-Based Modeling. Revista de Informática Teórica e Aplicada, 27(2), pp.81-95.Baeza, J.L., Noennig, J.R., Weber, V., Grignard, A., Noyman, A., Larson, K., Saxe, S. and Baldauf, U., 2020. Mobility Solutions for Cruise Passenger Transfer: An Exploration of Scenarios Using Agent-Based Simulation Models. In Towards User-Centric Transport in Europe 2 (pp. 89-101). Springer, Cham.Jindal, A. and Rao, S., 2020. Lockdowns to Contain COVID-19 Increase Risk and Severity of Mosquito-Borne Disease Outbreaks. medRxiv.Haddad, H., Bouyahia, Z. and Jabeur, N., 2020. Socially-Structured Vanpooling: A Case Study in Salalah, Oman. IEEE Intelligent Transportation Systems Magazine.Mariano, D.J.K. and Alves, C.D.M.A., 2020. The application of role-playing games and agent-based modelling to the collaborative water management in peri-urban communities. RBRH, 25.Emery, J., Marilleau, N., Martiny, N., &amp; Thévenin, T., 2020. Le modèle SCAUP: Simulation multi-agents à partir de données de CApteurs Urbains pour la Pollution atmosphérique automobile. Cybergeo: European Journal of Geography.Taj, F., Klein11, M. C., van Halteren, A., 2020. Towards a generic framework for a health behaviour change support agent. In ICAART (1) (pp. 311-318)Thierry, H. and Rogers, H., 2020. Where to rewild? A conceptual framework to spatially optimize ecological function. Proceedings of the Royal Society B, 287(1922), p.20193017.Baeza, J.L., Noennig, J.R., Weber, V., Grignard, A., Noyman, A., Larson, K., Saxe, S. and Baldauf, U., 2020. Mobility Solutions for Cruise Passenger Transfer: An Exploration of Scenarios Using Agent-Based Simulation Models. In Towards User-Centric Transport in Europe 2 (pp. 89-101). Springer, Cham.Galimberti, A., Alyokhin, A., Qu, H. and Jason, R.O.S.E., 2020. Simulation modelling of potato virus Y spread in relation to initial inoculum and vector activity. Journal of Integrative Agriculture, 19(2), pp.376-388.Daudé, É. and Tranouez, P., 2020. ESCAPE–SG: un simulateur d’évacuation massive de population pour la formation des acteurs à la gestion de crise. Netcom. Réseaux, communication et territoires. "},{"title":"2019​","type":1,"pageTitle":"Scientific References","url":"wiki/References#2019","content":"Démare, T., Bertelle, C., Dutot, A. and Fournier, D., 2019. Adaptive behavior modeling in logistic systems with agents and dynamic graphs. ACM Transactions on Autonomous and Adaptive Systems (TAAS), 13(3), pp.1-25.Olszewski, R., Pałka, P., Turek, A., Kietlińska, B., Płatkowski, T. and Borkowski, M., 2019. Spatiotemporal Modeling of the Smart City Residents’ Activity with Multi-Agent Systems. Applied Sciences, 9(10), p.2059. Larsen, J.B., 2019. Going beyond BDI for agent-based simulation. Journal of Information and Telecommunication, 3(4), pp.446-464.Larsen J.B., 2019. Adding Organizational Reasoning to Agent-Based Simulations in GAMA. In: Weyns D., Mascardi V., Ricci A. (eds) Engineering Multi-Agent Systems. EMAS 2018. LNCS, vol 11375. Springer, Cham.Cura R., 2019. « Model Visualization ». In Pumain D. (dir), Geographical Modeling: Cities and Territories, John Wiley &amp; Sons, Ltd, pp. 151‑91.Humann, J. and Pollard, K.A., 2019. Human Factors in the Scalability of Multirobot Operation: A Review and Simulation. In 2019 IEEE International Conference on Systems, Man and Cybernetics (SMC) (pp. 700-707). IEEE.Lammoglia, A., Leturcq, S., Delay, E., 2019. The VitiTerroir model to simulate the spatial dynamics of vineyards on the long term (1836-2014). Example of application in the department of Indre-et-Loire. Cybergeo: European Journal of Geography. 2019 Dec 8.Taillandier, P., Salliou, N., Thomopoulos, R., 2019. Coupling agent-based models and argumentation framework to simulate opinion dynamics: application to vegetarian diet diffusion. Social Simulation Conference 2019, Sep 2019, Mainz, Germany. ffhal-02265765fMancheva, L., Adam, C., &amp; Dugdale, J., 2019. Multi-agent geospatial simulation of human interactions and behaviour in bushfires. In International Conference on Information Systems for Crisis Response and Management. In ISCRAM 2019 conference, Valencia, Spain.Daudé, E., Chapuis, K., Taillandier, P., Tranouez, P., Caron, C., Drogoul, A., Gaudou, B., Rey-Coyrehourq, S., Saval, A., Zucker, J. D., 2019. ESCAPE: Exploring by Simulation Cities Awareness on Population Evacuation. In ISCRAM 2019 conference, Valencia, Spain.Farias, G. P., Leitzke, B. S., Born, M. B., de Aguiar, M. S., Adamatti, D. F., 2019. Modelagem Baseada em Agentes para Analise de Recursos Hidricos. In the Workshop-School on Agents, Environments, and Applications (WESAAC), Florianopolis – Santa Catarina (Brazil).Marrocco, L., Ferrer, E. C., Bucchiarone, A., Grignard, A., Alonso, L., Larson, K., 2019. BASIC: Towards a Blockchained Agent-Based SImulator for Cities. In International Workshop on Massively Multiagent Systems (pp. 144-162). Springer, Cham.Ruiz-Chavez, Z., Salvador-Meneses, J., Mejía-Astudillo, C., Diaz-Quilachamin, S., 2019. Analysis of Dogs's Abandonment Problem Using Georeferenced Multi-agent Systems. International Work-Conference on the Interplay Between Natural and Artificial Computation (pp. 297-306). Springer, Cham. https://doi.org/10.1007/978-3-030-19651-6_29Rodrique, K., Tuong, H., Manh, N., 2019. An Agent-based Simulation for Studying Air Pollution from Traffic in Urban Areas: The Case of Hanoi City. Int. J. Adv. Comput. Sci. Appl. 10. https://doi.org/10.14569/IJACSA.2019.0100376Micolier, A., Taillandier, F., Taillandier, P., Bos, F., 2019. Li-BIM, an agent-based approach to simulate occupant-building interaction from the Building-Information Modelling. Eng. Appl. Artif. Intell. 82, 44–59. https://doi.org/10.1016/j.engappai.2019.03.008Houssou, N.L.J., Cordero, J.D., Bouadjio-Boulic, A., Morin, L., Maestripieri, N., Ferrant, S., Belem, M., Pelaez Sanchez, J.I., Saenz, M., Lerigoleur, E., Elger, A., Gaudou, B., Maurice, L., Saqalli, M., 2019. Synchronizing Histories of Exposure and Demography: The Construction of an Agent-Based Model of the Ecuadorian Amazon Colonization and Exposure to Oil Pollution Hazards. J. Artif. Soc. Soc. Simul. 22, 1. https://doi.org/10.18564/jasss.3957Knapps, V., Zimmermann, K.-H., 2019. Distributed Monitoring of Topological Events via Homology. ArXiv190104146 Cs Math.Galimberti, A., Alyokhin, A., Qu, H., Rose, J., 2019. Simulation modelling of Potato virus Y spread in relation to initial inoculum and vector activity. Journal of Integrative Agriculture "},{"title":"2018​","type":1,"pageTitle":"Scientific References","url":"wiki/References#2018","content":"Alonso, L., Zhang, Y.R., Grignard, A., Noyman, A., Sakai, Y., ElKatsha, M., Doorley, R. and Larson, K., 2018, July. Cityscope: a data-driven interactive simulation tool for urban design. Use case Volpe. In International conference on complex systems (pp. 253-261). Springer, Cham.Sobieraj, J., Nouveliere, L., Hutzler, G. and Klaudel, H., 2018, October. Modélisation du changement de voie de véhicules autonomes à différents niveaux d'abstraction. Journées Francophones sur les Systèmes Multi-Agents 2018 (JFSMA’2018), Oct 2018, Métabief, France. pp.21–30.Tsagkis, P. and Photis, Y.N., 2018. Using Gama platform and Urban Atlas Data to predict urban growth. The case of Athens. 13th International Conference of the Hellenic Geographical Society.Marilleau, N., Lang, C., Giraudoux, P., 2018. Coupling agent-based with equation-based models to study spatially explicit megapopulation dynamics. Ecol. Model. 384, 34–42. https://doi.org/10.1016/j.ecolmodel.2018.06.011Adam, C., Taillandier, F., 2018. Games ready to use: A serious game for teaching natural risk management. Simulation and Gaming, SAGE Publications, 2018. Alfeo, A.L., Ferrer, E.C., Carrillo, Y.L., Grignard, A., Pastor, L.A., Sleeper, D.T., Cimino, M.G.C.A., Lepri, B., Vaglini, G., Larson, K., Dorigo, M., Pentland, A. `Sandy’, 2018. Urban Swarms: A new approach for autonomous waste management. ArXiv181007910 Cs.Qu, H., Drummond, F., 2018. Simulation-based modeling of wild blueberry pollination. Comput. Electron. Agric. 144, 94–101. https://doi.org/10.1016/j.compag.2017.11.003Shaham, Y., Benenson, I., 2018. Modeling fire spread in cities with non-flammable construction. Int. J. Disaster Risk Reduct. 31, 1337–1353. https://doi.org/10.1016/j.ijdrr.2018.03.010Mewes, B., Schumann, A.H., 2018. IPA (v1): a framework for agent-based modelling of soil water movement. Geosci. Model Dev. 11, 2175–2187. https://doi.org/10.5194/gmd-11-2175-2018Grignard, A., Macià, N., Alonso Pastor, L., Noyman, A., Zhang, Y., Larson, K., 2018. CityScope Andorra: A Multi-level Interactive and Tangible Agent-based Visualization, in: Proceedings of the 17th International Conference on Autonomous Agents and MultiAgent Systems, AAMAS ’18. International Foundation for Autonomous Agents and Multiagent Systems, Richland, SC, pp. 1939–1940.Zhang, Y., Grignard, A., Lyons, K., Aubuchon, A., Larson, K., 2018. Real-time Machine Learning Prediction of an Agent-Based Model for Urban Decision-making (Extended Abstract) 3.Bandyopadhyay, M., Singh, V., 2018. Agent-based geosimulation for assessment of urban emergency response plans. Arab. J. Geosci. 11, 165. https://doi.org/10.1007/s12517-018-3523-5Samad, T., Iqbal, S., Malik, A.W., Arif, O., Bloodsworth, P., 2018. A multi-agent framework for cloud-based management of collaborative robots. Int. J. Adv. Robot. Syst. 15, 172988141878507. https://doi.org/10.1177/1729881418785073Humann, J., Spero, E., 2018. Modeling and simulation of multi-UAV, multi-operator surveillance systems, in: 2018 Annual IEEE International Systems Conference (SysCon). Presented at the 2018 Annual IEEE International Systems Conference (SysCon), pp. 1–8. https://doi.org/10.1109/SYSCON.2018.8369546Mazzoli, M., Re, T., Bertilone, R., Maggiora, M., Pellegrino, J., 2018. Agent Based Rumor Spreading in a scale-free network. ArXiv180505999 Cs.Grignard, A., Alonso, L., Taillandier, P., Gaudou, B., Nguyen-Huu, T., Gruel, W., Larson, K., 2018a. The Impact of New Mobility Modes on a City: A Generic Approach Using ABM, in: Morales, A.J., Gershenson, C., Braha, D., Minai, A.A., Bar-Yam, Y. (Eds.), Unifying Themes in Complex Systems IX, Springer Proceedings in Complexity. Springer International Publishing, pp. 272–280.Touhbi, S., Babram, M.A., Nguyen-Huu, T., Marilleau, N., Hbid, M.L., Cambier, C., Stinckwich, S., 2018. Time Headway analysis on urban roads of the city of Marrakesh. Procedia Comput. Sci. 130, 111–118. https://doi.org/10.1016/j.procs.2018.04.019Laatabi, A., Marilleau, N., Nguyen-Huu, T., Hbid, H., Ait Babram, M., 2018. ODD+2D: An ODD Based Protocol for Mapping Data to Empirical ABMs. J. Artif. Soc. Soc. Simul. 21, 9. https://doi.org/10.18564/jasss.3646Chapuis K., Taillandier P., Gaudou B., Drogoul A., Daudé E. (2018) A Multi-modal Urban Traffic Agent-Based Framework to Study Individual Response to Catastrophic Events. In: Miller T., Oren N., Sakurai Y., Noda I., Savarimuthu B., Cao Son T. (eds) PRIMA 2018: Principles and Practice of Multi-Agent Systems. PRIMA 2018. Lecture Notes in Computer Science, vol 11224. Springer, ChamBourgais, M., Taillandier, P., Vercouter, L., Adam, C., 2018. Emotion Modeling in Social Simulation: A Survey. J. Artif. Soc. Soc. Simul. 21, 5. Grillot M., Vayssières J., Masse D., 2018. Agent-based modelling as a time machine to assess nutrient cycling reorganization during past agrarian transitions in West Africa. Agricultural Systems 164, 133‑151. https://doi.org/10.1016/j.agsy.2018.04.008Grillot, M., Guerrin, F., Gaudou, B., Masse, D., Vayssières, J., 2018. Multi-level analysis of nutrient cycling within agro-sylvo-pastoral landscapes in West Africa using an agent-based model. Environ. Model. Softw. 107, 267–280. https://doi.org/10.1016/j.envsoft.2018.05.003Valette, M., Gaudou, B., Longin, D., Taillandier, P., 2018. Modeling a Real-Case Situation of Egress Using BDI Agents with Emotions and Social Skills, in: Miller, T., Oren, N., Sakurai, Y., Noda, I., Savarimuthu, B.T.R., Cao Son, T. (Eds.), PRIMA 2018: Principles and Practice of Multi-Agent Systems. Springer International Publishing, Cham, pp. 3–18. https://doi.org/10.1007/978-3-030-03098-8_1Humann, J., Spero, E. (2018) Modeling and Simulation of multi-UAV, multi-Operator Surveillance Systems, 2018 Annual IEEE International Systems Conference (SysCon), Vancouver, BC.Lammoglia, A., Leturcq, S., Delay, E., 2018. Le modèle VitiTerroir pour simuler la dynamique spatiale des vignobles sur le temps long (1836-2014). Exemple d’application au département d’Indre-et-Loire. Cybergeo Eur. J. Geogr. https://doi.org/10.4000/cybergeo.29324Amores, D., Vasardani, M., Tanin, E., 2018. Early Detection of Herding Behaviour during Emergency Evacuations 15 pages. https://doi.org/10.4230/lipics.giscience.2018.1Rakotoarisoa, M.M., Fleurant, C., Taibi, A.N., Rouan, M., Caillault, S., Razakamanana, T., Ballouche, A., 2018. Un modèle multi-agents pour évaluer la vulnérabilité aux inondations : le cas des villages aux alentours du Fleuve Fiherenana (Madagascar). Cybergeo Eur. J. Geogr. https://doi.org/10.4000/cybergeo.29144 "},{"title":"2017​","type":1,"pageTitle":"Scientific References","url":"wiki/References#2017","content":"Bañgate, J., Dugdale, J., Beck, E., &amp; Adam, C. (2017, December). SOLACE a multi-agent model of human behaviour driven by social attachment during seismic crisis. In 2017 4th International Conference on Information and Communication Technologies for Disaster Management (ICT-DM) (pp. 1-9). IEEE.Arcile, J., Sobieraj, J., Klaudel, H., &amp; Hutzler, G. (2017). Combination of simulation and model-checking for the analysis of autonomous vehicles’ behaviors: A case study. In Multi-Agent Systems and Agreement Technologies (pp. 292-304). Springer, Cham.Cura, R., Tannier, C., Leturcq, S., Zadora-Rio, E., Lorans, E., &amp; Rodier, X. (2017). Transition 8: 800-1100. Fixation, polarisation et hiérarchisation de l'habitat rural en Europe du Nord-Ouest (chap. 11). (https://simfeodal.github.io/)Becu, N., Amalric, M., Anselme, B., Beck, E., Bertin, X., Delay, E., Long, N., Marilleau, N., Pignon-Mussaud, C., Rousseaux, F., 2017. Participatory simulation to foster social learning on coastal flooding prevention. Environ. Model. Softw. 98, 1–11. https://doi.org/10.1016/j.envsoft.2017.09.003Adam, C., Gaudou, B., 2017. Modelling Human Behaviours in Disasters from Interviews: Application to Melbourne Bushfires. J. Artif. Soc. Soc. Simul. 20, 12. https://doi.org/10.18564/jasss.3395Adam, C., Taillandier, P., Dugdale, J., Gaudou, B., 2017. BDI vs FSM Agents in Social Simulations for Raising Awareness in Disasters: A Case Study in Melbourne Bushfires. Int. J. Inf. Syst. Crisis Response Manag. 9, 27–44. https://doi.org/10.4018/IJISCRAM.2017010103Amalric, M., Anselme, B., Bécu, N., Delay, E., Marilleau, N., Pignon, C., Rousseaux, F., 2017. Sensibiliser au risque de submersion marine par le jeu ou faut-il qu’un jeu soit spatialement réaliste pour être efficace ? Sci. Jeu. https://doi.org/10.4000/sdj.859Emery, J., Marilleau, N., Martiny, N., Thévenin, T., Badram, M.A., Grignard, A., Hbdid, H., 2017. MARRAKAIR : UNE SIMULATION PARTICIPATIVE POUR OBSERVER LES ÉMISSIONS ATMOSPHÉRIQUES DU TRA- FIC ROUTIER EN MILIEU URBAIN 5.Martiny, N., Emery, J., Ceamanos, X., Briottet, X., Marilleau, N., Thevenin, T., Léon, J.-F., 2017. La Qualité de l’air en ville à Très haute Résolution (Quali_ThR): Apport des images Pléiades dans la démarche SCAUP ?, in: FUTURMOB : Préparer La Transition Vers La Mobilité Autonome. Montbéliard, France.Ta, X.-H., Gaudou, B., Longin, D., Ho, T.V., 2017. Emotional contagion model for group evacuation simulation. Informatica 41.Huynh, N.Q., Nguyen-Huu, T., Grignard, A., Huynh, H.X., Drogoul, A., 2017. Coupling equation based models and agent-based models: example of a multi-strains and switch SIR toy model. EAI Endorsed Trans. Context-Aware Syst. Appl. 4, 152334. https://doi.org/10.4108/eai.6-3-2017.152334Taillandier, P., Bourgais, M., Drogoul, A., Vercouter, L. Using parallel computing to improve the scalability of models with BDI agents. Social Simulation Conference, Sep 2017, Dublin, Ireland.Philippon, D., Choisy, M., Drogoul, A., Gaudou, B., Marilleau, N., Taillandier, P., Truong, Q.C. (2017) Exploring Trade and Health Policies Influence on Dengue Spread with an Agent-Based Model, in: Nardin, L.G., Antunes, L. (Eds.), Multi-Agent Based Simulation XVII. Springer International Publishing, Cham, pp. 111–127.doi:10.1007/978-3-319-67477-3_6Marilleau, N., Giraudoux, P., Lang, C., 2017. Multi-agent simulation as a tool to study risk in a spatial context, in: International Forum on Disaster Risk Management. Kunming, China. "},{"title":"2016​","type":1,"pageTitle":"Scientific References","url":"wiki/References#2016","content":"Fosset, P., Banos, A., Beck, E., Chardonnel, S., Lang, C., Marilleau, N., Piombini, A., Leysens, T., Conesa, A., Andre-Poyaud, I., Thevenin, T., 2016. Exploring Intra-Urban Accessibility and Impacts of Pollution Policies with an Agent-Based Simulation Platform: GaMiroD. Systems 4, 5. https://doi.org/10.3390/systems4010005Grignard, A., Fantino, G., Lauer, J.W., Verpeaux, A., Drogoul, A., 2016. Agent-Based Visualization: A Simulation Tool for the Analysis of River Morphosedimentary Adjustments, in: Gaudou, B., Sichman, J.S. (Eds.), Multi-Agent Based Simulation XVI. Springer International Publishing, Cham, pp. 109–120. https://doi.org/10.1007/978-3-319-31447-1_7Lucien, L., Lang, C., Marilleau, N., Philippe, L., 2016. Multiagent Hybrid Architecture for Collaborative Exchanges between Communicating Vehicles in an Urban Context. Procedia Comput. Sci. 83, 695–699. https://doi.org/10.1016/j.procs.2016.04.154Laatabi, A., Marilleau, N., Nguyen-Huu, T., Hbid, H., Babram, M.A., 2016. Formalizing Data to Agent Model Mapping Using MOF: Application to a Model of Residential Mobility in Marrakesh, in: Jezic, G., Chen-Burger, Y.-H.J., Howlett, R.J., Jain, L.C. (Eds.), Agent and Multi-Agent Systems: Technology and Applications. Springer International Publishing, Cham, pp. 107–117. https://doi.org/10.1007/978-3-319-39883-9_9Taillandier, P., Banos, A., Drogoul, A., Gaudou, B., Marilleau, N., Truong, Q.C. (2016) Simulating Urban Growth with Raster and Vector models: A case study for the city of Can Tho, Vietnam, in: Osman, N., Sierra, C. (Eds.), Autonomous Agents and Multiagent Systems, Lecture Notes in Computer Science. Springer International Publishing, pp. 154–171. Doi: 10.1007/978-3-319-46840-2_10.Nghi, H.Q, Nguyen-Huu, T., Grignard, A., Huynh, X.H., Drogoul, A. (2016) Toward an Agent-Based and Equation-Based Coupling Framework. International Conference on Nature of Computation and Communication, 311-324Bhamidipati, S., van der Lei, T., &amp; Herder, P. (2016) A layered approach to model interconnected infrastructure and its significance for asset management. EJTIR, 16(1), 254-272.Drogoul A., Huynh N.Q. and Truong Q.C. (2016) Coupling environmental, social and economic models to understand land-use change dynamics in the Mekong Delta. Front. Environ. Sci. 4:19. doi:10.3389/fenvs.2016.00019.Grignard, A., Fantino, G., Lauer, J.W., Verpeaux, A., Drogoul, A., 2016. Agent-Based Visualization: A Simulation Tool for the Analysis of River Morphosedimentary Adjustments, in: Gaudou, B., Sichman, J.S. (Eds.), Multi-Agent Based Simulation XVI. Springer International Publishing, Cham, pp. 109–120. https://doi.org/10.1007/978-3-319-31447-1_7Truong, Q.C., Taillandier, P., Gaudou, B., Vo, M.Q., Nguyen, T.H., Drogoul, A. (2016) Exploring Agent Architectures for Farmer Behavior in Land-Use Change. A Case Study in Coastal Area of the Vietnamese Mekong Delta, in: Gaudou, B., Sichman, J.S. (Eds.), Multi-Agent Based Simulation XVI, Lecture Notes in Computer Science. Springer International Publishing, pp. 146–158. doi: 10.1007/978-3-319-31447-1_10.Lang, C., Marilleau, N., Giraudoux, P., 2016. Couplage de SMA avec des EDO pour simuler les phénomènes écologiques à grande échelle, in: 2ème Rencontre ”Informatique Scientifique à Besançon”. Besançon, France.Giraudoux, P., Lang, C., Marilleau, N., 2016. Coupling agent based with equation based models for studying explicitly spatial population dynamics.Lucien, L., Lang, C., Marilleau, N., Philippe, L., 2016. A Proposition of Data Organization and Exchanges to Collaborate in an Autonomous Agent Context, in: 2016 IEEE Intl Conference on Computational Science and Engineering (CSE) and IEEE Intl Conference on Embedded and Ubiquitous Computing (EUC) and 15th Intl Symposium on Distributed Computing and Applications for Business Engineering (DCABES). Presented at the 2016 19th IEEE Intl Conference on Computational Science and Engineering (CSE), IEEE 14th Intl Conference on Embedded and Ubiquitous Computing (EUC), and 15th Intl Symposium on Distributed Computing and Applications for Business Engineering (DCABES), IEEE, Paris, pp. 561–568. https://doi.org/10.1109/CSE-EUC-DCABES.2016.242 "},{"title":"2015​","type":1,"pageTitle":"Scientific References","url":"wiki/References#2015","content":"Gasmi, N., Grignard, A., Drogoul, A., Gaudou, B., Taillandier, P., Tessier, O., An, V.D., 2015. Reproducing and Exploring Past Events Using Agent-Based Geo-Historical Models, in: Grimaldo, F., Norling, E. (Eds.), Multi-Agent-Based Simulation XV. Springer International Publishing, Cham, pp. 151–163.Le, V.-M., Chevaleyre, Y., Ho Tuong Vinh, Zucker, J.-D., 2015. Hybrid of linear programming and genetic algorithm for optimizing agent-based simulation. Application to optimization of sign placement for tsunami evacuation, in: The 2015 IEEE RIVF International Conference on Computing &amp; Communication Technologies - Research, Innovation, and Vision for Future (RIVF). Presented at the 2015 IEEE RIVF International Conference on Computing &amp; Communication Technologies, Research, Innovation, and Vision for the Future (RIVF), IEEE, Can Tho, Vietnam, pp. 138–143. https://doi.org/10.1109/RIVF.2015.7049889Emery, J., Marilleau, N., Martiny, N., Thévenin, T., Villery, J., 2015. L’apport de la simulation multi-agent du trafic routier pour l’estimation des pollutions atmosphériques automobiles, in: Douzièmes Rencontres de Théo Quant. Besançon, France. "},{"title":"2014​","type":1,"pageTitle":"Scientific References","url":"wiki/References#2014","content":"Macatulad, E. G., Blanco, A. C. (2014) 3DGIS-BASED MULTI-AGENT GEOSIMULATION AND VISUALIZATION OF BUILDING EVACUATION USING GAMA PLATFORM. The International Archives of the Photogrammetry, Remote Sensing and Spatial Information Sciences, Volume XL-2, 2014. ISPRS Technical Commission II Symposium, 6 – 8 October 2014, Toronto, Canada. Bhamidipati, S. (2014) A simulation framework for asset management in climate-change adaptation of transportation infrastructure. In: Proceedings of 42nd European Transport Conference. Frankfurt, Germany.Gaudou, B., Sibertin-Blanc, C., Thérond, O., Amblard, F., Auda, Y., Arcangeli, J.-P., Balestrat, M., Charron-Moirez, M.-H., Gondet, E., Hong, Y., Lardy, R., Louail, T., Mayor, E., Panzoli, D., Sauvage, S., Sanchez-Perez, J., Taillandier, P., Nguyen, V. B., Vavasseur, M., Mazzega, P. (2014). The MAELIA multi-agent platform for integrated assessment of low-water management issues. In: International Workshop on Multi-Agent-Based Simulation (MABS 2013), Saint-Paul, MN, USA, 06/05/2013-07/05/2013, Vol. 8235, Shah Jamal Alam, H. Van Dyke Parunak, (Eds.), Springer, Lecture Notes in Computer Science, p. 85-110.Gaudou, B., Lorini, E., Mayor, E. (2014.) Moral Guilt: An Agent-Based Model Analysis. In: Conference of the European Social Simulation Association (ESSA 2013), Warsaw, 16/09/2013-20/09/2013, Vol. 229, Springer, Advances in Intelligent Systems and Computing, p. 95-106.Le, V.-M., Chevaleyre, Y., Zucker, J.-D., Tuong Vinh, H., 2014. Approaches to Optimize Local Evacuation Maps for Helping Evacuation in Case of Tsunami, in: Hanachi, C., Bénaben, F., Charoy, F. (Eds.), Information Systems for Crisis Response and Management in Mediterranean Countries. Springer International Publishing, Cham, pp. 21–31. https://doi.org/10.1007/978-3-319-11818-5_3Emery, J., Marilleau, N., Thévenin, T., Martiny, N., 2014. Du comptage ponctuel à l’affectation par simulation multi-agents : application à la circulation routière de la ville de Dijon, in: Conférence Internationale de Géomatique et d’analyse Spatiale (SAGEO). Grenoble, France, p. CD-ROM. "},{"title":"2013​","type":1,"pageTitle":"Scientific References","url":"wiki/References#2013","content":"Drogoul, A., Gaudou, B., Grignard, A., Taillandier, P., &amp; Vo, D. A. (2013). Practical Approach To Agent-Based Modelling. In: Water and its Many Issues. Methods and Cross-cutting Analysis. Stéphane Lagrée (Eds.), Journées de Tam Dao, p. 277-300, Regional Social Sciences Summer University.Drogoul, A., Gaudou, B. (2013) Methods for Agent-Based Computer Modelling. In: Water and its Many Issues. Methods and Cross-cutting Analysis. Stéphane Lagrée (Eds.), Journées de Tam Dao, 1.6, p. 130-154, Regional Social Sciences Summer University. Truong, M.-T., Amblard, F., Gaudou, B., Sibertin-Blanc, C., Truong, V. X., Drogoul, A., Hyunh, X. H., Le, M. N. (2013). An implementation of framework of business intelligence for agent-based simulation. In: Symposium on Information and Communication Technology (SoICT 2013), Da Nang, Viet Nam, 05/12/2013-06/12/2013, Quyet Thang Huynh, Thanh Binh Nguyen, Van Tien Do, Marc Bui, Hong Son Ngo (Eds.), ACM, p. 35-44.Le, V. M., Gaudou, B., Taillandier, P., Vo, D. A (2013). A New BDI Architecture To Formalize Cognitive Agent Behaviors Into Simulations. In: Advanced Methods and Technologies for Agent and Multi-Agent Systems (KES-AMSTA 2013), Hue, Vietnam, 27/05/2013-29/05/2013, Vol. 252, Dariusz Barbucha, Manh Thanh Le, Robert J. Howlett, C. Jain Lakhmi (Eds.), IOS Press, Frontiers in Artificial Intelligence and Applications, p. 395-403.Emery, J., Boyard-Micheau, J., Marilleau, N., Martiny, N., Thévenin, T., 2013. Exploitation of traffic counting data for traffic study in urban areas: from traffic assignment to simulation model validation, in: 18th European Colloquium in Theoretical and Quantitative Geography (ECTQG). Dourdan, France.Banos, A., Marilleau, N., 2013. Improving Individual Accessibility to the City, in: Gilbert, T., Kirkilionis, M., Nicolis, G. (Eds.), Proceedings of the European Conference on Complex Systems 2012, Springer Proceedings in Complexity. Springer International Publishing, pp. 989–992. "},{"title":"2012​","type":1,"pageTitle":"Scientific References","url":"wiki/References#2012","content":"Taillandier, P., Therond, O., Gaudou B. (2012), A new BDI agent architecture based on the belief theory. Application to the modelling of cropping plan decision-making. In 'International Environmental Modelling and Software Society', Germany, pp. 107-116.NGUYEN, Q.T., BOUJU, A., ESTRAILLIER, P. (2012) Multi-agent architecture with space-time components for the simulation of urban transportation systems.Cisse, A., Bah, A., Drogoul, A., Cisse, A.T., Ndione, J.A., Kebe, C.M.F. &amp; Taillandier P. (2012), Un modèle à base d’agents sur la transmission et la diffusion de la fièvre de la Vallée du Rift à Barkédji (Ferlo, Sénégal), Studia Informatica Universalis 10 (1), pp. 77-97.Taillandier, P., Amouroux, E., Vo, D.A. and Olteanu-Raimond A.M. (2012), Using Belief Theory to formalize the agent behavior: application to the simulation of avian flu propagation. In ‘The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS)’, India, Volume 7057/2012, pp. 575-587.Le, V.M., Adam, C., Canal, R., Gaudou, B., Ho, T.V. and Taillandier, P. (2012), Simulation of the emotion dynamics in a group of agents in an evacuation situation. In ‘The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS)’, India, Volume 7057/2012, pp. 604-619.Nguyen Vu, Q. A., Canal, R., Gaudou, B., Hassas, S., Armetta, F. (2012), TrustSets - Using trust to detect deceitful agents in a distributed information collecting system. In: Journal of Ambient Intelligence and Humanized Computing, Springer-Verlag, Vol. 3 N. 4, p. 251-263. "},{"title":"2011​","type":1,"pageTitle":"Scientific References","url":"wiki/References#2011","content":"Taillandier, P., Therond, O. (2011), Use of the Belief Theory to formalize Agent Decision Making Processes : Application to cropping Plan Decision Making. In ’25th European Simulation and Modelling Conference’, Guimaraes, Portugal, pp. 138-142.Taillandier, P. &amp; Amblard, F. (2011), Cartography of Multi-Agent Model Parameter Space through a reactive Dicotomous Approach. In ’25th European Simulation and Modelling Conference’, Guimaraes, Portugal, pp. 38-42.Taillandier, P. &amp; Stinckwich, S. (2011), Using the PROMETHEE Multi-Criteria Decision Making Method to Define New Exploration Strategies for Rescue Robots’, IEEE International Symposium on Safety, Security, and Rescue Robotics, Kyoto, Japon, pp. 321 - 326. "},{"title":"2010​","type":1,"pageTitle":"Scientific References","url":"wiki/References#2010","content":"Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S. and Armetta, F. (2010), A cluster-based approach for disturbed, spatialized, distributed information gathering systems, in ‘The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS)’, India, pp. 588-603.Nguyen, N.D., Taillandier, P., Drogoul, A. and Augier, P. (2010), Inferring Equation-Based Models from Agent-Based Models: A Case Study in Competition Dynamics.In ‘The 13th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA)’, India, Volume 7057/2012, pp. 413-427.Amouroux, E., Gaudou, B. Desvaux, S. and Drogoul, A. (2010), O.D.D.: a Promising but Incomplete Formalism For Individual-Based Model Specification. in ‘IEEE International Conference on Computing and Telecommunication Technologies ’(2010 IEEE RIVF'), pp. 1-4.Nguyen, N.D., Phan, T.H.D., Nguyen, T.N.A., Drogoul, A., Zucker, J-D. (2010), Disk Graph-Based Model for Competition Dynamic, in ‘IEEE International Conference on Computing and Telecommunication Technologies ’(2010 IEEE RIVF').Nguyen, T.K., Marilleau, N., Ho T.V., El Fallah Seghrouchni, A. (2010), A meta-model for specifying collaborative simulation, Paper to appear in ‘IEEE International Conference on Computing and Telecommunication Technologies ’(2010 IEEE RIVF').Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S. and Armetta, F. (2010), TrustSets - Using trust to detect deceitful agents in a distributed information collecting system, Paper to appear in ‘IEEE International Conference on Computing and Telecommunication Technologies ’(2010 IEEE RIVF'), the best student paper award.Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S., Armetta, F. and Stinckwich, S. (2010), Using trust and cluster organisation to improve robot swarm mapping, Paper to appear in ‘Workshop on Robots and Sensors integration in future rescue INformation system ’ (ROSIN 2010). "},{"title":"2009​","type":1,"pageTitle":"Scientific References","url":"wiki/References#2009","content":"Taillandier, P. and Buard, E. (2009), Designing Agent Behaviour in Agent-Based Simulation through participatory method. In ‘The 12th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA)’, Nagoya, Japan, pp. 571--578.Taillandier, P. and Chu, T.Q. (2009), Using Participatory Paradigm to Learn Human Behaviour. In ‘International Conference on Knowledge and Systems Engineering’, Ha noi, Viet Nam, pp. 55--60.Gaudou, B., Ho, T.V. and Marilleau, N. (2009), Introduce collaboration in methodologies of modeling and simulation of Complex Systems. In ‘International Conference on Intelligent Networking and Collaborative Systems (INCOS '09)’. Barcelona, pp. 1--8.Nguyen, T.K., Gaudou B., Ho T.V. and Marilleau N. (2009), Application of PAMS Collaboration Platform to Simulation-Based Researches in Soil Science: The Case of the MIcro-ORganism Project. In ‘IEEE International Conference on Computing and Telecommunication Technologies (IEEE-RIVF 09)’. Da Nang, Viet Nam, pp. 296--303.Nguyen, V.Q., Gaudou B., Canal R., Hassas S. and Armetta F. (2009), Stratégie de communication dans un système de collecte d’information à base d’agents perturbés. In ‘Journées Francophones sur les Systèmes Multi-Agents (JFSMA'09)’. "},{"title":"2008​","type":1,"pageTitle":"Scientific References","url":"wiki/References#2008","content":"Chu, T.Q., Boucher, A., Drogoul, A., Vo, D.A., Nguyen, H.P. and Zucker, J.D. (2008). Interactive Learning of Expert Criteria for Rescue Simulations. In Pacific Rim International Workshop on Multi-Agents, Ha Noi, Viet Nam, pp. 127--138.Amouroux, E., Desvaux, S. and Drogoul, A. (2008), Towards Virtual Epidemiology: An Agent-Based Approach to the Modeling of H5N1 Propagation and Persistence in North-Vietnam. In Pacific Rim International Workshop on Multi-Agents, Ha Noi, Viet Nam, pp. 26--33. "},{"title":"Road Traffic","type":0,"sectionRef":"#","url":"wiki/RoadTrafficModel","content":"","keywords":""},{"title":"Model Overview​","type":1,"pageTitle":"Road Traffic","url":"wiki/RoadTrafficModel#model-overview","content":"The model built in this tutorial concerns the study of road traffic in a small city. Two layers of GIS data are used: a road layer (polylines) and a building layer (polygons). The building GIS data contain an attribute: the 'NATURE' of each building: a building can be either 'Residential' or 'Industrial'. In this model, people agents are moving along the road network. Each morning, they are going to an industrial building to work, and each night they are coming back home. Each time a people agent takes a road, it wears it out. More a road is worn out, more a people agent takes time to go all over it. The town council is able to repair some roads.  "},{"title":"Step List​","type":1,"pageTitle":"Road Traffic","url":"wiki/RoadTrafficModel#step-list","content":"This tutorial is composed of 7 steps corresponding to 7 models. For each step, we present its purpose, an explicit formulation, and the corresponding GAML code. Loading of GIS data (buildings and roads)Definition of people agentsMovement of the people agentsDefinition of weight for the road networkDynamic update of the road networkDefinition of a chart displayAutomatic repair of roads "},{"title":"2. People Agents","type":0,"sectionRef":"#","url":"wiki/RoadTrafficModel_step2","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"2. People Agents","url":"wiki/RoadTrafficModel_step2#formulation","content":"Define a new species of agents: the people agents. The people agents have a point for geometry and are represented by a yellow circle of radius 10m.At initialization, 100 people agents are created. Each people agent is placed inside a building of type 'Residential' (randomly selected). "},{"title":"Model Definition​","type":1,"pageTitle":"2. People Agents","url":"wiki/RoadTrafficModel_step2#model-definition","content":""},{"title":"species​","type":1,"pageTitle":"2. People Agents","url":"wiki/RoadTrafficModel_step2#species","content":"We define a new species of agents: the people agents. In this model, these agents will not have a specific behavior yet. They will be just displayed. Thus, we just have to define an aspect for the agents. We want to represent the people agents by a yellow circle of radius 10m. We then use the circle operator to define the shape to draw in the draw command, with the expected inner color (facet color) and border color (facet border). https://github.com/gama-platform/gama/blob/GAMA_1.8.2/msi.gama.models/models/Tutorials/Road%20Traffic/models/Model%2002.gaml  "},{"title":"1. Loading of GIS Data","type":0,"sectionRef":"#","url":"wiki/RoadTrafficModel_step1","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"1. Loading of GIS Data","url":"wiki/RoadTrafficModel_step1#formulation","content":"Set the time duration of a time step to 10 minutes.Load, agentify and display two layers of GIS data (building and road). Agentifying a GIS element will allow us to give it a behavior later on (thus not being simply a static/passive object).Read the 'NATURE' attribute of the building data: the buildings of 'Residential' type will be colored in gray, the buildings of 'Industrial' type will be color in blue. "},{"title":"Model Definition​","type":1,"pageTitle":"1. Loading of GIS Data","url":"wiki/RoadTrafficModel_step1#model-definition","content":""},{"title":"species​","type":1,"pageTitle":"1. Loading of GIS Data","url":"wiki/RoadTrafficModel_step1#species","content":"In this first model, we have to define two species of agents: the building agents and the road ones. These agents will not have a particular behavior (for the moment), they will just be displayed. For each of these species, we define a new attribute: color of type rgb, with for initial value: &quot;black&quot; for the road agent and &quot;gray&quot; (by default) for the building agent. Concerning the building species, we define a second attribute named type representing the type of the building (&quot;Residential&quot; or &quot;Industrial&quot;). At last, we define an aspect for these species. In this model, we want to represent the geometry of the agent, we then use the statement draw that allows to draw a given geometry. In order to draw the geometry of the agent, we use the attribute shape (which is a built-in attribute of all agents). species building { string type; rgb color &lt;- #gray ; aspect base { draw shape color: color ; } } species road { rgb color &lt;- #black ; aspect base { draw shape color: color ; } }  "},{"title":"Parameters​","type":1,"pageTitle":"1. Loading of GIS Data","url":"wiki/RoadTrafficModel_step1#parameters","content":"GAMA allows to automatically read GIS data that are formatted as shapefiles. In order to let the user chooses his/her shapefiles, we define three parameters. One allowing the user to choose the road shapefile, one allowing him/her to choose the building shapefile, and, at last, one allowing him/her to choose the bounds shapefile. We will come back later on the notion of &quot;bounds&quot; in GAMA. Definition of the three global variables of type file concerning the GIS files: global { file shape_file_buildings &lt;- file(&quot;../includes/building.shp&quot;); file shape_file_roads &lt;- file(&quot;../includes/road.shp&quot;); file shape_file_bounds &lt;- file(&quot;../includes/bounds.shp&quot;); }  All shapefiles are available in the model library (under Library models -&gt; Tutorials -&gt; Road Traffic) or you can download them by following this GitHub link. In the experiment section, we add three parameters to allow the user to change the shapefile used directly through the UI: experiment road_traffic type: gui { parameter &quot;Shapefile for the buildings:&quot; var: shape_file_buildings category: &quot;GIS&quot; ; parameter &quot;Shapefile for the roads:&quot; var: shape_file_roads category: &quot;GIS&quot; ; parameter &quot;Shapefile for the bounds:&quot; var: shape_file_bounds category: &quot;GIS&quot; ; }  "},{"title":"Agentification of GIS data​","type":1,"pageTitle":"1. Loading of GIS Data","url":"wiki/RoadTrafficModel_step1#agentification-of-gis-data","content":"In GAMA, the agentification of GIS data is very straightforward: it only requires to use the create command with the from facet to pass the shapefile. Each object of the shapefile will be directly used to instantiate an agent of the specified species. The reading of an attribute in a shapefile is also very simple. It only requires to use the with facet: the argument of this facet is a dictionary of which the keys are the names of the agent attributes and the value the read operator followed by the name of the shapefile attribute (&quot;NATURE&quot; in our case). In the init block of the global block, we create the road and building agents from the shapefiles. Concerning the building agents, we read the &quot;NATURE&quot; attribute of the shapefile to initiate the value of the type attribute. If the type attribute is equal to &quot;Industrial&quot; set the color attribute to &quot;blue&quot;. global { ... init { create building from: shape_file_buildings with: [type::read (&quot;NATURE&quot;)] { if type=&quot;Industrial&quot; { color &lt;- #blue ; } } create road from: shape_file_roads ; } }  "},{"title":"Time step​","type":1,"pageTitle":"1. Loading of GIS Data","url":"wiki/RoadTrafficModel_step1#time-step","content":"In GAMA, by default, a time step represents 1 second. It is possible to redefine this value by overriding the step global variable. This value of the time step is used by the moving primitives of GAMA. In our model, we define that a step represents 10 minutes. Note that it is possible to define the unit of a value by using # + unit name, e.g. #mn for minutes or #km for kilometers. global { ... float step &lt;- 10 #mn; ... }  "},{"title":"Environment​","type":1,"pageTitle":"1. Loading of GIS Data","url":"wiki/RoadTrafficModel_step1#environment","content":"Building a GIS environment in GAMA requires nothing special, just to define the bounds of the environment, i.e. the geometry of the world agent. It is possible to use a shapefile to automatically define it by computing its envelope. In this model, we use a specific shapefile to define it. However, it would be possible to use the road shapefile to define it and let GAMA computes its envelope automatically. https://github.com/gama-platform/gama/blob/GAMA_1.8.2/msi.gama.models/models/Tutorials/Road%20Traffic/models/Model%2001.gaml  "},{"title":"4. Weight for Road Network","type":0,"sectionRef":"#","url":"wiki/RoadTrafficModel_step4","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"4. Weight for Road Network","url":"wiki/RoadTrafficModel_step4#formulation","content":"Add a destruction_coeff variable to the road agent. The value of this variable is higher or equal to 1 or lower or equal to 2. At initialization, the value of this variable is randomly defined between 1 and 2.In the road network graph, more a road is worn out (destruction_coeff high), more a people agent takes time to go all over it. Then the value of the arc representing the road in the graph is equal to &quot;length of the road * destruction_coeff&quot;.The color of the road depends on the destruction_coeff. If &quot;destruction_coeff = 1&quot;, the road is green, if &quot;destruction_coeff = 2&quot;, the road is red. "},{"title":"Model Definition​","type":1,"pageTitle":"4. Weight for Road Network","url":"wiki/RoadTrafficModel_step4#model-definition","content":""},{"title":"road agent​","type":1,"pageTitle":"4. Weight for Road Network","url":"wiki/RoadTrafficModel_step4#road-agent","content":"We add a destruction_coeff variable which initial value is randomly defined between 1 and 2 and which have a max of 2. The color of the agent will depend on this variable. In order to simplify the GAML code, we define a new variable colorValue that represents the value of red color and that will be defined between 0 and 255. species road { float destruction_coeff &lt;- rnd(1.0,2.0) max: 2.0; int colorValue &lt;- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1)); rgb color &lt;- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ; ... }  "},{"title":"weighted road network​","type":1,"pageTitle":"4. Weight for Road Network","url":"wiki/RoadTrafficModel_step4#weighted-road-network","content":"In GAMA, adding a weight for a graph is very simple, we use the with_weights operator with the graph for left-operand and a weight map for the right-operand. The weight map contains the weight of each edge: [edge1::weight1, edge2:: weight2,...]. In this model, the weight will be equal to the length of the road (perimeter of the polyline) its destruction coefficient.  init { ... create road from: shape_file_roads ; map&amp;lt;road,float&gt; weights_map &lt;- road as_map (each:: (each.destruction_coeff * each.shape.perimeter)); the_graph &lt;- as_edge_graph(road) with_weights weights_map; ... }  "},{"title":"Complete Model​","type":1,"pageTitle":"4. Weight for Road Network","url":"wiki/RoadTrafficModel_step4#complete-model","content":"https://github.com/gama-platform/gama/blob/GAMA_1.8.2/msi.gama.models/models/Tutorials/Road%20Traffic/models/Model%2004.gaml  "},{"title":"3. Movement of People","type":0,"sectionRef":"#","url":"wiki/RoadTrafficModel_step3","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"3. Movement of People","url":"wiki/RoadTrafficModel_step3#formulation","content":"For each people agent, definition of 2 new attributes: living_place (building of type 'Residential') and working_place (building of type 'Industrial').For each people agent: definition of start_work and end_work hours attributes that respectively represent when the agent leaves its house to go to work and when it leaves its working place to go back home. These hours will be randomly defined between 6 AM (min_work_start) and 8 AM (max_work_start) for start_work and 4 PM (min_work_end) and 8 PM (max_work_end) for end_work.For each people agent: definition of an objective attribute: this one can 'go home' or 'working'.For each people agent: define a speed. The speed will be randomly defined between 1 km/h (min_speed) and 5 km/h (max_speed).The people agents move along the road, taking the shortest path.All the previously introduced values will be defined in global attributes. "},{"title":"Model Definition​","type":1,"pageTitle":"3. Movement of People","url":"wiki/RoadTrafficModel_step3#model-definition","content":""},{"title":"people agents​","type":1,"pageTitle":"3. Movement of People","url":"wiki/RoadTrafficModel_step3#people-agents","content":"First, we have to change the skill of the people agents: as we want to use an action of the moving skill (goto), we will provide the people agents with this skill. A skill is a built-in module that provide the modeler a self-contain and relevant set of actions and variables. species people skills: [moving] { ... }  Then, we have to add new attributes to the people agents: living_place, working_place, start_work, end_work and objective. In addition, we will add a the_target variable that will represent the point toward which the agent will be currently moving. species people skills: [moving]{ rgb color &lt;- #yellow ; building living_place &lt;- nil ; building working_place &lt;- nil ; int start_work ; int end_work ; string objective ; point the_target &lt;- nil ; ... }  We define two reflexes that allow to change the objective (and the_target) of the agent at the start_work and end_work hours. Concerning the_target value, we choose a random point in the objective building (working_place or living_place) by using the any_location_in operator. The attribute current_date is a built-in global attribute of type date that is automatically incremented from the starting_date of the simulation by step value. species people skills: [moving]{ ... reflex time_to_work when: current_date.hour = start_work and objective = &quot;resting&quot; { objective &lt;- &quot;working&quot; ; the_target &lt;- any_location_in (working_place); } reflex time_to_go_home when: current_date.hour = end_work and objective = &quot;working&quot; { objective &lt;- &quot;resting&quot; ; the_target &lt;- any_location_in (living_place); } ... }  At last, we define a reflex that allows the agent to move. If a target point is defined (the_target != nil), the agent moves toward its target using the goto action (provided by the moving skill). Note that we specified a graph to constraint the movement of the agents on the road network with the facet on. We will see later how this graph is built. The agent uses the shortest path (according to the graph) to go to the target point. When the agent arrives at its destination (the_target = self.location), the target is set to nil (the agent will stop moving). species people skills: [moving]{ ... reflex move when: the_target != nil { do goto target: the_target on: the_graph ; if the_target = location { the_target &lt;- nil ; } } }  "},{"title":"Parameters​","type":1,"pageTitle":"3. Movement of People","url":"wiki/RoadTrafficModel_step3#parameters","content":"We add several parameters (and thus global variables) (min_work_start, max_work_start, min_work_end, max_work_end, min_speed and max_speed) and two global variables: the_graph (graph computed from the road network). In addition, we set the starting date in order that the simulation starts at midnight. In the global section: global { ... date starting_date &lt;- date(&quot;2019-09-01-00-00-00&quot;); int min_work_start &lt;- 6; int max_work_start &lt;- 8; int min_work_end &lt;- 16; int max_work_end &lt;- 20; float min_speed &lt;- 1.0 #km / #h; float max_speed &lt;- 5.0 #km / #h; graph the_graph; ... }  In the experiment section, we add a parameter statement for each global variable we want to have as a parameter: experiment road_traffic type: gui { ... parameter &quot;Earliest hour to start work&quot; var: min_work_start category: &quot;People&quot; min: 2 max: 8; parameter &quot;Latest hour to start work&quot; var: max_work_start category: &quot;People&quot; min: 8 max: 12; parameter &quot;Earliest hour to end work&quot; var: min_work_end category: &quot;People&quot; min: 12 max: 16; parameter &quot;Latest hour to end work&quot; var: max_work_end category: &quot;People&quot; min: 16 max: 23; parameter &quot;minimal speed&quot; var: min_speed category: &quot;People&quot; min: 0.1 #km/#h ; parameter &quot;maximal speed&quot; var: max_speed category: &quot;People&quot; max: 10 #km/#h; ... }  "},{"title":"Initialization​","type":1,"pageTitle":"3. Movement of People","url":"wiki/RoadTrafficModel_step3#initialization","content":"First, we need to compute from the road agents, a graph for the moving of the people agents. The operator as_edge_graph allows doing that. It automatically builds from a set of agents or geometries a graph where the agents are the edges of the graph, a node represent the extremities of the agent geometry. global { init { ... create road from: shape_file_roads ; the_graph &lt;- as_edge_graph(road); ... }  We randomly assign one working place and one house to each people agent. To simplify the GAML code, we define two temporary variables: the list of buildings of type 'Residential' and the list of buildings of type 'Industrial' (by using the where command). At the creation of each people agent, we initialize its speed (built-in attribute coming from the moving skill), start_work and end_work to each people agent (according to the min and max values defined in the global). We define as well an initial objective (&quot;resting&quot;). Concerning the definition of the living_place and working_place, these ones are randomly chosen among the residential_buildings and industrial_buildings lists.  init { ... list&amp;lt;building&gt; residential_buildings &lt;- building where (each.type=&quot;Residential&quot;); list&amp;lt;building&gt; industrial_buildings &lt;- building where (each.type=&quot;Industrial&quot;) ; create people number: nb_people { speed &lt;- rnd(min_speed, max_speed); start_work &lt;- rnd (min_work_start, max_work_start); end_work &lt;- rnd(min_work_end, max_work_end); living_place &lt;- one_of(residential_buildings) ; working_place &lt;- one_of(industrial_buildings) ; objective &lt;- &quot;resting&quot;; location &lt;- any_location_in (living_place); } ... }  "},{"title":"Complete Model​","type":1,"pageTitle":"3. Movement of People","url":"wiki/RoadTrafficModel_step3#complete-model","content":"https://github.com/gama-platform/gama/blob/GAMA_1.8.2/msi.gama.models/models/Tutorials/Road%20Traffic/models/Model%2003.gaml  "},{"title":"5. Dynamic weights","type":0,"sectionRef":"#","url":"wiki/RoadTrafficModel_step5","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"5. Dynamic weights","url":"wiki/RoadTrafficModel_step5#formulation","content":"At initialization, the value of the destruction_coeff of the road agents will be equal to 1.Add a new parameter: the destroy parameter that represents the value of destruction when a people agent takes a road. By default, it is equal to 0.02.When a people agent arrive at its destination (home or work), it updates the destruction_coeff of the road agents it took to reach its destination: &quot;destruction_coeff = destruction_coeff - destroy&quot;. Then, the graph is updated. "},{"title":"Model Definition​","type":1,"pageTitle":"5. Dynamic weights","url":"wiki/RoadTrafficModel_step5#model-definition","content":""},{"title":"global section​","type":1,"pageTitle":"5. Dynamic weights","url":"wiki/RoadTrafficModel_step5#global-section","content":"We add the destroy parameter. In the global section, we define the destroy variable: float destroy &lt;- 0.02;  In the experiment section, we add a parameter: parameter &quot;Value of destruction when a people agent takes a road&quot; var: destroy category: &quot;Road&quot; ;  We define a new reflex that updates the graph at each simulation step. For that, we use the with_weights operator. This operator allows to update the weights of an existing graph. global { ... reflex update_graph{ map&amp;lt;road,float&gt; weights_map &lt;- road as_map (each:: (each.destruction_coeff * each.shape.perimeter)); the_graph &lt;- the_graph with_weights weights_map; } }  "},{"title":"people agents​","type":1,"pageTitle":"5. Dynamic weights","url":"wiki/RoadTrafficModel_step5#people-agents","content":"At each time-step, after a people agent has moved over one or multiple road segments, it updates the value of the destruction coefficient of road agents crossed (i.e. roads belonging to the path followed). We have for that to set the argument return_path to true in the goto action to obtain the path followed, then to compute the list of agents concerned by this path with the operator agent_from_geometry. species people skills: [moving]{ ... reflex move when: the_target != nil { path path_followed &lt;- goto(target: the_target, on:the_graph, return_path: true); list&amp;lt;geometry&gt; segments &lt;- path_followed.segments; loop line over: segments { float dist &lt;- line.perimeter; ask road(path_followed agent_from_geometry line) { destruction_coeff &lt;- destruction_coeff + (destroy * dist / shape.perimeter); } } if the_target = location { the_target &lt;- nil ; } } ... }  "},{"title":"Complete Model​","type":1,"pageTitle":"5. Dynamic weights","url":"wiki/RoadTrafficModel_step5#complete-model","content":"https://github.com/gama-platform/gama/blob/GAMA_1.8.2/msi.gama.models/models/Tutorials/Road%20Traffic/models/Model%2005.gaml  "},{"title":"7. Automatic Road Repair","type":0,"sectionRef":"#","url":"wiki/RoadTrafficModel_step7","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"7. Automatic Road Repair","url":"wiki/RoadTrafficModel_step7#formulation","content":"Add a new parameter, repair_time, that is equal to 2.Every repair_time, the road with the highest destruction_coeff value is repaired (set its destruction_coeff to 1). "},{"title":"Model Definition​","type":1,"pageTitle":"7. Automatic Road Repair","url":"wiki/RoadTrafficModel_step7#model-definition","content":""},{"title":"parameters​","type":1,"pageTitle":"7. Automatic Road Repair","url":"wiki/RoadTrafficModel_step7#parameters","content":"We add a new parameter: the repair_time. In the global section, we define the repair_time variable: int repair_time &lt;- 2 ;  In the experiment section, we define the associated parameter: parameter &quot;Number of steps between two road repairs&quot; var: repair_time category: &quot;Road&quot; ;  "},{"title":"road repairing​","type":1,"pageTitle":"7. Automatic Road Repair","url":"wiki/RoadTrafficModel_step7#road-repairing","content":"We have to add a reflex method in the global section that is triggered every repair_time hours. This reflex selects, thanks to the with_max_of operator the road agent with the highest destruction_coeff value, then sets this value at 1. global { ... reflex repair_road when: every(repair_time #hour) { road the_road_to_repair &lt;- road with_max_of (each.destruction_coeff) ; ask the_road_to_repair { destruction_coeff &lt;- 1.0 ; } } }  "},{"title":"Complete Model​","type":1,"pageTitle":"7. Automatic Road Repair","url":"wiki/RoadTrafficModel_step7#complete-model","content":"https://github.com/gama-platform/gama/blob/GAMA_1.8.2/msi.gama.models/models/Tutorials/Road%20Traffic/models/Model%2007.gaml  "},{"title":"6. Charts","type":0,"sectionRef":"#","url":"wiki/RoadTrafficModel_step6","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"6. Charts","url":"wiki/RoadTrafficModel_step6#formulation","content":"Add a chart to display the evolution of the road destruction: the mean value of the destruction_coeff of the road agents, and its max value (refreshed every 10 simulation steps).Add a chart to display the activity of the people agent (working or staying home, refreshed every 10 simulation steps). "},{"title":"Model Definition​","type":1,"pageTitle":"6. Charts","url":"wiki/RoadTrafficModel_step6#model-definition","content":""},{"title":"chart display​","type":1,"pageTitle":"6. Charts","url":"wiki/RoadTrafficModel_step6#chart-display","content":"First, we add a chart of type series to display the road destruction evolution. To compute the mean of the destruction_coeff, we combine the mean and collect operators. collect takes a container and an expression as operands and will compute a new list, each element being the evaluation on the container operand of the expression. mean computes the average of all the elements of a list. For the max, we use the max_of operator. (Note that the operator mean_of also exists to replace mean and collect).  output { display chart_display refresh:every(10#cycles) { chart &quot;Road Status&quot; type: series size: {1, 0.5} position: {0, 0} { data &quot;Mean road destruction&quot; value: mean (road collect each.destruction_coeff) style: line color: #green ; data &quot;Max road destruction&quot; value: road max_of each.destruction_coeff style: line color: #red ; } ... } }  Second, we add a chart of type pie to display the activity of the people agents. We use for that the objective variable of the people agents and the count operator that allows computing the number of elements of a list that verify a condition.  output { ... display chart_display refresh: every(10#cycles) { ... chart &quot;People Objectif&quot; type: pie style: exploded size: {1, 0.5} position: {0, 0.5}{ data &quot;Working&quot; value: people count (each.objective=&quot;working&quot;) color: #magenta ; data &quot;Resting&quot; value: people count (each.objective=&quot;resting&quot;) color: #blue ; } } }  We chose to display the 2 charts on the same display. As a consequence, we specified the size and position of each of them to define the layout of this display. "},{"title":"Complete Model​","type":1,"pageTitle":"6. Charts","url":"wiki/RoadTrafficModel_step6#complete-model","content":"https://github.com/gama-platform/gama/blob/GAMA_1.8.2/msi.gama.models/models/Tutorials/Road%20Traffic/models/Model%2006.gaml  "},{"title":"Running Experiments","type":0,"sectionRef":"#","url":"wiki/RunningExperiments","content":"","keywords":""},{"title":"Generic knowledge to start GAMA Headless​","type":1,"pageTitle":"Running Experiments","url":"wiki/RunningExperiments#generic-knowledge-to-start-gama-headless","content":"There are two ways to run a GAMA experiment in headless mode: using a dedicated bash wrapper (recommended) or directly from the command line. "},{"title":"Bash Wrapper​","type":1,"pageTitle":"Running Experiments","url":"wiki/RunningExperiments#bash-wrapper","content":"The file can be found in the headless directory located inside the GAMA's installed folder. It is named gama-headless.sh on macOS and Linux, or gama-headless.bat on Windows.  bash gama-headless.sh [m/c/t/hpc/v] $1 $2  with: $1 input parameter file : an xml file determining experiment parameters and attended outputs$2 output directory path : a directory which contains simulation results (numerical data and simulation snapshot)options [-m/c/t/hpc/v] -m memory : memory allocated to gama-c : console mode, the simulation description could be written with the stdin-t : tunneling mode, simulation description are read from the stdin, simulation results are printed out in stdout-hpc nb_of_cores : allocate a specific number of cores for the experiment plan-v : verbose mode. trace are displayed in the console  For example (using the provided sample), navigate in your terminal to the headless folder inside your GAMA root folder and type: bash gama-headless.sh samples/predatorPrey.xml outputHeadLess  As specified in predatorPrey.xml, this command runs the prey - predator model for 1000 steps and record a screenshot of the main display every 5 steps. The screenshots are recorded in the directory outputHeadLess (under the GAMA root folder). Note that the current directory to run gama-headless command must be $GAMA_PATH/headless "},{"title":"Java Command​","type":1,"pageTitle":"Running Experiments","url":"wiki/RunningExperiments#java-command","content":"java -cp $GAMA_CLASSPATH -Xms512m -Xmx2048m -Djava.awt.headless=true org.eclipse.core.launcher.Main -application msi.gama.headless.id4 $1 $2  with: $GAMA_CLASSPATH GAMA classpath: contains the relative or absolute path of jars inside the GAMA plugin directory and jars created by users$1 input parameter file: an XML file determining experiment parameters and attended outputs$2 output directory path: a directory which contains simulation results (numerical data and simulation snapshot) Note that the output directory is created during the experiment and should not exist before. "},{"title":"Running Headless","type":0,"sectionRef":"#","url":"wiki/RunningHeadless","content":"","keywords":""},{"title":"What is GAMA Headless​","type":1,"pageTitle":"Running Headless","url":"wiki/RunningHeadless#what-is-gama-headless","content":"The headless mode gives the possibility run one or multiple instances of GAMA without any user interface so that models and experiments can be launched on a grid or a cluster. Without GUI, the memory footprint, as well as the speed of the simulations, are usually greatly improved. In this mode, GAMA can only be used to run experiments. Editing or managing models is not possible. In order to launch experiments and still benefit from a user interface (which can be used to prepare headless experiments), launch GAMA normally (see here) and refer to this page for instructions. "},{"title":"Different headless modes​","type":1,"pageTitle":"Running Headless","url":"wiki/RunningHeadless#different-headless-modes","content":"The first and oldest way, called Legacy mode and detailed here, consists in explicitly writing your full experiment plan (i.e each simulation you want to run, with each parameter sets) in an XML file. This way of using the Headless was the first implementation of the headless inside GAMA.The second way, called Headless Batch and detailed on this page, allows launching a GAML batch experiment in headless mode (i.e. without having to open GAMA's interface). This way is the most natural way to use the headless as it works exactly like in GUI Batch mode.The last way, called Headless Server and described there, let you open an interactive GAMA headless server on which you can dynamically send experiments to run. This last mode is interesting for using GAMA as back-end of other project like web projects. "},{"title":"General knowledge about using GAMA Headless​","type":1,"pageTitle":"Running Headless","url":"wiki/RunningHeadless#general-knowledge-about-using-gama-headless","content":"There are two ways to run a GAMA experiment in headless mode: using a dedicated bash wrapper (recommended) or directly from the command line. "},{"title":"Bash Wrapper (recommended)​","type":1,"pageTitle":"Running Headless","url":"wiki/RunningHeadless#bash-wrapper-recommended","content":"The wrapper file can be found in the headless directory located inside Gama's installed folder. It is named gama-headless.sh on macOS and Linux, or gama-headless.bat on Windows. You can start using it like so :  bash ./gama-headless.sh [m/c/hpc/v] [launchingMode]  with: general headless options [-m/c/t/hpc/v] -m memory : memory allocated to gama (e.g. -m 8g to set it at 8GiB)-c : console mode, the simulation description could be written with the stdin-hpc nb_of_cores : limit to a specific number of cores the number of simulation running in parallel (eg. -hpc 3 to limit GAMA at using 3 cores/running 3 simulation at a time=-v : verbose mode. trace are displayed in the console launchingMode will depend on which headless mode you'll use and explained in following pages You also can display general help on every options with this command: bash ./gama-headless.sh -help  Which, for release 1.8.2, will output: ****************************************************************** * GAMA version 1.8.2 * * http://gama-platform.org * * (c) 2007-2022 UMI 209 UMMISCO IRD/SU &amp; Partners * ****************************************************************** Welcome to Gama-platform.org version GAMA 1.8.2 sh ./gama-headless.sh [Options] List of available options: === Headless Options === -m [mem] -- allocate memory (ex 2048m) -c -- start the console to write xml parameter file -v -- verbose mode -hpc [core] -- set the number of core available for experimentation -socket [socketPort] -- start socket pipeline to interact with another framework -p -- start pipeline to interact with another framework === Infos === -help -- get the help of the command line -version -- get the the version of gama === Library Runner === -validate -- invokes GAMA to validate models present in built-in library and plugins -test -- invokes GAMA to execute the tests present in built-in library and plugins and display their results === GAMA Headless Runner === -batch [experimentName] [modelFile.gaml] -- Run batch experiment in headless mode -xml [experimentName] [modelFile.gaml] [xmlOutputFile.xml] -- build an xml parameter file from a model [xmlHeadlessFile.xml] [outputDirectory] -- default usage of GAMA headless  "},{"title":"Java Command (hard)​","type":1,"pageTitle":"Running Headless","url":"wiki/RunningHeadless#java-command-hard","content":"As GAMA is developed in Java, you can start the Headless mode by load appropriate bundle and starting it like this: java -cp $GAMA_CLASSPATH -Xms512m -Xmx2048m -Djava.awt.headless=true org.eclipse.core.launcher.Main -application msi.gama.headless.id4 [options]  with: $GAMA_CLASSPATH: contains the relative or absolute path of jars inside the GAMA plugin directory and jars created by usersoptions as explained above and in following pages Note that we recommend you to open bash wrapper to have more detailed about how we imagine starting GAMA in headless mode. "},{"title":"Runtime Concepts","type":0,"sectionRef":"#","url":"wiki/RuntimeConcepts","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Runtime Concepts","url":"wiki/RuntimeConcepts#table-of-contents","content":"Simulation initializationAgents CreationAgents StepSchedule Agents "},{"title":"Simulation initialization​","type":1,"pageTitle":"Runtime Concepts","url":"wiki/RuntimeConcepts#simulation-initialization","content":"Once the user launches an experiment, GAMA starts by creating an experiment agent that will manage the initialization of the simulation(s). For each simulation, first, it creates a world agent. It initializes all its attributes with their init values. This includes its shape (that will be used as the environment of the simulation). If a species of type grid exists in the model, agents of this species are created. Finally, the init statement of the global is executed. It should include the creation of all the other agents of regular species of the simulation. After their creation and initialization, they are added in the list members the world (that contains all the micro-agent of the world). "},{"title":"Agents Creation​","type":1,"pageTitle":"Runtime Concepts","url":"wiki/RuntimeConcepts#agents-creation","content":"Except grid agents, other agents are created using the create statement. It is used to allocate memory for each agent and to initialize all its attributes. If no explicit initialization exists for an attribute, it will get the default value corresponding to its type. The initialization of an attribute can be located at several places in the code; they are executed in the following order (which means that, if several ways are used, the attribute will finally have the value of the last applied one): in the attribute declaration, using the init or &lt;- facet.using the from: or with facet of the create statement.in the init block of the species.in the embedded block of the create statement. "},{"title":"Agents Step​","type":1,"pageTitle":"Runtime Concepts","url":"wiki/RuntimeConcepts#agents-step","content":"When an agent is asked to step, it means that it is expected to: update its variables (facet update in the variable declaration), run its behaviors (reflex, state...),step its micro-agents (if any). step of agent agent_a { species_a &lt;- agent_a.species architecture_a &lt;- species_a.architecture ask architecture_a to step agent_a { ask agent_a to update species_a.variables ask agent_a to run architecture_a.behaviors } ask each micro-population mp of agent_a to step { list&amp;lt;agent&gt; sub-agents &lt;- mp.compute_agents_to_schedule ask each agent_b of sub-agents to step //... recursive call... } }  Notice that, using architecture to manage the behavior of agents, is only a possibility provided by GAMA to ease the development of a model. Modelers who need precise control on the agents' step can: redefine the _step_ action of the species, in order to explicit how the agents will behave,implement no behavior in the species (but only action). The execution of agents can thus be controlled from a reflex of the global that can control the execution of each of them. "},{"title":"Schedule Agents​","type":1,"pageTitle":"Runtime Concepts","url":"wiki/RuntimeConcepts#schedule-agents","content":"The global scheduling of agents is then simply the application of this previous step to the experiment agent, keeping in mind that this agent has only one micro-population (of simulation agents, each instance of the model species), and that the simulation(s) inside this population contain(s), in turn, all the &quot;regular&quot; populations of agents of the model. To influence this schedule, then, one possible way is to change the way populations compute their lists of agents to schedule, which can be done in a model by providing custom definitions to the schedules facet of one or several species. A practical application of this facet is to reduce simulation artifacts created by the default scheduling of populations, which is sequential (i.e. their agents are executed in turn in their order of creation). To enable pseudo-parallel scheduling based on a random scheduling recomputed at each step, one has simply to define the corresponding species like in the following example: species A schedules: shuffle(A) {...}  Moving further, it is possible to enable completely random scheduling, that will eliminate the sequential scheduling of populations, by defining a custom species acting as a scheduler of the agents (that will be executed after the world agent): global {...} species scheduler schedules: shuffle(A + B + C); species A schedules: [] {...} species B schedules: [] {...} species C schedules: [] {...}  It is important to suppress the population-based scheduling to avoid having agents being scheduled 2 times (one time in the custom definition, one time by their population). Note that it is not necessary to create a scheduler agent. Other schemes are possible. For instance, the following definition will completely suppress the default scheduling mechanism to replace it with a custom scheduler that will execute the world, then all agents of species A in a random way and then all agents of species B in their order of creation: global {...} species scheduler schedules: shuffle(A) + B; // explicit scheduling in the world species A schedules []; species B schedules: [];  Complex conditions can be used to express which agents need to be scheduled at each step. For instance, in the following definition, only agents of A that return true to a particular condition are scheduled: species A schedules: A where each.can_be_scheduled() { bool can_be_scheduled() { ... returns true_or_false; } }  Be aware that enabling a custom scheduling can potentially end up in non-functional simulations. For example, the following definition will result in an infinite loop (which will trigger a stack overflow at some point): global {} // The world is normally scheduled... species my_scheduler schedules: [world]; // ... but schedules itself again as a consequence of scheduling the micro-species 'my_scheduler'  Note that schedules facet will not be taken into account when it is added to the global. It is thus not possible to unschedule the world agent. "},{"title":"Run Several Simulations","type":0,"sectionRef":"#","url":"wiki/RunSeveralSimulations","content":"","keywords":""},{"title":"Index​","type":1,"pageTitle":"Run Several Simulations","url":"wiki/RunSeveralSimulations#index","content":"Create a simulationManipulate simulationsRandom seed Defining the seed from the modelDefining the seed from the experimentRun several simulations with the same random numbersChange the RNG "},{"title":"Create a simulation​","type":1,"pageTitle":"Run Several Simulations","url":"wiki/RunSeveralSimulations#create-a-simulation","content":"Let's remind you that in GAMA, everything is an agent. We already saw that the &quot;world&quot; agent is the agent of the model. The model is thus a species, called modelName_model : model toto // &lt;- the name of the species is &quot;toto_model&quot;  New highlight of the day : an Experiment is also an agent ! It's a special agent which will instantiate automatically an agent from the model species. You can then perfectly create agents (model agents) from your experiment, using the statement create : model multi_simulations // the &quot;world&quot; is an instance of the &quot;multi_simulations_model&quot; global { } experiment my_experiment type:gui { init { create multi_simulations_model; } }  This sort model will instantiate 2 simulations (two instance of the model) : one is created automatically by the experiment, and the second one is explicitly created through the statement create. To simplify the syntax, you can use the built-in attribute simulation of your experiment. When you have a model called &quot;multi_simulations&quot;, the two following lines are strictly equal : create multi_simulations_model; create simulation;  As it was the case for creating regular species, you can specify the parameters of your agent during the creation through the facet with: : model multi_simulations global { rgb bgd_color; } experiment my_experiment type:gui { parameter name:&quot;background color:&quot; var:bgd_color init:#blue; init { create simulation with:[bgd_color::#red]; } output { display &quot;my_display&quot; background:bgd_color{} } }  "},{"title":"Manipulate simulations​","type":1,"pageTitle":"Run Several Simulations","url":"wiki/RunSeveralSimulations#manipulate-simulations","content":"When you think the simulations as agents, it gives you a lot of new possibilities. You can for example create a reflex from your experiment, asking to create simulations during the experiment execution ! The following short model for example will create a new simulation at each 10 cycles : model multi_simulations global { init { write &quot;new simulation created ! Its name is &quot;+name; } } experiment my_experiment type:gui { init { } reflex when:(mod(cycle,10)=0 and cycle!=0) { create simulation; } output { } }  You may ask, what is the purpose of such a thing ? Well, with such a short model, it is not very interesting, for sure. But you can imagine running a simulation, and if the simulation reaches a certain state, it can be closed, and another simulation can be run instead with different parameters (a simulation can be closed by doing a &quot;do die&quot; on itself). You can also imagine to run two simulations, and to communicate from one to an other through the experiment, as it is shown in this easy model, where agents can move from one simulation to another :  model smallWorld global { int grid_size &lt;- 10; bool modelleft &lt;- true; int id&lt;- 0; int nb_agents &lt;- 50; init { create people number: nb_agents { my_cell &lt;- one_of(cell); location &lt;- my_cell.location; } if (modelleft) { ask cell where (each.grid_x = (grid_size - 1)) { color &lt;- #red; } } else { ask cell where (each.grid_x = 0) { color &lt;- #red; } } } action changeWorld(rgb color, point loc) { create people with:[color::color, location::loc] { my_cell &lt;- cell(location); } } } species people { rgb color &lt;- rnd_color(255); cell my_cell; reflex move { if (modelleft and my_cell.color = #red) { ask smallWorld_model[1] { do changeWorld(myself.color, {100 - myself.location.x,myself.location.y}); } do die; } else { list&amp;lt;cell&gt; free_cells &lt;- list&amp;lt;cell&gt; (my_cell.neighbors) where empty(people inside each); if not empty(free_cells) { my_cell &lt;- one_of(free_cells); location &lt;- my_cell.location; } } } aspect default { draw circle(50/grid_size) color: color; } } grid cell width: grid_size height: grid_size; experiment fromWorldToWorld type: gui { init { create simulation with:[grid_size::20, modelleft::false, id::1, nb_agents::0]; } output { display map { grid cell lines: #black; species people; } } }  Here is an other example of application of application, available in the model library. Here we run 4 times the Ant Foraging model, with different parameters.  "},{"title":"Random seed​","type":1,"pageTitle":"Run Several Simulations","url":"wiki/RunSeveralSimulations#random-seed","content":""},{"title":"Defining the seed from the model​","type":1,"pageTitle":"Run Several Simulations","url":"wiki/RunSeveralSimulations#defining-the-seed-from-the-model","content":"If you run several simulations, you may want to use the same seed for each one of those simulations (to compare the influence of a certain parameter, in exactly the same conditions). Let's remind you that seed is a built-in attribute of the model. You than just need to specify the value of your seed during the creation of the simulation if you want to fix the seed : create simulation with:[seed::10.0];  You can also specify the seed if you are inside the init scope of your global agent. global { init { seed&lt;-10.0; } }  Notice that if you affect the value of your seed built-in directly in the global scope, the affectation of the parameters (for instance specified with the facet with of the statement create), and the &quot;init&quot; will be done after will be done at the end. "},{"title":"Defining the seed from the experiment​","type":1,"pageTitle":"Run Several Simulations","url":"wiki/RunSeveralSimulations#defining-the-seed-from-the-experiment","content":"The experiment agent also have a built-in attribute seed. The value of this seed is defined in your simulation preferences. The first simulation created is created with the seed value of the experiment. The following sequence diagram can explain you better how the affectation of the seed attribute works :  The affectation of an attribute is always done in this order : (1) the attribute is affected with a specific value in the species scope. If no attribute value is specified, the value is a default value. (2) if a value is specified for this attribute in the create statement, then the attribute value is affected again. (3) the attribute value can be changed again in the init scope. "},{"title":"Run several simulations with the same random numbers​","type":1,"pageTitle":"Run Several Simulations","url":"wiki/RunSeveralSimulations#run-several-simulations-with-the-same-random-numbers","content":"The following code shows how to run several simulations with a specific seed, determined from the experiment agent : model multi_simulations global { init { create my_species; } } species my_species skills:[moving] { reflex update { do wander; } aspect base { draw circle(2) color:#green; } } experiment my_experiment type:gui { float seedValue &lt;- 10.0; float seed &lt;- seedValue; // force the value of the seed. init { // create a second simulation with the same seed as the main simulation create simulation with:[seed::seedValue]; } output { display my_display { species my_species aspect:base; } } }  When you run this simulation, their execution is exactly similar.  Let's try now to add a new species in this model, and to add a parameter to the simulation for the number of agents created for this species. model multi_simulations global { int number_of_speciesB &lt;- 1; init { create my_speciesA; create my_speciesB number:number_of_speciesB; } } species my_speciesA skills:[moving] { reflex update { do wander; } aspect base { draw circle(2) color:#green; } } species my_speciesB skills:[moving] { reflex update { do wander; } aspect base { draw circle(2) color:#red; } } experiment my_experiment type:gui { float seedValue &lt;- 10.0; float seed &lt;- seedValue; // force the value of the seed. init { create simulation with:[seed::seedValue,number_of_speciesB::2]; } output { display my_display { species my_speciesA aspect:base; species my_speciesB aspect:base; } } }  Then you run the experiment, you may find something strange...  Even if the first step seems ok (the green agent and one of the two red agent is initialized with the same location), the simulation differs completely. You should have expected to have the same behavior for the green agent in both of the simulation, but it is not the case. The explanation of this behavior is that a random number generator has generated more random numbers in the second simulation than in the first one. If you don't understand, here is a short example that may help you to understand better : model multi_simulations global { int iteration_number &lt;- 1; reflex update { float value; loop times:iteration_number { value&lt;-rnd(10.0); write value; } write &quot;cycle &quot;+cycle+&quot; in experiment &quot;+name+&quot; : &quot;+value; } } experiment my_experiment type:gui { float seedValue &lt;- 10.0; float seed &lt;- seedValue; // force the value of the seed. init { create simulation with:[seed::seedValue,iteration_number::2]; } output { } }  The output will be something like that : 7.67003069780383 cycle 0 in experiment multi_simulations_model0 : 7.67003069780383 7.67003069780383 0.22889843360303863 cycle 0 in experiment multi_simulations_model1 : 0.22889843360303863 0.22889843360303863 cycle 1 in experiment multi_simulations_model0 : 0.22889843360303863 4.5220913306263855 0.8363180333035425 cycle 1 in experiment multi_simulations_model1 : 0.8363180333035425 4.5220913306263855 cycle 2 in experiment multi_simulations_model0 : 4.5220913306263855 5.460148568140819 4.158355846617511 cycle 2 in experiment multi_simulations_model1 : 4.158355846617511 0.8363180333035425 cycle 3 in experiment multi_simulations_model0 : 0.8363180333035425 1.886091659169562 4.371253083874633 cycle 3 in experiment multi_simulations_model1 : 4.371253083874633  Which means : Cycle\tValue generated in simulation 0\tValue generated in simulation 11\t7.67003069780383\t7.67003069780383 0.22889843360303863 2\t0.22889843360303863\t4.5220913306263855 0.8363180333035425 3\t4.5220913306263855\t5.460148568140819 4.158355846617511 When writing your models, you have to be aware of this behavior. Remember that each simulation has it's own random number generator. "},{"title":"Change the RNG​","type":1,"pageTitle":"Run Several Simulations","url":"wiki/RunSeveralSimulations#change-the-rng","content":"The RNG (random number generator) can also be changed : rng is a string built-in attribute of the experiment (and also of the model). You can choose among the following rng : mersenne (by default)cellularjava The following model shows how to run 4 simulations with the same seed but with some different RNG : model multi_simulations global { init { create my_species number:50; } } species my_species skills:[moving] { reflex update { do wander; } aspect base { draw square(2) color:#blue; } } experiment my_experiment type:gui { float seed &lt;- 10.0; init { create simulation with:[rng::&quot;cellular&quot;,seed::10.0]; create simulation with:[rng::&quot;java&quot;,seed::10.0]; } output { display my_display { species my_species aspect:base; graphics &quot;my_graphic&quot; { draw rectangle(35,10) at:{0,0} color:#lightgrey; draw rng at:{3,3} font:font(&quot;Helvetica&quot;, 20 , #plain) color:#black; } } } }  "},{"title":"Start with GAML","type":0,"sectionRef":"#","url":"wiki/StartWithGAML","content":"Start with GAML In this part, we will present you some basic concepts of GAML that will help you a lot for the next pages. You will first learn how to organize a standard model, then you will learn about some basis about GAML, such as how to declare a variable, how to use the basic operators, how to write a conditional structure or a loop, how to manipulate containers and how to generate random values.","keywords":""},{"title":"Save and Restore simulations","type":0,"sectionRef":"#","url":"wiki/Save-and-restore-simulations","content":"","keywords":""},{"title":"Save a simulation​","type":1,"pageTitle":"Save and Restore simulations","url":"wiki/Save-and-restore-simulations#save-a-simulation","content":"experiment saveSimu type: gui { reflex store when: cycle = 5 { write &quot;================ START SAVE + self &quot; + &quot; - &quot; + cycle ; write &quot;Save of simulation : &quot; + saveSimulation('saveSimu.gsim'); write &quot;================ END SAVE + self &quot; + &quot; - &quot; + cycle ; } output { display main_display { species road aspect: geom; species people aspect: base; } } }  "},{"title":"Restore a simulation​","type":1,"pageTitle":"Save and Restore simulations","url":"wiki/Save-and-restore-simulations#restore-a-simulation","content":"experiment reloadSavedSimuOnly type: gui { action _init_ { create simulation from: saved_simulation_file(&quot;saveSimu.gsim&quot;); } output { display main_display { species road aspect: geom; species people aspect: base; } } }  "},{"title":"Memorize simulation​","type":1,"pageTitle":"Save and Restore simulations","url":"wiki/Save-and-restore-simulations#memorize-simulation","content":"model memorize global { init{ create people number:1; } } species people skills: [moving] { init{ location &lt;- {50, 50}; } reflex movement { location &lt;- {location.x + 1,location.y}; } aspect base { draw circle(5) color: color; draw &quot;&quot;+cycle; } } experiment memorizeExp type: memorize { output { display map { species people aspect: base; } } }  "},{"title":"3D Tutorial","type":0,"sectionRef":"#","url":"wiki/ThreeD","content":"","keywords":""},{"title":"Model Overview​","type":1,"pageTitle":"3D Tutorial","url":"wiki/ThreeD#model-overview","content":" "},{"title":"Step List​","type":1,"pageTitle":"3D Tutorial","url":"wiki/ThreeD#step-list","content":"This tutorial is composed of 3 steps corresponding to 3 models. For each step, we present its purpose, an explicit formulation, and the corresponding GAML code. Basic modelMoving cellsMoving cells with neighbors "},{"title":"1. Basic Model","type":0,"sectionRef":"#","url":"wiki/ThreeD_step1","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"1. Basic Model","url":"wiki/ThreeD_step1#formulation","content":"Initialize a 3D world with a population of cells placed randomly in a 3D 100x100x100 cube. Definition of the cell species.Definition of the nb_cells parameter.Creation of nb_cells cell agents randomly located in the 3D environment, that is defined as a cub of dimensions: 100x100x100.  "},{"title":"Model Definition​","type":1,"pageTitle":"1. Basic Model","url":"wiki/ThreeD_step1#model-definition","content":"In this model, we define one species of agent: the cell species. The agents will be just displayed as a blue sphere of radius 1. species cell { aspect default { draw sphere(1) color: #blue; } }  "},{"title":"Global Section​","type":1,"pageTitle":"1. Basic Model","url":"wiki/ThreeD_step1#global-section","content":"Global variables​ Definition of a global variable nb_cells of type int representing the number of cell agents. global { int nb_cells &lt;- 100; }  Model initialization​ Definition of the init block in order to create nb_cells cell agents. By default, an agent is created with a random location in x and y, and a z value equal to 0. In our case, we want to place the cell agents randomly in the 3D environment so we set a random value for x, y and z. create cell number: nb_cells { location &lt;- {rnd(100), rnd(100), rnd(100)}; }  "},{"title":"Experiment​","type":1,"pageTitle":"1. Basic Model","url":"wiki/ThreeD_step1#experiment","content":"In our model, we define a basic gui experiment called Tuto3D : experiment Tuto3D type: gui { }  Input​ Definition of a parameter from the global variable nb_cells : experiment Tuto3D type: gui { parameter &quot;Initial number of cells: &quot; var: nb_cells min: 1 max: 1000 category: &quot;Cells&quot;; }  Output​ In our model, we define a display to draw the cell agents in a 3D environment. output { display View1 type:opengl { species cell; } }  "},{"title":"Complete Model​","type":1,"pageTitle":"1. Basic Model","url":"wiki/ThreeD_step1#complete-model","content":"msi.gama.models/models/Tutorials/3D/models/Model%2001.gaml loading... See full example on GitHub "},{"title":"2. Moving Cells","type":0,"sectionRef":"#","url":"wiki/ThreeD_step2","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"2. Moving Cells","url":"wiki/ThreeD_step2#formulation","content":"Redefining the shape of the world with a 3D Shape.Attaching new skills (moving3D) to cell agents.Modify cell aspect.Add a graphics layer.  "},{"title":"Model Definition​","type":1,"pageTitle":"2. Moving Cells","url":"wiki/ThreeD_step2#model-definition","content":""},{"title":"Global Section​","type":1,"pageTitle":"2. Moving Cells","url":"wiki/ThreeD_step2#global-section","content":"Global variable​ We use a new global variable called environment_size to define the size of our 3D environment. In the global section, we define the new variable: int environment_size &lt;-100;  Then we redefine the shape of the world (by default the shape of the world is a 100x100 square) as a cube that will have the size defined by the environment_size variable. To do so we change the shape of the world in the global section: geometry shape &lt;- cube(environment_size);  Model initialization​ When we created the cell agents, we want to place them randomly in the 3D environment. To do so we set the location with a random value for x, y and z between 0 and environment_size. create cell number: nb_cells { location &lt;- {rnd(environment_size), rnd(environment_size), rnd(environment_size)}; }  "},{"title":"Moving3D skills​","type":1,"pageTitle":"2. Moving Cells","url":"wiki/ThreeD_step2#moving3d-skills","content":"In the previous example, we only created cell agents that did not have any behavior. In this step we want to make them move. To do so we add a moving3D skill to the cell species. More information on built-in skills proposed by GAMA can be found here. species cell skills: [moving3D]{ ... }  Then we define a new reflex for the species cell that consists in calling the action move bundled in moving3D skill. reflex move { do move; }  Finally we modify a bit the aspect of the sphere to set its size according to the environment_size global variable previously defined. aspect default { draw sphere(environment_size*0.01) color: #blue; }  "},{"title":"Experiment​","type":1,"pageTitle":"2. Moving Cells","url":"wiki/ThreeD_step2#experiment","content":"The experiment is the same as the previous one except that we will display the bounds of the environment by using a graphics layer. graphics &quot;env&quot; { draw cube(environment_size) color: #black wireframe: true; }  Output​ output { display View1 type:opengl{ graphics &quot;env&quot;{ draw cube(environment_size) color: #black wireframe: true; } species cell; } }  "},{"title":"Complete Model​","type":1,"pageTitle":"2. Moving Cells","url":"wiki/ThreeD_step2#complete-model","content":"msi.gama.models/models/Tutorials/3D/models/Model%2002.gaml loading... See full example on GitHub "},{"title":"3. Connections","type":0,"sectionRef":"#","url":"wiki/ThreeD_step3","content":"","keywords":""},{"title":"Formulation​","type":1,"pageTitle":"3. Connections","url":"wiki/ThreeD_step3#formulation","content":"Mapping the network of connection  "},{"title":"Model Definition​","type":1,"pageTitle":"3. Connections","url":"wiki/ThreeD_step3#model-definition","content":"In this final step, we will display edges between cells that are within a given distance. "},{"title":"Cells update​","type":1,"pageTitle":"3. Connections","url":"wiki/ThreeD_step3#cells-update","content":"We add a new reflex to collect the neighbors of the cell that are within a certain distance: species cells skills:[moving3D]{ ... reflex compute_neighbors { neighbors &lt;- cells select ((each distance_to self) &lt; 10); } }  Then we update the cell aspect as follows. For each element (cells) of the neighbors list, we draw a line between this neighbor's location and the current cell's location. aspect default { draw sphere(environment_size*0.01) color: #orange; loop pp over: neighbors { draw line([self.location,pp.location]); } }  "},{"title":"Complete Model​","type":1,"pageTitle":"3. Connections","url":"wiki/ThreeD_step3#complete-model","content":"msi.gama.models/models/Tutorials/3D/models/Model%2003.gaml loading... See full example on GitHub "},{"title":"Training Session","type":0,"sectionRef":"#","url":"wiki/TrainingSession","content":"","keywords":""},{"title":"SEARCA Phillippines 2021 (Online)​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#searca-phillippines-2021-online","content":"22-26 March, 2021 Trainers: Alexis Drogoul, Arthur Brugière, Patrick Taillandier, Nguyen Ngoc Doanh "},{"title":"AWP 2021(Online)​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#awp-2021online","content":"1-5 March, 2021 Trainers: Arthur Brugière, Alexis Drogoul, Huynh Quang Nghi, Nguyen Ngoc Doanh, Patrick Taillandier, Truong Chi Quang "},{"title":"USTH Training session 2020​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#usth-training-session-2020","content":"May 2020 - Hanoi, Vietnam Trainers: Benoit Gaudou "},{"title":"SMAC Toulouse 2020​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#smac-toulouse-2020","content":"April 2020 - Toulouse, France Trainers: Benoit Gaudou, Arthur Brugiere, Damien, Nicolas Verestaevel "},{"title":"Application to disaster management and evacuation​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#application-to-disaster-management-and-evacuation","content":"17-21 February - Cebu, Phillippines Trainers: Alexis Drogoul, Benoit Gaudou, Arthur Brugiere "},{"title":"Training session TLU 2019​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#training-session-tlu-2019","content":"October 2019 - Hanoi, Vietnam Trainers: Benoit Gaudou, Nguyen Ngoc Doanh, Arthur Brugiere, Doryan Kaced "},{"title":"AWP Phnom Penh 2019​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#awp-phnom-penh-2019","content":"8-12 July, Phnom Penh, Cambodia This is a training session that focuses on water urban risks: designing evacuation strategies in case of flooding with Agent-Based Modeling and GAMA "},{"title":"Formation Toulouse 2019​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#formation-toulouse-2019","content":"May 2019 - Toulouse, France Trainers: Patrick Taillandier, Doryan Kaced, Renauld Misslin, Frèdéric Amblard, Benoit Gaudou "},{"title":"Training session Brasilia 2019​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#training-session-brasilia-2019","content":"Feb 201 - Brasilia, Brazil Trainers: Benoit Gaudou, Ch. Le Page "},{"title":"Application to disaster management and evacuation​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#application-to-disaster-management-and-evacuation-1","content":"28 Jan - 1 Feb, Phillippines Trainers: Alexis Drogoul, Benoit Gaudou, Kevin Chapuis "},{"title":"AWP Can Tho 2018​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#awp-can-tho-2018","content":"July - Can Tho, Vietnam Trainers: Alexis Drogoul, Patrick Taillandier, Benoit Gaudou, Truong Chi Quang, Damien Philippon, Kevin Chapuis, Huynh Quang Nghi "},{"title":"SCEMSITE 2018​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#scemsite-2018","content":"May 2018 Trainers: Patrick Taillandier, Oliver Therond "},{"title":"Formation Toulouse 2018​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#formation-toulouse-2018","content":"Trainers: Patrick Taillandier, Benoit Gaudou "},{"title":"GAMA 1.7RC1 training session - Pays-Bas​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#gama-17rc1-training-session---pays-bas","content":"December 2017 "},{"title":"Analysis of land use dynamics (JTD 2017)​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#analysis-of-land-use-dynamics-jtd-2017","content":"9-14 July 2017 The JTD (Journées de Tam Dao) is an annual gathering of french-talkers researchers during the summer for one week, dealing with a specific subject related to sustainable development. For this 11th JTD, the topic was about the contributions of modeling for the analysis of land use dynamics. Case study: Thanh Phu district, Ben Tre province (Mekong delta) 2000-2010. Trainers: Alexis Drogoul, Patrick Taillandier, Quang Nghi Huynh, Quang Chi Truong, Damien Philippon "},{"title":"Master TRIAD 2017​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#master-triad-2017","content":"Jan 2017 "},{"title":"EDSS USTH Master 2016​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#edss-usth-master-2016","content":"November 2016 - Hanoi, Vietnam Trainers: Patrick Taillandier, Nicolas Marilleau, Benoit Gaudou "},{"title":"Design urban energy transition policies (JTD 2016)​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#design-urban-energy-transition-policies-jtd-2016","content":"10-15 July 2016 The JTD (Journées de Tam Dao) is an annual gathering of french-talkers researchers during the summer for one week, dealing with a specific subject related to sustainable development. For this 10th JTD, the topic was about the use of computer models to help design urban energy transition policies. Trainers: Javier Gil-Quijano, Alexis Drogoul, Benoît Gaudou, Patrick Taillandier, Julien Mazars, Hypatia Nassopoulos, Damien Philippon "},{"title":"Modeling for supporting decisions in urban management issues​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#modeling-for-supporting-decisions-in-urban-management-issues","content":"7-11 December 2015 - Siem Reap (Cambodia)  This training session took place at the Apsara Authorities, where we introduced how to build a model with agent-based approach, using GAMA. In a new and very fast-growing city such as Siem Reap, some measures have to be taken to anticipate the future of the city, and modeling is a science that can give some solutions to face those problems. The training session was divided into 2 parts: A theoretical part (3 days) dealing with the following subjects : Urban issues and introduction to Agent-Based ModelingPresentation of the modeling methodologyIntroduction to GAMA with a model on urban segregationGIS datas and graphs to model urban mobilityGIS, Raster datas and graphs to model urban growthUse of experiments to calibrate and explore models A practical part (2 days) to build a model about urban mobility in Siem Reap (by groups of 4/5 people) \t Trainers: Drogoul Alexis, Gaudou Benoit, Trung Quang, Philippon Damien, Mazars Julien. "},{"title":"Epidemiological risks and the integration of regional health policies (JTD 2015)​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#epidemiological-risks-and-the-integration-of-regional-health-policies-jtd-2015","content":"19-24 July 2015 The JTD (Journées de Tam Dao) is an annual gathering of french-talkers researchers during the summer for one week, dealing with a specific subject related to sustainable development. For this 9th JTD, the topic was about epidemiological risks and the integration of regional health policies with the application of modeling by GAMA platform to decision support. Trainers: Alexis Drogoul, Vo Duc An, Benoit Gaudou, Damien Philippon, Chi-Quang Truong "},{"title":"MAPS 8 2015​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#maps-8-2015","content":"8-25 June 2015 "},{"title":"Nex Days 2015 (GAMA 1.6.1)​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#nex-days-2015-gama-161","content":"May 2015 "},{"title":"MISS ABMS 2014​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#miss-abms-2014","content":"September 2014 "},{"title":"MAPS epidemic city tutorial 2014​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#maps-epidemic-city-tutorial-2014","content":"July 2014 "},{"title":"GAMA training session Phillippines​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#gama-training-session-phillippines","content":"12-16 Jan 2015 - Quezon, Phillippines "},{"title":"A Glance at Sustainable Urban Development (JTD)​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#a-glance-at-sustainable-urban-development-jtd","content":"July 2014 - Da lat (Vietnam) The JTD (Journées de Tam Dao) is an annual gathering of french-talkers researchers during the summer for one week, dealing with a specific subject related to sustainable development. For this 8th JTD, the topic was about sustainable urban development, and a workshop has been made especially about how to use tools as GAMA to build models in order to explore and understand urban spatial dynamics. Trainers: Drogoul Alexis, Banos Arnaud, Huynh Quang Nghi, Truong Chi Quang, Vo Duc An. Here is the link to download the pdf report of the JTD 2014: https://drive.google.com/file/d/0B2Go6pohIhQcbERhczZRd253UUU/view. "},{"title":"AUF 2013​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#auf-2013","content":"November 2013 "},{"title":"MISS ABM 2013​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#miss-abm-2013","content":"October 2013 "},{"title":"The perception and Management of Risk (JTD)​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#the-perception-and-management-of-risk-jtd","content":"July 2013 - Da lat (Vietnam) The JTD (Journées de Tam Dao) is an annual gathering of french-talkers researchers during the summer for one week, dealing with a specific subject related to sustainable development. For this 7th JTD, the topic was about the perception and management of risks, and a workshop has been made especially about how to use tools as GAMA to build models in order to understand past crises to better understand the present. Trainers: Alexis Drogoul, Benoit Gaudou, Nasser Gasmi, Arnaud Grignard, Patrick Taillandier, Olivier Tessier, Vo Duc An Here is the link to download the pdf report of the JTD 2013: https://drive.google.com/file/d/0B2Go6pohIhQcNXFwVllHd2pFdlk/view. "},{"title":"Can Tho training session 2012​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#can-tho-training-session-2012","content":"November 2012 - Can Tho, Vietnam "},{"title":"ESSA Tutorial 2012​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#essa-tutorial-2012","content":""},{"title":"Water and its many Issues (JTD)​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#water-and-its-many-issues-jtd","content":"July 2012 - Vietnam The JTD (Journées de Tam Dao) is an annual gathering of french-talkers researchers during the summer for one week, dealing with a specific subject related to sustainable development. For this 6th JTD, the topic was about the perception and management of risks, and a workshop has been made especially about how to use tools as GAMA to build models with an agent-based approach. Trainers : Alexis Drogoul, Benoit Gaudou, Arnaud Grignard, Patrick Taillandier, Vo Duc An Here is the link to download the pdf report of the JTD 2012: https://docs.google.com/file/d/0B2Go6pohIhQcUWRKU2hPelNqQmc/view. "},{"title":"Introduction of GAMA 1.4​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#introduction-of-gama-14","content":"5 December 2011 - Bondy, France This training session was held at PDI Doctoral School, Bondy. The main topic of this session is the introduction of GAMA 1.4 with its advances: Deep refactoring work of the source codeNew programming language GAML (not based on XML)Integration of a true IDE based on EclipseDeep refactoring of the meta-modelBetter integration of multi-levelsNew important notion: topologyNew variable types: geometry, graph, path, topologyMany more novelties/improvements/enrichments... Trainers: Alexis Drogoul, Patrick Taillandier, Benoit Gaudou, Vo Duc An, Jean-Daniel Zucker, Edouard Amouroux "},{"title":"Formation à IRD Bondy​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#formation-à-ird-bondy","content":"Octorber 2010 - Bondy (France) This training session was held at IRD Bondy. The topic of this session was about the future of GAMA and a glance at agent-based models were built based on the GAMA platform. Trainers: Alexis Drogould, Patrick Taillandier, Edouard Amouroux "},{"title":"Introduction to the GAMA and PAMS platforms (IFI 2009)​","type":1,"pageTitle":"Training Session","url":"wiki/TrainingSession#introduction-to-the-gama-and-pams-platforms-ifi-2009","content":"26-28 October 2009 - Hanoi (Vietnam) This training session was held at IFI Hanoi. The topic of this session was about the introduction of GAMA and PAMS platforms, and how to use tools such as GAMA to build models with an agent-based approach. Trainers: Alexis Drogoul, Vo Duc An, Patrick Taillandier, Benoit Gaudou, Chu Thanh Quang, Jean-Daniel Zucker, François Sempé, Guillaume Chérel, Nicolas Marilleau "},{"title":"Troubleshooting","type":0,"sectionRef":"#","url":"wiki/Troubleshooting","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Troubleshooting","url":"wiki/Troubleshooting#table-of-contents","content":"Troubleshooting Table of contentsOn Ubuntu (&amp; Linux Systems) Workaround if OpenGL display crash GAMA On macOS First launch of GAMA should be in GUI mode On Windows Problem with some Radeon graphics cards and Opengl displayProblem with High-DPI devices and Java2D display Memory problemsSubmitting an Issue "},{"title":"On Ubuntu (& Linux Systems)​","type":1,"pageTitle":"Troubleshooting","url":"wiki/Troubleshooting#on-ubuntu--linux-systems","content":""},{"title":"Workaround if OpenGL display crash GAMA​","type":1,"pageTitle":"Troubleshooting","url":"wiki/Troubleshooting#workaround-if-opengl-display-crash-gama","content":"In case GAMA crashes whenever trying to display an OpenGL display or a Java2D, and you are running Ubuntu 21.10 (or earlier), it probably means that you're using Wayland as Display backend. You can fix it by running in a terminal export GDK_BACKEND=x11 and launch GAMA from this same terminal. This workaround is described here: https://bugs.eclipse.org/bugs/show_bug.cgi?id=577515 and in Issue 3373. "},{"title":"On macOS​","type":1,"pageTitle":"Troubleshooting","url":"wiki/Troubleshooting#on-macos","content":""},{"title":"First launch of GAMA should be in GUI mode​","type":1,"pageTitle":"Troubleshooting","url":"wiki/Troubleshooting#first-launch-of-gama-should-be-in-gui-mode","content":"When GAMA has just been downloaded and installed, it needs to be first launched in its GUI version before using it in the headless mode. If it is first launched in the headless mode, GAMA will be damaged and the installed version needs to be removed and re-installed. "},{"title":"On Windows​","type":1,"pageTitle":"Troubleshooting","url":"wiki/Troubleshooting#on-windows","content":""},{"title":"Problem with some Radeon graphics cards and Opengl display​","type":1,"pageTitle":"Troubleshooting","url":"wiki/Troubleshooting#problem-with-some-radeon-graphics-cards-and-opengl-display","content":"Some Radeon graphics cards may cause GAMA to crash when using Opengl displays. The best solutions in this case are either to switch to java2D display or, if the computer is equipped with two graphics cards, to specify to specify that the other graphics card should be used for GAMA (see here). "},{"title":"Problem with high-DPI devices and java2D display​","type":1,"pageTitle":"Troubleshooting","url":"wiki/Troubleshooting#problem-with-high-dpi-devices-and-java2d-display","content":"For high-DPI screens, it is possible to observe an offset in java2D displays (not centered, not taking the whole panel, with an erroneous mouse location) when a scaling value is not a value divisible by 100, for example a scaling of 250%. Changing the scaling factor for a value divisible by 100 (200%, 300%) solves the problem. "},{"title":"Memory problems​","type":1,"pageTitle":"Troubleshooting","url":"wiki/Troubleshooting#memory-problems","content":"The most common causes of problems when running GAMA are memory problems. Depending on your activities, on the size of the models you are editing, on the size of the experiments you are running, etc., you have a chance to require more memory than what is currently allocated to GAMA. A typical GAMA installation will need between 2 and 4GB of memory to run &quot;normally&quot; and launch small models. Memory problems are easy to detect: in the bottom-right corner of its window, GAMA will always display the status of the current memory. The first number represents the memory currently used (in MB), the second (always larger) the memory currently allocated by the JVM. And the little trash icon allows to &quot;garbage collect&quot; the memory still used by agents that are not used anymore (if any). If GAMA appears to hang or crash and if you can see that the two numbers are very close, it means that the memory required by GAMA exceeds the memory allocated.  There are two ways to circumvent this problem: the first one is to increase the memory allocated to GAMA by the Java Virtual Machine. The second, detailed on this page is to try to optimize your models to reduce their memory footprint at runtime. To increase the memory allocated, first locate the file called Gama.ini. On Windows and Ubuntu, it is located next to the executable. On Mac OS X, you have to right-click on Gama.app, choose &quot;Display Package Contents...&quot;, and you will find Gama.ini in Contents/Eclipse. This file typically looks like the following (some options/keywords may vary depending on the system), and we are interested in two JVM arguments:  -Xms supplies the minimal amount of memory the JVM should allocate to GAMA, -Xmx the maximal amount. By changing these values (esp. the second one, of course, for example to 4096M, or 4g, or more!), saving the file and relaunching GAMA, you can probably solve your problem. Note that 32 bits versions of GAMA will not accept to run with a value of -Xmx greater than 1500M. See here for additional information on these two options. "},{"title":"Submitting an Issue​","type":1,"pageTitle":"Troubleshooting","url":"wiki/Troubleshooting#submitting-an-issue","content":"If you think you have found a new bug/issue in GAMA, it is time to create an issue report here! Alternatively, you can click the Issues tab on the project site, search if a similar problem has already been reported (and, maybe, solved) and, if not, enter a new issue with as much information as possible: A complete description of the problem and how it occurred.The GAMA model or code you are having trouble with. If possible, attach a complete model.Screenshots or other files that help describe the issue. Two files may be particularly interesting to attach to your issue: the configuration details and the error log. Both can be obtained quite easily from within GAMA itself in a few steps. First, click the &quot;About GAMA...&quot; menu item (under the &quot;Gama Platform&quot; menu on Mac OS X, &quot;Help&quot; menu on Linux &amp; Windows)  In the dialog that appears, you will find a button called &quot;Installation Details&quot;.  Click this button and a new dialog appears with several tabs.  To provide complete information about the status of your system at the time of the error, you can (1) copy and paste the text found in the tab &quot;Configuration&quot; into your issue. Although, it is preferable to attach it as a text file (using TextEdit, Notepad or Emacs e.g.) as it may be too long for the comment section of the issue form. (2) click the &quot;View error log&quot; button, which will bring you to the location, in your file system, of a file called &quot;log&quot;, which you can then attach to your issue as well.  "},{"title":"Tutorials","type":0,"sectionRef":"#","url":"wiki/Tutorials","content":"","keywords":""},{"title":"Predator Prey tutorial​","type":1,"pageTitle":"Tutorials","url":"wiki/Tutorials#predator-prey-tutorial","content":" This tutorial introduces the basic concepts of GAMA and the use of grids. It is based on the classic predator prey model (see for instance a formal definition here). It is particularly adapted to beginners that want to quickly learn how to build a simple model in GAMA. "},{"title":"Road Traffic​","type":1,"pageTitle":"Tutorials","url":"wiki/Tutorials#road-traffic","content":" This tutorial introduces the use of GIS data. It is based on a mobility and daily activity model. It is particularly adapted to modelers that want to quickly learn how to integrate GIS data in their model and to use a road shapefile for the movement of their agents. "},{"title":"3D Tutorial​","type":1,"pageTitle":"Tutorials","url":"wiki/Tutorials#3d-tutorial","content":"This tutorial introduces the use of 3D in GAMA. In particular, it offers a quick overview of the 3D capabilities of the platform and how to integrate 3D features in models. "},{"title":"Luneray's flu tutorial​","type":1,"pageTitle":"Tutorials","url":"wiki/Tutorials#lunerays-flu-tutorial","content":" This tutorial dedicated to beginners introduces the basic concepts of GAMA and proposes a brief overview of many features. It concerns a model of disease spreading in the small city of Luneray. In particular, it presents how to integrate GIS data and use GIS, to use a road shapefile for the movement of agents, and to define a 3D display. "},{"title":"Incremental Model​","type":1,"pageTitle":"Tutorials","url":"wiki/Tutorials#incremental-model","content":" This tutorial proposes is an advance version of the Luneray's tutorial. It concerns a model of disease spreading in a small city. In particular, it presents how to integrate GIS data and use GIS, to use a road shapefile for the movement of agents, to define a 3D display, to define a multi-level model and use differential equations. "},{"title":"BDI Architecture​","type":1,"pageTitle":"Tutorials","url":"wiki/Tutorials#bdi-architecture","content":"This tutorial introduces the use of the BDI architecture (named BEN provided with the GAMA platform. It is particularly adapted for advanced users who want to integrate reasoning capabilities in theirs agents, taking into account their emotions and social relationships. "},{"title":"Units and constants","type":0,"sectionRef":"#","url":"wiki/UnitsAndConstants","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Units and constants","url":"wiki/UnitsAndConstants#introduction","content":"Units can be used to qualify the values of numeric variables. By default, unqualified values are considered as: meters for distances, lengths...seconds for durationscubic meters for volumeskilograms for masses  So, an expression like: float foo &lt;- 1;  will be considered as 1 meter if foo is a distance, or 1 second if it is a duration, or 1 meter/second if it is a speed. If one wants to specify the unit, it can be done very simply by adding the unit symbol (° or #) followed by an unit name after the numeric value, like: float foo &lt;- 1 °centimeter;  or float foo &lt;- 1 #centimeter;  In that case, the numeric value of foo will be automatically translated to 0.01 (meter). It is recommended to always use float as the type of the variables that might be qualified by units (otherwise, for example in the previous case, they might be truncated to 0). Several units names are allowed as qualifiers of numeric variables. These units represent the basic metric and US units. Composed and derived units (like velocity, acceleration, special volumes or surfaces) can be obtained by combining these units using the * and / operators. For instance: float one_kmh &lt;- 1 °km / °h const: true; float one_millisecond &lt;-1 °sec / 1000; float one_cubic_inch &lt;- 1 °sqin * 1 °inch; ... etc ...   "},{"title":"3D​","type":1,"pageTitle":"Units and constants","url":"wiki/UnitsAndConstants#3d","content":"#ambient, value= Ambient light, Comment: Represent the 'ambient' type of light#direction, value= Directional light, Comment: Represent the 'direction' type of light#from_above, value= From above, Comment: Represent the position of the camera, above the scene#from_front, value= From front, Comment: Represent the position of the camera, in front of the scene#from_left, value= From left, Comment: Represent the position of the camera, on the left of the scene#from_right, value= From right, Comment: Represent the position of the camera, on the right of the scene#from_up_front, value= From up front, Comment: Represent the position of the camera, in front and slightly above the scene#from_up_left, value= From up left, Comment: Represent the position of the camera, on the left, slightly above the scene#from_up_right, value= From up right, Comment: Represent the position of the camera on the right, slightly above the scene#isometric, value= Isometric, Comment: Represent the position of the camera, on the left of the scene#point, value= Point light, Comment: Represent the 'point' type of light#spot, value= Spot light, Comment: Represent the 'spot' type of light  "},{"title":"Constants​","type":1,"pageTitle":"Units and constants","url":"wiki/UnitsAndConstants#constants","content":"#AdamsBashforth, value= AdamsBashforth, Comment: AdamsBashforth solver#AdamsMoulton, value= AdamsMoulton, Comment: AdamsMoulton solver#AStar, value= AStar, Comment: AStar shortest path computation algorithm#BellmannFord, value= BellmannFord, Comment: BellmannFord shortest path computation algorithm#Bhandari, value= Bhandari, Comment: Bhandari K shortest paths computation algorithm#BidirectionalDijkstra, value= BidirectionalDijkstra, Comment: BidirectionalDijkstra shortest path computation algorithm#CHBidirectionalDijkstra, value= CHBidirectionalDijkstra, Comment: CHBidirectionalDijkstra shortest path computation algorithm#current_error, value= , Comment: The text of the last error thrown during the current execution#DeltaStepping, value= DeltaStepping, Comment: DeltaStepping shortest path computation algorithm#Dijkstra, value= Dijkstra, Comment: Dijkstra shortest path computation algorithm#DormandPrince54, value= DormandPrince54, Comment: DormandPrince54 solver#dp853, value= dp853, Comment: dp853 solver#e, value= 2.718281828459045, Comment: The e constant#Eppstein, value= Eppstein, Comment: Eppstein K shortest paths computation algorithm#Euler, value= Euler, Comment: Euler solver#FloydWarshall, value= FloydWarshall, Comment: FloydWarshall shortest path computation algorithm#Gill, value= Gill, Comment: Gill solver#GraggBulirschStoer, value= GraggBulirschStoer, Comment: GraggBulirschStoer solver#HighamHall54, value= HighamHall54, Comment: HighamHall54 solver#infinity, value= Infinity, Comment: A constant holding the positive infinity of type float (Java Double.POSITIVE_INFINITY)#Luther, value= Luther, Comment: Luther solver#max_float, value= 1.7976931348623157E308, Comment: A constant holding the largest positive finite value of type float (Java Double.MAX_VALUE)#max_int, value= 2147483647, Comment: A constant holding the maximum value an int can have (Java Integer.MAX_VALUE)#Midpoint, value= Midpoint, Comment: Midpoint solver#min_float, value= 4.9E-324, Comment: A constant holding the smallest positive nonzero value of type float (Java Double.MIN_VALUE)#min_int, value= -2147483648, Comment: A constant holding the minimum value an int can have (Java Integer.MIN_VALUE)#nan, value= NaN, Comment: A constant holding a Not-a-Number (NaN) value of type float (Java Double.POSITIVE_INFINITY)#NBAStar, value= NBAStar, Comment: NBAStar shortest path computation algorithm#NBAStarApprox, value= NBAStarApprox, Comment: NBAStarApprox shortest path computation algorithm#pi, value= 3.141592653589793, Comment: The PI constant#rk4, value= rk4, Comment: rk4 solver#Suurballe, value= Suurballe, Comment: Suurballe K shortest paths computation algorithm#ThreeEighthes, value= ThreeEighthes, Comment: ThreeEighthes solver#to_deg, value= 57.29577951308232, Comment: A constant holding the value to convert radians into degrees#to_rad, value= 0.017453292519943295, Comment: A constant holding the value to convert degrees into radians#TransitNodeRouting, value= TransitNodeRouting, Comment: TransitNodeRouting shortest path computation algorithm#Yen, value= Yen, Comment: Yen K shortest paths computation algorithm  "},{"title":"Graphics units​","type":1,"pageTitle":"Units and constants","url":"wiki/UnitsAndConstants#graphics-units","content":"#bold, value= 1, Comment: This constant allows to build a font with a bold face. Can be combined with #italic#bottom_center, value= No Default Value, Comment: Represents an anchor situated at the center of the bottom side of the text to draw#bottom_left, value= No Default Value, Comment: Represents an anchor situated at the bottom left corner of the text to draw#bottom_right, value= No Default Value, Comment: Represents an anchor situated at the bottom right corner of the text to draw#camera_location, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current position of the camera as a point#camera_orientation, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current orientation of the camera as a point#camera_target, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current target of the camera as a point#center, value= No Default Value, Comment: Represents an anchor situated at the center of the text to draw#display_height, value= 1.0, Comment: This constant is only accessible in a graphical context: display, graphics...#display_width, value= 1.0, Comment: This constant is only accessible in a graphical context: display, graphics...#flat, value= 2, Comment: This constant represents a flat line buffer end cap style#horizontal, value= 3, Comment: This constant represents a layout where all display views are aligned horizontally#italic, value= 2, Comment: This constant allows to build a font with an italic face. Can be combined with #bold#left_center, value= No Default Value, Comment: Represents an anchor situated at the center of the left side of the text to draw#none, value= 0, Comment: This constant represents the absence of a predefined layout#pixels (#px), value= 1.0, Comment: This unit, only available when running aspects or declaring displays, returns a dynamic value instead of a fixed one. px (or pixels), returns the value of one pixel on the current view in terms of model units.#plain, value= 0, Comment: This constant allows to build a font with a plain face#right_center, value= No Default Value, Comment: Represents an anchor situated at the center of the right side of the text to draw#round, value= 1, Comment: This constant represents a round line buffer end cap style#split, value= 2, Comment: This constant represents a layout where all display views are split in a grid-like structure#square, value= 3, Comment: This constant represents a square line buffer end cap style#stack, value= 1, Comment: This constant represents a layout where all display views are stacked#top_center, value= No Default Value, Comment: Represents an anchor situated at the center of the top side of the text to draw#top_left, value= No Default Value, Comment: Represents an anchor situated at the top left corner of the text to draw#top_right, value= No Default Value, Comment: Represents an anchor situated at the top right corner of the text to draw#user_location, value= No Default Value, Comment: This unit contains in permanence the location of the mouse on the display in which it is situated. The latest location is provided when it is out of a display#vertical, value= 4, Comment: This constant represents a layout where all display views are aligned vertically#zoom, value= 1.0, Comment: This unit, only available when running aspects or declaring displays, returns the current zoom level of the display as a positive float, where 1.0 represent the neutral zoom (100%)  "},{"title":"Length units​","type":1,"pageTitle":"Units and constants","url":"wiki/UnitsAndConstants#length-units","content":"#µm (#micrometer,#micrometers), value= 1.0E-6, Comment: micrometer unit#cm (#centimeter,#centimeters), value= 0.01, Comment: centimeter unit#dm (#decimeter,#decimeters), value= 0.1, Comment: decimeter unit#foot (#feet,#ft), value= 0.3048, Comment: foot unit#inch (#inches), value= 0.025400000000000002, Comment: inch unit#km (#kilometer,#kilometers), value= 1000.0, Comment: kilometer unit#m (#meter,#meters), value= 1.0, Comment: meter: the length basic unit#mile (#miles), value= 1609.344, Comment: mile unit#mm (#milimeter,#milimeters), value= 0.001, Comment: millimeter unit#nm (#nanometer,#nanometers), value= 9.999999999999999E-10, Comment: nanometer unit#yard (#yards), value= 0.9144, Comment: yard unit  "},{"title":"Surface units​","type":1,"pageTitle":"Units and constants","url":"wiki/UnitsAndConstants#surface-units","content":"#m2, value= 1.0, Comment: square meter: the basic unit for surfaces#sqft (#square_foot,#square_feet), value= 0.09290304, Comment: square foot unit#sqin (#square_inch,#square_inches), value= 6.451600000000001E-4, Comment: square inch unit#sqmi (#square_mile,#square_miles), value= 2589988.110336, Comment: square mile unit  "},{"title":"Time units​","type":1,"pageTitle":"Units and constants","url":"wiki/UnitsAndConstants#time-units","content":"#custom, value= CUSTOM, Comment: custom: a custom date/time pattern that can be defined in the preferences of GAMA and reused in models#cycle (#cycles), value= 1, Comment: cycle: the discrete measure of time in the simulation. Used to force a temporal expression to be expressed in terms of cycles rather than seconds#day (#days), value= 86400.0, Comment: day time unit: defines an exact duration of 24 hours#epoch, value= No Default Value, Comment: The epoch default starting date as defined by the ISO format (1970-01-01T00:00Z)#h (#hour,#hours), value= 3600.0, Comment: hour time unit: defines an exact duration of 60 minutes#iso_local, value= ISO_LOCAL_DATE_TIME, Comment: iso_local: the standard ISO 8601 output / parsing format for local dates (i.e. with no time-zone information)#iso_offset, value= ISO_OFFSET_DATE_TIME, Comment: iso_offset: the standard ISO 8601 output / parsing format for dates with a time offset#iso_zoned, value= ISO_ZONED_DATE_TIME, Comment: iso_zoned: the standard ISO 8601 output / parsing format for dates with a time zone#minute (#minutes,#mn), value= 60.0, Comment: minute time unit: defined an exact duration of 60 seconds#month (#months), value= 2592000.0, Comment: month time unit: defines an exact duration of 30 days. WARNING: this duration is of course not correct in terms of calendar#msec (#millisecond,#milliseconds,#ms), value= 0.001, Comment: millisecond time unit: defines an exact duration of 0.001 second#now, value= 1.0, Comment: This value represents the current date#sec (#second,#seconds,#s), value= 1.0, Comment: second: the time basic unit, with a fixed value of 1. All other durations are expressed with respect to it#week (#weeks), value= 604800.0, Comment: week time unit: defines an exact duration of 7 days#year (#years,#y), value= 3.1536E7, Comment: year time unit: defines an exact duration of 365 days. WARNING: this duration is of course not correct in terms of calendar  "},{"title":"Volume units​","type":1,"pageTitle":"Units and constants","url":"wiki/UnitsAndConstants#volume-units","content":"#cl (#centiliter,#centiliters), value= 1.0E-5, Comment: centiliter unit#dl (#deciliter,#deciliters), value= 1.0E-4, Comment: deciliter unit#hl (#hectoliter,#hectoliters), value= 0.1, Comment: hectoliter unit#l (#liter,#liters,#dm3), value= 0.001, Comment: liter unit#m3, value= 1.0, Comment: cube meter: the basic unit for volumes  "},{"title":"Weight units​","type":1,"pageTitle":"Units and constants","url":"wiki/UnitsAndConstants#weight-units","content":"#gram (#grams), value= 0.001, Comment: gram unit#kg (#kilo,#kilogram,#kilos), value= 1.0, Comment: second: the basic unit for weights#longton (#lton), value= 1016.0469088000001, Comment: short ton unit#ounce (#oz,#ounces), value= 0.028349523125, Comment: ounce unit#pound (#lb,#pounds,#lbm), value= 0.45359237, Comment: pound unit#shortton (#ston), value= 907.18474, Comment: short ton unit#stone (#st), value= 6.35029318, Comment: stone unit#ton (#tons), value= 1000.0, Comment: ton unit  "},{"title":"Colors​","type":1,"pageTitle":"Units and constants","url":"wiki/UnitsAndConstants#colors","content":"In addition to the previous units, GAML provides a direct access to the 147 named colors defined in CSS (see http://www.cssportal.com/css3-color-names/). E.g, rgb my_color &lt;- °teal;  #aliceblue, value= r=240, g=248, b=255, alpha=1#antiquewhite, value= r=250, g=235, b=215, alpha=1#aqua, value= r=0, g=255, b=255, alpha=1#aquamarine, value= r=127, g=255, b=212, alpha=1#azure, value= r=240, g=255, b=255, alpha=1#beige, value= r=245, g=245, b=220, alpha=1#bisque, value= r=255, g=228, b=196, alpha=1#black, value= r=0, g=0, b=0, alpha=1#blanchedalmond, value= r=255, g=235, b=205, alpha=1#blue, value= r=0, g=0, b=255, alpha=1#blueviolet, value= r=138, g=43, b=226, alpha=1#brown, value= r=165, g=42, b=42, alpha=1#burlywood, value= r=222, g=184, b=135, alpha=1#cadetblue, value= r=95, g=158, b=160, alpha=1#chartreuse, value= r=127, g=255, b=0, alpha=1#chocolate, value= r=210, g=105, b=30, alpha=1#coral, value= r=255, g=127, b=80, alpha=1#cornflowerblue, value= r=100, g=149, b=237, alpha=1#cornsilk, value= r=255, g=248, b=220, alpha=1#crimson, value= r=220, g=20, b=60, alpha=1#cyan, value= r=0, g=255, b=255, alpha=1#darkblue, value= r=0, g=0, b=139, alpha=1#darkcyan, value= r=0, g=139, b=139, alpha=1#darkgoldenrod, value= r=184, g=134, b=11, alpha=1#darkgray, value= r=169, g=169, b=169, alpha=1#darkgreen, value= r=0, g=100, b=0, alpha=1#darkgrey, value= r=169, g=169, b=169, alpha=1#darkkhaki, value= r=189, g=183, b=107, alpha=1#darkmagenta, value= r=139, g=0, b=139, alpha=1#darkolivegreen, value= r=85, g=107, b=47, alpha=1#darkorange, value= r=255, g=140, b=0, alpha=1#darkorchid, value= r=153, g=50, b=204, alpha=1#darkred, value= r=139, g=0, b=0, alpha=1#darksalmon, value= r=233, g=150, b=122, alpha=1#darkseagreen, value= r=143, g=188, b=143, alpha=1#darkslateblue, value= r=72, g=61, b=139, alpha=1#darkslategray, value= r=47, g=79, b=79, alpha=1#darkslategrey, value= r=47, g=79, b=79, alpha=1#darkturquoise, value= r=0, g=206, b=209, alpha=1#darkviolet, value= r=148, g=0, b=211, alpha=1#deeppink, value= r=255, g=20, b=147, alpha=1#deepskyblue, value= r=0, g=191, b=255, alpha=1#dimgray, value= r=105, g=105, b=105, alpha=1#dimgrey, value= r=105, g=105, b=105, alpha=1#dodgerblue, value= r=30, g=144, b=255, alpha=1#firebrick, value= r=178, g=34, b=34, alpha=1#floralwhite, value= r=255, g=250, b=240, alpha=1#forestgreen, value= r=34, g=139, b=34, alpha=1#fuchsia, value= r=255, g=0, b=255, alpha=1#gainsboro, value= r=220, g=220, b=220, alpha=1#ghostwhite, value= r=248, g=248, b=255, alpha=1#gold, value= r=255, g=215, b=0, alpha=1#goldenrod, value= r=218, g=165, b=32, alpha=1#gray, value= r=128, g=128, b=128, alpha=1#green, value= r=0, g=128, b=0, alpha=1#greenyellow, value= r=173, g=255, b=47, alpha=1#grey, value= r=128, g=128, b=128, alpha=1#honeydew, value= r=240, g=255, b=240, alpha=1#hotpink, value= r=255, g=105, b=180, alpha=1#indianred, value= r=205, g=92, b=92, alpha=1#indigo, value= r=75, g=0, b=130, alpha=1#ivory, value= r=255, g=255, b=240, alpha=1#khaki, value= r=240, g=230, b=140, alpha=1#lavender, value= r=230, g=230, b=250, alpha=1#lavenderblush, value= r=255, g=240, b=245, alpha=1#lawngreen, value= r=124, g=252, b=0, alpha=1#lemonchiffon, value= r=255, g=250, b=205, alpha=1#lightblue, value= r=173, g=216, b=230, alpha=1#lightcoral, value= r=240, g=128, b=128, alpha=1#lightcyan, value= r=224, g=255, b=255, alpha=1#lightgoldenrodyellow, value= r=250, g=250, b=210, alpha=1#lightgray, value= r=211, g=211, b=211, alpha=1#lightgreen, value= r=144, g=238, b=144, alpha=1#lightgrey, value= r=211, g=211, b=211, alpha=1#lightpink, value= r=255, g=182, b=193, alpha=1#lightsalmon, value= r=255, g=160, b=122, alpha=1#lightseagreen, value= r=32, g=178, b=170, alpha=1#lightskyblue, value= r=135, g=206, b=250, alpha=1#lightslategray, value= r=119, g=136, b=153, alpha=1#lightslategrey, value= r=119, g=136, b=153, alpha=1#lightsteelblue, value= r=176, g=196, b=222, alpha=1#lightyellow, value= r=255, g=255, b=224, alpha=1#lime, value= r=0, g=255, b=0, alpha=1#limegreen, value= r=50, g=205, b=50, alpha=1#linen, value= r=250, g=240, b=230, alpha=1#magenta, value= r=255, g=0, b=255, alpha=1#maroon, value= r=128, g=0, b=0, alpha=1#mediumaquamarine, value= r=102, g=205, b=170, alpha=1#mediumblue, value= r=0, g=0, b=205, alpha=1#mediumorchid, value= r=186, g=85, b=211, alpha=1#mediumpurple, value= r=147, g=112, b=219, alpha=1#mediumseagreen, value= r=60, g=179, b=113, alpha=1#mediumslateblue, value= r=123, g=104, b=238, alpha=1#mediumspringgreen, value= r=0, g=250, b=154, alpha=1#mediumturquoise, value= r=72, g=209, b=204, alpha=1#mediumvioletred, value= r=199, g=21, b=133, alpha=1#midnightblue, value= r=25, g=25, b=112, alpha=1#mintcream, value= r=245, g=255, b=250, alpha=1#mistyrose, value= r=255, g=228, b=225, alpha=1#moccasin, value= r=255, g=228, b=181, alpha=1#navajowhite, value= r=255, g=222, b=173, alpha=1#navy, value= r=0, g=0, b=128, alpha=1#oldlace, value= r=253, g=245, b=230, alpha=1#olive, value= r=128, g=128, b=0, alpha=1#olivedrab, value= r=107, g=142, b=35, alpha=1#orange, value= r=255, g=165, b=0, alpha=1#orangered, value= r=255, g=69, b=0, alpha=1#orchid, value= r=218, g=112, b=214, alpha=1#palegoldenrod, value= r=238, g=232, b=170, alpha=1#palegreen, value= r=152, g=251, b=152, alpha=1#paleturquoise, value= r=175, g=238, b=238, alpha=1#palevioletred, value= r=219, g=112, b=147, alpha=1#papayawhip, value= r=255, g=239, b=213, alpha=1#peachpuff, value= r=255, g=218, b=185, alpha=1#peru, value= r=205, g=133, b=63, alpha=1#pink, value= r=255, g=192, b=203, alpha=1#plum, value= r=221, g=160, b=221, alpha=1#powderblue, value= r=176, g=224, b=230, alpha=1#purple, value= r=128, g=0, b=128, alpha=1#red, value= r=255, g=0, b=0, alpha=1#rosybrown, value= r=188, g=143, b=143, alpha=1#royalblue, value= r=65, g=105, b=225, alpha=1#saddlebrown, value= r=139, g=69, b=19, alpha=1#salmon, value= r=250, g=128, b=114, alpha=1#sandybrown, value= r=244, g=164, b=96, alpha=1#seagreen, value= r=46, g=139, b=87, alpha=1#seashell, value= r=255, g=245, b=238, alpha=1#sienna, value= r=160, g=82, b=45, alpha=1#silver, value= r=192, g=192, b=192, alpha=1#skyblue, value= r=135, g=206, b=235, alpha=1#slateblue, value= r=106, g=90, b=205, alpha=1#slategray, value= r=112, g=128, b=144, alpha=1#slategrey, value= r=112, g=128, b=144, alpha=1#snow, value= r=255, g=250, b=250, alpha=1#springgreen, value= r=0, g=255, b=127, alpha=1#steelblue, value= r=70, g=130, b=180, alpha=1#tan, value= r=210, g=180, b=140, alpha=1#teal, value= r=0, g=128, b=128, alpha=1#thistle, value= r=216, g=191, b=216, alpha=1#tomato, value= r=255, g=99, b=71, alpha=1#transparent, value= r=0, g=0, b=0, alpha=0#turquoise, value= r=64, g=224, b=208, alpha=1#violet, value= r=238, g=130, b=238, alpha=1#wheat, value= r=245, g=222, b=179, alpha=1#white, value= r=255, g=255, b=255, alpha=1#whitesmoke, value= r=245, g=245, b=245, alpha=1#yellow, value= r=255, g=255, b=0, alpha=1#yellowgreen, value= r=154, g=205, b=50, alpha=1 "},{"title":"Updating GAMA","type":0,"sectionRef":"#","url":"wiki/Updating","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Updating GAMA","url":"wiki/Updating#table-of-contents","content":"Updating GAMA Manual UpdateAutomatic Update "},{"title":"Manual Update​","type":1,"pageTitle":"Updating GAMA","url":"wiki/Updating#manual-update","content":"To activate this feature, you have to invoke the &quot;Check for Updates&quot; or &quot;Install New Software...&quot; menu commands in the &quot;Help&quot; menu. The first one will only check if the existing plugins have any updates available, while the second will, in addition, scan the update site to detect any new plugins that might be added to the current installation.  In general, it is preferable to use the second command, as more options (including that of desinstalling some plugins) are provided. Once invoked, it makes the following dialog appear:  GAMA expects the user to enter a so-called update site. You can copy and paste the following line (or choose it from the drop-down menu as this address is built inside GAMA): http://updates.gama-platform.org  GAMA will then scan the entire update site, looking both for new plugins of the GAMA kernel and updates to existing plugins. The list available in your installation will, of course, be different from the one displayed here. In order to make the plugins appear, you need to uncheck the option &quot;Group items by category&quot;. Choose the ones you want to update (or install) and click &quot;Next &gt;&quot;.  A summary page will appear, indicating which plugins will actually be installed (since some plugins might require additional plugins to run properly). Click on the &quot;Next &gt;&quot; button.  A license page will then appear: you have to accept all of them. Click on &quot;Finish&quot;.  GAMA will then proceed to the installation (that can be canceled at any time) of the chosen plugins. During the course of the installation, you might receive the following warning, that you can dismiss by clicking &quot;OK&quot;. You can click on the &quot;Details&quot; button to see which plugins contain unsigned contents.  Once the plugins are installed, GAMA will ask you whether you want to restart or not. It is always safer to do so, so select &quot;Restart now&quot; and let it close by itself, register the new plugins and restart.  "},{"title":"Automatic Update​","type":1,"pageTitle":"Updating GAMA","url":"wiki/Updating#automatic-update","content":"GAMA offers a mechanism to monitor the availability of updates to the plugins already installed. To activate this feature, open the preferences of GAMA and choose the button &quot;Advanced...&quot;, which gives access to additional preferences.  In the dialog that appears, navigate to &quot;Install/Update &gt; Automatic Updates&quot;. Then, enable the option using the check-box in the top of the dialog and choose the best settings for your workflow. Clicking on &quot;Apply and close&quot; will save these preferences and dismiss the dialog.  From now on, GAMA will continuously support you in having an up-to-date version of the platform, provided you accept the updates. "},{"title":"Using Git from GAMA to version and share models","type":0,"sectionRef":"#","url":"wiki/Using_Git","content":"","keywords":""},{"title":"Install the Git client [Tested on the GAMA 1.8.2]​","type":1,"pageTitle":"Using Git from GAMA to version and share models","url":"wiki/Using_Git#install-the-git-client-tested-on-the-gama-182","content":"The Git client for GAMA needs to be installed as an external plugin. Help &gt; Install new plugins...Add the following address in the text field &quot;Work with&quot;: https://download.eclipse.org/egit/updates. (press Enter key)In the available plugins to install, choose Git integration for Eclipse &gt; Git integration for EclipseClick on the Next button and follow the instructions (GAMA will be relaunched). "},{"title":"Open the Git view​","type":1,"pageTitle":"Using Git from GAMA to version and share models","url":"wiki/Using_Git#open-the-git-view","content":"To use Git in GAMA select Views -&gt; Other... -&gt; Show View -&gt; Other... In the Show view window that appears select Git -&gt; Git Repositories and click on Open.  "},{"title":"Create a Local Repository​","type":1,"pageTitle":"Using Git from GAMA to version and share models","url":"wiki/Using_Git#create-a-local-repository","content":"With Git you can easily create local repositories to version your work locally. First, you have to create a GAMA project (e.g GitNewProject) that you want to share via your local repository. After you have created your GAMA project, go to the Git Repository view and click on Create a new local Git repository.  In the following window specify the directory for the new repository (select the folder of the created GAMA project - GitNewProject -), throught the button Browse...  then hit the Create button.  Now your local repository is created, you can add models and files into your GAMA project. As you selected the folder of the new created GAMA Project, the repository will not be empty. So, it will be initialized with all the folders and files of the GAMA project. Note the changed icons: the project node will have a repository icon, the child nodes will have an icon with a question mark.  Before you can commit the files to your repository, you need to add them. Simply right click the shared project's node and navigate to Team -&gt; Add to Index.  After this operation, the question mark should change to a plus symbol.  To set certain folders or files to be ignored by Git, right click them and select Team -&gt; Ignore. The ignored items will be stored in a file called .gitignore, which you should add to the repository. "},{"title":"Commit​","type":1,"pageTitle":"Using Git from GAMA to version and share models","url":"wiki/Using_Git#commit","content":"Now you can modify files in your project, save changes made in your workspace to your repository and commit them. You can do commit the project by right clicking the project node and selecting Team -&gt; Commit... from the context menu. In the Commit wizard, all files should be selected automatically. Enter a commit message and hit the Commit button.  If the commit was successful, the plus symbols will have turned into repository icons.  After changing files in your project, a &quot;&gt;&quot; sign will appear right after the icon, telling you the status of these files is dirty. Any parent folder of this file will be marked as dirty as well.  If you want to commit the changes to your repository, right click the project (or the files you want to commit) and select Team -&gt; Commit... . Enter a commit message and click Commit to commit the selected files to your repository. "},{"title":"Add Files​","type":1,"pageTitle":"Using Git from GAMA to version and share models","url":"wiki/Using_Git#add-files","content":"To add a new file to the repository, you need to create it in your shared GAMA project first. Then, the new file will appear with a question mark.  Right click it and navigate to Team -&gt; Add to Index. The question mark will turn into a plus symbol and the file will be tracked by Git, but it is not yet committed. In the next commit, the file will be added to the repository and the plus symbol will turn into a repository icon.  "},{"title":"Revert Changes​","type":1,"pageTitle":"Using Git from GAMA to version and share models","url":"wiki/Using_Git#revert-changes","content":"If you want to revert any changes, there are two options. You can compare each file you want to revert with the HEAD revision (or the index, or the previous version) and undo some or all changes done. Second, you can hard reset your project, causing any changes to be reverted. "},{"title":"Revert via Compare​","type":1,"pageTitle":"Using Git from GAMA to version and share models","url":"wiki/Using_Git#revert-via-compare","content":"Right click the file you want to revert and select Compare With -&gt; HEAD Revision. This will open a comparison with the HEAD Revision, highlighting any changes done. You can revert several lines. select the line you want to revert and hit the Copy Current Change from Right to Left button (in the toolbar).  "},{"title":"Revert via Reset​","type":1,"pageTitle":"Using Git from GAMA to version and share models","url":"wiki/Using_Git#revert-via-reset","content":"To reset all changes made to your project, right click the project node and navigate to Team -&gt; Reset... . Select the branch you want to reset to (if you haven't created any other branches, there will be just one). Click the reset button. All changes will be reset to this branch's last commit. Be careful with this option as all last changes in your Gama Project will be lost.  "},{"title":"Clone Repositories​","type":1,"pageTitle":"Using Git from GAMA to version and share models","url":"wiki/Using_Git#clone-repositories","content":"To checkout a remote project, you will have to clone its repository first. Open the GAMA Import wizard: right click the User models node -&gt; Import... -&gt; Other...  Select Git -&gt; Projects from Git and click Next.  Select &quot;Clone URI&quot; and click Next.  Now you will have to enter the repository's location. Entering the URI will automatically fill some fields. Complete any other required fields and hit Next (e.g, Authentification fields). If you use GitHub, you can copy the URI from the web page.  Select all branches you wish to clone and hit Next again.  Hit next, then choose a local storage location to save the repository in.  To import the projects, select the cloned repository and hit Next. Select Import Existing Projects and hit Next.  In the following window, select all projects you want to import and click Finish.  The projects should now appear in the Models Explorer. (Note the repository symbol in the icons indicating that the projects are already shared.)  "},{"title":"Create Branches​","type":1,"pageTitle":"Using Git from GAMA to version and share models","url":"wiki/Using_Git#create-branches","content":"To create a new branch in your repository, right click your project and navigate to Team -&gt; Switch to -&gt; New Branch... from the context menu. Select the branch you want to create a new branch from, hit New branch and enter a name for the new branch.  The new branch (NewBranch) should appear in the branch selection window.  You can see all the branches in the Git Repositories view.  If you would like to checkout the a branch, select it and click Checkout.  "},{"title":"Merge​","type":1,"pageTitle":"Using Git from GAMA to version and share models","url":"wiki/Using_Git#merge","content":"To merge one branch into another, right click the project node and navigate to Team -&gt; Merge...  The merge will execute and a window will pop-up with the results. The possible results are Already-up-to-date, Fast-forward, Merged, Conflicting, Failed.  Note that a conflicting result will leave the merge process incomplete. You will have to resolve the conflicts and try again. When there are conflicting changes in the working project, the merge will fail. "},{"title":"Fetch and Pull​","type":1,"pageTitle":"Using Git from GAMA to version and share models","url":"wiki/Using_Git#fetch-and-pull","content":"To update the remote branches when cloning remote repositories (Git creates copies of the branches as local branches and as remote branches) you will have to use Fetch. To perform a Fetch, select Team -&gt; Fetch From... from the project's context menu. To update your local branches, you will have to perform a Merge operation after fetching. "},{"title":"Pull​","type":1,"pageTitle":"Using Git from GAMA to version and share models","url":"wiki/Using_Git#pull","content":"Pull combines Fetch and Merge. Select Team -&gt; Pull. "},{"title":"Push​","type":1,"pageTitle":"Using Git from GAMA to version and share models","url":"wiki/Using_Git#push","content":"Local changes made to your local branches can be pushed to remote repositories causing a merge from your branches into the branches of the remote repository (X pulls from Y is the same as Y pushes to X). The Push wizard is pretty much the same as the Fetch wizard.  "},{"title":"History View​","type":1,"pageTitle":"Using Git from GAMA to version and share models","url":"wiki/Using_Git#history-view","content":"To show the repository history, right click it and select Team -&gt; Show in History. This will open the History View, giving an overview of the commits and allowing you to perform several actions (creating branches/tags, revert, reset...).  "},{"title":"Using BEN (simple_bdi)","type":0,"sectionRef":"#","url":"wiki/Using-BEN-simple-bdi","content":"","keywords":""},{"title":"Introduction to BEN​","type":1,"pageTitle":"Using BEN (simple_bdi)","url":"wiki/Using-BEN-simple-bdi#introduction-to-ben","content":"BEN (Behavior with Emotions and Norms) is an agent architecture providing social agents with cognition, emotions, emotional contagion, personality, social relations, and norms. This work has been done during the Ph.D. of Mathieu Bourgais, funded by the ANR ACTEUR. The BEN architecture is accessible in GAMA through the use of the simple_bdi architecture when defining agents. This page indicates the theoretical running of BEN as well as the practical way it has been implemented in GAMA. This page features all the descriptions for the running of the BEN architecture. This page is updated with the version of BEN implemented in GAMA. To get more details on its implementation in GAMA, see operators related to BDI, BDI tutorial or BDI built-in architecture reference. "},{"title":"The BEN architecture​","type":1,"pageTitle":"Using BEN (simple_bdi)","url":"wiki/Using-BEN-simple-bdi#the-ben-architecture","content":"The BEN Architecture used by agents to make a decision at each time step is represented by the image right below:  Each social agent has its own instance of the BEN architecture to make a decision. The architecture is composed of 4 main parts connected to the agent's knowledge bases, seated on the agent's personnality. Each part is made up of processes that are automatically computed (in blue) or which need to be manually defined by the modeler (in pink). Some of these processes are mandatory (in solid line) and some others are optional (in dotted line). This modularity enables each modeler to only use components that seem pertinent to the studied situation without creating heavy and useless computations. The Activity diagram bellow shows the order in which each module and each process is activated. The rest of this page explains in details how each process from each module works and what is the difference between the theoretical architecture and its implementation.  "},{"title":"Predicates, knowledge and personality​","type":1,"pageTitle":"Using BEN (simple_bdi)","url":"wiki/Using-BEN-simple-bdi#predicates-knowledge-and-personality","content":"In BEN, an agent represents its environment through the concept of predicates. A predicate represents information about the world. This means it may represent a situation, an event or an action, depending on the context. As the goal is to create behaviors for agents in a social environment, that is to say taking actions performed by other agents into account with facts from the environment in the decision making process, an information P caused by an agent j with an associated list of value V is represented by Pj(V). A predicate P represents an information caused by any or none agent, with no particular value associated. The opposite of a predicate P is defined as not P. In GAML, the simplebdi architecture adds a new type called _predicate which is made of a name (mandatory), a map of values (optional) an agent causing it (optional) and a truth value (optional, by default at true). To manipulate these predicates, there are operators like set_agent_cause, set_truth, with_values and add_values to modify the corresponding attribute of a given predicate (with_values changes all the map of values while add_values enables to add a new value without changing the rest of the map). These values can be accessed with operators get_agent_cause, get_truth, get_values. An operator not is also defined for predicates. Below is an example of how to define predicates in GAML: predicate a &lt;- new_predicate(&quot;test&quot;); predicate b &lt;- new_predicate(&quot;test&quot;,[&quot;value1&quot;::10]); predicate c &lt;- new_predicate(&quot;test&quot;,agentBob); predicate d &lt;- new_predicate(&quot;test&quot;,false); predicate e &lt;- new_predicate(&quot;test&quot;,agenBob,false);  "},{"title":"Cognitive mental states​","type":1,"pageTitle":"Using BEN (simple_bdi)","url":"wiki/Using-BEN-simple-bdi#cognitive-mental-states","content":"Through the architecture, an agent manipulates cognitive mental states to make a decision; they constitute the agent's mind. A cognitive mental state possessed by the agent $i$ is represented by Mi(PMEm,Val,Li) with the following meaning: M: the modality indicating the type of the cognitive mental state (e.g. a belief).PMEm: the object with which the cognitive mental state relates. It can be a predicate, another cognitive mental state, or an emotion.Val: a real value which meaning depends on the modality.Li: a lifetime value indicating the time before the cognitive mental state is forgotten. A cognitive mental state with no particular value and no particular lifetime is written Mi(PMEm). Val[Mi(PMEm)] represents the value attached to a particular cognitive mental state and Li[Mi(PMEm)] represents its lifetime. The cognitive part of BEN is based on the BDI paradigm (Bratman, 1987) in which agents have a belief base, a desire base and an intention base to store the cognitive mental states about the world. In order to connect cognition with other social features, the architecture outlines a total of 6 different modalities which are defined as follows: Belief: represents what the agent knows about the world. The value attached to this mental state indicates the strength of the belief.Uncertainty: represents an uncertain information about the world. The value attached to this mental state indicates the importance of the uncertainty.Desire: represents a state of the world the agent wants to achieve. The value attached to this mental state indicates the priority of the desire.Intention: represents a state of the world the agent is committed to achieve. The value attached to this mental state indicates the priority of the intention.Ideal: represents an information socially judged by the agent. The value attached to this mental state indicates the praiseworthiness value of the ideal about P. It can be positive (the ideal about P is praiseworthy) or negative (the ideal about P is blameworthy).Obligation: represents a state of the world the agent has to achieve. The value attached to this mental state indicates the priority of the obligation. In GAML, mental states are manipulated thanks to add, remove and get actions related to each modality: add_belief, remove_belief, get_belief, add_desire, remove_desire ... Then, operators enables to acces or modify each attribute of a given mental state: get_predicate, set_predicate, get_strength, set_strength, get_lifetime, set_lifetime, etc. Below is an exemple of code in GAML concerning cognitive mental states: reflex testCognition{ predicate a &lt;- new_predicate(&quot;test&quot;); do add_belief(a,strength1,lifetime1); mental_state b &lt;- get_uncertainty(a); int c &lt;- get_lifetime(b); }  "},{"title":"Emotions​","type":1,"pageTitle":"Using BEN (simple_bdi)","url":"wiki/Using-BEN-simple-bdi#emotions","content":"In BEN, the definition of emotions is based on the OCC theory of emotions (Ortony, 90). According to this theory, an emotion is a valued answer to the appraisal of a situation. Once again, as the agents are taken into consideration in the context of a society and should act depending on it, the definition of an emotion needs to contain the agent causing it. Thus, an emotion is represented by Emi(P,Ag,I,De) with the following elements : Emi: the name of the emotion felt by agent i.P: the predicate representing the fact about which the emotion is expressed.Ag: the agent causing the emotion.I: the intensity of the emotion.De: the decay withdrawal from the emotion's intensity at each time step. An emotion with any intensity and any decay is represented by Emi(P,Ag) and an emotion caused by any agent is written Emi(P). I[Emi(P,Ag)] stands for the intensity of a particular emotion and De[Emi(P,Ag)] stands for its decay value. In GAML, emotions are manipulated thanks to add_emotion, remove_emotion and get_emotion actions and attributes of an emotion are manipulated with set and get operators (set_intensity, set_about, set_decay, set_agent_cause, get_intensity, get_about, get_decay, get_agent_cause). Below is an exemple of code in GAML concerning emotions: reflex testEmotion{ predicate a &lt;- new_predicate(&quot;test&quot;); do add_emotion(new_emotion(&quot;hope&quot;,a)); do add_emotion(new_emotion(&quot;joy&quot;,intesity1,a, decay1)); float c &lt;- get_intensity(get_emotion(new_emotion(&quot;joy&quot;,a))); }  "},{"title":"Social relations​","type":1,"pageTitle":"Using BEN (simple_bdi)","url":"wiki/Using-BEN-simple-bdi#social-relations","content":"As people create social relations when living with other people and change their behavior based on these relationships, BEN architecture makes it possible to describe social relations in order to use them in agents' behavior. Based on the research carried out by (Svennevig, 2000), a social relation is described by using a finite set of variables. Svennevig identifies a minimal set of four variables: liking, dominance, solidarity, and familiarity. A trust variable is added to interact with the enforcement of social norms. Therefore, in BEN, a social relation between agent i and agent j is expressed as Ri,j(L,D,S,F,T) with the following elements: R: the identifier of the social relation.L: a real value between -1 and 1 representing the degree of liking with the agent concerned by the link. A value of -1 indicates that agent j is hated, a value of 1 indicates that agent j is liked.D: a real value between -1 and 1 representing the degree of power exerted on the agent concerned by the link. A value of -1 indicates that agent j is dominating, a value of 1 indicates that agent j is dominated.S: a real value between 0 and 1 representing the degree of solidarity with the agent concerned by the link. A value of 0 indicates that there is no solidarity with agent j, a value of 1 indicates a complete solidarity with agent j.F: a real value between 0 and 1 representing the degree of familiarity with the agent concerned by the link. A value of 0 indicates that there is no familiarity with agent j, a value of 1 indicates a complete familiarity with agent j.T: a real value between -1 and 1 representing the degree of trust with the agent j. A value of -1 indicates doubts about agent j while a value of 1 indicates complete trust with agent j. The trust value does not evolve automatically in accordance with emotions. With this definition, a social relation is not necessarily symmetric, which means Ri,j(L,D,S,F,T) is not equal by definition to Ri,j(L,D,S,F,T). L[Ri,j] stands for the liking value of the social relation between agent i and agent j, D[i,j] stands for its dominance value, S[Ri,j] for its solidarity value, F[Ri,j] represents its familiarity value and T[Ri,j] its trust value. In GAML, social relations are manipulated with add_social_link, remove_social_link and get_social_link actions. Each feature of a social link is accessible with set and gt operators (set_agent, get_agent, set_liking, get_liking, set_dominance, etc.) Below is an exemple of code to manipulates social relations in GAML: reflex testSocialRelations{ do add_social_link(new_social_link(agentAlice)); do add_social_link(new_social_link(agentBob,0.5,-0.3,0.2,0.1)); float val &lt;- get_liking(get_social_link(new_social_link(agentBob))); social_link sl &lt;- set_dominance(get_social_link(new_social_link(agentBob)),0.3); }  "},{"title":"Personality and additional variables​","type":1,"pageTitle":"Using BEN (simple_bdi)","url":"wiki/Using-BEN-simple-bdi#personality-and-additional-variables","content":"In order to define personality traits, BEN relies on the OCEAN model (McCrae, 1992), also known as the big five factors model. In the BEN architecture, this model is represented through a vector of five values between 0 and 1, with 0.5 as the neutral value. The five personality traits are: O: represents the openness of someone. A value of 0 stands for someone narrow-minded, a value of 1 stands for someone open-minded.C: represents the consciousness of someone. A value of 0 stands for someone impulsive, a value of 1 stands for someone who acts with preparations.E: represents the extroversion of someone. A value of 0 stands for someone shy, a value of 1 stands for someone extrovert.A: represents the agreeableness of someone. A value of 0 stands for someone hostile, a value of 1 stands for someone friendly.N: represents the degree of control someone has on his/her emotions, called neurotism. A value of 0 stands for someones neurotic, a value of 1 stands for someone calm. In GAML, these variables are build-in attributes of agents using the simplebdi control architecture. They are called _openness, conscientiousness, extroversion, agreeableness and neurotism. To use this personality to automaticaly parametrize the other modules, a modeler needs to indicate it as shown in the GAML example below: species miner control:simple_bdi { ... bool use_personality &lt;- true; float openness &lt;- 0.1; float conscientiousness &lt;- 0.2; float extroversion &lt;- 0.3; float agreeableness &lt;- 0.4; float neurotism &lt;- 0.5; ... }  With BEN, the agent has variables related to some of the social features. The idea behind the BEN architecture is to connect these variables to the personality module and in particular to the five dimensions of the OCEAN model in order to reduce the number of parameters which need to be entered by the user. These additional variables are: The probability to keep the current plan.The probability to keep the current intention.A charisma value linked to the emotional contagion process.An emotional receptivity value linked to the emotional contagion.An obedience value used by the normative engine. With the cognition, the agent has two parameters representing the probability to randomly remove the current plan or the current intention in order to check whether there could be a better plan or a better intention in the current context. These two values are connected to the consciousness components of the OCEAN model as it describes the tendency of the agent to prepare its actions (with a high value) or act impulsively (with a low value). Probability Keeping Plans = C1/2Probability Keeping Intentions = C1/2 For the emotional contagion, the process (presented later) requires charisma (Ch) and emotional receptivity (R) to be defined for each agent. In BEN, charisma is related to the capacity of expression, which is related to the extroversion of the OCEAN model, while the emotional receptivity is related to the capacity to control the emotions, which is expressed with the neurotism value of OCEAN. Ch = E R = 1 - N With the concept of norms, the agent has a value of obedience between 0 and 1, which indicates its tendency to follow laws, obligations, and norms. According to research in psychology, which tried to explain the behavior of people participating in a recreation of the Milgram's experiment (Begue, 2015), obedience is linked with the notions of consciousness and agreeableness which gives the following equation: obedience = ((C+A)/2)1/2 With the same idea, all the parameters required by each process are linked to the OCEAN model. If a modeler wants to put a different value to one of these variables, he/she just need to indicate a new value manualy. For the probability to keep the current plan and the probability to keep the current intention, he/she also has to indicates it with a particular boolean value, as shown in the GAML example below: species miner control: simple_bdi { ... bool use_personality &lt;- true; bool use_persistence &lt;- true; float plan_persistence &lt;- 0.3; float intention_persistence &lt;- 0.4; float obedience &lt;- 0.2; float charisma &lt;- 0.3; float receptivity &lt;- 0.6; ... }  "},{"title":"Perception​","type":1,"pageTitle":"Using BEN (simple_bdi)","url":"wiki/Using-BEN-simple-bdi#perception","content":"The first step of BEN is the perception of the environment. This module is used to connect the environment to the knowledge of the agent, transforming information from the world into cognitive mental states, emotions or social links but also used to apply sanctions during the enforcement of norms from other agents. Below is an example of code to define a perception in GAML: perceive target: fireArea in: 10{ ... }  The first process in this perception consists of adding beliefs about the world. During this phase, information from the environment is transformed into predicates which are included in beliefs or uncertainties and then added to the agent's knowledge bases. This process enables the agent to update its knowledge about the world. From the modeler's point of view, it is only necessary to specify which information is transformed into which predicate. The addition of a belief BeliefA(X) triggers multiple processes : it removes BeliefA(not X).it removes IntentionA(X).it removes DesireA(X) if IntentionA(X) has just been removed.it removes UncertaintyA(X) or UncertaintyA(not X).it removes ObligationA(X). \\end{itemize} In GAML, the focus statement eases the use of this process. Below is an example that adds a belief and an uncertainty with the focus statement during a perception: perceive target: fireArea in: 10{ focus id:&quot;fireLocation&quot; var:location strength:10.0; //is equivalent to ask myself {do add_belief(new_predicate(&quot;fireLocation&quot;,[&quot;location_value&quot;::myself.location],10.0);} focus id:&quot;hazardLocation&quot; var:location strength:1.0 is_uncertain:true; //is equivalent to ask myself {do add_uncertainty(new_predicate(&quot;hazardLocation&quot;,[&quot;location_value&quot;::myself.location],1.0);} }  The emotional contagion enables the agent to update its emotions according to the emotions of other agents perceived. The modeler has to indicate the emotion triggering the contagion, the emotion created in the perceiving agent and the threshold of this contagion; the charisma (Ch) and receptivity (R) values are automatically computed as explained previously. The contagion from agent i to agent j occurs only if Chi x Rj is superior or equal to the threshold, which value is 0.25 by default. Then, the presence of the trigger emotion in the perceived agent is checked in order to create the emotion indicated. The intensity and decay value of the emotion acquired by contagion are automatically computed. If Emj(P) already exists: I[Emj(P)] = I[Emj(P)] + I[Emi(P)] x Chi x Rj if pEmi(P)] &gt; I[Emj(P)]: De[Emj(P)] = De[Emi(P)] if I[Emj(P)] &gt; I[Emi(P)]: De[Emj(P)] = De[Emj(P)] If Emj(P) does not already exist: I[Emj(P)] = I[Emi(P)] x Chi x Rj De[Emj(P)] = De[Emi(P)]. In GAML, emotional_contagion statement helps to define an emotional contagion during a perception, as shown below: perceive target: otherHumanAgents in: 10{ emotional_contagion emotion_detected:fearFire threshold:contagionThreshold; //creates the detected emotion, if detected, in the agent doing the perception. emotional_contagion emotion_detected:joyDance emotion_created:joyPartying; //creates the emotion &quot;joyPartying&quot;, if emotion &quot;joyDance&quot; is detected in the perceived agent. }  During the perception, the agent has the possibility of creating social relations with other perceived agents. The modeler indicates the initial value for each component of the social link, as explained previously. By default, a neutral relation is created, with each value of the link at 0.0. Social relations can also be defined before the start of the simulation, to indicate that an agent has links with other agents at the start of the simulation, like links with friends or family members. In GAML, the socialize statement help creating dynamicaly new social relations, as shown below: perceive target:otherHumanAgents in: 10{ socialize; //creates a neutral relation socialize dominance: -0.8 familiarity:0.2 when: isBoss; //example of a social link with precise values for some of its dimensions in a certain context }  Finally, the agent may apply sanctions through the norm enforcement of other agents perceived. The modeler needs to indicate which modality is enforced and the sanction and reward used in the process. Then, the agent checks if the norm, the obligation, or the law, is violated, applied or not activated by the perceived agent. Notions of norms laws and obligations and how they work are explained later in this ocument. A norm is considered violated when its context is verified, and yet the agent chose another norm or another plan to execute because it decided to disobey. A law is considered violated when its context is verified, but the agent disobeyed it, not creating the corresponding obligation. Finally, an obligation is considered violated if the agent did not execute the corresponding norm because it chose to disobey. Below is an example of how to define an enforcement in GAML: species miner skills: [moving] control:simple_bdi { ... perceive target: miner in: viewdist { myself.agent_perceived&lt;-self; enforcement norm:&quot;share_information&quot; sanction:&quot;sanctionToNorm&quot; reward:&quot;rewardToNorm&quot;; } sanction sanctionToNorm{ do change_liking(agent_perceived,-0.1); } sanction rewardToNorm{ do change_liking(agent_perceived,0.1); } }  "},{"title":"Managing knowledge bases​","type":1,"pageTitle":"Using BEN (simple_bdi)","url":"wiki/Using-BEN-simple-bdi#managing-knowledge-bases","content":"The second step of the architecture, corresponding to the module number 2, consists of managing the agent's knowledge. This means updating the knowledge bases according to the latest perceptions, adding new desires, new obligations, new emotions or updating social relations, for example. Modelers have to use inference rules for this purpose. Theses rules are triggered by a new belief, a new uncertainty or a new emotion, in a certain context, and may add or remove any cognitive mental state or emotion indicated by the user. Using multiple inference rules helps the agent to adapt its mind to the situation perceived without removing all its older cognitive mental states or emotions, thus enabling the creation of a cognitive behavior. These inference rules enable to link manually the various dimensions of an agent, for example creating desires depending on emotions, social relations and personality. In GAML, the rule statement enables to define inference rules: species miner skills: [moving] control: simple_bdi { ... perceive target: miner in: viewdist { ... } ... rule belief: new_predicate(&quot;testA&quot;) new_desire: new_predicate(&quot;testB&quot;); }  Using the same idea, modelers can define laws. These laws enable the creation of obligations in a given context based on the newest beliefs created by the agent through its perception or its inference rules. The modeler also needs to indicate an obedience threshold and if the agent's obedience value is below that threshold, the law is violated. If the law is activated, the obligation is added to the agent's cognitive mental state bases. The definition of laws makes it possible to create a behavior based on obligations imposed upon the agent. Below is an example of the definition of a law statement in GAML: law belief: new_predicate(&quot;testA&quot;) new_obligation:new_predicate(&quot;testB&quot;) threshold:thresholdLaw;  "},{"title":"Emotional engine​","type":1,"pageTitle":"Using BEN (simple_bdi)","url":"wiki/Using-BEN-simple-bdi#emotional-engine","content":"BEN enables the agent to get emotions about its cognitive mental states. This addition of emotions is based on the OCC model (Ortony, 1990) and its logical formalism (Adam, 2007), which has been proposed to integrate the OCC model in a BDI formalism. According to the OCC theory, emotions can be split into three groups: emotions linked to events, emotions linked to people and actions performed by people, and emotions linked to objects. In BEN, as the focus is on relations between social agents, only the first two groups of emotions (emotions linked to events and people) are considered. The twenty emotions defined in this paper can be divided into seven groups depending on their relations with mental states: emotions about beliefs, emotions about uncertainties, combined emotions about uncertainties, emotions about other agents with a positive liking value, emotions about other agents with a negative liking value, emotions about ideals and combined emotions about ideals. All the initial intensities and decay value are computed using the OCEAN model and the value attached to the concerned mental states. The emotions about beliefs are joy and sadness and are expressed this way: Joyi(Pj,j) = Beliefi(Pj) \\&amp; Desirei(P) Sadnessi(Pj,j) = Beliefi(Pj) \\&amp; Desirei(not P) Their initial intensity is computed according to the following equation with N the neurotism component from the OCEAN model: I[Emi(P)] = V[Beliefi(P)] x V[Desirei(P)] x (1+(0,5-N)) The emotions about uncertainties are fear and hope and are defined this way: Hopei(Pj,j) = Uncertaintyi(Pj) \\&amp; Desirei(P)Feari(Pj,j) = Uncertaintyi(Pj) \\&amp; Desirei(not P) Their initial intensity is computed according to the following equation: I[Emi(P)] = V[Uncertaintyi(P)] x V[Desirei(P)] x (1+(0,5-N)) Combined emotions about uncertainties are emotions built upon fear and hope. They appear when an uncertainty is replaced by a belief, transforming fear and hope into satisfaction, disappointment, relief or fear confirmed and they are defined this way: Satisfactioni(Pj,j) = Hopei(Pj,j) \\&amp; Beliefi(Pj)Disappointmenti(Pj,j) = Hopei(Pj,j) \\&amp; Beliefi(not Pj)Reliefi(Pj,j) = Feari(Pj,j) \\&amp; Beliefi(not Pj)Fear confirmedi(Pj,j) = Feari(Pj,j) \\&amp; Beliefi(Pj) Their initial intensity is computed according to the following equation with Em'i(P) the emotion of fear/hope. I[Emi(P)] = V[Beliefi(P)] x I[Em'i(P)] On top of that, according to the logical formalism (Adam, 2007), four inference rules are triggered by these emotions: The creation of fear confirmed or the creation of relief will replace the emotion of fear.The creation of satisfaction or the creation of disappointment will replace a hope emotion.The creation of satisfaction or relief leads to the creation of joy.The creation of disappointment or fear confirmed leads to the creation of sadness. The emotions about other agents with a positive liking value are emotions related to emotions of other agents which are in a the social relation base with a positive liking value on that link. They are the emotions called &quot;happy for&quot; and &quot;sorry for&quot; which are defined this way : Happy fori(P,j) = L[Ri,j]&gt;0 \\&amp; Joyj(P)Sorry fori(P,j) = L[Ri,j]&gt;0 \\&amp; Sadnessj(P) Their initial intensity is computed according to the following equation with A the agreeableness value from the OCEAN model. I[Emi(P)] = I[Emj(P)] x L[Ri,j] x (1-(0,5-A)) Emotions about other agents with a negative liking value are close to the previous definitions, however, they are related to the emotions of other agents which are in the social relation base with a negative liking value. These emotions are resentment and gloating and have the following definition: Resentmenti(P,j) = L[Ri,j]&lt;0 \\&amp; Joyj(P)Gloatingi(P,j) = L[Ri,j]&lt;0 \\&amp; Sadnessj(P) Their initial intensity is computed according to the following equation. This equation can be seen as the inverse of Equation \\eqref{eqIntensEmo4}, and means that the intensity of resentment or gloating is greater if the agent has a low level of agreeableness contrary to the intensity of &quot;happy for&quot; and &quot;sorry for&quot;. I[Emi(P)] = I[Emj(P)] x |L[Ri,j]| x (1+(0,5-A)) Emotions about ideals are related to the agent's ideal base which contains, at the start of the simulation, all the actions about which the agent has a praiseworthiness value to give. These ideals can be praiseworthy (their praiseworthiness value is positive) or blameworthy (their praiseworthiness value is negative). The emotions coming from these ideals are pride, shame, admiration and reproach and have the following definition: Pridei(Pi,i) = Beliefi(Pi) \\&amp; Ideali(Pi) \\&amp; V[Ideali(Pi)]&gt;0Shamei(Pi,i) = Beliefi(Pi) \\&amp; Ideali(Pi) \\&amp; V[Ideali(Pi)]&lt;0Admirationi(Pj,j) = Beliefi(Pj) \\&amp; Ideali(Pj) \\&amp; V[Ideali(Pj)]&gt;0Reproachi(Pj,j) = Beliefi(Pj) \\&amp; Ideali(Pj) \\&amp; V[Ideali(Pj)]&lt;0 Their initial intensity is computed according to the following equation with O the openness value from the OCEAN model: I[Emi(P)] = V[Beliefi(P)] x |V[Ideali(P)]| x (1+(0,5-O)) Finally, combined emotions about ideals are emotions built upon pride, shame, admiration and reproach. They appear when joy or sadness appear with an emotion about ideals. They are gratification, remorse, gratitude and anger which are defined as follows: Gratificationi(Pi,i) = Pridei(Pi,i) \\&amp; Joyi(Pi)Remorsei(Pi,i) = Shamei(Pi,i) \\&amp; Sadnessi(Pi)Gratitudei(Pj,j) = Admirationi(Pj,j) \\&amp; Joyi(Pj)Angeri(Pj,j) = Reproachi(Pj,j) \\&amp; Sadnessi(Pj) Their initial intensity is computed according to the following equation with Em'i(P) the emotion about ideals and Em&quot;i(P) the emotion about beliefs. I[Emi(P)] = I[Em'i(P)] x I[Em&quot;i(P)] In order to keep the initial intensity of each emotion between 0 and 1, each equation is truncated between 0 an 1 if necessary. The initial decay value for each of these twenty emotions is computed according to the same equation with Deltat a time step which enables to define that an emotion does not last more than a given time: De[Emi(P)] = N x I[Emi(P)] x Deltat To use this automatic computation of emotion, a modeler need to activate it as shown in the GAML example below : species miner control:simple_bdi { ... bool use_emotions_architecture &lt;- true; ... }  "},{"title":"Social Engine​","type":1,"pageTitle":"Using BEN (simple_bdi)","url":"wiki/Using-BEN-simple-bdi#social-engine","content":"When an agent already known is perceived (i.e. there is already a social link with it), the social relationship with this agent is updated automatically by BEN. This update is based on the work of (Ochs, 2009) and takes the agent's cognitive mental states and emotions into account. In this section, the automatic update of each variable of a social link Ri,j(L,D,S,F,T) by the architecture is described in details; the trust variable of the link is however not updated automatically. Liking: according to (Ortony, 1991), the degree of liking between two agents depends on the valence (positive or negative) of the emotions induced by the corresponding agent. In the emotional model of the architecture, joy and hope are considered as positive emotions (satisfaction and relief automatically raise joy with the emotional engine) while sadness and fear are considered as negative emotions (fear confirmed and disappointment automatically raise sadness with the emotional engine). So, if an agent i has a positive (resp. negative) emotion caused by an agent j, this will increase (resp. decrease) the value of appreciation in the social link from i concerning j.  Moreover, research has shown that the degree of liking is influenced by the solidarity value \\cite{smith2014social}. This may be explained by the fact that people tend to appreciate people similar to them. The computation formula is described with the following equation with mPos the mean value of all positive emotions caused by agent j, mNeg the mean value of all negative emotions caused by agent j and aL a coefficient depending of the agent's personality, indicating the importance of emotions in the process, and which is described below. L[Ri,j]=L[Ri,j]+|L[Ri,j]|(1-|L[Ri,j]|)S[Ri,j] + aL (1-|L[Ri,j]|)(mPos-mNeg) aL = 1-N Dominance : (Keltner, 2001) and (Shiota, 2004) explain that an emotion of fear or sadness caused by another agent represent an inferior status. But (Knutson, 1996) explains that perceiving fear and sadness in others increases the sensation of power over those persons. The computation formula is described by the following equation with mSE the mean value of all negative emotions caused by agent i to agent j, mOE the mean value of all negative emotions caused by agent j to agent i and aD a coefficient depending on the agent's personality, indicating the importance of emotions in the process. D[Ri,j]=D[Ri,j] + aD (1-|D[Ri,j]|)(mSE-mOE) aD = 1-N Solidarity: The solidarity represents the degree of similarity of desires, beliefs, and uncertainties between two agents. In BEN, the evolution of the solidarity value depends on the ratio of similarity between the desires, beliefs, and uncertainties of agent i and those of agent j. To compute the similarities and oppositions between agent i and agent j, agent i needs to have beliefs about agent j's cognitive mental states. Then it compares these cognitive mental states with its own to detect similar or opposite knowledge. On top of that, negative emotions tend to decrease the value of solidarity between two people. The computation formula is described by the following equation with sim the number of cognitive mental states similar between agent i and agent j, opp the number of opposite cognitive mental states between agent i and agent j, NbKnow the number of cognitive mental states in common between agent i and agent j, mNeg the mean value of all negative emotions caused by agent j, aS1 a coefficient depending of the agent's personality, indicating the importance of similarities and oppositions in the process, and aS2 a coefficient depending of the agent's personality, indicating the importance of emotions in the process. S[Ri,j]=S[Ri,j] + S[Ri,j] x (1-S[Ri,j]) x (aS1 (sim-opp)/(NbKnow) - aS2 mNeg)) aS1 = 1-O aS2 = 1-N Familiarity: In psychology, emotions and cognition do not seem to impact the familiarity. However, (Collins, 1994) explains that people tend to be more familiar with people whom they appreciate. This notion is modeled by basing the evolution of the familiarity value on the liking value between two agents. The computation formula is defined by the following equation. F[Ri,j]=F[Ri,j] x (1+L[Ri,j]) The trust value is not evolving automatically in BEN, as there is no clear and automatic link with cognition or emotions. However, this value can evolve manually, especially with sanctions and rewards to social norms where the modeler can indicate a modification of the trust value during the enforcement process. To use this automatic update of social relations, a modeler need to activate it as shown in the GAML example below: species miner control: simple_bdi { ... bool use_social_architecture &lt;- true; ... }  "},{"title":"Making Decision​","type":1,"pageTitle":"Using BEN (simple_bdi)","url":"wiki/Using-BEN-simple-bdi#making-decision","content":"The third part of the architecture is the only one mandatory as it is where the agent makes a decision. A cognitive engine can be coupled with a normative engine to chose an intention and a plan to execute. The complete engine is summed up in the figure below:  The decision-making process can be divided into seven steps: Step 1: the engine checks the current intention. If it is still valid, the intention is kept so the agent may continue to carry out its current plan.Step 2: the engine checks if the current plan/norm is still usable or not, depending on its context.Step 3: the engine checks if the agent obeys an obligation taken from the obligations corresponding to a norm with a valid context in the current situation and with a threshold level lower than the agent's obedience value as computed in Section 4.1.Step 4: the obligation with the highest priority is taken as the current intention.Step 5: the desire with the highest priority is taken as the current intention.Step 6: the plan or norm with the highest priority is selected as the current plan/norm, among the plans or norms corresponding to the current intention with a valid context.Step 7: the behavior associated with the current plan/norm is executed. Steps 4, 5 and 6 do not have to be deterministic; they may be probabilistic. In this case, the priority value associated with obligations, desires, plans, and norms serves as a probability. In GAML, a modeler may indicate the use of a probabilistic or deterministic cognitive engine with the variable probabilistic_choice, as shown in the example code below: species miner control: simple_bdi { ... bool probabilistic_choice &lt;- true; ... }  "},{"title":"Defining plans​","type":1,"pageTitle":"Using BEN (simple_bdi)","url":"wiki/Using-BEN-simple-bdi#defining-plans","content":"The modeler needs to define action plans which are used by the cognitive engine, as explained earlier. These plans are a set of behaviors executed in a certain context in response to an intention. In BEN, a plan owned by agent i is represented by Pli(Int,Cont,Pr,B) with: Pl: the name of the plan.Int: the intention triggering this plan.Cont: the context in which this plan may be applied.Pr: a priority value used to choose between multiple plans relevant at the same time. If two plans are relevant to the same priority, one is chosen at random.B: the behavior, as a sequence of instructions, to execute if the plan is chosen by the agent. The context of a plan is a particular state of the world in which this plan should be considered by the agent making a decision. This feature enables to define multiple plans answering the same intention but activated in various contexts. Below is an example for the definition of two plans answering the same intention in different contexts in GAML: species miner control: simple_bdi skills: [moving]{ ... plan evacuationFast intention: in_shelter emotion: fearConfirmed priority:2 { color &lt;- #yellow; speed &lt;- 60 #km/#h; if (target = nil or noTarget) { target &lt;- (shelter with_min_of (each.location distance_to location)).location; noTarget &lt;- false; } else { do goto target: target on: road_network move_weights: current_weights recompute_path: false; if (target = location) { do die; } } } plan evacuation intention: in_shelter finished_when: has_emotion(fearConfirmed){ color &lt;-#darkred; if (target = nil or noTarget) { target &lt;- (shelter with_min_of (each.location distance_to location)).location; noTarget &lt;- false; } else { do goto target: target on: road_network move_weights: current_weights recompute_path: false; if (target = location) { do die; } } } ... }  "},{"title":"Defining norms​","type":1,"pageTitle":"Using BEN (simple_bdi)","url":"wiki/Using-BEN-simple-bdi#defining-norms","content":"A normative engine may be used within the cognitive engine, as it has been explained above. This normative engine means choosing an obligation as the current intention and selecting a set of actions to answer this intention. Also, the concept of social norms is modeled as a set of action answering an intention, which an agent could disobey. tention and selecting a set of actions to answer this intention. Also, the concept of social norms is modeled as a set of action answering an intention, which an agent could disobey. In BEN, this concept of behavior which may be disobeyed is formally represented by a norm possessed by agent i Noi(Int,Cont,Ob,Pr,B,Vi) with: No: the name of the norm.Int: the intention which triggers this norm.Cont: the context in which this norm can be applied.Ob: an obedience value that serves as a threshold to determine whether or not the norm is applied depending on the agent's obedience value (if the agent's value is above the threshold, the norm may be executed).Pr: a priority value used to choose between multiple norms applicable at the same time.B: the behavior, as a sequence of instructions, to execute if the norm is followed by the agent.Vi: a violation time indicating how long the norm is considered violated once it has been violated. In GAML, a norm is defined as follows: species miner control: simple_bdi { ... //this first norm answer an intention coming from an obligation norm doingJob obligation:has_gold finished_when: has_belief(has_gold) threshold:thresholdObligation{ if (target = nil) { do add_subintention(has_gold,choose_goldmine, true); do current_intention_on_hold(); } else { do goto target: target ; if (target = location) { goldmine current_mine&lt;- goldmine first_with (target = each.location); if current_mine.quantity &gt; 0 { gold_transported &lt;- gold_transported+1; do add_belief(has_gold); ask current_mine {quantity &lt;- quantity - 1;} } else { do add_belief(new_predicate(empty_mine_location, [&quot;location_value&quot;::target])); do remove_belief(new_predicate(mine_at_location, [&quot;location_value&quot;::target])); } target &lt;- nil; } } } //this norm may be seen as a &quot;social norm&quot; as it answers an intention not coming from an obligation but may be disobeyed norm share_information intention:share_information threshold:thresholdNorm instantaneous: true{ list&amp;lt;miner&gt; my_friends &lt;- list&amp;lt;miner&gt;((social_link_base where (each.liking &gt; 0)) collect each.agent); loop known_goldmine over: get_beliefs_with_name(mine_at_location) { ask my_friends { do add_belief(known_goldmine); } } loop known_empty_goldmine over: get_beliefs_with_name(empty_mine_location) { ask my_friends { do add_belief(known_empty_goldmine); } } do remove_intention(share_information, true); } ... }  "},{"title":"Dynamic knowledge​","type":1,"pageTitle":"Using BEN (simple_bdi)","url":"wiki/Using-BEN-simple-bdi#dynamic-knowledge","content":"The final part of the architecture is used to create a temporal dynamic to the agent's behavior, useful in a simulation context. To do so, this module automatically degrades mental states and emotions and updates the status of each norm. The degradation of mental states consists of reducing their lifetime. When the lifetime is null, the mental state is removed from its base. The degradation of emotions consists of reducing the intensity of each emotion stored by its decay value. When the intensity of an emotion is null, the emotion is removed from the emotional base. In GAML, if a mental state has a lifetime value or if an emotion has an intensity and a decay value, this degradation process is done automatically. Finally, the status of each norm is updated to indicate if the norm was activated or not (if the context was right or wrong) and if it was violated or not (the norm was activated but the agent disobeyed it). Also, a norm can be violated for a certain time which is updated and if it becomes null, the norm is not violated anymore. These last steps enable the agent's behavior's components to automatically evolve through time, leading the agents to forget a piece of knowledge after a certain amount of time, creating dynamics in their behavior. "},{"title":"Conclusion​","type":1,"pageTitle":"Using BEN (simple_bdi)","url":"wiki/Using-BEN-simple-bdi#conclusion","content":"The BEN architecture is already implemented in GAMA and may be accessed by adding the simple_bdi control architecture to the definition of a species. A tutorial may be found with the BDI Tutorial. "},{"title":"Using extensions","type":0,"sectionRef":"#","url":"wiki/Using-extensions","content":"","keywords":""},{"title":"Selected plugins provided by the GAMA community​","type":1,"pageTitle":"Using extensions","url":"wiki/Using-extensions#selected-plugins-provided-by-the-gama-community","content":"The update site located at the address http://updates.gama-platform.org/experimental contains new plugins for GAMA mainly developed by the GAMA community (its Github repository is available here). As the name of the repository highlights it, these plugins are most of them still in development, before integration in the kernel of GAMA. The following plugins have been tested and are still supported: RJava: to connect GAMA en RWeka: to connect GAMA en WekaMatlab: to connect GAMA en MatlabArgumentation feature: to allow agents to reason on an argument systemBayesian Network feature: to use Bayesian Network to make decisionFuzzy logic: to use fuzzy logic model to make decisionLaunchpad: ****:  "},{"title":"RJava plugin​","type":1,"pageTitle":"Using extensions","url":"wiki/Using-extensions#rjava-plugin","content":"This plugin allows the modeler to launch some computation on the R software. To this purpose, R should be installed on your computer and GAMA should be properly configured. This possible connection to R opens thus the possibility for the modeler to use all the statistical functions and libraries developed in this tool of reference. In addition, R scripts defined by the modeler can also be used directly from his/her GAMA model. "},{"title":"Toward participative simulations with Remote.Gui and Gaming plugins​","type":1,"pageTitle":"Using extensions","url":"wiki/Using-extensions#toward-participative-simulations-with-remotegui-and-gaming-plugins","content":"There are more and more applications of GAMA for participative simulations (LittoSim, MarakAir, HoanKiemAir...). There was thus a need for new features to improve the possible interactions with simulations and the definition of the Graphical User Interface. The two plugins Remote.Gui and Gaming (available in the &quot;Participative simulation&quot; category) attempts to fill this need. Remote.Gui allows exposing some model parameters, in order that they can be modified through a network. This allows, for example, to develop a remote application (e.g. Android application) to control the parameters' values during the simulation. Gaming allows the modeler to define displays that are much more interactive. This is used to define serious games in which the users can have a wide range of possible interactions with the simulation. "},{"title":"Weka and Matlab plugins​","type":1,"pageTitle":"Using extensions","url":"wiki/Using-extensions#weka-and-matlab-plugins","content":"Similarly to RJava, Matlab and Weka plugins allow the modeler to run computations on the Matlab and Weka software, taking advantages of all the possibilities of these softwares and of scripts defined by him/herself. Notice that the Matlab plugin requires that MATLAB 2019a is installed and activated on your computer. "},{"title":"Statements","type":0,"sectionRef":"#","url":"wiki/Statements","content":"","keywords":""},{"title":"Table of Contents​","type":1,"pageTitle":"Statements","url":"wiki/Statements#table-of-contents","content":"=, abort, action, add, agents, annealing, ask, aspect, assert, benchmark, break, browse, camera, capture, catch, chart, conscious_contagion, coping, create, data, datalist, default, diffuse, diffusion, display, display_grid, display_population, do, draw, else, emotional_contagion, enforcement, enter, equation, error, event, exhaustive, exit, experiment, explicit, focus, focus_on, generate, genetic, global, graphics, grid, highlight, hill_climbing, if, image, init, inspect, invoke, law, layout, let, light, loop, match, match_between, match_one, match_regex, mesh, migrate, monitor, norm, output, output_file, overlay, parameter, perceive, permanent, plan, pso, put, reactive_tabu, reflex, release, remove, return, rotation, rule, rule, run, sanction, save, set, setup, simulate, sobol, socialize, solve, species, start_simulation, state, status, switch, tabu, task, test, text, trace, transition, try, unconscious_contagion, user_command, user_init, user_input, user_panel, using, Variable_container, Variable_number, Variable_regular, warn, write, "},{"title":"Statements by kinds​","type":1,"pageTitle":"Statements","url":"wiki/Statements#statements-by-kinds","content":"Batch method annealing, exhaustive, explicit, genetic, hill_climbing, pso, reactive_tabu, sobol, tabu, Behavior abort, aspect, coping, init, norm, plan, reflex, rule, sanction, state, task, test, user_init, user_panel, Experiment experiment, Layer agents, camera, chart, display_grid, display_population, event, graphics, image, light, mesh, overlay, rotation, Output browse, display, inspect, layout, monitor, output, output_file, permanent, Parameter parameter, Sequence of statements or action action, ask, benchmark, capture, catch, create, default, else, enter, equation, exit, generate, if, loop, match, match_between, match_one, match_regex, migrate, perceive, release, run, setup, start_simulation, switch, trace, transition, try, user_command, using, Single statement =, add, assert, break, conscious_contagion, data, datalist, diffuse, diffusion, do, draw, emotional_contagion, enforcement, error, focus, focus_on, highlight, invoke, law, let, put, remove, return, rule, save, set, simulate, socialize, solve, status, text, unconscious_contagion, user_input, warn, write, Species global, grid, species, Variable (container) Variable_container, Variable (number) Variable_number, Variable (regular) Variable_regular,  "},{"title":"Statements by embedment​","type":1,"pageTitle":"Statements","url":"wiki/Statements#statements-by-embedment","content":"Behavior add, ask, assert, benchmark, capture, conscious_contagion, create, diffuse, do, emotional_contagion, enforcement, error, focus, focus_on, generate, highlight, if, inspect, let, loop, migrate, put, release, remove, return, run, save, set, simulate, socialize, solve, start_simulation, status, switch, trace, transition, try, unconscious_contagion, using, warn, write, Environment species, Experiment action, annealing, exhaustive, explicit, genetic, hill_climbing, output, parameter, permanent, pso, reactive_tabu, reflex, rule, setup, simulate, sobol, state, tabu, task, test, text, user_command, user_init, user_panel, Variable_container, Variable_number, Variable_regular, Layer add, ask, benchmark, draw, error, focus_on, highlight, if, let, loop, put, remove, set, status, switch, trace, try, using, warn, write, Model action, aspect, coping, equation, experiment, law, norm, output, perceive, plan, reflex, rule, rule, run, sanction, setup, species, start_simulation, state, task, test, user_command, user_init, user_panel, Variable_container, Variable_number, Variable_regular, Output ask, if, Sequence of statements or action add, ask, assert, assert, benchmark, break, capture, conscious_contagion, create, data, datalist, diffuse, do, draw, emotional_contagion, enforcement, error, focus, focus_on, generate, highlight, if, inspect, let, loop, migrate, put, release, remove, return, save, set, simulate, socialize, solve, status, switch, trace, transition, try, unconscious_contagion, using, warn, write, Single statement run, start_simulation, Species action, aspect, coping, equation, law, norm, perceive, plan, reflex, rule, rule, run, sanction, setup, simulate, species, start_simulation, state, task, test, user_command, user_init, user_panel, Variable_container, Variable_number, Variable_regular, action assert, return, aspect draw, chart add, ask, data, datalist, do, put, remove, set, simulate, using, display agents, camera, chart, display_grid, display_population, event, graphics, image, light, mesh, overlay, rotation, display_population display_population, equation =, fsm state, user_panel, if else, output display, inspect, layout, monitor, output_file, parallel_bdi coping, rule, permanent display, inspect, monitor, output_file, probabilistic_tasks task, rules rule, simple_bdi coping, rule, sorted_tasks task, state enter, exit, switch default, match, test assert, try catch, user_command user_input, user_first user_panel, user_init user_panel, user_last user_panel, user_only user_panel, user_panel user_command, weighted_tasks task,  "},{"title":"General syntax​","type":1,"pageTitle":"Statements","url":"wiki/Statements#general-syntax","content":"A statement represents either a declaration or an imperative command. It consists in a keyword, followed by specific facets, some of them mandatory (in bold), some of them optional. One of the facet names can be omitted (the one denoted as omissible). It has to be the first one. statement_keyword expression1 facet2: expression2 ... ; or statement_keyword facet1: expression1 facet2: expression2 ...;  If the statement encloses other statements, it is called a sequence statement, and its sub-statements (either sequence statements or single statements) are declared between curly brackets, as in: statement_keyword1 expression1 facet2: expression2... { // a sequence statement statement_keyword2 expression1 facet2: expression2...; // a single statement statement_keyword3 expression1 facet2: expression2...; }   "},{"title":"=","type":1,"pageTitle":"Statements","url":"wiki/Statements##","content":"Facets​ right (float), (omissible) : the right part of the equation (it is mandatory that it can be evaluated as a float left (any type): the left part of the equation (it should be a variable or a call to the diff() or diff2() operators)  Definition​ Allows to implement an equation in the form function(n, t) = expression. The left function is only here as a placeholder for enabling a simpler syntax and grabbing the variable as its left member. Usages​ The syntax of the = statement is a bit different from the other statements. It has to be used as follows (in an equation): float t; float S; float I; equation SI { diff(S,t) = (- 0.3 * S * I / 100); diff(I,t) = (0.3 * S * I / 100); }  See also: equation, solve,  Embedments​ The = statement is of type: Single statementThe = statement can be embedded into: equation, The = statement embeds statements:   "},{"title":"action​","type":1,"pageTitle":"Statements","url":"wiki/Statements#action","content":"Facets​ name (an identifier), (omissible) : identifier of the actionindex (a datatype identifier): if the action returns a map, the type of its keysof (a datatype identifier): if the action returns a container, the type of its elementstype (a datatype identifier): the action returned typevirtual (boolean): whether the action is virtual (defined without a set of instructions) (false by default)  Definition​ Allows to define in a species, model or experiment a new action that can be called elsewhere. Usages​ The simplest syntax to define an action that does not take any parameter and does not return anything is: action simple_action { // [set of statements] }  If the action needs some parameters, they can be specified betwee, braquets after the identifier of the action: action action_parameters(int i, string s){ // [set of statements using i and s] }  If the action returns any value, the returned type should be used instead of the &quot;action&quot; keyword. A return statement inside the body of the action statement is mandatory. int action_return_val(int i, string s){ // [set of statements using i and s] return i + i; }  If virtual: is true, then the action is abstract, which means that the action is defined without body. A species containing at least one abstract action is abstract. Agents of this species cannot be created. The common use of an abstract action is to define an action that can be used by all its sub-species, which should redefine all abstract actions and implements its body. species parent_species { int virtual_action(int i, string s); } species children parent: parent_species { int virtual_action(int i, string s) { return i + i; } }  See also: do,  Embedments​ The action statement is of type: Sequence of statements or actionThe action statement can be embedded into: Species, Experiment, Model, The action statement embeds statements: assert, return,   "},{"title":"add​","type":1,"pageTitle":"Statements","url":"wiki/Statements#add","content":"Facets​ to (any type in [container, species, agent, geometry]): an expression that evaluates to a containeritem (any type), (omissible) : any expression to add in the containerall (any type): Allows to either pass a container so as to add all its element, or 'true', if the item to add is already a container.at (any type): position in the container of added element  Definition​ Allows to add, i.e. to insert, a new element in a container (a list, matrix, map, ...).Incorrect use: The addition of a new element at a position out of the bounds of the container will produce a warning and let the container unmodified. If all: is specified, it has no effect if its argument is not a container, or if its argument is 'true' and the item to add is not a container. In that latter case Usages​ The new element can be added either at the end of the container or at a particular position. add expr to: expr_container; // Add at the end add expr at: expr to: expr_container; // Add at position expr  Case of a list, the expression in the facet at: should be an integer. list&amp;lt;int&gt; workingList &lt;- [];add 0 at: 0 to: workingList ;//workingList equals [0]add 10 at: 0 to: workingList ;//workingList equals [10,0]add 20 at: 2 to: workingList ;//workingList equals [10,0,20]add 50 to: workingList;//workingList equals [10,0,20,50]add [60,70] all: true to: workingList;//workingList equals [10,0,20,50,60,70]  Case of a map: As a map is basically a list of pairs key::value, we can also use the add statement on it. It is important to note that the behavior of the statement is slightly different, in particular in the use of the at facet, which denotes the key of the pair. map&amp;lt;string,string&gt; workingMap &lt;- [];add &quot;val1&quot; at: &quot;x&quot; to: workingMap;//workingMap equals [&quot;x&quot;::&quot;val1&quot;]  If the at facet is omitted, a pair expr_item::expr_item will be added to the map. An important exception is the case where the expr_item is a pair: in this case the pair is added.   Notice that, as the key should be unique, the addition of an item at an existing position (i.e. existing key) will only modify the value associated with the given key.   On a map, the all facet will add all value of a container in the map (so as pair val_cont::val_cont)   In case of a graph, we can use the facets node, edge and weight to add a node, an edge or weights to the graph. However, these facets are now considered as deprecated, and it is advised to use the various edge(), node(), edges(), nodes() operators, which can build the correct objects to add to the graph  graph g &lt;- as_edge_graph([{1,5}::{12,45}]); add edge: {1,5}::{2,3} to: g; list var &lt;- g.vertices; // var equals [{1,5},{12,45},{2,3}] list var &lt;- g.edges; // var equals [polyline({1.0,5.0}::{12.0,45.0}),polyline({1.0,5.0}::{2.0,3.0})] add node: {5,5} to: g; list var &lt;- g.vertices; // var equals [{1.0,5.0},{12.0,45.0},{2.0,3.0},{5.0,5.0}] list var &lt;- g.edges; // var equals [polyline({1.0,5.0}::{12.0,45.0}),polyline({1.0,5.0}::{2.0,3.0})]  Case of a matrix: this statement can not be used on matrix. Please refer to the statement put. See also: put, remove,  Embedments​ The add statement is of type: Single statementThe add statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer, The add statement embeds statements:   "},{"title":"agents​","type":1,"pageTitle":"Statements","url":"wiki/Statements#agents","content":"Facets​ value (container): the set of agents to displayname (a label), (omissible) : Human readable title of the layeraspect (an identifier): the name of the aspect that should be used to display the speciesfading (boolean): Used in conjunction with 'trace:', allows to apply a fading effect to the previous traces. Default is falseposition (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer. In case of negative value OpenGl will position the layer out of the environment.refresh (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, useful in case of agents that do not move)rotate (float): Defines the angle of rotation of this layer, in degrees, around the z-axis.selectable (boolean): Indicates whether the agents present on this layer are selectable by the user. Default is truesize (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates &gt; 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in 'position', an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directionstrace (any type in [boolean, int]): Allows to aggregate the visualization of agents at each timestep on the display. Default is false. If set to an int value, only the last n-th steps will be visualized. If set to true, no limit of timesteps is applied.transparency (float): the transparency level of the layer (between 0 -- opaque -- and 1 -- fully transparent)visible (boolean): Defines whether this layer is visible or not  Definition​ agents allows the modeler to display only the agents that fulfill a given condition. Usages​ The general syntax is: display my_display { agents layer_name value: expression [additional options]; }  For instance, in a segregation model, agents will only display unhappy agents: display Segregation { agents agentDisappear value: people as list where (each.is_happy = false) aspect: with_group_color; }  See also: display, chart, event, graphics, display_grid, image, overlay, display_population,  Embedments​ The agents statement is of type: LayerThe agents statement can be embedded into: display, The agents statement embeds statements:   "},{"title":"annealing​","type":1,"pageTitle":"Statements","url":"wiki/Statements#annealing","content":"Facets​ name (an identifier), (omissible) : The name of the method. For internal use onlyaggregation (a label), takes values in: {min, max}: the agregation methodinit_solution (map): init solution: key: name of the variable, value: value of the variablemaximize (float): the value the algorithm tries to maximizeminimize (float): the value the algorithm tries to minimizenb_iter_cst_temp (int): number of iterations per level of temperaturetemp_decrease (float): temperature decrease coefficienttemp_end (float): final temperaturetemp_init (float): initial temperature  Definition​ This algorithm is an implementation of the Simulated Annealing algorithm. See the wikipedia article and [batch161 the batch dedicated page]. Usages​ As other batch methods, the basic syntax of the annealing statement uses method annealing instead of the expected annealing name: id :  method annealing [facet: value];  For example:  method annealing temp_init: 100 temp_end: 1 temp_decrease: 0.5 nb_iter_cst_temp: 5 maximize: food_gathered;  Embedments​ The annealing statement is of type: Batch methodThe annealing statement can be embedded into: Experiment, The annealing statement embeds statements:   "},{"title":"ask​","type":1,"pageTitle":"Statements","url":"wiki/Statements#ask","content":"Facets​ target (any type in [container, agent]), (omissible) : an expression that evaluates to an agent or a list of agentsas (species): an expression that evaluates to a speciesparallel (any type in [boolean, int]): (experimental) setting this facet to 'true' will allow 'ask' to use concurrency when traversing the targets; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet is false by default.  Definition​ Allows an agent, the sender agent (that can be the [Sections161#global world agent]), to ask another (or other) agent(s) to perform a set of statements. If the value of the target facet is nil or empty, the statement is ignored. Usages​ Ask a set of receiver agents, stored in a container, to perform a block of statements. The block is evaluated in the context of the agents' species ask ${receiver_agents} { ${cursor} }  Ask one agent to perform a block of statements. The block is evaluated in the context of the agent's species ask ${one_agent} { ${cursor} }  If the species of the receiver agent(s) cannot be determined, it is possible to force it using the as facet. An error is thrown if an agent is not a direct or undirect instance of this species ask${receiver_agent(s)} as: ${a_species_expression} { ${cursor} }  To ask a set of agents to do something only if they belong to a given species, the of_species operator can be used. If none of the agents belong to the species, nothing happens ask ${receiver_agents} of_species ${species_name} { ${cursor} }  Any statement can be declared in the block statements. All the statements will be evaluated in the context of the receiver agent(s), as if they were defined in their species, which means that an expression like self will represent the receiver agent and not the sender. If the sender needs to refer to itself, some of its own attributes (or temporary variables) within the block statements, it has to use the keyword myself. species animal { float energy &lt;- rnd (1000) min: 0.0; reflex when: energy &gt; 500 { // executed when the energy is above the given threshold list&amp;lt;animal&gt; others &lt;- (animal at_distance 5); // find all the neighboring animals in a radius of 5 meters float shared_energy &lt;- (energy - 500) / length (others); // compute the amount of energy to share with each of them ask others { // no need to cast, since others has already been filtered to only include animals if (energy &lt; 500) { // refers to the energy of each animal in others energy &lt;- energy + myself.shared_energy; // increases the energy of each animal myself.energy &lt;- myself.energy - myself.shared_energy; // decreases the energy of the sender } } } }  If the species of the receiver agent cannot be determined, it is possible to force it by casting the agent. Nothing happens if the agent cannot be casted to this species Embedments​ The ask statement is of type: Sequence of statements or actionThe ask statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer, Output, The ask statement embeds statements:   "},{"title":"aspect​","type":1,"pageTitle":"Statements","url":"wiki/Statements#aspect","content":"Facets​ name (an identifier), (omissible) : identifier of the aspect (it can be used in a display to identify which aspect should be used for the given species). Two special names can also be used: 'default' will allow this aspect to be used as a replacement for the default aspect defined in preferences; 'highlighted' will allow the aspect to be used when the agent is highlighted as a replacement for the default (application of a color)  Definition​ Aspect statement is used to define a way to draw the current agent. Several aspects can be defined in one species. It can use attributes to customize each agent's aspect. The aspect is evaluate for each agent each time it has to be displayed. Usages​ An example of use of the aspect statement: species one_species { int a &lt;- rnd(10); aspect aspect1 { if(a mod 2 = 0) { draw circle(a);} else {draw square(a);} draw text: &quot;a= &quot; + a color: #black size: 5; } }  Embedments​ The aspect statement is of type: BehaviorThe aspect statement can be embedded into: Species, Model, The aspect statement embeds statements: draw,   "},{"title":"assert​","type":1,"pageTitle":"Statements","url":"wiki/Statements#assert","content":"Facets​ value (boolean), (omissible) : a boolean expression. If its evaluation is true, the assertion is successful. Otherwise, an error (or a warning) is raised.warning (boolean): if set to true, makes the assertion emit a warning instead of an error  Definition​ Allows to check if the evaluation of a given expression returns true. If not, an error (or a warning) is raised. If the statement is used inside a test, the error is not propagagated but invalidates the test (in case of a warning, it partially invalidates it). Otherwise, it is normally propagated Usages​ Any boolean expression can be used assert (2+2) = 4; assert self != nil; int t &lt;- 0; assert is_error(3/t); (1 / 2) is float  if the 'warn:' facet is set to true, the statement emits a warning (instead of an error) in case the expression is false assert 'abc' is string warning: true  See also: test, setup, is_error, is_warning,  Embedments​ The assert statement is of type: Single statementThe assert statement can be embedded into: test, action, Sequence of statements or action, Behavior, Sequence of statements or action, The assert statement embeds statements:   "},{"title":"benchmark​","type":1,"pageTitle":"Statements","url":"wiki/Statements#benchmark","content":"Facets​ message (any type), (omissible) : A message to display alongside the results. Should concisely describe the contents of the benchmarkrepeat (int): An int expression describing how many executions of the block must be handled. The output in this case will return the min, max and average durations  Definition​ Displays in the console the duration in ms of the execution of the statements included in the block. It is possible to indicate, with the 'repeat' facet, how many times the sequence should be run Usages​ Embedments​ The benchmark statement is of type: Sequence of statements or actionThe benchmark statement can be embedded into: Behavior, Sequence of statements or action, Layer, The benchmark statement embeds statements:   "},{"title":"break​","type":1,"pageTitle":"Statements","url":"wiki/Statements#break","content":"Facets​ Definition​ break allows to interrupt the current sequence of statements. Usages​ Embedments​ The break statement is of type: Single statementThe break statement can be embedded into: Sequence of statements or action, The break statement embeds statements:   "},{"title":"camera​","type":1,"pageTitle":"Statements","url":"wiki/Statements#camera","content":"Facets​ name (string), (omissible) : The name of the camera. Will be used to populate a menu with the other camera presets. Can provide a value to the 'camera:' facet of the display, which specifies which camera to use.Using the special constant #default will make it the default of the surrounding displaydistance (float): If the 'location:' facet is not defined, defines the distance (in world units) that separates the camera from its target. If 'location:' is defined, especially if it is using a symbolic position, allows to specify the distance to keep from the target. If neither 'location:' or 'distance:' is defined, the default distance is the maximum between the width and the height of the worlddynamic (boolean): If true, the location, distance and target are automatically recomputed every step. Default is false. When true, will also set 'locked' to true, to avoid interferences from userslens (any type in [float, int]): Allows to define the lens -- field of view in degrees -- of the camera. Between 0 and 360. Defaults to 45°location (any type in [point, string]): Allows to define the location of the camera in the world, i.e. from where it looks at its target. If 'distance:' is specified, the final location is translated on the target-camera axis to respect the distance. Can be a (possibly dynamically computed) point or a symbolic position (#from_above, #from_left, #from_right, #from_up_right, #from_up_left, #from_front, #from_up_front) that will be dynamically recomputed if the target movesIf 'location:' is not defined, it will be that of the default camera (#from_top, #from_left...) defined in the preferences.locked (boolean): If true, the user cannot modify the camera location and target by interacting with the display. It is automatically set when the camera is dynamic, so that the display can 'follow' the coordinates; but it can also be used with fixed coordinates to 'focus' the display on a specific scenetarget (any type in [point, agent, geometry]): Allows to define the target of the camera (what does it look at). It can be a point (in world coordinates), a geometry or an agent, in which case its (possibly dynamic) location it used as the target. This facet can be complemented by 'distance:' and/or 'location:' to specify from where the target is looked at. If 'target:' is not defined, the default target is the centroid of the world shape.  Definition​ camera allows the modeler to define a camera. The display will then be able to choose among the camera defined (either within this statement or globally in GAMA) in a dynamic way. Several preset cameras are provided and accessible in the preferences (to choose the default) or in GAML using the keywords #from_above, #from_left, #from_right, #from_up_right, #from_up_left, #from_front, #from_up_front, #isometric.These cameras are unlocked (so that they can be manipulated by the user), look at the center of the world from a symbolic position, and the distance between this position and the target is equal to the maximum of the width and height of the world's shape. These preset cameras can be reused when defining new cameras, since their names can become symbolic positions for them. For instance: camera 'my_camera' location: #from_top distance: 10; will lower (or extend) the distance between the camera and the center of the world to 10. camera 'my_camera' locked: true location: #from_up_front target: people(0); will continuously follow the first agent of the people species from the up-front position. Usages​ See also: display, agents, chart, event, graphics, display_grid, image, display_population,  Embedments​ The camera statement is of type: LayerThe camera statement can be embedded into: display, The camera statement embeds statements:   "},{"title":"capture​","type":1,"pageTitle":"Statements","url":"wiki/Statements#capture","content":"Facets​ target (any type in [agent, container]), (omissible) : an expression that is evaluated as an agent or a list of the agent to be capturedas (species): the species that the captured agent(s) will become, this is a micro-species of the calling agent's speciesreturns (a new identifier): a list of the newly captured agent(s)  Definition​ Allows an agent to capture other agent(s) as its micro-agent(s). Usages​ The preliminary for an agent A to capture an agent B as its micro-agent is that the A's species must defined a micro-species which is a sub-species of B's species (cf. [Species161#Nesting_species Nesting species]). species A { ... } species B { ... species C parent: A { ... } ... }  To capture all &quot;A&quot; agents as &quot;C&quot; agents, we can ask an &quot;B&quot; agent to execute the following statement: capture list(B) as: C;  Deprecated writing: capture target: list (B) as: C;  See also: release,  Embedments​ The capture statement is of type: Sequence of statements or actionThe capture statement can be embedded into: Behavior, Sequence of statements or action, The capture statement embeds statements:   "},{"title":"catch​","type":1,"pageTitle":"Statements","url":"wiki/Statements#catch","content":"Facets​ Definition​ This statement cannot be used alone Usages​ See also: try,  Embedments​ The catch statement is of type: Sequence of statements or actionThe catch statement can be embedded into: try, The catch statement embeds statements:   "},{"title":"chart​","type":1,"pageTitle":"Statements","url":"wiki/Statements#chart","content":"Facets​ name (string), (omissible) : the identifier of the chart layeraxes (rgb): the axis colorbackground (rgb): the background colorcolor (rgb): Text colorgap (float): minimum gap between bars (in proportion)label_background_color (rgb): Color of the label background (for Pie chart)label_font (any type in [string, font]): Label font face. Either the name of a font face or a fontlabel_text_color (rgb): Color of the label text (for Pie chart)legend_font (any type in [string, font]): Legend font face. Either the name of a font face or a fontmemorize (boolean): Whether or not to keep the values in memory (in order to produce a csv file, for instance). The default value, true, can also be changed in the preferencesposition (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.reverse_axes (boolean): reverse X and Y axis (for example to get horizental bar chartsseries_label_position (an identifier), takes values in: {default, none, legend, onchart, yaxis, xaxis}: Position of the Series names: default (best guess), none, legend, onchart, xaxis (for category plots) or yaxis (uses the first serie name).size (point): the layer resize factor: {1,1} refers to the original size whereas {0.5,0.5} divides by 2 the height and the width of the layer. In case of a 3D layer, a 3D point can be used (note that {1,1} is equivalent to {1,1,0}, so a resize of a layer containing 3D objects with a 2D points will remove the elevation)style (an identifier), takes values in: {line, whisker, area, bar, dot, step, spline, stack, 3d, ring, exploded, default}: The sub-style style, also default style for the series.tick_font (any type in [string, font]): Tick font face. Either the name of a font face or a font. When used for a series chart, it will set the font of values on the axes, but When used with a pie, it will modify the font of messages associated to each pie section.tick_line_color (rgb): the tick lines colortitle_font (any type in [string, font]): Title font face. Either the name of a font face or a fonttitle_visible (boolean): chart title visibletype (an identifier), takes values in: {xy, scatter, histogram, series, pie, radar, heatmap, box_whisker}: the type of chart. It could be histogram, series, xy, pie, radar, heatmap or box whisker. The difference between series and xy is that the former adds an implicit x-axis that refers to the numbers of cycles, while the latter considers the first declaration of data to be its x-axis.x_label (string): the title for the X axisx_log_scale (boolean): use Log Scale for X axisx_range (any type in [float, int, point, list]): range of the x-axis. Can be a number (which will set the axis total range) or a point (which will set the min and max of the axis).x_serie (any type in [list, float, int]): for series charts, change the default common x serie (simulation cycle) for an other value (list or numerical).x_serie_labels (any type in [list, float, int, a label]): change the default common x series labels (replace x value or categories) for an other value (string or numerical).x_tick_line_visible (boolean): X tick line visiblex_tick_unit (float): the tick unit for the y-axis (distance between horyzontal lines and values on the left of the axis).x_tick_values_visible (boolean): X tick values visibley_label (string): the title for the Y axisy_log_scale (boolean): use Log Scale for Y axisy_range (any type in [float, int, point, list]): range of the y-axis. Can be a number (which will set the axis total range) or a point (which will set the min and max of the axis).y_serie_labels (any type in [list, float, int, a label]): for heatmaps/3d charts, change the default y serie for an other value (string or numerical in a list or cumulative).y_tick_line_visible (boolean): Y tick line visibley_tick_unit (float): the tick unit for the x-axis (distance between vertical lines and values bellow the axis).y_tick_values_visible (boolean): Y tick values visibley2_label (string): the title for the second Y axisy2_log_scale (boolean): use Log Scale for second Y axisy2_range (any type in [float, int, point, list]): range of the second y-axis. Can be a number (which will set the axis total range) or a point (which will set the min and max of the axis).y2_tick_unit (float): the tick unit for the x-axis (distance between vertical lines and values bellow the axis).  Definition​ chart allows modeler to display a chart: this enables to display specific values of the model at each iteration. GAMA can display various chart types: time series (series), pie charts (pie) and histograms (histogram). Usages​ The general syntax is: display chart_display { chart &quot;chart name&quot; type: series [additional options] { [Set of data, datalists statements] } }  See also: display, agents, event, graphics, display_grid, image, overlay, quadtree, display_population, text,  Embedments​ The chart statement is of type: LayerThe chart statement can be embedded into: display, The chart statement embeds statements: add, ask, data, datalist, do, put, remove, set, simulate, using,   "},{"title":"conscious_contagion​","type":1,"pageTitle":"Statements","url":"wiki/Statements#conscious_contagion","content":"Facets​ emotion_created (emotion): the emotion that will be created with the contagion emotion_detected (emotion): the emotion that will start the contagionname (an identifier), (omissible) : the identifier of the unconscious contagioncharisma (float): The charisma value of the perceived agent (between 0 and 1)decay (float): The decay value of the emotion added to the agentintensity (float): The intensity value of the emotion added to the agentreceptivity (float): The receptivity value of the current agent (between 0 and 1)threshold (float): The threshold value to make the contagionwhen (boolean): A boolean value to get the emotion only with a certain condition  Definition​ enables to directly add an emotion of a perceived specie if the perceived agent ges a patricular emotion. Usages​ Other examples of use:   conscious_contagion emotion_detected:fear emotion_created:fearConfirmed; conscious_contagion emotion_detected:fear emotion_created:fearConfirmed charisma: 0.5 receptivity: 0.5;  Embedments​ The conscious_contagion statement is of type: Single statementThe conscious_contagion statement can be embedded into: Behavior, Sequence of statements or action, The conscious_contagion statement embeds statements:   "},{"title":"coping​","type":1,"pageTitle":"Statements","url":"wiki/Statements#coping","content":"Facets​ name (an identifier), (omissible) : The name of the rulebelief (predicate): The mandatory beliefbeliefs (list): The mandatory beliefsdesire (predicate): The mandatory desiredesires (list): The mandatory desiresemotion (emotion): The mandatory emotionemotions (list): The mandatory emotionsideal (predicate): The mandatory idealideals (list): The mandatory idealslifetime (int): the lifetime value of the mental state creatednew_belief (predicate): The belief that will be addednew_beliefs (list): The belief that will be addednew_desire (predicate): The desire that will be addednew_desires (list): The desire that will be addednew_emotion (emotion): The emotion that will be addednew_emotions (list): The emotion that will be addednew_ideal (predicate): The ideal that will be addednew_ideals (list): The ideals that will be addednew_uncertainties (list): The uncertainty that will be addednew_uncertainty (predicate): The uncertainty that will be addedobligation (predicate): The mandatory obligationobligations (list): The mandatory obligationsparallel (any type in [boolean, int]): setting this facet to 'true' will allow 'perceive' to use concurrency with a parallel_bdi architecture; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet is true by default.remove_belief (predicate): The belief that will be removedremove_beliefs (list): The belief that will be removedremove_desire (predicate): The desire that will be removedremove_desires (list): The desire that will be removedremove_emotion (emotion): The emotion that will be removedremove_emotions (list): The emotion that will be removedremove_ideal (predicate): The ideal that will be removedremove_ideals (list): The ideals that will be removedremove_intention (predicate): The intention that will be removedremove_obligation (predicate): The obligation that will be removedremove_obligations (list): The obligation that will be removedremove_uncertainties (list): The uncertainty that will be removedremove_uncertainty (predicate): The uncertainty that will be removedstrength (any type in [float, int]): The stregth of the mental state createdthreshold (float): Threshold linked to the emotion.uncertainties (list): The mandatory uncertaintiesuncertainty (predicate): The mandatory uncertaintywhen (boolean):  Definition​ enables to add or remove mantal states depending on the emotions of the agent, after the emotional engine and before the cognitive or normative engine. Usages​ Other examples of use:   coping emotion: new_emotion(&quot;fear&quot;) when: flip(0.5) new_desire: new_predicate(&quot;test&quot;)  Embedments​ The coping statement is of type: BehaviorThe coping statement can be embedded into: simple_bdi, parallel_bdi, Species, Model, The coping statement embeds statements:   "},{"title":"create​","type":1,"pageTitle":"Statements","url":"wiki/Statements#create","content":"Facets​ species (any type in [species, agent]), (omissible) : an expression that evaluates to a species, the species of the agents to be created. In the case of simulations, the name 'simulation', which represents the current instance of simulation, can also be used as a proxy to their speciesas (species): optionally indicates a species into which to cast the created agents.from (any type): an expression that evaluates to a localized entity, a list of localized entities, a string (the path of a file), a file (shapefile, a .csv, a .asc or a OSM file) or a container returned by a request to a databasenumber (int): an expression that evaluates to an int, the number of created agentsreturns (a new identifier): a new temporary variable name containing the list of created agents (a list, even if only one agent has been created)with (map): an expression that evaluates to a map, for each pair the key is a species attribute and the value the assigned value  Definition​ Allows an agent to create number agents of species species, to create agents of species species from a shapefile or to create agents of species species from one or several localized entities (discretization of the localized entity geometries). Usages​ Its simple syntax to create an_int agents of species a_species is: create a_species number: an_int; create species_of(self) number: 5 returns: list5Agents; 5  In GAML modelers can create agents of species a_species (with two attributes typeandnaturewith types corresponding to the types of the shapefile attributes) from a shapefilethe_shapefile` while reading attributes 'TYPE_OCC' and 'NATURE' of the shapefile. One agent will be created by object contained in the shapefile: create a_species from: the_shapefile with: [type:: read('TYPE_OCC'), nature::read('NATURE')];  In order to create agents from a .csv file, facet header can be used to specified whether we can use columns header: create toto from: &quot;toto.csv&quot; header: true with:[att1::read(&quot;NAME&quot;), att2::read(&quot;TYPE&quot;)]; or create toto from: &quot;toto.csv&quot; with:[att1::read(0), att2::read(1)]; //with read(int), the index of the column  Similarly to the creation from shapefile, modelers can create agents from a set of geometries. In this case, one agent per geometry will be created (with the geometry as shape) create species_of(self) from: [square(4),circle(4)]; // 2 agents have been created, with shapes respectively square(4) and circle(4)  Created agents are initialized following the rules of their species. If one wants to refer to them after the statement is executed, the returns keyword has to be defined: the agents created will then be referred to by the temporary variable it declares. For instance, the following statement creates 0 to 4 agents of the same species as the sender, and puts them in the temporary variable children for later use. create species (self) number: rnd (4) returns: children; ask children { // ... }  If one wants to specify a special initialization sequence for the agents created, create provides the same possibilities as ask. This extended syntax is: create a_species number: an_int { [statements] }  The same rules as in ask apply. The only difference is that, for the agents created, the assignments of variables will bypass the initialization defined in species. For instance: create species(self) number: rnd (4) returns: children { set location &lt;- myself.location + {rnd (2), rnd (2)}; // tells the children to be initially located close to me set parent &lt;- myself; // tells the children that their parent is me (provided the variable parent is declared in this species) }  Deprecated uses:  // Simple syntax create species: a_species number: an_int;  If number equals 0 or species is not a species, the statement is ignored. Embedments​ The create statement is of type: Sequence of statements or actionThe create statement can be embedded into: Behavior, Sequence of statements or action, The create statement embeds statements:   "},{"title":"data​","type":1,"pageTitle":"Statements","url":"wiki/Statements#data","content":"Facets​ legend (string), (omissible) : The legend of the chart value (any type in [float, point, list]): The value to output on the chartaccumulate_values (boolean): Force to replace values at each step (false) or accumulate with previous steps (true)color (any type in [rgb, list]): color of the serie, for heatmap can be a list to specify [minColor,maxColor] or [minColor,medColor,maxColor]fill (boolean): Marker filled (true) or not (false)line_visible (boolean): Whether lines are visible or notmarker (boolean): marker visible or notmarker_shape (an identifier), takes values in: {marker_empty, marker_square, marker_circle, marker_up_triangle, marker_diamond, marker_hor_rectangle, marker_down_triangle, marker_hor_ellipse, marker_right_triangle, marker_vert_rectangle, marker_left_triangle}: Shape of the markermarker_size (float): Size in pixels of the markerstyle (an identifier), takes values in: {line, whisker, area, bar, dot, step, spline, stack, 3d, ring, exploded}: Style for the serie (if not the default one sepecified on chart statement)thickness (float): The thickness of the lines to drawuse_second_y_axis (boolean): Use second y axis for this seriex_err_values (any type in [float, list]): the X Error bar values to display. Has to be a List. Each element can be a number or a list with two values (low and high value)y_err_values (any type in [float, list]): the Y Error bar values to display. Has to be a List. Each element can be a number or a list with two values (low and high value)y_minmax_values (list): the Y MinMax bar values to display (BW charts). Has to be a List. Each element can be a number or a list with two values (low and high value)  Definition​ This statement allows to describe the values that will be displayed on the chart. Usages​ Embedments​ The data statement is of type: Single statementThe data statement can be embedded into: chart, Sequence of statements or action, The data statement embeds statements:   "},{"title":"datalist​","type":1,"pageTitle":"Statements","url":"wiki/Statements#datalist","content":"Facets​ value (list): the values to display. Has to be a matrix, a list or a List of List. Each element can be a number (series/histogram) or a list with two values (XY chart)legend (list), (omissible) : the name of the series: a list of strings (can be a variable with dynamic names)accumulate_values (boolean): Force to replace values at each step (false) or accumulate with previous steps (true)color (list): list of colors, for heatmaps can be a list of [minColor,maxColor] or [minColor,medColor,maxColor]fill (boolean): Marker filled (true) or not (false), same for all series.line_visible (boolean): Line visible or not (same for all series)marker (boolean): marker visible or notmarker_shape (an identifier), takes values in: {marker_empty, marker_square, marker_circle, marker_up_triangle, marker_diamond, marker_hor_rectangle, marker_down_triangle, marker_hor_ellipse, marker_right_triangle, marker_vert_rectangle, marker_left_triangle}: Shape of the marker. Same one for all series.marker_size (list): the marker sizes to display. Can be a list of numbers (same size for each marker of the series) or a list of list (different sizes by point)style (an identifier), takes values in: {line, whisker, area, bar, dot, step, spline, stack, 3d, ring, exploded}: Style for the serie (if not the default one sepecified on chart statement)thickness (float): The thickness of the lines to drawuse_second_y_axis (boolean): Use second y axis for this seriex_err_values (list): the X Error bar values to display. Has to be a List. Each element can be a number or a list with two values (low and high value)y_err_values (list): the Y Error bar values to display. Has to be a List. Each element can be a number or a list with two values (low and high value)y_minmax_values (list): the Y MinMax bar values to display (BW charts). Has to be a List. Each element can be a number or a list with two values (low and high value)  Definition​ add a list of series to a chart. The number of series can be dynamic (the size of the list changes each step). See Ant Foraging (Charts) model in ChartTest for examples. Usages​ Embedments​ The datalist statement is of type: Single statementThe datalist statement can be embedded into: chart, Sequence of statements or action, The datalist statement embeds statements:   "},{"title":"default​","type":1,"pageTitle":"Statements","url":"wiki/Statements#default","content":"Facets​ value (any type), (omissible) : The value or values this statement tries to match  Definition​ Used in a switch match structure, the block prefixed by default is executed only if no other block has matched (otherwise it is not). Usages​ See also: switch, match,  Embedments​ The default statement is of type: Sequence of statements or actionThe default statement can be embedded into: switch, The default statement embeds statements:   "},{"title":"diffuse​","type":1,"pageTitle":"Statements","url":"wiki/Statements#diffuse","content":"Facets​ var (an identifier), (omissible) : the variable to be diffused. If diffused over a field, then this name will serve to identify the diffusion on (any type in [species, 31, list]): the list of agents (in general cells of a grid), or a field on which the diffusion will occuravoid_mask (boolean): if true, the value will not be diffused in the masked cells, but will be restitute to the neighboring cells, multiplied by the proportion value (no signal lost). If false, the value will be diffused in the masked cells, but masked cells won't diffuse the value afterward (lost of signal). (default value : false)cycle_length (int): the number of diffusion operation applied in one simulation stepmask (matrix): a matrix that masks the diffusion ( created from an image for instance). The cells corresponding to the values smaller than &quot;-1&quot; in the mask matrix will not diffuse, and the other will diffuse.matrix (matrix): the diffusion matrix (&quot;kernel&quot; or &quot;filter&quot; in image processing). Can have any size, as long as dimensions are odd values.method (an identifier), takes values in: {convolution, dot_product}: the diffusion method. One of 'convolution' or 'dot_product'min (float): if a value is smaller than this value, it will not be diffused. By default, this value is equal to 0.0. This value cannot be smaller than 0.propagation (a label), takes values in: {diffusion, gradient}: represents both the way the signal is propagated and the way to treat multiple propagation of the same signal occurring at once from different places. If propagation equals 'diffusion', the intensity of a signal is shared between its neighbors with respect to 'proportion', 'variation' and the number of neighbors of the environment places (4, 6 or 8). I.e., for a given signal S propagated from place P, the value transmitted to its N neighbors is : S' = (S / N / proportion) - variation. The intensity of S is then diminished by S * proportion on P. In a diffusion, the different signals of the same name see their intensities added to each other on each place. If propagation equals 'gradient', the original intensity is not modified, and each neighbors receives the intensity : S / proportion - variation. If multiple propagation occur at once, only the maximum intensity is kept on each place. If 'propagation' is not defined, it is assumed that it is equal to 'diffusion'.proportion (float): a diffusion rateradius (int): a diffusion radius (in number of cells from the center)variation (float): an absolute value to decrease at each neighbors  Definition​ This statements allows a value to diffuse among a species on agents (generally on a grid) depending on a given diffusion matrix. Usages​ A basic example of diffusion of the variable phero defined in the species cells, given a diffusion matrix math_diff is: matrix&amp;lt;float&gt; math_diff &lt;- matrix([[1/9,1/9,1/9],[1/9,1/9,1/9],[1/9,1/9,1/9]]); diffuse var: phero on: cells matrix: math_diff;  The diffusion can be masked by obstacles, created from a bitmap image: diffuse var: phero on: cells matrix: math_diff mask: mymask;  A convenient way to have an uniform diffusion in a given radius is (which is equivalent to the above diffusion): diffuse var: phero on: cells proportion: 1/9 radius: 1;  Embedments​ The diffuse statement is of type: Single statementThe diffuse statement can be embedded into: Behavior, Sequence of statements or action, The diffuse statement embeds statements:   "},{"title":"display​","type":1,"pageTitle":"Statements","url":"wiki/Statements#display","content":"Facets​ name (a label), (omissible) : the identifier of the displayantialias (boolean): Indicates whether to use advanced antialiasing for the display or not. The default value is the one indicated in the preferences of GAMA ('false' is its factory default). Antialising produces smoother outputs, but comes with a cost in terms of speed and memory used.autosave (any type in [boolean, point, string]): Allows to save this display on disk. This facet accepts bool, point or string values. If it is false or nil, nothing happens. 'true' will save it at a resolution of 500x500 with a standard name (containing the name of the model, display, resolution, cycle and time). A non-nil point will change that resolution. A non-nil string will keep 500x500 and change the filename (if it is not dynamically built, the previous file will be erased). Note that setting autosave to true in a display will synchronize all the displays defined in the experimentaxes (boolean): Allows to enable/disable the drawing of the world shape and the ordinate axes. Default can be configured in Preferencesbackground (rgb): Allows to fill the background of the display with a specific colorcamera (string): Allows to define the name of the camera to use. Default value is 'default'. Accepted values are (1) the name of one of the cameras defined using the 'camera' statement or (2) one of the preset cameras, accessible using constants: #from_above, #from_left, #from_right, #from_up_left, #from_up_right, #from_front, #from_up_front, #isometricfullscreen (any type in [boolean, int]): Indicates, when using a boolean value, whether or not the display should cover the whole screen (default is false). If an integer is passed, specifies also the screen to use: 0 for the primary monitor, 1 for the secondary one, and so on and so forth. If the monitor is not available, the first one is usedkeystone (container): Set the position of the 4 corners of your screen ([topLeft,topRight,botLeft,botRight]), in (x,y) coordinate ( the (0,0) position is the top left corner, while the (1,1) position is the bottom right corner). The default value is : [{0,0},{1,0},{0,1},{1,1}]light (boolean): Allows to enable/disable the light at once. Default is trueorthographic_projection (boolean): Allows to enable/disable the orthographic projection. Default can be configured in Preferencesparent (an identifier): Declares that this display inherits its layers and attributes from the parent display named as the argument. Expects the identifier of the parent display or a string if the name of the parent contains spacesrefresh (boolean): Indicates the condition under which this output should be refreshed (default is true)show_fps (boolean): Allows to enable/disable the drawing of the number of frames per secondsynchronized (boolean): Indicates whether the display should be directly synchronized with the simulationtoolbar (any type in [boolean, rgb]): Indicates whether the top toolbar of the display view should be initially visible or not. If a color is passed, then the background of the toolbar takes this colortype (a label): Allows to use either Java2D (for planar models) or OpenGL (for 3D models) as the rendering subsystemvirtual (boolean): Declaring a display as virtual makes it invisible on screen, and only usable for display inheritancez_far (float): Set the distances to the far depth clipping planes. Must be positive.z_near (float): Set the distances to the near depth clipping planes. Must be positive.  Definition​ A display refers to an independent and mobile part of the interface that can display species, images, texts or charts. Usages​ The general syntax is: display my_display [additional options] { ... }  Each display can include different layers (like in a GIS). display gridWithElevationTriangulated type: opengl ambient_light: 100 { grid cell elevation: true triangulation: true; species people aspect: base; }  Embedments​ The display statement is of type: OutputThe display statement can be embedded into: output, permanent, The display statement embeds statements: agents, camera, chart, display_grid, display_population, event, graphics, image, light, mesh, overlay, rotation,   "},{"title":"display_grid​","type":1,"pageTitle":"Statements","url":"wiki/Statements#display_grid","content":"Facets​ species (species), (omissible) : the species of the agents in the gridborder (rgb): the color to draw lines (borders of cells)elevation (any type in [matrix, float, int, boolean]): Allows to specify the elevation of each cell, if any. Can be a matrix of float (provided it has the same size than the grid), an int or float variable of the grid species, or simply true (in which case, the variable called 'grid_value' is used to compute the elevation of each cell)grayscale (boolean): if true, givse a grey value to each polygon depending on its elevation (false by default)hexagonal (boolean): position (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer. In case of negative value OpenGl will position the layer out of the environment.refresh (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, usefull in case of agents that do not move)rotate (float): Defines the angle of rotation of this layer, in degrees, around the z-axis.selectable (boolean): Indicates whether the agents present on this layer are selectable by the user. Default is truesize (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates &gt; 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in 'position', an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directionssmooth (boolean): Applies a simple convolution (box filter) to smooth out the terrain produced by this field. Does not change the values of course.text (boolean): specify whether the attribute used to compute the elevation is displayed on each cells (false by default)texture (file): Either file containing the texture image to be applied on the grid or, if not specified, the use of the image composed by the colors of the cellstransparency (float): the transparency level of the layer (between 0 -- opaque -- and 1 -- fully transparent)triangulation (boolean): specifies whther the cells will be triangulated: if it is false, they will be displayed as horizontal squares at a given elevation, whereas if it is true, cells will be triangulated and linked to neighbors in order to have a continuous surface (false by default)visible (boolean): Defines whether this layer is visible or notwireframe (boolean): if true displays the grid in wireframe using the lines color  Definition​ display_grid is used using the grid keyword. It allows the modeler to display in an optimized way all cell agents of a grid (i.e. all agents of a species having a grid topology). Usages​ The general syntax is: display my_display { grid ant_grid lines: #black position: { 0.5, 0 } size: {0.5,0.5}; }  To display a grid as a DEM: display my_display { grid cell texture: texture_file text: false triangulation: true elevation: true; }  See also: display, agents, chart, event, graphics, image, overlay, display_population,  Embedments​ The display_grid statement is of type: LayerThe display_grid statement can be embedded into: display, The display_grid statement embeds statements:   "},{"title":"display_population​","type":1,"pageTitle":"Statements","url":"wiki/Statements#display_population","content":"Facets​ species (species), (omissible) : the species to be displayedaspect (an identifier): the name of the aspect that should be used to display the speciesfading (boolean): Used in conjunction with 'trace:', allows to apply a fading effect to the previous traces. Default is falseposition (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer. In case of negative value OpenGl will position the layer out of the environment.refresh (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, usefull in case of agents that do not move)rotate (float): Defines the angle of rotation of this layer, in degrees, around the z-axis.selectable (boolean): Indicates whether the agents present on this layer are selectable by the user. Default is truesize (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates &gt; 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in 'position', an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directionstrace (any type in [boolean, int]): Allows to aggregate the visualization of agents at each timestep on the display. Default is false. If set to an int value, only the last n-th steps will be visualized. If set to true, no limit of timesteps is applied.transparency (float): the transparency level of the layer (between 0 -- opaque -- and 1 -- fully transparent)visible (boolean): Defines whether this layer is visible or not  Definition​ The display_population statement is used using the species keyword. It allows modeler to display all the agent of a given species in the current display. In particular, modeler can choose the aspect used to display them. Usages​ The general syntax is: display my_display { species species_name [additional options]; }  Species can be superposed on the same plan (be careful with the order, the last one will be above all the others): display my_display { species agent1 aspect: base; species agent2 aspect: base; species agent3 aspect: base; }  Each species layer can be placed at a different z value using the opengl display. position:{0,0,0} means the layer will be placed on the ground and position:{0,0,1} means it will be placed at an height equal to the maximum size of the environment. display my_display type: opengl{ species agent1 aspect: base ; species agent2 aspect: base position:{0,0,0.5}; species agent3 aspect: base position:{0,0,1}; }  See also: display, agents, chart, event, graphics, display_grid, image, overlay,  Embedments​ The display_population statement is of type: LayerThe display_population statement can be embedded into: display, display_population, The display_population statement embeds statements: display_population,   "},{"title":"do​","type":1,"pageTitle":"Statements","url":"wiki/Statements#do","content":"Facets​ action (an identifier), (omissible) : the name of an action or a primitiveinternal_function (any type): with (map): a map expression containing the parameters of the action  Definition​ Allows the agent to execute an action or a primitive. For a list of primitives available in every species, see this [BuiltIn161 page]; for the list of primitives defined by the different skills, see this [Skills161 page]. Finally, see this [Species161 page] to know how to declare custom actions. Usages​ The simple syntax (when the action does not expect any argument and the result is not to be kept) is: do name_of_action_or_primitive;  In case the action expects one or more arguments to be passed, they are defined by using facets (enclosed tags or a map are now deprecated): do name_of_action_or_primitive arg1: expression1 arg2: expression2;  In case the result of the action needs to be made available to the agent, the action can be called with the agent calling the action (self when the agent itself calls the action) instead of do; the result should be assigned to a temporary variable: type_returned_by_action result &lt;- self name_of_action_or_primitive [];  In case of an action expecting arguments and returning a value, the following syntax is used: type_returned_by_action result &lt;- self name_of_action_or_primitive [arg1::expression1, arg2::expression2];  Deprecated uses: following uses of the do statement (still accepted) are now deprecated: // Simple syntax: do action: name_of_action_or_primitive; // In case the result of the action needs to be made available to the agent, the `returns` keyword can be defined; the result will then be referred to by the temporary variable declared in this attribute: do name_of_action_or_primitive returns: result; do name_of_action_or_primitive arg1: expression1 arg2: expression2 returns: result; type_returned_by_action result &lt;- name_of_action_or_primitive(self, [arg1::expression1, arg2::expression2]); // In case the result of the action needs to be made available to the agent let result &lt;- name_of_action_or_primitive(self, []); // In case the action expects one or more arguments to be passed, they can also be defined by using enclosed `arg` statements, or the `with` facet with a map of parameters: do name_of_action_or_primitive with: [arg1::expression1, arg2::expression2]; or do name_of_action_or_primitive { arg arg1 value: expression1; arg arg2 value: expression2; ... }  Embedments​ The do statement is of type: Single statementThe do statement can be embedded into: chart, Behavior, Sequence of statements or action, The do statement embeds statements:   "},{"title":"draw​","type":1,"pageTitle":"Statements","url":"wiki/Statements#draw","content":"Facets​ geometry (any type), (omissible) : any type of data (it can be geometry, image, text)anchor (point): Only used when perspective: true in OpenGL. The anchor point of the location with respect to the envelope of the text to draw, can take one of the following values: #center, #top_left, #left_center, #bottom_left, #bottom_center, #bottom_right, #right_center, #top_right, #top_center; or any point between {0,0} (#bottom_left) and {1,1} (#top_right)at (point): location where the shape/text/icon is drawnbegin_arrow (any type in [int, float]): the size of the arrow, located at the beginning of the drawn geometryborder (any type in [rgb, boolean]): if used with a color, represents the color of the geometry border. If set to false, expresses that no border should be drawn. If not set, the borders will be drawn using the color of the geometry.color (any type in [rgb, container]): the color to use to display the object. In case of images, will try to colorize it. You can also pass a list of colors : in that case, each color will be matched to its corresponding vertex.depth (float): (only if the display type is opengl) Add an artificial depth to the geometry previously defined (a line becomes a plan, a circle becomes a cylinder, a square becomes a cube, a polygon becomes a polyhedron with height equal to the depth value). Note: This only works if the geometry is not a pointend_arrow (any type in [int, float]): the size of the arrow, located at the end of the drawn geometryfont (any type in [font, string]): the font used to draw the text, if any. Applying this facet to geometries or images has no effect. You can construct here your font with the operator &quot;font&quot;. ex : font:font(&quot;Helvetica&quot;, 20 , #plain)lighted (boolean): Whether the object should be lighted or not (only applicable in the context of opengl displays)material (material): Set a particular material to the object (only if you use it in an &quot;opengl2&quot; display).perspective (boolean): Whether to render the text in perspective or facing the user. Default is true.precision (float): (only if the display type is opengl and only for text drawing) controls the accuracy with which curves are rendered in glyphs. Between 0 and 1, the default is 0.1. Smaller values will output much more faithful curves but can be considerably slower, so it is better if they concern text that does not change and can be drawn inside layers marked as 'refresh: false'rotate (any type in [float, int, pair]): orientation of the shape/text/icon; can be either an int/float (angle) or a pair float::point (angle::rotation axis). The rotation axis, when expressed as an angle, is by defaut {0,0,1}size (any type in [float, point]): Size of the shape/icon/image to draw, expressed as a bounding box (width, height, depth; if expressed as a float, represents the box as a cube). Does not apply to texts: use a font with the required size insteadtexture (any type in [string, list, file]): the texture(s) that should be applied to the geometry. Either a path to a file or a list of pathswidth (float): The line width to use for drawing this objectwireframe (boolean): a condition specifying whether to draw the geometry in wireframe or not  Definition​ draw is used in an aspect block to express how agents of the species will be drawn. It is evaluated each time the agent has to be drawn. It can also be used in the graphics block. Usages​ Any kind of geometry as any location can be drawn when displaying an agent (independently of his shape) aspect geometryAspect { draw circle(1.0) empty: !hasFood color: #orange ; }  Image or text can also be drawn aspect arrowAspect { draw &quot;Current state= &quot;+state at: location + {-3,1.5} color: #white font: font('Default', 12, #bold) ; draw file(ant_shape_full) rotate: heading at: location size: 5 }  Arrows can be drawn with any kind of geometry, using begin_arrow and end_arrow facets, combined with the empty: facet to specify whether it is plain or empty aspect arrowAspect { draw line([{20, 20}, {40, 40}]) color: #black begin_arrow:5; draw line([{10, 10},{20, 50}, {40, 70}]) color: #green end_arrow: 2 begin_arrow: 2 empty: true; draw square(10) at: {80,20} color: #purple begin_arrow: 2 empty: true; }  Embedments​ The draw statement is of type: Single statementThe draw statement can be embedded into: aspect, Sequence of statements or action, Layer, The draw statement embeds statements:   "},{"title":"else​","type":1,"pageTitle":"Statements","url":"wiki/Statements#else","content":"Facets​ Definition​ This statement cannot be used alone Usages​ See also: if,  Embedments​ The else statement is of type: Sequence of statements or actionThe else statement can be embedded into: if, The else statement embeds statements:   "},{"title":"emotional_contagion​","type":1,"pageTitle":"Statements","url":"wiki/Statements#emotional_contagion","content":"Facets​ emotion_detected (emotion): the emotion that will start the contagionname (an identifier), (omissible) : the identifier of the emotional contagioncharisma (float): The charisma value of the perceived agent (between 0 and 1)decay (float): The decay value of the emotion added to the agentemotion_created (emotion): the emotion that will be created with the contagionintensity (float): The intensity value of the emotion created to the agentreceptivity (float): The receptivity value of the current agent (between 0 and 1)threshold (float): The threshold value to make the contagionwhen (boolean): A boolean value to get the emotion only with a certain condition  Definition​ enables to make conscious or unconscious emotional contagion Usages​ Other examples of use:   emotional_contagion emotion_detected:fearConfirmed; emotional_contagion emotion_detected:fear emotion_created:fearConfirmed; emotional_contagion emotion_detected:fear emotion_created:fearConfirmed charisma: 0.5 receptivity: 0.5;  Embedments​ The emotional_contagion statement is of type: Single statementThe emotional_contagion statement can be embedded into: Behavior, Sequence of statements or action, The emotional_contagion statement embeds statements:   "},{"title":"enforcement​","type":1,"pageTitle":"Statements","url":"wiki/Statements#enforcement","content":"Facets​ name (an identifier), (omissible) : the identifier of the enforcementlaw (string): The law to enforcenorm (string): The norm to enforceobligation (predicate): The obligation to enforcereward (string): The positive sanction to apply if the norm has been followedsanction (string): The sanction to apply if the norm is violatedwhen (boolean): A boolean value to enforce only with a certain condition  Definition​ applay a sanction if the norm specified is violated, or a reward if the norm is applied by the perceived agent Usages​ Other examples of use:   focus var:speed /*where speed is a variable from a species that is being perceived*/  Embedments​ The enforcement statement is of type: Single statementThe enforcement statement can be embedded into: Behavior, Sequence of statements or action, The enforcement statement embeds statements:   "},{"title":"enter​","type":1,"pageTitle":"Statements","url":"wiki/Statements#enter","content":"Facets​ Definition​ In an FSM architecture, enter introduces a sequence of statements to execute upon entering a state. Usages​ In the following example, at the step it enters into the state s_init, the message 'Enter in s_init' is displayed followed by the display of the state name:  state s_init { enter { write &quot;Enter in&quot; + state; } write &quot;Enter in&quot; + state; } write state; }  See also: state, exit, transition,  Embedments​ The enter statement is of type: Sequence of statements or actionThe enter statement can be embedded into: state, The enter statement embeds statements:   "},{"title":"equation​","type":1,"pageTitle":"Statements","url":"wiki/Statements#equation","content":"Facets​ name (an identifier), (omissible) : the equation identifierparams (list): the list of parameters used in predefined equation systemssimultaneously (list): a list of species containing a system of equations (all systems will be solved simultaneously)vars (list): the list of variables used in predefined equation systems  Definition​ The equation statement is used to create an equation system from several single equations. Usages​ The basic syntax to define an equation system is: float t; float S; float I; equation SI { diff(S,t) = (- 0.3 * S * I / 100); diff(I,t) = (0.3 * S * I / 100); }  If the type: facet is used, a predefined equation system is defined using variables vars: and parameters params: in the right order. All possible predefined equation systems are the following ones (see [EquationPresentation161 EquationPresentation161] for precise definition of each classical equation system):  equation eqSI type: SI vars: [S,I,t] params: [N,beta]; equation eqSIS type: SIS vars: [S,I,t] params: [N,beta,gamma]; equation eqSIR type:SIR vars:[S,I,R,t] params:[N,beta,gamma]; equation eqSIRS type: SIRS vars: [S,I,R,t] params: [N,beta,gamma,omega,mu]; equation eqSEIR type: SEIR vars: [S,E,I,R,t] params: [N,beta,gamma,sigma,mu]; equation eqLV type: LV vars: [x,y,t] params: [alpha,beta,delta,gamma] ;  If the simultaneously: facet is used, system of all the agents will be solved simultaneously. See also: =, solve,  Embedments​ The equation statement is of type: Sequence of statements or actionThe equation statement can be embedded into: Species, Model, The equation statement embeds statements: =,   "},{"title":"error​","type":1,"pageTitle":"Statements","url":"wiki/Statements#error","content":"Facets​ message (string), (omissible) : the message to display in the error.  Definition​ The statement makes the agent output an error dialog (if the simulation contains a user interface). Otherwise displays the error in the console. Usages​ Throwing an error error 'This is an error raised by ' + self;  Embedments​ The error statement is of type: Single statementThe error statement can be embedded into: Behavior, Sequence of statements or action, Layer, The error statement embeds statements:   "},{"title":"event​","type":1,"pageTitle":"Statements","url":"wiki/Statements#event","content":"Facets​ name (an identifier), (omissible) : the type of event captured: can be &quot;mouse_up&quot;, &quot;mouse_down&quot;, &quot;mouse_move&quot;, &quot;mouse_exit&quot;, &quot;mouse_enter&quot;, &quot;mouse_menu&quot; or a characteraction (action): The identifier of the action to be executed in the context of the simulation. This action needs to be defined in 'global' or in the current experiment, without any arguments. The location of the mouse in the world can be retrieved in this action with the pseudo-constant #user_locationtype (string): Type of peripheric used to generate events. Defaults to 'default', which encompasses keyboard and mouseunused (an identifier), takes values in: {mouse_up, mouse_down, mouse_move, mouse_enter, mouse_exit, mouse_menu}: an unused facet that serves only for the purpose of declaring the string values  Definition​ event allows to interact with the simulation by capturing mouse or key events and doing an action. The name of this action can be defined with the 'action:' facet, in which case the action needs to be defined in 'global' or in the current experiment, without any arguments. The location of the mouse in the world can be retrieved in this action with the pseudo-constant #user_location. The statements to execute can also be defined in the block at the end of this statement, in which case they will be executed in the context of the experiment Usages​ The general syntax is: event [event_type] action: myAction;  For instance: global { // ... action myAction () { point loc &lt;- #user_location; // contains the location of the mouse in the world list&amp;lt;agent&gt; selected_agents &lt;- agents inside (10#m around loc); // contains agents clicked by the event // code written by modelers } } experiment Simple type:gui { display my_display { event mouse_up action: myAction; } }  See also: display, agents, chart, graphics, display_grid, image, overlay, display_population,  Embedments​ The event statement is of type: LayerThe event statement can be embedded into: display, The event statement embeds statements:   "},{"title":"exhaustive​","type":1,"pageTitle":"Statements","url":"wiki/Statements#exhaustive","content":"Facets​ name (an identifier), (omissible) : The name of the method. For internal use only  Definition​ This is the standard batch method. The exhaustive mode is defined by default when there is no method element present in the batch section. It explores all the combination of parameter values in a sequential way. See [batch161 the batch dedicated page]. Usages​ As other batch methods, the basic syntax of the exhaustive statement uses method exhaustive instead of the expected exhaustive name: id :  method exhaustive [facet: value];  For example:  method exhaustive maximize: food_gathered;  Embedments​ The exhaustive statement is of type: Batch methodThe exhaustive statement can be embedded into: Experiment, The exhaustive statement embeds statements:   "},{"title":"exit​","type":1,"pageTitle":"Statements","url":"wiki/Statements#exit","content":"Facets​ Definition​ In an FSM architecture, exit introduces a sequence of statements to execute right before exiting the state. Usages​ In the following example, at the state it leaves the state s_init, he will display the message 'EXIT from s_init':  state s_init initial: true { write state; transition to: s1 when: (cycle &gt; 2) { write &quot;transition s_init -&gt; s1&quot;; } exit { write &quot;EXIT from &quot;+state; } }  See also: enter, state, transition,  Embedments​ The exit statement is of type: Sequence of statements or actionThe exit statement can be embedded into: state, The exit statement embeds statements:   "},{"title":"experiment​","type":1,"pageTitle":"Statements","url":"wiki/Statements#experiment","content":"Facets​ name (a label), (omissible) : identifier of the experiment title (a label): type (a label), takes values in: {batch, memorize, gui, test, headless}: the type of the experiment (either 'gui' or 'batch'autorun (boolean): whether this experiment should be run automatically when launched (false by default)benchmark (boolean): If true, make GAMA record the number of invocations and running time of the statements and operators of the simulations launched in this experiment. The results are automatically saved in a csv file in a folder called 'benchmarks' when the experiment is closedcontrol (an identifier): frequency (int): the execution frequence of the experiment (default value: 1). If frequency: 10, the experiment is executed only each 10 steps.keep_seed (boolean): Allows to keep the same seed between simulations. Mainly useful for batch experimentskeep_simulations (boolean): In the case of a batch experiment, specifies whether or not the simulations should be kept in memory for further analysis or immediately discarded with only their fitness kept in memoryparallel (any type in [boolean, int]): When set to true, use multiple threads to run its simulations. Setting it to n will set the numbers of threads to useparent (an identifier): the parent experiment (in case of inheritance between experiments)repeat (int): In the case of a batch experiment, expresses hom many times the simulations must be repeatedschedules (container): A container of agents (a species, a dynamic list, or a combination of species and containers) , which represents which agents will be actually scheduled when the population is scheduled for execution. For instance, 'species a schedules: (10 among a)' will result in a population that schedules only 10 of its own agents every cycle. 'species b schedules: []' will prevent the agents of 'b' to be scheduled. Note that the scope of agents covered here can be larger than the population, which allows to build complex scheduling controls; for instance, defining 'global schedules: [] {...} species b schedules: []; species c schedules: b + world; ' allows to simulate a model where the agents of b are scheduled first, followed by the world, without even having to create an instance of c.skills (list): until (boolean): In the case of a batch experiment, an expression that will be evaluated to know when a simulation should be terminatedvirtual (boolean): whether the experiment is virtual (cannot be instantiated, but only used as a parent, false by default)  Definition​ Declaration of a particular type of agent that can manage simulations. If the experiment directly imports a model using the 'model:' facet, this facet must be the first one after the name of the experiment Usages​ Embedments​ The experiment statement is of type: ExperimentThe experiment statement can be embedded into: Model, The experiment statement embeds statements:   "},{"title":"explicit​","type":1,"pageTitle":"Statements","url":"wiki/Statements#explicit","content":"Facets​ name (an identifier), (omissible) : The name of the method. For internal use only parameter_sets (list): the list of parameter sets to explore; a parameter set is defined by a map: key: name of the variable, value: expression for the value of the variable  Definition​ This algorithm run simulations with the given parameter sets Usages​ As other batch methods, the basic syntax of the explicit statement uses method explicit instead of the expected explicit name: id :  method explicit [facet: value];  For example:  method explicit parameter_sets:[[&quot;a&quot;::0.5, &quot;b&quot;::10],[&quot;a&quot;::0.1, &quot;b&quot;::100]];  Embedments​ The explicit statement is of type: Batch methodThe explicit statement can be embedded into: Experiment, The explicit statement embeds statements:   "},{"title":"focus​","type":1,"pageTitle":"Statements","url":"wiki/Statements#focus","content":"Facets​ agent_cause (agent): the agentCause value of the created belief (can be nilbelief (predicate): The predicate to focus on the beliefs of the other agentdesire (predicate): The predicate to focus on the desires of the other agentemotion (emotion): The emotion to focus on the emotions of the other agentexpression (any type): an expression that will be the value kept in the beliefid (string): the identifier of the focusideal (predicate): The predicate to focus on the ideals of the other agentis_uncertain (boolean): a boolean to indicate if the mental state created is an uncertaintylifetime (int): the lifetime value of the created beliefstrength (any type in [float, int]): The priority of the created predicatetruth (boolean): the truth value of the created beliefuncertainty (predicate): The predicate to focus on the uncertainties of the other agentvar (any type in [any type, list, container]): the variable of the perceived agent you want to add to your beliefswhen (boolean): A boolean value to focus only with a certain condition  Definition​ enables to directly add a belief from the variable of a perceived specie. Usages​ Other examples of use:   focus var:speed /*where speed is a variable from a species that is being perceived*/  Embedments​ The focus statement is of type: Single statementThe focus statement can be embedded into: Behavior, Sequence of statements or action, The focus statement embeds statements:   "},{"title":"focus_on​","type":1,"pageTitle":"Statements","url":"wiki/Statements#focus_on","content":"Facets​ value (any type), (omissible) : The agent, list of agents, geometry to focus on  Definition​ Allows to focus on the passed parameter in all available displays. Passing 'nil' for the parameter will make all screens return to their normal zoom Usages​ Focuses on an agent, a geometry, a set of agents, etc...) focus_on my_species(0);  Embedments​ The focus_on statement is of type: Single statementThe focus_on statement can be embedded into: Behavior, Sequence of statements or action, Layer, The focus_on statement embeds statements:   "},{"title":"generate​","type":1,"pageTitle":"Statements","url":"wiki/Statements#generate","content":"Facets​ attributes (map): To specify the explicit link between agent attributes and file based attributes from (any type): To specify the input data used to inform the generation process. Various data input can be used: list of csv_file: can be aggregated or micro datamatrix: describe the joint distribution of two attributesgenstar generator: a dedicated gaml type to enclose various genstar options all in onespecies (any type in [species, agent]), (omissible) : The species of the agents to be created.generator (string): To specify the type of generator you want to use: as of now there is only DS (or DirectSampling) availablenumber (int): To specify the number of created agents interpreted as an int value. If facet is ommited or value is 0 or less, generator will treat data used in the 'from' facet as contingencies (i.e. a count of entities) and infer a number to generate (if distribution is used, then only one entity will be created  Definition​ Allows to create a synthetic population of agent from a set of given rules Usages​ The synthax to create a minimal synthetic population from aggregated file is: synthesis my_species from: [source_file]; attributes: [age::[&quot;below 18&quot;,&quot;19 to 45&quot;,&quot;more than 46&quot;] synthesis my_species from: my_matrix number: 5 returns: list5Agents;  Embedments​ The generate statement is of type: Sequence of statements or actionThe generate statement can be embedded into: Behavior, Sequence of statements or action, The generate statement embeds statements:   "},{"title":"genetic​","type":1,"pageTitle":"Statements","url":"wiki/Statements#genetic","content":"Facets​ name (an identifier), (omissible) : The name of this method. For internal use onlyaggregation (a label), takes values in: {min, max}: the agregation methodcrossover_prob (float): crossover probability between two individual solutionsimprove_sol (boolean): if true, use a hill climbing algorithm to improve the solutions at each generationmax_gen (int): number of generationsmaximize (float): the value the algorithm tries to maximizeminimize (float): the value the algorithm tries to minimizemutation_prob (float): mutation probability for an individual solutionnb_prelim_gen (int): number of random populations used to build the initial populationpop_dim (int): size of the population (number of individual solutions)stochastic_sel (boolean): if true, use a stochastic selection algorithm (roulette) rather a determistic one (keep the best solutions)  Definition​ This is a simple implementation of Genetic Algorithms (GA). See the wikipedia article and [batch161 the batch dedicated page]. The principle of the GA is to search an optimal solution by applying evolution operators on an initial population of solutions. There are three types of evolution operators: crossover, mutation and selection. Different techniques can be applied for this selection. Most of them are based on the solution quality (fitness). Usages​ As other batch methods, the basic syntax of the genetic statement uses method genetic instead of the expected genetic name: id :  method genetic [facet: value];  For example:  method genetic maximize: food_gathered pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 20;  Embedments​ The genetic statement is of type: Batch methodThe genetic statement can be embedded into: Experiment, The genetic statement embeds statements:   "},{"title":"graphics​","type":1,"pageTitle":"Statements","url":"wiki/Statements#graphics","content":"Facets​ name (a label), (omissible) : the human readable title of the graphicsfading (boolean): Used in conjunction with 'trace:', allows to apply a fading effect to the previous traces. Default is falseposition (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer. In case of negative value OpenGl will position the layer out of the environment.refresh (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, usefull in case of agents that do not move)rotate (float): Defines the angle of rotation of this layer, in degrees, around the z-axis.size (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates &gt; 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in 'position', an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directionstrace (any type in [boolean, int]): Allows to aggregate the visualization at each timestep on the display. Default is false. If set to an int value, only the last n-th steps will be visualized. If set to true, no limit of timesteps is applied.transparency (float): the transparency level of the layer (between 0 -- opaque -- and 1 -- fully transparent)visible (boolean): Defines whether this layer is visible or not  Definition​ graphics allows the modeler to freely draw shapes/geometries/texts without having to define a species. It works exactly like a species [Aspect161 aspect]: the draw statement can be used in the same way. Usages​ The general syntax is: display my_display { graphics &quot;my new layer&quot; { draw circle(5) at: {10,10} color: #red; draw &quot;test&quot; at: {10,10} size: 20 color: #black; } }  See also: display, agents, chart, event, graphics, display_grid, image, overlay, display_population,  Embedments​ The graphics statement is of type: LayerThe graphics statement can be embedded into: display, The graphics statement embeds statements:   "},{"title":"highlight​","type":1,"pageTitle":"Statements","url":"wiki/Statements#highlight","content":"Facets​ value (agent), (omissible) : The agent to hightlightcolor (rgb): An optional color to highlight the agent. Note that this color will become the default color for further higlight operations  Definition​ Allows to highlight the agent passed in parameter in all available displays, optionaly setting a color. Passing 'nil' for the agent will remove the current highlight Usages​ Highlighting an agent highlight my_species(0) color: #blue;  Embedments​ The highlight statement is of type: Single statementThe highlight statement can be embedded into: Behavior, Sequence of statements or action, Layer, The highlight statement embeds statements:   "},{"title":"hill_climbing​","type":1,"pageTitle":"Statements","url":"wiki/Statements#hill_climbing","content":"Facets​ name (an identifier), (omissible) : The name of the method. For internal use onlyaggregation (a label), takes values in: {min, max}: the agregation methodinit_solution (map): init solution: key: name of the variable, value: value of the variableiter_max (int): number of iterationsmaximize (float): the value the algorithm tries to maximizeminimize (float): the value the algorithm tries to minimize  Definition​ This algorithm is an implementation of the Hill Climbing algorithm. See the wikipedia article and [batch161 the batch dedicated page]. Usages​ As other batch methods, the basic syntax of the hill_climbing statement uses method hill_climbing instead of the expected hill_climbing name: id :  method hill_climbing [facet: value];  For example:  method hill_climbing iter_max: 50 maximize : food_gathered;  Embedments​ The hill_climbing statement is of type: Batch methodThe hill_climbing statement can be embedded into: Experiment, The hill_climbing statement embeds statements:   "},{"title":"if​","type":1,"pageTitle":"Statements","url":"wiki/Statements#if","content":"Facets​ condition (boolean), (omissible) : A boolean expression: the condition that is evaluated.  Definition​ Allows the agent to execute a sequence of statements if and only if the condition evaluates to true. Usages​ The generic syntax is: if bool_expr { [statements] }  Optionally, the statements to execute when the condition evaluates to false can be defined in a following statement else. The syntax then becomes: if bool_expr { [statements] } else { [statements] } string valTrue &lt;- &quot;&quot;; if true { valTrue &lt;- &quot;true&quot;; } else { valTrue &lt;- &quot;false&quot;; }//valTrue equals &quot;true&quot; string valFalse &lt;- &quot;&quot;; if false { valFalse &lt;- &quot;true&quot;; } else { valFalse &lt;- &quot;false&quot;; }//valFalse equals &quot;false&quot;  ifs and elses can be imbricated as needed. For instance: if bool_expr { [statements] } else if bool_expr2 { [statements] } else { [statements] }  Embedments​ The if statement is of type: Sequence of statements or actionThe if statement can be embedded into: Behavior, Sequence of statements or action, Layer, Output, The if statement embeds statements: else,   "},{"title":"image​","type":1,"pageTitle":"Statements","url":"wiki/Statements#image","content":"Facets​ name (any type in [string, file]), (omissible) : Human readable title of the image layercolor (rgb): in the case of a shapefile, this the color used to fill in geometries of the shapefile. In the case of an image, it is used to tint the imagefile (any type in [string, file]): the name/path of the image (in the case of a raster image)gis (any type in [file, string]): the name/path of the shape file (to display a shapefile as background, without creating agents from it)position (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer. In case of negative value OpenGl will position the layer out of the environment.refresh (boolean): (openGL only) specify whether the image display is refreshed or not. (false by default, true should be used in cases of images that are modified over the simulation)rotate (float): Defines the angle of rotation of this layer, in degrees, around the z-axis.size (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates &gt; 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in 'position', an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directionstransparency (float): the transparency level of the layer (between 0 -- opaque -- and 1 -- fully transparent)visible (boolean): Defines whether this layer is visible or not  Definition​ image allows modeler to display an image (e.g. as background of a simulation). Note that this image will not be dynamically changed or moved in OpenGL, unless the refresh: facet is set to true. Usages​ The general syntax is: display my_display { image layer_name file: image_file [additional options]; }  For instance, in the case of a bitmap image display my_display { image background file:&quot;../images/my_backgound.jpg&quot;; }  Or in the case of a shapefile: display my_display { image testGIS gis: &quot;../includes/building.shp&quot; color: rgb('blue'); }  It is also possible to superpose images on different layers in the same way as for species using opengl display: display my_display { image image1 file:&quot;../images/image1.jpg&quot;; image image2 file:&quot;../images/image2.jpg&quot;; image image3 file:&quot;../images/image3.jpg&quot; position: {0,0,0.5}; }  See also: display, agents, chart, event, graphics, display_grid, overlay, display_population,  Embedments​ The image statement is of type: LayerThe image statement can be embedded into: display, The image statement embeds statements:   "},{"title":"inspect​","type":1,"pageTitle":"Statements","url":"wiki/Statements#inspect","content":"Facets​ name (any type), (omissible) : the identifier of the inspectorattributes (list): the list of attributes to inspect. A list that can contain strings or pair&lt;string,type&gt;, or a mix of them. These can be variables of the species, but also attributes present in the attributes table of the agent. The type is necessary in that caserefresh (boolean): Indicates the condition under which this output should be refreshed (default is true)type (an identifier), takes values in: {agent, table}: the way to inspect agents: in a table, or a set of inspectorsvalue (any type): the set of agents to inspect, could be a species, a list of agents or an agent  Definition​ inspect (and browse) statements allows modeler to inspect a set of agents, in a table with agents and all their attributes or an agent inspector per agent, depending on the type: chosen. Modeler can choose which attributes to display. When browse is used, type: default value is table, whereas wheninspect is used, type: default value is agent. Usages​ An example of syntax is: inspect &quot;my_inspector&quot; value: ant attributes: [&quot;name&quot;, &quot;location&quot;];  Embedments​ The inspect statement is of type: OutputThe inspect statement can be embedded into: output, permanent, Behavior, Sequence of statements or action, The inspect statement embeds statements:   "},{"title":"law​","type":1,"pageTitle":"Statements","url":"wiki/Statements#law","content":"Facets​ name (an identifier), (omissible) : The name of the lawall (boolean): add an obligation for each beliefbelief (predicate): The mandatory beliefbeliefs (list): The mandatory beliefslifetime (int): the lifetime value of the mental state creatednew_obligation (predicate): The predicate that will be added as an obligationnew_obligations (list): The list of predicates that will be added as obligationsparallel (any type in [boolean, int]): setting this facet to 'true' will allow 'perceive' to use concurrency with a parallel_bdi architecture; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet is true by default.strength (any type in [float, int]): The stregth of the mental state createdthreshold (float): Threshold linked to the obedience value.when (boolean):  Definition​ enables to add a desire or a belief or to remove a belief, a desire or an intention if the agent gets the belief or/and desire or/and condition mentioned. Usages​ Other examples of use:   rule belief: new_predicate(&quot;test&quot;) when: flip(0.5) new_desire: new_predicate(&quot;test&quot;)  Embedments​ The law statement is of type: Single statementThe law statement can be embedded into: Species, Model, The law statement embeds statements:   "},{"title":"layout​","type":1,"pageTitle":"Statements","url":"wiki/Statements#layout","content":"Facets​ value (any type), (omissible) : Either #none, to indicate that no layout will be imposed, or one of the four possible predefined layouts: #stack, #split, #horizontal or #vertical. This layout will be applied to both experiment and simulation display views. In addition, it is possible to define a custom layout using the horizontal() and vertical() operatorsconsoles (boolean): Whether the consoles are visible or not (true by default)controls (boolean): Whether the experiment should show its control toolbar on top or noteditors (boolean): Whether the editors should initially be visible or notnavigator (boolean): Whether the navigator view is visible or not (true by default)parameters (boolean): Whether the parameters view is visible or not (true by default)tabs (boolean): Whether the displays should show their tab or nottoolbars (boolean): Whether the displays should show their toolbar or nottray (boolean): Whether the bottom tray is visible or not (true by default)  Definition​ Represents the layout of the display views of simulations and experiments Usages​ For instance, this layout statement will allow to split the screen occupied by displays in four equal parts, with no tabs. Pairs of display::weight represent the number of the display in their order of definition and their respective weight within a horizontal and vertical section layout horizontal([vertical([0::5000,1::5000])::5000,vertical([2::5000,3::5000])::5000]) tabs: false;  Embedments​ The layout statement is of type: OutputThe layout statement can be embedded into: output, The layout statement embeds statements:   "},{"title":"let​","type":1,"pageTitle":"Statements","url":"wiki/Statements#let","content":"Facets​ name (a new identifier), (omissible) : The name of the variable declaredindex (a datatype identifier): The type of the index if this declaration concerns a containerof (a datatype identifier): The type of the contents if this declaration concerns a containertype (a datatype identifier): The type of the variablevalue (any type): The value assigned to this variable  Definition​ Allows to declare a temporary variable of the specified type and to initialize it with a value Usages​ Embedments​ The let statement is of type: Single statementThe let statement can be embedded into: Behavior, Sequence of statements or action, Layer, The let statement embeds statements:   "},{"title":"light​","type":1,"pageTitle":"Statements","url":"wiki/Statements#light","content":"Facets​ name (string), (omissible) : The name of the light source, must be unique (otherwise the last definition prevails). Will be used to populate a menu where light sources can be easily turned on and off. Special names can be used:Using the special constant #ambient will allow to redefine or control the ambient light intensity and presenceUsing the special constant #default will replace the default directional light of the surrounding displayactive (boolean): a boolean expression telling if the light is on or off. (default value if not specified : true)angle (float): the angle of the spot light in degree (only for spot light). (default value : 45)direction (point): the direction of the light (only for direction and spot light). (default value : {0.5,0.5,-1})dynamic (boolean): specify if the parameters of the light need to be updated every cycle or treated as constants. (default value : true).intensity (any type in [int, rgb]): an int / rgb / rgba value to specify either the color+intensity of the light or simply its intensity. (default value if not specified can be set in the Preferences. If not, it is equal to: (160,160,160,255) ).linear_attenuation (float): the linear attenuation of the positionnal light. (default value : 0)location (point): the location of the light (only for point and spot light) in model coordinates. Default is {0,0,20}quadratic_attenuation (float): the quadratic attenuation of the positionnal light. (default value : 0)show (boolean): If true, draws the light source. (default value if not specified : false).type (string): the type of light to create. A value among {#point, #direction, #spot}  Definition​ light allows to define diffusion lights in your 3D display. They must be given a name, which will help track them in the UI. Two names have however special meanings: #ambient, which designates the ambient luminosity and color of the scene (with a default intensity of (160,160,160,255) or the value set in the Preferences) and #default, which designates the default directional light applied to a scene (with a default medium intensity of (160,160,160,255) or the value set in the Preferences in the direction given by (0.5,0.5,1)). Redefining a light named #ambient or #regular will then modify these default lights (for example changing their color or deactivating them). To be more precise, and given all the default values of the facets, the existence of these two lights is effectively equivalent to redefining:light #ambient intensity: gama.pref_display_light_intensity; light #default type: #direction intensity: gama.pref_display_light_intensity direction: {0.5,0.5,-1}; Usages​ The general syntax is: light 1 type:point location:{20,20,20} color:255, linear_attenuation:0.01 quadratic_attenuation:0.0001 draw_light:true update:false light 'spot1' type: #spot location:{20,20,20} direction:{0,0,-1} color:255 angle:25 linear_attenuation:0.01 quadratic_attenuation:0.0001 draw:true dynamic: false light 'point2' type: #point direction:{1,1,-1} color:255 draw:true dynamic: false  See also: display,  Embedments​ The light statement is of type: LayerThe light statement can be embedded into: display, The light statement embeds statements:   "},{"title":"loop​","type":1,"pageTitle":"Statements","url":"wiki/Statements#loop","content":"Facets​ name (a new identifier), (omissible) : a temporary variable namefrom (int): an int expressionover (any type in [container, point]): a list, point, matrix or map expressionstep (int): an int expressiontimes (int): an int expressionto (int): an int expressionwhile (boolean): a boolean expression  Definition​ Allows the agent to perform the same set of statements either a fixed number of times, or while a condition is true, or by progressing in a collection of elements or along an interval of integers. Be aware that there are no prevention of infinite loops. As a consequence, open loops should be used with caution, as one agent may block the execution of the whole model. Usages​ The basic syntax for repeating a fixed number of times a set of statements is: loop times: an_int_expression { // [statements] }  The basic syntax for repeating a set of statements while a condition holds is: loop while: a_bool_expression { // [statements] }  The basic syntax for repeating a set of statements by progressing over a container of a point is: loop a_temp_var over: a_collection_expression { // [statements] }  The basic syntax for repeating a set of statements while an index iterates over a range of values with a fixed step of 1 is: loop a_temp_var from: int_expression_1 to: int_expression_2 { // [statements] }  The incrementation step of the index can also be chosen: loop a_temp_var from: int_expression_1 to: int_expression_2 step: int_expression3 { // [statements] }  In these latter three cases, the name facet designates the name of a temporary variable, whose scope is the loop, and that takes, in turn, the value of each of the element of the list (or each value in the interval). For example, in the first instance of the &quot;loop over&quot; syntax : int a &lt;- 0; loop i over: [10, 20, 30] { a &lt;- a + i; } // a now equals 60  The second (quite common) case of the loop syntax allows one to use an interval of integers. The from and to facets take an integer expression as arguments, with the first (resp. the last) specifying the beginning (resp. end) of the inclusive interval (i.e. [to, from]). If the step is not defined, it is assumed to be equal to 1 or -1, depending on the direction of the range. If it is defined, its sign will be respected, so that a positive step will never allow the loop to enter a loop from i to j where i is greater than j list the_list &lt;-list (species_of (self)); loop i from: 0 to: length (the_list) - 1 { ask the_list at i { // ... } } // every agent of the list is asked to do something  Embedments​ The loop statement is of type: Sequence of statements or actionThe loop statement can be embedded into: Behavior, Sequence of statements or action, Layer, The loop statement embeds statements:   "},{"title":"match​","type":1,"pageTitle":"Statements","url":"wiki/Statements#match","content":"Facets​ value (any type), (omissible) : The value or values this statement tries to match  Definition​ In a switch...match structure, the value of each match block is compared to the value in the switch. If they match, the embedded statement set is executed. Four kinds of match can be used, equality, containment, betweenness and regex matching Usages​ match block is executed if the switch value is equals to the value of the match: switch 3 { match 1 {write &quot;Match 1&quot;; } match 3 {write &quot;Match 2&quot;; } }  match_between block is executed if the switch value is in the interval given in value of the match_between: switch 3 { match_between [1,2] {write &quot;Match OK between [1,2]&quot;; } match_between [2,5] {write &quot;Match OK between [2,5]&quot;; } }  match_one block is executed if the switch value is equals to one of the values of the match_one: switch 3 { match_one [0,1,2] {write &quot;Match OK with one of [0,1,2]&quot;; } match_between [2,3,4,5] {write &quot;Match OK with one of [2,3,4,5]&quot;; } }  See also: switch, default,  Embedments​ The match statement is of type: Sequence of statements or actionThe match statement can be embedded into: switch, The match statement embeds statements:   "},{"title":"mesh​","type":1,"pageTitle":"Statements","url":"wiki/Statements#mesh","content":"Facets​ source (any type in [file, matrix, species]), (omissible) : Allows to specify the elevation of each cell by passing a grid, a raster, image or csv file or directly a matrix of int/float. The dimensions of the field are those of the file or matrix.border (rgb): the color to draw lines (borders of cells)color (any type in [rgb, list, map]): if true, and if neither 'grayscale' or 'texture' are specified, displays the field using the given color or colors. List of colors, palettes (with interpolation), gradients and scales are supportedgrayscale (boolean): if true, gives a grey color to each polygon depending on its elevation (false by default). Supersedes 'color' if it is defined.no_data (float): Can be used to specify a 'no_data' value, forcing the renderer to not render the cells with this value. If not specified, that value will be searched in the field to displayposition (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.refresh (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, but should be deactivated if the field is static)rotate (float): Defines the angle of rotation of this layer, in degrees, around the z-axis.scale (float): Represents the z-scaling factor, which allows to scale all values of the field.size (any type in [point, float]): Represents the extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates &gt; 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in 'position', an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions. This latter possibility allows to limit the height of the field. If only a flat value is provided, it is considered implicitly as the z maximal amplitude (or z scaling factor if &lt; 1)smooth (any type in [boolean, int]): Applies a simple convolution (box filter) to smooth out the terrain produced by this field. If true, one pass is done with a simple 3x3 kernel. Otherwise, the user can specify the number of successive passes (up to 4). Specifying 0 is equivalent to passing falsetext (boolean): specify whether the value that represents the elevation is displayed on each cell (false by default)texture (file): A file containing the texture image to be applied to the field. If not specified, the field will be displayed either in color or grayscale, depending on the other facetstransparency (float): the transparency level of the layer (between 0 -- opaque -- and 1 -- fully transparent)triangulation (boolean): specifies wether the cells of th field will be triangulated: if it is false, they will be displayed as horizontal squares at a given elevation, whereas if it is true, cells will be triangulated and linked to neighbors in order to have a continuous surface (false by default)visible (boolean): Defines whether this layer is visible or notwireframe (boolean): if true displays the field in wireframe using the lines color  Definition​ Allows the modeler to display in an optimized way a field of values, optionally using elevation. Useful for displaying DEMs, for instance, without having to load them into a grid. Can be fed with a matrix of int/float, a grid, a csv/raster/image file and supports many visualisation options Usages​ The general syntax is: display my_display { field a_filename lines: #black position: { 0.5, 0 } size: {0.5,0.5} triangulated: true texture: anothe_file; }  See also: display, agents, grid, event, graphics, image, overlay, display_population,  Embedments​ The mesh statement is of type: LayerThe mesh statement can be embedded into: display, The mesh statement embeds statements:   "},{"title":"migrate​","type":1,"pageTitle":"Statements","url":"wiki/Statements#migrate","content":"Facets​ source (any type in [agent, species, container, an identifier]), (omissible) : can be an agent, a list of agents, a agent's population to be migrated target (species): target species/population that source agent(s) migrate to.returns (a new identifier): the list of returned agents in a new local variable  Definition​ This command permits agents to migrate from one population/species to another population/species and stay in the same host after the migration. Species of source agents and target species respect the following constraints: (i) they are &quot;peer&quot; species (sharing the same direct macro-species), (ii) they have sub-species vs. parent-species relationship. Usages​ It can be used in a 3-levels model, in case where individual agents can be captured into group meso agents and groups into clouds macro agents. migrate is used to allows agents captured by groups to migrate into clouds. See the model 'Balls, Groups and Clouds.gaml' in the library. migrate ball_in_group target: ball_in_cloud;  See also: capture, release,  Embedments​ The migrate statement is of type: Sequence of statements or actionThe migrate statement can be embedded into: Behavior, Sequence of statements or action, The migrate statement embeds statements:   "},{"title":"monitor​","type":1,"pageTitle":"Statements","url":"wiki/Statements#monitor","content":"Facets​ name (a label), (omissible) : identifier of the monitor value (any type): expression that will be evaluated to be displayed in the monitorcolor (rgb): Indicates the (possibly dynamic) color of this output (default is a light gray)refresh (boolean): Indicates the condition under which this output should be refreshed (default is true)  Definition​ A monitor allows to follow the value of an arbitrary expression in GAML. Usages​ An example of use is: monitor &quot;nb preys&quot; value: length(prey as list) refresh_every: 5;  Embedments​ The monitor statement is of type: OutputThe monitor statement can be embedded into: output, permanent, The monitor statement embeds statements:   "},{"title":"norm​","type":1,"pageTitle":"Statements","url":"wiki/Statements#norm","content":"Facets​ name (an identifier), (omissible) : the name of the normfinished_when (boolean): the boolean condition when the norm is finishedinstantaneous (boolean): indicates if the norm is instananeousintention (predicate): the intention triggering the normlifetime (int): the lifetime of the normobligation (predicate): the obligation triggering of the normpriority (float): the priority value of the normthreshold (float): the threshold to trigger the normwhen (boolean): the boolean condition when the norm is active  Definition​ a norm indicates what action the agent has to do in a certain context and with and obedience value higher than the threshold Usages​ Embedments​ The norm statement is of type: BehaviorThe norm statement can be embedded into: Species, Model, The norm statement embeds statements:   "},{"title":"output​","type":1,"pageTitle":"Statements","url":"wiki/Statements#output","content":"Facets​ autosave (any type in [boolean, string]): Allows to save the whole screen on disk. A value of true/false will save it with the resolution of the physical screen. Passing it a string allows to define the filename Note that setting autosave to true (or to any other value than false) in a display will synchronize all the displays defined in the experiment  Definition​ output blocks define how to visualize a simulation (with one or more display blocks that define separate windows). It will include a set of displays, monitors and files statements. It will be taken into account only if the experiment type is gui. Usages​ Its basic syntax is:  experiment exp_name type: gui { // [inputs] output { // [display, file, inspect, layout or monitor statements] } }  See also: display, monitor, inspect, output_file, layout,  Embedments​ The output statement is of type: OutputThe output statement can be embedded into: Model, Experiment, The output statement embeds statements: display, inspect, layout, monitor, output_file,   "},{"title":"output_file​","type":1,"pageTitle":"Statements","url":"wiki/Statements#output_file","content":"Facets​ name (an identifier), (omissible) : The name of the file where you want to export the data data (string): The data you want to exportfooter (string): Define a footer for your export fileheader (string): Define a header for your export filerefresh (boolean): Indicates the condition under which this file should be saved (default is true)rewrite (boolean): Rewrite or not the existing filetype (an identifier), takes values in: {csv, text, xml}: The type of your output data  Definition​ Represents an output that writes the result of expressions into a file Usages​ Embedments​ The output_file statement is of type: OutputThe output_file statement can be embedded into: output, permanent, The output_file statement embeds statements:   "},{"title":"overlay​","type":1,"pageTitle":"Statements","url":"wiki/Statements#overlay","content":"Facets​ background (rgb): the background color of the overlay displayed inside the view (the bottom overlay remains black)border (rgb): Color to apply to the border of the rectangular shape of the overlay. Nil by defaultcenter (any type): an expression that will be evaluated and displayed in the center section of the bottom overlaycolor (any type in [list, rgb]): the color(s) used to display the expressions given in the 'left', 'center' and 'right' facetsleft (any type): an expression that will be evaluated and displayed in the left section of the bottom overlayposition (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer. In case of negative value OpenGl will position the layer out of the environment.right (any type): an expression that will be evaluated and displayed in the right section of the bottom overlayrounded (boolean): Whether or not the rectangular shape of the overlay should be rounded. True by defaultsize (point): extent of the layer in the view from its position. Coordinates in [0,1[ are treated as percentages of the total surface of the view, while coordinates &gt; 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Unlike 'position', no elevation can be provided with the z coordinatetransparency (float): the transparency rate of the overlay (between 0 -- opaque and 1 -- fully transparent) when it is displayed inside the view. The bottom overlay will remain at 0.75visible (boolean): Defines whether this layer is visible or not  Definition​ overlay allows the modeler to display a line to the already existing bottom overlay, where the results of 'left', 'center' and 'right' facets, when they are defined, are displayed with the corresponding color if defined. Usages​ To display information in the bottom overlay, the syntax is: overlay &quot;Cycle: &quot; + (cycle) center: &quot;Duration: &quot; + total_duration + &quot;ms&quot; right: &quot;Model time: &quot; + as_date(time,&quot;&quot;) color: [#yellow, #orange, #yellow];  See also: display, agents, chart, event, graphics, display_grid, image, display_population,  Embedments​ The overlay statement is of type: LayerThe overlay statement can be embedded into: display, The overlay statement embeds statements:   "},{"title":"parameter​","type":1,"pageTitle":"Statements","url":"wiki/Statements#parameter","content":"Facets​ var (an identifier): the name of the variable (that should be declared in global)name (a label), (omissible) : The message displayed in the interfaceamong (list): the list of possible values that this parameter can takecategory (a label): a category label, used to group parameters in the interfacecolors (list): The colors of the control in the UI. An empty list has no effects. Only used for sliders and switches so far. For sliders, 3 colors will allow to specify the color of the left section, the thumb and the right section (in this order); 2 colors will define the left and right sections only (thumb will be dark green); 1 color will define the left section and the thumb. For switches, 2 colors will define the background for respectively the left 'true' and right 'false' sections. 1 color will define both backgroundsdisables (list): a list of global variables whose parameter editors will be disabled when this parameter value is set to true or to a value that casts to true (they are otherwise enabled)enables (list): a list of global variables whose parameter editors will be enabled when this parameter value is set to true or to a value that casts to true (they are otherwise disabled)extensions (list): Makes only sense for file parameters. A list of file extensions (like 'gaml', 'shp', etc.) that restricts the choice offered to the users to certain file types (folders not concerned). Default is empty, effectively accepting all filesin_workspace (boolean): Makes only sense for file parameters. Whether the file selector will be restricted to the workspace or notinit (any type): the init valuemax (any type): the maximum valuemin (any type): the minimum valueon_change (any type): Provides a block of statements that will be executed whenever the value of the parameter changesslider (boolean): Whether or not to display a slider for entering an int or float value. Default is true when max and min values are defined, false otherwise. If no max or min value is defined, setting this facet to true will have no effectstep (float): the increment step (mainly used in batch mode to express the variation step between simulation)type (a datatype identifier): the variable typeunit (a label): the variable unitupdates (list): a list of global variables whose parameter editors will be updated when this parameter value is changed (their min, max, step and among values will be updated accordingly if they depend on this parameter. Note that it might lead to some inconsistencies, for instance a parameter value which becomes out of range, or which does not belong anymore to a list of possible values. In these cases, the value of the affected parameter will not change)  Definition​ The parameter statement specifies which global attributes (i) will change through the successive simulations (in batch experiments), (ii) can be modified by user via the interface (in gui experiments). In GUI experiments, parameters are displayed depending on their type. Usages​ In gui experiment, the general syntax is the following: parameter title var: global_var category: cat;  In batch experiment, the two following syntaxes can be used to describe the possible values of a parameter: parameter 'Value of toto:' var: toto among: [1, 3, 7, 15, 100]; parameter 'Value of titi:' var: titi min: 1 max: 100 step: 2;  Embedments​ The parameter statement is of type: ParameterThe parameter statement can be embedded into: Experiment, The parameter statement embeds statements:   "},{"title":"perceive​","type":1,"pageTitle":"Statements","url":"wiki/Statements#perceive","content":"Facets​ target (any type in [container, agent]): the list of the agent you want to perceivename (an identifier), (omissible) : the name of the perceptionas (species): an expression that evaluates to a speciesemotion (emotion): The emotion needed to do the perceptionin (any type in [float, geometry]): a float or a geometry. If it is a float, it's a radius of a detection area. If it is a geometry, it is the area of detection of others species.parallel (any type in [boolean, int]): setting this facet to 'true' will allow 'perceive' to use concurrency with a parallel_bdi architecture; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet is true by default.threshold (float): Threshold linked to the emotion.when (boolean): a boolean to tell when does the perceive is active  Definition​ Allow the agent, with a bdi architecture, to perceive others agents Usages​ the basic syntax to perceive agents inside a circle of perception perceive name_of-perception target: the_agents_you_want_to_perceive in: a_distance when: a_certain_condition { Here you are in the context of the perceived agents. To refer to the agent who does the perception, use myself. If you want to make an action (such as adding a belief for example), use ask myself{ do the_action} }  Embedments​ The perceive statement is of type: Sequence of statements or actionThe perceive statement can be embedded into: Species, Model, The perceive statement embeds statements:   "},{"title":"permanent​","type":1,"pageTitle":"Statements","url":"wiki/Statements#permanent","content":"Facets​ tabs (boolean): Whether the displays should show their tab or nottoolbars (boolean): Whether the displays should show their toolbar or not  Definition​ Represents the outputs of the experiment itself. In a batch experiment, the permanent section allows to define an output block that will NOT be re-initialized at the beginning of each simulation but will be filled at the end of each simulation. Usages​ For instance, this permanent section will allow to display for each simulation the end value of the food_gathered variable: permanent { display Ants background: rgb('white') refresh_every: 1 { chart &quot;Food Gathered&quot; type: series { data &quot;Food&quot; value: food_gathered; } } }  Embedments​ The permanent statement is of type: OutputThe permanent statement can be embedded into: Experiment, The permanent statement embeds statements: display, inspect, monitor, output_file,   "},{"title":"plan​","type":1,"pageTitle":"Statements","url":"wiki/Statements#plan","content":"Facets​ name (an identifier), (omissible) : emotion (emotion): finished_when (boolean): instantaneous (boolean): intention (predicate): priority (float): threshold (float): when (boolean):  Definition​ define an action plan performed by an agent using the BDI engine Usages​ Embedments​ The plan statement is of type: BehaviorThe plan statement can be embedded into: Species, Model, The plan statement embeds statements:   "},{"title":"pso​","type":1,"pageTitle":"Statements","url":"wiki/Statements#pso","content":"Facets​ name (an identifier), (omissible) : The name of the method. For internal use only iter_max (int): number of iterationsaggregation (a label), takes values in: {min, max}: the agregation methodmaximize (float): the value the algorithm tries to maximizeminimize (float): the value the algorithm tries to minimizenum_particles (int): number of particlesweight_cognitive (float): weight for the cognitive componentweight_inertia (float): weight for the inertia componentweight_social (float): weight for the social component  Definition​ This algorithm is an implementation of the Particle Swarm Optimization algorithm. Only usable for numerical paramaters and based on a continuous parameter space search. See the wikipedia article for more details. Usages​ As other batch methods, the basic syntax of the pso statement uses method pso instead of the expected pso name: id :  method pso [facet: value];  For example:  method pso iter_max: 50 num_particles: 10 weight_inertia:0.7 weight_cognitive: 1.5 weight_social: 1.5 maximize: food_gathered ;  Embedments​ The pso statement is of type: Batch methodThe pso statement can be embedded into: Experiment, The pso statement embeds statements:   "},{"title":"put​","type":1,"pageTitle":"Statements","url":"wiki/Statements#put","content":"Facets​ in (any type in [container, species, agent, geometry]): an expression that evaluates to a containeritem (any type), (omissible) : any expressionall (any type): any expressionat (any type): any expressionkey (any type): any expression  Definition​ Allows the agent to replace a value in a container at a given position (in a list or a map) or for a given key (in a map). Note that the behavior and the type of the attributes depends on the specific kind of container. Usages​ The allowed parameters configurations are the following ones: put expr at: expr in: expr_container; put all: expr in: expr_container;  In the case of a list, the position should an integer in the bound of the list. The facet all: is used to replace all the elements of the list by the given value. putList &lt;- [1,2,3,4,5]; //putList equals [1,2,3,4,5]put -10 at: 1 in: putList;//putList equals [1,-10,3,4,5]put 10 all: true in: putList;//putList equals [10,10,10,10,10]  In the case of a matrix, the position should be a point in the bound of the matrix. The facet all: is used to replace all the elements of the matrix by the given value. putMatrix &lt;- matrix([[0,1],[2,3]]); //putMatrix equals matrix([[0,1],[2,3]])put -10 at: {1,1} in: putMatrix;//putMatrix equals matrix([[0,1],[2,-10]])put 10 all: true in: putMatrix;//putMatrix equals matrix([[10,10],[10,10]])  In the case of a map, the position should be one of the key values of the map. Notice that if the given key value does not exist in the map, the given pair key::value will be added to the map. The facet all is used to replace the value of all the pairs of the map. putMap &lt;- [&quot;x&quot;::4,&quot;y&quot;::7]; //putMap equals [&quot;x&quot;::4,&quot;y&quot;::7]put -10 key: &quot;y&quot; in: putMap;//putMap equals [&quot;x&quot;::4,&quot;y&quot;::-10]put -20 key: &quot;z&quot; in: putMap;//putMap equals [&quot;x&quot;::4,&quot;y&quot;::-10, &quot;z&quot;::-20]put -30 all: true in: putMap;//putMap equals [&quot;x&quot;::-30,&quot;y&quot;::-30, &quot;z&quot;::-30]  Embedments​ The put statement is of type: Single statementThe put statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer, The put statement embeds statements:   "},{"title":"reactive_tabu​","type":1,"pageTitle":"Statements","url":"wiki/Statements#reactive_tabu","content":"Facets​ name (an identifier), (omissible) : aggregation (a label), takes values in: {min, max}: the agregation methodcycle_size_max (int): minimal size of the considered cyclescycle_size_min (int): maximal size of the considered cyclesinit_solution (map): init solution: key: name of the variable, value: value of the variableiter_max (int): number of iterationsmaximize (float): the value the algorithm tries to maximizeminimize (float): the value the algorithm tries to minimizenb_tests_wthout_col_max (int): number of movements without collision before shortening the tabu listtabu_list_size_init (int): initial size of the tabu listtabu_list_size_max (int): maximal size of the tabu listtabu_list_size_min (int): minimal size of the tabu list  Definition​ This algorithm is a simple implementation of the Reactive Tabu Search algorithm ((Battiti et al., 1993)). This Reactive Tabu Search is an enhance version of the Tabu search. It adds two new elements to the classic Tabu Search. The first one concerns the size of the tabu list: in the Reactive Tabu Search, this one is not constant anymore but it dynamically evolves according to the context. Thus, when the exploration process visits too often the same solutions, the tabu list is extended in order to favor the diversification of the search process. On the other hand, when the process has not visited an already known solution for a high number of iterations, the tabu list is shortened in order to favor the intensification of the search process. The second new element concerns the adding of cycle detection capacities. Thus, when a cycle is detected, the process applies random movements in order to break the cycle. See [batch161 the batch dedicated page]. Usages​ As other batch methods, the basic syntax of the reactive_tabu statement uses method reactive_tabu instead of the expected reactive_tabu name: id :  method reactive_tabu [facet: value];  For example:  method reactive_tabu iter_max: 50 tabu_list_size_init: 5 tabu_list_size_min: 2 tabu_list_size_max: 10 nb_tests_wthout_col_max: 20 cycle_size_min: 2 cycle_size_max: 20 maximize: food_gathered;  Embedments​ The reactive_tabu statement is of type: Batch methodThe reactive_tabu statement can be embedded into: Experiment, The reactive_tabu statement embeds statements:   "},{"title":"reflex​","type":1,"pageTitle":"Statements","url":"wiki/Statements#reflex","content":"Facets​ name (an identifier), (omissible) : the identifier of the reflexwhen (boolean): an expression that evaluates a boolean, the condition to fulfill in order to execute the statements embedded in the reflex.  Definition​ Reflexes are sequences of statements that can be executed by the agent. Reflexes prefixed by the 'reflex' keyword are executed continuously. Reflexes prefixed by 'init' are executed only immediately after the agent has been created. Reflexes prefixed by 'abort' just before the agent is killed. If a facet when: is defined, a reflex is executed only if the boolean expression evaluates to true. Usages​ Example: reflex my_reflex when: flip (0.5){ //Only executed when flip returns true write &quot;Executing the unconditional reflex&quot;; }  Embedments​ The reflex statement is of type: BehaviorThe reflex statement can be embedded into: Species, Experiment, Model, The reflex statement embeds statements:   "},{"title":"release​","type":1,"pageTitle":"Statements","url":"wiki/Statements#release","content":"Facets​ target (any type in [agent, list, attributes]), (omissible) : an expression that is evaluated as an agent/a list of the agents to be released or an agent saved as a mapas (species): an expression that is evaluated as a species in which the micro-agent will be releasedin (agent): an expression that is evaluated as an agent that will be the macro-agent in which micro-agent will be released, i.e. their new hostreturns (a new identifier): a new variable containing a list of the newly released agent(s)  Definition​ Allows an agent to release its micro-agent(s). The preliminary for an agent to release its micro-agents is that species of these micro-agents are sub-species of other species (cf. [Species161#Nesting_species Nesting species]). The released agents won't be micro-agents of the calling agent anymore. Being released from a macro-agent, the micro-agents will change their species and host (macro-agent). Usages​ We consider the following species. Agents of &quot;C&quot; species can be released from a &quot;B&quot; agent to become agents of &quot;A&quot; species. Agents of &quot;D&quot; species cannot be released from the &quot;A&quot; agent because species &quot;D&quot; has no parent species. species A { ... } species B { ... species C parent: A { ... } species D { ... } ... }  To release all &quot;C&quot; agents from a &quot;B&quot; agent, agent &quot;C&quot; has to execute the following statement. The &quot;C&quot; agent will change to &quot;A&quot; agent. The won't consider &quot;B&quot; agent as their macro-agent (host) anymore. Their host (macro-agent) will the be the host (macro-agent) of the &quot;B&quot; agent. release list(C);  The modeler can specify the new host and the new species of the released agents: release list (C) as: new_species in: new host;  See also: capture,  Embedments​ The release statement is of type: Sequence of statements or actionThe release statement can be embedded into: Behavior, Sequence of statements or action, The release statement embeds statements:   "},{"title":"remove​","type":1,"pageTitle":"Statements","url":"wiki/Statements#remove","content":"Facets​ from (any type in [container, species, agent, geometry]): an expression that evaluates to a containeritem (any type), (omissible) : any expression to remove from the containerall (any type): an expression that evaluates to a container. If it is true and if the value a list, it removes the first instance of each element of the list. If it is true and the value is not a container, it will remove all instances of this value.index (any type): any expression, the key at which to remove the element from the containerkey (any type): any expression, the key at which to remove the element from the container  Definition​ Allows the agent to remove an element from a container (a list, matrix, map...). Usages​ This statement should be used in the following ways, depending on the kind of container used and the expected action on it: remove expr from: expr_container; remove index: expr from: expr_container; remove key: expr from: expr_container; remove all: expr from: expr_container;  In the case of list, the facet item: is used to remove the first occurence of a given expression, whereas all is used to remove all the occurrences of the given expression. list&amp;lt;int&gt; removeList &lt;- [3,2,1,2,3];remove 2 from: removeList;//removeList equals [3,1,2,3]remove 3 all: true from: removeList;//removeList equals [1,2]remove index: 1 from: removeList;//removeList equals [1]  In the case of map, the facet key: is used to remove the pair identified by the given key. map&amp;lt;string,int&gt; removeMap &lt;- [&quot;x&quot;::5, &quot;y&quot;::7, &quot;z&quot;::7];remove key: &quot;x&quot; from: removeMap;//removeMap equals [&quot;y&quot;::7, &quot;z&quot;::7]remove 7 all: true from: removeMap;//removeMap equals map([])  In addition, a map a be managed as a list with pair key as index. Given that, facets item:, all: and index: can be used in the same way: map&amp;lt;string,int&gt; removeMapList &lt;- [&quot;x&quot;::5, &quot;y&quot;::7, &quot;z&quot;::7, &quot;t&quot;::5];remove 7 from: removeMapList;//removeMapList equals [&quot;x&quot;::5, &quot;z&quot;::7, &quot;t&quot;::5]remove [5,7] all: true from: removeMapList;//removeMapList equals [&quot;t&quot;::5]remove index: &quot;t&quot; from: removeMapList;//removeMapList equals map([])  In the case of a graph, both edges and nodes can be removes using node: and edge facets. If a node is removed, all edges to and from this node are also removed. graph removeGraph &lt;- as_edge_graph([{1,2}::{3,4},{3,4}::{5,6}]); remove node: {1,2} from: removeGraph; remove node(1,2) from: removeGraph; list var &lt;- removeGraph.vertices; // var equals [{3,4},{5,6}] list var &lt;- removeGraph.edges; // var equals [polyline({3,4}::{5,6})] remove edge: {3,4}::{5,6} from: removeGraph; remove edge({3,4},{5,6}) from: removeGraph; list var &lt;- removeGraph.vertices; // var equals [{3,4},{5,6}] list var &lt;- removeGraph.edges; // var equals []  In the case of an agent or a shape, remove allows to remove an attribute from the attributes map of the receiver. However, for agents, it will only remove attributes that have been added dynamically, not the ones defined in the species or in its built-in parent. global { init { create speciesRemove; speciesRemove sR &lt;- speciesRemove(0); // sR.a now equals 100 remove key:&quot;a&quot; from: sR; // sR.a now equals nil } } species speciesRemove { int a &lt;- 100; }  This statement can not be used on matrix. See also: add, put,  Embedments​ The remove statement is of type: Single statementThe remove statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer, The remove statement embeds statements:   "},{"title":"return​","type":1,"pageTitle":"Statements","url":"wiki/Statements#return","content":"Facets​ value (any type), (omissible) : an expression that is returned  Definition​ Allows to immediately stop and tell which value to return from the evaluation of the surrounding action or top-level statement (reflex, init, etc.). Usually used within the declaration of an action. For more details about actions, see the following [Section161 section]. Usages​ Example: string foo { return &quot;foo&quot;; } reflex { string foo_result &lt;- foo(); // foos_result is now equals to &quot;foo&quot; }  In the specific case one wants an agent to ask another agent to execute a statement with a return, it can be done similarly to: // In Species A: string foo_different { return &quot;foo_not_same&quot;; } /// .... // In Species B: reflex writing { string temp &lt;- some_agent_A.foo_different []; // temp is now equals to &quot;foo_not_same&quot; }  Embedments​ The return statement is of type: Single statementThe return statement can be embedded into: action, Behavior, Sequence of statements or action, The return statement embeds statements:   "},{"title":"rotation​","type":1,"pageTitle":"Statements","url":"wiki/Statements#rotation","content":"Facets​ angle (any type in [float, int]), (omissible) : Defines the angle of rotation around the axis. No default defined.axis (point): The axis of rotation, defined by a vector. Default is {0,0,1} (rotation around the z axis)This facet can be complemented by 'distance:' and/or 'location:' to specify from where the target is looked at. If 'target:' is not defined, the default target is the centroid of the world shape.dynamic (boolean): If true, the rotation is applied every step. Default is false.location (point): Allows to define the center of the rotation. Defaut value is not specified is the center of mass of the world (i.e. {width/2, height/2, max(width, height) / 2})  Definition​ camera allows the modeler to define a camera. The display will then be able to choose among the camera defined (either within this statement or globally in GAMA) in a dynamic way. Several preset cameras are provided and accessible in the preferences (to choose the default) or in GAML using the keywords #from_above, #from_left, #from_right, #from_up_right, #from_up_left, #from_front, #from_up_front.These cameras are unlocked (so that they can be manipulated by the user), look at the center of the world from a symbolic position, and the distance between this position and the target is equal to the maximum of the width and height of the world's shape. These preset cameras can be reused when defining new cameras, since their names can become symbolic positions for them. For instance: camera 'my_camera' location: #from_top distance: 10; will lower (or extend) the distance between the camera and the center of the world to 10. camera 'my_camera' locked: true location: #from_up_front target: people(0); will continuously follow the first agent of the people species from the up-front position. Usages​ See also: display, agents, chart, event, graphics, display_grid, image, display_population,  Embedments​ The rotation statement is of type: LayerThe rotation statement can be embedded into: display, The rotation statement embeds statements:   "},{"title":"rule​","type":1,"pageTitle":"Statements","url":"wiki/Statements#rule","content":"Facets​ name (an identifier), (omissible) : the identifier of the rule when (boolean): The condition to fulfill in order to execute the statements embedded in the rule. when: true makes the rule always activablepriority (float): An optional priority for the rule, which is used to sort activable rules and run them in that order  Definition​ A simple definition of a rule (set of statements which execution depend on a condition and a priority). Usages​ Embedments​ The rule statement is of type: BehaviorThe rule statement can be embedded into: rules, Species, Experiment, Model, The rule statement embeds statements:   "},{"title":"rule​","type":1,"pageTitle":"Statements","url":"wiki/Statements#rule-1","content":"Facets​ name (an identifier), (omissible) : The name of the ruleall (boolean): add a desire for each beliefbelief (predicate): The mandatory beliefbeliefs (list): The mandatory beliefsdesire (predicate): The mandatory desiredesires (list): The mandatory desiresemotion (emotion): The mandatory emotionemotions (list): The mandatory emotionsideal (predicate): The mandatory idealideals (list): The mandatory idealslifetime (any type in [int, list]): the lifetime value of the mental state creatednew_belief (predicate): The belief that will be addednew_beliefs (list): The belief that will be addednew_desire (predicate): The desire that will be addednew_desires (list): The desire that will be addednew_emotion (emotion): The emotion that will be addednew_emotions (list): The emotion that will be addednew_ideal (predicate): The ideal that will be addednew_ideals (list): The ideals that will be addednew_uncertainties (list): The uncertainty that will be addednew_uncertainty (predicate): The uncertainty that will be addedobligation (predicate): The mandatory obligationobligations (list): The mandatory obligationsparallel (any type in [boolean, int]): setting this facet to 'true' will allow 'perceive' to use concurrency with a parallel_bdi architecture; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet is true by default.remove_belief (predicate): The belief that will be removedremove_beliefs (list): The belief that will be removedremove_desire (predicate): The desire that will be removedremove_desires (list): The desire that will be removedremove_emotion (emotion): The emotion that will be removedremove_emotions (list): The emotion that will be removedremove_ideal (predicate): The ideal that will be removedremove_ideals (list): The ideals that will be removedremove_intention (predicate): The intention that will be removedremove_obligation (predicate): The obligation that will be removedremove_obligations (list): The obligation that will be removedremove_uncertainties (list): The uncertainty that will be removedremove_uncertainty (predicate): The uncertainty that will be removedstrength (any type in [float, int, list]): The stregth of the mental state createdthreshold (float): Threshold linked to the emotion.uncertainties (list): The mandatory uncertaintiesuncertainty (predicate): The mandatory uncertaintywhen (boolean):  Definition​ enables to add a desire or a belief or to remove a belief, a desire or an intention if the agent gets the belief or/and desire or/and condition mentioned. Usages​ Embedments​ The rule statement is of type: Single statementThe rule statement can be embedded into: simple_bdi, parallel_bdi, Species, Model, The rule statement embeds statements:   "},{"title":"run​","type":1,"pageTitle":"Statements","url":"wiki/Statements#run","content":"Facets​ name (string), (omissible) : Indicates the name of the experiment to run of (string): Indicates the model containing the experiment to runcore (int): Indicates the number of cores to use to run the experimentsend_cycle (int): Indicates the cycle at which the experiment should stopseed (int): Provides a predetermined seed instead of letting GAMA choose onewith_output (map): with_param (map):  Embedments​ The run statement is of type: Sequence of statements or actionThe run statement can be embedded into: Behavior, Single statement, Species, Model, The run statement embeds statements:   "},{"title":"sanction​","type":1,"pageTitle":"Statements","url":"wiki/Statements#sanction","content":"Facets​ name (an identifier), (omissible) :  Definition​ declare the actions an agent execute when enforcing norms of others during a perception Usages​ Embedments​ The sanction statement is of type: BehaviorThe sanction statement can be embedded into: Species, Model, The sanction statement embeds statements:   "},{"title":"save​","type":1,"pageTitle":"Statements","url":"wiki/Statements#save","content":"Facets​ data (any type), (omissible) : the data that will be saved to the fileattributes (any type in [map, list]): Allows to specify the attributes of a shape file or GeoJson file where agents are saved. Can be expressed as a list of string or as a literal map. When expressed as a list, each value should represent the name of an attribute of the shape or agent. The keys of the map are the names of the attributes that will be present in the file, the values are whatever expressions neeeded to define their value.crs (any type): the name of the projection, e.g. crs:&quot;EPSG:4326&quot; or its EPSG id, e.g. crs:4326. Here a list of the CRS codes (and EPSG id): http://spatialreference.orgheader (boolean): an expression that evaluates to a boolean, specifying whether the save will write a header if the file does not existrewrite (boolean): a boolean expression specifying whether to erase the file if it exists or append data at the end of it. Only applicable to &quot;text&quot; or &quot;csv&quot; files. Default is trueto (string): an expression that evaluates to an string, the path to the file, or directly to a filetype (an identifier), takes values in: {shp, text, csv, asc, geotiff, image, kml, kmz, json, dimacs, dot, gexf, graphml, gml, graph6}: an expression that evaluates to an string, the type of the output file (it can be only &quot;shp&quot;, &quot;asc&quot;, &quot;geotiff&quot;, &quot;image&quot;, &quot;text&quot; or &quot;csv&quot;)  Definition​ Allows to save data in a file. The type of file can be &quot;shp&quot;, &quot;asc&quot;, &quot;geotiff&quot;, &quot;text&quot; or &quot;csv&quot;. Usages​ Its simple syntax is: save data to: output_file type: a_type_file;  To save data in a text file: save (string(cycle) + &quot;-&gt;&quot; + name + &quot;:&quot; + location) to: &quot;save_data.txt&quot; type: &quot;text&quot;;  To save the values of some attributes of the current agent in csv file: save [name, location, host] to: &quot;save_data.csv&quot; type: &quot;csv&quot;;  To save the values of all attributes of all the agents of a species into a csv (with optional attributes): save species_of(self) to: &quot;save_csvfile.csv&quot; type: &quot;csv&quot; header: false;  To save the geometries of all the agents of a species into a shapefile (with optional attributes): save species_of(self) to: &quot;save_shapefile.shp&quot; type: &quot;shp&quot; attributes: ['nameAgent'::name, 'locationAgent'::location] crs: &quot;EPSG:4326&quot;;  To save the grid_value attributes of all the cells of a grid into an ESRI ASCII Raster file: save grid to: &quot;save_grid.asc&quot; type: &quot;asc&quot;;  To save the grid_value attributes of all the cells of a grid into geotiff: save grid to: &quot;save_grid.tif&quot; type: &quot;geotiff&quot;;  To save the grid_value attributes of all the cells of a grid into png (with a worldfile): save grid to: &quot;save_grid.png&quot; type: &quot;image&quot;;  The save statement can be use in an init block, a reflex, an action or in a user command. Do not use it in experiments. Embedments​ The save statement is of type: Single statementThe save statement can be embedded into: Behavior, Sequence of statements or action, The save statement embeds statements:   "},{"title":"set​","type":1,"pageTitle":"Statements","url":"wiki/Statements#set","content":"Facets​ name (any type), (omissible) : the name of an existing variable or attribute to be modified value (any type): the value to affect to the variable or attribute  Definition​ Allows to assign a value to the variable or attribute specified Usages​ Embedments​ The set statement is of type: Single statementThe set statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer, The set statement embeds statements:   "},{"title":"setup​","type":1,"pageTitle":"Statements","url":"wiki/Statements#setup","content":"Facets​ Definition​ The setup statement is used to define the set of instructions that will be executed before every [#test test]. Usages​ As every test should be independent from the others, the setup will mainly contain initialization of variables that will be used in each test. species Tester { int val_to_test; setup { val_to_test &lt;- 0; } test t1 { // [set of instructions, including asserts] } }  See also: test, assert,  Embedments​ The setup statement is of type: Sequence of statements or actionThe setup statement can be embedded into: Species, Experiment, Model, The setup statement embeds statements:   "},{"title":"simulate​","type":1,"pageTitle":"Statements","url":"wiki/Statements#simulate","content":"Facets​ comodel (file), (omissible) : repeat (int): reset (boolean): share (list): until (boolean): with_experiment (string): with_input (map): with_output (map):  Definition​ Allows an agent, the sender agent (that can be the [Sections161#global world agent]), to ask another (or other) agent(s) to perform a set of statements. It obeys the following syntax, where the target attribute denotes the receiver agent(s): Usages​ Other examples of use:   ask receiver_agent(s) { // [statements] }  Embedments​ The simulate statement is of type: Single statementThe simulate statement can be embedded into: chart, Experiment, Species, Behavior, Sequence of statements or action, The simulate statement embeds statements:   "},{"title":"sobol​","type":1,"pageTitle":"Statements","url":"wiki/Statements#sobol","content":"Facets​ name (an identifier), (omissible) : The name of the method. For internal use only outputs (list): The list of output variables to analyse through sobol indexes sample (an identifier): The size of the sample for the sobol sequencereport (string): The path to the file where the Sobol report will be writtenresults (string): The path to the file where the automatic batch report will be written  Definition​ This algorithm runs a Sobol exploration - it has been built upon the moea framework at https://github.com/MOEAFramework/MOEAFramework - disabled the repeat facet of the experiment Usages​ For example:  method sobol sample_size:100 outputs:['my_var'] report:'../path/to/report/file.txt';  Embedments​ The sobol statement is of type: Batch methodThe sobol statement can be embedded into: Experiment, The sobol statement embeds statements:   "},{"title":"socialize​","type":1,"pageTitle":"Statements","url":"wiki/Statements#socialize","content":"Facets​ name (an identifier), (omissible) : the identifier of the socialize statementagent (agent): the agent value of the created social linkdominance (float): the dominance value of the created social linkfamiliarity (float): the familiarity value of the created social linkliking (float): the appreciation value of the created social linksolidarity (float): the solidarity value of the created social linktrust (float): the trust value of the created social linkwhen (boolean): A boolean value to socialize only with a certain condition  Definition​ enables to directly add a social link from a perceived agent. Usages​ Other examples of use:   socialize;  Embedments​ The socialize statement is of type: Single statementThe socialize statement can be embedded into: Behavior, Sequence of statements or action, The socialize statement embeds statements:   "},{"title":"solve​","type":1,"pageTitle":"Statements","url":"wiki/Statements#solve","content":"Facets​ equation (an identifier), (omissible) : the equation system identifier to be numerically solvedmax_step (float): maximal step, (used with dp853 method only), (sign is irrelevant, regardless of integration direction, forward or backward), the last step can be smaller than this valuemethod (string): integration method (can be one of &quot;Euler&quot;, &quot;ThreeEighthes&quot;, &quot;Midpoint&quot;, &quot;Gill&quot;, &quot;Luther&quot;, &quot;rk4&quot; or &quot;dp853&quot;, &quot;AdamsBashforth&quot;, &quot;AdamsMoulton&quot;, &quot;DormandPrince54&quot;, &quot;GraggBulirschStoer&quot;, &quot;HighamHall54&quot;) (default value: &quot;rk4&quot;) or the corresponding constantmin_step (float): minimal step, (used with dp853 method only), (sign is irrelevant, regardless of integration direction, forward or backward), the last step can be smaller than this valuenSteps (float): Adams-Bashforth and Adams-Moulton methods only. The number of past steps used for computation excluding the one being computed (default value: 2scalAbsoluteTolerance (float): allowed absolute error (used with dp853 method only)scalRelativeTolerance (float): allowed relative error (used with dp853 method only)step (float): (deprecated) integration step, use with fixed step integrator methods (default value: 0.005*step)step_size (float): integration step, use with fixed step integrator methods (default value: 0.005*step)t0 (float): the first bound of the integration interval (defaut value: cycle*step, the time at the begining of the current cycle.)tf (float): the second bound of the integration interval. Can be smaller than t0 for a backward integration (defaut value: cycle*step, the time at the begining of the current cycle.)  Definition​ Solves all equations which matched the given name, with all systems of agents that should solved simultaneously. Usages​ Other examples of use:   solve SIR method: #rk4 step:0.001;  Embedments​ The solve statement is of type: Single statementThe solve statement can be embedded into: Behavior, Sequence of statements or action, The solve statement embeds statements:   "},{"title":"species​","type":1,"pageTitle":"Statements","url":"wiki/Statements#species","content":"Facets​ name (an identifier), (omissible) : the identifier of the speciescell_height (float): (grid only), the height of the cells of the gridcell_width (float): (grid only), the width of the cells of the gridcompile (boolean): control (skill): defines the architecture of the species (e.g. fsm...)edge_species (species): In the case of a species defining a graph topology for its instances (nodes of the graph), specifies the species to use for representing the edgesfile (file): (grid only), a bitmap file that will be loaded at runtime so that the value of each pixel can be assigned to the attribute 'grid_value'files (list): (grid only), a list of bitmap file that will be loaded at runtime so that the value of each pixel of each file can be assigned to the attribute 'bands'frequency (int): The execution frequency of the species (default value: 1). For instance, if frequency is set to 10, the population of agents will be executed only every 10 cycles.height (int): (grid only), the height of the grid (in terms of agent number)horizontal_orientation (boolean): (hexagonal grid only),(true by default). Allows use a hexagonal grid with a horizontal or vertical orientation.mirrors (any type in [list, species]): The species this species is mirroring. The population of this current species will be dependent of that of the species mirrored (i.e. agents creation and death are entirely taken in charge by GAMA with respect to the demographics of the species mirrored). In addition, this species is provided with an attribute called 'target', which allows each agent to know which agent of the mirrored species it is representing.neighbors (int): (grid only), the chosen neighborhood (4, 6 or 8)optimizer (string): (grid only),(&quot;A&quot; by default). Allows to specify the algorithm for the shortest path computation (&quot;BF&quot;, &quot;Dijkstra&quot;, &quot;A&quot; or &quot;JPS*&quot;parallel (any type in [boolean, int]): (experimental) setting this facet to 'true' will allow this species to use concurrency when scheduling its agents; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet has a default set in the preferences (Under Performances &gt; Concurrency)parent (species): the parent class (inheritance)schedules (container): A container of agents (a species, a dynamic list, or a combination of species and containers) , which represents which agents will be actually scheduled when the population is scheduled for execution. Note that the world (or the simulation) is always scheduled first, so there is no need to explicitly mention it. Doing so would result in a runtime error. For instance, 'species a schedules: (10 among a)' will result in a population that schedules only 10 of its own agents every cycle. 'species b schedules: []' will prevent the agents of 'b' to be scheduled. Note that the scope of agents covered here can be larger than the population, which allows to build complex scheduling controls; for instance, defining 'global schedules: [] {...} species b schedules: []; species c schedules: b; ' allows to simulate a model where only the world and the agents of b are scheduled, without even having to create an instance of c.skills (list): The list of skills that will be made available to the instances of this species. Each new skill provides attributes and actions that will be added to the ones defined in this speciestopology (topology): The topology of the population of agents defined by this species. In case of nested species, it can for example be the shape of the macro-agent. In case of grid or graph species, the topology is automatically computed and cannot be redefinedtorus (boolean): is the topology toric (defaut: false). Needs to be defined on the global species.use_individual_shapes (boolean): (grid only),(true by default). Allows to specify whether or not the agents of the grid will have distinct geometries. If set to false, they will all have simpler proxy geometriesuse_neighbors_cache (boolean): (grid only),(true by default). Allows to turn on or off the use of the neighbors cache used for grids. Note that if a diffusion of variable occurs, GAMA will emit a warning and automatically switch to a caching versionuse_regular_agents (boolean): (grid only),(true by default). Allows to specify if the agents of the grid are regular agents (like those of any other species) or minimal ones (which can't have sub-populations, can't inherit from a regular species, etc.)virtual (boolean): whether the species is virtual (cannot be instantiated, but only used as a parent) (false by default)width (int): (grid only), the width of the grid (in terms of agent number)  Definition​ The species statement allows modelers to define new species in the model. global and grid are speciel cases of species: global being the definition of the global agent (which has automatically one instance, world) and grid being a species with a grid topology. Usages​ Here is an example of a species definition with a FSM architecture and the additional skill moving: species ant skills: [moving] control: fsm {  In the case of a species aiming at mirroring another one: species node_agent mirrors: list(bug) parent: graph_node edge_species: edge_agent {  The definition of the single grid of a model will automatically create gridwidth x gridheight agents: grid ant_grid width: gridwidth height: gridheight file: grid_file neighbors: 8 use_regular_agents: false {  Using a file to initialize the grid can replace width/height facets: grid ant_grid file: grid_file neighbors: 8 use_regular_agents: false {  Embedments​ The species statement is of type: SpeciesThe species statement can be embedded into: Model, Environment, Species, The species statement embeds statements:   "},{"title":"start_simulation​","type":1,"pageTitle":"Statements","url":"wiki/Statements#start_simulation","content":"Facets​ name (string), (omissible) : The name of the experiment to run of (string): The path to the model containing the experimentseed (int): with_param (map):  Embedments​ The start_simulation statement is of type: Sequence of statements or actionThe start_simulation statement can be embedded into: Behavior, Single statement, Species, Model, The start_simulation statement embeds statements:   "},{"title":"state​","type":1,"pageTitle":"Statements","url":"wiki/Statements#state","content":"Facets​ name (an identifier), (omissible) : the identifier of the statefinal (boolean): specifies whether the state is a final one (i.e. there is no transition from this state to another state) (default value= false)initial (boolean): specifies whether the state is the initial one (default value = false)  Definition​ A state, like a reflex, can contains several statements that can be executed at each time step by the agent. Usages​ Here is an exemple integrating 2 states and the statements in the FSM architecture:  state s_init initial: true { enter { write &quot;Enter in&quot; + state; } write &quot;Enter in&quot; + state; } write state; transition to: s1 when: (cycle &gt; 2) { write &quot;transition s_init -&gt; s1&quot;; } exit { write &quot;EXIT from &quot;+state; } } state s1 { enter {write 'Enter in '+state;} write state; exit {write 'EXIT from '+state;} }  See also: enter, exit, transition,  Embedments​ The state statement is of type: BehaviorThe state statement can be embedded into: fsm, Species, Experiment, Model, The state statement embeds statements: enter, exit,   "},{"title":"status​","type":1,"pageTitle":"Statements","url":"wiki/Statements#status","content":"Facets​ message (any type), (omissible) : Allows to display a necessarily short message in the status box in the upper left corner. No formatting characters (carriage returns, tabs, or Unicode characters) should be used, but a background color can be specified. The message will remain in place until it is replaced by another one or by nil, in which case the standard status (number of cycles) will be displayed againcolor (rgb): The color used for displaying the background of the status message  Definition​ The statement makes the agent output an arbitrary message in the status box. Usages​ Outputting a message status ('This is my status ' + self) color: #yellow;  Embedments​ The status statement is of type: Single statementThe status statement can be embedded into: Behavior, Sequence of statements or action, Layer, The status statement embeds statements:   "},{"title":"switch​","type":1,"pageTitle":"Statements","url":"wiki/Statements#switch","content":"Facets​ value (any type), (omissible) : an expression  Definition​ The &quot;switch... match&quot; statement is a powerful replacement for imbricated &quot;if ... else ...&quot; constructs. All the blocks that match are executed in the order they are defined, unless one invokes 'break', in which case the switch statement is exited. The block prefixed by default is executed only if none have matched (otherwise it is not). Usages​ The prototypical syntax is as follows: switch an_expression { match value1 {...} match_one [value1, value2, value3] {...} match_between [value1, value2] {...} default {...} }  Example: switch 3 { match 1 {write &quot;Match 1&quot;; } match 2 {write &quot;Match 2&quot;; } match 3 {write &quot;Match 3&quot;; } match_one [4,4,6,3,7] {write &quot;Match one_of&quot;; } match_between [2, 4] {write &quot;Match between&quot;; } default {write &quot;Match Default&quot;; } }  See also: match, default, if,  Embedments​ The switch statement is of type: Sequence of statements or actionThe switch statement can be embedded into: Behavior, Sequence of statements or action, Layer, The switch statement embeds statements: default, match,   "},{"title":"tabu​","type":1,"pageTitle":"Statements","url":"wiki/Statements#tabu","content":"Facets​ name (an identifier), (omissible) : The name of the method. For internal use onlyaggregation (a label), takes values in: {min, max}: the agregation methodinit_solution (map): init solution: key: name of the variable, value: value of the variableiter_max (int): number of iterationsmaximize (float): the value the algorithm tries to maximizeminimize (float): the value the algorithm tries to minimizetabu_list_size (int): size of the tabu list  Definition​ This algorithm is an implementation of the Tabu Search algorithm. See the wikipedia article and [batch161 the batch dedicated page]. Usages​ As other batch methods, the basic syntax of the tabu statement uses method tabu instead of the expected tabu name: id :  method tabu [facet: value];  For example:  method tabu iter_max: 50 tabu_list_size: 5 maximize: food_gathered;  Embedments​ The tabu statement is of type: Batch methodThe tabu statement can be embedded into: Experiment, The tabu statement embeds statements:   "},{"title":"task​","type":1,"pageTitle":"Statements","url":"wiki/Statements#task","content":"Facets​ name (an identifier), (omissible) : the identifier of the task weight (float): the priority level of the task  Definition​ As reflex, a task is a sequence of statements that can be executed, at each time step, by the agent. If an agent owns several tasks, the scheduler chooses a task to execute based on its current priority weight value. Usages​ Embedments​ The task statement is of type: BehaviorThe task statement can be embedded into: weighted_tasks, sorted_tasks, probabilistic_tasks, Species, Experiment, Model, The task statement embeds statements:   "},{"title":"test​","type":1,"pageTitle":"Statements","url":"wiki/Statements#test","content":"Facets​ name (an identifier), (omissible) : identifier of the test  Definition​ The test statement allows modeler to define a set of assertions that will be tested. Before the execution of the embedded set of instructions, if a setup is defined in the species, model or experiment, it is executed. In a test, if one assertion fails, the evaluation of other assertions continue. Usages​ An example of use: species Tester { // set of attributes that will be used in test setup { // [set of instructions... in particular initializations] } test t1 { // [set of instructions, including asserts] } }  See also: setup, assert,  Embedments​ The test statement is of type: BehaviorThe test statement can be embedded into: Species, Experiment, Model, The test statement embeds statements: assert,   "},{"title":"text​","type":1,"pageTitle":"Statements","url":"wiki/Statements#text","content":"Facets​ message (any type), (omissible) : the text to display.background (rgb): The color of the background of the textcategory (a label): a category label, used to group parameters in the interfacecolor (rgb): The color with wich the text will be displayedfont (any type in [font, string]): the font used to draw the text, which can be built with the operator &quot;font&quot;. ex : font:font(&quot;Helvetica&quot;, 20 , #bold)  Definition​ The statement makes an experiment display text in the parameters view. Usages​ Embedments​ The text statement is of type: Single statementThe text statement can be embedded into: Experiment, The text statement embeds statements:   "},{"title":"trace​","type":1,"pageTitle":"Statements","url":"wiki/Statements#trace","content":"Facets​ Definition​ All the statements executed in the trace statement are displayed in the console. Usages​ Embedments​ The trace statement is of type: Sequence of statements or actionThe trace statement can be embedded into: Behavior, Sequence of statements or action, Layer, The trace statement embeds statements:   "},{"title":"transition​","type":1,"pageTitle":"Statements","url":"wiki/Statements#transition","content":"Facets​ to (an identifier): the identifier of the next statewhen (boolean), (omissible) : a condition to be fulfilled to have a transition to another given state  Definition​ In an FSM architecture, transition specifies the next state of the life cycle. The transition occurs when the condition is fulfilled. The embedded statements are executed when the transition is triggered. Usages​ In the following example, the transition is executed when after 2 steps:  state s_init initial: true { write state; transition to: s1 when: (cycle &gt; 2) { write &quot;transition s_init -&gt; s1&quot;; } }  See also: enter, state, exit,  Embedments​ The transition statement is of type: Sequence of statements or actionThe transition statement can be embedded into: Sequence of statements or action, Behavior, The transition statement embeds statements:   "},{"title":"try​","type":1,"pageTitle":"Statements","url":"wiki/Statements#try","content":"Facets​ Definition​ Allows the agent to execute a sequence of statements and to catch any runtime error that might happen in a subsequent catch block, either to ignore it (not a good idea, usually) or to safely stop the model Usages​ The generic syntax is: try { [statements] }  Optionally, the statements to execute when a runtime error happens in the block can be defined in a following statement 'catch'. The syntax then becomes: try { [statements] } catch { [statements] }  Embedments​ The try statement is of type: Sequence of statements or actionThe try statement can be embedded into: Behavior, Sequence of statements or action, Layer, The try statement embeds statements: catch,   "},{"title":"unconscious_contagion​","type":1,"pageTitle":"Statements","url":"wiki/Statements#unconscious_contagion","content":"Facets​ emotion (emotion): the emotion that will be copied with the contagionname (an identifier), (omissible) : the identifier of the unconscious contagioncharisma (float): The charisma value of the perceived agent (between 0 and 1)decay (float): The decay value of the emotion added to the agentreceptivity (float): The receptivity value of the current agent (between 0 and 1)threshold (float): The threshold value to make the contagionwhen (boolean): A boolean value to get the emotion only with a certain condition  Definition​ enables to directly copy an emotion presents in the perceived specie. Usages​ Other examples of use:   unconscious_contagion emotion:fearConfirmed; unconscious_contagion emotion:fearConfirmed charisma: 0.5 receptivity: 0.5;  Embedments​ The unconscious_contagion statement is of type: Single statementThe unconscious_contagion statement can be embedded into: Behavior, Sequence of statements or action, The unconscious_contagion statement embeds statements:   "},{"title":"user_command​","type":1,"pageTitle":"Statements","url":"wiki/Statements#user_command","content":"Facets​ name (a label), (omissible) : the identifier of the user_commandaction (action): the identifier of the action to be executed. This action should be accessible in the context in which the user_command is defined (an experiment, the global section or a species). A special case is allowed to maintain the compatibility with older versions of GAMA, when the user_command is declared in an experiment and the action is declared in 'global'. In that case, all the simulations managed by the experiment will run the action in response to the user executing the commandcategory (a label): a category label, used to group parameters in the interfacecolor (rgb): The color of the button to displaycontinue (boolean): Whether or not the button, when clicked, should dismiss the user panel it is defined in. Has no effect in other contexts (menu, parameters, inspectors)when (boolean): the condition that should be fulfilled (in addition to the user clicking it) in order to execute this actionwith (map): the map of the parameters::values required by the action  Definition​ Anywhere in the global block, in a species or in an (GUI) experiment, user_command statements allows to either call directly an existing action (with or without arguments) or to be followed by a block that describes what to do when this command is run. Usages​ The general syntax is for example: user_command kill_myself action: some_action with: [arg1::val1, arg2::val2, ...];  See also: user_init, user_panel, user_input,  Embedments​ The user_command statement is of type: Sequence of statements or actionThe user_command statement can be embedded into: user_panel, Species, Experiment, Model, The user_command statement embeds statements: user_input,   "},{"title":"user_init​","type":1,"pageTitle":"Statements","url":"wiki/Statements#user_init","content":"Facets​ name (an identifier), (omissible) : The name of the panelinitial (boolean): Whether or not this panel will be the initial one  Definition​ Used in the user control architecture, user_init is executed only once when the agent is created. It opens a special panel (if it contains user_commands statements). It is the equivalent to the init block in the basic agent architecture. Usages​ See also: user_command, user_init, user_input,  Embedments​ The user_init statement is of type: BehaviorThe user_init statement can be embedded into: Species, Experiment, Model, The user_init statement embeds statements: user_panel,   "},{"title":"user_input​","type":1,"pageTitle":"Statements","url":"wiki/Statements#user_input","content":"Facets​ init (any type): the init value returns (a new identifier): a new local variable containing the value given by the username (a label), (omissible) : the displayed nameamong (list): the set of acceptable values, only for string inputsmax (float): the maximum valuemin (float): the minimum valueslider (boolean): Whether to display a slider or not when applicabletype (a datatype identifier): the variable type  Definition​ It allows to let the user define the value of a variable. Usages​ Other examples of use:   user_panel &quot;Advanced Control&quot; { user_input &quot;Location&quot; returns: loc type: point &lt;- {0,0}; create cells number: 10 with: [location::loc]; }  See also: user_command, user_init, user_panel,  Embedments​ The user_input statement is of type: Single statementThe user_input statement can be embedded into: user_command, The user_input statement embeds statements:   "},{"title":"user_panel​","type":1,"pageTitle":"Statements","url":"wiki/Statements#user_panel","content":"Facets​ name (an identifier), (omissible) : The name of the panelinitial (boolean): Whether or not this panel will be the initial one  Definition​ It is the basic behavior of the user control architecture (it is similar to state for the FSM architecture). This user_panel translates, in the interface, in a semi-modal view that awaits the user to choose action buttons, change attributes of the controlled agent, etc. Each user_panel, like a state in FSM, can have a enter and exit sections, but it is only defined in terms of a set of user_commands which describe the different action buttons present in the panel. Usages​ The general syntax is for example: user_panel default initial: true { user_input 'Number' returns: number type: int &lt;- 10; ask (number among list(cells)){ do die; } transition to: &quot;Advanced Control&quot; when: every (10); } user_panel &quot;Advanced Control&quot; { user_input &quot;Location&quot; returns: loc type: point &lt;- {0,0}; create cells number: 10 with: [location::loc]; }  See also: user_command, user_init, user_input,  Embedments​ The user_panel statement is of type: BehaviorThe user_panel statement can be embedded into: fsm, user_first, user_last, user_init, user_only, Species, Experiment, Model, The user_panel statement embeds statements: user_command,   "},{"title":"using​","type":1,"pageTitle":"Statements","url":"wiki/Statements#using","content":"Facets​ topology (topology), (omissible) : the topology  Definition​ using is a statement that allows to set the topology to use by its sub-statements. They can gather it by asking the scope to provide it. Usages​ All the spatial operations are topology-dependent (e.g. neighbors are not the same in a continuous and in a grid topology). So using statement allows modelers to specify the topology in which the spatial operation will be computed. float dist &lt;- 0.0; using topology(grid_ant) { d (self.location distance_to target.location); }  Embedments​ The using statement is of type: Sequence of statements or actionThe using statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer, The using statement embeds statements:   "},{"title":"Variable_container​","type":1,"pageTitle":"Statements","url":"wiki/Statements#variable_container","content":"Facets​ name (a new identifier), (omissible) : The name of the attributecategory (a label): Soon to be deprecated. Declare the parameter in an experiment insteadconst (boolean): Indicates whether this attribute can be subsequently modified or notfunction (any type): Used to specify an expression that will be evaluated each time the attribute is accessed. This facet is incompatible with both 'init:' and 'update:'index (a datatype identifier): The type of the key used to retrieve the contents of this attributeinit (any type): The initial value of the attributeof (a datatype identifier): The type of the contents of this container attributeon_change (any type): Provides a block of statements that will be executed whenever the value of the attribute changesparameter (a label): Soon to be deprecated. Declare the parameter in an experiment insteadtype (a datatype identifier): The type of the attributeupdate (any type): An expression that will be evaluated each cycle to compute a new value for the attribute  Definition​ Allows to declare an attribute of a species or an experiment Usages​ Embedments​ The Variable_container statement is of type: Variable (container)The Variable_container statement can be embedded into: Species, Experiment, Model, The Variable_container statement embeds statements:   "},{"title":"Variable_number​","type":1,"pageTitle":"Statements","url":"wiki/Statements#variable_number","content":"Facets​ name (a new identifier), (omissible) : The name of the attributeamong (list): A list of constant values among which the attribute can take its valuecategory (a label): Soon to be deprecated. Declare the parameter in an experiment insteadconst (boolean): Indicates whether this attribute can be subsequently modified or notfunction (any type in [int, float, point, date]): Used to specify an expression that will be evaluated each time the attribute is accessed. This facet is incompatible with both 'init:' and 'update:'init (any type in [int, float, point, date]): The initial value of the attributemax (any type in [int, float, point, date]): The maximum value this attribute can take. The value will be automatically clampled if it is higher.min (any type in [int, float, point, date]): The minimum value this attribute can take. The value will be automatically clamped if it is lower.on_change (any type): Provides a block of statements that will be executed whenever the value of the attribute changesparameter (a label): Soon to be deprecated. Declare the parameter in an experiment insteadstep (any type in [int, float, point, date]): A discrete step (used in conjunction with min and max) that constrains the values this variable can taketype (a datatype identifier): The type of the attribute, either 'int', 'float', 'point' or 'date'update (any type in [int, float, point, date]): An expression that will be evaluated each cycle to compute a new value for the attribute  Definition​ Allows to declare an attribute of a species or experiment; this type of attributes accepts min:, max: and step: facets, automatically clamping the value if it is lower than min or higher than max. Usages​ Embedments​ The Variable_number statement is of type: Variable (number)The Variable_number statement can be embedded into: Species, Experiment, Model, The Variable_number statement embeds statements:   "},{"title":"Variable_regular​","type":1,"pageTitle":"Statements","url":"wiki/Statements#variable_regular","content":"Facets​ name (a new identifier), (omissible) : The name of the attributeamong (list): A list of constant values among which the attribute can take its valuecategory (a label): Soon to be deprecated. Declare the parameter in an experiment insteadconst (boolean): Indicates whether this attribute can be subsequently modified or notfunction (any type): Used to specify an expression that will be evaluated each time the attribute is accessed. This facet is incompatible with both 'init:', 'update:' and 'on_change:' (or the equivalent final block)index (a datatype identifier): The type of the index used to retrieve elements if the type of the attribute is a container typeinit (any type): The initial value of the attributeof (a datatype identifier): The type of the elements contained in the type of this attribute if it is a container typeon_change (any type): Provides a block of statements that will be executed whenever the value of the attribute changesparameter (a label): Soon to be deprecated. Declare the parameter in an experiment insteadtype (a datatype identifier): The type of this attribute. Can be combined with facets 'of' and 'index' to describe container typesupdate (any type): An expression that will be evaluated each cycle to compute a new value for the attribute  Definition​ Allows to declare an attribute of a species or an experiment Usages​ Embedments​ The Variable_regular statement is of type: Variable (regular)The Variable_regular statement can be embedded into: Species, Experiment, Model, The Variable_regular statement embeds statements:   "},{"title":"warn​","type":1,"pageTitle":"Statements","url":"wiki/Statements#warn","content":"Facets​ message (string), (omissible) : the message to display as a warning.  Definition​ The statement makes the agent output an arbitrary message in the error view as a warning. Usages​ Emmitting a warning warn 'This is a warning from ' + self;  Embedments​ The warn statement is of type: Single statementThe warn statement can be embedded into: Behavior, Sequence of statements or action, Layer, The warn statement embeds statements:   "},{"title":"write​","type":1,"pageTitle":"Statements","url":"wiki/Statements#write","content":"Facets​ message (any type), (omissible) : the message to display. Modelers can add some formatting characters to the message (carriage returns, tabs, or Unicode characters), which will be used accordingly in the console.color (rgb): The color with wich the message will be displayed. Note that different simulations will have different (default) colors to use for this purpose if this facet is not specified  Definition​ The statement makes the agent output an arbitrary message in the console. Usages​ Outputting a message write 'This is a message from ' + self;  Embedments​ The write statement is of type: Single statementThe write statement can be embedded into: Behavior, Sequence of statements or action, Layer, The write statement embeds statements: "},{"title":"Using Database Access","type":0,"sectionRef":"#","url":"wiki/UsingDatabase","content":"","keywords":""},{"title":"Description​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#description","content":"Plug-in: irit.gaml.extensions.databaseAuthor: TRUONG Minh Thai, Frederic AMBLARD, Benoit GAUDOU, Christophe SIBERTIN-BLANC "},{"title":"Supported DBMS​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#supported-dbms","content":"The following DBMS are currently supported: SQLiteMySQL ServerPostgreSQL ServerSQL ServerMondrian OLAP ServerSQL Server Analysis Services Note that, other DBMSs require a dedicated server to work while SQLite only needs a file to be accessed. All the actions can be used independently from the chosen DBMS. Only the connection parameters are DBMS-dependent. "},{"title":"SQLSKILL​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#sqlskill","content":""},{"title":"Define a species that uses the SQLSKILL skill​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#define-a-species-that-uses-the-sqlskill-skill","content":"Example of declaration: species toto skills: [SQLSKILL] { //insert your descriptions here }  Agents with such a skill can use additional actions (defined in the skill) "},{"title":"Map of connection parameters for SQL​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#map-of-connection-parameters-for-sql","content":"In the actions defined in the SQLSkill, a parameter containing the connection parameters is required. It is a map with the following key::value pairs: Key\tOptional\tDescriptiondbtype\tNo\tDBMS type value. Its value is a string. We must use &quot;mysql&quot; when we want to connect to a MySQL. That is the same for &quot;postgres&quot;, &quot;sqlite&quot; or &quot;sqlserver&quot; (ignore case sensitive) host\tYes\tHost name or IP address of data server. It is absent when we work with SQlite. port\tYes\tPort of connection. It is not required when we work with SQLite. database\tNo\tName of database. It is the file name including the path when we work with SQLite. user\tYes\tUsername. It is not required when we work with SQLite. passwd\tYes\tPassword. It is not required when we work with SQLite. srid\tYes\tsrid (Spatial Reference Identifier) corresponds to a spatial reference system. This value is specified when GAMA connects to spatial database. If it is absent then GAMA uses spatial reference system defined in Preferences-&gt;External configuration. Table 1: Connection parameter description Example: Definitions of connection parameter // POSTGRES connection parameter map &amp;lt;string, string&gt; POSTGRES &lt;- [ 'host'::'localhost', 'dbtype'::'postgres', 'database'::'BPH', 'port'::'5433', 'user'::'postgres', 'passwd'::'abc']; //SQLite map &amp;lt;string, string&gt; SQLITE &lt;- [ 'dbtype'::'sqlite', 'database'::'../includes/meteo.db']; // SQLSERVER connection parameter map &amp;lt;string, string&gt; SQLSERVER &lt;- [ 'host'::'localhost', 'dbtype'::'sqlserver', 'database'::'BPH', 'port'::'1433', 'user'::'sa', 'passwd'::'abc']; // MySQL connection parameter map &amp;lt;string, string&gt; MySQL &lt;- [ 'host'::'localhost', 'dbtype'::'MySQL', 'database'::'', // it may be a null string 'port'::'3306', 'user'::'root', 'passwd'::'abc'];  "},{"title":"Test a connection to database​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#test-a-connection-to-database","content":"Syntax: testConnection (params: connection``parameter)_ The action tests the connection to a given database. Return: boolean. It is: true: the agent can connect to the DBMS (to the given Database with given name and password)false: the agent cannot connect Arguments: params: (type = map) map of connection parameters Exceptions: GamaRuntimeException Example: Check a connection to MySQL if (self testConnection(params:MySQL)){ write &quot;Connection is OK&quot; ; }else{ write &quot;Connection is false&quot; ; }  "},{"title":"Select data from database​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#select-data-from-database","content":"Syntax: select (param: connection`parameter, select: selectionstring,values: value`list)_ The action creates a connection to a DBMS and executes the select statement. If the connection or selection fails then it throws a GamaRuntimeException. Return: list &lt; list &gt;. If the selection succeeds, it returns a list with three elements: The first element is a list of column name.The second element is a list of column type.The third element is a data set. Arguments: params: (type = map) map containing the connection parametersselect: (type = string) select string. The selection string can contain question marks.values: List of values that are used to replace question marks in appropriate. This is an optional parameter. Exceptions: GamaRuntimeException Example: select data from table points map &amp;lt;string, string&gt; PARAMS &lt;- ['dbtype'::'sqlite', 'database'::'../includes/meteo.db']; list&amp;lt;list&gt; t &lt;- list&amp;lt;list&gt; (self select(params:PARAMS, select:&quot;SELECT * FROM points ;&quot;));  Example: select data from table point with question marks from table points map &amp;lt;string, string&gt; PARAMS &lt;- ['dbtype'::'sqlite', 'database'::'../includes/meteo.db']; list&amp;lt;list&gt; t &lt;- list&amp;lt;list&gt; (self select(params: PARAMS, select: &quot;SELECT temp_min FROM points where (day&gt;? and day&amp;lt;?);&quot; values: [10,20] ));  "},{"title":"Insert data into database​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#insert-data-into-database","content":"Syntax: insert (param: connection`parameter, into: tablename, columns: columnlist, values: valuelist)_The action creates a connection to a DBMS and executes the insert statement. If the connection or insertion fails then it throws a_GamaRuntimeException. Return: int If the insertion succeeds, it returns a number of records inserted by the insert. Arguments:params: (type = map) map containing the connection parameters.into: (type = string) table name.columns: (type=list) list of column names of table. It is an optional argument. If it is not applicable then all columns of table are selected.values: (type=list) list of values that are used to insert into table corresponding to columns. Hence the columns and values must have same size.Exceptions:_GamaRuntimeException Example: Insert data into table registration map&amp;lt;string, string&gt; PARAMS &lt;- ['dbtype'::'sqlite', 'database'::'../../includes/Student.db']; do insert (params: PARAMS, into: &quot;registration&quot;, values: [102, 'Mahnaz', 'Fatma', 25]); do insert (params: PARAMS, into: &quot;registration&quot;, columns: [&quot;id&quot;, &quot;first&quot;, &quot;last&quot;], values: [103, 'Zaid tim', 'Kha']); int n &lt;- insert (params: PARAMS, into: &quot;registration&quot;, columns: [&quot;id&quot;, &quot;first&quot;, &quot;last&quot;], values: [104, 'Bill', 'Clark']);  "},{"title":"Execution update commands​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#execution-update-commands","content":"Syntax: executeUpdate (param: connection`parameter, updateComm: tablename, values: value`list)_ The action executeUpdate executes an update command (create/insert/delete/drop) by using the current database connection of the agent. If the database connection does not exist or the update command fails then it throws a GamaRuntimeException. Otherwise, it returns an integer value. Return: int. If the insertion succeeds, it returns a number of records inserted by the insert.Arguments: params: (type = map) map containing the connection parametersupdateComm: (type = string) SQL command string. It may be commands: create, update, delete and drop with or without question marks.columns: (type=list) list of column names of table.values: (type=list) list of values that are used to replace question marks if appropriate. This is an optional parameter. Exceptions: GamaRuntimeException Examples: Using action executeUpdate do sql commands (create, insert, update, delete and drop). map&amp;lt;string, string&gt; PARAMS &lt;- ['dbtype'::'sqlite', 'database'::'../../includes/Student.db']; // Create table do executeUpdate (params: PARAMS, updateComm: &quot;CREATE TABLE registration&quot; + &quot;(id INTEGER PRIMARY KEY, &quot; + &quot; first TEXT NOT NULL, &quot; + &quot; last TEXT NOT NULL, &quot; + &quot; age INTEGER);&quot;); // Insert into do executeUpdate (params: PARAMS , updateComm: &quot;INSERT INTO registration &quot; + &quot;VALUES(100, 'Zara', 'Ali', 18);&quot;); do insert (params: PARAMS, into: &quot;registration&quot;, columns: [&quot;id&quot;, &quot;first&quot;, &quot;last&quot;], values: [103, 'Zaid tim', 'Kha']); // executeUpdate with question marks do executeUpdate (params: PARAMS, updateComm: &quot;INSERT INTO registration &quot; + &quot;VALUES(?, ?, ?, ?);&quot; , values: [101, 'Mr', 'Mme', 45]); //update int n &lt;- executeUpdate (params: PARAMS, updateComm: &quot;UPDATE registration SET age = 30 WHERE id IN (100, 101)&quot; ); // delete int n &lt;- executeUpdate (params: PARAMS, updateComm: &quot;DELETE FROM registration where id=? &quot;, values: [101] ); // Drop table do executeUpdate (params: PARAMS, updateComm: &quot;DROP TABLE registration&quot;);  "},{"title":"MDXSKILL​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#mdxskill","content":"MDXSKILL plays the role of an OLAP tool using select to query data from OLAP server to GAMA environment and then species can use the queried data for any analysis purposes. "},{"title":"Define a species that uses the MDXSKILL skill​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#define-a-species-that-uses-the-mdxskill-skill","content":"Example of declaration:  species olap skills: [MDXSKILL] { //insert your descriptions here } ...  Agents with such a skill can use additional actions (defined in the skill) "},{"title":"Map of connection parameters for MDX​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#map-of-connection-parameters-for-mdx","content":"In the actions defined in the SQLSkill, a parameter containing the connection parameters is required. It is a map with following key::value pairs: Key\tOptional\tDescriptionolaptype\tNo\tOLAP Server type value. Its value is a string. We must use &quot;SSAS/XMLA&quot; when we want to connect to an SQL Server Analysis Services by using XML for Analysis. That is the same for &quot;MONDRIAN/XML&quot; or &quot;MONDRIAN&quot; (ignore case sensitive) dbtype\tNo\tDBMS type value. Its value is a string. We must use &quot;mysql&quot; when we want to connect to a MySQL. That is the same for &quot;postgres&quot; or &quot;sqlserver&quot; (ignore case sensitive) host\tNo\tHost name or IP address of data server. port\tNo\tPort of connection. It is no required when we work with SQLite. database\tNo\tName of database. It is file name include path when we work with SQLite. catalog\tYes\tName of catalog. It is an optional parameter. We do not need to use it when we connect to SSAS via XMLA and its file name includes the path when we connect a ROLAP database directly by using Mondrian API (see Example as below) user\tNo\tUsername. passwd\tNo\tPassword. Table 2: OLAP Connection parameter description Example: Definitions of OLAP connection parameter //Connect SQL Server Analysis Services via XMLA map&amp;lt;string,string&gt; SSAS &lt;- [ 'olaptype'::'SSAS/XMLA', 'dbtype'::'sqlserver', 'host'::'172.17.88.166', 'port'::'80', 'database'::'olap', 'user'::'test', 'passwd'::'abc']; //Connect Mondriam server via XMLA map&amp;lt;string,string&gt; MONDRIANXMLA &lt;- [ 'olaptype'::&quot;MONDRIAN/XMLA&quot;, 'dbtype'::'postgres', 'host'::'localhost', 'port'::'8080', 'database'::'MondrianFoodMart', 'catalog'::'FoodMart', 'user'::'test', 'passwd'::'abc']; //Connect a ROLAP server using Mondriam API map&amp;lt;string,string&gt; MONDRIAN &lt;- [ 'olaptype'::'MONDRIAN', 'dbtype'::'postgres', 'host'::'localhost', 'port'::'5433', 'database'::'foodmart', 'catalog'::'../includes/FoodMart.xml', 'user'::'test', 'passwd'::'abc'];  "},{"title":"Test a connection to OLAP database​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#test-a-connection-to-olap-database","content":"Syntax: testConnection (params: connection``parameter)_ The action tests the connection to a given OLAP database. Return: boolean. It is: true: the agent can connect to the DBMS (to the given Database with given name and password)false: the agent cannot connect Arguments: params: (type = map) map of connection parameters Exceptions: GamaRuntimeException Example: Check a connection to MySQL if (self testConnection(params:MONDIRANXMLA)){ write &quot;Connection is OK&quot;; }else{ write &quot;Connection is false&quot;; }  "},{"title":"Select data from OLAP database​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#select-data-from-olap-database","content":"Syntax: select (param: connection`parameter, onColumns: columnstring, onRows: rowstring from: cubestring, where: conditionstring, values: value`list)The action creates a connection to an OLAP database and executes the select statement. If the connection or selection fails then it throws a GamaRuntimeException. Return: list &lt; list &gt;. If the selection succeeds, it returns a list with three elements: The first element is a list of column name.The second element is a list of column type.The third element is a data set. Arguments: params: (type = map) map containing the connection parametersonColumns: (type = string) declare the select string on columns. The selection string can contain question marks.onRows: (type = string) declare the selection string on rows. The selection string can contain question marks.from: (type = string) specify cube where data is selected. The cube_string can contain question marks.where: (type = string) specify the selection conditions. The condiction_string can contains question marks. This is an optional parameter. *_values: List of values that are used to replace question marks if appropriate. This is an optional parameter. Exceptions:_GamaRuntimeException Example: select data from SQL Server Analysis Service via XMLA if (self testConnection[ params::SSAS]){ list l1 &lt;- list(self select (params: SSAS , onColumns: &quot; { [Measures].[Quantity], [Measures].[Price] }&quot;, onRows:&quot; { { { [Time].[Year].[All].CHILDREN } * &quot; + &quot; { [Product].[Product Category].[All].CHILDREN } * &quot; +&quot;{ [Customer].[Company Name].&amp;[Alfreds Futterkiste], &quot; +&quot;[Customer].[Company Name].&amp;[Ana Trujillo Emparedadosy helados], &quot; + &quot;[Customer].[Company Name].&amp;[Antonio Moreno Taquería] } } } &quot; , from : &quot;FROM [Northwind Star] &quot;)); write &quot;result1:&quot;+ l1; }else { write &quot;Connect error&quot;; }  Example: select data from Mondrian via XMLA with question marks in selection if (self testConnection(params:MONDRIANXMLA)){ list&amp;lt;list&gt; l2 &lt;- list&amp;lt;list&gt; (self select(params: MONDRIANXMLA, onColumns:&quot; {[Measures].[Unit Sales], [Measures].[Store Cost], [Measures].[Store Sales]} &quot;, onRows:&quot; Hierarchize(Union(Union(Union({([Promotion Media].[All Media],&quot; +&quot; [Product].[All Products])}, &quot; +&quot; Crossjoin([Promotion Media].[All Media].Children, &quot; +&quot; {[Product].[All Products]})), &quot; +&quot; Crossjoin({[Promotion Media].[Daily Paper, Radio, TV]}, &quot; +&quot; [Product].[All Products].Children)), &quot; +&quot; Crossjoin({[Promotion Media].[Street Handout]}, &quot; +&quot; [Product].[All Products].Children))) &quot;, from:&quot; from [?] &quot; , where :&quot; where [Time].[?] &quot; , values:[&quot;Sales&quot;,1997])); write &quot;result2:&quot;+ l2; }else { write &quot;Connect error&quot;; }  "},{"title":"AgentDB​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#agentdb","content":"AgentBD is a built-in species, which supports behaviors that look like actions in SQLSKILL but differs slightly with SQLSKILL in that it uses only one connection for several actions. It means that AgentDB makes a connection to DBMS and keeps that connection for its later operations with DBMS. "},{"title":"Define a species that is an inheritance of agentDB​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#define-a-species-that-is-an-inheritance-of-agentdb","content":"Example of declaration: species agentDB parent: AgentDB { //insert your descriptions here }  "},{"title":"Connect to database​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#connect-to-database","content":"Syntax: Connect (param: connection``parameter)_ This action makes a connection to DBMS. If a connection is established then it will assign the connection object into a built-in attribute of species (conn) otherwise it throws a GamaRuntimeException. Return: connectionArguments: params: (type = map) map containing the connection parameters Exceptions: GamaRuntimeException Example: Connect to PostgreSQL // POSTGRES connection parameter map &amp;lt;string, string&gt; POSTGRES &lt;- [ 'host'::'localhost', 'dbtype'::'postgres', 'database'::'BPH', 'port'::'5433', 'user'::'postgres', 'passwd'::'abc']; ask agentDB { do connect (params: POSTGRES); }  "},{"title":"Check agent connected a database or not​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#check-agent-connected-a-database-or-not","content":"Syntax: isConnected (param: connection``parameter)_ This action checks if an agent is connecting to database or not. Return: Boolean. If agent is connecting to a database then isConnected returns true; otherwise it returns false.Arguments: params: (type = map) map containing the connection parameters Example: Using action executeUpdate do sql commands (create, insert, update, delete and drop). ask agentDB { if (self isConnected){ write &quot;It already has a connection&quot;; }else{ do connect (params: POSTGRES); } }  "},{"title":"Close the current connection​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#close-the-current-connection","content":"Syntax: closeThis action closes the current database connection of species. If species does not has a database connection then it throws a GamaRuntimeException. Return: null If the current connection of species is close then the action return null value; otherwise it throws a GamaRuntimeException. Example: ask agentDB { if (self isConnected){ do close; } }  "},{"title":"Get connection parameter​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#get-connection-parameter","content":"Syntax: getParameterThis action returns the connection parameter of species. Return: map &lt; string, string &gt; Example: ask agentDB { if (self isConnected){ write &quot;the connection parameter: &quot; +(self getParameter); } }  "},{"title":"Set connection parameter​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#set-connection-parameter","content":"Syntax: setParameter (param: connection``parameter)_ This action sets the new values for connection parameter and closes the current connection of species. If it can not close the current connection then it will throw GamaRuntimeException. If the species wants to make the connection to database with the new values then action connect must be called. Return: nullArguments: params: (type = map) map containing the connection parameters Exceptions: GamaRuntimeException Example: ask agentDB { if (self isConnected){ do setParameter(params: MySQL); do connect(params: (self getParameter)); } }  "},{"title":"Retrieve data from database by using AgentDB​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#retrieve-data-from-database-by-using-agentdb","content":"Because AgentDB's connection to database is kept alive, it can execute several SQL queries using only the connect action once. Hence AgentDB can do actions such as select, insert, executeUpdate with the same parameters as those of SQLSKILL except for the params parameter which is always absent. Examples: map&amp;lt;string, string&gt; PARAMS &lt;- ['dbtype'::'sqlite', 'database'::'../../includes/Student.db']; ask agentDB { do connect (params: PARAMS); // Create table do executeUpdate (updateComm: &quot;CREATE TABLE registration&quot; + &quot;(id INTEGER PRIMARY KEY, &quot; + &quot; first TEXT NOT NULL, &quot; + &quot; last TEXT NOT NULL, &quot; + &quot; age INTEGER);&quot;); // Insert into do executeUpdate ( updateComm: &quot;INSERT INTO registration &quot; + &quot;VALUES(100, 'Zara', 'Ali', 18);&quot;); do insert (into: &quot;registration&quot;, columns: [&quot;id&quot;, &quot;first&quot;, &quot;last&quot;], values: [103, 'Zaid tim', 'Kha']); // executeUpdate with question marks do executeUpdate (updateComm: &quot;INSERT INTO registration VALUES(?, ?, ?, ?);&quot;, values: [101, 'Mr', 'Mme', 45]); //select list&amp;lt;list&gt; t &lt;- list&amp;lt;list&gt; (self select( select:&quot;SELECT * FROM registration;&quot;)); //update int n &lt;- executeUpdate (updateComm: &quot;UPDATE registration SET age = 30 WHERE id IN (100, 101)&quot;); // delete int n &lt;- executeUpdate ( updateComm: &quot;DELETE FROM registration where id=? &quot;, values: [101] ); // Drop table do executeUpdate (updateComm: &quot;DROP TABLE registration&quot;); }  "},{"title":"Using database features to define environment or create species​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#using-database-features-to-define-environment-or-create-species","content":"In Gama, we can use results of select action of SQLSKILL or AgentDB to create species or define boundary of environment in the same way we do with shape files. Further more, we can also save simulation data that are generated by simulation including geometry data to database. "},{"title":"Define the boundary of the environment from database​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#define-the-boundary-of-the-environment-from-database","content":"Step 1: specify select query by declaration a map object with keys as below: Key\tOptional\tDescriptiondbtype\tNo\tDBMS type value. Its value is a string. We must use &quot;mysql&quot; when we want to connect to a MySQL. That is the same for &quot;postgres&quot;, &quot;sqlite&quot; or &quot;sqlserver&quot; (ignore case sensitive) host\tYes\tHost name or IP address of data server. It is absent when we work with SQlite. port\tYes\tPort of connection. It is not required when we work with SQLite. database\tNo\tName of database. It is the file name including the path when we work with SQLite. user\tYes\tUsername. It is not required when we work with SQLite. passwd\tYes\tPassword. It is not required when we work with SQLite. srid\tYes\tsrid (Spatial Reference Identifier) corresponds to a spatial reference system. This value is specified when GAMA connects to spatial database. If it is absent then GAMA uses spatial reference system defined in Preferences-&gt;External configuration. select\tNo\tSelection string Table 3: Select boundary parameter description Example: map&amp;lt;string,string&gt; BOUNDS &lt;- [ //'srid'::'32648', 'host'::'localhost', 'dbtype'::'postgres', 'database'::'spatial_DB', 'port'::'5433', 'user'::'postgres', 'passwd'::'tmt', 'select'::'SELECT ST_AsBinary(geom) as geom FROM bounds;' ];  Step 2: define boundary of environment by using the map object in first step. geometry shape &lt;- envelope(BOUNDS);  Note: We can do the same way if we work with MySQL, SQLite, or SQLServer and we must convert Geometry format in GIS database to binary format. "},{"title":"Create agents from the result of a select action​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#create-agents-from-the-result-of-a-select-action","content":"If we are familiar with how to create agents from a shapefile then it becomes very simple to create agents from select result. We can do as below: Step 1: Define a species with SQLSKILL or AgentDB species toto skills: SQLSKILL { //insert your descriptions here }  Step 2: Define a connection and selection parameters global { map&amp;lt;string,string&gt; PARAMS &lt;- ['dbtype'::'sqlite','database'::'../includes/bph.sqlite']; string location &lt;- 'select ID_4, Name_4, ST_AsBinary(geometry) as geom from vnm_adm4 where id_2=38253 or id_2=38254;'; ... }  Step 3: Create species by using selected results init { create toto { create locations from: list(self select (params: PARAMS, select: LOCATIONS)) with:[ id:: &quot;id_4&quot;, custom_name:: &quot;name_4&quot;, shape::&quot;geom&quot;]; } ... }  "},{"title":"Save Geometry data to database​","type":1,"pageTitle":"Using Database Access","url":"wiki/UsingDatabase#save-geometry-data-to-database","content":"If we are familiar with how to create agents from a shapefile then it becomes very simple to create agents from select result. We can do as below: Step 1: Define a species with SQLSKILL or AgentDB species toto skills: SQLSKILL { //insert your descriptions here }  Step 2: Define a connection and create GIS database and tables global { map&amp;lt;string,string&gt; PARAMS &lt;- ['host'::'localhost', 'dbtype'::'Postgres', 'database'::'', 'port'::'5433', 'user'::'postgres', 'passwd'::'tmt']; init { create toto ; ask toto { if (self testConnection[ params::PARAMS]){ // create GIS database do executeUpdate(params:PARAMS, updateComm: &quot;CREATE DATABASE spatial_db with TEMPLATE = template_postgis;&quot;); remove key: &quot;database&quot; from: PARAMS; put &quot;spatial_db&quot; key:&quot;database&quot; in: PARAMS; //create table do executeUpdate params: PARAMS updateComm : &quot;CREATE TABLE buildings &quot;+ &quot;( &quot; + &quot; name character varying(255), &quot; + &quot; type character varying(255), &quot; + &quot; geom GEOMETRY &quot; + &quot;)&quot;; }else { write &quot;Connection to MySQL can not be established &quot;; } } } }  Step 3: Insert geometry data to GIS database ask building { ask DB_Accessor { do insert(params: PARAMS, into: &quot;buildings&quot;, columns: [&quot;name&quot;, &quot;type&quot;,&quot;geom&quot;], values: [myself.name,myself.type,myself.shape]; } }  "},{"title":"Advanced Driving Skill","type":0,"sectionRef":"#","url":"wiki/UsingDrivingSkill","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Advanced Driving Skill","url":"wiki/UsingDrivingSkill#table-of-contents","content":"Advanced Driving Skill Structure of the network: road and road node skillsAdvanced driving skillApplication example "},{"title":"Structure of the network: road and road_node skills​","type":1,"pageTitle":"Advanced Driving Skill","url":"wiki/UsingDrivingSkill#structure-of-the-network-road-and-road_node-skills","content":"The advanced driving skill is versatile enough to be usable with most of classic road GIS data, in particular, OSM data. We use a classic format for the roads and nodes. Each road is a polyline composed of road sections (segments). Each road has a target node and a source node. Each node knows all its input and output roads. A road is considered as directed. For bidirectional roads, 2 roads have to be defined corresponding to both directions. Each road will be the linked_road of the other. Note that for some GIS data, only one road is defined for bidirectional roads, and the nodes are not explicitly defined. In this case, it is very easy, using the GAML language, to create the reverse roads and the corresponding nodes (it only requires a few lines of GAML).  A road can be composed of several lanes and the vehicles will be able to change at any time its lane. What a lane represents will depend a lot on the context of application. Typically, if in developed countries, the lanes are most of times well defined, in many other countries this notion is much more abstract. For example in Vietnam where the main means of locomotion is the motorcycle, a lane can designate a &quot;place&quot; for a motorcycle and thus be much narrower than classical lanes. Another property of the road that will be taken into account is the maximal authorized speed on it. Note that even if the user of the plug-in has no information about these values for some of the roads (the OSM data are often incomplete), it is very easy using the GAML language to fill the missing value by a default value. It is also possible to change these values dynamically during the simulation (for example, to take into account that after an accident, a lane of a road is closed or that the speed of a road is decreased by the authorities).  The road skill (skill_road) provides the road agents with several variables that will define the road properties: num_lanes: integer, number of lanes.maxspeed: float; maximal authorized speed on the road.linked_road: road agent; reverse road (if there is one).source_node: node agent; source node of the road.target_node: node agent; target node of the road. It provides as well the road agents with read-only variables: agents_on: list of list (of driver agents); for each lane, the list of driver agents on the road.all_agents: list (of driver agents): the list of agents on the road. The road node skill (skill_road_node) provides the road node agents with several variables that will define the road node properties: roads_in: list of road agents; the list of road agents that have this node for target node.roads_out: list of road agents; the list of road agents that have this node for source node.stop: list of list of road agents; list of stop signals, and for each stop signal, the list of concerned roads.priority_roads: list of road agents: the list of priority roads. It provides as well the road agents with one read-only variable: block: map: key: driver agent, value: list of road agents; the list of driver agents blocking the node, and for each agent, the list of concerned roads. "},{"title":"Advanced driving skill​","type":1,"pageTitle":"Advanced Driving Skill","url":"wiki/UsingDrivingSkill#advanced-driving-skill","content":"A vehicle is first characterized by its location, a 3D-point (coordinate) that represents the centroid of the vehicle. The actual geometry of the vehicle is not taken into account. However, the size of a vehicle is determined by two attributes: vehicle_length and num_lanes_occupied. Indeed, if we go back to our Vietnamese example where the lanes are defined according to the size of the motorcycles, we can consider that a motorcycle will occupy one lane, but that a car, which is much wider, will occupy two. Each vehicle agent has also a planned trajectory that consists of a succession of edges. When the vehicle agent enters a new edge, it first chooses its lane according to the traffic density, with a bias for the rightmost lane. The movement on an edge is inspired by the Intelligent Driver Model. The drivers have the possibility to change their lane at any time (and not only when entering a new edge). The lane-changing model is inspired from the MOBIL model. The advanced driving skill (advanced_driving ) provides the driver agents with several variables that will define the car properties and the personality of the driver: final_target: point; final location that the agent wants to reach (its goal).vehicle_length: float; length of the vehicle.num_lanes_occupied: float; the number of lanes occupied by the vehicle.max_acceleration: float; maximal acceleration of the vehicle.max_speed: float; maximal speed of the vehicle.right_side_driving: boolean; do drivers drive on the right side of the road?speed_coeff: float; coefficient that defines if the driver will try to drive above or below the speed limits.safety_distance_coeff: float; coefficient for the security distance. The security distance will depend on the driver speed and on this coefficient.proba_lane_change_up: float; probability to change lane to an upper lane if necessary (and if possible).proba_lane_change_down: float; probability to change lane to a lower lane if necessary (and if possible).proba_use_linked_road: float; probability to take the reverse road if necessary (if there is a reverse road).proba_respect_priorities: float; probability to respect left/right (according to the driving side) priority at intersections.proba_respect_stops: list of float; probabilities to respect each type of stop signals (traffic light, stop sign...).proba_block_node: float; probability to accept to block the intersecting roads to enter a new road.lane_change_cooldown: float; the duration that a vehicle must wait before changing lanes againmax_safe_deceleration: float; the maximum deceleration that the vehicle is willing to induce on its back vehicle when changing lanes. Known as the parameter 'b_save' in the MOBIL lane changing modelmin_safety_distance: float; the minimum distance of the vehicle's front bumper to the leading vehicle's rear bumper, known as the parameter s0 in the Intelligent Driver Modellane_change_limit: int; the maximum number of lanes that the vehicle can change during a simulation stepacc_gain_threshold: float; the minimum acceleration gain for the vehicle to switch to another lane, introduced to prevent frantic lane changing. Known as the parameter 'a_th' in the MOBIL lane changing modellinked_lane_limit: int; the maximum number of linked lanes that the vehicle can use; the default value is -1, i.e. the vehicle can use all available linked lanesignore_oneway: bool; if set to true, the vehicle will be able to violate one-way traffic rulelowest_lane: int; the lane with the smallest index that the vehicle is inacc_bias: float; the bias term used for asymmetric lane changing, parameter 'a_bias' in MOBILallowed_lanes: list of int; a list containing possible lane index values for the attribute lowest_lanetime_headway: float; the time gap that to the leading vehicle that the driver must maintain. Known as the parameter 'T' in the Intelligent Driver Modeldelta_idm: float; the exponent used in the computation of free-road acceleration in the Intelligent Driver Modelmax_deceleration: float; the maximum deceleration of the vehicle. Known as the parameter 'b' in the Intelligent Driver Modelpoliteness_factor: float; determines the politeness level of the vehicle when changing lanes. Known as the parameter 'p' in the MOBIL lane changing model It provides as well the driver agents with several read-only variables: speed: float; speed expected according to the road max_value, the car properties, the personality of the driver and its real_speed.real_speed: float; real speed of the car (that takes into account the other drivers and the traffic signals).current_path: path (list of roads to follow); the path that the agent is currently following.current_road: agent; the road on which the agent is driving on.lowest_lane: agent; the index of the lowest lane occupied.current_target: point; the next target to reach (sub-goal). It corresponds to a node.targets: list of points; list of locations (sub-goals) to reach the final target.current_index: integer; the index of the current goal the agent has to reach.using_linked_road: boolean; is the agent on the linked road? Of course, the values of these variables can be modified at any time during the simulation. For example, the probability to take a reverse road (proba_use_linked_road) can be increased if the driver is stuck for several minutes behind a slow vehicle. In addition, the advanced driving skill provides driver agents with several actions: compute_path: arguments: a graph and a target node. This action computes from a graph the shortest path to reach a given node.drive: no argument. This action moves the driver on its current path according to the traffic condition and the driver properties (vehicle properties and driver personality). The drive_random make the agent drives on a road and chooses randomly a new road at each intersection. The drive action works as follow: while the agent has the time to move (remaining_time &gt; 0), it first defines the speed expected. This speed is computed from the max_speed of the road, the current real_speed, the max_speed, the max_acceleration and the speed_coef of the driver. Then, the agent moves toward the current target and compute the remaining time. During the movement, the agents can change lanes. If the agent reaches its final target, it stops; if it reaches its current target (that is not the final target), it tests if it can cross the intersection to reach the next road of the current path. If it is possible, it defines its new target (target node of the next road) and continues to move. The function that defines if the agent crosses or not the intersection to continue to move works as follow: first, it tests if the road is blocked by a driver at the intersection (if the road is blocked, the agent does not cross the intersection). Then, if there is at least one stop signal at the intersection (traffic signal, stop sign...), for each of these signals, the agent tests its probability to respect or not the signal (note that the agent has a specific probability to respect each type of signals). If there is no stopping signal or if the agent does not respect it, the agent checks if there is at least one vehicle coming from a right (or left if the agent drives on the left side) road at a distance lower than its security distance. If there is one, it tests its probability to respect this priority. If there is no vehicle from the right roads or if it chooses to do not respect the right priority, it tests if it is possible to cross the intersection to its target road without blocking the intersection (i.e. if there is enough space in the target road). If it can cross the intersection, it crosses it; otherwise, it tests its probability to block the node: if the agent decides nevertheless to cross the intersection, then the perpendicular roads will be blocked at the intersection level (these roads will be unblocked when the agent is going to move). Concerning the movement of the driver agents on the current road, the agent moves from a section of the road (i.e. segment composing the polyline) to another section according to the maximal distance that the agent can moves (that will depend on the remaining time). For each road section, the agent first computes the maximal distance it can travel according to the remaining time and its speed. Then, the agent computes its security distance according to its speed and its safety_distance_coeff. While its remaining distance is not null, the agent computes the maximal distance it can travel (and the corresponding lane), then it moves according to this distance (and update its current lane if necessary). If the agent is not blocked by another vehicle and can reach the end of the road section, it updates its current road section and continues to move. The computation of the maximal distance an agent can move on a road section consists of computing for each possible lane the maximal distance the agent can move. First, if there is a lower lane, the agent tests the probability to change its lane to a lower one. If it decides to test the lower lane, the agent computes the distance to the next vehicle on this lane and memorizes it. If this distance corresponds to the maximal distance it can travel, it chooses this lane; otherwise, it computes the distance to the next vehicle on its current lane and memorizes it if it is higher than the current memorized maximal distance. Then if the memorized distance is lower than the maximal distance the agent can travel and if there is an upper lane, the agents test the probability to change its lane to an upper one. If it decides to test the upper lane, the agent computes the distance to the next vehicle on this lane and memorizes it if it is higher than the current memorized maximal distance. At last, if the memorized distance is still lower than the maximal distance it can travel if the agent is on the highest lane and if there is a reverse road, the agent tests the probability to use the reverse road (linked road). If it decides to use the reverse road, the agent computes the distance to the next vehicle on the lane 0 of this road and memorizes the distance if it is higher than the current memorized maximal distance. More details about the driving skill can be found here "},{"title":"Using FIPA ACL","type":0,"sectionRef":"#","url":"wiki/UsingFIPAACL","content":"","keywords":""},{"title":"Table of Contents​","type":1,"pageTitle":"Using FIPA ACL","url":"wiki/UsingFIPAACL#table-of-contents","content":"Main steps to create a conversation using FIPA Communication Acts and Interaction ProtocolsAttach the fipa skill to a speciesInitiate a conversationReceive messagesReply to a received messageThe message data typeThe conversation data type "},{"title":"Main steps to create a conversation using FIPA Communication Acts and Interaction Protocols​","type":1,"pageTitle":"Using FIPA ACL","url":"wiki/UsingFIPAACL#main-steps-to-create-a-conversation-using-fipa-communication-acts-and-interaction-protocols","content":"Attach the skill fipa to the agents' species that need to use Communication Acts An initiator agent starts a conversation with some agents: it chooses the Interaction Protocol and starts it by sending the first Communication Acts of the protocolEach agent involved in the conversation needs to check its received messages and respond to them by choosing the appropriate Communication Act. "},{"title":"Attach the fipa skill to a species​","type":1,"pageTitle":"Using FIPA ACL","url":"wiki/UsingFIPAACL#attach-the-fipa-skill-to-a-species","content":"To attach the fipa skill to a species, the modeler has to add it in the skills facet of the species statement (in a way similar to any other skill). species any_species skills: [fipa] { ... }  Agents of any species can communicate in the same conversation. The only constraint is that they need to have the capabilities to receive and send messages, i.e. to have the skill fipa. Species can have several attached skills: a single species can be provided with both the moving and fipa skills (and any other ones). This skill adds to every agent of the species: some additional attributes: conversations is the list of the agent's current conversations, mailbox is the list of messages of all types of performatives, requests, informs, proposes... are respectively the list of the 'request', 'inform', 'propose' performative messages. some additional actions, such as: inform, accept_proposal... that replies a message with an 'inform' (respectively 'accept_proposal' performative message).start_conversation that starts a conversation with a chosen interaction protocol.end_conversation that replies a message with an 'end_conversation' performative message. This message marks the end of a conversation. In a 'no-protocol' conversation, it is the responsibility of the modeler to explicitly send this message to mark the end of a conversation/interaction protocol.reply that replies a message. This action should be only used to reply a message in a 'no-protocol' conversation and with a 'user-defined performative'. For performatives supported by GAMA, please use the 'action' with the same name as the 'performative'. For example, to reply a message with a 'request' performative message, the modeler should use the 'request' action. "},{"title":"Initiate a conversation​","type":1,"pageTitle":"Using FIPA ACL","url":"wiki/UsingFIPAACL#initiate-a-conversation","content":"An interaction using an Interaction Protocol starts with the creation of a conversation by an agent, using the start_conversation action. The modeler specifies the chosen protocol (facet protocol), list of participants (facet to), communication act (facet performative) and message (facet contents). species Initiator skills: [fipa] { reflex send_propose_message when: (time = 1) { do start_conversation to: [p] protocol: 'fipa-propose' performative: 'propose' contents: ['Go swimming?'] ; }  "},{"title":"Receive messages​","type":1,"pageTitle":"Using FIPA ACL","url":"wiki/UsingFIPAACL#receive-messages","content":"Each agent (with the fipa skill) is provided with several &quot;mailbox&quot; attributes filtering the various received messages by communication act: e.g. proposes contains the list of the received messages with the &quot;Propose&quot; communication act. Receiving a message consists thus in looking at each message from the mailbox, and acting in accordance with its contents, participants... Important remark: once the contents field of a received message has been read, it is removed from all the lists it appears in. species Initiator skills: [fipa] { reflex read_accept_proposals when: !(empty(accept_proposals)) { write name + ' receives accept_proposal messages'; loop i over: accept_proposals { write 'accept_proposal message with content: ' + string(i.contents); } } } species Participant skills: [fipa] { reflex accept_proposal when: !(empty(proposes)) { message proposalFromInitiator &lt;- proposes at 0; do accept_proposal message: proposalFromInitiator contents: ['OK! It \\'s hot today!'] ; } }  Remark: To test that the agent has received a new message is simply done by testing whether the dedicated mailing box contains messages.To get a message, the modeler can either loop over the message list to get all the messages or get a message by its index in the message box. "},{"title":"Reply to a received message​","type":1,"pageTitle":"Using FIPA ACL","url":"wiki/UsingFIPAACL#reply-to-a-received-message","content":"Given the message it has received, an agent can reply using the appropriate Communication Act (using the appropriate action). It simply has to specify the message to which it replies and the content of the reply. Note that it does not need to specify the receiver as it is contained in the message. species Participant skills: [fipa] { reflex accept_proposal when: !(empty(proposes)) { message proposalFromInitiator &lt;- proposes at 0; do accept_proposal message: proposalFromInitiator contents: ['OK! It \\'s hot today!'] ; } }  "},{"title":"End a conversation​","type":1,"pageTitle":"Using FIPA ACL","url":"wiki/UsingFIPAACL#end-a-conversation","content":"When a conversation is made in the scope of an Interaction Protocol, it is ended automatically when the last Communicative Act has been sent. In the case of a 'no-protocol conversation', it is the responsibility of the modeler to explicitly send the end_conversation message to mark the end of a conversation/interaction protocol. When a conversation ends, it is automatically removed from the list conversations. "},{"title":"The message type​","type":1,"pageTitle":"Using FIPA ACL","url":"wiki/UsingFIPAACL#the-message-type","content":"The agents' mailbox is defined as a list of messages. Each message is a GAML object of type message. An exhaustive description of this type is provided in the dedicated GAML Data Types page. A message object is defined by a set of several fields, such as: contents (type unknown): the content of the messagesender (type unknown): the sender of the message. In the case where the sender is an agent, it is possible to get the corresponding agent with agent(m.sender) (where m is the considered message).unread (type bool): specify whether the message has been read.emission_timestamp (type int)recention_timestamp (type int) "},{"title":"The conversation data type​","type":1,"pageTitle":"Using FIPA ACL","url":"wiki/UsingFIPAACL#the-conversation-data-type","content":"The agents' conversations contain the list of the conversations in which the agent takes part. Each conversation is a GAML object of type conversation that contains the list of messages exchanged, the protocol, initiator... An exhaustive description of this type is provided in the dedicated GAML Data Types page. A conversation object is defined by a set of several fields, such as: messages (type = list of messages): the list of messages that compose this conversationprotocol (type = string): the name of the protocol followed by the conversationinitiator (type = agent): the agent that has initiated this conversationparticipants (type = list of agents): the list of agents that participate in this conversationended (type = bool): whether this conversation has ended or not "},{"title":"Using network","type":0,"sectionRef":"#","url":"wiki/UsingNetwork","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Using network","url":"wiki/UsingNetwork#introduction","content":"GAMA provides features to allow agents to communicate with other agents (and other applications) through network and to exchange messages of various types (from simple number to agents). To this purpose, the network skill should be used on agents intending to use these capabilities. Notice that in this communication, roles are asymetric: the simulations should contain a server and some clients to communicate. Message exchanges are made between agents through this server. 3 protocols are supported (TCP, UDP and MQTT): when TCP or UDP protocols are used: one agent of the simulation is the server and the other ones are the clients.when the MQTT protocol is used: all the agents are clients and the server is an external software. A free solution (ActiveMQ) can be freely downloaded from: http://activemq.apache.org. "},{"title":"Which protocol to use ?​","type":1,"pageTitle":"Using network","url":"wiki/UsingNetwork#which-protocol-to-use-","content":"In the GAMA network, 3 kinds of protocol can be used. Each of them has a particular purpose. MQTT: this is the default protocol that should be used to make agents of various GAMA instances to communicate through a MQTT server (that should be run as an external application, e.g. ActiveMQ that can be downloaded from: http://activemq.apache.org/),UDP: this protocol should be limited to fast (and unsecured) exchanges of small pieces of data from GAMA to an external application (for example, mouse location from a Processing application to GAMA, c.f. model library),TCP: this protocol can be used both to communicate between GAMA applications or between GAMA and an external application. "},{"title":"Disclaimer​","type":1,"pageTitle":"Using network","url":"wiki/UsingNetwork#disclaimer","content":"In all the models using any network communication, the server should be launched before the clients.As a consequence, when TCP or UDP protocols are used, a model creating a server agent should always be run first. Using MQTT protocol, the external software server should be launched before running any model using it. "},{"title":"Declaring a network species​","type":1,"pageTitle":"Using network","url":"wiki/UsingNetwork#declaring-a-network-species","content":"To create agents able to communicate through a network, their species should have the skill network: species Networking_Client skills: [network] { ... }  A list exhaustive of the additional attributes and available actions provided by this skill are described here:network skill preference page. "},{"title":"Creation of a network agent​","type":1,"pageTitle":"Using network","url":"wiki/UsingNetwork#creation-of-a-network-agent","content":"The network agents are created as any other agents, but (in general) at the creation of the agents, the connection is also created, using the connect built-in action: create Networking_Client { do connect to: &quot;localhost&quot; protocol: &quot;tcp_client&quot; port: 3001 with_name: &quot;Client&quot;; }  Each protocol has its specificities regarding the connection: TCP: protocol: the 2 possibles keywords are tcp_server or tcp_client, depending on the wanted role of the agent in the communication.port: traditionally the port 3001 is used. UDP: protocol: the 2 possibles keywords are udp_server or udp_emitter, depending on the wanted role of the agent in the communication.port: traditionally the port 9876 is used. MQTT: protocol: MQTT is the default protocol value (if no value is given, MQTT will be used)port: traditionally the port 1883 is used (when ActiveMQ is used as the server application)admin and password: traditionally the default login and password are &quot;admin&quot; (when ActiveMQ is used as the server application) Note: if no connection information is provided with the MQTT protocol (no port), then GAMA connects to an MQTT server provided by the GAMA community (for test purpose only!). "},{"title":"Sending messages​","type":1,"pageTitle":"Using network","url":"wiki/UsingNetwork#sending-messages","content":"To send any message, the agent has to use the send action: do send to: &quot;server&quot; contents: name + &quot; &quot; + cycle + &quot; sent to server&quot;;  The network skill in GAMA allows the modeler to send simple string messages between agents but also to send more complex objects (and in particular agents). In this case, the use of the MQTT protocol is highly recommended. do send to: &quot;receiver&quot; contents: (9 among NetworkingAgent);  "},{"title":"Receiving messages​","type":1,"pageTitle":"Using network","url":"wiki/UsingNetwork#receiving-messages","content":"The messages sent by other agents are received in the mailbox attribute of each agent. So to get its new message, the agent has simply to check whether it has a new message (with action has_more_message() ) and fetch it (that gets it and remove it from the mailing box) with the action fetch_message(). reflex fetch when: has_more_message() { message mess &lt;- fetch_message(); write name + &quot; fecth this message: &quot; + mess.contents; }  Note that when an agent is received, the fetch of the message will recreate the agent in the current simulation. Alternatively, the mailbox attribute can be directly accessed (notice that the mailbox is a list of messages): reflex receive { if (length(mailbox) &gt; 0) { write mailbox; } }  "},{"title":"Broadcasting a message to all the agents' members of a given group​","type":1,"pageTitle":"Using network","url":"wiki/UsingNetwork#broadcasting-a-message-to-all-the-agents-members-of-a-given-group","content":"Each time an agent creates a connection to another agent as a client, a way to communicate with it is stored in the network_groups attribute. So an agent can use this attribute to broadcast messages to all the agents with whose it can communicate: reflex broad { loop id over: network_groups { do send to: id contents: &quot;I am Server &quot; + name + &quot; I give order to &quot; + id; } }  To go further: network skill reference page.example models can be found in the GAMA model library, in: Plugin models &gt; Network. "},{"title":"Variables and Attributes","type":0,"sectionRef":"#","url":"wiki/VariablesAndAttributes","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Variables and Attributes","url":"wiki/VariablesAndAttributes#table-of-contents","content":"Variables and Attributes Direct AccessRemote Access "},{"title":"Direct Access​","type":1,"pageTitle":"Variables and Attributes","url":"wiki/VariablesAndAttributes#direct-access","content":"When an agent wants to use either one of the variables declared locally, one of the attributes declared in its species (or parent species), one of the attributes declared in the macro-species of its species, it can directly invoke its name and the compiler will do the rest (i.e. finding the variable or attribute in the right scope). For instance, we can have a look at the following example: species animal { float energy &lt;- 1000 min: 0 max: 2000 update: energy - 0.001; int age_in_years &lt;- 1 update: age_in_years + int (time / 365); action eat (float amount &lt;- 0) { float gain &lt;- amount / age_in_years; energy &lt;- energy + gain; } reflex feed { int food_found &lt;- rnd(100); do eat (amount: food_found); } }  "},{"title":"Species declaration​","type":1,"pageTitle":"Variables and Attributes","url":"wiki/VariablesAndAttributes#species-declaration","content":"Everywhere in the species declaration, we are able to directly name and use: time, a global built-in variable,energy and age_in_years, the two species attributes. Nevertheless, in the species declaration, but outside of the action eat and the reflex feed, we cannot name the variables: amount, the argument of eat action,gain, a local variable defined into the eat action,food_found, the local variable defined into the feed reflex. "},{"title":"Eat action declaration​","type":1,"pageTitle":"Variables and Attributes","url":"wiki/VariablesAndAttributes#eat-action-declaration","content":"In the eat action declaration, we can directly name and use: time, a global built-in variable,energy and age_in_years, the two species attributes,amount, which is an argument to the action eat,gain, a temporary variable within the action. We cannot name and use the variables: food_found, the local variable defined into the feed reflex. "},{"title":"feed reflex declaration​","type":1,"pageTitle":"Variables and Attributes","url":"wiki/VariablesAndAttributes#feed-reflex-declaration","content":"Similarly, in the feed reflex declaration, we can directly name and use: time, a global built-in variable,energy and age_in_years, the two species variables,food_found, the local variable defined into the reflex. But we cannot access to variables: amount, the argument of eat action,gain, a local variable defined into the eat action. "},{"title":"Remote Access​","type":1,"pageTitle":"Variables and Attributes","url":"wiki/VariablesAndAttributes#remote-access","content":"When an expression needs to get access to the attribute of an agent which does not belong to its scope of execution, a special notation (similar to that used in Java) has to be used: remote_agent.variable  where remote_agent can be the name of an agent, an expression returning an agent, self, myself or each. For instance, if we modify the previous species by giving its agents the possibility to feed another agent found in its neighborhood, the result would be: species animal { float energy &lt;- 1000 min: 0 max: 2000 update: energy - 0.001; int age_in_years &lt;- 1 update: age_in_years + int (time / 365); action eat (float amount &lt;- 0.0) { float gain &lt;- amount / age_in_years; energy &lt;- energy + gain; } action feed (animal target){ if (agent_to_feed != nil) and (agent_to_feed.energy &lt; energy { // verifies that the agent exists and that it need to be fed ask agent_to_feed { do eat amount: myself.energy / 10; // asks the agent to eat 10% of our own energy } energy &lt;- energy - (energy / 10); // reduces the energy by 10% } } reflex { animal candidates &lt;- agents_overlapping (10 around agent.shape); gathers all the neighbors agent_to_feed value: candidates with_min_of (each.energy); //grabs one agent with the lowest energy do feed target: agent_to_feed; // tries to feed it } }  In this example, agent_to_feed.energy, myself.energy and each.energy show different remote accesses to the attribute energy. The dotted notation used here can be employed in assignments as well. For instance, an action allowing two agents to exchange their energy could be defined as: action random_exchange {//exchanges our energy with that of the closest agent animal one_agent &lt;- agent_closest_to (self); float temp &lt;- one_agent.energy; // temporary storage of the agent's energy one_agent.energy &lt;- energy; // assignment of the agent's energy with our energy energy &lt;- temp; }  "},{"title":"Validation of Models","type":0,"sectionRef":"#","url":"wiki/ValidationOfModels","content":"","keywords":""},{"title":"Table of contents​","type":1,"pageTitle":"Validation of Models","url":"wiki/ValidationOfModels#table-of-contents","content":"Validation of Models Syntactic errorsSemantic errorsSemantic warningsSemantic informationSemantic documentationChanging the visual indicatorsErrors in imported filesCleaning models "},{"title":"Syntactic errors​","type":1,"pageTitle":"Validation of Models","url":"wiki/ValidationOfModels#syntactic-errors","content":"These errors are produced when the modeler enters a sentence that has no meaning in the grammar of GAML (see the documentation of the language). It can either be a non-existing symbol (like &quot;globals&quot; (instead of global) in the example below), a wrong punctuation scheme, or any other construct that puts the parser in the incapacity of producing a correct syntax tree. These errors are extremely common when editing models (since incomplete keywords or sentences are continuously validated). GAMA will report them using several indicators: the icon of the file in the title of the editor will sport an error icon and the gutter of the editor (i.e. the vertical space beside the line numbers) will use error markers to report two or more errors: one on the statement defining the model, and one (or more) in the various places where the parser has failed to produce the syntax tree. In addition, the toolbar over the editor will turn red and indicate that errors have been detected. Finally, the validation view gathers all the errors of the workspace.  Hovering over one of these markers indicates what went wrong during the syntactic validation. Note that these errors are sometimes difficult to interpret since the parser might fail in places that are not precisely those where a wrong syntax is being used (it will usually fail after).  "},{"title":"Semantic errors​","type":1,"pageTitle":"Validation of Models","url":"wiki/ValidationOfModels#semantic-errors","content":"When syntactic errors are eliminated, the validation enters a so-called semantic phase, during which it ensures that what the modeler has written makes sense with respect to the various rules of the language. To understand the difference between the two phases, take a look at the following example. This sentence below is syntactically correct: species my_species parent: my_species;  But it is semantically incorrect because a species cannot be parent of itself. No syntactic errors will be reported here, but the validation will fail with a semantic error.  Semantic errors are reported in a way similar to syntactic errors, except that no marker are displayed beside the model statement. The compiler tries to report them as precisely as possible, underlining the places where they have been found and outputting hopefully meaningful error messages. In the example below, for instance, we use the wrong number of arguments for defining a square geometry. Although the sentence is syntactically correct, GAMA will nevertheless issue an error and prevent the model from being experimentable. The message accompanying this error can be obtained by hovering over the error marker found in the gutter (multiple messages can actually be produced for the same error, see below).  "},{"title":"Semantic warnings​","type":1,"pageTitle":"Validation of Models","url":"wiki/ValidationOfModels#semantic-warnings","content":"The semantic validation phase does not only report errors. It also outputs various indicators that can help the modeler in verifying the correctness of his/her model. Among them are warnings. A warning is an indication that something is not completely right in the way the model is written, although it can probably be worked around by GAMA when the model will be executed. For instance, in the example below, we pass a string argument to the facet &quot;number:&quot; of the &quot;create&quot; statement. create people number: &quot;10&quot;;  GAMA will emit a warning in such a case, indicating that number: expects an integer and that the string passed will be cast to int when the model will be executed. Warnings are to be considered seriously, as they usually indicate some flaws in the logic of the model.  Hovering over the warning marker will allow the modeler to have access to the explanation and hopefully fix the cause of the warning.  "},{"title":"Semantic information​","type":1,"pageTitle":"Validation of Models","url":"wiki/ValidationOfModels#semantic-information","content":"Besides warnings, another type of harmless feedback is produced by the semantic validation phase: information markers. They are used to indicate useful information to the modeler, for example, that an attribute has been redefined in a sub-species, or that some operation will take place when running the model (for instance, the truncation of a float to an int). The visual affordance used in this case is voluntarily discrete (a small &quot;i&quot; in the editor's gutter).  As with the other types of markers, information markers unveil their messages when being hovered.  "},{"title":"Semantic documentation​","type":1,"pageTitle":"Validation of Models","url":"wiki/ValidationOfModels#semantic-documentation","content":"The last type of output of the semantic validation phase consists of a complete documentation of the various elements present in the model, which the user can retrieve by hovering over the different symbols. Note that although the best effort is being made in producing a complete and consistent documentation, it may happen that some symbols do not produce anything. In that case, please report a new Issue here.  "},{"title":"Changing the visual indicators​","type":1,"pageTitle":"Validation of Models","url":"wiki/ValidationOfModels#changing-the-visual-indicators","content":"The default visual indicators depicted in the examples above to report errors, warnings and information can be customized to be less (or more) intrusive. This can be done by choosing the &quot;Preferences...&quot; item of the editor contextual menu and navigating to &quot;General &gt; Editors &gt; Text Editors &gt; Annotations&quot;. There, you will find the various markers used, and you will be able to change how they are displayed in the editor's view. For instance, if you prefer to highlight errors in the text, you can change it here.  Which will result in the following visual feedback for errors:  "},{"title":"Errors in imported files​","type":1,"pageTitle":"Validation of Models","url":"wiki/ValidationOfModels#errors-in-imported-files","content":"Finally, even if your model has been cleansed of all errors, it may happen that it refuses to launch because it imports another model that cannot be compiled. In the following screenshot, MyFirstModel.gaml imports Imported Model.gaml, which sports an error.  In such a case, the importing model refuses to compile (although it is itself valid), showing an error in the import statement of the model with errors. There are cases, however, where the same importation can work. Consider the previous example, where Imported Model.gaml sports a semantic error in the definition of the global 'shape' attribute.  However, if MyFirstModel.gaml happens to redefine the shape attribute (in global), it is now considered as valid. All the valid sections of Imported Model.gaml are effectively imported, while the erroneous definition is superseded by the new one.  This process is described by the information marker next to the redefinition.  "},{"title":"Cleaning models​","type":1,"pageTitle":"Validation of Models","url":"wiki/ValidationOfModels#cleaning-models","content":"It may happen that the metadata that GAMA maintains about the different projects (which includes the various markers on files in the workspace, etc.) becomes corrupted from time to time. This especially happens if you frequently switch workspaces, but not only. In those (hopefully rare) cases, GAMA may report incorrect errors for perfectly legible files. When such odd behaviors are detected, or if you want to regularly keep your metadata in a good shape, you can clean all your project, by clicking on the button &quot;Clear and validate all projects&quot; (in the syntax errors view).  "},{"title":"Workspace, Projects and Models","type":0,"sectionRef":"#","url":"wiki/WorkspaceProjectsAndModels","content":"Workspace, Projects and Models The workspace is a directory in which GAMA stores all the current projects on which the user is working, links to other projects, as well as some meta-data like preference settings, the current status of the different projects, error markers, and so on. Except when running in headless mode, GAMA cannot function without a valid workspace. The workspace is organized in 4 categories, which are themselves organized into projects. The projects present in the workspace can be either directly stored within it (as sub-directories), which is usually the case when the user creates a new project, or linked from it (so the workspace will only contain a link to the directory of the project, supposed to be somewhere in the filesystem or on the network). A same project can be linked from different workspaces. GAMA models files are stored in these projects, which may contain also other files (called resources) necessary for the models to function. A project may, of course, contain several model files, especially if they are importing each other, if they represent different views on the same topic, or if they share the same resources. Learning how to navigate in the workspace, how to switch workspace or how to import, export is a necessity to use GAMA correctly. It is the purpose of the following sections. Navigating in the WorkspaceChanging WorkspaceImporting Models","keywords":""},{"title":"Writing Unit Tests in GAML","type":0,"sectionRef":"#","url":"wiki/Writing_Tests","content":"","keywords":""},{"title":"What is test in GAML?​","type":1,"pageTitle":"Writing Unit Tests in GAML","url":"wiki/Writing_Tests#what-is-test-in-gaml","content":"In GAML, the statement test allows the modeler to write a part of code lines to verify if portions of our GAML model are doing exactly what they are expected to do: this is done through the use of several assertions (using assert statements). This is done independently from other parts of the model. To write a typical GAML unit test, we can follow three steps: Define a set of attributes to use within the test,Write initialization instructions,Write assertions.  The aim of using unit testing is to observe the resulting behavior of some parts of our model. If the observed behavior is consistent with the expectations, the unit test passes, otherwise, it fails, indicating that there is a problem concerning the tested part of the model. "},{"title":"Introduction to assertions​","type":1,"pageTitle":"Writing Unit Tests in GAML","url":"wiki/Writing_Tests#introduction-to-assertions","content":"The basis of Unit tests is to check that given pieces of codes provide expected results. To this purpose, the modeler can write some basic tests that should be true: s/he thus asserts that such expression can be evaluated to true using the assert statement. Here are some examples of assert uses: assert 1 + 1 = 2; assert isGreater(5, 6) = false; assert rnd(1.0) &lt;= 1.0;  With the above statements, the modeler states the 1+1 is equal to 2, isGreater(5,6) is false (given the fact that isGreater is an action defined in a species) and rnd(1.0) always returns a value below 1.0. assert can be used in any behavior statement (as an example in a reflex, a state or in a test. Note that, if they are written outside of a test and that the test is not fulfilled, then an exception is thrown during their execution. As an example, the following model throws the exception: Assert failed 3&gt;4 (as obviously 3 is not greater than 4 and that the GAML &gt; operator is properly implemented on this case). model NewModel global { init { assert 3 &gt; 4; } } experiment NewModel type: gui {}  To be able to have a dashboard of the state of your model w.r.t. the unit tests, they need to be written in a test and the model launched with an experiment of type test. "},{"title":"How to write a GAML test?​","type":1,"pageTitle":"Writing Unit Tests in GAML","url":"wiki/Writing_Tests#how-to-write-a-gaml-test","content":"A test statement can be used in any species (regular species, global or experiment species) everywhere a reflex can be used. Its aim is to gather several asserts in one block. If the tests are executed with any kind of experiment but test, they will be executed, but nothing is reported. With a test experiment, a kind of dashboard will be displayed. So we will consider that we start by adding an experiment with type set to test. The following code shows an example. experiment MyTest type: test autorun: true { ... }  Let's consider the following GAML code: model TestModel global { init { create test_agent number: 1; } } species test_agent { bool isGreater (int p1, int p2) { if (p1 &gt;= p2) { return true; } else { return false; } } test testsOK { assert isGreater(5, 6) = false; assert isGreater(6, 5) = true; } test failingTests { assert ! isGreater(6, 6); } } experiment MyTest type: test autorun: true { }  In this example, the defined action, isGreater, returns true if a parameter p1 is greater than a parameter p2 and false if not. So to test it, we declare a unit test using test and add inside several assert statements. For instance, assert isGreater(5, 6) = false; will return true if the result of isGreater(5, 6) is really false and false if not. So, if the action isGreater is well-defined, it should return false. Considering that &quot;greater&quot; and &quot;greater and equal&quot; should be two different functions, we add a test to check that isGreater does not return true in case of equality of its 2 operands. In this case, as the action is not-well implemented the test fails. The following picture illustrates the GUI dashboard for unit tests, showing for each test and even each assert whether it passes or fails. Clicking on the button will display in the GAML editor the code line.  "},{"title":"Use of the setup statement​","type":1,"pageTitle":"Writing Unit Tests in GAML","url":"wiki/Writing_Tests#use-of-the-setup-statement","content":"In a species where we want to execute several tests, it is common to want to have the same initial states, in order to prevent the previous tests to have modified the tested object and thus altering the unit test results. To this purpose, we can add the setup statement in the species and use it to set the expected initial state of the object to be tested. It will be called before every test. As an example, in the following model, we want to test the operator translated_by and translated_to on a point. As each of them will modify the point object to be tested, wed add a setup to reinitialize it. model TestModel global { geometry loc &lt;- {0,0}; setup { loc &lt;- {0,0}; } test translate_to { loc &lt;- loc translated_to {10,10}; loc &lt;- loc translated_to {10,10}; assert loc.location = {10,10}; } test translated_by { loc &lt;- loc translated_by {10,10}; loc &lt;- loc translated_by {10,10}; assert loc.location = {20,20}; } } experiment MyTest type: test autorun: true { }  "},{"title":"The test experiment​","type":1,"pageTitle":"Writing Unit Tests in GAML","url":"wiki/Writing_Tests#the-test-experiment","content":"It is also possible to write tests in the experiment. The main idea is here to totally separate the model and its tests. As an example let's consider the following GAML code, which aims to test several GAML operators, related to the graph datatype: model TestGraphs global { graph the_graph; init { int i &lt;- 10; create node_agent number: 7 { location &lt;- {i, i + ((i / 10) mod 2) * 10}; i &lt;- i + 10; } the_graph &lt;- as_distance_graph(node_agent, 30.0); } } species edge_agent { aspect default { draw shape color: #black; } } species node_agent { aspect default { draw circle(1) color: #red; loop neigh over: the_graph neighbors_of self { draw line([self.location, agent(neigh).location]) color: #black; } } } experiment loadgraph type: gui { output { display map type: opengl { species edge_agent; species node_agent; } } } experiment MyTest type: test autorun: true { test &quot;MyFirstTest&quot; { write the_graph; write (node_agent[2]); write (&quot;Degrees&quot;); write (the_graph in_degree_of (node_agent[2])); write (the_graph out_degree_of (node_agent[2])); write (the_graph degree_of (node_agent[2])); assert the_graph in_degree_of (node_agent[2]) = 4; write (the_graph out_degree_of (node_agent[2])); assert the_graph out_degree_of (node_agent[2]) = 4; assert the_graph degree_of (node_agent[2]) = 8; } }  "}]