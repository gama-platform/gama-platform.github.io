"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[15183],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),p=u(n),d=i,m=p["".concat(s,".").concat(d)]||p[d]||h[d]||r;return n?a.createElement(m,l(l({ref:t},c),{},{components:n})):a.createElement(m,l({ref:t},c))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=p;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var u=2;u<r;u++)l[u]=n[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},60817:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>u,toc:()=>h});var a=n(87462),i=n(63366),r=(n(67294),n(3905)),l=["components"],o={title:"Control Architectures"},s=void 0,u={unversionedId:"ControlArchitecture",id:"version-1.8.2-RC2/ControlArchitecture",title:"Control Architectures",description:"[//]: # (keyword|concept_architecture)",source:"@site/versioned_docs/version-1.8.2-RC2/ControlArchitecture.md",sourceDirName:".",slug:"/ControlArchitecture",permalink:"/wiki/ControlArchitecture",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/ControlArchitecture/_edit",tags:[],version:"1.8.2-RC2",frontMatter:{title:"Control Architectures"},sidebar:"side",previous:{title:"Multi-Paradigm Modeling",permalink:"/wiki/MultiParadigmModeling"},next:{title:"Using Differential Equations",permalink:"/wiki/DifferentialEquations"}},c={},h=[{value:"Index",id:"index",level:2},{value:"Finite State Machine",id:"finite-state-machine",level:2},{value:"Declaration",id:"declaration",level:3},{value:"<code>state</code> statement",id:"state-statement",level:3},{value:"Facets",id:"facets",level:4},{value:"Sub Statements",id:"sub-statements",level:4},{value:"Definition",id:"definition",level:4},{value:"Task-Based",id:"task-based",level:2},{value:"Declaration",id:"declaration-1",level:3},{value:"<code>task</code> statement",id:"task-statement",level:3},{value:"Facets",id:"facets-1",level:4},{value:"Definition",id:"definition-1",level:4},{value:"Rules-based architecture",id:"rules-based-architecture",level:2},{value:"Declaration",id:"declaration-2",level:3},{value:"<code>rule</code> statement",id:"rule-statement",level:3},{value:"facets",id:"facets-2",level:4},{value:"Definition",id:"definition-2",level:4},{value:"User Control Architecture",id:"user-control-architecture",level:2},{value:"<code>user_only</code>, <code>user_first</code>, <code>user_last</code>",id:"user_only-user_first-user_last",level:3},{value:"Additional attribute",id:"additional-attribute",level:3},{value:"<code>user_panel</code>",id:"user_panel",level:3},{value:"Other Control Architectures",id:"other-control-architectures",level:2}],p={toc:h};function d(e){var t=e.components,n=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"GAMA allows the modeler to attach built-in control architecture to agents."),(0,r.kt)("p",null,"These control architectures will give the possibility to the modeler to use for a species a specific control architecture in addition to the ",(0,r.kt)("a",{parentName:"p",href:"DefiningActionsAndBehaviors#Behaviour"},"common behavior structure"),". Note that only one control architecture can be used per species."),(0,r.kt)("p",null,"The attachment of a control architecture to a species is done through the facets ",(0,r.kt)("inlineCode",{parentName:"p"},"control"),"."),(0,r.kt)("p",null,"For example, the given code attaches the ",(0,r.kt)("inlineCode",{parentName:"p"},"fsm")," control architecture to the dummy species."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"species dummy control: fsm {\n}\n")),(0,r.kt)("p",null,"GAMA integrates several agent control architectures that can be used in addition to the common behavior structure:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#finite-state-machine"},"fsm"),": finite state machine based behavior model. During its life cycle, the agent can be in several states. At any given time step, it is in one single state. Such an agent needs to have one initial state (the state in which it will be at its initialization)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#task-based"},"weighted","_","tasks"),": task-based control architecture. At any given time, only the task with the maximal weight is executed."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#task-based"},"sorted","_","tasks"),": task-based control architecture. At any given time, the tasks are all executed in the order specified by their weights (highest first)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#task-based"},"probabilistic","_","tasks"),": task-based control architecture. This architecture uses the weights as a support for making a weighted probabilistic choice among the different tasks. If all tasks have the same weight, one is randomly chosen at each step."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#rules-based-architecture"},"rules"),": rules-based control architecture. This architecture uses a set of rules, that will be executed if a given condition is fulfilled and in an order defined by a priority."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#user_only-user_first-user_last"},"user","_","only"),": allows users to take control over an agent during the course of the simulation. With this architecture, only the user control the agents (no reflexes)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#user_only-user_first-user_last"},"user","_","first"),": allows users to take control over an agent during the course of the simulation. With this architecture, the user actions are executed before the agent reflexes."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#user_only-user_first-user_last"},"user","_","last"),": allows users to take control over an agent during the course of the simulation. With this architecture, the user actions are executed after the agent reflexes.")),(0,r.kt)("p",null,"An ",(0,r.kt)("a",{parentName:"p",href:"BuiltInArchitectures"},"exhaustive list of the architectures available with GAMA")," provides all the variables and additional actions provided by an architecture."),(0,r.kt)("h2",{id:"index"},"Index"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#finite-state-machine"},"Finite State Machine"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#declaration"},"Declaration")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#state-statement"},(0,r.kt)("inlineCode",{parentName:"a"},"state")," statement")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#task-based"},"Task Based"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#declaration"},"Declaration")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#task-statement"},(0,r.kt)("inlineCode",{parentName:"a"},"task"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#user-control-architectures"},"User Control Architecture"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#user_only-user_first-user_last"},"user_only, user_first, user_last")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#additional-attribute"},"Additional attribute")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#user_panel"},"user_panel")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#other-control-architectures"},"Other Control Architectures"))),(0,r.kt)("h2",{id:"finite-state-machine"},"Finite State Machine"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"FSM (Finite State Machine)")," is a finite state machine-based behavior model. During its life cycle, the agent can be in several states. At any given time step, it is in one single state. Such an agent needs to have one initial state (the state in which it will be at its initialization)."),(0,r.kt)("p",null,"At each time step, the agent will:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"first (only if he just entered in its current state) execute statement embedded in the ",(0,r.kt)("inlineCode",{parentName:"li"},"enter")," statement,"),(0,r.kt)("li",{parentName:"ul"},"then all the statements in the ",(0,r.kt)("inlineCode",{parentName:"li"},"state")," statement,"),(0,r.kt)("li",{parentName:"ul"},"it will evaluate the condition of each embedded ",(0,r.kt)("inlineCode",{parentName:"li"},"transition")," statements. If one condition is fulfilled, the agent executes the embedded statements.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note that an agent executes only one state at each step"),"."),(0,r.kt)("h3",{id:"declaration"},"Declaration"),(0,r.kt)("p",null,"Using the FSM architecture for a species require to use the ",(0,r.kt)("strong",{parentName:"p"},"control")," facet:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"species dummy control: fsm {\n   ...\n}\n")),(0,r.kt)("h3",{id:"state-statement"},(0,r.kt)("inlineCode",{parentName:"h3"},"state")," statement"),(0,r.kt)("h4",{id:"facets"},"Facets"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"initial"),": a boolean expression, indicates the initial state of the agent (only one state with ",(0,r.kt)("inlineCode",{parentName:"li"},"initial")," set to true is allowed in a species)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"final"),": a boolean expression, indicates the final state of the agent.")),(0,r.kt)("h4",{id:"sub-statements"},"Sub Statements"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"enter"),": a sequence of statements to execute upon entering the state."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"exit"),": a sequence of statements to execute right before exiting the state. Note that the ",(0,r.kt)("inlineCode",{parentName:"li"},"exit")," statement will be executed even if the fired transition points to the same state (the FSM architecture in GAMA does not implement 'internal transitions' like the ones found in UML statecharts: all transitions, even \"self-transitions\", follow the same rules)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"transition"),": allows to define a condition that, when evaluated to true, will designate the next state of the life-cycle. Note that the evaluation of transitions is short-circuited: the first one that evaluates to true, in the order in which they have been defined, will be followed. I.e., if two transitions evaluate to true during the same time step, only the first one will be triggered.")),(0,r.kt)("p",null,"Things worth to be mentioned regarding these sub-statements:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Obviously, only one definition of ",(0,r.kt)("inlineCode",{parentName:"li"},"exit")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"enter")," is accepted in a given ",(0,r.kt)("inlineCode",{parentName:"li"},"state"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"transition"),' statements written in the middle of the state statements will only be evaluated at the end, so, even if it evaluates to true, the remaining of the statements found after the definition of the transition will be nevertheless executed. So, despite the appearance, a transition written somewhere in the sequence will "not stop" the state at that point (but only at the end).')),(0,r.kt)("h4",{id:"definition"},"Definition"),(0,r.kt)("p",null,"A state can contain several statements that will be executed, at each time step, by the agent. There are three exceptions to this rule:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"statements enclosed in ",(0,r.kt)("inlineCode",{parentName:"li"},"enter")," will only be executed when the state is entered (after a transition, or because it is the initial state)."),(0,r.kt)("li",{parentName:"ol"},"Those enclosed in ",(0,r.kt)("inlineCode",{parentName:"li"},"exit")," will be executed when leaving the state as a result of a successful transition (and before the statements enclosed in the transition)."),(0,r.kt)("li",{parentName:"ol"},"Those enclosed in a transition will be executed when performing this transition (but after the ",(0,r.kt)("inlineCode",{parentName:"li"},"exit")," sequence has been executed).")),(0,r.kt)("p",null,"For example, consider the following example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'species dummy control: fsm {       \n    state state1 initial: true { \n    write string(cycle) + ":" + name + "->" + "state1";\n    transition to: state2 when: flip(0.5) {\n        write string(cycle) + ":" + name + "->" + "transition to state1";\n    }\n    transition to: state3 when: flip(0.2) ; \n    }\n\n    state state2 {\n    write string(cycle) + ":" + name + "->" + "state2";\n    transition to: state1 when: flip(0.5) { \n        write string(cycle) + ":" + name + "->" + "transition to state1";\n    }\n    exit {\n        write string(cycle) + ":" + name + "->" + "leave state2";\n    }\n    }\n    \n    state state3 {\n    write string(cycle) + ":" + name + "->" + "state3";\n    transition to: state1 when: flip(0.5)  {\n        write string(cycle) + ":" + name + "->" + "transition to state1";\n    }\n    transition to: state2 when: flip(0.2)  ;\n    }   \n}\n')),(0,r.kt)("p",null,"The dummy agents start at ",(0,r.kt)("em",{parentName:"p"},"state1"),". At each simulation step, they have a probability of 0.5 to change their state to ",(0,r.kt)("em",{parentName:"p"},"state2"),". If they do not change their state to ",(0,r.kt)("em",{parentName:"p"},"state2"),", they have a probability of 0.2 to change their state to ",(0,r.kt)("em",{parentName:"p"},"state3"),". In ",(0,r.kt)("em",{parentName:"p"},"state2"),", at each simulation step, they have a probability of 0.5 to change their state to ",(0,r.kt)("em",{parentName:"p"},"state1"),". At last, in ",(0,r.kt)("em",{parentName:"p"},"step3"),", at each simulation step, they have a probability of 0.5 to change their state to ",(0,r.kt)("em",{parentName:"p"},"state1"),". If they do not change their state to ",(0,r.kt)("em",{parentName:"p"},"state1"),", they have a probability of 0.2 to change their state to ",(0,r.kt)("em",{parentName:"p"},"state2"),"."),(0,r.kt)("p",null,"Here a possible result that can be obtained with one dummy agent:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0:dummy0->state1\n0:dummy0->transition to state1\n1:dummy0->state2\n2:dummy0->state2\n2:dummy0->leave state2\n2:dummy0->transition to state1\n3:dummy0->state1\n3:dummy0->transition to state1\n4:dummy0->state2\n5:dummy0->state2\n5:dummy0->leave state2\n5:dummy0->transition to state1\n6:dummy0->state1\n7:dummy0->state3\n8:dummy0->state2\n")),(0,r.kt)("h2",{id:"task-based"},"Task-Based"),(0,r.kt)("p",null,"GAMA integrated several ",(0,r.kt)("strong",{parentName:"p"},"task-based")," control architectures. Species can define any number of tasks within their body. At any given time, only one or several tasks are executed according to the architecture chosen:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"weighted_tasks"),": in this architecture, only the task with the maximal weight is executed."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"sorted_tasks"),": in this architecture, the tasks are all executed in the order specified by their weights (biggest first)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"probabilistic_tasks"),": this architecture uses the weights as a support for making a weighted probabilistic choice among the different tasks. If all tasks have the same weight, one is randomly chosen each step.")),(0,r.kt)("h3",{id:"declaration-1"},"Declaration"),(0,r.kt)("p",null,"Using one of the task architectures for a species requires to use the ",(0,r.kt)("strong",{parentName:"p"},"control")," facet:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"species dummy control: weighted_tasks {\n   ...\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"species dummy control: sorted_tasks {\n   ...\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"species dummy control: probabilistic_tasks {\n   ...\n}\n")),(0,r.kt)("h3",{id:"task-statement"},(0,r.kt)("inlineCode",{parentName:"h3"},"task")," statement"),(0,r.kt)("h4",{id:"facets-1"},"Facets"),(0,r.kt)("p",null,"Besides a sequence of statements like ",(0,r.kt)("inlineCode",{parentName:"p"},"reflex"),", a task contains the following additional facet:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"weight"),": Mandatory. The priority level of the task.")),(0,r.kt)("h4",{id:"definition-1"},"Definition"),(0,r.kt)("p",null,"As ",(0,r.kt)("inlineCode",{parentName:"p"},"reflex"),", a ",(0,r.kt)("inlineCode",{parentName:"p"},"task")," is a sequence of statements that can be executed, at each time step, by the agent. If an agent owns several tasks, the scheduler chooses a task to execute based on its current priority weight value."),(0,r.kt)("p",null,"For example, consider the following example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'species dummy control: weighted_tasks {   \n    task task1 weight: cycle mod 3 { \n    write string(cycle) + ":" + name + "->" + "task1";\n    }\n    task task2 weight: 2 { \n    write string(cycle) + ":" + name + "->" + "task2";\n    }\n}\n')),(0,r.kt)("p",null,"As the ",(0,r.kt)("strong",{parentName:"p"},"weighted","_","tasks")," control architecture was chosen, at each simulation step, the dummy agents execute only the task with the highest behavior. Thus,  when ",(0,r.kt)("em",{parentName:"p"},"cycle modulo 3")," is higher to 2, task1 is executed; when ",(0,r.kt)("em",{parentName:"p"},"cycle modulo 3")," is lower than 2, task2 is executed. In case when ",(0,r.kt)("em",{parentName:"p"},"cycle modulo 3")," is equal 2 (at cycle 2, 5, ...), the only the first task defined (here task1) is executed."),(0,r.kt)("p",null,"Here the result obtained with one dummy agent:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0:dummy0->task2\n1:dummy0->task2\n2:dummy0->task1\n3:dummy0->task2\n4:dummy0->task2\n5:dummy0->task1\n6:dummy0->task2\n")),(0,r.kt)("h2",{id:"rules-based-architecture"},"Rules-based architecture"),(0,r.kt)("p",null,"The behavior of an agent with the rules-based architecture can contain ",(0,r.kt)("inlineCode",{parentName:"p"},"reflex")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"rule")," statements. The ",(0,r.kt)("inlineCode",{parentName:"p"},"reflex")," block will always be executed first. Then the rules are fired (executed) when their condition becomes true and in the order defined by their decreasing priorities. "),(0,r.kt)("h3",{id:"declaration-2"},"Declaration"),(0,r.kt)("p",null,"Using the rules-based architectures for a species requires to use the ",(0,r.kt)("strong",{parentName:"p"},"control")," facet:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"species dummy control: rules {\n   ...\n}\n")),(0,r.kt)("h3",{id:"rule-statement"},(0,r.kt)("inlineCode",{parentName:"h3"},"rule")," statement"),(0,r.kt)("h4",{id:"facets-2"},"facets"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"when"),": (boolean), the condition that needs to be fulfilled to execute the rule."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"priority"),": (float), an optional priority for the rule, which is used to sort activable rules and run them in that order.")),(0,r.kt)("h4",{id:"definition-2"},"Definition"),(0,r.kt)("p",null,"As ",(0,r.kt)("inlineCode",{parentName:"p"},"reflex"),", a ",(0,r.kt)("inlineCode",{parentName:"p"},"rule")," is a sequence of statements that can be executed, at each time step, by the agent. They are executed if and only if their condition expression (",(0,r.kt)("inlineCode",{parentName:"p"},"when")," facet) is fulfilled. Among all the rules that fulfill their condition, the tasks are executed in the decreasing order of their priority (",(0,r.kt)("inlineCode",{parentName:"p"},"priority")," facet)."),(0,r.kt)("p",null,"For example, consider the following example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'species simple_rules_statements control: rules {\n    \n    int priority_of_a <- 0 update: rnd(100);\n    int priority_of_b <- 0 update: rnd(100);\n    \n    reflex show_priorities {\n    write "Priority of rule a = " + priority_of_a + ", priority of rule b = " + priority_of_b;\n    }\n\n    rule a when: priority_of_a < 50 priority: priority_of_a {\n    write "  Rule a fired with priority: " + priority_of_a;\n    }\n    \n    rule b when: priority_of_b > 25 priority: priority_of_b {\n    write "  Rule b fired with priority: " + priority_of_b;\n    }\n}\n')),(0,r.kt)("p",null,"At each simulation step, first, the agents update the priority values associated with the rules. The ",(0,r.kt)("inlineCode",{parentName:"p"},"reflex")," will first display these values. Then the conditions are evaluated and the rules that can be executed are executed in their priority order."),(0,r.kt)("p",null,"Here a possible result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Priority of rule a = 38, priority of rule b = 32\n  Rule a fired with priority: 38\n  Rule b fired with priority: 32\nPriority of rule a = 91, priority of rule b = 32\n  Rule b fired with priority: 32\nPriority of rule a = 37, priority of rule b = 2\n  Rule a fired with priority: 37\nPriority of rule a = 77, priority of rule b = 90\n  Rule b fired with priority: 90\nPriority of rule a = 32, priority of rule b = 23\n  Rule a fired with priority: 32\nPriority of rule a = 18, priority of rule b = 7\n  Rule a fired with priority: 18\nPriority of rule a = 95, priority of rule b = 94\n  Rule b fired with priority: 94\nPriority of rule a = 20, priority of rule b = 5\n  Rule a fired with priority: 20\nPriority of rule a = 78, priority of rule b = 47\n  Rule b fired with priority: 47\nPriority of rule a = 77, priority of rule b = 76\n  Rule b fired with priority: 76\n")),(0,r.kt)("h2",{id:"user-control-architecture"},"User Control Architecture"),(0,r.kt)("h3",{id:"user_only-user_first-user_last"},(0,r.kt)("inlineCode",{parentName:"h3"},"user_only"),", ",(0,r.kt)("inlineCode",{parentName:"h3"},"user_first"),", ",(0,r.kt)("inlineCode",{parentName:"h3"},"user_last")),(0,r.kt)("p",null,"A specific type of control architecture has been introduced to allow users to take control of an agent during the course of the simulation. When the user gets control of the agent, a control panel will appear in the interface. This architecture can be invoked using three different keywords: ",(0,r.kt)("inlineCode",{parentName:"p"},"user_only"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"user_first"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"user_last"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"species user control: user_only {\n   ...\n}\n")),(0,r.kt)("p",null,"If the control chosen is ",(0,r.kt)("inlineCode",{parentName:"p"},"user_first"),', it means that the user-controlled panel is opened first, and then the agent has a chance to run its "own" behaviors (reflexes, essentially, or "init" in the case of a "user',"_",'init" panel).\nIf the control chosen is ',(0,r.kt)("inlineCode",{parentName:"p"},"user_last"),", it is the contrary."),(0,r.kt)("h3",{id:"additional-attribute"},"Additional attribute"),(0,r.kt)("p",null,"Each agent provided with this architecture inherits a boolean attribute called ",(0,r.kt)("inlineCode",{parentName:"p"},"user_controlled"),'. If this attribute becomes false, no panels will be displayed and the agent will run "normally" unless its species is defined with a ',(0,r.kt)("inlineCode",{parentName:"p"},"user_only")," control."),(0,r.kt)("h3",{id:"user_panel"},(0,r.kt)("inlineCode",{parentName:"h3"},"user_panel")),(0,r.kt)("p",null,'This control architecture is a specialization of the Finite State Machine Architecture where the "behaviors" of agents can be defined by using new constructs called ',(0,r.kt)("inlineCode",{parentName:"p"},"user_panel")," (and one ",(0,r.kt)("inlineCode",{parentName:"p"},"user_init"),"), mixed with ",(0,r.kt)("inlineCode",{parentName:"p"},"state")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"reflex"),". This ",(0,r.kt)("inlineCode",{parentName:"p"},"user_panel")," translates, in the interface, in a semi-modal view that awaits the user to choose action buttons, change attributes of the controlled agent, etc. Each ",(0,r.kt)("inlineCode",{parentName:"p"},"user_panel"),", like a ",(0,r.kt)("inlineCode",{parentName:"p"},"state")," in FSM, can have an ",(0,r.kt)("inlineCode",{parentName:"p"},"enter")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"exit")," sections, but it is only defined in terms of a set of ",(0,r.kt)("inlineCode",{parentName:"p"},"user_command"),"s which describe the different action buttons present in the panel."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"user_command")," can also accept inputs, in order to create more interesting commands for the user. This uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"user_input")," statement (and not operator), which is basically the same as a temporary variable declaration whose value is asked to the user. "),(0,r.kt)("p",null,"As ",(0,r.kt)("inlineCode",{parentName:"p"},"user_panel")," is a specialization of ",(0,r.kt)("inlineCode",{parentName:"p"},"state"),", the modeler has the possibility to describe several panels and choose the one to open depending on some condition, using the same syntax than for finite state machines:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"either adding ",(0,r.kt)("inlineCode",{parentName:"li"},"transitions")," to the user","_","panels,"),(0,r.kt)("li",{parentName:"ul"},"or setting the ",(0,r.kt)("inlineCode",{parentName:"li"},"state")," attribute to a new value, from inside or from another agent.")),(0,r.kt)("p",null,"This ensures great flexibility for the design of the user interface proposed to the user, as it can be adapted to the different stages of the simulation, etc..."),(0,r.kt)("p",null,'Follows a simple example, where, every 10 steps, and depending on the value of an attribute called "advanced", either the basic or the advanced panel is proposed. (The full model is provided in the GAMA model library.)'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'species user control:user_only {\n   user_panel default initial: true {\n      transition to: "Basic Control" when: every (10 #cycles) and !advanced_user_control;\n      transition to: "Advanced Control" when: every(10 #cycles) and advanced_user_control;\n   }\n   \n   user_panel "Basic Control" {\n      user_command "Kill one cell" {\n         ask (one_of(cell)){\n            do die;\n         }\n      }\n      user_command "Create one cell" {\n        create cell ;\n      } \n      transition to: default when: true;\n   }\n   user_panel "Advanced Control" {\n      user_command "Kill cells" {\n        user_input "Number" returns: number type: int <- 10;\n        ask (number among cell){\n           do die;\n        }\n      }\n      user_command "Create cells" {\n        user_input "Number" returns: number type: int <- 10;\n        create cell number: number ;\n      } \n      transition to: default when: true;\n   }\n}\n')),(0,r.kt)("p",null,"The panel marked with the ",(0,r.kt)("inlineCode",{parentName:"p"},"initial: true")," facet will be the one run first when the agent is supposed to run. If none is marked, the first panel (in their definition order) is chosen."),(0,r.kt)("p",null,"A special panel called ",(0,r.kt)("inlineCode",{parentName:"p"},"user_init")," will be invoked only once when initializing the agent if it is defined.\nIf no panel is described or if all panels are empty (i.e. no ",(0,r.kt)("inlineCode",{parentName:"p"},"user_command"),"), the control view is never invoked. If the control is said to be ",(0,r.kt)("inlineCode",{parentName:"p"},"user_only"),", the agent will then not run any of its behaviors."),(0,r.kt)("h2",{id:"other-control-architectures"},"Other Control Architectures"),(0,r.kt)("p",null,"Some other control architectures are available in additional plugins. For instance, ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gama-platform/gama/wiki/BDIAgents"},"BDI (Belief, desire, intention) architecture")," is available. Feel free to read about it if you want to learn more."),(0,r.kt)("p",null,"Do you need some other control architectures for your model? Feel free to make your suggestion to the team of developers through the ",(0,r.kt)("a",{parentName:"p",href:"https://groups.google.com/forum/#!forum/gama-platform"},"mailing list"),". Remember also that GAMA is an open-source platform, you can design your own control architecture easily. Go to the section Community/contribute if you want to jump into coding!"))}d.isMDXComponent=!0}}]);