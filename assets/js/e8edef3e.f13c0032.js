"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[83659],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>f});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),c=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},h=function(e){var t=c(e.components);return i.createElement(s.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},g=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),d=c(n),g=a,f=d["".concat(s,".").concat(g)]||d[g]||p[g]||o;return n?i.createElement(f,r(r({ref:t},h),{},{components:n})):i.createElement(f,r({ref:t},h))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=g;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:a,r[1]=l;for(var c=2;c<o;c++)r[c]=n[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}g.displayName="MDXCreateElement"},42672:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>s,default:()=>f,frontMatter:()=>l,metadata:()=>c,toc:()=>d});var i=n(87462),a=n(63366),o=(n(67294),n(3905)),r=["components"],l={"^title":"PlayPool"},s=void 0,c={unversionedId:"PlayPool",id:"PlayPool",title:"PlayPool",description:"Path: Plugin models/Physics Engine/models/Play Pool.gaml",source:"@site/../docs/PlayPool.md",sourceDirName:".",slug:"/PlayPool",permalink:"/wiki/next/PlayPool",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/PlayPool/_edit",tags:[],version:"current",frontMatter:{"^title":"PlayPool"}},h={},d=[],p={toc:d},g="wrapper";function f(e){var t=e.components,n=(0,a.Z)(e,r);return(0,o.kt)(g,(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("img",{width:"960",alt:"Annotation 2023-04-15 184506_playpool",src:"https://user-images.githubusercontent.com/4437331/232238771-6cdcfb07-f41b-497d-a335-89e6281a655a.png"}),(0,o.kt)("p",null,"Path: Plugin models/Physics Engine/models/Play Pool.gaml"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'\n/**\n* Name: Pool using Physics Engine\n* Author: Arnaud Grignard (2012) --revised by Alexis Drogoul (2021)\n* Description: This is a model that allows the user to play a (simplistic) game of pool in order to show how the physics engine works. It also\n* demonstrates the effect of different physical properties (friction, restitution, etc.) \n*\n* Tags: physics_engine, skill, 3d, spatial_computation, obstacle\n*/\nmodel pool3D\n\n/**\n * The model is inheriting from \'physical_world\' a special model species that provides access to the physics engine -- and the possibility\n * to manage physical agents. In this model, the world itself is not a physical agent but all the other agents (balls and walls) are \n * automatically registered (thanks to the default value of \'true\' of the variable \'automated_registration\').\n */\nglobal parent: physical_world {\n    // The dynamics of the agents is a bit different if we use the native (3.0.x) or Java version (2.8.x) of Bullet\n    bool use_native <- false;\n    bool draw_aabb <- false;\n    string library <- "bullet";\n    //All the physical characteristics of the balls can be accessed here and modified at will by the user\n    float ball_damping <- 0.05 min: 0.0 max: 1.0 on_change: {ask ball {damping<-ball_damping;}};\n    float ball_restitution <- 0.8  min: 0.0 max: 1.0 on_change: {ask ball {restitution<-ball_restitution;}};\n    float ball_friction <- 0.2  min: 0.0 max: 1.0 on_change: {ask ball {friction<-ball_friction;}};\n    float wall_restitution <- 0.7  min: 0.0 max: 1.0 on_change: {ask wall {restitution<-wall_restitution;}};\n    float wall_friction <- 0.2  min: 0.0 max: 1.0 on_change: {ask wall {friction<-wall_friction;}};\n    float ground_friction <- 0.6  min: 0.0 max: 1.0 on_change: {ask ground {friction<-ground_friction;}};\n    float strength <- 120.0  min: 0.0 max: 200.0;\n    int width <- 200;\n    int height <- 300;\n    //Given that very few agents inhabit this world, the step is really small, so as to prevent the physical world to go too fast. \n    //The simulation itself is aligned with this number (see experiment.minimum_cycle_duration)\n    float step <-1.0/120;\n    //Gives access (or not) to an improved (but slower) detection collision algorithm\n    bool better_collision_detection <- false;\n    // Artificially high gravity to make sure that the balls stay on the ground\n    point gravity <- {0,0,-20};\n\n\n    //Physical Engine\n    geometry shape <- rectangle(width, height);\n    ball white;\n    point target;\n\n    init {\n\n        float floor <- -4.0;\n        float depth <- 4.0;\n        create ground from: [\n            box({width - 20, height - 24, depth}) at_location {width / 2, height / 2, floor}, \n            box({width - 20, 20, depth}) at_location {width / 2, 6, floor}, \n            box({width - 20, 20, depth}) at_location {width / 2, height - 6, floor}, \n            box({20, height / 2 - 18, depth}) at_location {6, height / 4 + 3, floor}, \n            box({20, height / 2 - 18, depth}) at_location {6, 3 * height / 4 - 3, floor}, \n            box({20, height / 2 - 18, depth}) at_location {width - 6, height / 4 + 3, floor}, \n            box({20, height / 2 - 18, depth}) at_location {width - 6, 3 * height / 4 - 3, floor}\n        ];\n                \n        float section <- 10.0;\n        float z <- section + section/4;\n        create wall from: [\n            line([{0,height + section/2,z}, {width,height + section/2,z}], section/2), //down\n            line([{0,-section/2,z}, {width,-section/2,z}], section/2), // up\n            line([{-section/2,-section/2,z}, {-section/2,height + section/2, z}], section/2), // left\n            line([{width+section/2,-section/2,z}, {width+section/2,height + section/2, z}], section/2) // right\n\n        ];\n        \n        create wall with: [inside::true] from: [\n            box(width+3*section/2, section/2, section) at_location {width / 2, height + section/2, 0}, // down\n            box(width+3*section/2, section/2, section) at_location {width / 2,  -section/2, 0}, // up\n            box(section/2, height +  section, section) at_location {-section/2, height / 2, 0}, // left\n            box(section/2, height + section, section) at_location {width + section/2, height / 2, 0} // right\n        ];\n\n        \n        do create_white_ball;\n\n        int deltaI <- 0;\n        int initX <- 75;\n        int initY <- int(height / 8);\n        int i <- 0;\n\n        //Create the other balls for the pool\n        create ball number: 15 {\n            location <- {initX + (i - deltaI) * 10, initY, 0};\n            i <- i + 1;\n            color <- (i mod 2) = 0 ? #red :  #yellow;\n            if (i in [5, 9, 12, 14]) {\n                initX <- initX + 5;\n                initY <- initY + 9;\n                deltaI <- i;\n            }\n\n        }\n\n    }\n    \n    action create_white_ball {\n        create ball {\n            location <- {width / 2, 4 * height / 5, 0};\n            white <- self;\n        }\n    }\n\n}\n\n//Species representing the ground agents used for the computation of the forces, using the skill static_body\nspecies ground skills: [static_body] {\n    float friction <- ground_friction;\n}\n\n//Species representing the wall agents of the pool using the skill static_body\nspecies wall skills: [static_body] {\n    bool inside;\n    float friction <- wall_friction;\n    float restitution <- wall_restitution;  \n    \n    aspect default {\n        if (inside) {\n            draw shape color: (#darkgreen);\n        } else {\n            draw shape texture: "../images/wood.jpg";\n        }\n        \n        if (draw_aabb) {draw aabb wireframe: true border: #lightblue;}\n\n    }\n}\n\n//Species representing the ball agents, provided with dynamic_body capabilities (a mass, a velocity, damping ...)\nspecies ball skills: [dynamic_body] {\n    rgb color <- #white;\n    float mass <-2.0;\n    geometry shape <- sphere(5);\n    float friction <- ball_friction;\n    float restitution <- ball_restitution;\n    float damping <- ball_damping;\n    float angular_damping <- 0.0;\n    float contact_damping <- 0.0;\n    \n    // If any ball falls or goes away, it is destroyed, except the white ball, replaced on the table\n    reflex manage_location when: location.z < -20 {\n        if (self = white) {\n            ask world {\n                do create_white_ball;\n            }\n            target <- nil;\n        }\n        do die;\n    }\n\n    aspect default {\n        draw  sphere(5) color: color;\n        if (draw_aabb) {draw aabb wireframe: true border: #lightblue;}\n\n    }\n\n}\n\nexperiment "Play !" type: gui autorun: true   {\n    parameter "Ball Restitution" var: ball_restitution category: "Ball properties" ;\n    parameter "Ball Damping (natural deceleration)" var: ball_damping category: "Ball properties" ;\n    parameter "Ball Friction" var: ball_friction category: "Ball properties" ;\n    parameter "Wall Restitution" var: wall_restitution category: "Wall properties" ;\n    parameter "Wall Friction" var: wall_friction category: "Wall properties" ;\n    parameter "Ground Friction" var: ground_friction category: "Ground properties";\n    parameter "Strength" var: strength category: "Player properties";\n    parameter "Draw bounding boxes" var: draw_aabb category: "General";\n    \n    // Ensure that the simulation does not go too fast\n    float minimum_cycle_duration <- 1.0/120;\n    \n    action _init_ {\n        // A trick to make sure the parameters are expanded and visible when the simulation is launched.\n        bool previous <- gama.pref_experiment_expand_params;\n        gama.pref_experiment_expand_params <- true;\n        create simulation;\n        gama.pref_experiment_expand_params <- previous;\n    }\n    \n    output {\n        display Pool type: 3d antialias: false axes: false{\n            camera #default location: {100.0,400.0,300.0} target: {width/2,height/2,-20.0};\n            light #ambient intensity: 180;\n            light #default intensity: 180 direction: {0.5, 0.5, -1};\n            graphics user {\n                if (white != nil) and (target != nil) {\n                    draw line(white, target) color: #white end_arrow: 3;\n                }\n                if target = nil {\n                    draw "Choose a target" color: #white font: font("Helvetica", 30, #bold) at: location + {0, 0, 10} perspective: false anchor: #center;\n                }\n            }\n\n            event #mouse_down  {\n                target <- #user_location;\n                float divisor <- distance_to(target, white.location);\n                point direction <- (target - white.location) /divisor;\n                // When the user hits the mouse, we apply an impulse to the while ball, in the direction of the target. \'velocity\' could also be used here\n                ask white {\n                    do apply impulse: {strength * direction.x * 4, strength * direction.y * 4, 0};\n                }\n            }\n            event #mouse_move {\n                target <- #user_location;   \n            }\n            species ground refresh: false {\n                draw shape texture: image_file("../images/mat.jpg");\n                if (draw_aabb) {draw aabb wireframe: true border: #lightblue;}\n            }\n            species wall refresh:false;\n            species ball;\n        }\n\n    }\n\n}\n\n')))}f.isMDXComponent=!0}}]);