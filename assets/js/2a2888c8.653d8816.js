"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[81979],{3905:(n,e,t)=>{t.d(e,{Zo:()=>c,kt:()=>u});var o=t(67294);function a(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function r(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,o)}return t}function i(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?r(Object(t),!0).forEach((function(e){a(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function s(n,e){if(null==n)return{};var t,o,a=function(n,e){if(null==n)return{};var t,o,a={},r=Object.keys(n);for(o=0;o<r.length;o++)t=r[o],e.indexOf(t)>=0||(a[t]=n[t]);return a}(n,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(o=0;o<r.length;o++)t=r[o],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(a[t]=n[t])}return a}var l=o.createContext({}),d=function(n){var e=o.useContext(l),t=e;return n&&(t="function"==typeof n?n(e):i(i({},e),n)),t},c=function(n){var e=d(n.components);return o.createElement(l.Provider,{value:e},n.children)},p="mdxType",f={inlineCode:"code",wrapper:function(n){var e=n.children;return o.createElement(o.Fragment,{},e)}},g=o.forwardRef((function(n,e){var t=n.components,a=n.mdxType,r=n.originalType,l=n.parentName,c=s(n,["components","mdxType","originalType","parentName"]),p=d(t),g=a,u=p["".concat(l,".").concat(g)]||p[g]||f[g]||r;return t?o.createElement(u,i(i({ref:e},c),{},{components:t})):o.createElement(u,i({ref:e},c))}));function u(n,e){var t=arguments,a=e&&e.mdxType;if("string"==typeof n||a){var r=t.length,i=new Array(r);i[0]=g;var s={};for(var l in e)hasOwnProperty.call(e,l)&&(s[l]=e[l]);s.originalType=n,s[p]="string"==typeof n?n:a,i[1]=s;for(var d=2;d<r;d++)i[d]=t[d];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}g.displayName="MDXCreateElement"},21364:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>d,toc:()=>p});var o=t(87462),a=t(63366),r=(t(67294),t(3905)),i=["components"],s={"^title":"AntsForaging"},l=void 0,d={unversionedId:"AntsForaging.gaml",id:"AntsForaging.gaml",title:"AntsForaging.gaml",description:"Path: Library models/Toy Models/Ants (Foraging and Sorting)/models/Ant Foraging.gaml",source:"@site/../docs/AntsForaging.gaml.md",sourceDirName:".",slug:"/AntsForaging.gaml",permalink:"/wiki/next/AntsForaging.gaml",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/AntsForaging.gaml/_edit",tags:[],version:"current",frontMatter:{"^title":"AntsForaging"}},c={},p=[],f={toc:p},g="wrapper";function u(n){var e=n.components,t=(0,a.Z)(n,i);return(0,r.kt)(g,(0,o.Z)({},f,t,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("img",{width:"960",alt:"Annotation 2023-04-14 182942_AntForaging",src:"https://user-images.githubusercontent.com/4437331/232103699-b1b21e2f-c178-4e84-96f5-de945a87c715.png"}),(0,r.kt)("p",null,"Path: Library models/Toy Models/Ants (Foraging and Sorting)/models/Ant Foraging.gaml"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"\n/**\n* Name: Ant Foraging (Complex)\n* Author: \n* Description: Toy Model ant using the question of how ants search food and use pheromons to return to their \n* nest once they did find food. \n* Tags: gui, fsm, grid, diffusion\n*/\n@no_warning\nmodel ants\n\nglobal {\n//Utilities\n    bool use_icons <- true;\n    bool display_state <- false;\n    //Evaporation value per cycle\n    float evaporation_per_cycle <- 5.0 min: 0.0 max: 240.0 parameter: 'Evaporation of the signal (unit/cycle):' category: 'Signals';\n    //Diffusion rate of the pheromon among the grid\n    float diffusion_rate <- 1.0 min: 0.0 max: 1.0 parameter: 'Rate of diffusion of the signal (%/cycle):' category: 'Signals';\n    //Size of the grid\n    int gridsize <- 100 min: 30 parameter: 'Width and Height of the grid:' category: 'Environment and Population';\n    //Number of ants\n    int ants_number <- 200 min: 1 parameter: 'Number of ants:' category: 'Environment and Population';\n    //Frequency of update of the grid\n    int grid_frequency <- 1 min: 1 max: 100 parameter: 'Grid updates itself every:' category: 'Environment and Population';\n    //Number of food places among the grid\n    int number_of_food_places <- 5 min: 1 parameter: 'Number of food depots:' category: 'Environment and Population';\n    float grid_transparency <- 1.0;\n    image_file ant_shape const: true <- file('../images/ant.png');\n    svg_file ant_shape_svg const: true <- svg_file(\"../images/ant.svg\");\n    obj_file ant3D_shape const: true <- obj_file('../images/fire-ant.obj', '../images/fire-ant.mtl', -90::{1, 0, 0});\n    font regular <- font(\"Helvetica\", 14, #bold);\n    font bigger <- font(\"Helvetica\", 18, #bold);\n\n    //The center of the grid that will be considered as the nest location\n    point center const: true <- {round(gridsize / 2), round(gridsize / 2)};\n    int food_gathered <- 1;\n    int food_placed <- 1;\n    rgb background const: true <- rgb(99, 200, 66);\n    rgb food_color const: true <- rgb(31, 22, 0);\n    rgb nest_color const: true <- rgb(0, 0, 0);\n    geometry shape <- square(gridsize);\n    image_file terrain <- image_file(\"../images/soil.jpg\");\n    matrix<float> grid_values <- matrix<float>(as_matrix(terrain, {gridsize, gridsize}));\n\n    init {\n\n    // Normalization of the grid values\n        float min <- min(grid_values);\n        float max <- max(grid_values);\n        float range <- (max - min) / 2.5;\n        loop i from: 0 to: gridsize - 1 {\n            loop j from: 0 to: gridsize - 1 {\n                grid_values[i, j] <- (grid_values[i, j] - min) / range;\n            }\n\n        }\n\n        //Creation of the food places placed randomly with a certain distance between each\n        loop times: number_of_food_places {\n            point loc <- {rnd(gridsize - 10) + 5, rnd(gridsize - 10) + 5};\n            list<ant_grid> food_places <- (ant_grid where ((each distance_to loc) < 5));\n            ask food_places {\n                if food = 0 {\n                    food <- 5;\n                    food_placed <- food_placed + 5;\n                    color <- food_color;\n                }\n\n            }\n\n        }\n        //Creation of the ants that will be placed in the nest\n        create ant number: ants_number with: (location: center);\n    }\n    //Reflex to diffuse the pheromon among the grid\n    reflex diffuse {\n        diffuse var: road on: ant_grid proportion: diffusion_rate radius: 3 propagation: gradient method: convolution;\n    } }\n\n    //Grid used to discretize the space to place food\ngrid ant_grid width: gridsize height: gridsize neighbors: 8 frequency: grid_frequency use_regular_agents: false use_individual_shapes: false {\n    bool is_nest const: true <- (topology(ant_grid) distance_between [self, center]) < 4;\n    float road <- 0.0 max: 240.0 update: (road <= evaporation_per_cycle) ? 0.0 : road - evaporation_per_cycle;\n    rgb color <- is_nest ? nest_color : ((food > 0) ? food_color : ((road < 0.001) ? background : rgb(0, 99, 0) + int(road * 5))) update: is_nest ? nest_color : ((food > 0) ?\n    food_color : ((road < 0.001) ? background : rgb(0, 99, 0) + int(road * 5)));\n    int food <- 0;\n}\n//Species ant that will move and follow a final state machine\nspecies ant skills: [moving] control: fsm {\n    float speed <- 1.0;\n    bool has_food <- false;\n\n    //Reflex to place a pheromon stock in the cell\n    reflex diffuse_road when: has_food = true {\n        ant_grid(location).road <- ant_grid(location).road + 100.0;\n    }\n    //Action to pick food\n    action pick (int amount) {\n        has_food <- true;\n        ant_grid place <- ant_grid(location);\n        place.food <- place.food - amount;\n    }\n    //Action to drop food\n    action drop {\n        food_gathered <- food_gathered + 1;\n        has_food <- false;\n        heading <- heading - 180;\n    }\n    //Action to find the best place in the neighborhood cells\n    point choose_best_place {\n        container list_places <- ant_grid(location).neighbors;\n        if (list_places count (each.food > 0)) > 0 {\n            return point(list_places first_with (each.food > 0));\n        } else {\n            list_places <- (list_places where ((each.road > 0) and ((each distance_to center) > (self distance_to center)))) sort_by (each.road);\n            return point(last(list_places));\n        }\n\n    }\n    //Reflex to drop food once the ant is in the nest\n    reflex drop when: has_food and (ant_grid(location)).is_nest {\n        do drop();\n    }\n    //Reflex to pick food when there is one at the same location\n    reflex pick when: !has_food and (ant_grid(location)).food > 0 {\n        do pick(1);\n    }\n    //Initial state to make the ant wander \n    state wandering initial: true {\n        do wander(amplitude: 90.0);\n        float pr <- (ant_grid(location)).road;\n        transition to: carryingFood when: has_food;\n        transition to: followingRoad when: (pr > 0.05) and (pr < 4);\n    }\n    //State to carry food once it has been found\n    state carryingFood {\n        do goto(target: center);\n        transition to: wandering when: !has_food;\n    }\n    //State to follow a pheromon road if once has been found\n    state followingRoad {\n        point next_place <- choose_best_place();\n        float pr <- (ant_grid(location)).road;\n        location <- next_place;\n        transition to: carryingFood when: has_food;\n        transition to: wandering when: (pr < 0.05) or (next_place = nil);\n    }\n\n    aspect info {\n        if (use_icons) {\n            draw ant_shape size: {7, 5} rotate: my heading + 1;\n        } else {\n            draw circle(1) wireframe: !has_food color: #red;\n        }\n\n        if (destination != nil) {\n            draw line([location + {0, 0, 0.5}, {location.x + 5 * cos(heading), location.y + 5 * sin(heading)} + {0, 0, 0.5}]) + 0.1 color: #white border: false end_arrow: 1.2;\n        }\n\n        if (display_state) {\n            draw string(self as int) color: #white font: regular at: my location + {0, -1, 0.5} anchor: #center;\n            draw state color: #yellow font: bigger at: my location + {0, 0, 0.5} anchor: #center;\n        }\n\n    }\n\n    aspect threeD {\n        draw ant3D_shape size: {7, 5} at: (location + {0, 0, 1}) rotate: heading;\n    }\n\n    aspect icon {\n        draw ant_shape size: {7, 5} rotate: my heading + 1 wireframe: true;\n    }\n\n    aspect icon_svg {\n        draw ant_shape_svg size: {5, 7} rotate: my heading + 270 color: #black;\n    } }\n\n    //Complete experiment that will inspect all ants in a table\nexperiment \"With Inspector\" type: gui {\n    parameter 'Number:' var: ants_number init: 100 unit: 'ants' category: 'Environment and Population';\n    parameter 'Grid dimension:' var: gridsize init: 100 unit: '(number of rows and columns)' category: 'Environment and Population';\n    parameter 'Number of food depots:' var: number_of_food_places init: 5 min: 1 category: 'Environment and Population';\n    output {\n        layout #split editors: false;\n        display Ants type: 3d axes:false{\n            image terrain position: {0.05, 0.05} size: {0.9, 0.9} refresh: false;\n            agents \"agents\" transparency: 0.7 position: {0.05, 0.05} size: {0.9, 0.9} value: (ant_grid as list) where ((each.food > 0) or (each.road > 0) or (each.is_nest));\n            species ant position: {0.05, 0.05, 0.05} size: {0.9, 0.9} aspect: icon_svg;\n            overlay transparency: 0.3 background: rgb(99, 85, 66, 255) position: {50 #px, 50 #px} size: {250 #px, 150 #px} border: rgb(99, 85, 66, 255) rounded: true {\n                draw ant_shape at: {60 #px, 70 #px} size: {140 #px, 100 #px} rotate: -60;\n                draw ('Food foraged: ' + (((food_placed = 0 ? 0 : food_gathered / food_placed) * 100) with_precision 2) + '%') at: {40 #px, 70 #px} font: font(\"Arial\", 18, #bold) color:\n                #white;\n                draw ('Carrying ants: ' + (((100 * ant count (each.has_food or each.state = \"followingRoad\")) / length(ant)) with_precision 2) + '%') at: {40 #px, 100 #px} font:\n                font(\"Arial\", 18, #bold) color: #white;\n            }\n\n        }\n\n        inspect \"All ants\" type: table value: ant attributes: ['name', 'state'];\n    }\n\n}\n\nexperiment \"Classic\" type: gui {\n    parameter 'Number of ants:' var: ants_number category: 'Model';\n    parameter 'Evaporation of the signal (unit/cycle):' var: evaporation_per_cycle category: 'Model';\n    parameter 'Rate of diffusion of the signal (%/cycle):' var: diffusion_rate category: 'Model';\n    parameter 'Use icons for the agents:' var: use_icons category: 'Display';\n    parameter 'Display state of agents:' var: display_state category: 'Display';\n    \n    \n    \n    output {\n        display Ants antialias: false type: 3d {\n            light #ambient intensity: 127;\n            light #default intensity: 127;\n            image terrain refresh: false;\n            agents \"Grid\" transparency: 0.4 value: ant_grid where ((each.food > 0) or (each.road > 0) or (each.is_nest));\n            species ant aspect: info;\n        }\n\n    }\n\n}\n\n//Complete experiment that will inspect all ants in a table\nexperiment \"3D View\" type: gui {\n    parameter 'Number:' var: ants_number init: 30 unit: 'ants' category: 'Environment and Population';\n    parameter 'Grid dimension:' var: gridsize init: 100 unit: '(number of rows and columns)' category: 'Environment and Population';\n    parameter 'Number of food depots:' var: number_of_food_places init: 5 min: 1 category: 'Environment and Population';\n    output {\n        \n\n        display Ants3D type: 3d show_fps: true antialias: false{\n            grid ant_grid elevation: grid_values triangulation: true texture: terrain refresh: false;\n            agents \"Trail\" transparency: 0.7 position: {0.05, 0.05, 0.02} size: {0.9, 0.9} value: (ant_grid as list) where ((each.food > 0) or (each.road > 0) or (each.is_nest));\n            species ant position: {0.05, 0.05, 0.025} size: {0.9, 0.9} aspect: threeD;\n        }\n\n    }\n\n}\n\n//Experiment to show how to make multi simulations\nexperiment \"3 Simulations\" type: gui {\n    parameter 'Number:' var: ants_number init: 100 unit: 'ants' category: 'Environment and Population';\n    parameter 'Grid dimension:' var: gridsize init: 100 unit: '(number of rows and columns)' category: 'Environment and Population';\n    parameter 'Number of food depots:' var: number_of_food_places init: 5 min: 1 category: 'Environment and Population';\n\n    // We create 2 supplementary simulations using the species name 'ants_model' (automatically created from the name of the model + '_model')\n    init {\n        create ants_model with: [ants_number::200, evaporation_per_cycle::100, diffusion_rate::0.2];\n        create ants_model with: [ants_number::10, evaporation_per_cycle::72, diffusion_rate::0.6];\n    }\n\n\n    permanent {\n        display Comparison background: #white {\n            chart \"Food Gathered\" type: series {\n                loop s over: simulations {\n                    data \"Food \" + int(s) value: s.food_gathered color: s.color marker: false style: line thickness: 5;\n                }\n\n            }\n\n        }\n\n    }\n\n    output {\n        layout #split editors: false consoles: false toolbars: true tabs: false tray: false;\n        display Ants background: color type: 3d toolbar: color axes: false {\n            image terrain position: {0.05, 0.05} size: {0.9, 0.9} refresh: false;\n            agents \"agents\" transparency: 0.5 position: {0.05, 0.05} size: {0.9, 0.9} value: (ant_grid as list) where ((each.food > 0) or (each.road > 0) or (each.is_nest));\n            species ant position: {0.05, 0.05} size: {0.9, 0.9} aspect: icon;\n        }\n\n    }\n\n}\n\n\n")))}u.isMDXComponent=!0}}]);