"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[74990],{21880:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"Writing_Tests","title":"Writing Unit Tests in GAML","description":"Unit testing is an essential instrument to ensure the quality of any software and it has been implemented in GAMA: this allows in particular that parts of the model are behaving as expected and that evolutions in the model do not introduce unexpected changes. To these purposes, the modeler can define a set of assertions that will be tested. Before the execution of the embedded set of instructions, if a setup is defined in the species, model or experiment, it is executed. In a test, if one assertion fails, the evaluation of other assertions continue.","source":"@site/../docs/Writing_Tests.md","sourceDirName":".","slug":"/Writing_Tests","permalink":"/wiki/next/Writing_Tests","draft":false,"unlisted":false,"editUrl":"https://github.com/gama-platform/gama/wiki/Writing_Tests/_edit","tags":[],"version":"current","frontMatter":{"title":"Writing Unit Tests in GAML"},"sidebar":"main","previous":{"title":"Calling gama from another program","permalink":"/wiki/next/HeadlessTutorial"},"next":{"title":"Ensure model\'s reproducibility","permalink":"/wiki/next/Ensure-model-reproducibility"}}');var i=n(74848),r=n(28453);const o={title:"Writing Unit Tests in GAML"},a=void 0,d={},l=[{value:"What is <code>test</code> in GAML?",id:"what-is-test-in-gaml",level:2},{value:"Introduction to assertions",id:"introduction-to-assertions",level:2},{value:"How to write a GAML <code>test</code>?",id:"how-to-write-a-gaml-test",level:2},{value:"Use of the <code>setup</code> statement",id:"use-of-the-setup-statement",level:2},{value:"The test experiment",id:"the-test-experiment",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Unit_testing",children:"Unit testing"})," is an essential instrument to ensure the quality of any software and it has been implemented in GAMA: this allows in particular that parts of the model are behaving as expected and that evolutions in the model do not introduce unexpected changes. To these purposes, the modeler can define a set of assertions that will be tested. Before the execution of the embedded set of instructions, if a setup is defined in the species, model or experiment, it is executed. In a test, if one assertion fails, the evaluation of other assertions continue."]}),"\n",(0,i.jsx)(t.p,{children:"Writing tests in GAML involves the use of 4 keywords:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsxs)(t.a,{href:"Statements#assert",children:[(0,i.jsx)(t.code,{children:"assert"})," statement"]}),","]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsxs)(t.a,{href:"Statements#test",children:[(0,i.jsx)(t.code,{children:"test"})," statement"]}),","]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsxs)(t.a,{href:"Statements#setup",children:[(0,i.jsx)(t.code,{children:"setup"})," statement"]}),","]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsxs)(t.a,{href:"ModelOrganization#experiment-declarations",children:[(0,i.jsx)(t.code,{children:"type: test"})," facet of ",(0,i.jsx)(t.code,{children:"experiment"})]}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["In this unit testing tutorial, we intend to show how to write unit tests in GAML using the statement ",(0,i.jsx)(t.code,{children:"test"}),"."]}),"\n",(0,i.jsxs)(t.h2,{id:"what-is-test-in-gaml",children:["What is ",(0,i.jsx)(t.code,{children:"test"})," in GAML?"]}),"\n",(0,i.jsxs)(t.p,{children:["In GAML, the statement ",(0,i.jsx)(t.code,{children:"test"})," allows the modeler to write a part of code lines to verify if portions of our GAML model are doing exactly what they are expected to do: this is done through the use of several assertions (using ",(0,i.jsx)(t.code,{children:"assert"})," statements). This is done independently from other parts of the model."]}),"\n",(0,i.jsx)(t.p,{children:"To write a typical GAML unit test, we can follow three steps:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Define a set of attributes to use within the test,"}),"\n",(0,i.jsx)(t.li,{children:"Write initialization instructions,"}),"\n",(0,i.jsx)(t.li,{children:"Write assertions."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The aim of using unit testing is to observe the resulting behavior of some parts of our model. If the observed behavior is consistent with the expectations, the unit test passes, otherwise, it fails, indicating that there is a problem concerning the tested part of the model."}),"\n",(0,i.jsx)(t.h2,{id:"introduction-to-assertions",children:"Introduction to assertions"}),"\n",(0,i.jsxs)(t.p,{children:["The basis of Unit tests is to check that given pieces of codes provide expected results. To this purpose, the modeler can write some basic tests that should be true: s/he thus asserts that such expression can be evaluated to true using the ",(0,i.jsx)(t.code,{children:"assert"})," statement. Here are some examples of ",(0,i.jsx)(t.code,{children:"assert"})," uses:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"assert 1 + 1 = 2;\nassert isGreater(5, 6) = false;\nassert rnd(1.0) <= 1.0;\n"})}),"\n",(0,i.jsxs)(t.p,{children:["With the above statements, the modeler states the ",(0,i.jsx)(t.code,{children:"1+1"})," is equal to ",(0,i.jsx)(t.code,{children:"2"}),", ",(0,i.jsx)(t.code,{children:"isGreater(5,6)"})," is false (given the fact that ",(0,i.jsx)(t.code,{children:"isGreater"})," is an action defined in a species) and ",(0,i.jsx)(t.code,{children:"rnd(1.0)"})," always returns a value below 1.0."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"assert"})," can be used in any behavior statement (as an example in a ",(0,i.jsx)(t.code,{children:"reflex"}),", a ",(0,i.jsx)(t.code,{children:"state"})," or in a ",(0,i.jsx)(t.code,{children:"test"}),". Note that, if they are written outside of a ",(0,i.jsx)(t.code,{children:"test"})," and that the test is not fulfilled, then an exception is thrown during their execution."]}),"\n",(0,i.jsxs)(t.p,{children:["As an example, the following model throws the exception: ",(0,i.jsx)(t.code,{children:"Assert failed 3>4"})," (as obviously 3 is not greater than 4 and that the GAML ",(0,i.jsx)(t.code,{children:">"})," operator is properly implemented on this case)."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"model NewModel\n\nglobal {\n    init {\n\tassert 3 > 4;\n    }\n}\n\nexperiment NewModel type: gui {}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["To be able to have a dashboard of the state of your model w.r.t. the unit tests, they need to be written in a ",(0,i.jsx)(t.code,{children:"test"})," and the model launched with an experiment of type ",(0,i.jsx)(t.code,{children:"test"}),"."]}),"\n",(0,i.jsxs)(t.h2,{id:"how-to-write-a-gaml-test",children:["How to write a GAML ",(0,i.jsx)(t.code,{children:"test"}),"?"]}),"\n",(0,i.jsxs)(t.p,{children:["A ",(0,i.jsx)(t.code,{children:"test"})," statement can be used in any species (regular species, global or experiment species) everywhere a ",(0,i.jsx)(t.code,{children:"reflex"})," can be used. Its aim is to gather several asserts in one block. If the tests are executed with any kind of experiment but ",(0,i.jsx)(t.code,{children:"test"}),", they will be executed, but nothing is reported. With a ",(0,i.jsx)(t.code,{children:"test"})," experiment, a kind of dashboard will be displayed."]}),"\n",(0,i.jsxs)(t.p,{children:["So we will consider that we start by adding an ",(0,i.jsx)(t.code,{children:"experiment"})," with ",(0,i.jsx)(t.code,{children:"type"})," set to ",(0,i.jsx)(t.code,{children:"test"}),". The following code shows an example."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"experiment MyTest type: test autorun: true { \n    ...\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"Let's consider the following GAML code:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"model TestModel\n\nglobal {\n    init {\n\tcreate test_agent number: 1;\n    }\n}\n\nspecies test_agent {\n    bool isGreater (int p1, int p2) {\n\tif (p1 >= p2) {\n\t    return true;\n\t} else {\n\t    return false;\n\t}\n    }\n\n    test testsOK {\n\tassert isGreater(5, 6) = false;\n\tassert isGreater(6, 5) = true;\n    }\n    \n    test failingTests {\n\tassert ! isGreater(6, 6);\n    }        \n}\n\nexperiment MyTest type: test autorun: true { }\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In this example, the defined action, ",(0,i.jsx)(t.code,{children:"isGreater"}),", returns ",(0,i.jsx)(t.code,{children:"true"})," if a parameter ",(0,i.jsx)(t.code,{children:"p1"})," is greater than a parameter ",(0,i.jsx)(t.code,{children:"p2"})," and ",(0,i.jsx)(t.code,{children:"false"})," if not. So to test it, we declare a unit test using ",(0,i.jsx)(t.code,{children:"test"})," and add inside several ",(0,i.jsx)(t.code,{children:"assert"})," statements. For instance, ",(0,i.jsx)(t.code,{children:"assert isGreater(5, 6) = false;"})," will return ",(0,i.jsx)(t.code,{children:"true"})," if the result of ",(0,i.jsx)(t.code,{children:"isGreater(5, 6)"})," is really false and ",(0,i.jsx)(t.code,{children:"false"})," if not. So, if the action ",(0,i.jsx)(t.code,{children:"isGreater"})," is well-defined, it should return ",(0,i.jsx)(t.code,{children:"false"}),'. Considering that "greater" and "greater and equal" should be two different functions, we add a test to check that ',(0,i.jsx)(t.code,{children:"isGreater"})," does not return true in case of equality of its 2 operands. In this case, as the action is not-well implemented the test fails."]}),"\n",(0,i.jsx)(t.p,{children:"The following picture illustrates the GUI dashboard for unit tests, showing for each test and even each assert whether it passes or fails. Clicking on the button will display in the GAML editor the code line."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Interface for unit tests execution.",src:n(34431).A+"",width:"1250",height:"530"})}),"\n",(0,i.jsxs)(t.h2,{id:"use-of-the-setup-statement",children:["Use of the ",(0,i.jsx)(t.code,{children:"setup"})," statement"]}),"\n",(0,i.jsxs)(t.p,{children:["In a species where we want to execute several tests, it is common to want to have the same initial states, in order to prevent the previous tests to have modified the tested object and thus altering the unit test results. To this purpose, we can add the ",(0,i.jsx)(t.code,{children:"setup"})," statement in the species and use it to set the expected initial state of the object to be tested. It will be called before every ",(0,i.jsx)(t.code,{children:"test"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["As an example, in the following model, we want to test the operator ",(0,i.jsx)(t.code,{children:"translated_by"})," and ",(0,i.jsx)(t.code,{children:"translated_to"})," on a point. As each of them will modify the point object to be tested, wed add a ",(0,i.jsx)(t.code,{children:"setup"})," to reinitialize it."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"model TestModel\n\nglobal {\n    geometry loc <- {0,0};\n\t\n    setup {\n\tloc <- {0,0};\t\n    }\n\n    test translate_to {\n\tloc <- loc translated_to {10,10};\n\tloc <- loc translated_to {10,10};\n\tassert loc.location = {10,10};\n    }\n\t\n    test translated_by {\n\tloc <- loc translated_by {10,10};\n\tloc <- loc translated_by {10,10};\n\tassert loc.location = {20,20};\n    }\n}\n\nexperiment MyTest type: test autorun: true { }\n"})}),"\n",(0,i.jsx)(t.h2,{id:"the-test-experiment",children:"The test experiment"}),"\n",(0,i.jsxs)(t.p,{children:["It is also possible to write tests in the ",(0,i.jsx)(t.code,{children:"experiment"}),". The main idea is here to totally separate the model and its tests.\nAs an example let's consider the following GAML code, which aims to test several GAML operators, related to the graph datatype:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'model TestGraphs\n\nglobal {\n    graph the_graph;\n\n    init {\n\tint i <- 10;\n\tcreate node_agent number: 7 {\n\t    location <- {i, i + ((i / 10) mod 2) * 10};\n\t    i <- i + 10;\n\t}\n\n\tthe_graph <- as_distance_graph(node_agent, 30.0);\n    }\n}\n\nspecies edge_agent {\n    aspect default {\n\tdraw shape color: #black;\n    }\n}\n\nspecies node_agent {\n    aspect default {\n\tdraw circle(1) color: #red;\n\tloop neigh over: the_graph neighbors_of self {\n\t    draw line([self.location, agent(neigh).location]) color: #black;\n\t}\n    }\n}\n\nexperiment loadgraph type: gui {\n    output {\n\tdisplay map type: opengl {\n\t    species edge_agent;\n\t    species node_agent;\n\t}\n    }\n}\n\nexperiment MyTest type: test autorun: true {\n    test "MyFirstTest" {\n\twrite the_graph;\n\twrite (node_agent[2]);\n\twrite ("Degrees");\n\twrite (the_graph in_degree_of (node_agent[2]));\n\twrite (the_graph out_degree_of (node_agent[2]));\n\twrite (the_graph degree_of (node_agent[2]));\n\tassert the_graph in_degree_of (node_agent[2]) = 4;\n\twrite (the_graph out_degree_of (node_agent[2]));\n\tassert the_graph out_degree_of (node_agent[2]) = 4;\n\tassert the_graph degree_of (node_agent[2]) = 8;\n    }\n}\n'})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var s=n(96540);const i={},r=s.createContext(i);function o(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:t},e.children)}},34431:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/unit_tests_isgreater-c63d07124e72575154c013e7e5589b23.png"}}]);