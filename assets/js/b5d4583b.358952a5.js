"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[57093],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>g});var o=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,i=function(e,n){if(null==e)return{};var t,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=o.createContext({}),s=function(e){var n=o.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=s(e.components);return o.createElement(c.Provider,{value:n},e.children)},u="mdxType",f={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=s(t),d=i,g=u["".concat(c,".").concat(d)]||u[d]||f[d]||a;return t?o.createElement(g,r(r({ref:n},p),{},{components:t})):o.createElement(g,r({ref:n},p))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,r=new Array(a);r[0]=d;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l[u]="string"==typeof e?e:i,r[1]=l;for(var s=2;s<a;s++)r[s]=t[s];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},56998:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>c,default:()=>g,frontMatter:()=>l,metadata:()=>s,toc:()=>u});var o=t(87462),i=t(63366),a=(t(67294),t(3905)),r=["components"],l={"^title":"ContinuousMove"},c=void 0,s={unversionedId:"ContinuousMove",id:"ContinuousMove",title:"ContinuousMove",description:"Path: Library models/Toy Models/Evacuation/models/Continuous Move.gaml",source:"@site/../docs/ContinuousMove.md",sourceDirName:".",slug:"/ContinuousMove",permalink:"/wiki/next/ContinuousMove",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/ContinuousMove/_edit",tags:[],version:"current",frontMatter:{"^title":"ContinuousMove"}},p={},u=[],f={toc:u},d="wrapper";function g(e){var n=e.components,t=(0,i.Z)(e,r);return(0,a.kt)(d,(0,o.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("img",{width:"960",alt:"Annotation 2023-04-14 184314_ContinuousMove",src:"https://user-images.githubusercontent.com/4437331/232225645-73d26e9b-141e-4e82-912d-355baefa6840.png"}),(0,a.kt)("p",null,"Path: Library models/Toy Models/Evacuation/models/Continuous Move.gaml"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'\n/**\n* Name: continuous_move\n* Author: Patrick Taillandier\n* Description: A 3D model which show how to represent an evacuation system with \n*   obstacles, cohesion factor and velocity. The people are placed randomly and have \n*   to escape by going to a target point\n* Tags: 3d, shapefile, gis, agent_movement, skill\n*/\nmodel continuous_move \nglobal { \n    //Shapefile of the buildings\n    file building_shapefile <- file("../includes/building.shp");\n    //Shape of the environment\n    geometry shape <- envelope(building_shapefile);\n    int maximal_turn <- 90; //in degree\n    int cohesion_factor <- 10;\n    //Size of the people\n    float people_size <- 2.0;\n    //Space without buildings\n    geometry free_space;\n    //Number of people agent\n    int nb_people <- 500;\n    //Point to evacuate\n    point target_point <- {shape.width, 0};\n    init { \n        \n        free_space <- copy(shape);\n        //Creation of the buildinds\n        create building from: building_shapefile {\n            //Creation of the free space by removing the shape of the different buildings existing\n            free_space <- free_space - (shape + people_size);\n        }\n        //Simplification of the free_space to remove sharp edges\n        free_space <- free_space simplification(1.0);\n        //Creation of the people agents\n        create people number: nb_people {\n            //People agents are placed randomly among the free space\n            location <- any_location_in(free_space);\n            target_loc <-  target_point;\n        }           \n    }   \n}\n//Species which represent the building \nspecies building {\n    //Height of the buildings\n    float height <- 3.0 + rnd(5);\n    aspect default {\n        draw shape color: #gray depth: height;\n    }\n}\n//Species people which move to the evacuation point using the skill moving\nspecies people skills:[moving]{\n    //Target point to evacuate\n    point target_loc;\n    //Speed of the agent\n    float speed <- 0.5 + rnd(1000) / 1000;\n    //Velocity of the agent\n    point velocity <- {0,0};\n    //Direction of the agent taking in consideration the maximal turn an agent is able to make\n    float heading max: heading + maximal_turn min: heading - maximal_turn;\n    \n    //Size of the agent\n    float size <- people_size; \n    rgb color <- rgb(rnd(255),rnd(255),rnd(255));\n        \n    //Reflex to kill the agent when it has evacuated the area\n    reflex end when: location distance_to target_loc <= 2 * people_size{\n        write name + " is arrived";\n        do die;\n    }\n    //Reflex to compute the velocity of the agent considering the cohesion factor\n    reflex follow_goal  {\n        velocity <- velocity + ((target_loc - location) / cohesion_factor);\n    }\n    //Reflex to apply separation when people are too close from each other\n    reflex separation {\n        point acc <- {0,0};\n        ask (people at_distance size)  {\n            acc <- acc - (location - myself.location);\n        }  \n        velocity <- velocity + acc;\n    }\n    //Reflex to avoid the different obstacles\n    reflex avoid { \n        point acc <- {0,0};\n        list<building> nearby_obstacles <- (building at_distance people_size);\n        loop obs over: nearby_obstacles {\n            acc <- acc - (obs.location - location); \n        }\n        velocity <- velocity + acc; \n    }\n    //Reflex to move the agent considering its location, target and velocity\n    reflex move {\n        point old_location <- copy(location);\n        do goto target: location + velocity ;\n        if not(self overlaps free_space ) {\n            location <- ((location closest_points_with free_space)[1]);\n        }\n        velocity <- location - old_location;\n    }   \n    aspect default {\n        draw pyramid(size) color: color;\n        draw sphere(size/3) at: {location.x,location.y,size*0.75} color: color;\n    }\n}\n\nexperiment main type: gui {\n    parameter "nb people" var: nb_people min: 1 max: 1000;\n    float minimum_cycle_duration <- 0.04; \n    output {\n        display map type: 3d {\n            species building refresh: false;\n            species people;\n            graphics "exit" refresh: false {\n                draw sphere(2 * people_size) at: target_point color: #green;    \n            }\n        }\n    }\n}\n\n\n')))}g.isMDXComponent=!0}}]);