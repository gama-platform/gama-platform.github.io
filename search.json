{
    
      "wiki-additionnal-plugins-html": {
        "title": "Additionnal Plugins",
        "content": "Additionnal PluginsThis section is composed of the following sub-section :      Diffusion Statement        Ordinary Differential Equations  ",
        "url":"/wiki/Additionnal-Plugins.html"
      }
      ,
    
      "wiki-agent-movement-follow-path-html": {
        "title": "Movement of an agent on different paths",
        "content": "Movement of an agent on different paths_Author : _Model showing the movement of an agent following three different paths : one defined by its vertices, an other defined thanks to all the roads species, and finally a path defined by a graph with weights (graph created thanks to an other species)Code of the model :model path_and_followglobal{\tgraph the_graph;    init{    \t\t//It is possible to define a road by defining its shape, being a line. The line need to be created by passing the location of the vertices       create road {       \t\tshape &lt;- line([{0,50},{40,60}]);       }       create road {       \t\tshape &lt;- line([{40,60},{50,50},{55,60}]);       }       create road {       \t\tshape &lt;- line([{55,60},{65,40}]);       }              create road_of_graph {       \t\tshape &lt;- line([{65,40},{75,35}]);       }       create road_of_graph {       \t\tshape &lt;- line([{75,35},{85,40},{80,60}]);       }       //It is possible to define a weights map by linking the road and their weights (the road will be the key of the weight)       map&lt;road_of_graph,float&gt; weight_map &lt;- road_of_graph as_map (each::each.shape.perimeter * 10);              //A graph can be defined by using a list or all the agents of a species and it is possible to use a map of weights with each key        // of the map being a road to link the road and its weight       //The as_edge_graph operator is an operator creating a graph using the list of agents passed as edges of the graph       the_graph &lt;- as_edge_graph(road_of_graph) with_weights weight_map;             create myCircle {       \t\tlocation &lt;- {0,0};       }          }  }species myCircle skills:[moving]{\t//The different ways to declare a path : declaring all the lines of the path using their vertices\t//\t\t\t\t\t\t\t  using a list of agents representing the lines of the path\t//\t\t\t\t\t\t\t  using the graph as a path\t\t \tpath path_to_follow1 &lt;- path([{0,0},{10,10},{0,20},{20,30},{20,40},{0,50}]);\t \tpath path_to_follow2 &lt;- path(list(road));\t \tpath path_to_follow3 &lt;- list(road_of_graph) as_path the_graph;\t \t \t//These two variables will change when the cycle will be higher than 100 and 200 \tpath path_following&lt;- path_to_follow1; \trgb color &lt;- #green; \t\treflex myfollow{ \t\t//The operator follow make the agent move from the starting vertice of the starting edge of a path to the last vertice of the last edge of the path\t\t// but following the edges of the concerned path\t \tdo follow path: path_following;\t\t \tif(cycle&gt;200)\t \t{\t \t\tpath_following&lt;- path_to_follow3;\t\t \t\tcolor&lt;-#pink;\t \t}\t \telse\t \t{\t \t\tif(cycle&gt;100)\t\t \t{\t\t \t\tpath_following&lt;- path_to_follow2;\t\t\t \t\tcolor&lt;-#blue;\t\t \t}\t \t}\t}\t\taspect base {\t  draw circle(1) color:#red ;\t\t  //We loop on all the edges of the path the agent follow to display them\t  \tloop seg over: path_following.edges {\t  \t\tdraw seg color: color;\t \t }\t  \t} }species road {\taspect base {\t  draw shape color:#blue ;\t\t  \t} }species road_of_graph {\taspect base {\t  draw shape color:#red ;\t\t  \t} }experiment main type: gui {\tfloat minimum_cycle_duration &lt;- 0.10;\toutput {\t\tdisplay myView { \t\t\tspecies myCircle aspect:base; \t\t}\t}}",
        "url":"/wiki/Agent-movement-Follow-Path.html"
      }
      ,
    
      "wiki-agent-movement-follow-weighted-network-agents-html": {
        "title": "Follow Weighted Network",
        "content": "Follow Weighted NetworkAuthor :  Martine TaillandierModel representing how to make a weighted graph and the impacts of the weights on the time to follow the path for the agents. Two agents are represented to show this difference : one knowing the weights and following a fast path, an other following a path longer without knowing it’s a longer path.Code of the model :model weightperagentsglobal {\tmap&lt;road, float&gt; roads_weight;\tgraph road_network;\tfloat slow_coeff &lt;- 3.0;\tinit {\t\t//This road will be slow\t\tcreate road {\t\t\tshape &lt;- line ([{10,50},{90,50}]);\t\t\tslow &lt;- true;\t\t}\t\t//The others will be faster\t\tcreate road {\t\t\tshape &lt;- line ([{10,50},{10,10}]);\t\t\tslow &lt;- false;\t\t}\t\tcreate road {\t\t\tshape &lt;- line ([{10,10},{90,10}]);\t\t\tslow &lt;- false;\t\t}\t\tcreate road {\t\t\tshape &lt;- line ([{90,10},{90,50}]);\t\t\tslow &lt;- false;\t\t}\t\t\t\t//Weights map of the graph for those who will know the shortest road by taking into account the weight of the edges\t\troads_weight &lt;- road as_map (each:: each.shape.perimeter * (each.slow ? slow_coeff : 1.0));\t\troad_network &lt;- as_edge_graph(road);\t\t\t\t//people with information about the traffic\t\tcreate people {\t\t\tcolor &lt;- #blue;\t\t\tsize &lt;- 2.0;\t\t\troads_knowledge &lt;- roads_weight;\t\t}\t\t\t\t//people without information about the traffic\t\tcreate people {\t\t\tcolor &lt;- #yellow;\t\t\tsize &lt;- 1.0;\t\t\troads_knowledge &lt;- road as_map (each:: each.shape.perimeter);\t\t}\t}\t}species road {\tbool slow;\taspect geom {\t\tdraw shape color: slow ? #red : #green;\t}}\tspecies people skills: [moving] {\tmap&lt;road, float&gt; roads_knowledge;\tpoint the_target;\trgb color;\tfloat size;\tpath path_to_follow;\t\tinit {\t\tthe_target &lt;- {90,50};\t\tlocation &lt;- {10,50};\t}\t\t\treflex movement when: location != the_target{\t\tif (path_to_follow = nil) {\t\t\t\t\t\t//Find the shortest path using the agent's own weights to compute the shortest path\t\t\tpath_to_follow &lt;- path_between(road_network with_weights roads_knowledge, location,the_target);\t\t}\t\t//the agent follows the path it computed but with the real weights of the graph\t\tdo follow path:path_to_follow speed: 5 move_weights: roads_weight;\t}\t\t\taspect base {\t\tdraw circle(size) color: color;\t}}experiment weightperagents type: gui {\tfloat minimum_cycle_duration &lt;- 0.1;\toutput {\t\tdisplay map {\t\t\tspecies road aspect: geom;\t\t\tspecies people aspect: base;\t\t}\t}}",
        "url":"/wiki/Agent-movement-Follow-Weighted-Network-(Agents).html"
      }
      ,
    
      "wiki-agent-movement-goto-directed-graph-html": {
        "title": "Directed Graph Model",
        "content": "Directed Graph ModelAuthor :  Patrick TaillandierModel representing how to directed graph using GIS Data for the road networks : the GIS contains a column defining the direction of the roads and people moving from one random point to another on this graphCode of the model :model simplemodelglobal {\tfile road_file &lt;- file(\"../includes/gis/roads.shp\");\tgeometry shape &lt;- envelope(road_file);\tgraph the_graph; \t\tinit {\t\tcreate road from: road_file with:[direction::int(read(\"DIRECTION\"))] {\t\t\tswitch direction {\t\t\t\tmatch 0 {color &lt;- #green;}\t\t\t\tmatch 1 {color &lt;- #red;\t\t\t\t\t//inversion of the road geometry\t\t\t\t\tshape &lt;- polyline(reverse(shape.points));\t\t\t\t}\t\t\t\tmatch 2 {color &lt;- #blue;\t\t\t\t\t//bidirectional: creation of the inverse road\t\t\t\t\tcreate road {\t\t\t\t\t\tshape &lt;- polyline(reverse(myself.shape.points));\t\t\t\t\t\tdirection &lt;- 2;\t\t\t\t\t\tcolor &lt;- #blue;\t\t\t\t\t}\t\t\t\t} \t\t\t}\t\t}\t\t//The operator directed modify the graph created by as_edge_graph(road) to a directed graph\t\tthe_graph &lt;- directed(as_edge_graph(road)) ;\t\t\t\t\t\tcreate people number: 1000 {\t\t\t//The operator any_location_in returns a random point located in one of the road agents\t\t\ttarget &lt;- any_location_in(one_of (road)) ;\t\t\tlocation &lt;- any_location_in (one_of(road));\t\t\tsource &lt;- location;\t\t} \t}}species road {\tint direction;\trgb color;\taspect geom {\t\tdraw shape color: color;\t}}//The people agents use the skill moving which have built-in variables such as speed, target, location, heading and built-in operatorsspecies people skills: [moving] {\tpoint target;\tpath my_path; \tpoint source;\tstring r_s;\tstring r_t; \taspect circle {\t\tdraw circle(10) color: #green;\t}\t\treflex movement {\t\t\t\t//The operator goto is a built-in operator derivated from the moving skill, moving the agent from its location to its target, \t\t//   restricted by the on variable, with the speed and returning the path followed\t\tmy_path &lt;- self goto (on:the_graph, target:target, speed:10, return_path: true);\t\t\t\t//If the agent arrived to its target location, then it choose randomly an other target on the road\t\tif (target = location) {\t\t\t\t\t\ttarget &lt;- any_location_in(one_of (road)) ;\t\t\tsource &lt;- location;\t\t}\t}}experiment simplemodel type: gui {\toutput {\t\tdisplay map {\t\t\tspecies road aspect: geom;\t\t\tspecies people aspect: circle;\t\t}\t}}",
        "url":"/wiki/Agent-movement-Goto-Directed-Graph.html"
      }
      ,
    
      "wiki-agent-movement-goto-grid-html": {
        "title": "Movement on a Grid of Cells",
        "content": "Movement on a Grid of CellsAuthor :  Patrick TaillandierModel to represent how the agents move from one point to a target agent on a grid of cells with obstacles, following the shortest path and coloring in magenta the cells intersecting the path of an agentCode of the model :model Gridglobal {\tinit {    \t\tcreate goal{\t\t\tlocation &lt;- (one_of (cell where not each.is_obstacle)).location;\t\t}\t\tcreate people number: 10 {\t\t\ttarget &lt;- one_of (goal);\t\t\tlocation &lt;-  (one_of (cell where not each.is_obstacle)).location;\t\t}\t} }grid cell width: 50 height: 50 neighbors: 4 {\tbool is_obstacle &lt;- flip(0.2);\trgb color &lt;- is_obstacle ? #black : #white;} \t species goal {\taspect default { \t\tdraw circle(0.5) color: #red;\t}}  \t\t  species people skills: [moving] {\tgoal target;\tfloat speed &lt;- float(3);\t\taspect default {\t\tdraw circle(0.5) color: #green;\t}\t\treflex move when: location != target{\t\t//Neighs contains all the neighbours cells that are reachable by the agent plus the cell where it's located\t\tlist&lt;cell&gt; neighs &lt;- (cell(location) neighbors_at speed) + cell(location); \t\t\t\t//We restrain the movements of the agents only at the grid of cells that are not obstacle using the on facet of the goto operator and we return the path\t\t//followed by the agent\t\t//the recompute_path is used to precise that we do not need to recompute the shortest path at each movement (gain of computation time): the obtsacles on the grid never change.\t\tpath followed_path &lt;- self goto (on:(cell where not each.is_obstacle), target:target, speed:speed, return_path:true, recompute_path: false);\t\t\t\t//As a side note, it is also possible to use the path_between operator and follow action with a grid\t\t//Add a my_path attribute of type path to the people species\t\t//if my_path = nil {my_path &lt;- path_between((cell where not each.is_obstacle), location, target);}\t\t//path followed_path &lt;- self follow (path: my_path,  return_path:true);\t\t\t\tif (followed_path != nil) and not empty(followed_path.segments) {\t\t\tgeometry path_geom &lt;- geometry(followed_path.segments);\t\t\t\t\t\t//The cells intersecting the path followed by the agent are colored in magenta\t\t\task (neighs where (each.shape intersects path_geom)) { color &lt;- #magenta;}\t\t}\t\t}}experiment goto_grid type: gui {\toutput {\t\tdisplay objects_display {\t\t\tgrid cell lines: #black;\t\t\tspecies goal aspect: default ;\t\t\tspecies people aspect: default ;\t\t}\t}}",
        "url":"/wiki/Agent-movement-Goto-Grid.html"
      }
      ,
    
      "wiki-agent-movement-goto-network-html": {
        "title": "Shortest Path Computation on a Graph",
        "content": "Shortest Path Computation on a GraphAuthor :  Patrick TaillandierModel to show how to use the optimizer methods to compute the shortest path for the agents placed on a network with all of them having the same goal location. It also shows how to save these paths computed into a text file.Code of the model :model Networkglobal {\tfile shape_file_in &lt;- file('../includes/gis/roads.shp') ;\tgraph the_graph; \tgeometry shape &lt;- envelope(shape_file_in);\tbool save_shortest_paths &lt;- false;\tbool load_shortest_paths &lt;- false;\tstring shortest_paths_file &lt;- \"../includes/shortest_paths.csv\";\tbool memorize_shortest_paths &lt;- true;\t\t/*4 type of optimizer can be used for the shortest path computation:\t *    - Djikstra: the default one - ensure to find the best shortest path - compute one shortest path at a time (by default, memorise the shortest path found)\t * \t  - Bellmann: ensure to find the best shortest path - compute one shortest path at a time (by default, memorise the shortest path found)\t * \t  - AStar: do not ensure to find the best shortest path - compute one shortest path at a time (by default, memorise the shortest path found)\t *    - Floyd Warshall: ensure to find the best shortest path - compute all the shortest pathes at the same time (and keep them in memory)\t */\tstring optimizer_type &lt;- \"Djikstra\";\tint nb_people &lt;- 100;\tinit {    \t\tcreate road from: shape_file_in ;\t\tthe_graph &lt;- as_edge_graph(list(road));\t\t\t\t//allows to choose the type of algorithm to use compute the shortest paths\t\tthe_graph &lt;- the_graph with_optimizer_type optimizer_type;\t\t\t\t//allows to define if the shortest paths computed should be memorized (in a cache) or not\t\tthe_graph &lt;- the_graph use_cache memorize_shortest_paths;\t\t\t\t//computes all the shortest paths, puts them in a matrix, then saves the matrix in a file\t\tif save_shortest_paths {\t\t\tmatrix ssp &lt;- all_pairs_shortest_path(the_graph);\t\t\tsave ssp type:\"text\" to:shortest_paths_file;\t\t\t\t\t//loads the file of the shortest paths as a matrix and uses it to initialize all the shortest paths of the graph\t\t} else if load_shortest_paths {\t\t\tthe_graph &lt;- the_graph load_shortest_paths matrix(file(shortest_paths_file));\t\t}\t\t\t\tcreate goal number: 1 {\t\t\tlocation &lt;- any_location_in (one_of(road));\t\t}\t\tcreate people number: nb_people {\t\t\ttarget &lt;- one_of (goal) ;\t\t\tlocation &lt;- any_location_in (one_of(road));\t\t} \t}}species road  {\tfloat speed_coef ;\taspect default {\t\tdraw shape color: #black ;\t}} \tspecies goal {\taspect default {\t\tdraw circle(50) color: #red;\t}}\tspecies people skills: [moving] {\tgoal target;\tpath my_path; \t\taspect default {\t\tdraw circle(50) color: #green;\t}\treflex movement {\t\tdo goto on:the_graph target:target speed:1;\t}}experiment goto_network type: gui {\tparameter \"Type of optimizer\" var: optimizer_type among: [\"Djikstra\", \"AStar\", \"Bellmann\", \"Floyd Warshall\"];\tparameter \"Number of people\" var: nb_people min: 1 max: 1000000;\tparameter \"Computed all the shortest paths and save the results\" var: save_shortest_paths;\tparameter \"Load the shortest paths from the file\" var: load_shortest_paths;\t\toutput {\t\tdisplay objects_display {\t\t\tspecies road aspect: default ;\t\t\tspecies people aspect: default ;\t\t\tspecies goal aspect: default ;\t\t}\t}}",
        "url":"/wiki/Agent-movement-Goto-Network.html"
      }
      ,
    
      "wiki-agent-movement-goto-polygon-html": {
        "title": "Movement on a Graph created by Polygons",
        "content": "Movement on a Graph created by PolygonsAuthor :  Patrick TaillandierModel to show how to create a graph using a polygon shapefile by skeletonizing it, and creating roads using the skeleton. All of the agents will use this graph to go to the same targeted location.Code of the model :model polygonglobal {\t//Import of the shapefile containing the different polygons\tfile shape_file_in &lt;- file('../includes/gis/squareHole.shp') ;\tgraph the_graph;\t\tgeometry shape &lt;- envelope(shape_file_in);\t\tinit {    \t\tcreate object from: shape_file_in ;\t\tobject the_object &lt;- first(object);\t\t\t\t//triangulation of the object to get the different triangles of the polygons\t\tlist&lt;geometry&gt; triangles &lt;- list(triangulate(the_object));\t\t\t\tloop trig over: triangles {\t\t\tcreate triangle_obj {\t\t\t\tshape &lt;- trig;\t\t\t}\t\t}\t\t\t\t//creation of a list of skeleton from the object \t\tlist&lt;geometry&gt; skeletons &lt;- list(skeletonize(the_object));\t\t\t\t//Split of the skeletons list according to their intersection points\t\tlist&lt;geometry&gt; skeletons_split  &lt;- split_lines(skeletons);\t\tloop sk over: skeletons_split {\t\t\tcreate skeleton {\t\t\t\tshape &lt;- sk;\t\t\t}\t\t}\t\t\t\t//Creation of the graph using the edges resulting of the splitted skeleton\t\t the_graph &lt;- as_edge_graph(skeleton);\t\t \t\t \t\tcreate goal  {\t\t\t location &lt;- any_location_in (one_of(skeleton)); \t\t}\t\tcreate people number: 100 {\t\t\t target &lt;- one_of (goal) ; \t\t\t location &lt;- any_location_in (one_of(skeleton));\t\t} \t}}species object  {\taspect default {\t\tdraw shape color: #gray ;\t}}species triangle_obj  {\trgb color &lt;- rgb(150 +rnd(100),150 + rnd(100),150 + rnd(100));\taspect default {\t\tdraw shape color: color ; \t}}species skeleton  {\taspect default {\t\tdraw shape + 0.2 color: #red ;\t}}\tspecies goal {\taspect default {\t\tdraw circle(3) color:#red;\t}}species people skills: [moving] {\tgoal target;\tpath my_path; \t\treflex goto {\t\tdo goto on:the_graph target:target speed:1;\t}\taspect default {\t\tdraw circle(3) color: #green;\t}}experiment goto_polygon type: gui {\toutput {\t\tdisplay objects_display {\t\t\tspecies object aspect: default ;\t\t\tspecies triangle_obj aspect: default ;\t\t\tspecies skeleton aspect: default ;\t\t\tspecies people aspect: default ;\t\t\tspecies goal aspect: default ;\t\t}\t}}",
        "url":"/wiki/Agent-movement-Goto-Polygon.html"
      }
      ,
    
      "wiki-agent-movement-moving3d-html": {
        "title": "Movement in 3D",
        "content": "Movement in 3DAuthor :  Arnaud Grignard - Tri Nguyen HuuThis model illustrates the different action and effect offered by the movingSkill3D (move,wander,goto and follow)Code of the model :model Moving3DModel   global {\tint number_of_agents parameter: 'Number of Agents' min: 1 &lt;- 250 step:10 category: 'Initialization'; \tint envSize &lt;-100; //max:100;\tint mazeSize &lt;-10;\tint radius parameter: 'Radius' min: 1 &lt;- 1 ;\tint directionSize parameter: 'direction size' min: 1 &lt;- 10 ;\tstring effectType &lt;-\"\";// among:[\"\",\"firework\", \"blob\",\"direction\"];\tstring movingType &lt;-\"move\";\tgraph mazeGraph;\tgeometry shape &lt;- cube(envSize);\tbool trace &lt;-false;\tstring agentAspect &lt;- \"sphere\" among:[\"circle\", \"sphere\",\"direction\"];\tinit { \t\t\t\tif(movingType = \"move\" or movingType = \"complete\"){\t\t  create movingAgent number: number_of_agents{\t\t  \tif(effectType = \"firework\"){\t\t  \t  location &lt;- {envSize/2, envSize/2, envSize/2};\t\t\t  \t}\t\t  \telse{\t\t  \t\tlocation &lt;- {rnd(envSize), rnd(envSize), rnd(envSize)};\t\t  \t}\t\t    color&lt;-°red;\t\t\t  }\t\t\t}\t\t\t\tif(movingType = \"wander\" or movingType = \"complete\"){\t\t\tcreate wanderAgent number: number_of_agents{\t\t\t  location &lt;- {rnd(envSize), rnd(envSize), rnd(envSize)};\t\t\t  color&lt;-°green;\t\t\t\t}\t\t}\t\t\t\tif(movingType = \"goto\" or movingType = \"complete\"){\t\t\tcreate gotoAgent number: number_of_agents{\t\t\t  location &lt;- {rnd(envSize), rnd(envSize), rnd(envSize)};\t\t\t  myTarget &lt;-{rnd(envSize),rnd(envSize),rnd(envSize)};\t\t\t  color&lt;-°yellow;\t\t\t}\t\t}\t\t\t\tif(movingType = \"gotoOnNetwork\" or movingType = \"complete\"){\t\t\t\t\t\tloop i from:0 to:mazeSize{\t\t      loop j from:0 to: mazeSize{\t\t\t    loop k from:0 to:mazeSize{\t\t\t      create cell{\t\t\t\t    location &lt;-{(i)*envSize/mazeSize,(j)*envSize/mazeSize, (k)*envSize/mazeSize};\t\t\t      }\t\t\t\t    }\t\t          }\t\t    }\t\t    create gotoAgentOnNetwork number: number_of_agents{\t\t\t  location &lt;- {floor(rnd(envSize)/mazeSize)*10, floor(rnd(envSize)/mazeSize)*10, floor(rnd(envSize)/mazeSize)*10};\t\t\t  myTarget &lt;-{0,0,0};\t\t\t  speed &lt;-0.1;\t\t\t  color&lt;-°orange;\t\t\t\t\t}\t\t    mazeGraph &lt;- as_distance_graph(cell, [\"distance\"::10.0,\"species\"::edge_agent]);\t\t}\t }}species abstractAgent skills: [moving3D]{\trgb color;\taspect default {\t\tif(agentAspect = \"sphere\"){\t\t\tdraw sphere(radius) color:color;\t\t}\t\tif(agentAspect = \"circle\"){\t\t\tdraw circle(radius) color:color;\t\t}\t\tif(agentAspect = \"direction\"){\t\t  draw sphere(radius) color:color;          draw line([{location.x,location.y,location.z},{location.x+directionSize*cos(pitch)*cos(heading),location.y+directionSize*cos(pitch)*sin(heading),location.z+directionSize*sin(pitch)}]) end_arrow:1.0 color:color;\t\t\t}  \t \t    }} species movingAgent  parent:abstractAgent{ \treflex move{\t  do move;\t}\t\t}species wanderAgent parent:abstractAgent{ \treflex wander{\t  do wander amplitude:90;\t}}species gotoAgent parent:abstractAgent{ \tpoint myTarget;\tstring gotoType;\treflex goto{\t\tif(effectType = \"blob\"){\t\t\tmyTarget&lt;-{rnd(envSize),rnd(envSize),rnd(envSize)};\t\t}\t  \tdo goto target:myTarget;\t  \t}}species gotoAgentOnNetwork parent:abstractAgent{ \tpoint myTarget;\tstring gotoType;\treflex goto{\t  \tdo goto target:myTarget on: mazeGraph;\t}\t\t}species followAgent parent:abstractAgent{ \tpoint myTarget;\tstring gotoType;\treflex goto{\t  if(gotoType = \"goto\"){\t  \tdo goto target:myTarget;\t  }\t  if(gotoType = \"gotoOnNetwork\"){\t  \tdo goto target:myTarget on: mazeGraph;\t  }\t  \t}\t}    species cell schedules:[]{\t\taspect myPoint{\t\tdraw sphere(0.01 * envSize/mazeSize) color:rgb(255,255,255,0.5) at:location ;\t}\t}species edge_agent schedules:[]{\taspect base2 {\t\tdraw shape color: rgb(255,255,255);\t}}\texperiment Moving  type: gui {\tparameter \"Trace\" var:trace &lt;- false;\tparameter \"Movement\" var:movingType &lt;- \"move\";\tparameter \"Agent Aspect\" var:agentAspect &lt;- \"direction\";\tparameter \"Effect type\" var:effectType &lt;- \"\" among:[\"\",\"firework\"];\toutput {\t\t\tdisplay MovingAgent type:opengl  background:rgb(10,40,55) {\t\t\tspecies movingAgent trace:trace;\t\t}\t}}experiment Wandering  type: gui {\tparameter \"Trace\" var:trace &lt;- false;\tparameter \"Movement\" var:movingType &lt;- \"wander\";\tparameter \"Agent Aspect\" var:agentAspect &lt;- \"direction\";\toutput {\t\t\tdisplay WanderingAgent type:opengl  background:rgb(10,40,55) {\t\t\tspecies wanderAgent trace:trace;\t\t}\t}}experiment Goto  type: gui {\tparameter \"Trace\" var:trace &lt;- false;\tparameter \"Movement\" var:movingType &lt;- \"goto\";\tparameter \"Agent Aspect\" var:agentAspect &lt;- \"direction\";\tparameter \"Effect Type\" var:effectType &lt;- \"\" among:[\"\",\"blob\"];\toutput {\t\t\tdisplay GotoAgent type:opengl  background:rgb(10,40,55) {\t\t\tspecies gotoAgent trace:trace;\t\t}\t}}experiment GotoOnNetwork  type: gui {\tparameter \"Trace\" var:trace &lt;- false;\tparameter \"Movement\" var:movingType &lt;- \"gotoOnNetwork\";\tparameter \"Agent Aspect\" var:agentAspect &lt;- \"direction\";\toutput {\t\t\t\t\tdisplay GotoOnNetworkAgent type:opengl background:rgb(10,40,55) {\t\t\tspecies gotoAgentOnNetwork trace:trace;\t\t\tspecies cell aspect:myPoint;\t\t\tspecies edge_agent aspect: base2 ;\t\t}\t}}experiment Complete  type: gui {\tparameter \"Trace\" var:trace &lt;- false;\tparameter \"Movement\" var:movingType &lt;- \"complete\";\tparameter \"Agent Aspect\" var:agentAspect &lt;- \"direction\";\toutput {\t\t\t\t\tdisplay GotoOnNetworkAgent type:opengl background:rgb(10,40,55) {\t\t\tspecies movingAgent position:{0,0,0} trace:trace;\t\t\tspecies wanderAgent position:{envSize,0,0} trace:trace;\t\t\tspecies gotoAgent position:{envSize*2,0,0} trace:trace;\t\t\tspecies gotoAgentOnNetwork position:{envSize*3,0,0} trace:trace;\t\t\tspecies cell aspect:myPoint position:{envSize*3,0,0};\t\t\tspecies edge_agent aspect: base2 position:{envSize*3,0,0};\t\t}\t}}",
        "url":"/wiki/Agent-movement-Moving3D.html"
      }
      ,
    
      "wiki-agent-movement-html": {
        "title": "Agent movement",
        "content": "Agent movementThis sub-section is composed of the following models :       Movement of an agent on different paths         Follow Weighted Network         Directed Graph Model         Movement on a Grid of Cells         Shortest Path Computation on a Graph         Movement on a Graph created by Polygons         Movement in 3D  ",
        "url":"/wiki/Agent-movement.html"
      }
      ,
    
      "wiki-agentbuiltin-html": {
        "title": "The 'agent' built-in species (Under Construction)",
        "content": "The ‘agent’ built-in species (Under Construction)As described in the presentation of GAML, the hierarchy of species derives from a single built-in species called agent. All its components (attributes, actions) will then be inherited by all direct or indirect children species (including model and experiment), with the exception of species that explicitly mention use_minimal_agents: true as a facet, which inherit from a stripped-down version of agent (see below).agent attributesagent defines several attributes, which form the minimal set of knowledge any agent will have in a model.  agent actions",
        "url":"/wiki/AgentBuiltIn.html"
      }
      ,
    
      "wiki-ants-foraging-and-sorting-ant-foraging-charts-examples-html": {
        "title": "Ant Foraging (Charts examples)",
        "content": "Ant Foraging (Charts examples)_Author : _Toy Model ant using the question of how ants search food and use pheromons to return to their nest once they did find food. In this model, the charts are particularly used.Code of the model :model antsglobal {\t//Number of ants\tint ants_number &lt;- 100 min: 1 max: 2000 ;\t//Evaporation value per cycle for the pheromons\tfloat evaporation_per_cycle &lt;- 5.0 min: 0.0 max: 240.0 ;\t//Diffusion rate for the pheromons\tfloat diffusion_rate &lt;- 1.0 min: 0.0 max: 1.0 ;\tbool use_icons &lt;- true ;\tbool display_state &lt;- true;\t//Size of the grid\tint gridsize &lt;- 75 ;\t//Center of the grid to put the location of the nest\tconst center type: point &lt;- { (gridsize / 2),  (gridsize / 2)} ;\tconst types type: file &lt;- (pgm_file('../images/environment75x75.pgm')) ;\tconst ant_shape_empty type: string &lt;- '../icons/ant.png' ;\tconst ant_shape_full type: string &lt;- '../icons/full_ant.png'  ;\tconst C00CC00 type: rgb &lt;- rgb('#00CC00') ;    \tconst C009900 type: rgb &lt;- rgb('#009900') ; \tconst C005500 type: rgb &lt;- rgb('#005500') ; \tint food_gathered &lt;- 0 ;   \tgeometry shape &lt;- square(gridsize);\tinit{  \t\t//Ant are placed randomly in the nest\t\tcreate ant number: ants_number with: [location::any_location_in (ant_grid(center))] ;\t}\t\t//Reflex to diffuse the road of pheromon on the grid\treflex diffuse {      diffuse var:road on:ant_grid proportion: diffusion_rate radius:2 propagation: gradient;   }}//Grid to discretize space for the food and the nestgrid ant_grid width: gridsize height: gridsize neighbors: 8 use_regular_agents: false {\tbool multiagent &lt;- true ;\tfloat road &lt;- 0.0 max:240.0 update: (road&lt;=evaporation_per_cycle) ? 0.0 : road-evaporation_per_cycle;\tint type &lt;- int(types at {grid_x,grid_y}) ;\tbool isNestLocation &lt;- (self distance_to center) &lt; 4 ; \tbool isFoodLocation &lt;- type = 2 ; \trgb color &lt;- isNestLocation ? °violet:((food &gt; 0)? °blue : ((road &lt; 0.001)? rgb ([100,100,100]) : ((road &gt; 2)? °white : ((road &gt; 0.5)? (C00CC00) : ((road &gt; 0.2)? (C009900) : (C005500)))))) update: isNestLocation ? °violet:((food &gt; 0)? °blue : ((road &lt; 0.001)? rgb ([100,100,100]) : ((road &gt; 2)? °white : ((road &gt; 0.5)? (C00CC00) : ((road &gt; 0.2)? (C009900) : (C005500)))))) ;\tint food &lt;- isFoodLocation ? 5 : 0 ;\tconst nest type: int &lt;- 300 - int(self distance_to center) ;\t}//Species ant that will move and follow a final state machinespecies ant skills: [moving] control: fsm {\tfloat speed &lt;- 2.0 ;\tant_grid place update: ant_grid (location ); \tstring im &lt;- 'ant_shape_empty' ;\tbool hasFood &lt;- false ;\treflex diffuse_road when:hasFood=true{      ant_grid(location).road &lt;- ant_grid(location).road + 100.0;   }   //Action to pick food\taction pick {\t\tim &lt;- ant_shape_full ;\t\thasFood &lt;- true ;\t\tplace.food &lt;- place.food - 1 ;\t}\t//Action to drop food\taction drop {\t\tfood_gathered &lt;- food_gathered + 1 ;\t\thasFood &lt;- false ;\t\theading &lt;- heading - 180 ;\t}\t//Action to chose the best place according to the possible food in the neighbour cells\taction choose_best_place type: ant_grid {\t\tlist&lt;ant_grid&gt; list_places &lt;- place.neighbors ;\t\tif (list_places count (each.food &gt; 0)) &gt; 0  {\t\t\treturn (list_places first_with (each.food &gt; 0)) ;\t\t} else {\t\t\t\tint min_nest  &lt;-  (list_places min_of (each.nest)) ;\t\t\t\tlist_places &lt;- list_places sort ((each.nest = min_nest) ? each.road :  0.0) ;\t\t\t\treturn last(list_places) ;\t\t\t}\t}\t\t//Initial state of the ant : wander until it finds food or find a road to follow\tstate wandering initial: true {\t\tdo wander amplitude:120 ;\t\ttransition to: carryingFood when: place.food &gt; 0 {\t\t\tdo pick ;\t\t}\t\ttransition to: followingRoad when: place.road &gt; 0.05 ;\t}\t//State to carry food to the nest once the food is found\tstate carryingFood {\t\tdo goto target: center ;\t\ttransition to: wandering when: place.isNestLocation { \t\t\tdo drop ;\t\t}\t}\t//State to follow a road \tstate followingRoad {\t\tlocation &lt;- (self choose_best_place []) as point ;\t\ttransition to: carryingFood when: place.food &gt; 0 {\t\t\tdo pick ;\t\t}\t\ttransition to: wandering when: (place.road &lt; 0.05) ;\t}\taspect text {\t\tif use_icons {\t\t\tdraw  hasFood ? file(ant_shape_full) : file(ant_shape_empty) rotate: heading at: location size: {7,5} ;\t\t} else {\t\t\tdraw circle(1.0) empty: !hasFood color: rgb ('orange') ;\t\t}\t\tif display_state {\t\t\tdraw state at: location + {-3,1.5} color: °white size: 0.8 ;\t\t}\t}\taspect default {\t\tdraw circle(1.0) empty: !hasFood color: #orange ; \t}}experiment Ant type: gui {\t//Parameters to play with  in the gui\tparameter 'Number of ants:' var: ants_number category: 'Model' ;\tparameter 'Evaporation of the signal (unit/cycle):' var: evaporation_per_cycle category: 'Model' ;\tparameter 'Rate of diffusion of the signal (%/cycle):' var: diffusion_rate category: 'Model' ;\tparameter 'Use icons for the agents:' var: use_icons category: 'Display' ;\tparameter 'Display state of agents:' var: display_state category: 'Display' ;\tlist&lt;list&lt;int&gt;&gt; nbants&lt;-[[0]];\tlist&lt;string&gt; statesnames&lt;-[\"\"];\tlist&lt;string&gt; categnames&lt;-[\"empty\",\"carry\"];\tlist&lt;list&lt;int&gt;&gt; nbantsbydist&lt;-[[0]];\tlist xytestvallist&lt;-[[[1,1],[2,2],[3,3]],[[1,2],[2,1],[3,4]],[[1,3],[2,3],[0,1]],[[1,4],[2,5],[0,0]]];\tlist&lt;list&lt;int&gt;&gt; xyval&lt;-[[1,1],[2,1],[3,2]];\t\t//Reflex to update the charts, belonging to the experiment bloc as it will not be used by other experiment which don't have the charts\treflex update_charts\t{\t\tnbants&lt;-[];\t\tstatesnames&lt;-[];\t\tcategnames&lt;-[\"empty\",\"carry\"];\t\tnbantsbydist&lt;-[];\t\tant x&lt;-one_of(world.ant);\t\tloop x over:list(world.ant)\t\t{\t\t\tif !(statesnames contains (x.state))\t\t\t{\t\t\t\t\t\t\tadd [(list(ant) count (each.state=x.state and !each.hasFood)),(list(ant) count (each.state=x.state and each.hasFood))] to: nbants;\t\t\tadd (x.state) to:statesnames;\t\t\t\t\t\t\tint d&lt;-0;\t\t\tlist&lt;int&gt; nl&lt;-[];\t\t\tloop d from:0 to:9\t\t\t\t{\t\t\tadd (list(ant) count (each.state=x.state and (((each distance_to center)&gt;gridsize/20*d) and ((each distance_to center)&lt;gridsize/20*(d+1))))) to: nl;\t\t\t\t}\t\t\tadd nl to:nbantsbydist;\t\t\t}//\t\t\tadd length((list(world.ant) collect (each.next_place distance_to each.location)) where (each=x)) to:nbants;\t\t}\t\t//write(\"nbants\"+nbants);\t\t//write(\"nbantsbydist\"+nbantsbydist);\t\t//write(\"states\"+statesnames);\t\t\t}\t//The different displays\toutput {\t\tdisplay Ants type: opengl {\t\t\tgrid ant_grid ;\t\t\tspecies ant aspect: text ;\t\t}\t\tdisplay ChartPie {\t\t\tchart \"DataPie\" type:pie\t\t\t{\t\t\t\tdata \"empty_ants\" value:(list(ant) count (!each.hasFood)) color:°red;\t\t\t\tdata \"carry_food_ants\" value:(list(ant) count (each.hasFood)) color:°green;\t\t\t\t\t\t\t}\t\t\t\t\t\t}\t\tdisplay ChartPieList {\t\t\tchart \"DataListPie\" type:pie style:exploded\t\t\t{\t\t\t\tdatalist [\"empty\",\"carry\"] value:[(list(ant) count (!each.hasFood)),(list(ant) count (each.hasFood))] color:[°red,°green];\t\t\t\t\t\t\t}\t\t}\t\tdisplay ChartHisto {\t\t\tchart \"DataBar\" type:histogram\t\t\t{\t\t\t\tdata \"empty_ants\" value:(list(ant) count (!each.hasFood)) color:°red;\t\t\t\tdata \"carry_food_ants\" value:(list(ant) count (each.hasFood)) color:°green;\t\t\t\t\t\t\t}\t\t\t\t\t\t}\t\tdisplay ChartHistoList {\t\t\tchart \"DataListBar\" type:histogram style:\"3d\"\t\t\t{\t\t\t\tdatalist [\"empty\",\"carry\"] value:[(list(ant) count (!each.hasFood)),(list(ant) count (each.hasFood))] color:[°red,°green];\t\t\t\t\t\t\t}\t\t}\t\tdisplay ChartHistoListList {\t\t\tchart \"DataListListBar\" type:histogram\t\t\t{\t\t\t\tdatalist categoriesnames:categnames  value:nbants legend:statesnames inverse_series_categories :false style:stack;\t\t\t}\t\t}\t\tdisplay ChartSerie {\t\t\tchart \"DataSeries\" type:series\t\t\t{\t\t\t\tdata \"empty_ants\" value:float((list(ant) count (!each.hasFood))) color:°red;\t\t\t\tdata \"carry_food_ants\" value:float((list(ant) count (each.hasFood))) color:°green;\t\t\t\t\t\t\t}\t\t\t\t\t\t}\t\tdisplay Dispscaleoption\t\t{\t\t\tchart \"simpleserieslist\" type:series  y_range:{-6.11, -4.11} x_tick_unit:0.5 y_tick_unit:0.05\t\t\t{\t\t\t\tdata value:[-5,-6,-8] legend:\"prems\" color:°blue marker_shape:marker_square fill:false;\t\t\t\tdata value:[-5.5,-4.11,-5.645] legend:\"sec\" color:°red marker_shape:marker_empty;\t\t\t\tdata value:[-7,-6,-4.654] legend:\"third\" color:°green marker_shape:marker_hor_ellipse fill:false;\t\t\t}\t\t}\t\tdisplay Cyclevalues\t\t{\t\t\tchart \"simplecyclelist\" type:xy x_tick_unit:0.5 y_tick_unit:0.5\t\t\t{\t\t\t\tdata value:{-5+cycle,-4} legend:\"prems\" color:°blue marker_shape:marker_square fill:false;\t\t\t\tdata value:{-5.5+cycle,-3.5} legend:\"sec\" color:°red marker_shape:marker_diamond;\t\t\t\tdata value:{-7+cycle,-4.654} legend:\"third\" color:°green marker_shape:marker_hor_ellipse fill:false;\t\t\t}\t\t}\t\t\tdisplay ChartSerieList {\t\t\tchart \"DataListSeries\" type:series\t\t\t{\t\t\t\tdatalist [\"food\",\"empty\"] value:[(list(ant) count (each.hasFood)),(list(ant) count (!each.hasFood))] color:[°purple,°black] style:area;\t\t\t\t\t\t\t}\t\t}\t\tdisplay ChartSeriesListList {\t\t\tchart \"DataListListSeries\" type:series\t\t\t{\t\t\t\tdatalist categoriesnames:categnames  value:nbants legend:statesnames inverse_series_categories :false style:line;\t\t\t}\t\t}\t\tdisplay ChartScatter {\t\t\tchart \"DataScatter\" type:scatter\t\t\t{\t\t\t\tdata \"empty_ants\" value:((list(ant) where (!each.hasFood)) collect each.location) color:°red line_visible:false;\t\t\t\tdata \"carry_food_ants\" value:((list(ant) where (each.hasFood)) collect each.location) color:°green line_visible:false;\t\t\t\t\t\t\t}\t\t\t\t\t\t}\t\tdisplay ChartScatterList {\t\t\tchart \"DataListScatter\" type:scatter\t\t\t{\t\t\t\tdatalist [\"empty\",\"carry\"] value:[((list(ant) where (!each.hasFood))  collect each.location),((list(ant) where (each.hasFood))  collect each.location)] color:[°red,°green] line_visible:false;\t\t\t\t\t\t\t}\t\t}\t\tdisplay ChartScatterHistory {\t\t\tchart \"DataListScatterHistory\" type:scatter\t\t\t{\t\t\t\tdatalist [\"empty\",\"carry\"] value:[mean((list(ant) where (!each.hasFood)) collect each.location),mean((list(ant) where (each.hasFood)) collect each.location)]\t\t\t\t\t color:[°red,°green] line_visible:true;\t\t\t\t\t\t\t}\t\t}\t\t\t}\t\t}\t//Experiment with only two display : the grid and the ants, and a chartexperiment AntOneDisp type: gui {\tparameter 'Number of ants:' var: ants_number category: 'Model' ;\tparameter 'Evaporation of the signal unit/cycle):' var: evaporation_per_cycle category: 'Model' ;\tparameter 'Rate of diffusion of the signal (%/cycle):' var: diffusion_rate category: 'Model' ;\tparameter 'Use icons for the agents:' var: use_icons category: 'Display' ;\tparameter 'Display state of agents:' var: display_state category: 'Display' ;\tlist&lt;list&lt;int&gt;&gt; nbants&lt;-[[0]];\tlist&lt;string&gt; statesnames&lt;-[\"\"];\tlist&lt;string&gt; categnames&lt;-[\"empty\",\"carry\"];\tlist&lt;list&lt;int&gt;&gt; nbantsbydist&lt;-[[0]];\tlist xytestvallist&lt;-[[[1,1],[2,2],[3,3]],[[1,2],[2,1],[3,4]],[[1,3],[2,3],[0,1]],[[1,4],[2,5],[0,0]]];\tlist&lt;list&lt;int&gt;&gt; xyval&lt;-[[1,1],[2,1],[3,2]];\treflex update_charts\t{\t\tant x&lt;-one_of(world.ant);\t\tloop x over:list(world.ant)\t\t{\t\t\tif !(statesnames contains (x.state))\t\t\t{\t\t\t\t\t\t\tadd [(list(ant) count (each.state=x.state and !each.hasFood)),(list(ant) count (each.state=x.state and each.hasFood))] to: nbants;\t\t\tadd (x.state) to:statesnames;\t\t\t\t\t\t\tint d&lt;-0;\t\t\tlist&lt;int&gt; nl&lt;-[];\t\t\tloop d from:0 to:9\t\t\t\t{\t\t\tadd (list(ant) count (each.state=x.state and (((each distance_to center)&gt;gridsize/20*d) and ((each distance_to center)&lt;gridsize/20*(d+1))))) to: nl;\t\t\t\t}\t\t\tadd nl to:nbantsbydist;\t\t\t}\t\t}\t\twrite(\"nbants\"+nbants);\t\twrite(\"nbantsbydist\"+nbantsbydist);\t\twrite(\"states\"+statesnames);\t\t\t}\toutput {\t\tdisplay Ants type: opengl {\t\t\tgrid ant_grid ;\t\t\tspecies ant aspect: text ;\t\t}\t\tdisplay ChartSerieList {\t\t\tchart \"DataListScatterHistory\" type:scatter\t\t\t{\t\t\t\tdatalist [\"empty\",\"carry\"] value:[mean((list(ant) where (!each.hasFood)) collect each.location),mean((list(ant) where (each.hasFood)) collect each.location)]\t\t\t\t\t color:[°red,°green] line_visible:true;\t\t\t\t\t\t\t}\t\t}\t}}",
        "url":"/wiki/Ants-(Foraging-and-Sorting)-Ant-Foraging-(Charts-examples).html"
      }
      ,
    
      "wiki-ants-foraging-and-sorting-ant-foraging-classic-html": {
        "title": "Ant Foraging (Classic)",
        "content": "Ant Foraging (Classic)_Author : _Toy Model ant using the question of how ants search food and use pheromons to return to their nest once they did find food. This model is considered as the classic one.Code of the model :model antsglobal {\t//Number of ants\tint ants_number &lt;- 100 min: 1 max: 2000 ;\t//Evaporation value per cycle\tfloat evaporation_per_cycle &lt;- 5.0 min: 0.0 max: 240.0 ;\t//Diffusion rate for the pheromon diffused among the grid\tfloat diffusion_rate &lt;- 0.5 min: 0.0 max: 1.0 ;\tbool use_icons &lt;- true ;\tbool display_state &lt;- true;\t//Size of the grid\tint gridsize &lt;- 75 ;\t//Center of the grid that will be used as a nest for the ants\tpoint center const: true &lt;- { (gridsize / 2),  (gridsize / 2)} ;\tfile types const: true &lt;- (pgm_file('../images/environment75x75.pgm')) ;\tstring ant_shape_empty const: true &lt;- '../icons/ant.png' ;\tstring ant_shape_full const: true &lt;- '../icons/full_ant.png'  ;\trgb C00CC00 const: true &lt;- rgb('#00CC00') ;    \trgb C009900 const: true &lt;- rgb('#009900') ; \trgb C005500 const: true &lt;- rgb('#005500') ; \tint food_gathered &lt;- 0 ;    \tgeometry shape &lt;- square(gridsize);\tinit{  \t\t//Creation of the ants that will be placed randomly in the nest\t\tcreate ant number: ants_number with: [location::any_location_in (ant_grid(center))] ;\t}\t//Reflex to diffuse the pheromon among the grid\treflex diffuse {      diffuse var:road on:ant_grid proportion: diffusion_rate radius:2 propagation: gradient;   }}//Grid that will be used to place the food in a discretized spacegrid ant_grid width: gridsize height: gridsize neighbors: 8 use_regular_agents: false {\tlist&lt;ant_grid&gt; neighbours &lt;- self neighbors_at 1;\tfloat road &lt;- 0.0 max:240.0 update: (road&lt;=evaporation_per_cycle) ? 0.0 : road-evaporation_per_cycle;\tint type &lt;- int(types at {grid_x,grid_y}) ;\tbool isNestLocation &lt;- (self distance_to center) &lt; 4 ;\tbool isFoodLocation &lt;- type = 2 ; \trgb color &lt;- isNestLocation ? °sienna:((food &gt; 0)? °brown : ((road &lt; 0.001)? #darkgoldenrod: ((road &gt; 2)? °white : ((road &gt; 0.5)? (C00CC00) : ((road &gt; 0.2)? (C009900) : (C005500)))))) update: isNestLocation ? °sienna:((food &gt; 0)? °brown : ((road &lt; 0.001)?#darkgoldenrod : ((road &gt; 2)? °white : ((road &gt; 0.5)? (C00CC00) : ((road &gt; 0.2)? (C009900) : (C005500)))))) ;\tint food &lt;- isFoodLocation ? 5 : 0 ;\tint nest const: true &lt;- 300 - int(self distance_to center) ;\t}//Species ant that will move and follow a final state machinespecies ant skills: [moving] control: fsm {\tfloat speed &lt;- 2.0 ;\tant_grid place update: ant_grid (location ); \tstring im &lt;- 'ant_shape_empty' ;\tbool hasFood &lt;- false ;\t//Reflex to allow the diffusion of the road of pheromon by putting pheromon inside a cell\treflex diffuse_road when:hasFood=true{      ant_grid(location).road &lt;- ant_grid(location).road + 100.0;   }   //Action to pick the food\taction pick {\t\tim &lt;- ant_shape_full ;\t\thasFood &lt;- true ;\t\tplace.food &lt;- place.food - 1 ;\t}\t//Action to drop the food\taction drop {\t\tfood_gathered &lt;- food_gathered + 1 ;  \t\thasFood &lt;- false ;\t\theading &lt;- heading - 180 ;\t}\t//Action to find the best cell in the neighbourhood of the ant\taction choose_best_place type: ant_grid {  \t\tlist&lt;ant_grid&gt; list_places &lt;- place.neighbours ;\t\tif (list_places count (each.food &gt; 0)) &gt; 0  { \t\t\treturn (list_places first_with (each.food &gt; 0)) ;\t\t} else {\t\t\t\tint min_nest  &lt;-  (list_places min_of (each.nest)) ;\t\t\t\tlist_places &lt;- list_places sort ((each.nest = min_nest) ? each.road :  0.0) ;\t\t\t\treturn last(list_places) ;\t\t\t}\t} \t//initial state of the ant that will make it wander until it finds food or a road\tstate wandering initial: true { \t\tdo wander amplitude:120 ;\t\ttransition to: carryingFood when: place.food &gt; 0 {\t\t\t\t\t\t \t\t\tdo pick ;\t\t}\t\ttransition to: followingRoad when: place.road &gt; 0.05 ; \t}\t//State to carry food to the nest once it has been found\tstate carryingFood {\t\tdo goto target: center ;\t\ttransition to: wandering when: place.isNestLocation { \t\t\tdo drop ;\t\t}\t}\t//State to follow a pheromon road once it has been found\tstate followingRoad {\t\tlocation &lt;- (self choose_best_place()) as point ;\t\ttransition to: carryingFood when: place.food &gt; 0 {\t\t\tdo pick ;\t\t}\t\ttransition to: wandering when: (place.road &lt; 0.05) ;\t}\taspect text {\t\tif use_icons {\t\t\tdraw  hasFood ? file(ant_shape_full) : file(ant_shape_empty) rotate: heading at: location size: {8,5} ;\t\t} else {\t\t\tdraw circle(1.0) empty: !hasFood color: rgb ('orange') ;\t\t}\t\tif display_state {\t\t\tdraw state at: location + {-3,1.5} color: °white font: font(\"Helvetica\", 14 * #zoom, #plain) perspective:true;\t\t}\t} \taspect default {\t\tdraw circle(1.0) empty: !hasFood color: #orange ; \t}           }experiment Ant type: gui {\tparameter 'Number of ants:' var: ants_number category: 'Model' ;\tparameter 'Evaporation of the signal (unit/cycle):' var: evaporation_per_cycle category: 'Model' ;\tparameter 'Rate of diffusion of the signal (%/cycle):' var: diffusion_rate category: 'Model' ;\tparameter 'Use icons for the agents:' var: use_icons category: 'Display' ;\tparameter 'Display state of agents:' var: display_state category: 'Display' ;\toutput {\t\tdisplay Ants type: opengl  {\t\t\tgrid ant_grid ;\t\t\tspecies ant aspect: text ;\t\t}\t}}",
        "url":"/wiki/Ants-(Foraging-and-Sorting)-Ant-Foraging-(Classic).html"
      }
      ,
    
      "wiki-ants-foraging-and-sorting-ant-foraging-complex-html": {
        "title": "Ant Foraging (Complex)",
        "content": "Ant Foraging (Complex)_Author : _Toy Model ant using the question of how ants search food and use pheromons to return to their nest once they did find food. Two experiments are proposed to show how to use batch : Batch and Genetic.Code of the model :model antsglobal {\t//Evaporation value per cycle\tfloat evaporation_per_cycle &lt;- 5.0 min: 0.0 max: 240.0 parameter: 'Evaporation of the signal (unit/cycle):' category: 'Signals';\t//Diffusion rate of the pheromon among the grid\tfloat diffusion_rate &lt;- 1.0 min: 0.0 max: 1.0 parameter: 'Rate of diffusion of the signal (%/cycle):' category: 'Signals';\t//Size of the grid\tint gridsize &lt;- 100 min: 30 parameter: 'Width and Height of the grid:' category: 'Environment and Population';\t//Number of ants\tint ants_number &lt;- 200 min: 1 parameter: 'Number of ants:' category: 'Environment and Population';\t//Frequency of update of the grid\tint grid_frequency &lt;- 1 min: 1 max: 100 parameter: 'Grid updates itself every:' category: 'Environment and Population';\t//Number of food places among the grid\tint number_of_food_places &lt;- 5 min: 1 parameter: 'Number of food depots:' category: 'Environment and Population';\tfloat grid_transparency &lt;- 1.0;\tfile ant_shape_empty const: true &lt;- file('../icons/ant.png');\timage_file ant_shape_full const: true &lt;- file('../icons/full_ant.png');\t//The center of the grid that will be considered as the nest location\tpoint center const: true &lt;- { round(gridsize / 2), round(gridsize / 2) };\tint food_gathered &lt;- 1;\tint food_placed &lt;- 1;\trgb background const: true &lt;- rgb(#99CC66);\trgb food_color const: true &lt;- rgb(#312200);\trgb nest_color const: true &lt;- rgb(#000000); \tgeometry shape &lt;- square(gridsize);\tinit {\t\t//Creation of the food places placed randomly with a certain distance between each\t\tloop times: number_of_food_places {\t\t\tpoint loc &lt;- { rnd(gridsize - 10) + 5, rnd(gridsize - 10) + 5 };\t\t\tlist&lt;ant_grid&gt; food_places &lt;- (ant_grid where ((each distance_to loc) &lt; 5));\t\t\task food_places {\t\t\t\tif food = 0 {\t\t\t\t\tfood &lt;- 5;\t\t\t\t\tfood_placed &lt;- food_placed + 5;\t\t\t\t\tcolor &lt;- food_color;  \t\t\t\t}                                           \t\t\t}\t\t}\t\t//Creation of the ants that will be placed in the nest\t\tcreate ant number: ants_number with: (location: center);\t}\t//Reflex to diffuse the pheromon among the grid\treflex diffuse {      diffuse var:road on:ant_grid proportion: diffusion_rate radius:3 propagation: gradient method:convolution;   }  }//Grid used to discretize the space to place foodgrid ant_grid width: gridsize height: gridsize neighbors: 8 frequency: grid_frequency use_regular_agents: false use_individual_shapes: false{\tbool is_nest const: true &lt;- (topology(ant_grid) distance_between [self, center]) &lt; 4;\tfloat road &lt;- 0.0 max: 240.0 update: (road &lt;= evaporation_per_cycle) ? 0.0 : road - evaporation_per_cycle;\trgb color &lt;- is_nest ? nest_color : ((food &gt; 0) ? food_color : ((road &lt; 0.001) ? background : rgb(#009900) + int(road * 5))) update: is_nest ? nest_color : ((food &gt; 0) ?\tfood_color : ((road &lt; 0.001) ? background : rgb(#009900) + int(road * 5)));\tint food &lt;- 0;}//Species ant that will move and follow a final state machinespecies ant skills: [moving] control: fsm {\tfloat speed &lt;- 1.0;\tbool has_food &lt;- false;\t\t//Reflex to place a pheromon stock in the cell\treflex diffuse_road when:has_food=true{      ant_grid(location).road &lt;- ant_grid(location).road + 100.0;   }\t//Action to pick food\taction pick (int amount) {\t\thas_food &lt;- true;\t\tant_grid place &lt;- ant_grid(location);\t\tplace.food &lt;- place.food - amount;\t}\t//Action to drop food\taction drop {\t\tfood_gathered &lt;- food_gathered + 1;\t\thas_food &lt;- false;\t\theading &lt;- heading - 180;\t}\t//Action to find the best place in the neighborhood cells\tpoint choose_best_place {\t\tcontainer list_places &lt;- ant_grid(location).neighbors;\t\tif (list_places count (each.food &gt; 0)) &gt; 0 {\t\t\treturn point(list_places first_with (each.food &gt; 0));\t\t} else {\t\t\tlist_places &lt;- (list_places where ((each.road &gt; 0) and ((each distance_to center) &gt; (self distance_to center)))) sort_by (each.road);\t\t\treturn point(last(list_places));\t\t}\t}\t//Reflex to drop food once the ant is in the nest\treflex drop when: has_food and (ant_grid(location)).is_nest {\t\tdo drop();\t}\t//Reflex to pick food when there is one at the same location\treflex pick when: !has_food and (ant_grid(location)).food &gt; 0 {\t\tdo pick(1);\t}\t//Initial state to make the ant wander \tstate wandering initial: true {\t\tdo wander(amplitude: 90);\t\tfloat pr &lt;- (ant_grid(location)).road;\t\ttransition to: carryingFood when: has_food;\t\ttransition to: followingRoad when: (pr &gt; 0.05) and (pr &lt; 4);\t}\t//State to carry food once it has been found\tstate carryingFood {\t\tdo goto(target: center);\t\ttransition to: wandering when: !has_food;\t}\t//State to follow a pheromon road if once has been found\tstate followingRoad {\t\tpoint next_place &lt;- choose_best_place();\t\tfloat pr &lt;- (ant_grid(location)).road;\t\tlocation &lt;- next_place;\t\ttransition to: carryingFood when: has_food;\t\ttransition to: wandering when: (pr &lt; 0.05) or (next_place = nil);\t}\taspect info {\t\tdraw circle(1) empty: !has_food color: #red;\t\tif (destination != nil) {\t\t\tdraw line([location + {0,0,0.5}, destination + {0,0,0.5}]) + 0.1 color: #white border: false;\t\t}\t\tdraw circle(4) empty: true color: #white;\t\tdraw string(self as int) color: #white font: font(\"Helvetica\", 12 * #zoom, #bold) at: my location - {1, 1, -0.5};\t\tdraw state color: #yellow  font: font(\"Helvetica\", 10 * #zoom, #plain) at: my location + { 1, 1, 0.5 } perspective: false;\t}\taspect icon {\t\tdraw ant_shape_empty size: {7,5} rotate: my heading + 1;\t}\taspect default {\t\tdraw square(1) empty: !has_food color: #blue rotate: my heading;\t}}\t//Simple experiment to display the antsexperiment Displays type: gui {\tpoint quadrant_size &lt;- { 0.5, 0.5 };\tfloat inc &lt;- 0.001;\tfloat pos &lt;- 0.0;\treflex moving_quadrant {\t//pos &lt;- pos + inc;\t\tif (pos &gt; 0.5 or pos &lt;= 0) {\t\t\tinc &lt;- -inc;\t\t}\t\t\t}\toutput {\t\tdisplay Ants background: #white type: opengl {\t\t\timage '../images/soil.jpg' position: { pos, pos } size: quadrant_size;\t\t\tagents \"agents\" transparency: 0.5 position: { pos, pos } size: quadrant_size value: (ant_grid as list) where ((each.food &gt; 0) or (each.road &gt; 0) or (each.is_nest));\t\t\tspecies ant position: { pos, pos } size: quadrant_size aspect: icon;\t\t\tgrid ant_grid lines: #darkgray position: { 0.5, 0 } size: quadrant_size;\t\t\tspecies ant position: { 0.5, 0 } size: quadrant_size aspect: info;\t\t}\t}}//Complete experiment that will inspect all ants in a tableexperiment Complete type: gui {\tparameter 'Number:' var: ants_number init: 100 unit: 'ants' category: 'Environment and Population';\tparameter 'Grid dimension:' var: gridsize init: 100 unit: '(number of rows and columns)' category: 'Environment and Population';\tparameter 'Number of food depots:' var: number_of_food_places init: 5 min: 1 category: 'Environment and Population';\t// Experimentator\tinit {\t\twrite \"Experimentator agent running \" + self;\t   ants_number &lt;- 200;\t}\toutput {\t\tdisplay Ants2D type: java2D {\t\t\timage '../images/soil.jpg' position: { 0.05, 0.05 } size: { 0.9, 0.9 };\t\t\tagents \"agents\" transparency: 0.7 position: { 0.05, 0.05 } size: { 0.9, 0.9 } value: (ant_grid as list) where ((each.food &gt; 0) or (each.road &gt; 0) or (each.is_nest)) ;\t\t\tspecies ant position: { 0.05, 0.05 } size: { 0.9, 0.9 } aspect: icon;\t\t\toverlay \"Texts\" transparency: 0.3 background: rgb (99, 85, 66,255)  position: {10°px, 10°px} size: {250°px, 150°px} border: rgb (99, 85, 66,255) rounded: true{\t\t\t\tdraw ant_shape_full at: {60°px, 70°px} size: {140°px, 100°px} rotate: -60;\t\t\t\tdraw ('Food foraged: ' + (((food_placed = 0 ? 0 : food_gathered / food_placed) * 100) with_precision 2) + '%') at: {40°px,70°px} font:font(\"Arial\", 18, #bold) color: #white;\t\t\t\tdraw ('Carrying ants: ' + (((100 * ant count (each.has_food or each.state = \"followingRoad\")) / length(ant)) with_precision 2) + '%') at: {40°px, 100°px} font:font(\"Arial\", 18 , #bold) color: #white;\t\t\t}\t\t\t\t\t\t\t}\t\tinspect \"All ants\" type: table value: ant attributes: ['name', 'location', 'heading','state'];\t}}//Batch experiment to find the best way to maximize the food gathered using exhaustive methodexperiment Batch type: batch repeat: 4 keep_seed: true until: (food_gathered = food_placed) or (time &gt; 1000) {\tparameter 'Size of the grid:' var: gridsize init: 75 unit: 'width and height';\tparameter 'Number:' var: ants_number among:[10,20,50] unit: 'ants';\tparameter  'Evaporation:' var: evaporation_per_cycle among: [0.1, 0.5, 2.0, 10.0] unit: 'units every cycle';\tparameter  'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.2;\tmethod exhaustive maximize: food_gathered;\t\tpermanent {\t\tdisplay Comparison background: #white {\t\t\tchart \"Food Gathered\" type: series {\t\t\t\t\tdata \"Min\" value:  min(ants_model collect each.food_gathered ) style: spline color: #darkgreen ;\t\t\t\t\tdata \"Max\" value:  max(ants_model collect each.food_gathered ) style: spline color: #red ;\t\t\t}\t\t}\t}}//Batch experiment to find the best way to maximize the food gathered using genetic methodexperiment Genetic type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed) or (time &gt; 1000) {\tparameter 'Size of the grid:' var: gridsize init: 75 unit: '(width and height)';\tparameter 'Number:' var: ants_number among:[10,20,50] unit: 'ants';\tparameter  'Evaporation:' var: evaporation_per_cycle among: [0.1, 0.5, 2.0, 10.0] unit: 'units every cycle';\tparameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.2;\tmethod genetic maximize: food_gathered pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 20;\t\t\tpermanent {\t\tdisplay Comparison background: #white {\t\t\tchart \"Food Gathered\" type: series {\t\t\t\t\tdata \"Min\" value:  min(ants_model collect each.food_gathered ) style: spline color: #darkgreen ;\t\t\t\t\tdata \"Max\" value:  max(ants_model collect each.food_gathered ) style: spline color: #red ;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Ants-(Foraging-and-Sorting)-Ant-Foraging-(Complex).html"
      }
      ,
    
      "wiki-ants-foraging-and-sorting-ant-foraging-multi-simulation-html": {
        "title": "Ant Foraging (Multi-Simulation)",
        "content": "Ant Foraging (Multi-Simulation)_Author : _Toy Model ant using the question of how ants search food and use pheromons to return to their nest once they did find food.Code of the model :model antsglobal {\t//Evaporation value per cycle of the pheromons\tfloat evaporation_per_cycle &lt;- 5.0 min: 0.0 max: 240.0 parameter: 'Evaporation of the signal (unit/cycle):' category: 'Signals';\t//Diffusion rate of the pheromons\tfloat diffusion_rate &lt;- 1.0 min: 0.0 max: 1.0 parameter: 'Rate of diffusion of the signal (%/cycle):' category: 'Signals';\t//Size of the grid\tint gridsize &lt;- 100 min: 30 parameter: 'Width and Height of the grid:' category: 'Environment and Population';\t//Number of ants that will be created\tint ants_number &lt;- 50 min: 1 parameter: 'Number of ants:' category: 'Environment and Population';\t//Number of food places to create\tint number_of_food_places &lt;- 5 min: 1 parameter: 'Number of food depots:' category: 'Environment and Population';\tfloat grid_transparency &lt;- 1.0;\tfile ant_shape_empty const: true &lt;- file('../icons/ant.png');\tstring ant_shape_full const: true &lt;- '../icons/full_ant.png';\tpoint center const: true &lt;- { round(gridsize / 2), round(gridsize / 2) };\tint food_gathered  &lt;- 1;\tint food_placed  &lt;- 1;\trgb background const: true &lt;- rgb(#99CC66);\trgb food_color const: true &lt;- rgb(#312200);\trgb nest_color const: true &lt;- rgb(#000000); \tgeometry shape &lt;- square(gridsize);\tinit {\t\t//Creation of the food places placed randomly with a certain distance between each\t\tloop times: number_of_food_places {\t\t\tpoint loc &lt;- { rnd(gridsize - 10) + 5, rnd(gridsize - 10) + 5 };\t\t\tlist&lt;ant_grid&gt; food_places &lt;- (ant_grid where ((each distance_to loc) &lt; 5));\t\t\task food_places {\t\t\t\tif food = 0 {\t\t\t\t\tfood &lt;- 5;\t\t\t\t\tfood_placed &lt;- food_placed + 5;\t\t\t\t\tcolor &lt;- food_color;  \t\t\t\t}                                           \t\t\t}\t\t}\t\t//Creation of the ants that will be placed in the nest\t\tcreate ant number: ants_number with: (location: center);\t\t//Write the index of the simulation\t\twrite \"Simulation \" + int(self) + \" created\";\t}\t//Reflex to diffuse the pheromon among the grid\treflex diffuse {      diffuse var:road on:ant_grid proportion: diffusion_rate radius:2 propagation: gradient;   }    } //Grid used to discretize the space to place foodgrid ant_grid width: gridsize height: gridsize neighbors: 8 /*frequency: grid_frequency*/ use_regular_agents: false use_individual_shapes: false{\tbool is_nest const: true &lt;- (topology(ant_grid) distance_between [self, center]) &lt; 4;\tfloat road &lt;- 0.0 max:240.0 update: (road&lt;=evaporation_per_cycle) ? 0.0 : road-evaporation_per_cycle;\trgb color &lt;- is_nest ? nest_color : ((food &gt; 0) ? food_color : ((road &lt; 0.001) ? background : rgb(#009900) + int(road * 5))) update: is_nest ? nest_color : ((food &gt; 0) ?\tfood_color : ((road &lt; 0.001) ? background : rgb(#009900) + int(road * 5)));\tint food &lt;- 0;}//Species ant that will move and follow a final state machinespecies ant skills: [moving] control: fsm {\tfloat speed &lt;- 1.0;\tbool has_food &lt;- false;\t\t//Reflex to place a pheromon stock in the cell\treflex diffuse_road when:has_food=true{      ant_grid(location).road &lt;- ant_grid(location).road + 100.0;   }\t//Action to pick food\taction pick (int amount) {\t\thas_food &lt;- true;\t\tant_grid place &lt;- ant_grid(location);\t\tplace.food &lt;- place.food - amount;\t}\t//Action to drop food\taction drop {\t\tfood_gathered &lt;- food_gathered + 1;\t\thas_food &lt;- false;\t\theading &lt;- heading - 180;\t}\t//Action to find the best place in the neighborhood cells\t\tpoint choose_best_place {\t\tlist&lt;ant_grid&gt; list_places &lt;- ant_grid(location).neighbors;\t\tif (list_places count (each.food &gt; 0)) &gt; 0 {\t\t\treturn point(list_places first_with (each.food &gt; 0));\t\t} else {\t\t\tlist_places &lt;- (list_places where ((each.road &gt; 0) and ((each distance_to center) &gt; (self distance_to center)))) sort_by (each.road);\t\t\treturn point(last(list_places));\t\t}\t}\t//Reflex to drop food once the ant is in the nest\t\treflex drop when: has_food and (ant_grid(location)).is_nest {\t\tdo drop();\t}\t//Reflex to pick food when there is one at the same location\treflex pick when: !has_food and (ant_grid(location)).food &gt; 0 {\t\tdo pick(1);\t}\t//Initial state to make the ant wander \tstate wandering initial: true {\t\tdo wander(amplitude: 90);\t\tfloat pr &lt;- (ant_grid(location)).road;\t\ttransition to: carryingFood when: has_food;\t\ttransition to: followingRoad when: (pr &gt; 0.05) and (pr &lt; 4);\t}\t//State to carry food once it has been found\tstate carryingFood {\t\tdo goto(target: center);\t\ttransition to: wandering when: !has_food;\t}\t//State to follow a pheromon road if once has been found\tstate followingRoad {\t\tpoint next_place &lt;- choose_best_place();\t\tfloat pr &lt;- (ant_grid(location)).road;\t\tlocation &lt;- next_place;\t\ttransition to: carryingFood when: has_food;\t\ttransition to: wandering when: (pr &lt; 0.05) or (next_place = nil);\t}\taspect icon {\t\tdraw ant_shape_empty size: {8,6} rotate: my heading + 1;\t}}\t//Experiment to show how to make multi simulationsexperiment \"4 Simulations\" type: gui {\tparameter 'Number:' var: ants_number init: 100 unit: 'ants' category: 'Environment and Population';\tparameter 'Grid dimension:' var: gridsize init: 100 unit: '(number of rows and columns)' category: 'Environment and Population';\tparameter 'Number of food depots:' var: number_of_food_places init: 5 min: 1 category: 'Environment and Population';\t// We create three supplementary simulations using the species name 'ants_model' (automatically created from the name of the model + '_model')\tinit {\t\tcreate ants_model with: [ants_number::200,evaporation_rate::0.7,diffusion_rate::0.2];\t\tcreate ants_model with: [ants_number::50,evaporation_rate::0.05,diffusion_rate::0.8];\t\tcreate ants_model with: [ants_number::10,evaporation_rate::0.3,diffusion_rate::0.6];\t}\t\tpermanent {\t\tdisplay Comparison background: #white {\t\t\tchart \"Food Gathered\" type: series {\t\t\t\tloop s over: simulations {\t\t\t\t\tdata \"Food \" + int(s) value: s.food_gathered color: s.color marker: false style: line ;\t\t\t\t}\t\t\t}\t\t}\t}\toutput {\t\tdisplay Ants background: #white type: opengl{\t\t\timage '../images/soil.jpg' position: { 0.05, 0.05 } size: { 0.9, 0.9 };\t\t\tagents \"agents\" transparency: 0.5 position: { 0.05, 0.05 } size: { 0.9, 0.9 } value: (ant_grid as list) where ((each.food &gt; 0) or (each.road &gt; 0) or (each.is_nest));\t\t\tspecies ant position: { 0.05, 0.05 } size: { 0.9, 0.9 } aspect: icon;\t\t}\t\t}}",
        "url":"/wiki/Ants-(Foraging-and-Sorting)-Ant-Foraging-(Multi-Simulation).html"
      }
      ,
    
      "wiki-ants-foraging-and-sorting-ant-foraging-simple-html": {
        "title": "Ant Foraging (Simple)",
        "content": "Ant Foraging (Simple)_Author : _Toy Model ant using the question of how ants search food and use pheromons to return to their nest once they did find food. This model is the simple one.Code of the model :model antsglobal {\tint t &lt;- 1;\t//Evaporation value per cycle of the pheromons\tfloat evaporation_per_cycle &lt;- 5.0 min: 0.01 max: 240.0 ;\t//Diffusion rate of the pheromons\tfloat diffusion_rate const: true &lt;- 1.0 min: 0.0 max: 1.0 ;\t//Size of the grid\tint gridsize const: true &lt;- 75; \t//Number of ants to create\tint ants_number  &lt;- 50 min: 1 max: 200 parameter: 'Number of Ants:';\t//Variable to keep information about the food remaining\tint food_remaining update: list ( ant_grid ) count ( each . food &gt; 0) &lt;- 10;\t//Center of the grid that will be considered as the nest of ants\tpoint center const: true &lt;- { round ( gridsize / 2 ) , round ( gridsize / 2 ) };\tmatrix&lt;int&gt; types &lt;- matrix&lt;int&gt; (pgm_file ( '../images/environment75x75_scarce.pgm' )); \t\tgeometry shape &lt;- square(gridsize);\t\tinit {\t\t//Creation of the ants placed in the nest\t\tcreate ant number: ants_number with: [ location :: center ];\t} \t\t//Different actions triggered by an user interaction\taction press (point loc, list selected_agents)\t{\t\twrite(\"press \" + loc.x + \" \" + loc.y + \" \"+selected_agents);\t}\taction release (point loc, list selected_agents)\t{\t\twrite(\"release\");\t}\taction click  (point loc, list selected_agents)\t{\t\twrite(\"click\");\t}\taction click2   (point loc, list selected_agents)\t{\t\twrite(\"click2\");\t}\t//Reflex to diffuse the pheromons among the grid\treflex diffuse {      diffuse var:road on:ant_grid proportion: diffusion_rate radius:2 propagation: gradient;   }} //Grid used to discretize space to place food in cellsgrid ant_grid width: gridsize height: gridsize neighbors: 8 {\tbool isNestLocation  &lt;- ( self distance_to center ) &lt; 4;\tbool isFoodLocation &lt;-  types[grid_x , grid_y] = 2;       \tlist&lt;ant_grid&gt; neighbours &lt;- self neighbors_at 1;  \tfloat road &lt;- 0.0 max:240.0 update: (road&lt;=evaporation_per_cycle) ? 0.0 : road-evaporation_per_cycle;\trgb color &lt;- rgb([ self.road &gt; 15 ? 255 : ( isNestLocation ? 125 : 0 ) , self.road * 30 , self.road &gt; 15 ? 255 : food * 50 ]) update: rgb([ self.road &gt; 15 ? 255 : ( isNestLocation ? 125 : 0 ) ,self.road * 30 , self.road &gt; 15 ? 255 : food * 50 ]); \tint food &lt;- isFoodLocation ? 5 : 0; \tint nest const: true &lt;- int(300 - ( self distance_to center ));}//Species ant that will movespecies ant skills: [ moving ] {     \trgb color &lt;- #red;\tant_grid place function: {ant_grid ( location )};\tbool hasFood &lt;- false; \tbool hasRoad &lt;- false update: place . road &gt; 0.05;\t\t//Reflex to diffuse pheromon on the cell once the agent has food\treflex diffuse_road when:hasFood=true{      ant_grid(location).road &lt;- ant_grid(location).road + 100.0;   }\t//Reflex to wander while the ant has no food\treflex wandering when: ( ! hasFood ) and ( ! hasRoad ) and ( place . food = 0) {\t\tdo wander amplitude: 120 speed: 1.0;\t}\t//Reflex to search food when the agent has no food nor pheromon road close\treflex looking when: ( ! hasFood ) and ( hasRoad ) and ( place . food = 0 ) { \t\tlist&lt;ant_grid&gt; list_places &lt;- place . neighbours;\t\tant_grid goal &lt;- list_places first_with ( each . food &gt; 0 );\t\tif goal != nil {\t\t\tlocation &lt;- goal.location ; \t\t} else {\t\t\tint min_nest &lt;- ( list_places min_of ( each . nest ) );\t\t\tlist_places &lt;- list_places sort ( ( each . nest = min_nest ) ? each . road : 0.0 ) ;\t\t\tlocation &lt;- point ( last ( list_places ) ) ;\t\t}\t}\t//Reflex to take food\treflex taking when: ( ! hasFood ) and ( place . food &gt; 0 ) { \t\thasFood &lt;- true ;\t\tplace . food &lt;- place . food - 1 ;\t}\t//Reflex to make the ant return to the nest once it has food\treflex homing when: ( hasFood ) and ( ! place . isNestLocation ) {\t\tdo goto target:center  speed:1.0;\t}\t//Reflex to drop food once the ant arrived at the nest\treflex dropping when: ( hasFood ) and ( place . isNestLocation ) {\t\thasFood &lt;- false ;\t\theading &lt;- heading - 180 ;\t}\taspect default {\t\tdraw circle(2.0) color: color;\t}\t}//Experiment simple to display ant and have user interactionexperiment Simple type:gui {\tparameter 'Evaporation:' var: evaporation_per_cycle;\tparameter 'Diffusion Rate:' var: diffusion_rate;\toutput { \t\tdisplay Ants refresh: every(2) { \t\t\tgrid ant_grid;\t\t\tspecies ant aspect: default;\t\t\tgraphics 'displayText' {\t\t\t\tdraw string ( food_remaining ) size: 24.0 at: { 20 , 20 } color: rgb ( 'white' );\t\t\t}\t\t\t//Event triggering the action passed in parameter\t\t\tevent mouse_down action:press;\t\t\tevent mouse_up action:release;\t\t}  \t\tdisplay Ants_2 refresh: every(2) { \t\t\tgrid ant_grid;\t\t\tgraphics 'displayText' {\t\t\t\tdraw string ( food_remaining ) size: 24.0 at: { 20 , 20 } color: rgb ( 'white' );\t\t\t}\t\t\tevent mouse_down action:press;\t\t\tevent mouse_up action:click2;\t\t}  \t}}// This experiment explores two parameters with an exhaustive strategy, // repeating each simulation two times, in order to find the best combination // of parameters to minimize the time taken by ants to gather all the foodexperiment 'Exhaustive optimization' type: batch repeat: 2 keep_seed: true until: ( food_remaining = 0 ) or ( time &gt; 400 ) {\tparameter 'Evaporation' var: evaporation_per_cycle among: [ 0.1 , 1.0 , 2.0 , 5.0 ,  10.0 ];\tparameter 'Diffusion rate' var: diffusion_rate min: 0.1 max: 1.0 step:\t0.3;\tmethod exhaustive minimize: time;}// This experiment simply explores two parameters with an exhaustive strategy, // repeating each simulation two timesexperiment Repeated type: batch repeat: 2 keep_seed: true until: (food_remaining = 0 ) or ( time &gt; 400 ) {\tparameter 'Evaporation' var: evaporation_per_cycle among: [ 0.1 , 1.0 , 2.0 , 5.0 ,  10.0 ];\tparameter 'Diffusion rate' var: diffusion_rate min: 0.1 max: 1.0 step:0.3;}// This experiment explores two parameters with a GA strategy, // repeating each simulation two times, in order to find the best combination // of parameters to minimize the time taken by ants to gather all the food experiment Genetic type: batch keep_seed: true repeat: 3 until: ( food_remaining= 0 ) or ( time &gt; 400 ) {\tparameter 'Evaporation' var: evaporation_per_cycle min: 0.05 max: 10.0\tstep: 0.1;\tparameter 'Diffusion rate' var: diffusion_rate min: 0.0 max: 1.0 step:\t0.01;\tmethod genetic pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1\tnb_prelim_gen: 1 max_gen: 20 minimize: time;}",
        "url":"/wiki/Ants-(Foraging-and-Sorting)-Ant-Foraging-(Simple).html"
      }
      ,
    
      "wiki-ants-foraging-and-sorting-ant-sorting-html": {
        "title": "Ant Sorting",
        "content": "Ant Sorting_Author : _This model is loosely based on the behavior of ants sorting different elements in their nest. A of mobile agents - the ants - is placed on a grid. The grid itself contains cells of different colors. Each step, the agents move randomly. If they enter a colored cell, they pick this color if its density in the neighbourhood is less than number_of_objects_around. If they have picked a color, they drop it on a black cell if they have encountered at least number_of_objects_in_history cells with the same color.\\n After a while, colors begin to be aggregated.Code of the model :model ant_sortglobal  {\t// Parameters \tint number_of_different_colors &lt;- 5 max: 9 ;\tint density_percent &lt;- 30 min: 0 max: 99 ;\tint number_of_objects_in_history &lt;- 3 min: 0 ;\tint number_of_objects_around  &lt;- 5 min: 0 max: 8;\tint width_and_height_of_grid &lt;- 128 max: 400 min: 10 ;  \tint ants &lt;- 20 min: 1 ;\t\t//Action to kill all the ants\taction kill_all {\t\task ant {do die;}\t}\t\t//Action to create all the ants\taction create_all {\t\tcreate ant number: ants;\t}\trgb black &lt;- #black  ;\t\tlist&lt;rgb&gt; colors const: true &lt;- [#yellow,#red, #orange, #blue, #green,#cyan, #gray,#pink,#magenta] ;\t//Action to write the description of the model\taction description {\t\twrite \"\\n Description. \\n This model is loosely based on the behavior of ants sorting different elements in their nest. \\n A of mobile agents - the ants - is placed on a grid. The grid itself contains cells of different colors. Each step, the agents move randomly. If they enter a colored cell, they pick this color if its density in the neighbourhood is less than *number_of_objects_around*. If they have picked a color, they drop it on a black cell if they have encountered at least *number_of_objects_in_history* cells with the same color.\\n After a while, colors begin to be aggregated. \" ;\t\t}  \tinit { \t\tdo description ;\t\tdo create_all;\t} }//Species ant that will move and follow a final state machinespecies ant skills: [ moving ] control: fsm { \trgb color &lt;- #white ; \tant_grid place -&gt; {ant_grid (location)} ;\t\t//Reflex to make the ant wander\treflex wandering { \t\tdo wander amplitude: 120;\t}\t//Initial state that will change to full\tstate empty initial: true {\t\ttransition to: full when: (place.color != black) and ( (place.neighbors count (each.color = place.color)) &lt; (rnd(number_of_objects_around))) {\t\t\tcolor &lt;- place.color ;\t\t\tplace.color &lt;- black ; \t\t}\t}\t//State full that will change to black if the place color is empty and drop the color inside it\tstate full {\t\tenter { \t\t\tint encountered &lt;- 0; \t\t}\t\tif place.color = color { \t\t\tencountered &lt;- encountered + 1 ;\t\t}\t\ttransition to: empty when: (place.color = black) and (encountered &gt; number_of_objects_in_history) {\t\t\tplace.color &lt;- color ;\t\t\tcolor &lt;- black ;\t\t}\t}\taspect default {\t\tdraw file(\"../images/ant_normal.svg\") size:5 color: color rotate: heading - 90;\t\tdraw circle(5) empty: true color: color;\t}}//Grid that will use the density to determine the colorgrid ant_grid width: width_and_height_of_grid height: width_and_height_of_grid neighbors: 8 use_regular_agents: false frequency: 0{\trgb color &lt;- (rnd(100)) &lt; density_percent ? (colors at rnd(number_of_different_colors - 1)) : #black ;}\texperiment sort type: gui{\tparameter \"Number of colors:\" var: number_of_different_colors category: \"Environment\" ;\tparameter \"Density of colors:\" var: density_percent category: \"Environment\" ;\tparameter \"Number of similar colors in memory necessary to put down:\" var: number_of_objects_in_history category: \"Agents\" ;\tparameter \"Number of similar colors in perception necessary to pick up:\" var: number_of_objects_around category: \"Agents\" ;\tparameter \"Width and height of the grid:\" var: width_and_height_of_grid category: \"Environment\" ;\tparameter \"Number of agents:\" var: ants category: \"Agents\" ;\t\toutput {\t\tdisplay OpenGL type: opengl  {\t\t\tgrid ant_grid ;\t\t\tspecies ant transparency: 0.2 ;\t\t}\t}}",
        "url":"/wiki/Ants-(Foraging-and-Sorting)-Ant-Sorting.html"
      }
      ,
    
      "wiki-ants-foraging-and-sorting-html": {
        "title": "Ants (Foraging and Sorting)",
        "content": "Ants (Foraging and Sorting)This sub-section is composed of the following models :      Ant Foraging (Classic)        Ant Foraging (Complex)        Ant Foraging (Multi-Simulation)        Ant Foraging (Simple)        Ant Sorting  ",
        "url":"/wiki/Ants-(Foraging-and-Sorting).html"
      }
      ,
    
      "wiki-articles-prima-model1-html": {
        "title": "Prima 1",
        "content": "Prima 1_Author : _This model shows how to create agent and make them move randomly in the world. Some agents are infected, and others can gain the infection if they are in a certain range.Code of the model :model SI_cityglobal{\tgeometry shape&lt;-envelope(square(500));\t\t//Creation of the people agents\tinit{\t\tcreate people number:1000;\t}}//People species with agents moving and can be infectedspecies people skills:[moving]{\t\t\tfloat speed &lt;- 5.0 + rnd(5);\tbool is_infected &lt;- flip(0.01);\t//Make the agent wander at each step with a certain speed.\treflex move{\t\tdo wander;\t}\t//Infect the agent if it is not already infected, and according to the infected people in a range\treflex infect when: is_infected{\t\task people at_distance 10 {\t\t\tif flip(0.01) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(5) color:is_infected ? #red : #green;\t}}experiment main_experiment type:gui{\toutput {\t\tdisplay map  {\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t}}",
        "url":"/wiki/Articles-Prima_model1.html"
      }
      ,
    
      "wiki-articles-prima-model2-html": {
        "title": "Prima 2",
        "content": "Prima 2_Author : _This model shows how to create agent and make them move randomly in the world. Some agents are infected, and others can gain the infection if they are in a certain range. The people are now placed in buildings at the initial state. Those buildings are created thanks to a shapefile. Roads are also created thanks to an other shapefile.Code of the model :model model2  global {\t//Shapefile for the roads\tfile roads_shapefile &lt;- file(\"../includes/road.shp\");\t//Shapefile for the buildings\tfile buildings_shapefile &lt;- file(\"../includes/building.shp\");\t//Definition of the shape as the bounds of the roads shapefile\tgeometry shape &lt;- envelope(roads_shapefile);\tinit {\t\t//Creation of the road agents using the shapefile\t\tcreate roads from: roads_shapefile;\t\t//Creation of the building agents using the shapefile\t\tcreate buildings from: buildings_shapefile;\t\t//Creation of the people agent and place them in one of the building and chose a target in the building agents\t\tcreate people number:1000 {\t\t\tlocation &lt;- any_location_in(one_of(buildings));\t\t\ttarget &lt;- any_location_in(one_of(buildings));\t\t}\t}}//People species with agents moving and can be infectedspecies people skills:[moving]{\t\t\tfloat speed &lt;- 5.0 + rnd(5);\tbool is_infected &lt;- flip(0.01);\tpoint target;\t//Make the agent wander at each step with a certain speed.\treflex move {\t\tdo wander;\t}\t//Infect the agent if it is not already infected, and according to the infected people in a range\treflex infect when: is_infected{\t\task people at_distance 10 {\t\t\tif flip(0.01) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(5) color:is_infected ? #red : #green;\t}}species roads {\taspect geom {\t\tdraw shape color: #black;\t}}species buildings {\taspect geom {\t\tdraw shape color: #gray;\t}}experiment main_experiment type:gui{\toutput {\t\tdisplay map {\t\t\tspecies roads aspect:geom;\t\t\tspecies buildings aspect:geom;\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t}}",
        "url":"/wiki/Articles-Prima_model2.html"
      }
      ,
    
      "wiki-articles-prima-model3-html": {
        "title": "Prima 3",
        "content": "Prima 3_Author : _This model shows how to create agent and make them move randomly in the world.Some agents are infected, and others can gain the infection if they are in a certain range. The people are now placed in buildings at the initial state. Those buildings are created thanks toa shapefile. Roads are also created thanks to an other shapefile. A graph is now created fromthe road agents, and the people move from their location to a targent on the graph.Code of the model :model model3  global {\t//Shapefile for the roads\tfile roads_shapefile &lt;- file(\"../includes/road.shp\");\t//Shapefile for the buildings\tfile buildings_shapefile &lt;- file(\"../includes/building.shp\");\t//The bounds of the world are the same as the bounds of the roads shapefile\tgeometry shape &lt;- envelope(roads_shapefile);\t//We need now a graph on which people will move\tgraph road_network;\tinit {\t\t//Create the roads using the shapefiles\t\tcreate roads from: roads_shapefile;\t\t//Create the graph using the road agents as edges of the graph\t\troad_network &lt;- as_edge_graph(roads);\t\t//Create the buildings using the shapefiles\t\tcreate buildings from: buildings_shapefile;\t\t//Create the people agents and choose their location and target\t\tcreate people number:1000 {\t\t\tlocation &lt;- any_location_in(one_of(buildings));\t\t\ttarget &lt;- any_location_in(one_of(buildings));\t\t}\t}}//Species people that will move from a location to a targetspecies people skills:[moving]{\t\t\tfloat speed &lt;- 5.0 + rnd(5);\tbool is_infected &lt;- flip(0.01);\tpoint target;\t//Reflex to make the agent move to a target\treflex move {\t\tdo goto target:target on: road_network;\t\t//Each time the agent is at the target's location, chose an other target\t\tif (location = target) {\t\t\ttarget &lt;- any_location_in(one_of(buildings));\t\t}\t}\t//check if the agent is infected if it is not infected already and if there are infected people nearby\treflex infect when: is_infected{\t\task people at_distance 10 {\t\t\tif flip(0.01) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(5) color:is_infected ? #red : #green;\t}}species roads {\taspect geom {\t\tdraw shape color: #black;\t}}species buildings {\taspect geom {\t\tdraw shape color: #gray;\t}}experiment main_experiment type:gui{\toutput {\t\tdisplay map {\t\t\tspecies roads aspect:geom;\t\t\tspecies buildings aspect:geom;\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t}}",
        "url":"/wiki/Articles-Prima_model3.html"
      }
      ,
    
      "wiki-articles-prima-model4-html": {
        "title": "Prima 4",
        "content": "Prima 4_Author : _This model shows how to create agent and make them move randomly in the world.Some agents are infected, and others can gain the infection if they are in a certain range. The people are now placed in buildings at the initial state. Those buildings are created thanks toa shapefile. Roads are also created thanks to an other shapefile. A graph is now created fromthe road agents, and the people move from their location to a targent on the graph. The displayis now a 3D display.Code of the model :model model4 global {\t//Shapefile for the roads\tfile roads_shapefile &lt;- shape_file(\"../includes/road.shp\");\t//Shapefile for the buildings\tfile buildings_shapefile &lt;- file(\"../includes/building.shp\");\t//The world bounds are now the shapefile roads 's boundss\tgeometry shape &lt;- envelope(roads_shapefile);\t//The graph of roads on which people will move\tgraph road_network;\tinit {\t\t//Creation of the roads using the road shapefile\t\tcreate roads from: roads_shapefile;\t\t//Creation of the graph using roads as the edges of the graph\t\troad_network &lt;- as_edge_graph(roads);\t\t//Creation of the buildings from the building shapefile\t\tcreate buildings from: buildings_shapefile;\t\t//Creation of the people agent, located in one of the building\t\tcreate people number:1000 {\t\t\tbuildings init_place &lt;- one_of(buildings);\t\t\tlocation &lt;- any_location_in(init_place) + {0,0, init_place.height};\t\t\ttarget &lt;- any_location_in(one_of(buildings));\t\t}\t}}//Species people that will move from a location to a target and can be infectedspecies people skills:[moving]{\t\t\tfloat speed &lt;- 5.0 + rnd(5);\tbool is_infected &lt;- flip(0.01);\tpoint target;\t\t//Reflex to move to the target on the graph of roads\treflex move {\t\tdo goto target:target on: road_network;\t\t//Once the target is reached, find an other target\t\tif (location = target) {\t\t\ttarget &lt;- any_location_in(one_of(buildings));\t\t}\t}\t//Reflex to check if we are infected if we aren't already and infected people are nearby\treflex infect when: is_infected{\t\task people at_distance 10 {\t\t\tif flip(0.01) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw sphere(5) color:is_infected ? #red : #green;\t}}species roads {\taspect geom {\t\tdraw shape color: #black;\t}}species buildings {\tfloat height &lt;- 10.0+ rnd(10);\taspect geom {\t\tdraw shape color: #gray depth: height;\t}}experiment main_experiment type:gui{\toutput {\t\t//Type opengl to display in 3D\t\tdisplay map type: opengl {\t\t\tspecies roads aspect:geom;\t\t\tspecies buildings aspect:geom;\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t}}",
        "url":"/wiki/Articles-Prima_model4.html"
      }
      ,
    
      "wiki-articles-prima-model5-html": {
        "title": "Prima 5",
        "content": "Prima 5_Author : _This model shows how to create agent and make them move randomly in the world.Some agents are infected, and others can gain the infection if they are in a certain range. The people are now placed in buildings at the initial state. Those buildings are created thanks toa shapefile. Roads are also created thanks to an other shapefile. A graph is now created fromthe road agents, and the people move from their location to a targent on the graph. The displayis now a 3D display. The model adds a new level as people going inside a building will be nowa new species belonging to the building and that will be manage by the building agent concernedCode of the model :model model5 global {\t//Shapefile of the roads\tfile roads_shapefile &lt;- file(\"../includes/road.shp\");\t//Shapefile of the buildings\tfile buildings_shapefile &lt;- file(\"../includes/building.shp\");\t//The bounds of the world are the bounds of the roads shapefile\tgeometry shape &lt;- envelope(roads_shapefile);\t//The graph of road on which people agents will move\tgraph road_network;\tinit {\t\t//Creation of the roads using the road shapefile\t\tcreate roads from: roads_shapefile;\t\t//Creation of the graph using the road agents as edge\t\troad_network &lt;- as_edge_graph(roads);\t\t//Creation of the building using the building shapefile\t\tcreate buildings from: buildings_shapefile;\t\t//Creation of the people that will be placed in a building randomly chosen\t\tcreate people number:1000 {\t\t\tbuildings init_place &lt;- one_of(buildings);\t\t\tlocation &lt;- any_location_in(init_place) + {0,0, init_place.height};\t\t\ttarget &lt;- any_location_in(one_of(buildings));\t\t}\t}}//Species people that can be infected and will move from a location to a targetspecies people skills:[moving]{\t\t\tfloat speed &lt;- 5.0 + rnd(5);\tbool is_infected &lt;- flip(0.01);\tpoint target;\t//Make the agent move to its target\treflex move {\t\tdo goto target:target on: road_network;\t\t//Change the target once it has been reached\t\tif (location = target) {\t\t\ttarget &lt;- any_location_in(one_of(buildings));\t\t}\t}\t//Reflex to infect the people agent if it is not infected already and if there are infected people nearby\treflex infect when: is_infected{\t\task people at_distance 10 {\t\t\tif flip(0.01) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw sphere(5) color:is_infected ? #red : #green;\t}}species roads {\taspect geom {\t\tdraw shape color: #black;\t}}//Species buildings that will change the people agents inside it to people in building agent//Managing them once they have been captured, and releasing them once they reached a//leaving timespecies buildings {\tfloat height &lt;- 10.0+ rnd(10);\tint nb_I -&gt; {members count (people_in_building(each).is_infected)};\t\taspect geom {\t\tdraw shape color: empty(members) ? #gray : (nb_I/length(members) &gt; 0.5 ? #red : #green) depth: height;\t}\t//Species people in building that will be managed by the building agents\tspecies people_in_building parent: people schedules: [] {\t\tint leaving_time;\t\taspect circle{}\t}\t//Reflex to capture the people entering inside the building, changing them in people in building species and puting a leaving time to know when lettiing\t// them out\treflex let_people_enter {\t\tlist&lt;people&gt; entering_people &lt;- (people inside self);\t\tif !(empty (entering_people)) {\t\t\t//Change the species of the people captured from people species to people_in_building species\t\t\tcapture entering_people as: people_in_building returns: people_captured;\t\t\task people_captured {\t\t\t\tleaving_time &lt;- int(time + 50 + rnd(50));\t\t\t} \t\t}\t}\t//Reflex to let the people_in_building agents go out if there leaving time is reached, releasing them in the world as people agent\treflex let_people_leave  {\t\tlist&lt;people_in_building&gt; leaving_people &lt;- members of_species people_in_building where (time &gt;= each.leaving_time);\t\tif !(empty (leaving_people)) {\t\t\trelease leaving_people as: people in: world;\t\t}\t}}experiment main_experiment type:gui{\toutput {\t\tdisplay map type: opengl {\t\t\tspecies roads aspect:geom;\t\t\tspecies buildings aspect:geom;\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t}}",
        "url":"/wiki/Articles-Prima_model5.html"
      }
      ,
    
      "wiki-articles-prima-model6-html": {
        "title": "Prima 5",
        "content": "Prima 5_Author : _This model shows how to create agent and make them move randomly in the world.Some agents are infected, and others can gain the infection if they are in a certain range. The people are now placed in buildings at the initial state. Those buildings are created thanks toa shapefile. Roads are also created thanks to an other shapefile. A graph is now created fromthe road agents, and the people move from their location to a targent on the graph. The displayis now a 3D display. The model adds a new level as people going inside a building will be nowa new species belonging to the building and that will be manage by the building agent concernedThe people_in_building agent will be infected inside a building respecting an ordinary differentialequation system.Code of the model :model model6 global {\t//Shapefile of roads\tfile roads_shapefile &lt;- file(\"../includes/road.shp\");\t//Shapefile of buildings\tfile buildings_shapefile &lt;- file(\"../includes/building.shp\");\t//Bounds of the world will be the bounds of the shapefile of roads\tgeometry shape &lt;- envelope(roads_shapefile);\t//The graph of roads on which people agents will move\tgraph road_network;\t\t//The beta used for the ODE system\tfloat beta &lt;- 0.4;\t\tinit {\t\t//Creation of the roads using the shapefile\t\tcreate roads from: roads_shapefile;\t\t//Creation of the graph using the road agents as edge\t\troad_network &lt;- as_edge_graph(roads);\t\t//Creation of the buildings using the shapefile\t\tcreate buildings from: buildings_shapefile;\t\t//Creation of the people that will be placed in a building randomly chosen\t\tcreate people number:1000 {\t\t\tbuildings init_place &lt;- one_of(buildings);\t\t\tlocation &lt;- any_location_in(init_place) + {0,0, init_place.height};\t\t\ttarget &lt;- any_location_in(one_of(buildings));\t\t}\t}}//Species people that can be infected and will move from a location to a targetspecies people skills:[moving]{\t\t\tfloat speed &lt;- 5.0 + rnd(5);\tbool is_infected &lt;- flip(0.01);\tpoint target;\t//Reflex to make the agent move from its location to its target on the graph\treflex move {\t\tdo goto target:target on: road_network;\t\t//Change the target once it has been reached\t\tif (location = target) {\t\t\ttarget &lt;- any_location_in(one_of(buildings));\t\t}\t}\t//Reflex to know if a non-infected agent is infected by the agents nearby\treflex infect when: is_infected{\t\task people at_distance 10 {\t\t\tif flip(0.01) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw sphere(5) color:is_infected ? #red : #green;\t}}species roads {\taspect geom {\t\tdraw shape color: #black;\t}}//Species buildings that will change the people agents inside it to people in building agent//Managing them once they have been captured, and releasing them once they reached a//leaving timespecies buildings {\tfloat height &lt;- 10.0+ rnd(10);\t//Variable to know the number of people infected inside the buildings\tint nb_I -&gt; {members count (people_in_building(each).is_infected)};\t//Variable to know the number of people inside the building\tint nbInhabitants update: length(members);\t//List of all the people_in_building agents not infected\t\t\t\t\tlist&lt;people_in_building&gt; membersS update: list&lt;people_in_building&gt;(members) where (!each.is_infected);\t//List of all the people_in_building agents infected\t\t\t\t\tlist&lt;people_in_building&gt; membersI update: list&lt;people_in_building&gt;(members) where (each.is_infected);\tfloat t;\t//Float used in the ODE system representing the number of non infected agents    \tfloat S update: length(membersS) as float; \t//Float used in the ODE system representing the number of infected agents    \tfloat I update: length(membersI) as float;   \tfloat I_to_1 &lt;- 0.0;   \tfloat h&lt;-0.1;   \t\taspect geom {\t\tdraw shape color: empty(members) ? #gray : (nb_I/length(members) &gt; 0.5 ? #red : #green) depth: height;\t}\t//Species people in building that will be managed by the building agents\tspecies people_in_building parent: people schedules: [] {\t\tint leaving_time;\t\taspect circle{}\t}\t//Reflex to capture the people entering inside the building, changing them in people in building species and puting a leaving time to know when lettiing\t// them out\treflex let_people_enter {\t\tlist&lt;people&gt; entering_people &lt;- (people inside self);\t\tif !(empty (entering_people)) {\t\t\tcapture entering_people as: people_in_building returns: people_captured;\t\t\task people_captured {\t\t\t\tleaving_time &lt;- int(time + 50 + rnd(50));\t\t\t} \t\t}\t}\t//Reflex to let the people_in_building agents go out if there leaving time is reached, releasing them in the world as people agent\treflex let_people_leave  {\t\tlist&lt;people_in_building&gt; leaving_people &lt;- list&lt;people_in_building&gt;(members) where (time &gt;= each.leaving_time);\t\tif !(empty (leaving_people)) {\t\t\trelease leaving_people as: people in: world;\t\t}\t}\t//ODE system to represent the infection among the building\tequation SIR{ \t\tdiff(S,t) = (- beta * S * I / nbInhabitants) ;\t\tdiff(I,t) = (  beta * S * I / nbInhabitants) ;\t}\t//Make the computation of the ODE System only when they are people inside\treflex epidemic when:(S&gt;0 and I&gt;0){ \t\t\tfloat I0 &lt;- I;    \tsolve SIR method: \"rk4\" step: h ;    \tI_to_1 &lt;- I_to_1 + (I - I0);    \tif(I_to_1 &gt; 1) {    \t\task(membersS){    \t\t\tis_infected &lt;- true;    \t\t\tmyself.I_to_1 &lt;- myself.I_to_1 - 1;    \t\t}    \t}    }    }experiment main_experiment type:gui{\toutput {\t\tdisplay map type: opengl {\t\t\tspecies roads aspect:geom;\t\t\tspecies buildings aspect:geom;\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t}}",
        "url":"/wiki/Articles-Prima_model6.html"
      }
      ,
    
      "wiki-articles-ville-1-html": {
        "title": "Ville 1",
        "content": "Ville 1_Author : _This is a simple model showing different circle with a color according to the income of the house.Code of the model :model villeglobal {\tinit {\t\tcreate foyer number: 500;\t}}species batiment {\tstring type;\tint capacite;}species route {}species foyer {\tfloat revenu &lt;- gauss(1500, 500);\tbool est_satisfait ;\tbatiment habitation;\tbatiment lieu_travail;\t\taspect revenu {\t\tint val &lt;- int(255 * (revenu / 3000));\t\tdraw circle(5) color: rgb(255 - val, val, 0);\t}}experiment ville type: gui { \toutput {\t\tdisplay carte_principale {\t\t\tspecies foyer aspect: revenu;\t\t}\t}}",
        "url":"/wiki/Articles-ville_1.html"
      }
      ,
    
      "wiki-articles-ville-2-html": {
        "title": "Ville 2",
        "content": "Ville 2_Author : _Creation of buildings and roads thanks to a shape file. The color of the building depends on the type of the building, while the color of a house depend on its income.Code of the model :model villeglobal {\tfile shape_file_batiments &lt;- file(\"../includes/batiments.shp\");\tfile shape_file_routes &lt;- file(\"../includes/routes.shp\");\tgeometry shape &lt;- envelope(shape_file_routes);\tinit {\t\tcreate route from: shape_file_routes;\t\tcreate batiment from: shape_file_batiments with: [type:: string(read(\"NATURE\"))];\t\tcreate foyer number: 500;\t}}species batiment {\tstring type;\tint capacite &lt;- type = \"Industrial\" ? 0 : int(shape.area / 60.0);\taspect geometrie {\t\tdraw shape color: type = \"Industrial\" ? #pink : #gray;\t}}species route {\taspect geometrie {\t\tdraw shape color: #black;\t}}species foyer {\tfloat revenu &lt;- gauss(1500, 500);\tbatiment habitation;\tbatiment lieu_travail;\t\taspect revenu {\t\tint val &lt;- int(255 * (revenu / 3000));\t\tdraw circle(5) color: rgb(255 - val, val, 0);\t}}experiment ville type: gui {\toutput {\t\tdisplay carte_principale {\t\t\tspecies batiment aspect: geometrie;\t\t\tspecies route aspect: geometrie;\t\t\tspecies foyer aspect: revenu;\t\t}\t}}",
        "url":"/wiki/Articles-ville_2.html"
      }
      ,
    
      "wiki-articles-ville-3-html": {
        "title": "Ville 3",
        "content": "Ville 3_Author : _Creation of buildings and roads thanks to a shape file. The color of the building depends on the type of the building, while the color of a house depend on its income. People among the world will try to find the best building according to the mean income of their neighbors and their own income.Code of the model :model villeglobal {\tfile shape_file_batiments &lt;- file(\"../includes/batiments.shp\");\tfile shape_file_routes &lt;- file(\"../includes/routes.shp\");\tgeometry shape &lt;- envelope(shape_file_routes);\tinit \t{\t\tcreate route from: shape_file_routes;\t\tcreate batiment from: shape_file_batiments with: [type:: string(read(\"NATURE\"))];\t\tcreate foyer number: 500;\t}}species foyer {\tfloat revenu &lt;- gauss(1500, 500);\tbool est_satisfait update: calculer_satisfaction();\tbatiment habitation;\tbatiment lieu_travail;\tinit {\t\tlieu_travail &lt;- one_of(batiment where (each.type = \"Industrial\"));\t\thabitation &lt;- choisir_batiment(); \t\tdo emmenager;\t}\tbool calculer_satisfaction {\t\tlist&lt;foyer&gt; voisins &lt;- foyer at_distance 50.0;\t\tfloat revenu_moyen &lt;- mean(voisins collect (each.revenu));\t\treturn empty(voisins) or (revenu_moyen &gt; (revenu * 0.7) and revenu_moyen &lt; (revenu / 0.7));\t}\taction emmenager {\t\thabitation.capacite &lt;- habitation.capacite - 1;\t\tlocation &lt;- any_location_in(habitation.shape);\t}\taction demenager {\t\thabitation.capacite &lt;- habitation.capacite + 1;\t}\tbatiment choisir_batiment {\t\treturn one_of(batiment where (each.capacite &gt;0));\t}\treflex demenagement when: !est_satisfait {\t\tdo demenager;\t\thabitation &lt;- choisir_batiment();\t\tdo emmenager;\t}\taspect revenu {\t\tint val &lt;- int(255 * (revenu / 3000));\t\tdraw circle(5) color: rgb(255 - val, val, 0);\t}}species batiment {\tstring type;\tint capacite &lt;- type = \"Industrial\" ? 0 : int(shape.area / 70.0);\taspect geometrie {\t\tdraw shape color: type = \"Industrial\" ? #pink : #gray;\t}}species route {\taspect geometrie {\t\tdraw shape color: #black;\t}}experiment ville type: gui {\toutput {\t\tdisplay carte_principale {\t\t\tspecies batiment aspect: geometrie;\t\t\tspecies route aspect: geometrie;\t\t\tspecies foyer aspect: revenu;\t\t}\t}}",
        "url":"/wiki/Articles-ville_3.html"
      }
      ,
    
      "wiki-articles-ville-4-html": {
        "title": "Ville 4",
        "content": "Ville 4_Author : _Creation of buildings and roads thanks to a shape file. The color of the building depends on the type of the building, while the color of a house depend on its income. People among the world will try to find the best building according to the mean income of their neighbors and their own income, but also to their working place.Code of the model :model villeglobal {\tfile shape_file_batiments &lt;- file(\"../includes/batiments.shp\");\tfile shape_file_routes &lt;- file(\"../includes/routes.shp\");\tgeometry shape &lt;- envelope(shape_file_routes);\tgraph&lt;point, route&gt; reseau_route;\tinit {\t\tcreate route from: shape_file_routes;\t\treseau_route &lt;- as_edge_graph(route);\t\tcreate batiment from: shape_file_batiments with: [type:: string(read(\"NATURE\"))];\t\tcreate foyer number: 500;\t}}species foyer {\tfloat revenu &lt;- gauss(1500, 500);\tbool est_satisfait update: calculer_satisfaction();\tbatiment habitation;\tbatiment lieu_travail;\tinit {\t\tlieu_travail &lt;- one_of(batiment where (each.type = \"Industrial\"));\t\thabitation &lt;- choisir_batiment(); \t\tdo emmenager;\t}\tbool calculer_satisfaction {\t\tlist&lt;foyer&gt; voisins &lt;- foyer at_distance 50.0;\t\tfloat revenu_moyen &lt;- mean(voisins collect (each.revenu));\t\treturn empty(voisins) or (revenu_moyen &gt; (revenu * 0.7) and revenu_moyen &lt; (revenu / 0.7));\t}\taction emmenager {\t\thabitation.capacite &lt;- habitation.capacite - 1;\t\tlocation &lt;- any_location_in(habitation.shape);\t}\taction demenager {\t\thabitation.capacite &lt;- habitation.capacite + 1;\t}\tbatiment choisir_batiment {\t\treturn one_of(batiment where ((each.capacite &gt;0) and ( each.distances[lieu_travail]&lt; 1000.0)));\t}\treflex demenagement when: !est_satisfait {\t\tdo demenager;\t\thabitation &lt;- choisir_batiment();\t\tdo emmenager;\t}\taspect revenu {\t\tint val &lt;- int(255 * (revenu / 3000));\t\tdraw circle(5) color: rgb(255 - val, val, 0);\t}}species batiment {\tstring type;\tint capacite &lt;- type = \"Industrial\" ? 0 : int(shape.area / 70.0);\tmap&lt;batiment,float&gt; distances;\tinit {\t\tloop bat over: batiment where (each.type = \"Industrial\") {\t\t\tput (topology(reseau_route) distance_between [self,bat]) at: bat in: distances;\t\t}\t}\taspect geometrie {\t\tdraw shape color: type = \"Industrial\" ? #pink : #gray;\t}}species route {\taspect geometrie {\t\tdraw shape color: #black;\t}}experiment ville type: gui {\toutput {\t\tdisplay carte_principale {\t\t\tspecies batiment aspect: geometrie;\t\t\tspecies route aspect: geometrie;\t\t\tspecies foyer aspect: revenu;\t\t}\t}}",
        "url":"/wiki/Articles-ville_4.html"
      }
      ,
    
      "wiki-articles-ville-5-html": {
        "title": "Ville 5",
        "content": "Ville 5_Author : _Creation of buildings and roads thanks to a shape file. The color of the building depends on the type of the building, while the color of a house depend on its income. People among the world will try to find the best building according to the mean income of their neighbors and their own income, but also to their working place. This model add a new display showing the “color” of each building according to the mean income of its residentsCode of the model :model villeglobal {\tfile shape_file_batiments &lt;- file(\"../includes/batiments.shp\");\tfile shape_file_routes &lt;- file(\"../includes/routes.shp\");\tgeometry shape &lt;- envelope(shape_file_routes);\tgraph&lt;point, route&gt; reseau_route;\t\tinit {\t\tcreate route from: shape_file_routes;\t\treseau_route &lt;- as_edge_graph(route);\t\tcreate batiment from: shape_file_batiments with: [type:: string(read(\"NATURE\"))];\t\tcreate foyer number: 500;\t}} species foyer {\tfloat revenu &lt;- gauss(1500, 500);\tbool est_satisfait update: calculer_satisfaction();\tbatiment habitation;\tbatiment lieu_travail;\tinit {\t\tlieu_travail &lt;- one_of(batiment where (each.type = \"Industrial\"));\t\thabitation &lt;- choisir_batiment(); \t\tdo emmenager;\t}\tbool calculer_satisfaction {\t\tlist&lt;foyer&gt; voisins &lt;- foyer at_distance 50.0;\t\tfloat revenu_moyen &lt;- mean(voisins collect (each.revenu));\t\treturn empty(voisins) or (revenu_moyen &gt; (revenu * 0.7) and revenu_moyen &lt; (revenu / 0.7));\t}\taction emmenager {\t\thabitation.capacite &lt;- habitation.capacite - 1;\t\thabitation.foyers &lt;&lt; self;\t\tlocation &lt;- any_location_in(habitation.shape) + {0,0, habitation.hauteur};\t}\taction demenager {\t\thabitation.capacite &lt;- habitation.capacite + 1;\t\tremove self from: habitation.foyers;\t}\tbatiment choisir_batiment {\t\treturn one_of(batiment where ((each.capacite &gt;0) and ( each.distances[lieu_travail]&lt; 1000.0)));\t}\treflex demenagement when: !est_satisfait {\t\tdo demenager;\t\thabitation &lt;- choisir_batiment();\t\tdo emmenager;\t}\taspect revenu {\t\tint val &lt;- int(255 * (revenu / 3000));\t\tdraw sphere(5) color: rgb(255 - val, val, 0);\t}}species batiment {\tstring type;\tint capacite &lt;- type = \"Industrial\" ? 0 : int(shape.area / 70.0);\tmap&lt;batiment,float&gt; distances;\tint hauteur &lt;- 5 + rnd(10);\tlist&lt;foyer&gt; foyers ;\tfloat revenu_moyen update: empty(foyer) ? 0.0 : mean (foyers collect each.revenu);\tinit {\t\tloop bat over: batiment where (each.type = \"Industrial\") {\t\t\tput (topology(reseau_route) distance_between [self,bat]) at: bat in: distances;\t\t}\t}\taspect geometrie {\t\tdraw shape color: type = \"Industrial\" ? #pink : #gray depth: hauteur;\t}\taspect information_foyer {\t\tdraw shape color: type = \"Industrial\" ? #pink : (empty(foyers) ? #gray : rgb(int(255 * (1 - (revenu_moyen / 3000))), int(255 * (revenu_moyen / 3000)), 0)) depth: length(foyers);\t}}species route {\taspect geometrie {\t\tdraw shape color: #black;\t}}experiment ville type: gui {\toutput {\t\tdisplay carte_principale type: java2D {\t\t\tspecies batiment aspect: geometrie;\t\t\tspecies route aspect: geometrie;\t\t\tspecies foyer aspect: revenu;\t\t}\t\tdisplay carte_batiment type: opengl {\t\t\tspecies batiment aspect: information_foyer;\t\t}\t}}",
        "url":"/wiki/Articles-ville_5.html"
      }
      ,
    
      "wiki-articles-ville-6-html": {
        "title": "Ville 6",
        "content": "Ville 6_Author : _Creation of buildings and roads thanks to a shape file. The color of the building depends on the type of the building, while the color of a house depend on its income. People among the world will try to find the best building according to the mean income of their neighbors and their own income, but also to their working place. This model add a new display showing the “color” of each building according to the mean income of its residents. The buildings also have a z location given thanks to a mnt file.Code of the model :model villeglobal {\tfile shape_file_batiments &lt;- file(\"../includes/batiments.shp\");\tfile shape_file_routes &lt;- file(\"../includes/routes.shp\");\tfile mnt &lt;- file(\"../includes/mnt.asc\");\tfile texture &lt;- file('../includes/Texture.png');\tgeometry shape &lt;- envelope(mnt);\tgraph&lt;point, route&gt; reseau_route;\tlist&lt;batiment&gt; industries;\t\tinit {\t\tcreate route from: shape_file_routes;\t\treseau_route &lt;- as_edge_graph(route);\t\tcreate batiment from: shape_file_batiments with: [type:: string(read(\"NATURE\"))] {\t\t\tfloat z &lt;- (mnt_cell(location)).grid_value;   \t\t\tlocation &lt;- {location.x,location.y,z};\t\t}\t\tindustries &lt;- batiment select (each.type = \"Industrial\");\t\tcreate foyer number: 500;\t}}grid mnt_cell file: mnt;species foyer {\tfloat revenu &lt;- gauss(1500, 500);\tbool est_satisfait update: calculer_satisfaction();\tbatiment habitation;\tbatiment lieu_travail;\tinit {\t\tlieu_travail &lt;- one_of(batiment where (each.type = \"Industrial\"));\t\thabitation &lt;- choisir_batiment(); \t\tdo emmenager;\t}\tbool calculer_satisfaction {\t\tlist&lt;foyer&gt; voisins &lt;- foyer at_distance 50.0;\t\tfloat revenu_moyen &lt;- mean(voisins collect (each.revenu));\t\treturn empty(voisins) or (revenu_moyen &gt; (revenu * 0.7) and revenu_moyen &lt; (revenu / 0.7));\t}\taction emmenager {\t\thabitation.capacite &lt;- habitation.capacite - 1;\t\tlocation &lt;- any_location_in(habitation.shape) + {0,0, (habitation.hauteur + habitation.location.z)};\t\thabitation.foyers &lt;&lt; self;\t}\taction demenager {\t\thabitation.capacite &lt;- habitation.capacite + 1;\t\tremove self from: habitation.foyers;\t}\tbatiment choisir_batiment {\t\tbatiment b  &lt;- one_of(batiment where ((each.capacite &gt;0) and ( each.distances[lieu_travail]&lt; 1000.0)));\t\treturn b;\t}\treflex demenagement when: !est_satisfait {\t\tdo demenager;\t\thabitation &lt;- choisir_batiment();\t\tdo emmenager;\t}\taspect revenu {\t\tint val &lt;- int(255 * (revenu / 3000));\t\tdraw sphere(5) color: rgb(255 - val, val, 0);\t}}species batiment {\tstring type;\tint capacite &lt;- type = \"Industrial\" ? 0 : int(shape.area / 70.0);\tmap&lt;batiment,float&gt; distances;\tint hauteur &lt;- 5 + rnd(10);\tlist&lt;foyer&gt; foyers ;\tfloat revenu_moyen update: empty(foyer) ? 0.0 : mean (foyers collect each.revenu);\tinit {\t\tloop bat over: batiment where (each.type = \"Industrial\") {\t\t\tput (topology(reseau_route) distance_between [self,bat]) at: bat in: distances;\t\t}\t}\taspect geometrie {\t\tdraw shape color: type = \"Industrial\" ? #pink : #gray depth: hauteur;\t}\taspect information_foyer {\t\tdraw shape color: type = \"Industrial\" ? #pink : (empty(foyers) ? #gray : rgb(int(255 * (1 - (revenu_moyen / 3000))), int(255 * (revenu_moyen / 3000)), 0)) depth: length(foyers);\t}}species route {\taspect geometrie {\t\tdraw shape color: #black at:{location.x,location.y,(mnt_cell(location)).grid_value};\t}}experiment ville type: gui {\toutput {\t\tdisplay carte_principale type: opengl {\t\t\tgrid mnt_cell triangulation: true texture:texture elevation:true transparency: 0.3;\t\t\tspecies batiment aspect: geometrie;\t\t\tspecies route aspect: geometrie;\t\t\tspecies foyer aspect: revenu;\t\t}\t\tdisplay carte_batiment type: opengl {\t\t\tspecies batiment aspect: information_foyer;\t\t}\t}}",
        "url":"/wiki/Articles-ville_6.html"
      }
      ,
    
      "wiki-articles-html": {
        "title": "Articles",
        "content": "ArticlesThis sub-section is composed of the following models :      Ville 1        Ville 2        Ville 3        Ville 4        Ville 5        Ville 6        Prima 1        Prima 2        Prima 3        Prima 4        Prima 5        Prima 5  ",
        "url":"/wiki/Articles.html"
      }
      ,
    
      "wiki-attachingskills-html": {
        "title": "Attaching Skills",
        "content": "Attaching SkillsGAMA allows to attach skills to agents through the facet skills. Skills are built-in modules that provide a set of related built-in attributes and built-in actions (in addition to those already proposed by GAMA) to the species that declare them.Index  The moving skill  Other skills  Example of implementationSkillsA declaration of skill is done by filling the skills facet in the species definition:species my_species skills: [skill1,skill2] {}A very useful and common skill is the moving skill.species my_species skills: [moving] {}Once your species has the moving skill, it earns automatically the following attributes: speed, heading, destination and the following actions: move, goto, follow, wander and wander_3D.Attributes:  speed (float) designs the speed of the agent, in m/s.  heading (int) designs the heading of an agent in degrees, which means that is the maximum angle the agent can turn around each step.  destination (point) is the updated destination of the agent, with respect to its speed and heading. It’s a read-only attribute, you can’t change its value.Actions:followmoves the agent along a given path passed in the arguments.  returns: path  speed (float): the speed to use for this move (replaces the current value of speed)  path (path): a path to be followed.  move_weights (map): Weights used for the moving.  return_path (boolean): if true, return the path followed (by default: false)gotomoves the agent towards the target passed in the arguments.  returns: path  target (agent,point,geometry): the location or entity towards which to move.  speed (float): the speed to use for this move (replaces the current value of speed)  on (graph): graph that restrains this move  recompute_path (boolean): if false, the path is not recompute even if the graph is modified (by default: true)  return_path (boolean): if true, return the path followed (by default: false)  move_weights (map): Weights used for the moving.movemoves the agent forward, the distance being computed with respect to its speed and heading. The value of the corresponding variables are used unless arguments are passed.  returns: path  speed (float): the speed to use for this move (replaces the current value of speed)  heading (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2)  bounds (geometry,agent): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometrywanderMoves the agent towards a random location at the maximum distance (with respect to its speed). The heading of the agent is chosen randomly if no amplitude is specified. This action changes the value of heading.  returns: void  speed (float): the speed to use for this move (replaces the current value of speed)  amplitude (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2)  bounds (agent,geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometrywander_3DMoves the agent towards a random location (3D point) at the maximum distance (with respect to its speed). The heading of the agent is chosen randomly if no amplitude is specified. This action changes the value of heading.  returns: path  speed (float): the speed to use for this move (replaces the current value of speed)  amplitude (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2)  z_max (int): the maximum altitude (z) the geometry can reach  bounds (agent,geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometryOther skillsA lot of other skills are available. Some of them can be built in skills, integrated by default in GAMA, other are linked to additional plugins.This is the list of skills:Advanced_driving, communication, driving, GAMASQL, graphic, grid, MDXSKILL, moving, moving3D, physical3D, skill_road, skill_road, skill_road_node, SQLSKILLExampleWe can now build a model using the skill moving. Let’s design 2 species, one is “species_red”, the other is “species_green”. Species_green agents are moving randomly with a certain speed and a certain heading.Species_red agents wait for a species_green agent to be in a certain range of distance. Once it is the case, the agent move toward the species_green agent. A line link the red_species agent and its target.Here is an example of implementation:model green_and_red_speciesglobal{\tfloat distance_to_intercept &lt;- 10.0;\tint number_of_green_species &lt;- 50;\tint number_of_red_species &lt;- 50;\tinit {\t\tcreate speciesA number:number_of_green_species;\t\tcreate speciesB number:number_of_red_species;\t}}species speciesA skills:[moving] {\tinit {\t\tspeed &lt;- 1.0;\t}\treflex move {\t\tdo wander amplitude:90;\t}\taspect default {\t\tdraw circle(1) color:#green;\t}}species speciesB skills:[moving] {\tspeciesA target;\tinit {\t\tspeed &lt;- 0.0;\t\theading &lt;- 90;\t}\treflex search_target when:target=nil {\t\task speciesA at_distance(distance_to_intercept) {\t\t\tmyself.target &lt;- self;\t\t}\t}\treflex follow when:target!=nil {\t\tspeed &lt;- 0.8;\t\tdo goto target:target;\t}\taspect default {\t\tdraw circle(1) color:#red;\t\tif (target!=nil) {\t\t\tdraw polyline([self.location,target.location]) color:#black;\t\t}\t}}experiment my_experiment type:gui{\toutput{\t\tdisplay myDisplay {\t\t\tspecies speciesA aspect:default;\t\t\tspecies speciesB aspect:default;\t\t}\t}}",
        "url":"/wiki/AttachingSkills.html"
      }
      ,
    
      "wiki-basicprogrammingconceptsingaml-html": {
        "title": "Basic programming concepts in GAML",
        "content": "Basic programming concepts in GAMLIn this part, we will focus on the very basic structures in GAML, such as how to declare a variable, how to use loops, or how to manipulate lists. We will overfly quickly all those basic programming concepts, admitting that you already have some basics in coding.Index  Variables          Basic types      The point type      A word about dimensions        Declare variables using facet  Operators in GAMA          Logical operators      Comparison operators      Type casting operators      Other operators        Conditional structures  Loop  Manipulate containers  Random valuesVariablesVariables are declared very easily in GAML, starting with the keyword for the type, following by the name you want for your variable. NB: The declaration has to be inside the global scope, or inside the species scope.typeName myVariableName;Basic typesAll the “basic” types are present in GAML:int, float, string, bool.The operator for the affectation in GAML is &lt;- (the operator = is used to test the equality).int integerVariable &lt;- 3;float floatVariable &lt;- 2.5;string stringVariable &lt;- \"test\"; // you can also write simple ' : &lt;- 'test'bool booleanVariable &lt;- true; // or falseTo follow the behavior of variable, we can write their value in the console. Let’s go back to our basic skeleton of a model, and let’s create a reflex in the global scope (to be short, a reflex is a function that is executed in each step. We will come back to this concept later). The write function works very easily, simply writing down the keyword write and the name of the variable we want to be displayed.model firstModelglobal {\tint integerVariable &lt;- 3;\tfloat floatVariable &lt;- 2.5;\tstring stringVariable &lt;- \"test\"; // you can also write simple ' : &lt;- 'test'\tbool booleanVariable &lt;- true; // or false\treflex writeDebug {\t\twrite integerVariable;\t\twrite floatVariable;\t\twrite stringVariable;\t\twrite booleanVariable;\t}}experiment myExperiment{}The function write is overloaded for each type of variable (even for the more complex type, such as containers).Note that before being initialized, a variable has the value nil.reflex update {\tstring my_string;\twrite my_string; // this will write \"nil\".\tint my_int;\twrite my_int; // this will write \"0\", which is the default value for int.}nil is also a literal you can use to initialize your variable (you can learn more about the concept of literal in this page).reflex update {\tstring my_string &lt;- \"a string\";\tmy_string &lt;- nil;\twrite my_string; // this will write \"nil\".\tint my_int &lt;- 6;\tmy_int &lt;- nil;\twrite my_int; // this will write \"0\", which is the default value for int.}The point typeAnother variable type you should know is the point variable. This type of variable is used to describe coordinates. It is in fact a complex variable, composed of two float variables (or three if you are working in 3D). To declare it, you have to use the curly bracket {:point p &lt;- {0.2,2.4};The first field is related to the x value, and the second, to the y value. You can easily get this value as following:point p &lt;- {0.2,2.4};write p.x; // the output will be 0.2write p.y; // the output will be 2.4You can’t modify directly the value. But if you want, you can do a simple operation to get what you want:point p &lt;- {0.2,2.4};p &lt;- p + {0.0,1.0};write p.y; // the output will be 3.4A world about dimensionsWhen manipulating float values, you can specify the dimension of your value. Dimensions are preceded by # or ° (exactly the same).float a &lt;- 5°m;float b &lt;- 4#cm;float c &lt;- a + b; // c is equal to 5.0399999 (it's not equal to 5.04 because it is a float value, not as precise as int)Declare variables using facetFacets are used to describe the behavior of a variable during its declaration, by adding the keyword facet just after the variable name, followed by the value you want for the facet (or also just after the initial value).type variableName &lt;- initialValue facet1:valueForFacet1 facet2:valueForFacet2;// or:type variableName facet1:valueForFacet1 facet2:valueForFacet2;variableName &lt;- initialValue;You can use the facet update if you want to change the value of your variable. For example, to increment your integer variable each step, you can do as follow:int integerVariable &lt;- 3 min:0 max:10 update:integerVariable+1;// nb: the operator \"++\" doesn't exist in gaml.You can use the facet min and max to constraint the value in a specific range of values:int integerVariable &lt;- 3 min:0 max:10 update:integerVariable+1;// the result will be 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - 10 - 10 - ...The facet among can also be useful (that can be seen as an enum):string fruits &lt;- \"banana\" among:[\"pear\",\"apple\",\"banana\"];Operators in GAMAIn GAML language, you can use a lot of different operators. They are all listed in this page, but here are the most useful ones:-\tMathematical operatorsThe basic arithmetical operators, such as +(add), -(substract), *(multiply), /(divide), ^(power) are used this way:FirstOperand Operator SecondOperand –&gt; ex: 5 * 3; // return 15Some other operators, such as cos(cosinus), sin(sinus), tan(tangent), sqrt(square root), round(rounding) etc… are used this way:Operator(Operand) --&gt; ex: sqrt(49); // return 7Logical operatorsLogical operators such as and(and), or(inclusive or) are used the same way as basic arithmetical operators. The operator !(negation) has to be placed just before the operand. They return a boolean result.FirstOperand Operator SecondOperand --&gt; ex: true or false; // return trueNegationOperator Operand --&gt; ex: !(true or false); // return falseComparison operatorsThe comparison operators !=(different than), &lt;(smaller than), &lt;=(smaller of equal), =(equal), &gt;(bigger than), &gt;=(bigger or equal) are used the same way as basic arithmetical operators:FirstOperand Operator SecondOperand --&gt; ex: 5 &lt; 3; // return falseType casting operatorsYou can cast an operand to a special type using casting operator:Operator(Operand); --&gt; ex: int(2.1); // return 2Other operatorsA lot of other operators exist in GAML. The standard way to use those operators is as followed:Operator(FirstOperand,SecondOperand,...) --&gt; ex: rnd(1,8);Some others are used in a more intuitive way:FirstOperand Operator SecondOperand --&gt; ex: 2[6,4,5] contains(5);Conditional structuresYou can write if/else if/else in GAML:if (integerVariable&lt;0) {\twrite \"my value is negative !! The exact value is \" + integerVariable;}else if (integerVariable&gt;0) {\twrite \"my value is positive !! The exact value is \" + integerVariable;}else if (integerVariable=0) {\twrite \"my value is equal to 0 !!\";}else {\twrite \"hey... This is not possible, right ?\";}GAML also accepts ternary operator:stringVariable &lt;- (booleanVariable) ? \"booleanVariable = true\" : \"booleanVariable = false\";LoopLoops in GAML are designed by the keyword loop. As for variables, a loop have multiple facet to determine its behavior:  The facet times, to repeat a fixed number of times a set of statements:loop times: 2 {write \"helloWorld\";} // the output will be helloWorld - helloWorld  The facet while, to repeat a set of statements while a condition is true:loop while: (true) {}// infinity loop  The facet from / to, to repeat a set of statements while an index iterates over a range of values with a fixed step of 1:loop i from:0 to: 5 { // or loop name:i from:0 to:5 -&gt; the name is also a facet\twrite i;}// the output will be 0 - 1 - 2 - 3 - 4 - 5  The facet from / to combine with the facet step to choose the step:loop i from:0 to: 5 step: 2 {\twrite i;}// the output will be 0 - 2 - 4  The facet over to browse containers, as we will see in the next part.Nb: you can interrupt a loop at any time by using the break statement.Manipulate containersWe saw in the previous parts “simple” types of variable. You also have a multiple containers types, such as list, matrix, map, pair… In this section, we will only focus on the container list (you can learn the other by reading the section about datatypes).How to declare a list?To declare a list, you can either or not specify the type of the data of its elements:list&lt;int&gt; listOfInt &lt;- [5,4,9,8];list listWithoutType &lt;- [2,4.6,\"oij\",[\"hoh\",0.0]];How to know the number of elements of a list?To know the number of element of a list, you can use the operator length that returns the number of elements (note that this operator also works with strings).int numberOfElements &lt;- length([12,13]); // will return 2int numberOfElements &lt;- length([]); // will return 0int numberOfElements &lt;- length(\"stuff\"); // will return 5There is an other operator, empty, that returns you a boolean telling you if the list is empty or not.bool isEmpty &lt;- empty([12,13]); // will return falsebool isEmpty &lt;- empty([]); // will return truebool isEmpty &lt;- empty(\"stuff\"); // will return falseHow to get an element from a list?To get an element from a list by its index, you have to use the operator at (nb: it is indeed an operator, and not a facet, so no “:” after the keyword).int theFirstElementOfTheList &lt;- [5,4,9,8] at 0; // this will return 5int theThirdElementOfTheList &lt;- [5,4,9,8] at 2; // this will return 9How to know the index of an element of a list?You can know the index of the first occurrence of a value in a list using the operator index_of.You can know the index of the last occurrence of a value in a list using the operator last_index_of.int result &lt;- [4,2,3,4,5,4] last_index_of 4;  // result equals 5int result &lt;- [4,2,3,4,5,4] index_of 4;  // result equals 0How to know if an element exists in a list?You can use the operator contains (return a boolean):bool result &lt;- [{1,2}, {3,4}, {5,6}] contains {3,4};  // result equals trueHow to insert/remove an element to/from a list?For those operation, no operator are available, but you can use a statement instead. The statements add and put are used to insert/modify an element, while the statement remove is used to remove an element. Here are some example of how to use those 3 statements with the most common facets:list&lt;int&gt; list_int &lt;- [1,5,7,6,7];remove from:list_int index:1; // remove the 2nd element of the listwrite list_int; // the output is : [1,7,6,7]remove item:7 from:list_int; // remove the 1st occurrence of 7write list_int; // the output is : [1,6,7]add item:9 to: list_int at: 2; // add 9 in the 3rd positionwrite list_int; // the output is : [1,6,9,7]add 0 to: list_int; // add 0 in the last positionwrite list_int; // the output is : [1,6,9,7,0]put 3 in: list_int at: 0; // put 3 in the 1st positionwrite list_int; // the output is : [3,6,9,7,0]put 2 in: list_int key: 2; // put 2 in the 3rd positionwrite list_int; // the output is : [3,6,2,7,0]How to add 2 lists?You can add 2 lists by creating a third one and browsing the 2 first one, but you can do it much easily by using the operator + :list&lt;int&gt; list_int1 &lt;- [1,5,7,6,7];list&lt;int&gt; list_int2 &lt;- [6,9];list&lt;int&gt; list_int_result &lt;- list_int1 + list_int2;How to browse a list?You can use the facet over of a loop:list&lt;int&gt; exampleOfList &lt;- [4,2,3,4,5,4];loop i over:exampleOfList {\twrite i;}// the output will be 4 - 2 - 3 - 4 - 5 - 4How to filter a list?If you want to get all the elements of a list that fulfill a particular condition, you need the operator where. In the condition, you can design all the element of a particular list by using the pseudo variable each as followed:list&lt;int&gt; exampleOfList &lt;- [4,2,3,4,5,4] where (each &lt;= 3); // the list is now [2,3]Other useful operators for the manipulation of lists:Here are some other operators which can be useful to manipulate lists: sort, sort_by, shuffle, reverse, collect, accumulate, among. Please read the GAML Reference if you want to know more about those operators.Random valuesWhen you will implement your model, you will have to manipulate some random values quite often.To get a random value in a range of value, use the operator rnd. You can use this operator in many ways:int var0 &lt;- rnd (2);    // var0 equals 0, 1 or 2float var1 &lt;- rnd (1000) / 1000;    // var1 equals a float between 0 and 1 with a precision of 0.001point var2 &lt;- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}, 1);    // var2 equals a point with x = 2.0, y equal to 2.0, 3.0 or 4.0 and z between 0.0 and 10.0 every 1.0float var3 &lt;- rnd (2.0, 4.0, 0.5);  // var3 equals a float number between 2.0 and 4.0 every 0.5float var4 &lt;- rnd(3.4);     // var4 equals a random float between 0.0 and 3.4int var5 &lt;- rnd (2, 12, 4);     // var5 equals 2, 6 or 10point var6 &lt;- rnd ({2.5,3, 0.0});   // var6 equals {x,y} with x in [0.0,2.0], y in [0.0,3.0], z = 0.0int var7 &lt;- rnd (2, 4);     // var7 equals 2, 3 or 4point var8 &lt;- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0});   // var8 equals a point with x = 2.0, y between 2.0 and 4.0 and z between 0.0 and 10.0float var9 &lt;- rnd (2.0, 4.0);   // var9 equals a float number between 2.0 and 4.0Use the operator flip if you want to pick a boolean value with a certain probability:bool result &lt;- flip(0.2); // result will have 20% of chance to be trueYou can use randomness in list, by using the operator shuffle, or also by using the operator among to pick randomly one (or several) element of your list:list TwoRandomValuesFromTheList &lt;- 2 among [5,4,9,8];// the list will be for example [5,9].You can use probabilistic laws, using operators such as gauss, poisson, binomial, or truncated_gauss (we invite you to read the documentation for those operators).            //: # (endConcept      programming_basis)      ",
        "url":"/wiki/BasicProgrammingConceptsInGAML.html"
      }
      ,
    
      "wiki-batch-batch-html": {
        "title": "Model using Batch mode",
        "content": "Model using Batch modeAuthor :  Patrick TaillandierA model showing how to use batch experiments to find the best combination of parameters to minimize the numbers of infected people in a SIR infection model where agents infect others and become immune for a certain time. The batch mode uses three different methods : Exhaustive, GA and Tabu Search. The model proposes five experiments : one simple with a User Interface, one running 5 experiments and saving the data, and one for each strategy.Code of the model :model batch_exampleglobal {    int number_people &lt;- 300;  // The init number of people    int number_I &lt;- 1 ;\t// The init number of infected    float infection_rate &lt;- 0.1 ; // The infection rate\tfloat infection_distance &lt;- 5.0 ; // infection distance (in meters)\tint immune_step &lt;- 30 ; // number of steps before becoming immune after infection\tint end_immunity_step &lt;-50; // number of steps before not being immune anymore\tfloat speed_people &lt;- 5.0 ; // speed of the Host\tint nb_infected &lt;- 0;\tinit {\t\tcreate people number: number_people ;        ask (number_I among people) {        \tis_infected &lt;- true;        \tcolor &lt;- #red;        }\t}}species people skills:[moving] {\tbool is_infected &lt;- false;\tbool is_immune &lt;- false;\trgb color &lt;- #green;\tint cpt &lt;- 0;\treflex basic_move {\t\tdo wander speed: speed_people;\t}\treflex end_of_immunity when: is_immune {\t\tif (cpt &gt; end_immunity_step) {\t\t\tcpt &lt;- 0;\t\t\tis_immune &lt;- false;\t\t\tcolor &lt;-  #green;\t\t} else {\t\t\tcpt &lt;- cpt + 1;\t\t}\t}\treflex become_immune when: is_infected {\t\tif (cpt &gt; immune_step) {\t\t\tcpt &lt;- 0;\t\t\tis_immune &lt;- true;\t\t\tis_infected &lt;- false;\t\t\tcolor &lt;-  #blue;\t\t} else {\t\t\tcpt &lt;- cpt + 1;\t\t}\t}\treflex become_infected when: not is_infected and not is_immune{\t\tif (flip(infection_rate) and not empty(people at_distance infection_distance where each.is_infected)) {\t\t\tis_infected &lt;- true;\t\t\tcolor &lt;-  #red;\t\t\tnb_infected &lt;- nb_infected + 1;\t\t}\t}\taspect default { \t\tdraw circle(1) color: color;    }}experiment Simple type:gui {\tparameter 'Infection Rate:' var: infection_rate;\tparameter 'Infection Distance:' var: infection_distance;\toutput {\t\tmonitor \"nb of infected people\" value: nb_infected;\t\tdisplay map {\t\t\tspecies people aspect: default;\t\t}\t}}// This experiment runs the simulation 5 times.// At the end of each simulation, the people agents are saved in a shapefileexperiment 'Run 5 simulations' type: batch repeat: 5 keep_seed: true until: ( time &gt; 1000 ) {\t\t// the reflex will be activated at the end of each run; in this experiment a run consists of the execution of 5 simulations (repeat: 5)\treflex end_of_runs\t{\t\tint cpt &lt;- 0;\t\t// each simulation of the run is an agent; it is possible to access to the list of these agents by using the variable \"simulations\" of the experiment. \t\t// Another way of accessing to the simulations consists in using the name of model + _model: here \"batch_example_model\"\t\t//in this example, we ask all the simulation agents of the run to save (at the end of the simulation) the people population in a shapefile with their is_infected and is_immune attributes \t\task simulations\t\t{\t\t\tsave people type: \"shp\" to: \"people_shape\" + cpt + \".shp\" with: [is_infected::\"INFECTED\", is_immune::\"IMMUNE\"];\t\t\tcpt &lt;- cpt + 1;\t\t}\t}}// This experiment explores two parameters with an exhaustive strategy,// repeating each simulation three times (the aggregated fitness correspond to the mean fitness), // in order to find the best combination of parameters to minimize the number of infected peopleexperiment 'Exhaustive optimization' type: batch repeat: 5 keep_seed: true until: ( time &gt; 1000 ) {\tparameter 'Infection rate' var: infection_rate among: [ 0.1 , 0.5 , 1.0 ];\tparameter 'Speed of people:' var: speed_people min: 1.0 max: 3.0 step:1.0;\tmethod exhaustive minimize: nb_infected;\t\t//the permanent section allows to define a output section that will be kept during all the batch experiment\tpermanent {\t\tdisplay Comparison {\t\t\tchart \"Number of people infected\" type: series {\t\t\t\t//we can access to all the simulations of a run (here composed of 5 simulation -&gt; repeat: 5) by the variable \"simulations\" of the experiment.\t\t\t\t//here we display for the 5 simulations, the mean, min and max values of the nb_infected variable.\t\t\t\tdata \"Mean\" value: mean(simulations collect each.nb_infected ) style: spline color: #blue ;\t\t\t\tdata \"Min\" value:  min(simulations collect each.nb_infected ) style: spline color: #darkgreen ;\t\t\t\tdata \"Max\" value:  max(simulations collect each.nb_infected ) style: spline color: #red ;\t\t\t}\t\t}\t\t}}// This experiment explores two parameters with a GA strategy,// repeating each simulation three times (the aggregated fitness correspond to the min fitness), // in order to find the best combination of parameters to minimize the number of infected peopleexperiment Genetic type: batch keep_seed: true repeat: 3 until: ( time &gt; 1000 ) {\tparameter 'Infection rate' var: infection_rate among: [ 0.1 ,0.2, 0.5 , 0.6,0.8, 1.0 ];\tparameter 'Speed of people:' var: speed_people min: 1.0 max: 10.0 step:1.0;\tmethod genetic pop_dim: 3 crossover_prob: 0.7 mutation_prob: 0.1\tnb_prelim_gen: 1 max_gen: 5  minimize: nb_infected  aggregation: \"min\";}// This experiment explores two parameters with a Tabu Search strategy,// repeating each simulation three times (the aggregated fitness correspond to the max fitness), // in order to find the best combination of parameters to minimize the number of infected peopleexperiment Tabu_Search type: batch keep_seed: true repeat: 3 until: ( time &gt; 1000 ) {\tparameter 'Infection rate' var: infection_rate among: [ 0.1 ,0.2, 0.5 , 0.6,0.8, 1.0 ];\tparameter 'Speed of people:' var: speed_people min: 1.0 max: 10.0 step:1.0;\tmethod tabu iter_max: 10 tabu_list_size: 5 minimize: nb_infected aggregation: \"max\";}",
        "url":"/wiki/Batch-Batch.html"
      }
      ,
    
      "wiki-batch-html": {
        "title": "Batch",
        "content": "BatchThis sub-section is composed of the following models :   Model using Batch mode",
        "url":"/wiki/Batch.html"
      }
      ,
    
      "wiki-batchexperiments-html": {
        "title": "Defining Batch Experiments",
        "content": "Defining Batch ExperimentsBatch experiments allows to execute numerous successive simulation runs.They are used to explore the parameter space of a model or to optimize a set of model parameters.A Batch experiment is defined by:experiment exp_title type: batch {   [parameter to explore]   [exploration method]   [reflex]   [permanent]}Table of contents  The batch experiment facets  Action _step  Reflexes  PermanentThe batch experiment facetsBatch experiment have the following three facets:  until: (expression) Specifies when to stop each simulations. Its value is a condition on variables defined in the model. The run will stop when the condition is evaluated to true. If omitted, the first simulation run will go forever, preventing any subsequent run to take place (unless a halt command is used in the model itself).  repeat: (integer) A parameter configuration corresponds to a set of values assigned to each parameter. The attribute repeat specifies the number of times each configuration will be repeated, meaning that as many simulations will be run with the same parameter values. Different random seeds are given to the pseudo-random number generator. This allows to get some statistical power from the experiments conducted. Default value is 1.  keep_seed: (boolean) If true, the same series of random seeds will be used from one parameter configuration to another. Default value is false.experiment my_batch_experiment type: batch repeat: 5 keep_seed: true until: time = 300 {   [parameter to explore]   [exploration method]}Action _stepThe_step_action of an experiment is called at the end of a simulation. It is possible to override this action to apply a specific action at the end of each simulation. Note that at the experiment level, you have access to all the species and all the global variables._For instance, the following experiment runs the simulation 5 times, and, at the end of each simulation, saves the people agents in a shapefile.experiment 'Run 5 simulations' type: batch repeat: 5 keep_seed: true until: ( time &gt; 1000 ) {\tint cpt &lt;- 0;\taction _step_ {\t\tsave people type:\"shp\" to:\"people_shape\" + cpt + \".shp\" with: [is_infected::\"INFECTED\",is_immune::\"IMMUNE\"];\t\tcpt &lt;- cpt + 1;\t}}A second solution to achieve the same result is to use reflexes (see below).ReflexesIt is possible to write reflexes inside a batch experiment. This reflex will be executed at the end of each simulation. For instance, the following reflex writes at the end of each simulation the value of the variable food_gathered:reflex info_sim {\twrite \"Running a new simulation \" + simulation + \" -&gt; \" + food_gathered;}PermanentThe permanent section allows to define a output block that will not be re-initialized at the beginning of each simulation but will be filled at the end of each simulation.For instance, this permanent section will allows to display for each simulation the end value of the food_gathered variable.permanent {\tdisplay Ants background: rgb('white') refresh:every(1) {\t\tchart \"Food Gathered\" type: series {\t\t\tdata \"Food\" value: food_gathered;\t\t}\t}}",
        "url":"/wiki/BatchExperiments.html"
      }
      ,
    
      "wiki-batchspecific-html": {
        "title": "Batch Specific UI",
        "content": "Batch Specific UIWhen an experiment of type Batch is run, a dedicated UI is displayed, depending on the parameters to explore and of the exploration methods.Table of contents  Batch Specific UI          Information bar      Batch UI      Information barIn batch mode, the top information bar displays 3 distinct information (instead of only the cycle number in the GUI experiment):  The run number: One run corresponds to X executions of simulation with one given parameters values (X is an integer given by the facet repeat in the definition of the exploration method);  The simulation number: the number of replications done (and the number of replications specified with the repeat facet);  The number of thread: the number of threads used for the simulation.Batch UIThe parameters view is also a bit different in the case of a Batch UI. The following interface is generated given the following model part:experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed) or (time &gt; 400) {   parameter 'Size of the grid:' var: gridsize init: 75 unit: 'width and height';   parameter 'Number:' var: ants_number init: 200 unit: 'ants';   parameter 'Evaporation:' var: evaporation_rate among: [0.1, 0.2, 0.5, 0.8, 1.0] unit: 'rate every cycle (1.0 means 100%)';   parameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;   method exhaustive maximize: food_gathered;The interface summarizes all model parameters and the parameters given to the exploration method:  Environment and Population: displays all the model parameters that should not be explored;  Parameters to explore: the parameters to explore are the parameters defined in the experiment with a range of values (with among facet or min, max and step facets);  Exploration method: it summarizes the Exploration method and the stop condition. For exhaustive method it also evaluates the parameter space. For other methods, it also displays the method parameters (e.g. mutation or crossover probability…). Finally the best fitness found and the last fitness found are displayed (with the associated parameter set).",
        "url":"/wiki/BatchSpecific.html"
      }
      ,
    
      "wiki-boids-boids-3d-analysis-html": {
        "title": "Boids 3D Analysis",
        "content": "Boids 3D Analysis_Author : _This model shows the movement of boids following a goal, and creating without their own volonty, a flock . Four experiments are proposed : start is the 3D display of the boids like a real world, trajectory_analysis like the name means is about the analysis of the trajectory of the boids, Space Time Cube adds two display to see the movement of the boids using the time as the z-axis, and the last one represents the differents camera available in GAMA.Code of the model :model boids global torus: torus_environment{ \t//Number of boids to represent\tint number_of_agents parameter: 'Number of agents' &lt;- 10 min: 1 max: 1000000;\t//Number of obstacles to represent\tint number_of_obstacles parameter: 'Number of obstacles' &lt;- 4 min: 0;\t//Size of the boids\tint boids_size parameter: 'Boids size' &lt;- 20 min: 1;\t//Maximal speed allowed for the boids\tfloat maximal_speed parameter: 'Maximal speed' &lt;- 15.0 min: 0.1 max: 15.0;\t//Speed radius\tfloat  radius_speed parameter: 'radius speed' &lt;- 0.5 min: 0.1;\t//Cohesion factor of the boid group  in the range of a boid agent\tint cohesion_factor parameter: 'Cohesion Factor' &lt;- 200;\t//Alignment factor used for the boid group in the range of a boid agent\tint alignment_factor parameter: 'Alignment Factor' &lt;- 100; \t//Minimal distance to move\tfloat minimal_distance parameter: 'Minimal Distance' &lt;- 10.0; \t//Maximal turn done by the boids\tint maximal_turn parameter: 'Maximal Turn' &lt;- 90 min: 0 max: 359; \t\t//Parameters of the environment and the simulations\tint width_and_height_of_environment parameter: 'Width/Height of the Environment' &lt;- 800;  \tbool torus_environment parameter: 'Toroidal Environment ?' &lt;- false; \tbool apply_cohesion &lt;- true parameter: 'Apply Cohesion ?';\tbool apply_alignment &lt;- true parameter: 'Apply Alignment ?';   \tbool apply_separation &lt;- true parameter: 'Apply Separation ?';   \tbool apply_goal &lt;- true parameter: 'Follow Goal ?'; \tbool apply_avoid &lt;- true parameter: 'Apply Avoidance ?';   \tbool apply_wind &lt;- true parameter: 'Apply Wind ?';     \tbool moving_obstacles &lt;- false parameter: 'Moving Obstacles ?';    \tint bounds &lt;- int(width_and_height_of_environment / 20); \t//Wind vector \tpoint wind_vector &lt;- {0,0} parameter: 'Direction of the wind';  \tint goal_duration &lt;- 30 update: (goal_duration - 1); \t//Goal location\tpoint goal &lt;- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 }; \tlist images of: image_file &lt;- [file('../images/bird1.png'),file('../images/bird2.png'),file('../images/bird3.png')]; \tstring file_path_to_ocean &lt;- '../images/ocean.jpg';\tint xmin &lt;- bounds;    \tint ymin &lt;- bounds;  \tint xmax &lt;- (width_and_height_of_environment - bounds);    \tint ymax &lt;- (width_and_height_of_environment - bounds);   \tgeometry shape &lt;- square(width_and_height_of_environment);\t// flock's parameter \tfloat two_boids_distance const: true init: 30.0;  \tint merging_distance const: true init: 30;\tbool create_flock  init: false;  \t\tinit {\t\t//Create the boids and place them randomlly\t\tcreate boids number: number_of_agents { \t\t\tlocation &lt;- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };\t\t} \t\t \t\t //Create an obstacle and place it randomly\t\tcreate obstacle number: number_of_obstacles {\t\t\tlocation &lt;- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 }; \t\t}\t\t//Create a goal and place it at the goal location\t\tcreate  boids_goal number: 1 {\t\t\tlocation &lt;- goal;\t\t}\t\t\t\tcreate aggregatedboids;\t}\t\t//Reflex to create flock of boids considering the neighbours of each boids \t reflex create_flocks {\t \tif create_flock {\t \t\t//Create a map using a boid agent as a key and the list of all its neighbours as the value for the key\t \t\tmap&lt;boids, list&lt;boids&gt;&gt; potentialBoidsNeighboursMap;\t \t\t\t \t\t//Search all the boids within the two boids distance from a boid agent and put them in the map\t \t\tloop one_boids over: boids {\t \t\t\tlist&lt;boids&gt; free_neighbours &lt;- boids overlapping (one_boids.shape + (two_boids_distance));\t \t\t\tremove one_boids from: free_neighbours;  \t \t\t\tif !(empty (free_neighbours)) {\t \t\t\t\tadd (one_boids::free_neighbours) to: potentialBoidsNeighboursMap;\t \t\t\t} \t \t\t}\t \t\t\t \t\t//Sorting of all the boids considered as key in the map by the length of their neighbours\t \t\tlist&lt;boids&gt; sorted_free_boids &lt;- (potentialBoidsNeighboursMap.keys) sort_by (length (potentialBoidsNeighboursMap at each));\t \t\t//Removing of all the boids which has been considered as a key of the map, but  which are already included in a bigger list of neighbours by one of them neighbours\t \t\tloop one_boids over: sorted_free_boids {\t \t\t\tlist&lt;boids&gt; one_boids_neighbours &lt;- potentialBoidsNeighboursMap at one_boids;\t \t\t\t\t \t\t\tif  (one_boids_neighbours != nil) {\t \t\t\t\tloop one_neighbour over: one_boids_neighbours {\t \t\t\t\t\tremove one_neighbour from: potentialBoidsNeighboursMap; \t \t\t\t\t}\t \t\t\t}\t \t\t}\t \t\t//Remove all the duplicates key of potentialBoidsNeighboursMap\t\t \tlist&lt;boids&gt; boids_neighbours &lt;- (potentialBoidsNeighboursMap.keys);\t\t \tloop one_key over: boids_neighbours {\t\t \t\tput (remove_duplicates (( potentialBoidsNeighboursMap at (one_key)) + one_key)) at: one_key in: potentialBoidsNeighboursMap;\t\t \t}\t\t \t\t\t \t//Create a flock of boids considering the key of potentialBoidsNeighboursMap\t\t \tloop one_key over: (potentialBoidsNeighboursMap.keys) {\t\t \t\tlist&lt;boids&gt; micro_agents &lt;- potentialBoidsNeighboursMap at one_key;\t\t \t\t\t\t\t \t\tif ( (length (micro_agents)) &gt; 1 ) {\t\t \t\t\tcreate flock number: 1 with: [ color::rgb([rnd (255), rnd (255), rnd (255)]) ] { \t\t \t\t\t\tcapture micro_agents as: boids_delegation;\t\t \t\t\t}\t\t \t\t}\t\t \t} \t\t}\t}  }//Species boids_goal which represents the goal followed by the boids agent, using the skill movingspecies boids_goal skills: [moving] {\tfloat range const: true init: 20.0;\tint radius &lt;-3;\t\t//Reflex to make the goal move in circle\treflex wander_in_circle{\t\t\t\tlocation &lt;- {world.shape.width/2 + world.shape.width/2 * cos (time*radius_speed), world.shape.width/2 + world.shape.width/2 * sin (time*radius_speed)};\t\tgoal &lt;- location;\t}\t\taspect default {\t\tdraw circle(10) color: rgb ('red');\t\tdraw circle(40) color: rgb ('orange') size: 40 empty: true;\t}\t\taspect sphere{\t\tdraw sphere(10) color: rgb('white');\t}} //Species flock which represents the flock of boids agents, managing the boids agents capturedspecies flock  {\t//Represent the cohesion index of the flock\tfloat cohesionIndex &lt;- two_boids_distance update: (two_boids_distance + (length (members)));\trgb color &lt;- rgb ([64, 64, 64]); \tgeometry shape update: !(empty (members)) ? ( (polygon (members collect (boids_delegation (each)).location )) + 2.0 ) : ( polygon ([ {rnd (width_and_height_of_environment), rnd (width_and_height_of_environment)} ]) );\t \t//Species that will represent the boids agents captured or inside a flock\tspecies boids_delegation parent: boids topology: topology(world.shape)  \t{\t\tlist&lt;boids&gt; others -&gt; {( (boids_delegation overlapping (shape + range))) - self};  \t\t//Action to compute the mass center of the flock\t\taction compute_mass_center type: point \t\t{\t\t\tloop o over: others \t\t\t{\t\t\t\tif  dead(o) \t\t\t\t{\t\t\t\t\tdo write message: 'in ' + name + ' agent with others contains death agents'; \t\t\t\t} \t\t\t}\t\t \t\t\treturn (length(others) &gt; 0) ? (mean (others collect (each.location)) ) : location;\t\t}\t\treflex separation when: apply_separation {\t\t}\t\t\t\treflex alignment when: apply_alignment {\t\t}\t\t//Reflex to apply the cohesion on the boids agents\t\treflex cohesion when: apply_cohesion {\t\t\tpoint acc &lt;- (self compute_mass_center []) - location;\t\t\tacc &lt;- acc / cohesion_factor;\t\t\tvelocity &lt;- velocity + acc;\t\t}\t\t\t\treflex avoid when: apply_avoid {\t\t}\t\t\t}\t//Reflex to capture boids agents and release captured boids agents\treflex capture_release_boids {\t\t list&lt;boids_delegation&gt; removed_components &lt;- boids_delegation where ((each distance_to location) &gt; cohesionIndex );\t\t if !(empty (removed_components)) {\t\t \trelease removed_components;\t\t }\t\t \t\t list&lt;boids&gt; added_components &lt;- boids where ((each distance_to location) &lt; cohesionIndex );\t\t if !(empty (added_components)) {\t\t \tcapture added_components as: boids_delegation;\t\t }\t}\t//Reflexe to kill the flock if the boids agents contained is lower than 2\treflex dispose when: ((length (members)) &lt; 2) {\t\t release members;\t\t do die;\t}\t//Reflex to merge the flocks too close from each other\treflex merge_nearby_flocks {\t\tlist&lt;flock&gt; nearby_flocks&lt;- (flock overlapping (shape +  merging_distance));\t\tif !(empty (nearby_flocks)) {\t\t \tnearby_flocks &lt;- nearby_flocks sort_by (length (each.members));\t\t \tflock largest_flock &lt;- nearby_flocks at ((length (nearby_flocks)) - 1);\t\t \t \t\t \tremove largest_flock from: nearby_flocks;\t\t \t \t\t \tlist&lt;boids&gt; added_components ;\t\t \tloop one_flock over: nearby_flocks {\t\t \t\trelease one_flock.members returns: released_boids; \t\t \t\t\t\t \t\tloop rb over: released_boids {\t\t \t\t\tadd boids(rb) to: added_components;\t\t \t\t}\t\t \t}\t\t \t\t\t \tif !(empty (added_components)) { \t\t \t\task largest_flock {\t\t \t\t\tcapture added_components as: boids_delegation;\t\t \t\t}\t\t \t} \t\t }\t}\t\taspect default {\t\tdraw shape color: color;\t}}\t//Species to represent the boids aggregatedspecies aggregatedboids{\treflex updateLocation{\t  location &lt;- mean (boids collect (each.location));\t\t}\taspect base{   \t\t\t\tdraw sphere(10) color: rgb('red');\t}}//Species to represent the boids agent using the skill movingspecies boids skills: [moving] {\t//Speed of the agent\tfloat speed max: maximal_speed &lt;- maximal_speed;\t//Range of movement for the neighbours\tfloat range &lt;- minimal_distance * 2;\t//Velocity of the agent\tpoint velocity &lt;- {0,0};\tfloat hue &lt;- rnd(360) / 360;\t\t//List of the neighbours boids\tlist&lt;boids&gt; others update: ((boids overlapping (circle (range)))  - self);\t\t//Point of the mass center of the \"flock\" considered as the neighbours agents\tpoint mass_center update:  (length(others) &gt; 0) ? (mean (others collect (each.location)) )  : location;\t\t//Reflex to do the separation of the agents with the other boids in the minimal distance\treflex separation when: apply_separation {\t\tpoint acc &lt;- {0,0}; \t\tloop boid over: (boids overlapping (circle(minimal_distance)))  {\t\t\tacc &lt;- acc - ((location of boid) - location);\t\t}  \t\tvelocity &lt;- velocity + acc;\t}\t\t//Reflex to do the alignement of the boids\treflex alignment when: apply_alignment {\t\tpoint acc &lt;- mean (others collect (each.velocity)) - velocity;\t\tvelocity &lt;- velocity + (acc / alignment_factor);\t}\t \t//Reflex to apply the cohesion using the mass center of the \"flock\"\treflex cohesion when: apply_cohesion {\t\tpoint acc &lt;- mass_center - location;\t\tacc &lt;- acc / cohesion_factor;\t\tvelocity &lt;- velocity + acc; \t}\t//Reflex to avoid the obstacles\treflex avoid when: apply_avoid {\t\tpoint acc &lt;- {0,0};\t\tlist&lt;obstacle&gt; nearby_obstacles &lt;- (obstacle overlapping (circle (range)) );\t\tloop obs over: nearby_obstacles {\t\t\tacc &lt;- acc - ((location of obs) - my (location));\t\t}\t\tvelocity &lt;- velocity + acc; \t}\t//action to represent the bounding of the movement of the boids\taction bounding {\t\tif  !(torus_environment) {\t\t\tif  (location.x) &lt; xmin {\t\t\t\tvelocity &lt;- velocity + {bounds,0};\t\t\t} else if (location.x) &gt; xmax {\t\t\t\tvelocity &lt;- velocity - {bounds,0};\t\t\t}\t\t\t\t\t\tif (location.y) &lt; ymin {\t\t\t\tvelocity &lt;- velocity + {0,bounds};\t\t\t} else if (location.y) &gt; ymax {\t\t\t\tvelocity &lt;- velocity - {0,bounds};\t\t\t}\t\t\t\t\t}\t}\t//Reflex to follow the goal \treflex follow_goal when: apply_goal {\t\tvelocity &lt;- velocity + ((goal - location) / cohesion_factor);\t}\t//Reflex to apply the wind vector\treflex wind when: apply_wind {\t\tvelocity &lt;- velocity + wind_vector;\t}\t//action to move  \taction do_move {  \t\tif (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) {\t\t\tvelocity &lt;- {(rnd(4)) -2, (rnd(4)) - 2}; \t\t}\t\tpoint old_location &lt;- location; \t\tdo goto target: location + velocity;\t\tvelocity &lt;- location - old_location; \t}\t\t//Reflex to do the movement, calling both bounding and do_move actions\treflex movement {\t\tdo bounding;\t\tdo do_move;\t}\t\taspect basic{\t\tdraw triangle(boids_size) color:rgb('black');\t}\taspect image {\t\tdraw (images at (rnd(2))) size: boids_size rotate: heading color: rgb('black') ;\t\t\t    \t}\t\t\t\taspect dynamicColor{\t\trgb cc &lt;- hsb (float(heading)/360.0,1.0,1.0);\t\tdraw triangle(20) size: 15 rotate: 90 + heading color: cc border:cc depth:5;\t\tdraw name;\t}} //Species which represents the obstacles using the skill movingspecies obstacle skills: [moving] {\tfloat speed &lt;- 0.1;\t \taspect default {\t\tdraw triangle(20) color: rgb('yellow') depth:5;\t}}experiment start type: gui {\toutput {\t\tdisplay RealBoids  type:opengl z_fighting:false {\t\t\timage 'background' file:file_path_to_ocean;\t\t\tspecies boids aspect: dynamicColor  position:{0,0,0.1} trace: 30;\t\t\tspecies boids_goal transparency:0.2 position:{0,0,0.1};\t\t\tspecies obstacle position:{0,0,0.1}; \t\t\t\t}\t}}experiment trajectory_analysis type: gui {\toutput {\t\t\t\tdisplay RealBoids  type:opengl {\t\t\timage 'background' file:file_path_to_ocean;\t\t\tspecies boids aspect: dynamicColor transparency:0.5 position:{0,0,0.1};\t\t\tspecies boids aspect: image transparency:0.5 position:{0,0,0.11};\t\t\tspecies boids_goal transparency:0.2 position:{0,0,0.1};\t\t\tspecies obstacle position:{0,0,0.1}; \t\t\t\t}\t\t\t\t\t\tdisplay AggregatedBoidsTrajectory  type:opengl  {\t\t\timage 'background' file:file_path_to_ocean;\t\t\tspecies aggregatedboids  aspect: base trace:100 fading: true ;\t\t\tspecies boids_goal aspect:sphere;\t\t\t\t}\t} }experiment SpaceTimeCube type: gui {\toutput {\t\tdisplay RealBoids  type:opengl {\t\t\timage 'background' file:file_path_to_ocean;\t\t\tspecies boids aspect: dynamicColor transparency:0.5 position:{0,0,0.1};\t\t\tspecies boids aspect: image transparency:0.5 position:{0,0,0.11};\t\t\tspecies boids_goal transparency:0.2 position:{0,0,0.1};\t\t\tspecies obstacle position:{0,0,0.1}; \t\t\t\t}\t\t\t\tdisplay SpaceTimeCubeAll  type:opengl {\t\t\timage 'background' file:file_path_to_ocean;\t\t\tspecies boids trace:true{\t\t\t    draw triangle(20) size: 15 rotate: 90 + heading color: hsb (float(heading)/360.0,1.0,1.0) border:hsb (float(heading)/360.0,1.0,1.0) depth:5 at: {location.x ,location.y,location.z+time};\t\t\t\t}\t\t\tspecies boids_goal trace:true{\t\t\t\tdraw sphere(10) color: rgb('yellow') at: {location.x ,location.y,location.z+time};\t\t\t}\t\t\t}\t\t\t\t\t\tdisplay SpaceTimeCubeAggregated  type:opengl {\t\t\timage 'background' file:file_path_to_ocean;\t\t\tspecies aggregatedboids trace:true{\t\t\t    draw sphere(10) color: rgb('red') at: {location.x ,location.y,location.z+time};\t\t\t\t}\t\t\tspecies boids_goal trace:true{\t\t\t\tdraw sphere(10) color: rgb('yellow') at: {location.x ,location.y,location.z+time};\t\t\t}\t\t\t}\t}}experiment MultipleView type: gui {\toutput {\t\tdisplay RealBoids   type:opengl {\t\t\timage 'background' file:file_path_to_ocean;\t\t\tspecies boids aspect: image  transparency:0.5 position:{0,0,0.25};\t\t\tspecies boids_goal transparency:0.2 position:{0,0,0.25};\t\t\tspecies obstacle ;\t\t\tspecies boids  aspect: dynamicColor transparency:0.2 position:{0,0,0.24};\t\t\t\t}\t\t\t\tdisplay ThirdPersonn  type:opengl camera_interaction:false camera_pos:{int(first(boids).location.x),int(first(boids).location.y),250} \t\tcamera_look_pos:{int(first(boids).location.x),first(boids).location.y,0} \t\tcamera_up_vector:{0.0,-1.0,0.0} {\t\t\t\t\timage 'background' file:file_path_to_ocean;\t\t\tspecies obstacle;\t\t\tspecies boids  aspect: dynamicColor transparency:0.2 ;\t\t\tspecies boids_goal  transparency:0.2; \t\t\t\t}\t\t\t\t\t\t\tdisplay FirstPerson  type:opengl camera_interaction:false camera_pos:{int(first(boids).location.x),int(first(boids).location.y),10} \t\t\tcamera_look_pos:{cos(first(boids).heading)*first(boids).speed+int(first(boids).location.x),\t\t\tsin(first(boids).heading)*first(boids).speed+int(first(boids).location.y),10} \t\t\tcamera_up_vector:{0.0,0.0,1.0} {\t\t\t\timage 'background' file:file_path_to_ocean;\t\t\tspecies obstacle ;\t\t\tspecies boids  aspect: dynamicColor transparency:0.2 ;\t\t\tspecies boids_goal  transparency:0.2; \t\t\t\t}\t}}",
        "url":"/wiki/Boids-Boids-3D-Analysis.html"
      }
      ,
    
      "wiki-boids-boids-3d-motion-html": {
        "title": "Boids 3D Motion",
        "content": "Boids 3D Motion_Author : _This model shows the movement of boids following a goal, and creating without their own volonty, a flock .  The goal agent and the boids will move within the 3D space.Code of the model :model boids_3D global torus: torus_environment{ \t//Number of boids to create\tint number_of_agents parameter: 'Number of agents' &lt;- 100 min: 1 max: 1000000;\t//Number of obstacles to create\tint number_of_obstacles parameter: 'Number of obstacles' &lt;- 0 min: 0;\t//Size of the boids\tint boids_size parameter: 'Boids size' &lt;- 50 min: 1;\t//Maximal speed of the boids\tfloat maximal_speed parameter: 'Maximal speed' &lt;- 15.0 min: 0.1 max: 15.0;\t//Factor for the boids flock\tint cohesion_factor parameter: 'Cohesion Factor' &lt;- 100; \tint alignment_factor parameter: 'Alignment Factor' &lt;- 100; \tfloat minimal_distance parameter: 'Minimal Distance' &lt;- 10.0; \t//MAximal angle of turn for the boids\tint maximal_turn parameter: 'Maximal Turn' &lt;- 90 min: 0 max: 359; \t//environment parameters\tint width_and_height_of_environment parameter: 'Width/Height of the Environment' &lt;- 800;  \tint z_max parameter: 'Z max of the Environment' &lt;- 400;  \tbool torus_environment parameter: 'Toroidal Environment ?' &lt;- false; \t//Experiment parameter\tbool apply_cohesion &lt;- true parameter: 'Apply Cohesion ?';\tbool apply_alignment &lt;- true parameter: 'Apply Alignment ?';   \tbool apply_separation &lt;- true parameter: 'Apply Separation ?';   \tbool apply_goal &lt;- true parameter: 'Follow Goal ?'; \tbool apply_wind &lt;- true parameter: 'Apply Wind ?';     \t//Wind variable\tpoint wind_vector &lt;- {0,0,0}  parameter: 'Direction of the wind';   \t//Duration of the goal\tint goal_duration &lt;- 30 update: (goal_duration - 1); \t//Location of the goal\tpoint goal &lt;- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 ,(rnd(z_max - 2) + 1)}; \tlist images &lt;- [file('../images/bird1.png'),file('../images/bird2.png'),file('../images/bird3.png')]; \tgeometry shape &lt;- cube(width_and_height_of_environment);\tinit {\t\t//Creation of the boids agents that will be placed randomly within the environment\t\tcreate boids number: number_of_agents { \t\t\tlocation &lt;- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 , (rnd(z_max - 2) + 1)};\t\t} \t\t//Creation of the goal\t\tcreate boids_goal {\t\t\tlocation &lt;- goal;\t\t}\t}}//Species boids_goal that will represent the goal agent, using the skill movingspecies boids_goal skills: [moving3D] {\tfloat range init: 20.0;\t\t//Reflex to make the goal agent wander in a certain amplitude and a certain speed, \t//Respecting the minimal and maximal z values\treflex wander { \t\tdo  wander amplitude: 45 speed: 20; \t\tif (location.z) &lt; 0 {\t\t\tlocation &lt;- {location.x,location.y,0};\t\t} else if (location.z) &gt; z_max {\t\t\tlocation &lt;- {location.x,location.y,z_max};\t\t}\t\tgoal &lt;- location;\t}\t\taspect default { \t\tdraw sphere(10) color: #red ;\t}} //Species boids that will represent the boids agents, using the skill movingspecies boids skills: [moving] {\t//Attribute for the speed of the boids\tfloat speed max: maximal_speed &lt;- maximal_speed;\t//Range of sensing of the boids\tfloat range &lt;- minimal_distance * 2;\tpoint velocity &lt;- {0,0, 0} ;\t\t//List of the others boids in the range distance of the agent\tlist others update: ((boids at_distance range)  - self);\t//Mass center of the \"flock\" represented as the other boids in the sensing range\tpoint mass_center update:  (length(others) &gt; 0) ? (mean (others collect (each.location)) )  : location;\t\t//Reflex to apply separation\treflex separation when: apply_separation {\t\tpoint acc &lt;- {0,0,0};\t\tloop boid over: (boids at_distance (minimal_distance))  {\t\t\tacc &lt;- acc - ((location of boid) - location);\t\t}  \t\tvelocity &lt;- velocity + acc;\t}\t//Reflex to apply alignment\treflex alignment when: apply_alignment {\t\tpoint acc &lt;- (length(others) &gt; 0) ? (mean (others collect (each.velocity))) : {0.0,0.0,0.0};\t\tacc &lt;- acc - velocity;\t\tvelocity &lt;- velocity + (acc / alignment_factor);\t}\t//Reflex to apply cohesion\treflex cohesion when: apply_cohesion {\t\tpoint acc &lt;- mass_center - location;\t\tacc &lt;- acc / cohesion_factor;\t\tvelocity &lt;- velocity + acc; \t}\t//Action to make the agent location within the environment\taction bounding {\t\tif (location.z) &lt; 0 {\t\t\tlocation &lt;- {location.x,location.y,0};\t\t} else if (location.z) &gt; z_max {\t\t\tlocation &lt;- {location.x,location.y,z_max};\t\t}\t}\t//Reflex to make the agent follow the goal\treflex follow_goal when: apply_goal {\t\tvelocity &lt;- velocity + ((goal - location) / cohesion_factor);\t}\t//Reflex to apply the wind by using the vector of wind\treflex wind when: apply_wind {\t\tvelocity &lt;- velocity + wind_vector;\t}\t//Action to make the agent moving\taction do_move {  \t\tif (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) and (((velocity.z) as int) = 0) {\t\t\tvelocity &lt;- {(rnd(4)) -2, (rnd(4)) - 2,  ((rnd(4)) - 2)} ; \t\t}\t\tpoint old_location &lt;- location;\t\tdo goto target: location + velocity;\t\tvelocity &lt;- location - old_location;\t}\t//Reflex to move the agent, calling both bounding and do_move action\treflex movement {\t\tdo bounding;\t\tdo do_move;\t}\t\taspect sphere {\t\tdraw sphere(10) color: #green;\t}\t\taspect image {\t\tdraw (images at (rnd(2))) size: boids_size rotate: heading color: #black ;      \t}}experiment boids_3D type: gui {\t\t\toutput {\t\t\t\tdisplay Sky1 type:opengl  z_fighting:false{\t\t\timage 'background' file:'../images/ocean.jpg' ;\t\t\tspecies boids aspect: image;\t\t\tspecies boids_goal;\t\t\t}\t\t\t}}",
        "url":"/wiki/Boids-Boids-3D-Motion.html"
      }
      ,
    
      "wiki-boids-boids-with-flocks-html": {
        "title": "Boids With Flocks",
        "content": "Boids With Flocks_Author : _This model shows the movement of boids following a goal, and creating without their own volonty, a flock .Imported model :model boids global torus: torus_environment{ \t//Number of boids that will be created\tint number_of_agents &lt;- 50 min: 1 max: 1000000;\t//Number of obstacles for the boids movement to represent\tint number_of_obstacles &lt;- 0 min: 0;\t//Maximal speed of the boids\tfloat maximal_speed &lt;- 15.0 min: 0.1 max: 15.0;\t//Factors for the group of boids\tint cohesion_factor &lt;- 200;\tint alignment_factor &lt;- 100; \t//Variables for the movement of the boids\tfloat minimal_distance &lt;- 10.0; \tint maximal_turn &lt;- 45 min: 0 max: 359; \t\tint width_and_height_of_environment &lt;- 1000;  \tbool torus_environment &lt;- false; \tbool apply_cohesion &lt;- true ;\tbool apply_alignment &lt;- true ;\tbool apply_separation &lt;- true;\tbool apply_avoid &lt;- true;  \tbool apply_wind &lt;- true;   \tbool moving_obstacles &lt;- false;   \tint bounds &lt;- int(width_and_height_of_environment / 20); \t//Vector for the wind\tpoint wind_vector &lt;- {0,0}; \tlist images of: image_file &lt;- [file('../images/bird1.png'),file('../images/bird2.png'),file('../images/bird3.png')]; \tint xmin &lt;- bounds;   \tint ymin &lt;- bounds;  \tint xmax &lt;- (width_and_height_of_environment - bounds);     \tint ymax &lt;- (width_and_height_of_environment - bounds);   \t\t//Action to move the goal to the mouse location\taction move_goal(point mouse) {\t\task first(boids_goal) {\t\t\tdo goto target: mouse speed: 30;\t\t}\t}\t\tgeometry shape &lt;- square(width_and_height_of_environment);\t\tinit { \t\t//Create the boids agents\t\tcreate boids number: number_of_agents { \t\t\t location &lt;- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };\t\t} \t\t//Create the obstacles agents\t\tcreate obstacle number: number_of_obstacles {\t\t\tlocation &lt;- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 }; \t\t}\t\t//Create the goal that boids will follow\t\tcreate  boids_goal;\t\t}\t}//Species boids goal which represents the goal that will be followed by boids agents using the skill movingspecies boids_goal skills: [moving] {\tfloat range  &lt;- 20.0;\t\t//If the mouse is not used, then the goal just wander\treflex wander {  \t\tdo  wander amplitude: 45 speed: 20;  \t}\t\taspect default {\t\tdraw circle(10) color: #red ;\t\tdraw circle(40) color: #orange empty: true;\t}} //Species boids which represents the boids agents whom follow the boid goal agents, using the skill movingspecies boids skills: [moving] {\t//Speed of the boids agents\tfloat speed max: maximal_speed &lt;- maximal_speed;\t//Range used to consider the group of the agent\tfloat range &lt;- minimal_distance * 2;\tpoint velocity &lt;- {0,0};\t\t\t//Reflex used when the separation is applied to change the velocity of the boid\treflex separation when: apply_separation {\t\tpoint acc &lt;- {0,0};\t\task (boids overlapping (circle(minimal_distance)))  {\t\t\tacc &lt;- acc - ((location) - myself.location);\t\t}  \t\tvelocity &lt;- velocity + acc;\t}\t\t//Reflex to align the boid with the other boids in the range\treflex alignment when: apply_alignment {\t\tlist others  &lt;- ((boids overlapping (circle (range)))  - self);\t\tpoint acc &lt;- mean (others collect (each.velocity)) - velocity;\t\tvelocity &lt;- velocity + (acc / alignment_factor);\t}\t \t//Reflex to apply the cohesion of the boids group in the range of the agent\treflex cohesion when: apply_cohesion {\t\tlist others &lt;- ((boids overlapping (circle (range)))  - self);\t\tpoint mass_center &lt;- (length(others) &gt; 0) ? mean (others collect (each.location)) : location;\t\tpoint acc &lt;- mass_center - location;\t\tacc &lt;- acc / cohesion_factor; \t\tvelocity &lt;- velocity + acc;   \t}\t\t//Reflex to avoid the obstacles\treflex avoid when: apply_avoid { \t\tpoint acc &lt;- {0,0};\t\tlist&lt;obstacle&gt; nearby_obstacles &lt;- (obstacle overlapping (circle (range)) );\t\tloop obs over: nearby_obstacles {\t\t\tacc &lt;- acc - ((location of obs) - my (location));\t\t}\t\tvelocity &lt;- velocity + acc; \t}\t\t//action to represent the bounding of the environment considering the velocity of the boid\taction bounding {\t\tif  !(torus_environment) {\t\t\tif  (location.x) &lt; xmin {\t\t\t\tvelocity &lt;- velocity + {bounds,0};\t\t\t} else if (location.x) &gt; xmax {\t\t\t\tvelocity &lt;- velocity - {bounds,0};\t\t\t}\t\t\t\t\t\tif (location.y) &lt; ymin {\t\t\t\tvelocity &lt;- velocity + {0,bounds};\t\t\t} else if (location.y) &gt; ymax {\t\t\t\tvelocity &lt;- velocity - {0,bounds};\t\t\t}\t\t\t\t\t}\t}\t//Reflex to follow the goal \treflex follow_goal {\t\tvelocity &lt;- velocity + ((first(boids_goal).location - location) / cohesion_factor);\t}\t//Reflex to apply the wind vector on the velocity\treflex wind when: apply_wind {\t\tvelocity &lt;- velocity + wind_vector;\t}\t\t//Action to move the agent  \taction do_move {  \t\tif (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) {\t\t\tvelocity &lt;- {(rnd(4)) -2, (rnd(4)) - 2};\t\t}\t\tpoint old_location &lt;- copy(location);\t\tdo goto target: location + velocity;\t\tvelocity &lt;- location - old_location;\t}\t\t//Reflex to apply the movement by calling the do_move action\treflex movement {\t\tdo do_move;\t}\t\taspect image {\t\tdraw (images at (rnd(2))) size: {50,50} rotate: heading ;      \t}\taspect circle { \t\tdraw circle(15)  color: #red;\t}\t\taspect default { \t\tdraw circle(20) color: #lightblue empty: true;\t}} //Species obstacle that represents the obstacles avoided by the boids agents using the skill movingspecies obstacle skills: [moving] {\tfloat speed &lt;- 2.0;\tgeometry shape &lt;- triangle(15);\t\t//Reflex to move the obstacles if it is available\treflex move_obstacles when: moving_obstacles {\t\t//Will make the agent go to a boid with a 50% probability\t\tif flip(0.5)  \t\t{ \t\t\tdo goto target: one_of(boids);\t\t} \t\telse{ \t\t\tdo wander amplitude: 360;   \t\t}\t}\taspect default {\t\tdraw  triangle(20) color: #black ;\t}}experiment boids_gui type: gui {\tparameter 'Number of agents' var: number_of_agents;\tparameter 'Number of obstacles' var: number_of_obstacles;\tparameter 'Maximal speed' var: maximal_speed;\tparameter 'Cohesion Factor' var: cohesion_factor;\tparameter 'Alignment Factor' var: alignment_factor; \tparameter 'Minimal Distance'  var: minimal_distance; \tparameter 'Maximal Turn'  var: maximal_turn; \tparameter 'Width/Height of the Environment' var: width_and_height_of_environment ;  \tparameter 'Toroidal Environment ?'  var: torus_environment ; \tparameter 'Apply Cohesion ?' var: apply_cohesion ;\tparameter 'Apply Alignment ?' var: apply_alignment ;   \tparameter 'Apply Separation ?' var: apply_separation ;   \tparameter 'Apply Avoidance ?' var: apply_avoid ;   \tparameter 'Apply Wind ?' var: apply_wind ;     \tparameter 'Moving Obstacles ?' var: moving_obstacles  ;    \tparameter 'Direction of the wind' var: wind_vector ;  \t\t//Minimum duration of a step to better see the movements\tfloat minimum_cycle_duration &lt;- 0.01;\toutput {\t\tdisplay Sky  background: #blue type: opengl { \t\t\timage '../images/sky.jpg' refresh: false;\t\t\tspecies boids aspect: image trace: 10 fading: true ;\t\t\tspecies boids_goal;\t\t\tspecies obstacle;\t\t\t//Event to call the action move_goal in global if the mouse move within the experiment\t\t\tevent mouse_move action: move_goal;\t\t}\t}}Code of the model :model boids_flock//Import the boids modelimport \"Boids.gaml\"global {\t//Size of the boids\tfloat boids_size &lt;- float(3);\t//Shape of the boids\tgeometry boids_shape &lt;- circle(boids_size);\t//Separation between boids\tfloat boids_separation &lt;- 4 * boids_size;\t//Distance to allow creation of the flock \tint flock_creation_distance &lt;- int(boids_separation + 1);\t//Minimum number of member among a flock\tint min_group_member &lt;- 3;\t//Frequency of update for the flock\tint update_frequency &lt;- 10;\t//Frequency of merge for the flock\tint merge_frequency &lt;- 10;\t//Allow the creation of flock\tbool create_flocks &lt;- false;\t//Perception range of the boids\tint base_perception_range &lt;- int(xmax / 100) min: 1;\t\tinit {\t\t//Creation of the different agents viewer\t\tcreate boids_agents_viewer;\t\tcreate flock_agents_viewer;\t\tcreate boids_in_flock_viewer;\t}\t//Reflex to create the flocks if it is available\treflex create_flocks when: create_flocks {\t\t\t\tif (length(boids) &gt; 1) {\t\t\t//Clustering by distance of the boids to determine the satisfying boids groups\t\t\tlist&lt;list&lt;boids&gt;&gt; satisfying_boids_groups &lt;- (boids.population simple_clustering_by_distance flock_creation_distance) where ((length(each)) &gt; min_group_member);\t\t\tloop one_group over: satisfying_boids_groups {\t\t\t\t\t\t\t\tgeometry potential_flock_polygon &lt;- convex_hull(solid(polygon(one_group collect boids(each).location)) + (base_perception_range + 5));\t\t\t\t//If there is no obstacle between the boids of a potential flock, then the flock is created and all the boids become boids in flock\t\t\t\tif (empty(obstacle overlapping potential_flock_polygon)) {\t\t\t\t\tcreate flock {\t\t\t\t\t\tcapture one_group as: boids_in_flock;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t}}//Species flock which represent the flock of boids, using the skill movingspecies flock skills: [moving] {\trgb color &lt;- rgb(rnd(255), rnd(255), rnd(255));\tgeometry shape &lt;- polygon(((boids_in_flock))) buffer 10;\t//Range of perception of the flock\tfloat perception_range &lt;- float(base_perception_range + (rnd(5)));\t//Speed of the flock\tfloat speed update: mean(boids_in_flock collect each.speed);\t//Reflex to disaggregate the flock if there is a obstacle in the flock\treflex disaggregate {\t\tgeometry buffered_shape &lt;- shape + perception_range;\t\tif !(empty(obstacle overlapping buffered_shape)) {\t\t\trelease members as: boids in: world;\t\t\tdo die;\t\t}\t}\t//Reflex to capture the boids nearby in the range of perception with an update_frequency\treflex capture_nearby_boids when: ((cycle mod update_frequency) = 0) {\t\tgeometry buffered_shape &lt;- shape + perception_range;\t\tlist&lt;boids&gt; nearby_boids &lt;- (boids overlapping buffered_shape);\t\tif (!(empty(nearby_boids))) {\t\t\tgeometry new_polygon &lt;- convex_hull(solid(shape + polygon(nearby_boids collect (each.location))));\t\t\tif (empty(obstacle overlapping new_polygon)) {\t\t\t\tcapture nearby_boids as: boids_in_flock;\t\t\t}\t\t}\t}\t//Reflex to merge the intersecting flocks\treflex merge_nearby_flocks when: ((cycle mod merge_frequency) = 0) \t{\t\tloop f over: (flock) {\t\t\tif (f != self and (shape intersects f.shape)) {\t\t\t\tgeometry new_shape &lt;- convex_hull(polygon(shape.points + f.shape.points));\t\t\t\tif empty(obstacle overlapping new_shape) {\t\t\t\t\tlist&lt;boids&gt; released_boids;\t\t\t\t\task f {\t\t\t\t\t\trelease members as: boids in: world returns: released_coms;\t\t\t\t\t\treleased_boids &lt;- list(released_coms);\t\t\t\t\t\tdo die;\t\t\t\t\t}\t\t\t\t\tif (!empty(released_boids)) {\t\t\t\t\t\tcapture released_boids as: boids_in_flock;\t\t\t\t\t}\t\t\t\t\tshape &lt;- convex_hull(polygon(members collect (boids_in_flock(each).location)));\t\t\t\t}\t\t\t}\t\t}\t}\t//Reflex to make the flock follow the goal\treflex chase_goal {\t\tint direction_to_nearest_ball &lt;- (self towards (first(boids_goal)));\t\tfloat step_distance &lt;- speed * step;\t\tfloat dx &lt;- step_distance * (cos(direction_to_nearest_ball));\t\tfloat dy &lt;- step_distance * (sin(direction_to_nearest_ball));\t\tgeometry envelope &lt;- shape.envelope;\t\tfloat min_y &lt;- (envelope.points with_min_of (each.y)).y;\t\tfloat min_x &lt;- (envelope.points with_min_of (each.x)).x;\t\tfloat max_x &lt;- (envelope.points with_max_of (each.x)).x;\t\tfloat max_y &lt;- (envelope.points with_max_of (each.y)).y;\t\tif (((dx + min_x) &lt; xmin) and min_x &gt; xmin) or (((dx + max_x) &gt; xmax) and max_x &lt; xmax) {\t\t\tdx &lt;- 0.0;\t\t}\t\tif (((dy + min_y) &lt; ymin) and min_y &gt; ymin) or (((dy + max_y) &gt; ymax) and max_y &lt; ymax) {\t\t\tdy &lt;- 0.0;\t\t}\t\t\t\tloop com over: boids_in_flock {\t\t\t(boids_in_flock(com)).location &lt;- (boids_in_flock(com)).location + { dx, dy };\t\t}\t\tshape &lt;- convex_hull(polygon(list(boids_in_flock) collect (each.location)));\t}\taspect default {\t\tdraw shape color: color;\t}\t//Species boids_in_flock which represents the boids agents captured by the flock\tspecies boids_in_flock parent: boids {\t\tfloat my_age &lt;- 1.0 update: my_age + 0.01;\t\treflex separation when: apply_separation {\t\t}\t\treflex alignment when: apply_alignment {\t\t}\t\treflex cohesion when: apply_cohesion {\t\t}\t\treflex avoid when: apply_avoid {\t\t}\t\treflex follow_goal  {\t\t}\t\treflex wind when: apply_wind {\t\t}\t\taction do_move {\t\t}\t\treflex movement {\t\t\tdo do_move;\t\t}\t\taspect default {\t\t\tdraw circle(my_age) color: ((host as flock).color).darker;\t\t}\t}}//Species flock agents viewer which draw the flock informationspecies flock_agents_viewer {\taspect default {\t\tdraw \"Flocks: \" + (string(length(list(flock)))) at: { width_and_height_of_environment - 810, (width_and_height_of_environment) - 5 } color: #blue size: 80 ;\t}}//Species boids agents viewer which draw the boids informationspecies boids_agents_viewer {\taspect default {\t\tdraw \"Boids: \" + (string(length(list(boids)))) at: { width_and_height_of_environment - 810, (width_and_height_of_environment) - 165 } color: #blue size: 80 ;\t}}//Species boids_in_flock_viewer which draw the boids in flock informationspecies boids_in_flock_viewer {\taspect default {\t\tdraw \"Boids in flocks: \" + (string(number_of_agents - (length(list(boids))))) at: { width_and_height_of_environment - 810, width_and_height_of_environment - 85 } color:\t\t#blue size: 80 ;\t}}experiment boids_flocks type: gui {\tparameter \"Create flock?\" var: create_flocks &lt;- true;\tparameter \"Number of boids\" var: number_of_agents &lt;- 300;\tparameter \"Environment size\" var: width_and_height_of_environment &lt;- 1600;\tparameter \"Moving obstacles?\" var: moving_obstacles &lt;- true;\tparameter \"Torus environment?\" var: torus_environment &lt;- false;\tparameter \"Number of obstacles\" var: number_of_obstacles &lt;- 5;\toutput {\t\tdisplay default_display {\t\t\tspecies boids_goal;\t\t\tspecies boids aspect: image;\t\t\tspecies obstacle;\t\t\tspecies flock aspect: default transparency: 0.5 {\t\t\t\tspecies boids_in_flock aspect: default;\t\t\t}\t\t\tspecies flock_agents_viewer;\t\t\tspecies boids_agents_viewer;\t\t\tspecies boids_in_flock_viewer;\t\t}\t}}",
        "url":"/wiki/Boids-Boids-With-Flocks.html"
      }
      ,
    
      "wiki-boids-boids-html": {
        "title": "Boids",
        "content": "Boids_Author : _This model shows the movement of boids following a goal, and creating without their own volonty, a flock. The experiment proposes to display in a 3D view the different boids and allows the user to move the goal to see the behaviour of boids.Code of the model :model boids global torus: torus_environment{ \t//Number of boids that will be created\tint number_of_agents &lt;- 50 min: 1 max: 1000000;\t//Number of obstacles for the boids movement to represent\tint number_of_obstacles &lt;- 0 min: 0;\t//Maximal speed of the boids\tfloat maximal_speed &lt;- 15.0 min: 0.1 max: 15.0;\t//Factors for the group of boids\tint cohesion_factor &lt;- 200;\tint alignment_factor &lt;- 100; \t//Variables for the movement of the boids\tfloat minimal_distance &lt;- 10.0; \tint maximal_turn &lt;- 45 min: 0 max: 359; \t\tint width_and_height_of_environment &lt;- 1000;  \tbool torus_environment &lt;- false; \tbool apply_cohesion &lt;- true ;\tbool apply_alignment &lt;- true ;\tbool apply_separation &lt;- true;\tbool apply_avoid &lt;- true;  \tbool apply_wind &lt;- true;   \tbool moving_obstacles &lt;- false;   \tint bounds &lt;- int(width_and_height_of_environment / 20); \t//Vector for the wind\tpoint wind_vector &lt;- {0,0}; \tlist images of: image_file &lt;- [file('../images/bird1.png'),file('../images/bird2.png'),file('../images/bird3.png')]; \tint xmin &lt;- bounds;   \tint ymin &lt;- bounds;  \tint xmax &lt;- (width_and_height_of_environment - bounds);     \tint ymax &lt;- (width_and_height_of_environment - bounds);   \t\t//Action to move the goal to the mouse location\taction move_goal(point mouse) {\t\task first(boids_goal) {\t\t\tdo goto target: mouse speed: 30;\t\t}\t}\t\tgeometry shape &lt;- square(width_and_height_of_environment);\t\tinit { \t\t//Create the boids agents\t\tcreate boids number: number_of_agents { \t\t\t location &lt;- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };\t\t} \t\t//Create the obstacles agents\t\tcreate obstacle number: number_of_obstacles {\t\t\tlocation &lt;- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 }; \t\t}\t\t//Create the goal that boids will follow\t\tcreate  boids_goal;\t\t}\t}//Species boids goal which represents the goal that will be followed by boids agents using the skill movingspecies boids_goal skills: [moving] {\tfloat range  &lt;- 20.0;\t\t//If the mouse is not used, then the goal just wander\treflex wander {  \t\tdo  wander amplitude: 45 speed: 20;  \t}\t\taspect default {\t\tdraw circle(10) color: #red ;\t\tdraw circle(40) color: #orange empty: true;\t}} //Species boids which represents the boids agents whom follow the boid goal agents, using the skill movingspecies boids skills: [moving] {\t//Speed of the boids agents\tfloat speed max: maximal_speed &lt;- maximal_speed;\t//Range used to consider the group of the agent\tfloat range &lt;- minimal_distance * 2;\tpoint velocity &lt;- {0,0};\t\t\t//Reflex used when the separation is applied to change the velocity of the boid\treflex separation when: apply_separation {\t\tpoint acc &lt;- {0,0};\t\task (boids overlapping (circle(minimal_distance)))  {\t\t\tacc &lt;- acc - ((location) - myself.location);\t\t}  \t\tvelocity &lt;- velocity + acc;\t}\t\t//Reflex to align the boid with the other boids in the range\treflex alignment when: apply_alignment {\t\tlist others  &lt;- ((boids overlapping (circle (range)))  - self);\t\tpoint acc &lt;- mean (others collect (each.velocity)) - velocity;\t\tvelocity &lt;- velocity + (acc / alignment_factor);\t}\t \t//Reflex to apply the cohesion of the boids group in the range of the agent\treflex cohesion when: apply_cohesion {\t\tlist others &lt;- ((boids overlapping (circle (range)))  - self);\t\tpoint mass_center &lt;- (length(others) &gt; 0) ? mean (others collect (each.location)) : location;\t\tpoint acc &lt;- mass_center - location;\t\tacc &lt;- acc / cohesion_factor; \t\tvelocity &lt;- velocity + acc;   \t}\t\t//Reflex to avoid the obstacles\treflex avoid when: apply_avoid { \t\tpoint acc &lt;- {0,0};\t\tlist&lt;obstacle&gt; nearby_obstacles &lt;- (obstacle overlapping (circle (range)) );\t\tloop obs over: nearby_obstacles {\t\t\tacc &lt;- acc - ((location of obs) - my (location));\t\t}\t\tvelocity &lt;- velocity + acc; \t}\t\t//action to represent the bounding of the environment considering the velocity of the boid\taction bounding {\t\tif  !(torus_environment) {\t\t\tif  (location.x) &lt; xmin {\t\t\t\tvelocity &lt;- velocity + {bounds,0};\t\t\t} else if (location.x) &gt; xmax {\t\t\t\tvelocity &lt;- velocity - {bounds,0};\t\t\t}\t\t\t\t\t\tif (location.y) &lt; ymin {\t\t\t\tvelocity &lt;- velocity + {0,bounds};\t\t\t} else if (location.y) &gt; ymax {\t\t\t\tvelocity &lt;- velocity - {0,bounds};\t\t\t}\t\t\t\t\t}\t}\t//Reflex to follow the goal \treflex follow_goal {\t\tvelocity &lt;- velocity + ((first(boids_goal).location - location) / cohesion_factor);\t}\t//Reflex to apply the wind vector on the velocity\treflex wind when: apply_wind {\t\tvelocity &lt;- velocity + wind_vector;\t}\t\t//Action to move the agent  \taction do_move {  \t\tif (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) {\t\t\tvelocity &lt;- {(rnd(4)) -2, (rnd(4)) - 2};\t\t}\t\tpoint old_location &lt;- copy(location);\t\tdo goto target: location + velocity;\t\tvelocity &lt;- location - old_location;\t}\t\t//Reflex to apply the movement by calling the do_move action\treflex movement {\t\tdo do_move;\t}\t\taspect image {\t\tdraw (images at (rnd(2))) size: {50,50} rotate: heading ;      \t}\taspect circle { \t\tdraw circle(15)  color: #red;\t}\t\taspect default { \t\tdraw circle(20) color: #lightblue empty: true;\t}} //Species obstacle that represents the obstacles avoided by the boids agents using the skill movingspecies obstacle skills: [moving] {\tfloat speed &lt;- 2.0;\tgeometry shape &lt;- triangle(15);\t\t//Reflex to move the obstacles if it is available\treflex move_obstacles when: moving_obstacles {\t\t//Will make the agent go to a boid with a 50% probability\t\tif flip(0.5)  \t\t{ \t\t\tdo goto target: one_of(boids);\t\t} \t\telse{ \t\t\tdo wander amplitude: 360;   \t\t}\t}\taspect default {\t\tdraw  triangle(20) color: #black ;\t}}experiment boids_gui type: gui {\tparameter 'Number of agents' var: number_of_agents;\tparameter 'Number of obstacles' var: number_of_obstacles;\tparameter 'Maximal speed' var: maximal_speed;\tparameter 'Cohesion Factor' var: cohesion_factor;\tparameter 'Alignment Factor' var: alignment_factor; \tparameter 'Minimal Distance'  var: minimal_distance; \tparameter 'Maximal Turn'  var: maximal_turn; \tparameter 'Width/Height of the Environment' var: width_and_height_of_environment ;  \tparameter 'Toroidal Environment ?'  var: torus_environment ; \tparameter 'Apply Cohesion ?' var: apply_cohesion ;\tparameter 'Apply Alignment ?' var: apply_alignment ;   \tparameter 'Apply Separation ?' var: apply_separation ;   \tparameter 'Apply Avoidance ?' var: apply_avoid ;   \tparameter 'Apply Wind ?' var: apply_wind ;     \tparameter 'Moving Obstacles ?' var: moving_obstacles  ;    \tparameter 'Direction of the wind' var: wind_vector ;  \t\t//Minimum duration of a step to better see the movements\tfloat minimum_cycle_duration &lt;- 0.01;\toutput {\t\tdisplay Sky  background: #blue type: opengl { \t\t\timage '../images/sky.jpg' refresh: false;\t\t\tspecies boids aspect: image trace: 10 fading: true ;\t\t\tspecies boids_goal;\t\t\tspecies obstacle;\t\t\t//Event to call the action move_goal in global if the mouse move within the experiment\t\t\tevent mouse_move action: move_goal;\t\t}\t}}",
        "url":"/wiki/Boids-Boids.html"
      }
      ,
    
      "wiki-boids-html": {
        "title": "Boids",
        "content": "BoidsThis sub-section is composed of the following models :      Boids 3D Analysis        Boids 3D Motion        Boids With Flocks        Boids  ",
        "url":"/wiki/Boids.html"
      }
      ,
    
      "wiki-builtinarchitectures-html": {
        "title": "Built-in Architectures",
        "content": "Built-in ArchitecturesThis file is automatically generated from java files. Do Not Edit It.INTRODUCTIONTable of Contents[fsm](#fsm), [parallel_bdi](#parallel_bdi), [probabilistic_tasks](#probabilistic_tasks), [reflex](#reflex), [simple_bdi](#simple_bdi), [sorted_tasks](#sorted_tasks), [user_first](#user_first), [user_last](#user_last), [user_only](#user_only), [weighted_tasks](#weighted_tasks), fsmVariables  state (string): Returns the current state in which the agent is  states (list): Returns the list of all possible states the agents can be inActionsparallel_bdiVariablesActionsprobabilistic_tasksVariablesActionsreflexVariablesActionssimple_bdiVariables  belief_base (list):  charisma (float):  current_plan (any type):  desire_base (list):  emotion_base (list):  intention_base (list):  intention_persistence (float): intention persistence  plan_base (list):  plan_persistence (float): plan persistence  probabilistic_choice (boolean):  receptivity (float):  social_link_base (list):  thinking (list):  uncertainty_base (list):  use_emotions_architecture (boolean):  use_social_architecture (boolean):Actionsadd_beliefadd the predicate in the belief base.  returns: bool  predicate (546704): predicate to add as a beliefadd_desireadds the predicates is in the desire base.  returns: bool  predicate (546704): predicate to add  todo (546704): add the desire as a subintention of this parameteradd_emotionadd the emotion to the emotion base.  returns: bool  emotion (546706): emotion to add to the baseadd_intentioncheck if the predicates is in the desire base.  returns: bool  predicate (map): predicate to checkadd_social_linkadd the social link to the social link base.  returns: bool  social_link (546707): social link to add to the baseadd_subintentionadds the predicates is in the desire base.  returns: bool  predicate (546704): predicate name  subintentions (546704): the subintention to add to the predicate  add_as_desire (boolean): add the subintention as a desire as well (by default, false)add_uncertaintyadd a predicate in the uncertainty base.  returns: bool  predicate (546704): predicate to checkclear_beliefsclear the belief base  returns: boolclear_desiresclear the desire base  returns: boolclear_emotionsclear the emotion base  returns: boolclear_intentionsclear the intention base  returns: boolclear_social_linksclear the intention base  returns: boolclear_uncertaintiesclear the uncertainty base  returns: boolcurrent_intention_on_holdputs the current intention on hold until the specified condition is reached or all subintentions are reached (not in desire base anymore).  returns: bool  until (any type): the current intention is put on hold (fited plan are not considered) until specific condition is reached. Can be an expression (which will be tested), a list (of subintentions), or nil (by default the condition will be the current list of subintentions of the intention)get_beliefget the predicate in the belief base (if several, returns the first one).  returns: predicate  predicate (546704): predicate to getget_belief_with_nameget the predicates is in the belief base (if several, returns the first one).  returns: predicate  name (string): name of the predicate to checkget_beliefsget the list of predicates is in the belief base  returns: msi.gama.util.IList  predicate (546704): name of the predicates to checkget_beliefs_with_nameget the list of predicates is in the belief base with the given name.  returns: msi.gama.util.IList  name (string): name of the predicates to checkget_current_intentionreturns the current intention (last entry of intention base).  returns: predicateget_desireget the predicates is in the desire base (if several, returns the first one).  returns: predicate  predicate (546704): predicate to checkget_desire_with_nameget the predicates is in the belief base (if several, returns the first one).  returns: predicate  name (string): name of the predicate to checkget_desiresget the list of predicates is in the belief base  returns: msi.gama.util.IList  predicate (546704): name of the predicates to checkget_desires_with_nameget the list of predicates is in the belief base with the given name.  returns: java.util.List  name (string): name of the predicates to checkget_emotionget the emotion in the emotion base (if several, returns the first one).  returns: emotion  emotion (546706): emotion to getget_intentionget the predicates is in the belief base (if several, returns the first one).  returns: predicate  predicate (546704): predicate to checkget_intention_with_nameget the predicates is in the belief base (if several, returns the first one).  returns: predicate  name (string): name of the predicate to checkget_intentionsget the list of predicates is in the belief base  returns: msi.gama.util.IList  predicate (546704): name of the predicates to checkget_intentions_with_nameget the list of predicates is in the belief base with the given name.  returns: java.util.List  name (string): name of the predicates to checkget_plansget the list of plans.  returns: java.util.Listget_social_linkget the social linke (if several, returns the first one).  returns: msi.gaml.architecture.simplebdi.SocialLink  social_link (546707): social link to checkget_uncertaintyget the predicates is in the uncertainty base (if several, returns the first one).  returns: predicate  predicate (546704): predicate to checkhas_beliefcheck if the predicates is in the belief base.  returns: bool  predicate (546704): predicate to checkhas_desirecheck if the predicates is in the desire base.  returns: bool  predicate (546704): predicate to checkhas_emotioncheck if the emotion is in the belief base.  returns: bool  emotion (546706): emotion to checkhas_social_linkcheck if the social link base.  returns: bool  social_link (546707): social link to checkhas_uncertaintycheck if the predicates is in the uncertainty base.  returns: bool  predicate (546704): predicate to checkis_current_intentioncheck if the predicates is the current intention (last entry of intention base).  returns: bool  predicate (546704): predicate to checkremove_all_beliefsremoves the predicates from the belief base.  returns: bool  predicate (546704): predicate to removeremove_beliefremoves the predicate from the belief base.  returns: bool  predicate (546704): predicate to removeremove_desireremoves the predicates from the desire base.  returns: bool  predicate (546704): predicate to addremove_emotionremoves the emotion from the emotion base.  returns: bool  emotion (546706): emotion to removeremove_intentionremoves the predicates from the desire base.  returns: bool  predicate (546704): predicate to add  desire_also (boolean): removes also desireremove_social_linkremoves the social link from the social relation base.  returns: bool  social_link (546707): social link to removeremove_uncertaintyremoves the predicates from the desire base.  returns: bool  predicate (546704): predicate to addreplace_beliefreplace the old predicate by the new one.  returns: bool  old_predicate (546704): predicate to remove  predicate (546704): predicate to addsorted_tasksVariablesActionsuser_firstVariablesActionsuser_lastVariablesActionsuser_onlyVariablesActionsweighted_tasksVariablesActions",
        "url":"/wiki/BuiltInArchitectures.html"
      }
      ,
    
      "wiki-builtinskills-html": {
        "title": "Built-in Skills",
        "content": "Built-in SkillsThis file is automatically generated from java files. Do Not Edit It.IntroductionSkills are built-in modules, written in Java, that provide a set of related built-in variables and built-in actions (in addition to those already provided by GAMA) to the species that declare them. A declaration of skill is done by filling the skills attribute in the species definition:species my_species skills: [skill1, skill2] {    ...}Skills have been designed to be mutually compatible so that any combination of them will result in a functional species. An example of skill is the moving skill.So, for instance, if a species is declared as:species foo skills: [moving]{...}Its agents will automatically be provided with the following variables : speed, heading, destination and the following actions: move, goto, wander, follow in addition to those built-in in species and declared by the modeller. Most of these variables, except the ones marked read-only, can be customized and modified like normal variables by the modeller. For instance, one could want to set a maximum for the speed; this would be done by redeclaring it like this:float speed max:100 min:0;Or, to obtain a speed increasing at each simulation step:float speed max:100 min:0  &lt;- 1 update: speed * 1.01;Or, to change the speed in a behavior:if speed = 5 {    speed &lt;- 10;}Table of Contentsadvanced_driving, driving, fipa, GAMASQL, grid, MDXSKILL, messaging, moving, moving3D, network, physics, skill_road, skill_road_node, SQLSKILL,advanced_drivingVariables  current_index (int): the current index of the agent target (according to the targets list)  current_lane (int): the current lane on which the agent is  current_path (path): the current path that tha agent follow  current_road (agent): current road on which the agent is  current_target (point): the current target of the agent  distance_to_goal (float): euclidean distance to the next point of the current segment  final_target (point): the final target of the agent  max_acceleration (float): maximum acceleration of the car for a cycle  max_speed (float): maximal speed of the vehicle  on_linked_road (boolean): is the agent on the linked road?  proba_block_node (float): probability to block a node (do not let other driver cross the crossroad)  proba_lane_change_down (float): probability to change lane to a lower lane (right lane if right side driving) if necessary  proba_lane_change_up (float): probability to change lane to a upper lane (left lane if right side driving) if necessary  proba_respect_priorities (float): probability to respect priority (right or left) laws  proba_respect_stops (list): probability to respect stop laws - one value for each type of stop  proba_use_linked_road (float): probability to change lane to a linked road lane if necessary  real_speed (float): the actual speed of the agent (in meter/second)  right_side_driving (boolean): are drivers driving on the right size of the road?  security_distance_coeff (float): the coefficient for the computation of the the min distance between two drivers (according to the vehicle speed - security_distance = 1#m + security_distance_coeff * real_speed )  segment_index_on_road (int): current segment index of the agent on the current road  speed (float): the speed of the agent (in meter/second)  speed_coeff (float): speed coefficient for the speed that the driver want to reach (according to the max speed of the road)  targets (list): the current list of points that the agent has to reach (path)  vehicle_length (float): the length of the vehicle (in meters)Actionsadvanced_follow_drivingmoves the agent towards along the path passed in the arguments while considering the other agents in the network (only for graph topology)  returns: float  path (path): a path to be followed.  target (point): the target to reach  speed (float): the speed to use for this move (replaces the current value of speed)  time (float): time to travelcompute_pathaction to compute a path to a target location according to a given graph  returns: path  graph (graph): the graph on wich compute the path  target (agent): the target node to reach  source (agent): the source node (optional, if not defined, closest node to the agent location)  on_road (agent): the road on which the agent is located (optional)driveaction to drive toward the final target  returns: voiddrive_randomaction to drive by chosen randomly the next road  returns: void  proba_roads (map): a map containing for each road (key), the probability to be selected as next road (value)external_factor_impactaction that allows to define how the remaining time is impacted by external factor  returns: float  new_road (agent): the road on which to the driver wants to go  remaining_time (float): the remaining timeis_ready_next_roadaction to test if the driver can take the given road at the given lane  returns: bool  new_road (agent): the road to test  lane (int): the lane to testlane_choiceaction to choose a lane  returns: int  new_road (agent): the road on which to choose the lanepath_from_nodesaction to compute a path from a list of nodes according to a given graph  returns: path  graph (graph): the graph on wich compute the path  nodes (list): the list of nodes composing the pathspeed_choiceaction to choose a speed  returns: float  new_road (agent): the road on which to choose the speedtest_next_roadaction to test if the driver can take the given road  returns: bool  new_road (agent): the road to testdrivingVariables  lanes_attribute (string): the name of the attribut of the road agent that determine the number of road lanes  living_space (float): the min distance between the agent and an obstacle (in meter)  obstacle_species (list): the list of species that are considered as obstacles  speed (float): the speed of the agent (in meter/second)  tolerance (float): the tolerance distance used for the computation (in meter)Actionsfollow_drivingmoves the agent along a given path passed in the arguments while considering the other agents in the network.  returns: path  speed (float): the speed to use for this move (replaces the current value of speed)  path (path): a path to be followed.  return_path (boolean): if true, return the path followed (by default: false)  move_weights (map): Weigths used for the moving.  living_space (float): min distance between the agent and an obstacle (replaces the current value of living_space)  tolerance (float): tolerance distance used for the computation (replaces the current value of tolerance)  lanes_attribute (string): the name of the attribut of the road agent that determine the number of road lanes (replaces the current value of lanes_attribute)goto_drivingmoves the agent towards the target passed in the arguments while considering the other agents in the network (only for graph topology)  returns: path  target (geometry): the location or entity towards which to move.  speed (float): the speed to use for this move (replaces the current value of speed)  on (any type): list, agent, graph, geometry that restrains this move (the agent moves inside this geometry)  return_path (boolean): if true, return the path followed (by default: false)  move_weights (map): Weigths used for the moving.  living_space (float): min distance between the agent and an obstacle (replaces the current value of living_space)  tolerance (float): tolerance distance used for the computation (replaces the current value of tolerance)  lanes_attribute (string): the name of the attribut of the road agent that determine the number of road lanes (replaces the current value of lanes_attribute)fipaThe fipa skill offers some primitives and built-in variables which enable agent to communicate with each other using the FIPA interaction protocol.Variables  accept_proposals (list): A list of ‘accept_proposal’ performative messages of the agent’s mailbox having .  agrees (list): A list of ‘accept_proposal’ performative messages.  cancels (list): A list of ‘cancel’ performative messages.  cfps (list): A list of ‘cfp’ (call for proposal) performative messages.  conversations (list): A list containing the current conversations of agent. Ended conversations are automatically removed from this list.  failures (list): A list of ‘failure’ performative messages.  informs (list): A list of ‘inform’ performative messages.  proposes (list): A list of ‘propose’ performative messages .  queries (list): A list of ‘query’ performative messages.  refuses (list): A list of ‘propose’ performative messages.  reject_proposals (list): A list of ‘reject_proposals’ performative messages.  requests (list): A list of ‘request’ performative messages.  requestWhens (list): A list of ‘request-when’ performative messages.  subscribes (list): A list of ‘subscribe’ performative messages.Actionsaccept_proposalReplies a message with an ‘accept_proposal’ performative message.  returns: unknown  message (24): The message to be replied  contents (list): The content of the replying messageagreeReplies a message with an ‘agree’ performative message.  returns: unknown  message (24): The message to be replied  contents (list): The content of the replying messagecancelReplies a message with a ‘cancel’ peformative message.  returns: unknown  message (24): The message to be replied  contents (list): The content of the replying messagecfpReplies a message with a ‘cfp’ performative message.  returns: unknown  message (24): The message to be replied  contents (list): The content of the replying messageend_conversationReply a message with an ‘end_conversation’ peprformative message. This message marks the end of a conversation. In a ‘no-protocol’ conversation, it is the responsible of the modeler to explicitly send this message to mark the end of a conversation/interaction protocol.  returns: unknown  message (24): The message to be replied  contents (list): The content of the replying messagefailureReplies a message with a ‘failure’ performative message.  returns: unknown  message (24): The message to be replied  contents (list): The content of the replying messageinformReplies a message with an ‘inform’ performative message.  returns: unknown  message (24): The message to be replied  contents (list): The content of the replying messageproposeReplies a message with a ‘propose’ performative message.  returns: unknown  message (24): The message to be replied  contents (list): The content of the replying messagequeryReplies a message with a ‘query’ performative message.  returns: unknown  message (24): The message to be replied  contents (list): The content of the replying messagerefuseReplies a message with a ‘refuse’ performative message.  returns: unknown  message (24): The message to be replied  contents (list): The contents of the replying messagereject_proposalReplies a message with a ‘reject_proposal’ performative message.  returns: unknown  message (24): The message to be replied  contents (list): The content of the replying messagereplyReplies a message. This action should be only used to reply a message in a ‘no-protocol’ conversation and with a ‘user defined performative’. For performatives supported by GAMA (i.e., standard FIPA performatives), please use the ‘action’ with the same name of ‘performative’. For example, to reply a message with a ‘request’ performative message, the modeller should use the ‘request’ action.  returns: unknown  message (24): The message to be replied  performative (string): The performative of the replying message  contents (list): The content of the replying messagerequestReplies a message with a ‘request’ performative message.  returns: unknown  message (24): The message to be replied  contents (list): The content of the replying messagesendStarts a conversation/interaction protocol.  returns: msi.gaml.extensions.fipa.FIPAMessage  to (list): A list of receiver agents  contents (list): The content of the message. A list of any GAML type  performative (string): A string, representing the message performative  protocol (string): A string representing the name of interaction protocolstart_conversationStarts a conversation/interaction protocol.  returns: msi.gaml.extensions.fipa.FIPAMessage  to (list): A list of receiver agents  contents (list): The content of the message. A list of any GAML type  performative (string): A string, representing the message performative  protocol (string): A string representing the name of interaction protocolsubscribeReplies a message with a ‘subscribe’ performative message.  returns: unknown  message (24): The message to be replied  contents (list): The content of the replying messageGAMASQLVariablesActionsread  returns: void  params (map): Connection parameters  table (string): select string with question marks  filter (list): List of values that are used to replace question marksSqlObject  returns: msi.gama.database.geosql.GamaSqlConnection  params (map): Connection parameters  table (string): select string with question marks  filter (string): Filter for selecttestConnection  returns: bool  params (map): Connection parametersgridVariables  bands (list): Represents the values of the different bands of the cell (list of floating point value automatically set when the grid is initialized from a grid file)  color (rgb): Represents the color of the cell, used by default to represent the grid on displays  grid_value (float): Represents a floating point value (automatically set when the grid is initialized from a grid file, and used by default to represent the elevation of the cell when displaying it on a display)  grid_x (int): Returns the 0-based index of the column of the cell in the grid  grid_y (int): Returns the 0-based index of the row of the cell in the grid  neighbors (list): Represents the neighbor at distance 1 of the cellActionsMDXSKILLVariablesActionsselect  returns: list  params (map): Connection parameters  onColumns (string): select string with question marks  onRows (list): List of values that are used to replace question marks  from (list): List of values that are used to replace question marks  where (list): List of values that are used to replace question marks  values (list): List of values that are used to replace question markstestConnection  returns: bool  params (map): Connection parameterstimeStamp  returns: floatmessagingA simple skill that provides agents with a mailbox than can be filled with messagesVariables  mailbox (list): The list of messages that can be consulted by the agentActionssend  returns: msi.gama.extensions.messaging.GamaMessage  to (any type): The agent, or server, to which this message will be sent to  contents (any type): The contents of the message, an arbitrary objectmovingThe moving skill is intended to define the minimal set of behaviours required for agents that are able to move on different topologiesVariables  current_edge (geometry): Represents the agent/geometry on which the agent is located (only used with a graph)  current_path (path): Represents the path on which the agent is moving on (goto action on a graph)  destination (point): Represents the next location of the agent if it keeps its current speed and heading (read-only)  heading (int): Represents the absolute heading of the agent in degrees.  location (point): Represents the current position of the agent  real_speed (float): Represents the actual speed of the agent (in meter/second)  speed (float): Represents the speed of the agent (in meter/second)Actionsfollowmoves the agent along a given path passed in the arguments.  returns: path  speed (float): the speed to use for this move (replaces the current value of speed)  path (path): a path to be followed.  move_weights (map): Weights used for the moving.  return_path (boolean): if true, return the path followed (by default: false)gotomoves the agent towards the target passed in the arguments.  returns: path  target (geometry): the location or entity towards which to move.  speed (float): the speed to use for this move (replaces the current value of speed)  on (any type): graph, topology, list of geometries that restrain this move  recompute_path (boolean): if false, the path is not recompute even if the graph is modified (by default: true)  return_path (boolean): if true, return the path followed (by default: false)  move_weights (map): Weights used for the moving.movemoves the agent forward, the distance being computed with respect to its speed and heading. The value of the corresponding variables are used unless arguments are passed.  returns: path  speed (float): the speed to use for this move (replaces the current value of speed)  heading (int): the angle (in degree) of the target direction.  bounds (geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometrywanderMoves the agent towards a random location at the maximum distance (with respect to its speed). The heading of the agent is chosen randomly if no amplitude is specified. This action changes the value of heading.  returns: void  speed (float): the speed to use for this move (replaces the current value of speed)  amplitude (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2)  bounds (geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry)  on (graph): the graph that restrains this move (the agent moves on the graph  proba_edges (map): When the agent moves on a graph, the probability to choose another edge. If not defined, each edge has the same probability to be chosenmoving3DThe moving skill 3D is intended to define the minimal set of behaviours required for agents that are able to move on different topologiesVariables  destination (point): continuously updated destination of the agent with respect to its speed and heading (read-only)  heading (int): the absolute heading of the agent in degrees (in the range 0-359)  pitch (int): the absolute pitch of the agent in degrees (in the range 0-359)  roll (int): the absolute roll of the agent in degrees (in the range 0-359)  speed (float): the speed of the agent (in meter/second)Actionsmovemoves the agent forward, the distance being computed with respect to its speed and heading. The value of the corresponding variables are used unless arguments are passed.  returns: path  speed (float): the speed to use for this move (replaces the current value of speed)  heading (int): int, optional, the direction to take for this move (replaces the current value of heading)  pitch (int): int, optional, the direction to take for this move (replaces the current value of pitch)  heading (int): int, optional, the direction to take for this move (replaces the current value of roll)  bounds (geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometrynetworkVariables  network_groups (list): Net ID of the agent  network_name (string): Net ID of the agent  network_server (list): Net ID of the agentActionsconnect  returns: void  protocol (string): protocol type (udp, tcp, mqqt)  port (int): port number  with_name (string): server nameL  login (string): server nameL  password (string): server nameL  to (string): server URLexecute  returns: string  command (string): command to executefetch_message  returns: msi.gama.extensions.messaging.GamaMessagehas_more_message  returns: boolleave_the_groupleave a group of agent  returns: void  with_name (string): name of the group agent want to leavephysicsVariables  collisionBound (map):  density (float):  mass (float):  motor (point):  space (agent):  velocity (list):Actionsskill_roadVariables  agents_on (list): for each lane of the road, the list of agents for each segment  all_agents (list): the list of agents on the road  lanes (int): the number of lanes  linked_road (-18): the linked road: the lanes of this linked road will be usable by drivers on the road  maxspeed (float): the maximal speed on the road  source_node (agent): the source node of the road  target_node (agent): the target node of the roadActionsregisterregister the agent on the road at the given lane  returns: void  agent (agent): the agent to register on the road.  lane (int): the lane index on which to register; if lane index &gt;= number of lanes, then register on the linked roadunregisterunregister the agent on the road  returns: void  agent (agent): the agent to unregister on the road.skill_road_nodeVariables  block (map): define the list of agents blocking the node, and for each agent, the list of concerned roads  priority_roads (list): the list of priority roads  roads_in (list): the list of input roads  roads_out (list): the list of output roads  stop (list): define for each type of stop, the list of concerned roadsActionsSQLSKILLVariablesActionsexecuteUpdate  returns: int  params (map): Connection parameters  updateComm (string): SQL commands such as Create, Update, Delete, Drop with question mark  values (list): List of values that are used to replace question markgetCurrentDateTime  returns: string  dateFormat (string): date format examples: ‘yyyy-MM-dd’ , ‘yyyy-MM-dd HH:mm:ss’getDateOffset  returns: string  dateFormat (string): date format examples: ‘yyyy-MM-dd’ , ‘yyyy-MM-dd HH:mm:ss’  dateStr (string): Start date  offset (string): number on day to increase or decreaseinsert  returns: int  params (map): Connection parameters  into (string): Table name  columns (list): List of column name of table  values (list): List of values that are used to insert into table. Columns and values must have same sizelist2Matrix  returns: matrix  param (list): Param: a list of records and metadata  getName (boolean): getType: a boolean value, optional parameter  getType (boolean): getType: a boolean value, optional parameterselect  returns: container  params (map): Connection parameters  select (string): select string with question marks  values (list): List of values that are used to replace question markstestConnection  returns: bool  params (map): Connection parameterstimeStamp  returns: float",
        "url":"/wiki/BuiltInSkills.html"
      }
      ,
    
      "wiki-builtinspecies-html": {
        "title": "Built-in Species",
        "content": "Built-in SpeciesThis file is automatically generated from java files. Do Not Edit It.It is possible to use in the models a set of built-in agents. These agents allow to directly use some advance features like clustering, multi-criteria analysis, etc. The creation of these agents are similar as for other kinds of agents:create species: my_built_in_agent returns: the_agent;So, for instance, to be able to use clustering techniques in the model:create cluster_builder returns: clusterer;Table of Contentsagent, AgentDB, base_edge, experiment, graph_edge, graph_node, model, physical_world,agentActions_init_  returns: unknown_step_  returns: unknownAgentDBActionsclose  returns: unknownconnect      returns: unknown        → params (map): Connection parameters  executeUpdate      returns: int    → updateComm (string): SQL commands such as Create, Update, Delete, Drop with question mark  → values (list): List of values that are used to replace question markgetParameter  returns: unknowninsert      returns: int    → into (string): Table name  → columns (list): List of column name of table  → values (list): List of values that are used to insert into table. Columns and values must have same sizeisConnected  returns: boolselect      returns: container    → select (string): select string  → values (list): List of values that are used to replace question markssetParameter      returns: unknown        → params (map): Connection parameters  testConnection      returns: bool        → params (map): Connection parameters  timeStamp  returns: floatbase_edgeActionsexperimentActionsupdate_outputsForces all outputs to refresh, optionally recomputing their values      returns: unknown        → recompute (boolean): Whether or not to force the outputs to make a computation step  graph_edgeActionsgraph_nodeActionsrelated_to      returns: bool        → other (agent):  modelActionshaltAllows to stop the current simulation so that cannot be continued after. All the behaviors and updates are stopped.  returns: unknownpauseAllows to pause the current simulation ACTUALLY EXPERIMENT FOR THE MOMENT. It can be set to continue with the manual intervention of the user.  returns: unknownphysical_worldActionscompute_forces  returns: unknown",
        "url":"/wiki/BuiltInSpecies.html"
      }
      ,
    
      "wiki-callingr-html": {
        "title": "Calling R",
        "content": "Calling RIntroductionR language is one of powerful data mining tools, and its community is very large in the world (See the website: http://www.r-project.org/). Adding the R language into GAMA is our strong endeavors to accelerate many statistical, data mining tools into GAMA.RCaller 2.0 package (Website: http://code.google.com/p/rcaller/) is used for GAMA 1.6.1.Table of contents  Introduction          Configuration in GAMA      Calling R from GAML                  Calling the built-in operators                          Example 1                                Calling R codes from a text file (.txt) WITHOUT the parameters                          Example 2              Correlation.R file                                Output                          Example 3              RandomForest.R file                                            Load the package:  Read data from iris:  Build the decision tree:  Build the random forest of 50 decision trees:  Predict the acceptance of test set:  Calculate the accuracy:          * Output      * Calling R codes from a text file (.R, .txt) WITH the parameters          * Example 4          * Mean.R file      * Output          * Example 5          * AddParam.R file          * OutputConfiguration in GAMA1) Install R language into your computer.2) In GAMA, select menu option: Edit/Preferences.3) In “Config RScript’s path”, browse to your “Rscript” file (R language installed in your system).Notes: Ensure that install.packages(“Runiversal”) is already applied in R environment.Calling R from GAMLCalling the built-in operatorsExample 1model CallingRglobal {\tlist X &lt;- [2, 3, 1];\tlist Y &lt;- [2, 12, 4]; \tlist result;\t\tinit{\t\twrite corR(X, Y); // -&gt; 0.755928946018454\t\twrite meanR(X); // -&gt; 2.0\t}}Calling R codes from a text file (.R,.txt) WITHOUT the parametersUsing R_compute(String RFile) operator. This operator DOESN’T ALLOW to add any parameters form the GAML code. All inputs is directly added into the R codes.Remarks: Don’t let any white lines at the end of R codes. R_compute will return the last variable of R file, this parameter can be a basic type or a list.  Please ensure that the called packages must be installed before using.Example 2model CallingRglobal{\tlist result;\tinit{\t\tresult &lt;- R_compute(\"C:/YourPath/Correlation.R\");\t\twrite result at 0;\t}}Above syntax is deprecated, use following syntax with R_file instead of R_compute:model CallingRglobal{\tfile result;\tinit{\t\tresult &lt;- R_file(\"C:/YourPath/Correlation.R\");\t\twrite result.contents;\t}}Correlation.R filex &lt;- c(1, 2, 3)y &lt;- c(1, 2, 4)result &lt;- cor(x, y, method = \"pearson\")Outputresult::[0.981980506061966]Example 3model CallingRglobal{\tlist result;\tinit{\t\tresult &lt;- R_compute(\"C:/YourPath/RandomForest.R\");\t\twrite result at 0;\t}}RandomForest.R file# Load the package:library(randomForest)# Read data from iris:data(iris)nrow&lt;-length(iris[,1])ncol&lt;-length(iris[1,])idx&lt;-sample(nrow,replace=FALSE)trainrow&lt;-round(2*nrow/3)trainset&lt;-iris[idx[1:trainrow],]# Build the decision tree:trainset&lt;-iris[idx[1:trainrow],]testset&lt;-iris[idx[(trainrow+1):nrow],]# Build the random forest of 50 decision trees:model&lt;-randomForest(x= trainset[,-ncol], y= trainset[,ncol], mtry=3, ntree=50)# Predict the acceptance of test set: pred&lt;-predict(model, testset[,-ncol], type=\"class\")# Calculate the accuracy:acc&lt;-sum(pred==testset[, ncol])/(nrow-trainrow)Outputacc::[0.98]Calling R codes from a text file (.R, .txt) WITH the parametersUsing R_compute_param(String RFile, List vectorParam) operator. This operator ALLOWS to add the parameters from the GAML code.Remarks: Don’t let any white lines at the end of R codes. R_compute_param will return the last variable of R file, this parameter can be a basic type or a list. Please ensure that the called packages must be installed before using.Example 4model CallingRglobal{\tlist X &lt;- [2, 3, 1];\tlist result;\tinit{\t\tresult &lt;- R_compute_param(\"C:/YourPath/Mean.R\", X);\t\twrite result at 0;\t}}Mean.R fileresult &lt;- mean(vectorParam)Outputresult::[3.33333333333333]Example 5model CallingRglobal {\tlist X &lt;- [2, 3, 1];\tlist result;\t        init{\t\tresult &lt;- R_compute_param(\"C:/YourPath/AddParam.R\", X);\t\twrite result at 0;\t}}AddParam.R filev1 &lt;- vectorParam[1]v2&lt;-vectorParam[2]v3&lt;-vectorParam[3]result&lt;-v1+v2+v3Outputresult::[10]//: # (endConcept|call_r)",
        "url":"/wiki/CallingR.html"
      }
      ,
    
      "wiki-changingworkspace-html": {
        "title": "Changing Workspace",
        "content": "Changing WorkspaceIt is possible, and actually common, to store different projects/models in different workspaces and to tell GAMA to switch between these workspaces. Doing so involves being able to create one or several new workspace locations (even if GAMA has been told to remember the current one) and being able to easily switch between them.Table of contents  Changing Workspace          Switching to another Workspace      Cloning the Current Workspace      Switching to another WorkspaceThis process is similar to the choice of the workspace location when GAMA is launched for the first time. The only preliminary step is to invoke the appropriate command (“Switch Workspace”) from the “File” menu.In the dialog that appears, the current workspace location should already be entered. Changing it to a new location (or choosing one in the file selector invoked by clicking on “Browse…”) and pressing “OK” will then either create a new workspace if none existed at that location or switch to this new workspace. Both operations will restart GAMA and set the new workspace location. To come back to the previous location, just repeat this step (the previous location is normally now accessible from the combo box).Cloning the Current WorkspaceAnother possibility, if you have models in your current workspace that you would like to keep in the new one (and that you do not want to import one by one after switching workspace), or if you change workspace because you suspect the current one is corrupted, or outdated, etc. but you still want to keep your models, is to clone the current workspace into a new (or existing) one.Please note that cloning (as its name implies) is an operation that will make a copy of the files into a new workspace. So, if projects are stored in the current workspace, this will result in two different instances of the same projets/models with the same name in the two workspaces. However, for projects that are simply linked from the current workspace, only the link will be copied (which allows to have different workspaces “containing” the same project)This can be done by entering the new workspace location and choosing “Clone current workspace” in the previous dialog instead of “Ok”.If the new location does not exist, GAMA will ask you to confirm the creation and cloning using a specific dialog box. Dismissing it will cancel the operation.If the new location is already the location of an existing workspace, another confirmation dialog is produced. It is important to note that all projects in the target workspace will be erased and replaced by the projects in the current workspace if you proceed. Dismissing it will cancel the operation.There are two cases where cloning is not accepted. The first one is when the user tries to clone the current workspace into itself (i.e. the new location is the same as the current location).The second case is when the user tries to clone the current workspace into one of its subdirectories (which is not feasible).",
        "url":"/wiki/ChangingWorkspace.html"
      }
      ,
    
      "wiki-charts-ant-foraging-charts-examples-html": {
        "title": "Ant Foraging (Charts examples)",
        "content": "Ant Foraging (Charts examples)_Author : _Toy Model ant using the question of how ants search food and use pheromons to return to their nest once they did find food. In this model, the charts are particularly used.Code of the model :model antsglobal {\t//Number of ants\tint ants_number &lt;- 100 min: 1 max: 2000 ;\t//Evaporation value per cycle for the pheromons\tfloat evaporation_per_cycle &lt;- 5.0 min: 0.0 max: 240.0 ;\t//Diffusion rate for the pheromons\tfloat diffusion_rate &lt;- 1.0 min: 0.0 max: 1.0 ;\tbool use_icons &lt;- true ;\tbool display_state &lt;- true;\t//Size of the grid\tint gridsize &lt;- 75 ;\t//Center of the grid to put the location of the nest\tpoint center const: true &lt;- { (gridsize / 2),  (gridsize / 2)} ;\tfile types const: true &lt;- (pgm_file('../images/environment75x75.pgm')) ;\tstring ant_shape_empty const: true &lt;- '../icons/ant.png' ;\tstring ant_shape_full const: true &lt;- '../icons/full_ant.png'  ;\trgb C00CC00 const: true &lt;- rgb('#00CC00') ;    \trgb C009900 const: true &lt;- rgb('#009900') ; \trgb C005500 const: true &lt;- rgb('#005500') ; \tint food_gathered &lt;- 0 ;   \tgeometry shape &lt;- square(gridsize);\tinit{  \t\t//Ant are placed randomly in the nest\t\tcreate ant number: ants_number with: [location::any_location_in (ant_grid(center))] ;\t}\t\t//Reflex to diffuse the road of pheromon on the grid\treflex diffuse {      diffuse var:road on:ant_grid proportion: diffusion_rate radius:2 propagation: gradient;   }}//Grid to discretize space for the food and the nestgrid ant_grid width: gridsize height: gridsize neighbors: 8 use_regular_agents: false {\tbool multiagent &lt;- true ;\tfloat road &lt;- 0.0 max:240.0 update: (road&lt;=evaporation_per_cycle) ? 0.0 : road-evaporation_per_cycle;\tint type &lt;- int(types at {grid_x,grid_y}) ;\tbool isNestLocation &lt;- (self distance_to center) &lt; 4 ; \tbool isFoodLocation &lt;- type = 2 ; \trgb color &lt;- isNestLocation ? °violet:((food &gt; 0)? °blue : ((road &lt; 0.001)? rgb ([100,100,100]) : ((road &gt; 2)? °white : ((road &gt; 0.5)? (C00CC00) : ((road &gt; 0.2)? (C009900) : (C005500)))))) update: isNestLocation ? °violet:((food &gt; 0)? °blue : ((road &lt; 0.001)? rgb ([100,100,100]) : ((road &gt; 2)? °white : ((road &gt; 0.5)? (C00CC00) : ((road &gt; 0.2)? (C009900) : (C005500)))))) ;\tint food &lt;- isFoodLocation ? 5 : 0 ;\tint nest const: true &lt;- 300 - int(self distance_to center) ;\t}//Species ant that will move and follow a final state machinespecies ant skills: [moving] control: fsm {\tfloat speed &lt;- 2.0 ;\tant_grid place update: ant_grid (location ); \tstring im &lt;- 'ant_shape_empty' ;\tbool hasFood &lt;- false ;\treflex diffuse_road when:hasFood=true{      ant_grid(location).road &lt;- ant_grid(location).road + 100.0;   }   //Action to pick food\taction pick {\t\tim &lt;- ant_shape_full ;\t\thasFood &lt;- true ;\t\tplace.food &lt;- place.food - 1 ;\t}\t//Action to drop food\taction drop {\t\tfood_gathered &lt;- food_gathered + 1 ;\t\thasFood &lt;- false ;\t\theading &lt;- heading - 180 ;\t}\t//Action to chose the best place according to the possible food in the neighbour cells\taction choose_best_place type: ant_grid {\t\tlist&lt;ant_grid&gt; list_places &lt;- place.neighbors ;\t\tif (list_places count (each.food &gt; 0)) &gt; 0  {\t\t\treturn (list_places first_with (each.food &gt; 0)) ;\t\t} else {\t\t\t\tint min_nest  &lt;-  (list_places min_of (each.nest)) ;\t\t\t\tlist_places &lt;- list_places sort ((each.nest = min_nest) ? each.road :  0.0) ;\t\t\t\treturn last(list_places) ;\t\t\t}\t}\t\t//Initial state of the ant : wander until it finds food or find a road to follow\tstate wandering initial: true {\t\tdo wander amplitude:120 ;\t\ttransition to: carryingFood when: place.food &gt; 0 {\t\t\tdo pick ;\t\t}\t\ttransition to: followingRoad when: place.road &gt; 0.05 ;\t}\t//State to carry food to the nest once the food is found\tstate carryingFood {\t\tdo goto target: center ;\t\ttransition to: wandering when: place.isNestLocation { \t\t\tdo drop ;\t\t}\t}\t//State to follow a road \tstate followingRoad {\t\tlocation &lt;- (self choose_best_place []) as point ;\t\ttransition to: carryingFood when: place.food &gt; 0 {\t\t\tdo pick ;\t\t}\t\ttransition to: wandering when: (place.road &lt; 0.05) ;\t}\taspect text {\t\tif use_icons {\t\t\tdraw  hasFood ? file(ant_shape_full) : file(ant_shape_empty) rotate: heading at: location size: {7,5} ;\t\t} else {\t\t\tdraw circle(1.0) empty: !hasFood color: rgb ('orange') ;\t\t}\t\tif display_state {\t\t\tdraw state at: location + {-3,1.5} color: °white size: 0.8 ;\t\t}\t}\taspect default {\t\tdraw circle(1.0) empty: !hasFood color: #orange ; \t}}experiment Ant type: gui {\t//Parameters to play with  in the gui\tparameter 'Number of ants:' var: ants_number category: 'Model' ;\tparameter 'Evaporation of the signal (unit/cycle):' var: evaporation_per_cycle category: 'Model' ;\tparameter 'Rate of diffusion of the signal (%/cycle):' var: diffusion_rate category: 'Model' ;\tparameter 'Use icons for the agents:' var: use_icons category: 'Display' ;\tparameter 'Display state of agents:' var: display_state category: 'Display' ;\tlist&lt;list&lt;int&gt;&gt; nbants&lt;-[[0]];\tlist&lt;string&gt; statesnames&lt;-[\"wandering\"];\tlist&lt;string&gt; categnames&lt;-[\"empty\",\"carry\"];\tlist&lt;list&lt;int&gt;&gt; nbantsbydist&lt;-[[0]];\tlist xytestvallist&lt;-[[[1,1],[2,2],[3,3]],[[1,2],[2,1],[3,4]],[[1,3],[2,3],[0,1]],[[1,4],[2,5],[0,0]]];\tlist&lt;list&lt;int&gt;&gt; xyval&lt;-[[1,1],[2,1],[3,2]];\t//Reflex to update the charts, belonging to the experiment bloc as it will not be used by other experiment which don't have the charts\treflex update_charts\t{\t\tnbants&lt;-list&lt;list&lt;int&gt;&gt;([]);\t\tstatesnames&lt;-list&lt;string&gt;([]);\t\tcategnames&lt;-[\"empty\",\"carry\"];\t\tnbantsbydist&lt;-list&lt;list&lt;int&gt;&gt;([]);\t\tant x&lt;-one_of(world.ant);\t\tloop x over:list(world.ant)\t\t{\t\t\tif !(statesnames contains (x.state))\t\t\t{\t\t\t\t\t\t\tadd [(list(ant) count (each.state=x.state and !each.hasFood)),(list(ant) count (each.state=x.state and each.hasFood))] to: nbants;\t\t\tadd (x.state) to:statesnames;\t\t\t\t\t\t\tint d&lt;-0;\t\t\tlist&lt;int&gt; nl&lt;-list&lt;int&gt;([]);\t\t\tloop d from:0 to:9\t\t\t\t{\t\t\tadd (list(ant) count (each.state=x.state and (((each distance_to center)&gt;gridsize/20*d) and ((each distance_to center)&lt;gridsize/20*(d+1))))) to: nl;\t\t\t\t}\t\t\tadd nl to:nbantsbydist;\t\t\t}//\t\t\tadd length((list(world.ant) collect (each.next_place distance_to each.location)) where (each=x)) to:nbants;\t\t}\t\t//write(\"nbants\"+nbants);\t\t//write(\"nbantsbydist\"+nbantsbydist);\t\t//write(\"states\"+statesnames);\t\t\t}\t\t//The different displays\toutput {\t\tdisplay Ants type: opengl {\t\t\tgrid ant_grid ;\t\t\tspecies ant aspect: text ;\t\t}\t\tdisplay ProportionCarryFood {\t\t\tchart \"Proportions carrying: Pie\"  size: {0.5,0.5} position: {0, 0} type:pie\t\t\t{\t\t\t\tdata \"empty_ants\" value:(list(ant) count (!each.hasFood)) color:°red;\t\t\t\tdata \"carry_food_ants\" value:(list(ant) count (each.hasFood)) color:°green;\t\t\t\t\t\t\t}\t\t\t\t\t\tchart \"Proportions carrying: Radar\"  size: {0.5,0.5} position: {0.5, 0} type:radar\t\t\taxes:#white\t\t\t{\t\t\t\tdata \"empty\" value:(list(ant) count (!each.hasFood)) \t\t\t\taccumulate_values:true\t\t\t\tcolor:°red;\t\t\t\t\t\t\t\tdata \"carry\" value:(list(ant) count (each.hasFood)) \t\t\t\taccumulate_values:true\t\t\t\tcolor:°blue;\t\t\t\t\t\t\t}\t\t\t\t\t\tchart \"Proportion: serie\"   size: {1.0,0.5} position: {0, 0.5} type:series \t\t\tseries_label_position: legend\t\t\tstyle:stack\t\t\t{\t\t\t\tdatalist [\"empty\",\"carry\"] accumulate_values:true \t\t\t\tvalue:[(list(ant) count (!each.hasFood)),(list(ant) count (each.hasFood))] \t\t\t\tcolor:[°red,°green];\t\t\t\t\t\t\t}\t\t}// idem with stacked bar:/* \t\tdisplay ProportionByState {\t\t\tchart \"DataListListBar\" type:histogram \t\t\tx_serie_labels: categnames \t\t\tseries_label_position: legend\t\t\t{\t\t\t\tdatalist value:nbants legend:statesnames style:stack;\t\t\t}\t\t\t\t\t}*/\t\t\t// Idem with datalist://\t\tdisplay PositionByState {//\t\t\tchart \"Position by state (datalist)\" type:scatter//\t\t\t{//\t\t\t\tdatalist [\"empty\",\"carry\"] value:[((list(ant) where (!each.hasFood))  collect each.location),((list(ant) where (each.hasFood))  collect each.location)] color:[°red,°green] line_visible:false;\t\t\t\t//\t\t\t}//\t\t}\t\tdisplay CentroidPosition {\t\t\tchart \"Positions and History of Centroide and size by Carry state\" type:scatter\t\t\t{\t\t\t\tdatalist [\"avg-carry\",\"avg-empty\"] value:[mean((list(ant) where (each.hasFood)) collect each.location),\t\t\t\t\tmean((list(ant) where (!each.hasFood)) collect each.location)\t\t\t\t]\t\t\t\tmarker_size: [length(list(ant) where (each.hasFood))/20,length(list(ant) where (!each.hasFood))/20]\t\t\t\t\t color:[°red,°green] \t\t\t\t\t fill:false\t\t\t\t\t line_visible:true;\t\t\t\t\t\t\t\tdata \"empty_ants\" value:((list(ant) where (!each.hasFood)) collect each.location) color:°red \t\t\t\taccumulate_values:false\t\t\t\tline_visible:false;\t\t\t\tdata \"carry_food_ants\" value:((list(ant) where (each.hasFood)) collect each.location) \t\t\t\taccumulate_values:false\t\t\t\tcolor:°green line_visible:false;\t\t\t}\t\t}\t\t\tdisplay Distribution2dPosition {\t\t\tchart \"Distribution of the X positions\"   size: {0.65,0.3} position: {0.05, 0} type:histogram\t\t\t\t\t\t{\t\t\t\tdatalist (distribution_of(list(ant) collect each.location.x,10,0,100) at \"legend\") \t\t\t\t\tvalue:(distribution_of(list(ant) collect each.location.x,10,0,100) at \"values\");\t\t\t}\t\t\tchart \"Distribution of the Y positions\"   size: {0.3,0.7} position: {0.7, 0.28} type:histogram\t\t\treverse_axes:true\t\t\t\t\t\t{\t\t\t\tdatalist reverse(distribution_of(list(ant) collect each.location.x,10,0,100) at \"legend\") \t\t\t\t\tvalue:reverse(distribution_of(list(ant) collect each.location.x,10,0,100) at \"values\");\t\t\t}\t\t\tchart \"Distribution2d of the XvsY positions- heatmap\"   size: {0.7,0.7} position: {0, 0.3} type:heatmap\t\t\tx_serie_labels: (distribution2d_of(list(ant) collect each.location.x,list(ant) collect each.location.y,10,0,100,10,0,100) at \"legendx\")\t\t\ty_serie_labels: (distribution2d_of(list(ant) collect each.location.x,list(ant) collect each.location.y,10,0,100,10,0,100) at \"legendy\")\t\t\tseries_label_position:none\t\t\t{\t\t\t\tdata  \"XYdistrib\"\t\t\t\t\tvalue:(distribution2d_of(list(ant) collect each.location.x,list(ant) collect each.location.y,10,0,100,10,0,100) at \"values\")\t\t\t\t\tcolor:[#red];\t\t\t}\t\t}\t\t\t\tdisplay DistributionPosition {\t\t\tchart \"Distribution of the X positions\"   size: {0.92,0.3} position: {0, 0} type:histogram\t\t\t\t\t\t{\t\t\t\tdatalist (distribution_of(list(ant) collect each.location.x,10,0,100) at \"legend\") \t\t\t\t\tvalue:(distribution_of(list(ant) collect each.location.x,10,0,100) at \"values\");\t\t\t}\t\t\tchart \"Distribution of the X positions- heatmap\"   size: {1.0,0.7} position: {0, 0.3} type:heatmap\t\t\tx_serie_labels: (distribution_of(list(ant) collect each.location.x,10,0,100) at \"legend\")\t\t\ty_range:50\t\t\t{\t\t\t\tdata  \"Xdistrib\"\t\t\t\t\tvalue:(distribution_of(list(ant) collect each.location.x,10,0,100) at \"values\")\t\t\t\t\tcolor:[#red];\t\t\t}\t\t}\t\t\t}\t\t}\t//Experiment with only two display : the grid and the ants, and a chartexperiment AntOneDisp type: gui {\tparameter 'Number of ants:' var: ants_number category: 'Model' ;\tparameter 'Evaporation of the signal unit/cycle):' var: evaporation_per_cycle category: 'Model' ;\tparameter 'Rate of diffusion of the signal (%/cycle):' var: diffusion_rate category: 'Model' ;\tparameter 'Use icons for the agents:' var: use_icons category: 'Display' ;\tparameter 'Display state of agents:' var: display_state category: 'Display' ;\tlist&lt;list&lt;int&gt;&gt; nbants&lt;-[[0]];\tlist&lt;string&gt; statesnames&lt;-[\"\"];\tlist&lt;string&gt; categnames&lt;-[\"empty\",\"carry\"];\tlist&lt;list&lt;int&gt;&gt; nbantsbydist&lt;-[[0]];\tlist xytestvallist&lt;-[[[1,1],[2,2],[3,3]],[[1,2],[2,1],[3,4]],[[1,3],[2,3],[0,1]],[[1,4],[2,5],[0,0]]];\tlist&lt;list&lt;int&gt;&gt; xyval&lt;-[[1,1],[2,1],[3,2]];\treflex update_charts\t{\t\tant x&lt;-one_of(world.ant);\t\tnbants&lt;-list&lt;list&lt;int&gt;&gt;([]);\t\tstatesnames&lt;-list&lt;string&gt;([]);\t\tloop x over:list(world.ant)\t\t{\t\t\tif !(statesnames contains (x.state))\t\t\t{\t\t\t\t\t\t\tadd [(list(ant) count (each.state=x.state and !each.hasFood)),(list(ant) count (each.state=x.state and each.hasFood))] to: nbants;\t\t\tadd (x.state) to:statesnames;\t\t\t\t\t\t\tint d&lt;-0;\t\t\tlist&lt;int&gt; nl&lt;-list&lt;int&gt;([]);\t\t\tloop d from:0 to:9\t\t\t\t{\t\t\tadd (list(ant) count (each.state=x.state and (((each distance_to center)&gt;gridsize/20*d) and ((each distance_to center)&lt;gridsize/20*(d+1))))) to: nl;\t\t\t\t}\t\t\tadd nl to:nbantsbydist;\t\t\t}\t\t}\t\twrite(\"nbants\"+nbants);\t\twrite(\"nbantsbydist\"+nbantsbydist);\t\twrite(\"states\"+statesnames);\t\t\t}\toutput {\t\tdisplay Ants type: opengl {\t\t\tgrid ant_grid ;\t\t\tspecies ant aspect: text ;\t\t}\t\tdisplay ChartScatter {\t\t\tchart \"Distribution2d of the XvsY positions- heatmap\"   size: {0.7,0.7} position: {0, 0.3} type:heatmap\t\t\tx_serie_labels: (distribution2d_of(list(ant) collect each.location.x,list(ant) collect each.location.y,10,0,100,10,0,100) at \"legendx\")\t\t\ty_serie_labels: (distribution2d_of(list(ant) collect each.location.x,list(ant) collect each.location.y,10,0,100,10,0,100) at \"legendy\")\t\t\tseries_label_position:none\t\t\t{\t\t\t\tdata  \"XYdistrib\"\t\t\t\t\tvalue:(distribution2d_of(list(ant) collect each.location.x,list(ant) collect each.location.y,10,0,100,10,0,100) at \"values\")\t\t\t\t\tcolor:[#red];\t\t\t}\t\t\t\t\t\t}\t}}",
        "url":"/wiki/Charts-Ant-Foraging-(Charts-examples).html"
      }
      ,
    
      "wiki-charts-html": {
        "title": "Charts",
        "content": "ChartsThis sub-section is composed of the following models :  Ant Foraging (Charts examples)",
        "url":"/wiki/Charts.html"
      }
      ,
    
      "wiki-circle-circle-html": {
        "title": "Circle",
        "content": "Circle_Author : _This model shows the movement of cells trying to do a circle shape with themselves considering the other cells. The second experiment shows a bigger circle using more cell agents.Code of the model :model circle_modelglobal { \t//Number of agents to create\tint number_of_agents min: 1 &lt;- 50 ;\t//Radius of the circle that the cells will make\tint radius_of_circle min: 10 &lt;- 1000 ;\t//Repulsion strength of one cell to the others\tint repulsion_strength min: 1 &lt;- 5 ;\t//Size of the environment\tint width_and_height_of_environment min: 10 &lt;- 3000 ; \t//Range of the agents\tint range_of_agents min: 1 &lt;- 25 ;\t//Speed of the agents\tfloat speed_of_agents min: 0.1  &lt;- 2.0 ; \t//Size of the agents\tint size_of_agents &lt;- 100;\t//Center of the considered circle created by the cells\tpoint center const: true &lt;- {width_and_height_of_environment/2,width_and_height_of_environment/2};\tgeometry shape &lt;- square(width_and_height_of_environment);\tinit { \t\t//Creation of the cell agents\t\tcreate cell number: number_of_agents;\t}  }    //Species cell which represents the cell agents, using the skill movingspecies cell skills: [moving] {  \t//Color of the cell, randomly chosen\trgb color const: true &lt;- [100 + rnd (155),100 + rnd (155), 100 + rnd (155)] as rgb;\t//Size of the cell\tfloat size const: true &lt;- float(size_of_agents);\t//Range of the cell\tfloat range const: true &lt;- float(range_of_agents); \t//Speed of the cell\tfloat speed const: true &lt;- speed_of_agents;   \t//Heading of the cell, the direction it 'watches'\tint heading &lt;- rnd(359);\t\t//Reflex to make the cell agent fo to the center, calling the derivated action move\treflex go_to_center {\t\theading &lt;- (((self distance_to center) &gt; radius_of_circle) ? self towards center : (self towards center) - 180);\t\tdo move speed: speed; \t}\t//Reflex to flee of the other cells agents, which will help to design the circle shape\treflex flee_others {\t\tcell close &lt;- one_of ( ( (self neighbors_at range) of_species cell) sort_by (self distance_to each) );\t\tif close != nil {\t\t\theading &lt;- (self towards close) - 180;\t\t\tfloat dist &lt;- self distance_to close;\t\t\tdo move speed: dist / repulsion_strength heading: heading;\t\t}\t}\t\taspect default { \t\tdraw circle(size)  color: color;\t}}experiment main type: gui {\tparameter 'Number of Agents' var: number_of_agents;\tparameter 'Radius of Circle' var: radius_of_circle; \tparameter 'Strength of Repulsion' var: repulsion_strength; \tparameter 'Dimensions' var: width_and_height_of_environment;\tparameter 'Range of Agents' var: range_of_agents;\tparameter 'Speed of Agents' var: speed_of_agents ; \t\toutput {\t\tdisplay Circle {\t\t\tspecies cell;\t\t}\t}}experiment main2 type: gui  {\tparameter \"Size of Agents\" var: size_of_agents &lt;- 100;\tparameter 'Number of Agents' var: number_of_agents &lt;- 300;\tparameter 'Radius of Circle' var: radius_of_circle min: 10 &lt;- 15000;\tparameter 'Strength of Repulsion' var: repulsion_strength min: 1 &lt;- 50;\tparameter 'Dimensions' var: width_and_height_of_environment  min: 10 &lt;- 40000;\tparameter 'Range of Agents' var: range_of_agents min: 1 &lt;- 250;\tparameter 'Speed of Agents' var: speed_of_agents min: 0.1 &lt;- 100.0 ;\toutput {\t\tdisplay Circle  {\t\t\tspecies cell;\t\t}\t}}",
        "url":"/wiki/Circle-Circle.html"
      }
      ,
    
      "wiki-circle-html": {
        "title": "Circle",
        "content": "CircleThis sub-section is composed of the following models :  Circle",
        "url":"/wiki/Circle.html"
      }
      ,
    
      "wiki-clock-clock-html": {
        "title": "Clock",
        "content": "Clock_Author : JD _Code of the model :model Clockglobal {\t//Background of the clock\tfile clock_normal     const: true &lt;- image_file(\"../images/clock.png\");\t//Image for the big hand \tfile clock_big_hand   const: true &lt;- image_file(\"../images/big_hand.png\");\t//Image for the small hand\tfile clock_small_hand const: true &lt;- image_file(\"../images/small_hand.png\");\t//Image for the clock alarm\tfile clock_alarm \t  const: true &lt;- image_file(\"../images/alarm_hand.png\");\t//Zoom to take in consideration the zoom in the display, to better write the cycle values\tint zoom &lt;- 4 min:1 max:100;\t//Time value for a cycle\tfloat step&lt;-360000.0#ms min: 1.0 max: 360000.0;\t\t//Alarm parameters\tint alarm_days &lt;- 0 min:0 max:365;\tint alarm_hours &lt;- 2 min:0 max:11;\tint alarm_minutes &lt;- 0 min:0 max:59;\tint alarm_seconds &lt;- 0 min:0 max:59;\tbool alarm_am &lt;- true;\tint alarmCycle &lt;-  int((alarm_seconds+alarm_minutes*60+alarm_hours*3600 + (alarm_am ? 0 : 3600*12) + alarm_days*3600*24) * 1000 / step);\t\t//Time elapsed since the beginning of the experiment\tint timeElapsed &lt;- 0 update:  int(cycle * step);\tstring reflexType &lt;-\"\";\tinit {\t\t//Creation of the clock\t\tcreate clock number: 1 {\t\t\tlocation &lt;- {world.shape.width/5,world.shape.height/5};\t\t}\t}}//Species that will represent the clockspecies  clock { \t\tfloat nb_minutes&lt;-0.0 update: ((timeElapsed mod 3600000#ms))/60000#ms; //Mod with 60 minutes or 1 hour, then divided by one minute value to get the number of minutes\t\tfloat nb_hours&lt;-0.0 update:((timeElapsed mod 43200000#ms))/3600000#ms;\t\treflex update {\t\t\twrite string(nb_hours)+\" : \"+nb_minutes;\t\t\tif (cycle = alarmCycle) \t\t\t{\t\t\t\t write \"Time to leave\" ; \t\t\t\t // Uncomment the following statement to play the Alarm.mp3\t\t\t\t // But firstly, you need to go to \"Help -&gt; Install New Software...\" to install the \"Audio\" feature (which is still in the experimental stage). \t\t\t\t//start_sound source:\"../includes/Alarm.mp3\" ;\t\t\t}\t\t}\t\taspect default {\t\t\tdraw string(\"#cycles: \" + cycle + \" cycles\")  size:zoom/2 font:\"times\" color:°black at:{world.shape.width/3,0};\t\t\tdraw clock_big_hand rotate: nb_minutes*(360/60)  + 90  size: {7 * zoom, 2}; //Modulo with the representation of a minute in ms and divided by 10000 to get the degree of rotation\t\t\tdraw clock_small_hand rotate: nb_hours*(360/12)  + 90  size:{5*zoom, 2} ;\t\t\t\t\t\tdraw clock_alarm rotate:      (alarmCycle/12000)  size: zoom/3 ; // Alarm time\t\t} }experiment Display type: gui {\tfloat minimum_cycle_duration &lt;- 0.1#s;\tparameter 'Zoom: ' var: zoom category: 'Init' ;\tparameter 'Milliseconds/cycle' var: step category: 'Init';\tparameter 'alarm Day' var: alarm_days;\tparameter 'alarm Hour' var: alarm_hours;\tparameter 'alarm Am' var: alarm_am;\tparameter 'alarm Minutes' var: alarm_minutes;\tparameter 'alarm Seconds' var: alarm_seconds;\toutput {\t\tdisplay ClockView type: opengl { \t\t\tgraphics \"c\" refresh: false {draw clock_normal size: 10*zoom at:{world.shape.width/5,world.shape.height/5} ;}\t\t\tspecies clock ;\t\t}\t}}",
        "url":"/wiki/Clock-Clock.html"
      }
      ,
    
      "wiki-clock-html": {
        "title": "Clock",
        "content": "ClockThis sub-section is composed of the following models :  Clock",
        "url":"/wiki/Clock.html"
      }
      ,
    
      "wiki-clustering-clustering-html": {
        "title": "Clustering of agents by K Means and DBScan",
        "content": "Clustering of agents by K Means and DBScanAuthor :  Patrick TaillandierA model to show how to use clustering operators and two methods of clustering (K Means and DBScan) with the goal of regrouping agents in clustersCode of the model :model clusteringglobal {\t//the number of groups to create (kmeans)\tint k &lt;- 4;\t\t//the maximum radius of the neighborhood (DBscan)\tfloat eps &lt;- 10.0; \t\t//the minimum number of elements needed for a cluster (DBscan)\tint minPoints &lt;- 3;\t\tinit {\t\t//create dummy agents\t\tcreate dummy number: 100;\t}\t\treflex cluster_building {\t\t//create a list of list containing for each dummy agent a list composed of its x and y values\t\tlist&lt;list&gt; instances &lt;- dummy collect ([each.location.x, each.location.y]);\t\t\t\t//from the previous list, create groups with the eps and minPoints parameters and the DBSCAN algorithm (https://en.wikipedia.org/wiki/DBSCAN)\t\tlist&lt;list&lt;int&gt;&gt; clusters_dbscan &lt;- list&lt;list&lt;int&gt;&gt;(dbscan(instances, eps,minPoints));\t\t\t\t//We give a random color to each group (i.e. to each dummy agents of the group)       loop cluster over: clusters_dbscan {\t\t\trgb col &lt;- rnd_color(255);\t\t\tloop i over: cluster {\t\t\t\task dummy[i] {color_dbscan &lt;- col;}\t\t\t}\t\t}\t\t\t\t//from the previous list, create k groups  with the Kmeans algorithm (https://en.wikipedia.org/wiki/K-means_clustering)\t\tlist&lt;list&lt;int&gt;&gt; clusters_kmeans &lt;- list&lt;list&lt;int&gt;&gt;(kmeans(instances, k));\t\t\t\t//We give a random color to each group (i.e. to each dummy agents of the group)\t\tloop cluster over: clusters_kmeans {\t\t\trgb col &lt;- rnd_color(255);\t\t\tloop i over: cluster {\t\t\t\task dummy[i] {color_kmeans &lt;- col;}\t\t\t}\t\t}\t}\t}species dummy {\trgb color_dbscan &lt;- #grey;\trgb color_kmeans &lt;- #grey;\taspect dbscan_aspect {\t\tdraw circle(2) color: color_dbscan;\t}\taspect kmeans_aspect {\t\tdraw circle(2) color: color_kmeans;\t}}experiment clustering type: gui {\tparameter \"Number of clusters to split the data into\" var: k category: \"KMEANS\";\tparameter \"Maximum radius of the neighborhood to be considered\" var: eps category: \"DBSCAN\";\tparameter \"Minimum number of points needed for a cluster \" var: minPoints category: \"DBSCAN\";\toutput {\t\tdisplay map_dbscan{\t\t\tspecies dummy aspect: dbscan_aspect;\t\t}\t\tdisplay map_kmeans{\t\t\tspecies dummy aspect: kmeans_aspect;\t\t}\t}}",
        "url":"/wiki/Clustering-Clustering.html"
      }
      ,
    
      "wiki-clustering-spatial-clustering-html": {
        "title": "Clustering of agents by their distance",
        "content": "Clustering of agents by their distanceAuthor :  Patrick TaillandierA model to show how to use clustering operators with simple_clustering_by_distance to take into account the distances between agents or between cells to create the clusters,  and showing the relations between the people from the same cluster.Code of the model :model clusteringglobal {\t//define the maximal distance between people in the continuous environement (in meters): if the distance between 2 people is lower than this value, they will be in the same group\tfloat max_dist_people &lt;- 20.0;\t\t//define the maximal distance between cells (in number of cells): if the distance between 2 cells is lower than this value, they will be in the same group\tint max_dist_cell &lt;- 1;\t\t//probability for a cell to have vegetation\tfloat proba_vegetation &lt;- 0.2;\t\t//create the people agents\tinit {\t\tcreate people number:20;     }        //reflex that builds the people clusters    reflex people_clustering {    \t//clustering by using the simple clustering operator: two people agents are in the same groups if their distance is lower than max_dist_people (in meters)    \t//returns a list of lists (i.e. a list of groups, a group is a list of people agents)    \tlist&lt;list&lt;people&gt;&gt; clusters &lt;- list&lt;list&lt;people&gt;&gt;(simple_clustering_by_distance(people, max_dist_people));                //We give a random color to each group (i.e. to each people agents of the group)        loop cluster over: clusters {        \trgb rnd_color &lt;- rnd_color(255);        \task cluster {        \t\tcolor_cluster &lt;- rnd_color;        \t}        }                //build the hierchical clustering (https://en.wikipedia.org/wiki/Hierarchical_clustering)        list clustering_tree &lt;- hierarchical_clustering (people, max_dist_people);                //create groups from the results of the hierarchical clustering        do create_groups(clustering_tree, nil);    }        //recursive action that create group_people agents from the list of group.    action create_groups (list group, group_people parent_gp) {    \tbool compute_shape &lt;- false;    \tloop el over: group {    \t\tif (el is people) {    \t\t\tparent_gp.shape &lt;- people(el).shape;    \t\t}    \t\telse {    \t\t\tcreate group_people returns: created_g{    \t\t\t\tif (parent_gp != nil) {    \t\t\t\t\tadd self to: parent_gp.sub_groups;    \t\t\t\t}    \t\t\t\tparent &lt;- parent_gp;    \t\t\t}    \t\t\tdo create_groups(el, first(created_g));    \t\t\tcompute_shape &lt;- true;    \t\t}    \t}    \tif (compute_shape and parent_gp != nil) {    \t\task parent_gp {    \t\t\tshape &lt;- polyline (sub_groups collect each.location);    \t\t}    \t\t    \t}    }    //reflex that builds the cell clusters    reflex forest_clustering {    \tlist&lt;list&lt;vegetation_cell&gt;&gt; clusters &lt;- list&lt;list&lt;vegetation_cell&gt;&gt;(simple_clustering_by_distance(vegetation_cell where (each.color = #green), max_dist_cell));        loop cluster over: clusters {        \tcreate forest {        \t\tcells &lt;- cluster;        \t\tshape &lt;- union (cells);        \t}        }        list clustering_tree &lt;- hierarchical_clustering (people, max_dist_people);    }    }grid vegetation_cell width: 25 height: 25 neighbors: 4{\trgb color &lt;- flip (proba_vegetation) ? #green : #white;}species forest {\tlist&lt;vegetation_cell&gt; cells;\taspect default {\t\tdraw shape.contour + 0.5 color: #red;\t}}species people {\trgb color_cluster &lt;- #black;\trgb color_tree &lt;- #black;\taspect cluster {\t\tdraw circle(2) color: color_cluster;\t}\taspect tree {\t\tdraw circle(2) color: color_tree;\t}}species group_people {\tlist&lt;group_people&gt; sub_groups;\tgroup_people parent;\taspect default {\t\tdraw shape + 0.2 color: #red;\t\tif (parent != nil) {\t\t\tdraw line ([location, parent.location]) end_arrow: 2 color: #red;\t\t}\t}}experiment clustering type: gui {\tparameter \"Maximal distance for people clustering\" var: max_dist_people min: 0.0 max: 100.0 category: \"People\";\tparameter \"Maximal distance for vegetation cell clustering\" var: max_dist_cell min: 0 max: 5 category: \"Forest\";\tparameter \"Probability for vegetation cells\" var: proba_vegetation min: 0.1 max: 1.0 category: \"Forest\";\toutput {\t\tdisplay map_people_clusters {\t\t\tspecies people aspect: cluster;\t\t}\t\tdisplay map_people_tree {\t\t\tspecies people aspect: tree;\t\t\tspecies group_people;\t\t}\t\tdisplay map_forest_clusters {\t\t\tgrid vegetation_cell lines: #black;\t\t\tspecies forest;\t\t}\t}}",
        "url":"/wiki/Clustering-Spatial-Clustering.html"
      }
      ,
    
      "wiki-clustering-html": {
        "title": "Clustering",
        "content": "ClusteringThis sub-section is composed of the following models :       Clustering of agents by K Means and DBScan         Clustering of agents by their distance   ",
        "url":"/wiki/Clustering.html"
      }
      ,
    
      "wiki-co-model-example-comodel-sir-switch-html": {
        "title": "Comodel SIR Switch",
        "content": "Comodel SIR SwitchAuthor : HUYNH Quang NghiThis is a comodel that implement the dynamic of SIR_switch: it will use the EBM when the density of population is big and ABM when the density of population is low. It demonstrate the capability of using dynamically the legacy models.SIR_ABM_coupling is the coupling that manipulates the elements inside SIR_ABM model and proposes the function would be used from outside. SIR_ABM is a simple example of SIR that use the agents to represent the spreading of disease..SIR_EBM_coupling is the coupling that manipulates the elements inside SIR_EBM model and proposes the function would be used from outside. SIR_EBM is a simple example of ODE use into agents with the example of the SIR equation system.Imported models :model SIR_ABM global{\tgeometry shape&lt;-envelope(square(100));\tfloat beta &lt;- 0.5 ; \t \tfloat nu &lt;- 0.001 ;\tfloat delta &lt;- 0.01;\tinit{\t\tcreate Host number:495 ;\t\tcreate Host number:5{state&lt;-1;}\t\t\t}}species Host skills:[moving]{\tint state&lt;-0;\tlist&lt;rgb&gt; color&lt;-[#green, #red, #yellow];\treflex moving{\t\tdo wander;\t}        reflex become_infected when: state=1 {    \tlist n&lt;- self neighbors_at(1);    \task n{    \t\t\t    \tif (flip(beta)) {\t\t\t\tstate&lt;-1;    \t        }    \t}    }        reflex become_immune when: (state=1 and flip(delta)) {    \tstate&lt;-2;    }                \taspect base{\t\tdraw circle(1) color: color[state];\t}}experiment SIR_ABM_exp type:gui{\toutput {\t\tdisplay gridDisp{\t\t\tspecies Host aspect:base;\t\t}\t}}model SIR_ABM_couplingimport \"SIR_ABM.gaml\"experiment SIR_ABM_coupling_exp type: gui parent: SIR_ABM_exp{\tint get_num_S\t{\t\treturn length(Host where (each.state = 0));\t}\tint get_num_I\t{\t\treturn length(Host where (each.state = 1));\t}\tint get_num_R\t{\t\treturn length(Host where (each.state = 2));\t}\taction set_num_S_I_R (int numS, int numI, int numR)\t{\t\tunknown call;\t\tcall &lt;- set_num_S(numS);\t\tcall &lt;- set_num_I(numI);\t\tcall &lt;- set_num_R(numR);\t}\taction set_num_S (int num)\t{\t\task (Host where (each.state = 0))\t\t{\t\t\tdo die;\t\t}\t\tcreate Host number: num\t\t{\t\t\tstate &lt;- 0;\t\t}\t}\taction set_num_I (int num)\t{\t\task (Host where (each.state = 1))\t\t{\t\t\tdo die;\t\t}\t\tcreate Host number: num\t\t{\t\t\tstate &lt;- 1;\t\t}\t}\taction set_num_R (int num)\t{\t\task (Host where (each.state = 2))\t\t{\t\t\tdo die;\t\t}\t\tcreate Host number: num\t\t{\t\t\tstate &lt;- 2;\t\t}\t}\toutput\t{\t}}model SIR_EBMglobal {\tinit{\t\tcreate agent_with_SIR_dynamic;\t} }species agent_with_SIR_dynamic {\tint N &lt;- 495 ;\tint iInit &lt;- 5;\t\t    float t;  \tfloat S &lt;- N - float(iInit); \t      \tfloat I &lt;- float(iInit); \tfloat R &lt;- 0.0; \t\tfloat alpha &lt;- 0.2;\tfloat beta &lt;- 0.8; \tfloat h &lt;- 0.01;   \tequation SIR{ \t\tdiff(S,t) = (- beta *   S * I / N);\t\tdiff(I,t) = (  beta*  S * I / N) - (alpha * I)  ;\t\tdiff(R,t) = (  alpha  *  I) ;\t}                    reflex solving {//    \twrite S;    \tsolve SIR method: \"rk4\" step: h;// cycle_length: 1/h ;    }    }experiment SIR_EBM_exp type: gui {\toutput { \t\tdisplay display_charts {\t\t\tchart \"SIR_agent\" type: series background: #white {\t\t\t\tdata 'S' value: first(list(agent_with_SIR_dynamic)).S color: #green ;\t\t\t\t\t\t\t\tdata 'I' value: first(list(agent_with_SIR_dynamic)).I color: #red ;\t\t\t\tdata 'R' value: first(list(agent_with_SIR_dynamic)).R color: #blue ;\t\t\t}\t\t}\t}}model SIR_EBM_couplingimport \"SIR_EBM.gaml\"experiment SIR_EBM_coupling_exp type: gui parent: SIR_EBM_exp{\tint get_num_S\t{\t\treturn first(agent_with_SIR_dynamic).S;\t}\tint get_num_I\t{\t\treturn first(agent_with_SIR_dynamic).I;\t}\tint get_num_R\t{\t\treturn first(agent_with_SIR_dynamic).R;\t}\taction set_num_S_I_R (int numS, int numI, int numR)\t{\t\tunknown call;\t\tcall &lt;- set_num_S(numS);\t\tcall &lt;- set_num_I(numI);\t\tcall &lt;- set_num_R(numR);\t}\taction set_num_S (int num)\t{\t\tfirst(agent_with_SIR_dynamic).S &lt;- float(num);\t}\taction set_num_I (int num)\t{\t\tfirst(agent_with_SIR_dynamic).I &lt;- float(num);\t}\taction set_num_R (int num)\t{\t\tfirst(agent_with_SIR_dynamic).R &lt;- float(num);\t}\toutput\t{\t}}Code of the model :model Comodel_SIR_Switchimport \"Legacy_models/SIR_EBM_coupling.gaml\" as SIR_1import \"Legacy_models/SIR_ABM_coupling.gaml\" as SIR_2global{\tgeometry shape &lt;- envelope(square(100));\tint switch_threshold &lt;- 120; // threshold for switching models\tint threshold_to_IBM &lt;- 220; // threshold under which the model swith to IBM\tint threshold_to_Maths &lt;- 20;\tinit\t{\t\tcreate SIR_1.SIR_EBM_coupling_exp;\t\tcreate SIR_2.SIR_ABM_coupling_exp;\t\tcreate Switch;\t}}species Switch{\tint S &lt;- 495;\tint I &lt;- 5;\tint R &lt;- 0;\treflex request_from_micro_model\t{\t\t//if the size of S population and I population are bigger than a threshold, use the EBM\t\tif (S &gt; threshold_to_Maths and I &gt; threshold_to_Maths)\t\t{\t\t\task world\t\t\t{\t\t\t\tunknown call;\t\t\t\tcall &lt;- first(SIR_1.SIR_EBM_coupling_exp).set_num_S_I_R(myself.S, myself.I, myself.R);\t\t\t\task first(SIR_1.SIR_EBM_coupling_exp).simulation\t\t\t\t{\t\t\t\t\tloop times: 5\t\t\t\t\t{\t\t\t\t\t\tdo _step_;\t\t\t\t\t}\t\t\t\t}\t\t\t\tmyself.S &lt;- first(SIR_1.SIR_EBM_coupling_exp).get_num_S();\t\t\t\tmyself.I &lt;- first(SIR_1.SIR_EBM_coupling_exp).get_num_I();\t\t\t\tmyself.R &lt;- first(SIR_1.SIR_EBM_coupling_exp).get_num_R();\t\t\t}\t\t}\t\t\t\t//if the size of S population or  I population are smaller  than a threshold, use the ABM\t\tif (I &lt; threshold_to_IBM or S &lt; threshold_to_IBM)\t\t{\t\t\task world\t\t\t{\t\t\t\tunknown call;\t\t\t\tcall &lt;- first(SIR_2.SIR_ABM_coupling_exp).set_num_S_I_R(myself.S, myself.I, myself.R);\t\t\t\task first(SIR_2.SIR_ABM_coupling_exp).simulation\t\t\t\t{\t\t\t\t\tloop times: 1\t\t\t\t\t{\t\t\t\t\t\tdo _step_;\t\t\t\t\t}\t\t\t\t}\t\t\t\tmyself.S &lt;- first(SIR_2.SIR_ABM_coupling_exp).get_num_S();\t\t\t\tmyself.I &lt;- first(SIR_2.SIR_ABM_coupling_exp).get_num_I();\t\t\t\tmyself.R &lt;- first(SIR_2.SIR_ABM_coupling_exp).get_num_R();\t\t\t}\t\t}\t}\taspect base\t{\t\tdraw square(100);\t}}experiment Simple_exp type: gui{\toutput\t{\t\tdisplay co_SIR_chart\t\t{\t\t\tchart \"SIR_agent\" type: series background: # white\t\t\t{\t\t\t\tdata 'S' value: first(Switch).S color: # green;\t\t\t\tdata 'I' value: first(Switch).I color: # red;\t\t\t\tdata 'R' value: first(Switch).R color: # yellow;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Co-model-Example-Comodel_SIR_Switch.html"
      }
      ,
    
      "wiki-co-model-example-comodelboidsvoronoi-html": {
        "title": "Comodel of Boids and Voronoi",
        "content": "Comodel of Boids and VoronoiAuthor : HUYNH Quang NghiCo-model example : Voronoi applied on Boids.Imported models :model voronoi global {\t// Parameters \t//Number of points\tint num_points &lt;- 4 min: 1 max: 1000;\t//Size of the environment\tint env_width &lt;- 100 min: 10 max: 400;\tint env_height &lt;- 100 min: 10 max: 400;\t\t// Environment\tgeometry shape &lt;- rectangle(env_width, env_height);\t\tinit { \t\twrite 'This model shows how Voronoi-like shapes can be drawn on a regular surface. A set of mobile agents is placed on a grid. Each agent possesses an attribute called *inside_color*. Each step, the agents move randomly and the grid cells paint themselves using the *inside_color* of the nearest agent. Dynamical boundaries then appear on the screen without any further calculations.';\t\t//Creation of all the points\t\tcreate center number: num_points ;  \t}   } //Grid for the voronoi clusteringgrid cell width: env_width height: env_height neighbors: 8 use_regular_agents: false {\t// Note: since GAMA 1.7, the topology needs to be specified for this computation to use continuous distances\tcenter closest_center &lt;- nil update: (center closest_to self.location) using topology(world);\trgb color &lt;- #white update: (closest_center).color;}//Species representing the center of a Voronoi pointspecies center skills: [moving] { \trgb color &lt;- rgb([rnd (255),rnd (255),rnd (255)]); \t//Make the center of the cluster wander in the environment       \treflex wander {\t\tdo wander amplitude: 90;\t}  \taspect base {\t\tdraw square(1.0) color: color;\t}}experiment voronoi type: gui{ \tparameter 'Number of points:' var: num_points;\tparameter 'Width of the environment:' var: env_width;\tparameter 'Height of the environment:' var: env_height;\t\toutput {\t\tdisplay Voronoi type: opengl {\t\t\tgrid cell  ;\t\t\tspecies center aspect: base ;\t\t}\t}\t}model Voronoi_couplingimport \"../../../Toy Models/Voronoi/Voronoi.gaml\"experiment Voronoi_coupling_exp type:gui  parent:voronoi{\t\tlist&lt;center&gt; getCenter{\t\treturn list(center);\t}\tlist&lt;cell&gt; getCell{\t\treturn list(cell);\t}\t\t\toutput{\t}}model boids global torus: torus_environment{ \t//Number of boids that will be created\tint number_of_agents &lt;- 50 min: 1 max: 1000000;\t//Number of obstacles for the boids movement to represent\tint number_of_obstacles &lt;- 0 min: 0;\t//Maximal speed of the boids\tfloat maximal_speed &lt;- 15.0 min: 0.1 max: 15.0;\t//Factors for the group of boids\tint cohesion_factor &lt;- 200;\tint alignment_factor &lt;- 100; \t//Variables for the movement of the boids\tfloat minimal_distance &lt;- 10.0; \tint maximal_turn &lt;- 45 min: 0 max: 359; \t\tint width_and_height_of_environment &lt;- 1000;  \tbool torus_environment &lt;- false; \tbool apply_cohesion &lt;- true ;\tbool apply_alignment &lt;- true ;\tbool apply_separation &lt;- true;\tbool apply_avoid &lt;- true;  \tbool apply_wind &lt;- true;   \tbool moving_obstacles &lt;- false;   \tint bounds &lt;- int(width_and_height_of_environment / 20); \t//Vector for the wind\tpoint wind_vector &lt;- {0,0}; \tlist images of: image_file &lt;- [file('../images/bird1.png'),file('../images/bird2.png'),file('../images/bird3.png')]; \tint xmin &lt;- bounds;   \tint ymin &lt;- bounds;  \tint xmax &lt;- (width_and_height_of_environment - bounds);     \tint ymax &lt;- (width_and_height_of_environment - bounds);   \t\t//Action to move the goal to the mouse location\taction move_goal(point mouse) {\t\task first(boids_goal) {\t\t\tdo goto target: mouse speed: 30;\t\t}\t}\t\tgeometry shape &lt;- square(width_and_height_of_environment);\t\tinit { \t\t//Create the boids agents\t\tcreate boids number: number_of_agents { \t\t\t location &lt;- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };\t\t} \t\t//Create the obstacles agents\t\tcreate obstacle number: number_of_obstacles {\t\t\tlocation &lt;- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 }; \t\t}\t\t//Create the goal that boids will follow\t\tcreate  boids_goal;\t\t}\t}//Species boids goal which represents the goal that will be followed by boids agents using the skill movingspecies boids_goal skills: [moving] {\tfloat range  &lt;- 20.0;\t\t//If the mouse is not used, then the goal just wander\treflex wander {  \t\tdo  wander amplitude: 45 speed: 20;  \t}\t\taspect default {\t\tdraw circle(10) color: #red ;\t\tdraw circle(40) color: #orange empty: true;\t}} //Species boids which represents the boids agents whom follow the boid goal agents, using the skill movingspecies boids skills: [moving] {\t//Speed of the boids agents\tfloat speed max: maximal_speed &lt;- maximal_speed;\t//Range used to consider the group of the agent\tfloat range &lt;- minimal_distance * 2;\tpoint velocity &lt;- {0,0};\t\t\t//Reflex used when the separation is applied to change the velocity of the boid\treflex separation when: apply_separation {\t\tpoint acc &lt;- {0,0};\t\task (boids overlapping (circle(minimal_distance)))  {\t\t\tacc &lt;- acc - ((location) - myself.location);\t\t}  \t\tvelocity &lt;- velocity + acc;\t}\t\t//Reflex to align the boid with the other boids in the range\treflex alignment when: apply_alignment {\t\tlist others  &lt;- ((boids overlapping (circle (range)))  - self);\t\tpoint acc &lt;- mean (others collect (each.velocity)) - velocity;\t\tvelocity &lt;- velocity + (acc / alignment_factor);\t}\t \t//Reflex to apply the cohesion of the boids group in the range of the agent\treflex cohesion when: apply_cohesion {\t\tlist others &lt;- ((boids overlapping (circle (range)))  - self);\t\tpoint mass_center &lt;- (length(others) &gt; 0) ? mean (others collect (each.location)) : location;\t\tpoint acc &lt;- mass_center - location;\t\tacc &lt;- acc / cohesion_factor; \t\tvelocity &lt;- velocity + acc;   \t}\t\t//Reflex to avoid the obstacles\treflex avoid when: apply_avoid { \t\tpoint acc &lt;- {0,0};\t\tlist&lt;obstacle&gt; nearby_obstacles &lt;- (obstacle overlapping (circle (range)) );\t\tloop obs over: nearby_obstacles {\t\t\tacc &lt;- acc - ((location of obs) - my (location));\t\t}\t\tvelocity &lt;- velocity + acc; \t}\t\t//action to represent the bounding of the environment considering the velocity of the boid\taction bounding {\t\tif  !(torus_environment) {\t\t\tif  (location.x) &lt; xmin {\t\t\t\tvelocity &lt;- velocity + {bounds,0};\t\t\t} else if (location.x) &gt; xmax {\t\t\t\tvelocity &lt;- velocity - {bounds,0};\t\t\t}\t\t\t\t\t\tif (location.y) &lt; ymin {\t\t\t\tvelocity &lt;- velocity + {0,bounds};\t\t\t} else if (location.y) &gt; ymax {\t\t\t\tvelocity &lt;- velocity - {0,bounds};\t\t\t}\t\t\t\t\t}\t}\t//Reflex to follow the goal \treflex follow_goal {\t\tvelocity &lt;- velocity + ((first(boids_goal).location - location) / cohesion_factor);\t}\t//Reflex to apply the wind vector on the velocity\treflex wind when: apply_wind {\t\tvelocity &lt;- velocity + wind_vector;\t}\t\t//Action to move the agent  \taction do_move {  \t\tif (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) {\t\t\tvelocity &lt;- {(rnd(4)) -2, (rnd(4)) - 2};\t\t}\t\tpoint old_location &lt;- copy(location);\t\tdo goto target: location + velocity;\t\tvelocity &lt;- location - old_location;\t}\t\t//Reflex to apply the movement by calling the do_move action\treflex movement {\t\tdo do_move;\t}\t\taspect image {\t\tdraw (images at (rnd(2))) size: {50,50} rotate: heading ;      \t}\taspect circle { \t\tdraw circle(15)  color: #red;\t}\t\taspect default { \t\tdraw circle(20) color: #lightblue empty: true;\t}} //Species obstacle that represents the obstacles avoided by the boids agents using the skill movingspecies obstacle skills: [moving] {\tfloat speed &lt;- 2.0;\tgeometry shape &lt;- triangle(15);\t\t//Reflex to move the obstacles if it is available\treflex move_obstacles when: moving_obstacles {\t\t//Will make the agent go to a boid with a 50% probability\t\tif flip(0.5)  \t\t{ \t\t\tdo goto target: one_of(boids);\t\t} \t\telse{ \t\t\tdo wander amplitude: 360;   \t\t}\t}\taspect default {\t\tdraw  triangle(20) color: #black ;\t}}experiment boids_gui type: gui {\tparameter 'Number of agents' var: number_of_agents;\tparameter 'Number of obstacles' var: number_of_obstacles;\tparameter 'Maximal speed' var: maximal_speed;\tparameter 'Cohesion Factor' var: cohesion_factor;\tparameter 'Alignment Factor' var: alignment_factor; \tparameter 'Minimal Distance'  var: minimal_distance; \tparameter 'Maximal Turn'  var: maximal_turn; \tparameter 'Width/Height of the Environment' var: width_and_height_of_environment ;  \tparameter 'Toroidal Environment ?'  var: torus_environment ; \tparameter 'Apply Cohesion ?' var: apply_cohesion ;\tparameter 'Apply Alignment ?' var: apply_alignment ;   \tparameter 'Apply Separation ?' var: apply_separation ;   \tparameter 'Apply Avoidance ?' var: apply_avoid ;   \tparameter 'Apply Wind ?' var: apply_wind ;     \tparameter 'Moving Obstacles ?' var: moving_obstacles  ;    \tparameter 'Direction of the wind' var: wind_vector ;  \t\t//Minimum duration of a step to better see the movements\tfloat minimum_cycle_duration &lt;- 0.01;\toutput {\t\tdisplay Sky  background: #blue type: opengl { \t\t\timage '../images/sky.jpg' refresh: false;\t\t\tspecies boids aspect: image trace: 10 fading: true ;\t\t\tspecies boids_goal;\t\t\tspecies obstacle;\t\t\t//Event to call the action move_goal in global if the mouse move within the experiment\t\t\tevent mouse_move action: move_goal;\t\t}\t}}model Boids_couplingimport \"../../../Toy Models/Boids/models/Boids.gaml\"experiment Boids_coupling_exp type:gui  parent:boids_gui{\t\tlist&lt;boids_goal&gt; getBoids_goal{\t\treturn list(boids_goal);\t}\t\tlist&lt;boids&gt; getBoids{\t\treturn list(boids);\t}\t\t\toutput{\t}}Code of the model :model comodelBoidsVoronoiimport \"Boids_coupling.gaml\" as myBoidsimport \"Voronoi_coupling.gaml\" as myVoronoiglobal{\t// set the bound of the environment\tgeometry shape &lt;- envelope(100);\t\tinit\t{\t\t\t//create experiment from micro-model myBoids\t\tcreate myBoids.Boids_coupling_exp with: [shape::square(0.5), width_and_height_of_environment::100, number_of_agents::100];\t\t//create experiment form micro-model myVoronoi\t\tcreate myVoronoi.Voronoi_coupling_exp with:[num_points::100, env_width::100, env_height::100];\t}\treflex simulate_micro_models\t{\t\t//tell myBoids to step a cycle\t\task (myBoids.Boids_coupling_exp collect each.simulation){ do _step_;}\t\t//get all boids's location into a list\t\tlist&lt;point&gt; theLocations&lt;-(myBoids.Boids_coupling_exp accumulate each.getBoids()) collect each.location;\t\t//myVoronoi do a step with the location of their agent from the location list above \t\task (myVoronoi.Voronoi_coupling_exp collect each.simulation){ ask center{location&lt;-theLocations at (int(self)); }do _step_;}\t}}experiment comodel_Boids_Voronoi_Exp type: gui{\toutput\t{\t\tdisplay \"comodel_disp\" \t\t{\t\t\tagents \"cell\" value: (myVoronoi.Voronoi_coupling_exp accumulate each.getCell());\t\t\t\t\t\tagents \"boids_goal\" value: (myBoids.Boids_coupling_exp accumulate each.getBoids_goal()) {draw circle(5) color:#red;}\t\t\t\t\t\tagents \"boids\" value: (myBoids.Boids_coupling_exp accumulate each.getBoids()) {draw circle(1) color:#blue;}\t\t\t\t\t}\t}}",
        "url":"/wiki/Co-model-Example-comodelBoidsVoronoi.html"
      }
      ,
    
      "wiki-co-model-example-comodel-flood-evacuation-html": {
        "title": "Comodel of Flood and Evacuation model",
        "content": "Comodel of Flood and Evacuation modelAuthor : HUYNH Quang NghiCo-model example : couple the evacuation model with the flood model. Water win or human win?Imported models :model continuous_move global { \t//Shapefile of the buildings\tfile building_shapefile &lt;- file(\"../includes/building.shp\");\t//Shape of the environment\tgeometry shape &lt;- envelope(building_shapefile);\tint maximal_turn &lt;- 90; //in degree\tint cohesion_factor &lt;- 10;\t//Size of the people\tfloat people_size &lt;- 2.0;\t//Space without buildings\tgeometry free_space;\t//Number of people agent\tint nb_people &lt;- 500;\t//Point to evacuate\tpoint target_point &lt;- {world.location.x, 0};\tinit { \t\t\t\tfree_space &lt;- copy(shape);\t\t//Creation of the buildinds\t\tcreate building from: building_shapefile {\t\t\t//Creation of the free space by removing the shape of the different buildings existing\t\t\tfree_space &lt;- free_space - (shape + people_size);\t\t}\t\t//Simplification of the free_space to remove sharp edges\t\tfree_space &lt;- free_space simplification(1.0);\t\t//Creation of the people agents\t\tcreate people number: nb_people {\t\t\t//People agents are placed randomly among the free space\t\t\tlocation &lt;- any_location_in(free_space);\t\t\ttarget_loc &lt;-  target_point;\t\t} \t\t \t\t}\t}//Species which represent the building species building {\t//Height of the buildings\tfloat height &lt;- 3.0 + rnd(5);\taspect default {\t\tdraw shape color: #gray depth: height;\t}}//Species people which move to the evacuation point using the skill movingspecies people skills:[moving]{\t//Target point to evacuate\tpoint target_loc;\t//Speed of the agent\tfloat speed &lt;- 0.5 + rnd(1000) / 1000;\t//Velocity of the agent\tpoint velocity &lt;- {0,0};\t//Direction of the agent taking in consideration the maximal turn an agent is able to make\tint heading max: heading + maximal_turn min: heading - maximal_turn;\t\t//Size of the agent\tfloat size &lt;- people_size;\trgb color &lt;- rgb(rnd(255),rnd(255),rnd(255));\t\t\t//Reflex to kill the agent when it has evacuated the area\treflex end when: location distance_to target_loc &lt;= 2 * people_size{\t\twrite name + \" is arrived\";\t\tdo die;\t}\t//Reflex to compute the velocity of the agent considering the cohesion factor\treflex follow_goal  {\t\tvelocity &lt;- velocity + ((target_loc - location) / cohesion_factor);\t}\t//Reflex to apply separation when people are too close from each other\treflex separation {\t\tpoint acc &lt;- {0,0};\t\task (people at_distance size)  {\t\t\tacc &lt;- acc - (location - myself.location);\t\t}  \t\tvelocity &lt;- velocity + acc;\t}\t//Reflex to avoid the different obstacles\treflex avoid { \t\tpoint acc &lt;- {0,0};\t\tlist&lt;building&gt; nearby_obstacles &lt;- (building at_distance people_size);\t\tloop obs over: nearby_obstacles {\t\t\tacc &lt;- acc - (obs.location - location);\t\t}\t\tvelocity &lt;- velocity + acc; \t}\t//Reflex to move the agent considering its location, target and velocity\treflex move {\t\tpoint old_location &lt;- copy(location);\t\tdo goto target: location + velocity ;\t\tif (not empty(building overlapping self )) {\t\t\tlocation &lt;- point((location closest_points_with free_space)[1]);\t\t}\t\tvelocity &lt;- location - old_location;\t}\t\taspect default {\t\tdraw pyramid(size) color: color;\t\tdraw sphere(size/3) at: {location.x,location.y,size} color: color;\t}}experiment main type: gui {\tparameter \"nb people\" var: nb_people min: 1 max: 1000;\toutput {\t\tdisplay map type: opengl {\t\t\tspecies building refresh: false;\t\t\tspecies people;\t\t\tgraphics \"exit\" refresh: false {\t\t\t\tdraw sphere(2 * people_size) at: target_point color: #green;\t\t\t\t}\t\t}\t}}model Evacuation_couplingimport \"../../../Toy Models/Evacuation/models/Continuous Move.gaml\"experiment Evacuation_coupling_exp type: gui parent: main{\tpoint centroid &lt;- { 0, 180 };\tlist&lt;building&gt; getBuilding\t{\t\treturn list(building);\t}\taction transform_environement\t{\t\tloop t over: list(building)\t\t{\t\t\tt.shape &lt;- t.shape translated_by centroid;\t\t\tt.shape &lt;- t.shape * 10;\t\t\tt.location &lt;- t.location * 8;\t\t}\t\tloop t over: list(people)\t\t{\t\t\tt.speed &lt;- 10.0;\t\t\tt.size &lt;- 20.0;\t\t\tt.shape &lt;- t.shape translated_by centroid;\t\t\tt.location &lt;- t.location * 8;\t\t}\t\ttarget_point &lt;- point(target_point translated_by centroid);\t}\tlist&lt;people&gt; getPeople\t{\t\treturn list(people);\t}\toutput\t{\t}}model hydroglobal {   //Shapefile for the river   file river_shapefile &lt;- file(\"../includes/RedRiver.shp\");   //Shapefile for the dykes   file dykes_shapefile &lt;- file(\"../includes/Dykes.shp\");   //Shapefile for the buildings   file buildings_shapefile &lt;- file(\"../includes/Building.shp\");      //Data elevation file   file dem_file &lt;- file(\"../includes/mnt50.asc\");     //Diffusion rate   float diffusion_rate &lt;- 0.6;   //Height of the dykes   float dyke_height &lt;- 15.0;   //Width of the dyke   float dyke_width &lt;- 15.0;       //Shape of the environment using the dem file   geometry shape &lt;- envelope(dem_file);      //List of the drain and river cells   list&lt;cell&gt; drain_cells;   list&lt;cell&gt; river_cells;           float step &lt;- 1°h;      init {   \t //Initialization of the cells      do init_cells;     //Initialization of the water cells      do init_water;     //Initialization of the river cells     river_cells &lt;- cell where (each.is_river);     //Initialization of the drain cells      drain_cells &lt;- cell where (each.is_drain);     //Initialization of the obstacles (buildings and dykes)      do init_obstacles;      //Set the height of each cell      ask cell {         obstacle_height &lt;- compute_highest_obstacle();         do update_color;      }   }   //Action to initialize the altitude value of the cell according to the dem file   action init_cells {      ask cell {         altitude &lt;- grid_value;         neighbour_cells &lt;- (self neighbors_at 1) ;      }   }   //action to initialize the water cells according to the river shape file and the drain   action init_water {      geometry river &lt;- geometry(river_shapefile);      ask cell overlapping river {         water_height &lt;- 10.0;         is_river &lt;- true;         is_drain &lt;- grid_y = matrix(cell).rows - 1;      }   }   //initialization of the obstacles (the buildings and the dykes)   action init_obstacles{      create buildings from: buildings_shapefile  {         do update_cells;      }      create dyke from: dykes_shapefile;      ask dyke {          shape &lt;-  shape + dyke_width;            do update_cells;      }   }   //Reflex to add water among the water cells   reflex adding_input_water {   \t  float water_input &lt;- rnd(100)/100;      ask river_cells {         water_height &lt;- water_height + water_input;      }   }   //Reflex to flow the water according to the altitute and the obstacle   reflex flowing {      ask cell {already &lt;- false;}      ask (cell sort_by ((each.altitude + each.water_height + each.obstacle_height))) {         do flow;      }   }   //Reflex to update the color of the cell   reflex update_cell_color {      ask cell {         do update_color;      }   }   //Reflex for the drain cells to drain water   reflex draining {      ask drain_cells {         water_height &lt;- 0.0;      }   }   }//Species which represent the obstacle   species obstacle {   \t  //height of the obstacle      float height min: 0.0;      //Color of the obstacle      rgb color;      //Pressure of the water      float water_pressure update: compute_water_pressure();            //List of cells concerned      list&lt;cell&gt; cells_concerned ;      //List of cells in the neighbourhood       list&lt;cell&gt; cells_neighbours;            //Action to compute the water pressure      float compute_water_pressure {      \t//If the obstacle doesn't have height, then there will be no pressure         if (height = 0.0) {            return 0.0;         } else {         \t//The leve of the water is equals to the maximul level of water in the neighbours cells            float water_level &lt;- cells_neighbours max_of (each.water_height);            //Return the water pressure as the minimal value between 1 and the water level divided by the height            return min([1.0,water_level / height]);         }       }            //Action to update the cells      action update_cells {      \t//All the cells concerned by the obstacle are the ones overlapping the obstacle         cells_concerned &lt;- (cell overlapping self);        \task cells_concerned {        \t//Add the obstacles to the obstacles of the cell            add myself to: obstacles;            water_height &lt;- 0.0;         }         //Cells neighbours are all the neighbours cells of the cells concerned         cells_neighbours &lt;- cells_concerned + cells_concerned accumulate (each.neighbour_cells);         //The height is now computed      \t do compute_height();         if (height &gt; 0.0) {            \t//We compute the water pressure again            water_pressure &lt;- compute_water_pressure();         } else {water_pressure &lt;- 0.0;}      }      action compute_height;      aspect geometry {         int val &lt;- int( 255 * water_pressure);         color &lt;- rgb(val,255-val,0);         draw shape color: color depth: height*5 border: color;      }   }   //Species buildings which is derivated from obstacle   species buildings parent: obstacle {   \t //The building has a height randomly chosed between 2 and 10      float height &lt;- 2.0 + rnd(8);   }   //Species dyke which is derivated from obstacle   species dyke parent: obstacle{   \t       int counter_wp &lt;- 0;       int breaking_threshold &lt;- 24;            //Action to represent the break of the dyke       action break{         ask cells_concerned {            do update_after_destruction(myself);         }         do die;      }      //Action to compute the height of the dyke as the dyke_height without the mean height of the cells it overlaps      action compute_height       {      \t   height &lt;- dyke_height - mean(cells_concerned collect (each.altitude));            }            //Reflex to break the dynamic of the water      reflex breaking_dynamic {      \tif (water_pressure = 1.0) {      \t\tcounter_wp &lt;- counter_wp + 1;      \t\tif (counter_wp &gt; breaking_threshold) {      \t\t\tdo break;      \t\t}      \t} else {      \t\tcounter_wp &lt;- 0;      \t}      }      //user command which allows the possibility to destroy the dyke for the user      user_command \"Destroy dyke\" action: break;    }   //Grid cell to discretize space, initialized using the dem file   grid cell file: dem_file neighbors: 8 frequency: 0  use_regular_agents: false use_individual_shapes: false use_neighbors_cache: false {      //Altitude of the cell      float altitude;      //Height of the water in the cell      float water_height &lt;- 0.0 min: 0.0;      //Height of the cell      float height;      //List of the neighbour cells      list&lt;cell&gt; neighbour_cells ;      //Boolean to know if it is a drain cell      bool is_drain &lt;- false;      //Boolean to know if it is a river cell      bool is_river &lt;- false;      //List of all the obstacles overlapping the cell      list&lt;obstacle&gt; obstacles;      //Height of the obstacles      float obstacle_height &lt;- 0.0;      bool already &lt;- false;            //Action to compute the highest obstacle among the obstacles      float compute_highest_obstacle {         if (empty(obstacles))         {            return 0.0;          } else {            return obstacles max_of(each.height);         }      }      //Action to flow the water       action flow {      \t//if the height of the water is higher than 0 then, it can flow among the neighbour cells         if (water_height &gt; 0) {         \t//We get all the cells already done            list&lt;cell&gt; neighbour_cells_al &lt;- neighbour_cells where (each.already);            //If there are cells already done then we continue            if (!empty(neighbour_cells_al)) {               //We compute the height of the neighbours cells according to their altitude, water_height and obstacle_height               ask neighbour_cells_al {height &lt;- altitude + water_height + obstacle_height;}               //The height of the cell is equals to its altitude and water height               height &lt;-  altitude +  water_height;               //The water of the cells will flow to the neighbour cells which have a height less than the height of the actual cell               list&lt;cell&gt; flow_cells &lt;- (neighbour_cells_al where (height &gt; each.height)) ;               //If there are cells, we compute the water flowing               if (!empty(flow_cells)) {                  loop flow_cell over: shuffle(flow_cells) sort_by (each.height){                     float water_flowing &lt;- max([0.0, min([(height - flow_cell.height), water_height * diffusion_rate])]);                      water_height &lt;- water_height - water_flowing;                     flow_cell.water_height &lt;-flow_cell.water_height +  water_flowing;                     height &lt;- altitude + water_height;                  }                  }            }         }         already &lt;- true;      }        //Update the color of the cell      action update_color {          int val_water &lt;- 0;         val_water &lt;- max([0, min([255, int(255 * (1 - (water_height / 12.0)))])]) ;           color &lt;- rgb([val_water, val_water, 255]);         grid_value &lt;- water_height + altitude;      }      //action to compute the destruction of the obstacle      action update_after_destruction(obstacle the_obstacle){         remove the_obstacle from: obstacles;         obstacle_height &lt;- compute_highest_obstacle();      }          }experiment main_gui type: gui {   parameter \"Shapefile for the river\" var:river_shapefile category:\"Water data\";   parameter \"Shapefile for the dykes\" var:dykes_shapefile category:\"Obstacles\";   parameter \"Shapefile for the buildings\" var:buildings_shapefile category:\"Obstacles\";   parameter \"Height of the dykes\" var:dyke_height category:\"Obstacles\";   parameter \"Diffusion rate\" var:diffusion_rate category:\"Water dynamic\";   output {       display map type: opengl {         grid cell triangulation: true;         species buildings aspect: geometry;         species dyke aspect: geometry ;      }      display chart_display refresh: every(24) {          chart \"Pressure on Dykes\" type: series {            data \"Mean pressure on dykes \" value: mean(dyke collect (each.water_pressure)) style: line color: #magenta ;            data \"Rate of dykes with max pressure\" value: (dyke count (each.water_pressure = 1.0))/ length(dyke) style: line color: #red ;            data \"Rate of dykes with high pressure\" value: (dyke count (each.water_pressure &gt; 0.5))/ length(dyke) style: line color: #orange ;            data \"Rate of dykes with low pressure\" value: (dyke count (each.water_pressure &lt; 0.25))/ length(dyke) style: line color: #green ;         }      }   }}model Flood_couplingimport \"../../../Toy Models/Flood Simulation/models/Hydrological Model.gaml\"experiment Flood_coupling_exp type: gui parent: main_gui{\tpoint newSize &lt;- { 0.07, 0.07 };\tcell getCellAt (geometry p)\t{\t\task simulation\t\t{\t\t\treturn cell closest_to p;\t\t}\t}\tlist&lt;cell&gt; getCell\t{\t\treturn list(cell) where (each.grid_value &gt; 8.0);\t}\tlist&lt;buildings&gt; getBuildings\t{\t\treturn list(buildings);\t}\tlist&lt;dyke&gt; getDyke\t{\t\treturn list(dyke);\t}\toutput\t{\t}}Code of the model :model comodel_Flood_Evacuationimport \"Flood_coupling.gaml\" as myFloodimport \"Evacuation_coupling.gaml\" as myEvacuationglobal{\t//set the bound of environment\tgeometry shape &lt;- envelope(file(\"../../../Toy Models/Flood Simulation/includes/mnt50.asc\"));\t//counting variable of casualty\tint casualty &lt;- 0;\tinit\t{\t\t//create experiment from micro-model myFlood with corresponding parameters\t\tcreate myFlood.Flood_coupling_exp with:\t\t[buildings_shapefile::file(\"../../../Toy Models/Flood Simulation/includes/Building.shp\"), river_shapefile::file(\"../../../Toy Models/Flood Simulation/includes/RedRiver.shp\"), dykes_shapefile::file(\"../../../Toy Models/Flood Simulation/includes/Dykes.shp\"), dem_file::file(\"../../../Toy Models/Flood Simulation/includes/mnt50.asc\")];\t\t//create the Evacuation micro-model's experiment\t\tcreate myEvacuation.Evacuation_coupling_exp with: [nb_people::200, target_point::{ 0, 1580 }, building_shapefile::file(\"../../../Toy Models/Evacuation/includes/building.shp\")]\t\t{\t\t\t//transform the environment and the agents to new location (near the river)\t\t\tdo transform_environement;\t\t}\t}\treflex doing_cosimulation\t{\t\t//do a step of Flooding\t\task myFlood.Flood_coupling_exp collect each.simulation\t\t{\t\t\tdo _step_;\t\t}\t\t//people evacate \t\task myEvacuation.Evacuation_coupling_exp collect each.simulation\t\t{\t\t\t//depending on the real plan of evacuation, we can test the speed of the evacuation with the speed of flooding by doing more or less simulation step  \t\t\tif (cycle mod 2 = 0)\t\t\t{\t\t\t\tdo _step_;\t\t\t}\t\t}\t\t//loop over the population\t\tloop thePeople over: first(myEvacuation.Evacuation_coupling_exp).getPeople()\t\t{\t\t\t//get the cell at people's location\t\t\tcell theWater &lt;- cell(first(myFlood.Flood_coupling_exp).getCellAt(thePeople));\t\t\t//if the water levele is high than 8 meters and people is overlapped, tell him that he must dead\t\t\tif (theWater.grid_value &gt; 8.0 and theWater overlaps thePeople)\t\t\t{\t\t\t\task thePeople\t\t\t\t{\t\t\t\t\tdo die;\t\t\t\t}\t\t\t\t//increase the counting variable\t\t\t\tcasualty &lt;- casualty + 1;\t\t\t}\t\t}\t}}experiment comodel_Flood_Evacuation_exp type: gui{\toutput\t{\t\tdisplay \"comodel_disp\"\t\t{\t\t\tagents \"building\" value: first(myEvacuation.Evacuation_coupling_exp).getBuilding();\t\t\tagents \"people\" value: first(myEvacuation.Evacuation_coupling_exp).getPeople();\t\t\tagents \"cell\" value: first(myFlood.Flood_coupling_exp).getCell();\t\t\tagents \"dyke\" value: first(myFlood.Flood_coupling_exp).getDyke();\t\t\tgraphics 'CasualtyView'\t\t\t{\t\t\t\tdraw ('Casualty: ' + casualty) at: { 0, 4000 } font: font(\"Arial\", 18, # bold) color: # red;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Co-model-Example-comodel_Flood_Evacuation.html"
      }
      ,
    
      "wiki-co-model-example-comodel-urban-traffic-html": {
        "title": "comodel Urban and Traffic model",
        "content": "comodel Urban and Traffic modelAuthor : HUYNH Quang NghiCo-model example : coupling urban growth model with the traffic model.Imported models :model raster3global{ \t//File for the ascii grid\tfile asc_grid &lt;- grid_file(\"../includes/cantho_1999_v6.asc\");\t//Shapefile for the road\tfile road_shapefile &lt;- shape_file(\"../includes/roads15_3.shp\");\t//Shapefile for the city\tfile city_center_shapefile &lt;- shape_file(\"../includes/city center.shp\");\t//Shape of the environment\tgeometry shape &lt;- envelope(asc_grid);\t//Graph of the roads\tgraph roads_network;\t\t// Dynamic list of the cells to consider at each cycle\tlist&lt;plot&gt; empty_plots &lt;- plot where (each.grid_value = 0.0) update: shuffle(plot where (each.grid_value = 0.0));\t\tlist&lt;rgb&gt; plot_colors &lt;- [ \t\t#lightgray, //empty\t\t#orange, // 1 built\t\t#blue // 2 River-lake\t];\t//Radius of density\tint density_radius &lt;- 4;\t//Weight of density\tfloat weight_density &lt;- 0.05;\t//Weight of the road distance\tfloat weight_road_dist &lt;- 0.5;\t//Weight of the city center distance\tfloat weight_cc_dist &lt;- 0.3;\t//Number of plot allowing to build a building\tint nb_plots_to_build &lt;- 195;\tinit\t{\t\t//Creation of the roads using the shapefile of the road\t\tcreate roads from: road_shapefile;\t\t//Creation of the city center using the city center shapefile\t\tcreate city_center from: city_center_shapefile;\t\t//Creation of the graph of the road network\t\troads_network &lt;- as_edge_graph(roads);\t\t\t\t//Each road has to compute its distance from the city center\t\task roads {\t\t\tdo compute_cc_dist;\t\t}\t\t//Compute the city distance for each plot\t\task empty_plots {\t\t\tdo compute_distances;\t\t}\t\t//Normalization of the distance\t\tdo normalize_distances;\t}\t//Action to normalize the distance\taction normalize_distances {\t\t//Maximum distance from the road of all the plots\t\tfloat max_road_dist &lt;- empty_plots max_of each.dist_route;\t\t//Maximum distance from the city center for all the plots\t\tfloat max_cc_dist &lt;- empty_plots max_of each.dist_cv;\t\t//Normalization of  each empty plot according to the maximal value of each attribute\t\task empty_plots {\t\t\tdist_cv &lt;- 1 - dist_cv / max_cc_dist;\t\t\tdist_route &lt;- 1 - dist_route / max_road_dist;\t\t}\t}\t\t\t//Reflex representing the global dynamic of the model\treflex dynamique_globale when: weight_density != 0 or weight_road_dist != 0 or weight_cc_dist != 0 {\t\t//Ask to each empty plot to compute its constructability\t\task empty_plots {\t\t\tconstructability &lt;- compute_constructability();\t\t}\t\tlist&lt;plot&gt; ordered_plots &lt;- empty_plots sort_by (each.constructability);\t\tordered_plots &lt;- nb_plots_to_build last ordered_plots;\t\t//Build on each empty plot having the highest constructability\t\task ordered_plots\t\t{\t\t\tdo build;\t\t}\t}\t}//Species representing the city centerspecies city_center {\taspect default {\t\tdraw circle(300) color: #cyan;\t}\t}//Species representing the roadsspecies roads{\tfloat dist_cv;\t//Action to compute the city center distance for the road\taction compute_cc_dist {\t\tusing topology(roads_network)\t\t{\t\t\tdist_cv &lt;- self distance_to first(city_center);\t\t}\t}\taspect default {\t\tdraw shape color: #black;\t\t}}//Grid species to represent the different building plotsgrid plot file: asc_grid use_individual_shapes: false use_regular_agents: false neighbors: 4{\trgb color &lt;- grid_value = -1 ? #white : plot_colors[int(grid_value)];\t//Distance from the road\tfloat dist_route &lt;- 0.0;\t//Distance from the city center\tfloat dist_cv &lt;- 0.0;\t//Constructability of the plot\tfloat constructability;\t\t//Action to compute all the distances for the cell\taction compute_distances\t{\t\troads route_pp &lt;- roads closest_to self;\t\tdist_route &lt;- (self distance_to route_pp) using topology(world);\t\tdist_cv &lt;- dist_route + route_pp.dist_cv;\t}\t//Action to build on the cell\taction build\t{\t\tgrid_value &lt;- 1.0;\t\tcolor &lt;- plot_colors[1];\t}\t//Action to compute the constructability of the plot cell\tfloat compute_constructability\t{\t\t//Get all the neighbours plots\t\tlist&lt;plot&gt; voisins &lt;- (self neighbors_at density_radius);\t\t//Compute the density of all the neighbours plots\t\tfloat densite &lt;- (voisins count (each.grid_value = 1.0)) / length(voisins);\t\treturn (densite * weight_density + dist_route * weight_road_dist + dist_cv * weight_cc_dist) / (weight_density + weight_road_dist + weight_cc_dist);\t}\t\t\t}experiment raster type: gui { \tparameter \"Weight of the density criteria\" var: weight_density; \tparameter \"Weight of the distance to roads criteria\" var: weight_road_dist; \tparameter \"Weight of the distance to city center criteria\" var: weight_cc_dist; \toutput { \t\tdisplay map type: opengl {\t\t\tgrid plot;\t\t\tspecies roads;\t\t\tspecies city_center;\t\t}\t}}model Urban_couplingimport \"../../../Toy Models/Urban Growth/models/raster model.gaml\"experiment Urban_coupling_exp type: gui parent: raster{\tlist&lt;plot&gt; getPlot\t{\t\treturn list(plot);\t}}model trafficglobal {\t//Shapefile of the buildings\tfile building_shapefile &lt;- file(\"../includes/buildings.shp\");\t//Shapefile of the roads\tfile road_shapefile &lt;- file(\"../includes/roads.shp\");\t//Shape of the environment\tgeometry shape &lt;- envelope(road_shapefile);\t//Step value\tfloat step &lt;- 10 #s;\t//Graph of the road network\tgraph road_network;\t//Map containing all the weights for the road network graph\tmap&lt;road,float&gt; road_weights;\t\tinit {\t\t//Initialization of the building using the shapefile of buildings\t\tcreate building from: building_shapefile;\t\t//Initialization of the road using the shapefile of roads\t\tcreate road from: road_shapefile;\t\t\t\t//Creation of the people agents\t\tcreate people number: 1000{\t\t\t//People agents are located anywhere in one of the building\t\t\tlocation &lt;- any_location_in(one_of(building));      \t}      \t//Weights of the road      \troad_weights &lt;- road as_map (each::each.shape.perimeter);      \troad_network &lt;- as_edge_graph(road);\t}\t//Reflex to update the speed of the roads according to the weights\treflex update_road_speed  {\t\troad_weights &lt;- road as_map (each::each.shape.perimeter / each.speed_coeff);\t\troad_network &lt;- road_network with_weights road_weights;\t}}//Species to represent the people using the skill movingspecies people skills: [moving]{\t//Target point of the agent\tpoint target;\t//Probability of leaving the building\tfloat leaving_proba &lt;- 0.05; \t//Speed of the agent\tfloat speed &lt;- 5 #km/#h;\trgb color &lt;- rnd_color(255);\t//Reflex to leave the building to another building\treflex leave when: (target = nil) and (flip(leaving_proba)) {\t\ttarget &lt;- any_location_in(one_of(building));\t}\t//Reflex to move to the target building moving on the road network\treflex move when: target != nil {\t\tdo goto target: target on: road_network recompute_path: false move_weights: road_weights;\t\tif (location = target) {\t\t\ttarget &lt;- nil;\t\t}\t\t}\t\taspect default {\t\tdraw circle(5) color: color;\t}}//Species to represent the buildingsspecies building {\taspect default {\t\tdraw shape color: #gray;\t}}//Species to represent the roadsspecies road {\t//Capacity of the road considering its perimeter\tfloat capacity &lt;- 1 + shape.perimeter/30;\t//Number of people on the road\tint nb_people &lt;- 0 update: length(people at_distance 1);\t//Speed coefficient computed using the number of people on the road and the capicity of the road\tfloat speed_coeff &lt;- 1.0 update:  exp(-nb_people/capacity) min: 0.1;\t\taspect default {\t\tdraw (shape + 3 * speed_coeff) color: #red;\t}}experiment trafic type: gui {\tfloat minimum_cycle_duration &lt;- 0.01;\toutput {\t\tdisplay carte type: opengl{\t\t\tspecies building refresh: false;\t\t\tspecies road ;\t\t\tspecies people ;\t\t}\t}}model Traffic_couplingimport \"../../../Toy Models/Traffic/models/Simple traffic model.gaml\"experiment Traffic_coupling_exp type: gui parent: trafic{\tlist&lt;building&gt; getBuilding\t{\t\treturn list(building);\t}\tlist&lt;people&gt; getPeople\t{\t\treturn list(people);\t}\tlist&lt;road&gt; getRoad\t{\t\treturn list(road);\t}}Code of the model :model comodel_Urban_Trafficimport \"Traffic_coupling.gaml\" as myTrafficimport \"Urban_coupling.gaml\" as myUrbanglobal{\t//set the bound of the world\tgeometry shape &lt;- envelope(shape_file(\"../../../Toy Models/Traffic/includes/roads.shp\"));\tinit\t{\t\t//create Traffic micro-model's experiment\t\tcreate myTraffic.Traffic_coupling_exp with:\t\t[building_shapefile::file(\"../../../Toy Models/Traffic/includes/buildings.shp\"), road_shapefile::file(\"../../../Toy Models/Traffic/includes/roads.shp\")];\t\t//create Urban micro-model;s experiment\t\tcreate myUrban.Urban_coupling_exp with:\t\t[asc_grid::grid_file(\"../../../Toy Models/Urban Growth/includes/cantho_1999_v6.asc\"), road_shapefile::shape_file(\"../../../Toy Models/Urban Growth/includes/roads15_3.shp\"), city_center_shapefile::shape_file(\"../../../Toy Models/Urban Growth/includes/city center.shp\")];\t}\treflex simulate_micro_models\t{\t\t//ask simulation of micro-model step one\t\task myTraffic.Traffic_coupling_exp collect each.simulation\t\t{\t\t\tdo _step_;\t\t}\t\t// tell the urban to grow up every 200 step\t\task myUrban.Urban_coupling_exp collect each.simulation\t\t{\t\t\tif (cycle mod 200 = 0)\t\t\t{\t\t\t\tdo _step_;\t\t\t}\t\t}\t}}experiment comodel_Urban_Traffic_exp type: gui{\toutput\t{\t\tdisplay \"comodel_disp\"\t\t{\t\t\tagents \"Plotgrid\" value: first(myUrban.Urban_coupling_exp).getPlot() size: { 0.037, 0.052 };\t\t\tagents \"building\" value: first(myTraffic.Traffic_coupling_exp).getBuilding();\t\t\tagents \"people\" value: first(myTraffic.Traffic_coupling_exp).getPeople();\t\t\tagents \"road\" value: first(myTraffic.Traffic_coupling_exp).getRoad();\t\t}\t}}",
        "url":"/wiki/Co-model-Example-comodel_Urban_Traffic.html"
      }
      ,
    
      "wiki-co-model-example-html": {
        "title": "Co-model Example",
        "content": "Co-model ExampleThis sub-section is composed of the following models :      Comodel of Boids and Voronoi        Comodel of Flood and Evacuation model        Comodel SIR Switch        comodel Urban and Traffic model  ",
        "url":"/wiki/Co-model-Example.html"
      }
      ,
    
      "wiki-co-model-usage-comodel-mix-behaviors-html": {
        "title": "comodel with mixed behaviors",
        "content": "comodel with mixed behaviorsAuthor : HUYNH Quang NghiThis is a simple comodel serve to demonstrate the mixing behaviors of preyPredator with the Ants. Ants are the prey, fleeing from Predators, when they are not chasing, they try to do job of the ants.Imported models :model antsglobal {\t//Evaporation value per cycle\tfloat evaporation_per_cycle &lt;- 5.0 min: 0.0 max: 240.0 parameter: 'Evaporation of the signal (unit/cycle):' category: 'Signals';\t//Diffusion rate of the pheromon among the grid\tfloat diffusion_rate &lt;- 1.0 min: 0.0 max: 1.0 parameter: 'Rate of diffusion of the signal (%/cycle):' category: 'Signals';\t//Size of the grid\tint gridsize &lt;- 100 min: 30 parameter: 'Width and Height of the grid:' category: 'Environment and Population';\t//Number of ants\tint ants_number &lt;- 200 min: 1 parameter: 'Number of ants:' category: 'Environment and Population';\t//Frequency of update of the grid\tint grid_frequency &lt;- 1 min: 1 max: 100 parameter: 'Grid updates itself every:' category: 'Environment and Population';\t//Number of food places among the grid\tint number_of_food_places &lt;- 5 min: 1 parameter: 'Number of food depots:' category: 'Environment and Population';\tfloat grid_transparency &lt;- 1.0;\tfile ant_shape_empty const: true &lt;- file('../icons/ant.png');\timage_file ant_shape_full const: true &lt;- file('../icons/full_ant.png');\t//The center of the grid that will be considered as the nest location\tpoint center const: true &lt;- { round(gridsize / 2), round(gridsize / 2) };\tint food_gathered &lt;- 1;\tint food_placed &lt;- 1;\trgb background const: true &lt;- rgb(#99CC66);\trgb food_color const: true &lt;- rgb(#312200);\trgb nest_color const: true &lt;- rgb(#000000); \tgeometry shape &lt;- square(gridsize);\tinit {\t\t//Creation of the food places placed randomly with a certain distance between each\t\tloop times: number_of_food_places {\t\t\tpoint loc &lt;- { rnd(gridsize - 10) + 5, rnd(gridsize - 10) + 5 };\t\t\tlist&lt;ant_grid&gt; food_places &lt;- (ant_grid where ((each distance_to loc) &lt; 5));\t\t\task food_places {\t\t\t\tif food = 0 {\t\t\t\t\tfood &lt;- 5;\t\t\t\t\tfood_placed &lt;- food_placed + 5;\t\t\t\t\tcolor &lt;- food_color;  \t\t\t\t}                                           \t\t\t}\t\t}\t\t//Creation of the ants that will be placed in the nest\t\tcreate ant number: ants_number with: (location: center);\t}\t//Reflex to diffuse the pheromon among the grid\treflex diffuse {      diffuse var:road on:ant_grid proportion: diffusion_rate radius:3 propagation: gradient method:convolution;   }  }//Grid used to discretize the space to place foodgrid ant_grid width: gridsize height: gridsize neighbors: 8 frequency: grid_frequency use_regular_agents: false use_individual_shapes: false{\tbool is_nest const: true &lt;- (topology(ant_grid) distance_between [self, center]) &lt; 4;\tfloat road &lt;- 0.0 max: 240.0 update: (road &lt;= evaporation_per_cycle) ? 0.0 : road - evaporation_per_cycle;\trgb color &lt;- is_nest ? nest_color : ((food &gt; 0) ? food_color : ((road &lt; 0.001) ? background : rgb(#009900) + int(road * 5))) update: is_nest ? nest_color : ((food &gt; 0) ?\tfood_color : ((road &lt; 0.001) ? background : rgb(#009900) + int(road * 5)));\tint food &lt;- 0;}//Species ant that will move and follow a final state machinespecies ant skills: [moving] control: fsm {\tfloat speed &lt;- 1.0;\tbool has_food &lt;- false;\t\t//Reflex to place a pheromon stock in the cell\treflex diffuse_road when:has_food=true{      ant_grid(location).road &lt;- ant_grid(location).road + 100.0;   }\t//Action to pick food\taction pick (int amount) {\t\thas_food &lt;- true;\t\tant_grid place &lt;- ant_grid(location);\t\tplace.food &lt;- place.food - amount;\t}\t//Action to drop food\taction drop {\t\tfood_gathered &lt;- food_gathered + 1;\t\thas_food &lt;- false;\t\theading &lt;- heading - 180;\t}\t//Action to find the best place in the neighborhood cells\tpoint choose_best_place {\t\tcontainer list_places &lt;- ant_grid(location).neighbors;\t\tif (list_places count (each.food &gt; 0)) &gt; 0 {\t\t\treturn point(list_places first_with (each.food &gt; 0));\t\t} else {\t\t\tlist_places &lt;- (list_places where ((each.road &gt; 0) and ((each distance_to center) &gt; (self distance_to center)))) sort_by (each.road);\t\t\treturn point(last(list_places));\t\t}\t}\t//Reflex to drop food once the ant is in the nest\treflex drop when: has_food and (ant_grid(location)).is_nest {\t\tdo drop();\t}\t//Reflex to pick food when there is one at the same location\treflex pick when: !has_food and (ant_grid(location)).food &gt; 0 {\t\tdo pick(1);\t}\t//Initial state to make the ant wander \tstate wandering initial: true {\t\tdo wander(amplitude: 90);\t\tfloat pr &lt;- (ant_grid(location)).road;\t\ttransition to: carryingFood when: has_food;\t\ttransition to: followingRoad when: (pr &gt; 0.05) and (pr &lt; 4);\t}\t//State to carry food once it has been found\tstate carryingFood {\t\tdo goto(target: center);\t\ttransition to: wandering when: !has_food;\t}\t//State to follow a pheromon road if once has been found\tstate followingRoad {\t\tpoint next_place &lt;- choose_best_place();\t\tfloat pr &lt;- (ant_grid(location)).road;\t\tlocation &lt;- next_place;\t\ttransition to: carryingFood when: has_food;\t\ttransition to: wandering when: (pr &lt; 0.05) or (next_place = nil);\t}\taspect info {\t\tdraw circle(1) empty: !has_food color: #red;\t\tif (destination != nil) {\t\t\tdraw line([location + {0,0,0.5}, destination + {0,0,0.5}]) + 0.1 color: #white border: false;\t\t}\t\tdraw circle(4) empty: true color: #white;\t\tdraw string(self as int) color: #white font: font(\"Helvetica\", 12 * #zoom, #bold) at: my location - {1, 1, -0.5};\t\tdraw state color: #yellow  font: font(\"Helvetica\", 10 * #zoom, #plain) at: my location + { 1, 1, 0.5 } perspective: false;\t}\taspect icon {\t\tdraw ant_shape_empty size: {7,5} rotate: my heading + 1;\t}\taspect default {\t\tdraw square(1) empty: !has_food color: #blue rotate: my heading;\t}}\t//Simple experiment to display the antsexperiment Displays type: gui {\tpoint quadrant_size &lt;- { 0.5, 0.5 };\tfloat inc &lt;- 0.001;\tfloat pos &lt;- 0.0;\treflex moving_quadrant {\t//pos &lt;- pos + inc;\t\tif (pos &gt; 0.5 or pos &lt;= 0) {\t\t\tinc &lt;- -inc;\t\t}\t\t\t}\toutput {\t\tdisplay Ants background: #white type: opengl {\t\t\timage '../images/soil.jpg' position: { pos, pos } size: quadrant_size;\t\t\tagents \"agents\" transparency: 0.5 position: { pos, pos } size: quadrant_size value: (ant_grid as list) where ((each.food &gt; 0) or (each.road &gt; 0) or (each.is_nest));\t\t\tspecies ant position: { pos, pos } size: quadrant_size aspect: icon;\t\t\tgrid ant_grid lines: #darkgray position: { 0.5, 0 } size: quadrant_size;\t\t\tspecies ant position: { 0.5, 0 } size: quadrant_size aspect: info;\t\t}\t}}//Complete experiment that will inspect all ants in a tableexperiment Complete type: gui {\tparameter 'Number:' var: ants_number init: 100 unit: 'ants' category: 'Environment and Population';\tparameter 'Grid dimension:' var: gridsize init: 100 unit: '(number of rows and columns)' category: 'Environment and Population';\tparameter 'Number of food depots:' var: number_of_food_places init: 5 min: 1 category: 'Environment and Population';\t// Experimentator\tinit {\t\twrite \"Experimentator agent running \" + self;\t   ants_number &lt;- 200;\t}\toutput {\t\tdisplay Ants2D type: java2D {\t\t\timage '../images/soil.jpg' position: { 0.05, 0.05 } size: { 0.9, 0.9 };\t\t\tagents \"agents\" transparency: 0.7 position: { 0.05, 0.05 } size: { 0.9, 0.9 } value: (ant_grid as list) where ((each.food &gt; 0) or (each.road &gt; 0) or (each.is_nest)) ;\t\t\tspecies ant position: { 0.05, 0.05 } size: { 0.9, 0.9 } aspect: icon;\t\t\toverlay \"Texts\" transparency: 0.3 background: rgb (99, 85, 66,255)  position: {10°px, 10°px} size: {250°px, 150°px} border: rgb (99, 85, 66,255) rounded: true{\t\t\t\tdraw ant_shape_full at: {60°px, 70°px} size: {140°px, 100°px} rotate: -60;\t\t\t\tdraw ('Food foraged: ' + (((food_placed = 0 ? 0 : food_gathered / food_placed) * 100) with_precision 2) + '%') at: {40°px,70°px} font:font(\"Arial\", 18, #bold) color: #white;\t\t\t\tdraw ('Carrying ants: ' + (((100 * ant count (each.has_food or each.state = \"followingRoad\")) / length(ant)) with_precision 2) + '%') at: {40°px, 100°px} font:font(\"Arial\", 18 , #bold) color: #white;\t\t\t}\t\t\t\t\t\t\t}\t\tinspect \"All ants\" type: table value: ant attributes: ['name', 'location', 'heading','state'];\t}}//Batch experiment to find the best way to maximize the food gathered using exhaustive methodexperiment Batch type: batch repeat: 4 keep_seed: true until: (food_gathered = food_placed) or (time &gt; 1000) {\tparameter 'Size of the grid:' var: gridsize init: 75 unit: 'width and height';\tparameter 'Number:' var: ants_number among:[10,20,50] unit: 'ants';\tparameter  'Evaporation:' var: evaporation_per_cycle among: [0.1, 0.5, 2.0, 10.0] unit: 'units every cycle';\tparameter  'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.2;\tmethod exhaustive maximize: food_gathered;\t\tpermanent {\t\tdisplay Comparison background: #white {\t\t\tchart \"Food Gathered\" type: series {\t\t\t\t\tdata \"Min\" value:  min(ants_model collect each.food_gathered ) style: spline color: #darkgreen ;\t\t\t\t\tdata \"Max\" value:  max(ants_model collect each.food_gathered ) style: spline color: #red ;\t\t\t}\t\t}\t}}//Batch experiment to find the best way to maximize the food gathered using genetic methodexperiment Genetic type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed) or (time &gt; 1000) {\tparameter 'Size of the grid:' var: gridsize init: 75 unit: '(width and height)';\tparameter 'Number:' var: ants_number among:[10,20,50] unit: 'ants';\tparameter  'Evaporation:' var: evaporation_per_cycle among: [0.1, 0.5, 2.0, 10.0] unit: 'units every cycle';\tparameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.2;\tmethod genetic maximize: food_gathered pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 20;\t\t\tpermanent {\t\tdisplay Comparison background: #white {\t\t\tchart \"Food Gathered\" type: series {\t\t\t\t\tdata \"Min\" value:  min(ants_model collect each.food_gathered ) style: spline color: #darkgreen ;\t\t\t\t\tdata \"Max\" value:  max(ants_model collect each.food_gathered ) style: spline color: #red ;\t\t\t}\t\t}\t}}model Ants_couplingimport \"../../../Toy Models/Ants (Foraging and Sorting)/models/Ant Foraging (Complex).gaml\" experiment Ants_coupling_exp type:gui  parent:Complete{\t\tlist&lt;ant&gt; getAnts{\t\treturn list(ant);\t}\t\tlist&lt;ant_grid&gt; getAnt_grid{\t\treturn list(ant_grid);\t}\t\toutput{\t\t}}model PreyPredator global{\tgeometry shape &lt;- square(100);\tfloat perceipt_radius &lt;- 20.0;\tint preyinit &lt;- 500;\tint predatorinit &lt;- 3;\tlist&lt;agent&gt; lstPredator &lt;- list&lt;agent&gt;(predator);\tlist&lt;agent&gt; lstPrey &lt;- list&lt;agent&gt;(prey);\tinit\t{\t\tcreate prey number: preyinit;\t\tcreate predator number: predatorinit;\t\tlstPredator &lt;- list&lt;agent&gt;(predator);\t\tlstPrey &lt;- list&lt;agent&gt;(prey);\t}}species generic_species skills: [moving]{\tfloat speed &lt;- 1.0;\tpoint goal &lt;- nil;\tbool is_chased &lt;- false;\treflex live_with_my_goal\t{\t\tif (goal != nil)\t\t{\t\t\tdo wander speed: speed;\t\t\tdo goto target: goal speed: speed;\t\t} else\t\t{\t\t\tdo wander speed: speed;\t\t}\t}}species prey parent: generic_species{\tgeometry shape &lt;- circle(0.5);\tfloat speed &lt;- 0.2;\trgb color &lt;- # green;\treflex fleeing\t{\t\tif (length((lstPredator where (each != nil and !dead(each) and each distance_to self &lt; perceipt_radius))) &gt; 0)\t\t{\t\t\tspeed &lt;- 1.0;\t\t\tis_chased &lt;- true;\t\t\tcolor &lt;- # lime;\t\t\tif (goal = nil)\t\t\t{\t\t\t\tagent a &lt;- any(((lstPrey where (each != nil and !dead(each) and !generic_species(each).is_chased))));\t\t\t\tif (a != nil and !dead(a))\t\t\t\t{\t\t\t\t\tif (flip(0.5))\t\t\t\t\t{\t\t\t\t\t\tgoal &lt;- a.location;\t\t\t\t\t} else\t\t\t\t\t{\t\t\t\t\t\tgoal &lt;- any_location_in(world.shape);\t\t\t\t\t}\t\t\t\t} else\t\t\t\t{\t\t\t\t\tgoal &lt;- any_location_in(world.shape);\t\t\t\t}\t\t\t}\t\t}\t\tif (goal != nil and self.location distance_to goal &lt; 0.5)\t\t{\t\t\tgoal &lt;- nil;\t\t}\t\tif (length((lstPredator where (each != nil and !dead(each))) where (each distance_to self &lt;= perceipt_radius)) = 0)\t\t{\t\t\tis_chased &lt;- false;\t\t\tcolor &lt;- # green;\t\t\tspeed &lt;- 0.2;\t\t}\t}\taspect default\t{\t\tdraw shape color: color;\t}}species predator parent: generic_species{\tgeometry shape &lt;- triangle(2);\trgb color &lt;- # red;\treflex hunting\t{\t\tif (goal = nil)\t\t{\t\t\tlist tmp &lt;- (lstPrey where (!dead(each) and each.shape distance_to self.shape &lt; perceipt_radius));\t\t\tif (length(tmp) &gt; 0)\t\t\t{\t\t\t\tagent a &lt;- first(tmp sort (each.shape distance_to self.shape));\t\t\t\tif (a = nil)\t\t\t\t{\t\t\t\t\ta &lt;- any((lstPrey where (!dead(each))));\t\t\t\t}\t\t\t\tif (a != nil)\t\t\t\t{\t\t\t\t\tspeed &lt;- 2.0;\t\t\t\t\tgoal &lt;- a.location;\t\t\t\t}\t\t\t}\t\t} else if ((self.location distance_to goal &lt; 0.5))\t\t{\t\t\task lstPrey where (!dead(each) and each.location distance_to goal &lt; 0.5)\t\t\t{\t\t\t\tdo die;\t\t\t}\t\t\tgoal &lt;- nil;\t\t\tspeed &lt;- 1.0;\t\t}\t}\taspect default\t{\t\tdraw circle(perceipt_radius) color: # pink empty: true;\t\tdraw shape color: color rotate: 90 + my heading;\t}}experiment prey_predator_exp type: gui{\toutput\t{\t\tdisplay main_display\t\t{\t\t\tspecies prey;\t\t\tspecies predator;\t\t}\t}}model PreyPredator_couplingimport \"PreyPredator.gaml\"global{\t}experiment PreyPredator_coupling_exp parent:prey_predator_exp type: gui{geometry shape&lt;- square(100);\tlist&lt;prey&gt; getPrey{\t\treturn list(prey);\t}\t\tlist&lt;predator&gt; getPredator{\t\treturn list(predator);\t}\t\t//if we redefine the output, i.e, a blank output, the displays in parent experiement dont show.\toutput\t{\t}}Code of the model :model comodel_mix_behaviorsimport \"PreyPredator_coupling.gaml\" as myPreyPredatorimport \"Ants_coupling.gaml\" as myAntglobal{\t//set the shape of environment: square 100 \tgeometry shape &lt;- square(100);\t// the variable that refer to the ants population in micro-model \tlist&lt;agent&gt; theAnts;\t// the variable that refer to the prey population in micro-model\tlist&lt;prey&gt; thePreys;\t\tinit\t{\t\t//create the Ants micro-model with the size of grid is 100 and the population have 500 ants.\t\tcreate myAnt.Ants_coupling_exp with: [gridsize::100,ants_number::500];\t\t//create the PreyPredator micro-model with the parameters and the number of the prey is equal with the size of ants population\t\tcreate myPreyPredator.PreyPredator_coupling_exp with: [shape::square(100), preyinit::myAnt.Ants_coupling_exp[0].simulation.ants_number, predatorinit::3]  \t\t{\t\t\t// set the size of micro-model PreyPredator equal with the size of the grid of myAnt\t\t\tshape &lt;- square(100);\t\t}\t\t// save the original population of the Ants and the Preys\t\ttheAnts &lt;- myAnt.Ants_coupling_exp accumulate each.getAnts();\t\tthePreys &lt;- list&lt;prey&gt;(myPreyPredator.PreyPredator_coupling_exp accumulate each.getPrey());\t}\treflex simulate_micro_models\t{\t\t// ask myAnt do a step\t\task (myAnt.Ants_coupling_exp collect each.simulation)\t\t{\t\t\tdo _step_;\t\t}\t\t// ask myPreyPredator do a step, too\t\task (myPreyPredator.PreyPredator_coupling_exp collect each.simulation)\t\t{\t\t\tdo _step_;\t\t}\t\t//check if a Prey is chased, set the position of that agent to the location of prey \t\t//if not, set ant's location to agent location.\t\t// if the agent (prey) died, then tell the ant do die\t\tloop i from: 0 to: length(theAnts) - 1\t\t{\t\t\tif (!dead(thePreys at i) and !dead(theAnts at i))\t\t\t{\t\t\t\tif (!(thePreys at i).is_chased)\t\t\t\t{\t\t\t\t\t(thePreys at i).location &lt;- (theAnts at i).location;\t\t\t\t} else\t\t\t\t{\t\t\t\t\t(theAnts at i).location &lt;- (thePreys at i).location;\t\t\t\t}\t\t\t} else\t\t\t{\t\t\t\task (theAnts at i)\t\t\t\t{\t\t\t\t\tdo die;\t\t\t\t}\t\t\t}\t\t}\t}}experiment comodel_mix_behaviors_exp type: gui{\toutput\t{\t\tdisplay \"comodel\"\t\t{\t\t\tagents \"ant_grid\" value: myAnt.Ants_coupling_exp accumulate each.getAnt_grid() transparency: 0.7;\t\t\tagents \"agentprey\" value: (myPreyPredator.PreyPredator_coupling_exp accumulate each.getPrey());\t\t\tagents \"agentpredator\" value: (myPreyPredator.PreyPredator_coupling_exp accumulate each.getPredator());\t\t}\t}}",
        "url":"/wiki/Co-model-Usage-comodel_mix_behaviors.html"
      }
      ,
    
      "wiki-co-model-usage-comodel-mutate-population-html": {
        "title": "comodel_with_the_coupling",
        "content": "comodel_with_the_couplingAuthor : HUYNH Quang NghiThis is a simple comodel serve to demonstrate the importation and instatiation of micro-model  using the couplings  with the mutation the population of micro-model. A population can be a collection from itself and from other mircro-modelImported models :model PreyPredator global{\tgeometry shape &lt;- square(100);\tfloat perceipt_radius &lt;- 20.0;\tint preyinit &lt;- 500;\tint predatorinit &lt;- 3;\tlist&lt;agent&gt; lstPredator &lt;- list&lt;agent&gt;(predator);\tlist&lt;agent&gt; lstPrey &lt;- list&lt;agent&gt;(prey);\tinit\t{\t\tcreate prey number: preyinit;\t\tcreate predator number: predatorinit;\t\tlstPredator &lt;- list&lt;agent&gt;(predator);\t\tlstPrey &lt;- list&lt;agent&gt;(prey);\t}}species generic_species skills: [moving]{\tfloat speed &lt;- 1.0;\tpoint goal &lt;- nil;\tbool is_chased &lt;- false;\treflex live_with_my_goal\t{\t\tif (goal != nil)\t\t{\t\t\tdo wander speed: speed;\t\t\tdo goto target: goal speed: speed;\t\t} else\t\t{\t\t\tdo wander speed: speed;\t\t}\t}}species prey parent: generic_species{\tgeometry shape &lt;- circle(0.5);\tfloat speed &lt;- 0.2;\trgb color &lt;- # green;\treflex fleeing\t{\t\tif (length((lstPredator where (each != nil and !dead(each) and each distance_to self &lt; perceipt_radius))) &gt; 0)\t\t{\t\t\tspeed &lt;- 1.0;\t\t\tis_chased &lt;- true;\t\t\tcolor &lt;- # lime;\t\t\tif (goal = nil)\t\t\t{\t\t\t\tagent a &lt;- any(((lstPrey where (each != nil and !dead(each) and !generic_species(each).is_chased))));\t\t\t\tif (a != nil and !dead(a))\t\t\t\t{\t\t\t\t\tif (flip(0.5))\t\t\t\t\t{\t\t\t\t\t\tgoal &lt;- a.location;\t\t\t\t\t} else\t\t\t\t\t{\t\t\t\t\t\tgoal &lt;- any_location_in(world.shape);\t\t\t\t\t}\t\t\t\t} else\t\t\t\t{\t\t\t\t\tgoal &lt;- any_location_in(world.shape);\t\t\t\t}\t\t\t}\t\t}\t\tif (goal != nil and self.location distance_to goal &lt; 0.5)\t\t{\t\t\tgoal &lt;- nil;\t\t}\t\tif (length((lstPredator where (each != nil and !dead(each))) where (each distance_to self &lt;= perceipt_radius)) = 0)\t\t{\t\t\tis_chased &lt;- false;\t\t\tcolor &lt;- # green;\t\t\tspeed &lt;- 0.2;\t\t}\t}\taspect default\t{\t\tdraw shape color: color;\t}}species predator parent: generic_species{\tgeometry shape &lt;- triangle(2);\trgb color &lt;- # red;\treflex hunting\t{\t\tif (goal = nil)\t\t{\t\t\tlist tmp &lt;- (lstPrey where (!dead(each) and each.shape distance_to self.shape &lt; perceipt_radius));\t\t\tif (length(tmp) &gt; 0)\t\t\t{\t\t\t\tagent a &lt;- first(tmp sort (each.shape distance_to self.shape));\t\t\t\tif (a = nil)\t\t\t\t{\t\t\t\t\ta &lt;- any((lstPrey where (!dead(each))));\t\t\t\t}\t\t\t\tif (a != nil)\t\t\t\t{\t\t\t\t\tspeed &lt;- 2.0;\t\t\t\t\tgoal &lt;- a.location;\t\t\t\t}\t\t\t}\t\t} else if ((self.location distance_to goal &lt; 0.5))\t\t{\t\t\task lstPrey where (!dead(each) and each.location distance_to goal &lt; 0.5)\t\t\t{\t\t\t\tdo die;\t\t\t}\t\t\tgoal &lt;- nil;\t\t\tspeed &lt;- 1.0;\t\t}\t}\taspect default\t{\t\tdraw circle(perceipt_radius) color: # pink empty: true;\t\tdraw shape color: color rotate: 90 + my heading;\t}}experiment prey_predator_exp type: gui{\toutput\t{\t\tdisplay main_display\t\t{\t\t\tspecies prey;\t\t\tspecies predator;\t\t}\t}}model PreyPredator_couplingimport \"PreyPredator.gaml\"global{\t}experiment PreyPredator_coupling_exp parent:prey_predator_exp type: gui{geometry shape&lt;- square(100);\tlist&lt;prey&gt; getPrey{\t\treturn list(prey);\t}\t\tlist&lt;predator&gt; getPredator{\t\treturn list(predator);\t}\t\t//if we redefine the output, i.e, a blank output, the displays in parent experiement dont show.\toutput\t{\t}}Code of the model :model comodel_with_the_couplingimport \"PreyPredator_coupling.gaml\" as myPglobal{\t// set the shape of world as a rectangle 200 x 100\tgeometry shape &lt;- rectangle(200, 100);\tinit\t{\t\t//instantiate three instant of micro-model PreyPredator\t\tcreate myP.PreyPredator_coupling_exp with: [shape::square(100), preyinit::rnd(20), predatorinit::1] number: 3;\t\t\t\t//explicitly save the orginal population of predator and original population of prey of each micro-model\t\tlist&lt;agent&gt; lstpredator0 &lt;- myP.PreyPredator_coupling_exp[0].getPredator();\t\tlist&lt;agent&gt; lstprey0 &lt;- myP.PreyPredator_coupling_exp[0].getPrey();\t\t\t\tlist&lt;agent&gt; lstpredator1 &lt;- myP.PreyPredator_coupling_exp[1].getPredator();\t\tlist&lt;agent&gt; lstprey1 &lt;- myP.PreyPredator_coupling_exp[1].getPrey();\t\t\t\tlist&lt;agent&gt; lstpredator2 &lt;- myP.PreyPredator_coupling_exp[2].getPredator();\t\tlist&lt;agent&gt; lstprey2 &lt;- myP.PreyPredator_coupling_exp[2].getPrey();\t\t\t\t//mutate the popuplation of micro-model by assigning the list above to  the population of micro-models\t\t(myP.PreyPredator_coupling_exp[0].simulation).lstPredator &lt;- lstpredator2;\t\t(myP.PreyPredator_coupling_exp[1].simulation).lstPredator &lt;- lstprey2;\t\t(myP.PreyPredator_coupling_exp[2].simulation).lstPredator &lt;- lstprey1;\t\t\t\t\t\t(myP.PreyPredator_coupling_exp[0].simulation).lstPrey &lt;- lstprey0 + lstprey1;\t\t(myP.PreyPredator_coupling_exp[1].simulation).lstPrey &lt;- lstpredator1;\t\t(myP.PreyPredator_coupling_exp[2].simulation).lstPrey &lt;- lstpredator0 + lstprey2;\t\t\t\t//change the shape correspond with the new role of agent in the new populations\t\task (myP.PreyPredator_coupling_exp accumulate each.simulation.lstPredator)\t\t{\t\t\tshape &lt;- triangle(2);\t\t}\t\task (myP.PreyPredator_coupling_exp accumulate each.simulation.lstPrey)\t\t{\t\t\tshape &lt;- circle(0.5);\t\t}\t}\treflex simulate_micro_models\t{\t\t// ask all simulation do their job\t\task (myP.PreyPredator_coupling_exp collect each.simulation)\t\t{\t\t\tdo _step_;\t\t}\t}}experiment comodel_with_the_coupling_exp type: gui{\toutput\t{\t\t//a mixing display of all agents from all populations\t\tdisplay \"comodel\"\t\t{\t\t\tagents \"agentprey\" value: (myP.PreyPredator_coupling_exp accumulate each.getPrey());\t\t\tagents \"agentpredator\" value: (myP.PreyPredator_coupling_exp accumulate each.getPredator());\t\t}\t}}",
        "url":"/wiki/Co-model-Usage-comodel_mutate_population.html"
      }
      ,
    
      "wiki-co-model-usage-comodel-simple-html": {
        "title": "Simple syntax demonstration of Comodeling",
        "content": "Simple syntax demonstration of ComodelingAuthor : HUYNH Quang NghiThis is a simple comodel serve to demonstrate the importation and instatiation of micro-model without using the couplingsImported models :model M2global{\tint n &lt;- 4;\tinit\t{\t\tcreate B number: n;\t}}species B skills: [moving]{\tint IQ &lt;- rnd(100);\treflex dolive\t{\t\twrite \"\" + \"i'm alive !!\";\t\tdo wander;\t}\taspect default\t{\t\tdraw square(1) color: # red;\t}}experiment M2_exp type: gui{\toutput\t{\t\tdisplay \"m2_disp\"\t\t{\t\t\tspecies B aspect: default;\t\t}\t}}model M1global{\tint n &lt;- 8;\tinit\t{\t\tcreate A number: n;\t}}species A skills: [moving]{\tint IQ &lt;- rnd(100);\treflex dolive\t{\t\twrite \"\" + \"i'm alive !!\";\t\tdo wander;\t}\taspect default\t{\t\tdraw square(1) color: # green;\t}}experiment M1_exp type: gui{\toutput\t{\t\tdisplay \"m1_disp\"\t\t{\t\t\tspecies A aspect: default;\t\t}\t}}Code of the model :model Comodel_simpleimport \"m1.gaml\" as micro_model_1import \"m2.gaml\" as micro_model_2global{\tinit\t{\t//micro_model must be instantiated by create statement. We create an experiment inside the micro-model and the simulation will be created implicitly (1 experiment have only 1 simulation).\t\tcreate micro_model_1.M1_exp number: 5;\t\tcreate micro_model_2.M2_exp;\t}\treflex simulate_micro_models\t{\t//tell the first experiment of micro_model_1 do 1 step;\t\task first(micro_model_1.M1_exp).simulation\t\t{\t\t\tdo _step_;\t\t}\t\t//tell the  experiment at 3 of micro_model_1 do 1 step;\t\task (micro_model_1.M1_exp at 3).simulation\t\t{\t\t\tdo _step_;\t\t}\t\t//tell all experiments of micro_model_1 do 1 step;\t\task (micro_model_1.M1_exp collect each.simulation)\t\t{\t\t\tdo _step_;\t\t}\t\t//tell all experiments of micro_model_2 do 1 step;\t\task (micro_model_2.M2_exp collect each.simulation)\t\t{\t\t\tdo _step_;\t\t}\t\t\t\t//kill simulation  of micro_model and recreate then\t\task  (micro_model_2.M2_exp collect each.simulation){\t\t\tdo die;\t\t}\t\task (micro_model_2.M2_exp){\t\t\tcreate simulation{do _init_;}\t\t}\t}}experiment Comodel_simple_exp type: gui{}",
        "url":"/wiki/Co-model-Usage-comodel_simple.html"
      }
      ,
    
      "wiki-co-model-usage-comodel-with-the-coupling-html": {
        "title": "comodel_with_the_coupling",
        "content": "comodel_with_the_couplingAuthor : HUYNH Quang NghiThis is a simple comodel serve to demonstrate the importation and instatiation of micro-model using the couplingsImported models :model M2global{\tint n &lt;- 4;\tinit\t{\t\tcreate B number: n;\t}}species B skills: [moving]{\tint IQ &lt;- rnd(100);\treflex dolive\t{\t\twrite \"\" + \"i'm alive !!\";\t\tdo wander;\t}\taspect default\t{\t\tdraw square(1) color: # red;\t}}experiment M2_exp type: gui{\toutput\t{\t\tdisplay \"m2_disp\"\t\t{\t\t\tspecies B aspect: default;\t\t}\t}}model M2_couplingimport \"m2.gaml\"global{}experiment M2_coupling_exp parent:M2_exp type: gui{\tlist&lt;B&gt; getB{\t\treturn list(B);\t}\t\t//if we redefine the output, i.e, a blank output, the displays in parent experiement dont show.\toutput\t{\t}}model M1global{\tint n &lt;- 8;\tinit\t{\t\tcreate A number: n;\t}}species A skills: [moving]{\tint IQ &lt;- rnd(100);\treflex dolive\t{\t\twrite \"\" + \"i'm alive !!\";\t\tdo wander;\t}\taspect default\t{\t\tdraw square(1) color: # green;\t}}experiment M1_exp type: gui{\toutput\t{\t\tdisplay \"m1_disp\"\t\t{\t\t\tspecies A aspect: default;\t\t}\t}}model M1_couplingimport \"m1.gaml\"global{}experiment M1_coupling_exp parent:M1_exp type: gui{\tlist&lt;A&gt; getA{\t\treturn list(A);\t}\t\t//if we redefine the output, i.e, a blank output, the displays in parent experiement dont show.\toutput\t{\t}}Code of the model :model comodel_with_the_couplingimport \"m1_coupling.gaml\" as micro_model_1import \"m2_coupling.gaml\" as micro_model_2global{\tgeometry shape&lt;-envelope(square(100));\tinit{\t\t//micro_model must be instantiated by create statement. We create an experiment inside the micro-model and the simulation will be created implicitly (1 experiment have only 1 simulation).\t\tcreate micro_model_1.M1_coupling_exp;\t\tcreate micro_model_2.M2_coupling_exp number:5;\t}\treflex simulate_micro_models{\t\t\t\t//tell all experiments of micro_model_1 do 1 step;\t\task (micro_model_1.M1_coupling_exp collect each.simulation){\t\t\tdo _step_;\t\t}\t\t\t\t//tell the first experiment of micro_model_2 do 1 step;\t\task (micro_model_2.M2_coupling_exp collect each.simulation){\t\t\tdo _step_;\t\t}\t}}experiment comodel_with_the_coupling type: gui{\toutput{\t\tdisplay \"comodel\" {\t\t\t//to display the agents of micro-models, we use the agent layer with the values come from the coupling.\t\t\tagents \"agentA\" value:first(micro_model_1.M1_coupling_exp).getA();\t\t\tagents \"agentB\" value:first(micro_model_2.M2_coupling_exp).getB();\t\t}\t}}",
        "url":"/wiki/Co-model-Usage-comodel_with_the_coupling.html"
      }
      ,
    
      "wiki-co-model-usage-html": {
        "title": "Co-model Usage",
        "content": "Co-model UsageThis sub-section is composed of the following models :      comodel with mixed behaviors         comodel_with_the_coupling        Simple syntax demonstration of Comodeling         comodel_with_the_coupling  ",
        "url":"/wiki/Co-model-Usage.html"
      }
      ,
    
      "wiki-color-bubble-sort-3d-html": {
        "title": "Creating color and sort cubes by color",
        "content": "Creating color and sort cubes by colorAuthor :  Arnaud GrignardA model to show how to create color by using the rgb operator, the color depending on the position of cube in the xyz space. The cubes are randomly mixed to finally be sorted according to the color of each vertix of the whole big cube, using the bubble sort algorithm (https://en.wikipedia.org/wiki/Bubble_sort).Code of the model :model bubblesort3Dglobal {//Number of cubes by faces of the whole big cubeint nb_cells&lt;-15;geometry shape &lt;- cube(nb_cells) ;bool change &lt;- true;init {\t//We create nb_cells^3 cubes and we define their color depending on their position in XYZ\tloop i from:0 to:nb_cells-1{\t\tloop j from:0 to: nb_cells-1{\t\t\tloop k from:0 to:nb_cells-1{\t\t\t  create cells{\t\t\t\tlocation &lt;-{i mod nb_cells,j mod nb_cells, k mod nb_cells};\t\t\t\t\t\t\t\t//The canal RGB limit color to 255 by canal\t\t\t\tred &lt;- float((i mod nb_cells)* int(255 / nb_cells));\t\t\t\tgreen &lt;- float((j mod nb_cells) * int(255 / nb_cells));\t\t\t\tblue &lt;- float((k mod nb_cells) * int(255 / nb_cells));\t\t\t\t\t\t\t\t//We create the color according to the value of the red, green and blue canals\t\t\t\tcolor &lt;- rgb(red,green,blue);\t\t\t  }\t\t\t\t}\t\t    }\t}\t\t//We mix all the cubes randomly by permuting two randomly chosen cubes\tloop times: 10000 {\t\t\task one_of(cells) {\t\t\t\tcells one_cells &lt;- one_of(cells);\t\t\t\tif (self != one_cells) {\t\t\t\t\tpoint loc &lt;- copy(location);\t\t\t\t\tlocation &lt;- one_cells.location;\t\t\t\t\tone_cells.location &lt;- loc;\t\t\t\t}\t\t\t}\t\t}\t\t\t}//Reflex to finish the execution of the model when nothing has changed during the cyclereflex end {\tif (not change) {\t\tdo pause;\t\t} \tchange &lt;- false;\t}}species cells{\trgb color;\tfloat red;\tfloat green;\tfloat blue;\tlist&lt;cells&gt; neigbhours update: cells at_distance (1.1);\t\t//Update of the neighbours cubes at each cycle of the simulation according to their location\tcells upper_cell_y update: neigbhours first_with (shape.location.y &gt; each.shape.location.y);\tcells upper_cell_x update: neigbhours first_with (shape.location.x &gt; each.shape.location.x);\tcells upper_cell_z update: neigbhours first_with (shape.location.z &gt; each.shape.location.z);\t\t//We permute the cube agent with its neighbour if its intensity is greater according to the canal related to its axis (z for canal blue, y for green and x for red)\treflex swap_z when: upper_cell_z != nil and blue &lt; upper_cell_z.blue{ \t\tpoint tmp1Loc &lt;-location;\t\tlocation &lt;- upper_cell_z.location;      \tupper_cell_z.location&lt;-tmp1Loc; \t\t    change &lt;- true;\t    }\t\treflex swap_y when: upper_cell_y != nil and green &lt; upper_cell_y.green{ \t\tpoint tmp1Loc &lt;-location;\t\tlocation &lt;- upper_cell_y.location;      \tupper_cell_y.location&lt;-tmp1Loc; \t\t    change &lt;- true;\t    }        reflex swap_x when: upper_cell_x != nil and red &lt; upper_cell_x.red{ \t\tpoint tmp1Loc &lt;-location;\t\tlocation &lt;- upper_cell_x.location;      \tupper_cell_x.location&lt;-tmp1Loc; \t\t    change &lt;- true;\t    }\taspect default {\t\tdraw cube(1) color:color border:color at:location;\t}\t}experiment Display type: gui {\toutput {\t\tdisplay View1 type:opengl draw_env:false{\t\t\tspecies cells transparency:0.1;\t\t\tgraphics \"di\"{\t\t\t draw \"black(0,0,0)\" at:{0,0,0} color:°black perspective:false;\t\t\t draw \"red(1,0,0)\" at:{world.shape.width,0,0} color:°red perspective:false;\t\t\t draw \"green(0,1,0)\" at:{0,world.shape.height,0} color:°green perspective:false;\t\t\t draw \"blue(0,0,1)\" at:{0,0,world.shape.width} color:°blue perspective:false;\t\t\t draw \"yellow(1,1,0)\" at:{world.shape.width,world.shape.height,0} color:°yellow perspective:false;\t\t\t draw \"magenta(1,0,1)\" at:{world.shape.width,0,world.shape.depth} color:°magenta perspective:false;\t\t\t draw \"cyan(0,1,1)\" at:{0,world.shape.height,world.shape.depth} color:°cyan perspective:false;\t\t\t draw \"white(1,1,1)\" at:{world.shape.width,world.shape.height,world.shape.depth} color:°white perspective:false;\t\t\t\t}\t\t}\t}}",
        "url":"/wiki/Color-Bubble-Sort-3D.html"
      }
      ,
    
      "wiki-color-color-brewer-html": {
        "title": "Color defined by choosing a Color Brewer",
        "content": "Color defined by choosing a Color BrewerAuthor :  Arnaud Grignard &amp; Patrick TaillandierA model to show how to use color brewer. In this model, two experiments are presents : one just to show the different colors present in some selected brewer, and a second one to show in a grid the different colors of brewler having at least a minimal number of colors passed in parameter.Code of the model :model ColorBrewerglobal {//number of colorsint nb_classes&lt;-14 min:5 max: 15;int square_size &lt;- 10;//list of palettes that have at least nb_classeslist&lt;string&gt; palettes &lt;- brewer_palettes(nb_classes);//the current sequential palette from the list of all available sequential Palettesstring sequentialPalette &lt;- \"YlOrRd\" among:[\"YlOrRd\",\"Grays\",\"PuBu\",\"BuPu\",\"YlOrBr\",\"Greens\",\"BuGn\",\"GnBu\",\"PuRd\",\"Purples\",\"Blues\",\"Oranges\",\"OrRd\",\"Reds\",\"YlGn\",\"YlGnBu\"];//the current diverging palette from the list of all available diverging Palettesstring divergingPalette &lt;- \"BrBG\" among:[\"PRGn\",\"PuOr\",\"RdGy\",\"Spectral\",\"RdYlGn\",\"RdBu\",\"RdYlBu\",\"PiYG\",\"BrBG\"];//the current qualitative palette from the list of all available qualitative Palettesstring qualitativePalette &lt;- \"Pastel1\" among:[\"Accents\",\"Paired\",\"Set3\",\"Set2\",\"Set1\",\"Dark2\",\"Pastel2\",\"Pastel1\"];//build the lists of colors from the paletteslist&lt;rgb&gt; SequentialColors&lt;-list&lt;rgb&gt;(brewer_colors(sequentialPalette));list&lt;rgb&gt; DivergingColors&lt;-list&lt;rgb&gt;(brewer_colors(divergingPalette));list&lt;rgb&gt; QualitativeColors&lt;-list&lt;rgb&gt;(brewer_colors(qualitativePalette));\tinit {\t\t//if the palettes is not empty\t\tif (not empty(palettes)) {\t\t\t//for each palette\t\t\tloop i from: 0 to: length(palettes) - 1 {\t\t\t\t//define a  list of nb_classes colors from the current palette\t\t\t\tlist&lt;rgb&gt; colors&lt;-list&lt;rgb&gt;(brewer_colors(palettes[i],nb_classes));\t\t\t\t\t\t\t\t//define the colors of the corresponding cells\t\t\t\task cell where (each.grid_y = i){\t\t\t\t\tcolor &lt;- colors[grid_x,i];\t\t\t\t\t}\t\t\t}\t\t}\t}}grid cell width:nb_classes height: max([1,length(palettes)]) ;//in this experiment, we do not use the cell agents, but we directlty draw the different palettes of colorsexperiment BrewerPalette type: gui {\tparameter \"Sequential Palettes\" var:sequentialPalette category:\"Brewer\";\tparameter \"Diverging Palettes\" var:divergingPalette category:\"Brewer\";\tparameter \"Qualitatives Palettes\" var:qualitativePalette category:\"Brewer\";\toutput {\t\tdisplay View1 type:opengl draw_env:false{\t\t\tgraphics \"brewer\"{\t\t\t\t//Sequential\t\t\t\tdraw \"Sequential\" at:{-world.shape.width*0.2,0} color:°black perspective:true;\t\t\t\tloop i from:0 to:length(SequentialColors)-1{\t\t\t\t\tdraw square(square_size) color:SequentialColors[i] at: {square_size*(0.5 + i), 0, 0};\t\t\t\t}\t\t\t\t//Diverging\t\t\t\tloop i from:0 to:length(DivergingColors)-1{\t\t\t\t\tdraw \"Diverging\" at:{-world.shape.width*0.2,1*square_size} color:°black perspective:false;\t\t\t\t\tdraw square(square_size) color:DivergingColors[i] at: {square_size*(0.5 + i), 1*square_size, 0};\t\t\t\t}\t\t\t\t//Qualitative\t\t\t\t\t\tloop i from:0 to:length(QualitativeColors)-1{\t\t\t\t\tdraw \"Qualitative\" at:{-world.shape.width*0.2,2*square_size} color:°black perspective:false;\t\t\t\t\tdraw square(square_size) color:QualitativeColors[i] at: {square_size*(0.5 + i), 2*square_size, 0};\t\t\t\t}\t\t    }\t\t}\t\t}}//in this experiment, we display the cell agents with the  different aspectsexperiment BrewerColoredAgent type: gui {\tparameter \"Number of data classes\" var:nb_classes category:\"Brewer\";\toutput {\t\tdisplay View1 {\t\t\tgrid cell lines: #black ;\t\t}\t\t}}",
        "url":"/wiki/Color-Color-Brewer.html"
      }
      ,
    
      "wiki-color-rgb-to-xyz-html": {
        "title": "RGB color to XYZ position",
        "content": "RGB color to XYZ positionAuthor :  Arnaud GrignardA model to show how to convert rgb values in xyz position using the operator rgb_to_xyz. Each pixel of a given image is used to create a point with its coordinates depending on its color : red value for x coordinate, green value for y coordinate and blue value for the z coordinate.Code of the model :model rgbCubeglobal {\t//import an image\tfile imageRaster &lt;- file('images/RGB.jpg');\t\t//list of points  create from the image \tlist&lt;point&gt; p;\t\t//geometry of the world (environment)\tgeometry shape &lt;- square(255);\t\t//create the list of points from the image: a point is defined per pixel, its coordinate correspond to the value of the red,green,blue color\tinit {\t\tp &lt;- list&lt;point&gt; (rgb_to_xyz(imageRaster));\t}}experiment Display type: gui {\toutput {\t\tdisplay RGB_to_XYZ type: opengl { \t\t\timage imageRaster.path refresh: false;\t\t\tgraphics \"pts\" refresh: false{\t\t\t\tloop pt over: p {\t\t\t\t\tdraw cube(1) at: pt color: rgb(pt.x, pt.y, pt.z);\t\t\t\t}\t\t\t}\t\t}\t}}",
        "url":"/wiki/Color-RGB-to-XYZ.html"
      }
      ,
    
      "wiki-color-html": {
        "title": "Color",
        "content": "ColorThis sub-section is composed of the following models :      Creating color and sort cubes by color        Color defined by choosing a Color Brewer        RGB color to XYZ position  ",
        "url":"/wiki/Color.html"
      }
      ,
    
      "wiki-comodel-html": {
        "title": "Using Comodel",
        "content": "Using ComodelIntroductionIn the trend of developing complex system of multi-disciplinary, composing and coupling models are days by days become the most attractive research objectives. GAMA is supporting the co-modelling and co-simulation which are suppose to be the common coupling infrastructure.Example of a ComodelA Comodel is a model, especially an multi-agent-based, compose several sub-model, called micro-model. A comodel itself could be also a micro-model of an other comodel. From the view of a micro-model, comodel is called a macro-model.A micro-model must be import, instantiate, and life-control by macro-model.Why and when can we use Comodel ?to be completed…Use of Comodel in a GAML modelThe GAML language has been evolve by extend the import section. The old importation tell the compiler to merge all imported elements into as one model, but the new one allows modellers to keep the elements come from imported models separately with the caller model.Defining a micro-modelDefining a micro-model of comodel is to import an existing model with an alias name. The syntax is:import &lt;path to the GAML model&gt; as &lt;identifier&gt;The identifier is then become the new name of the micro-model.Instantiate a micro-modelAfter the importation and giving an identifier, micro-model must be explicitly instantiated. It could be done by create statement.create &lt;micro-model identifier&gt; . &lt;experiment name&gt; [optional parameter];THe  is an expriment inside micro-model. This syntax will generate an experiment agent and attach an implicitly simulation.Note: Creation of multi-instant is not create multi-simulation, but multi-experiment. Modellers could create a experiment with multi-simulation by explicitly do the init inside the experiment scope.Control micro-model life-cycleA micro-model can be control as the normal agent by asking the correspond identifier, and also be destroy by the ‘o die’ statement. As fact, it can be recreate any time we need.ask (&lt;micro-model identifier&gt; . &lt;experiment name&gt;  at &lt;number&gt; ) . simulation {\t\t...}Visualize micro-modelThe micro-model species could display in comodel with the support of agent layeragents \"name of layer\" value: (&lt;micro-model&gt; . &lt;experiment name&gt; at &lt;number&gt;).&lt;get List of agents&gt;;More detailsExample of the comodelUrbanization model with Traffic modelFlood model with Evacuation modelReusing of  two existing models:Flood Simulation and Evacuation.Toy Models/Evacuation/models/continuous_move.gamlToy Models/Flood Simulation/models/Hydrological Model.gamlThe comodel explore the effect of flood on evacuation plan:Simulation results:",
        "url":"/wiki/Comodel.html"
      }
      ,
    
      "wiki-contribute-html": {
        "title": "Contribute",
        "content": "ContributeSince GAMA is a free opensource software, we are proud to share the source code with anyone who wants to contribute to the platform. Note that GAMA is easy to extand through the use of additionnal plugins.Table of content  Developer documentation  Source code  GAMA Dev mailing list  Developers  Citing GAMADeveloper documentationA more complete documentation exists on Github at the following address : https://github.com/gama-platform/gama/wiki. You can find here the last updated version of the documentation (the documentation of the latest git version), and also a developer documentation (which is not available in the “regular” website).Source CodeGAMA can be downloaded as a regular application or built from source, which is necessary if you want to contribute to the platform.The source code is available from this GITHub repository:https://github.com/gama-platform/gamaWhich you can also browse from the web here.It is, in any case, recommended to follow the instructions on this page in order to build GAMA from source.GAMA Dev mailing listIf you want to contribute to the platform, you can send a request to the developping team to be in the gama-dev@googlegroups.com mailing list.DevelopersGAMA is being designed, developed and maintained by an active group of researchers coming from different institutions in France and Vietnam. Please find below a short introduction to each of them and a summary of their contributions to the platform:  Alexis Drogoul, Senior Researcher at the IRD, member of the UMMISCO International Research Unit. Mostly working on agent-based modeling and simulation. Has contributed and still contributes to the original design of the platform, including the GAML language (from the meta-model to the editor) and simulation facilities like Java2D displays.  Patrick Taillandier, Associate Professor at the University of Rouen, member of the IDEES CNRS Mixed Research Unit. Contributes since 2008 to the spatial and graph features (GIS integration, spatial operators) and to parameter space search algorithms. Currently working on new features related to graphical modeling and traffic simulation.  Benoit Gaudou, Associate Professor at the University Toulouse 1 Capitole, member of the IRIT CNRS Mixed Research Unit. Contributes since 2010 to documentation and unit test generation and coupling mathematical (ODE and PDE) and agent paradigms.  Arnaud Grignard, software engineer and PhD fellow (PDI-MSC) at UPMC. Contributes since 2011 to the development of new features related to visualization (3D Display), online analysis and interaction.  Huynh Quang Nghi, software engineering lecturer at CTU and PhD fellow (PDI-MSC) at UPMC. Contributes since 2012 to the development of new features related to GAML parser, coupling formalisms in EBM-ABM and ABM-ABM.  Truong Minh Thai, software engineering lecturer at CTU and PhD fellow (PRJ322-MOET) at IRIT-UT1. Contributes since 2012 to the development of new features related to data management and analysis.  Nicolas Marilleau, Researcher at the IRD, member of the UMMISCO International Research Unit and associate researcher at DISC team of FEMTO-ST institute. Contributes since 2010 to the development of headless mode and the high performance computing module.  Philippe Caillou, Associate professor at the University Paris Sud 11, member of the LRI and INRIA project-team TAO. Contributes since 2012 and actually working on charts, simulation analysis and BDI agents.  Vo Duc An, Post-doctoral Researcher, working on synthetic population generation in agent-based modelling, at the UMMISCO International Research Unit of the IRD. Has contributed to bringing the platform to the Eclipse RCP environment and to the development of several features (e.g., the FIPA-compliant agent communication capability, the multi-level architecture).  Truong Xuan Viet, software engineering lecturer at CTU and PhD fellow (PDI-MSC) at UPMC. Contributes since 2011 to the development of new features related to R caller, online GIS (OPENGIS: Web Map Service - WMS, Web Feature Services - WMS, Google map, etc).          Samuel Thiriot      Citing GAMAIf you use GAMA in your research and want to cite it (in a paper, presentation, whatever), please use this reference:  A. Grignard, P. Taillandier, B. Gaudou, D-A. Vo, N-Q. Huynh, A. Drogoul (2013), GAMA 1.6: Advancing the Art of Complex Agent-Based Modeling and Simulation. In ‘PRIMA 2013: Principles and Practice of Multi-Agent Systems’, Lecture Notes in Computer Science, Vol. 8291, Springer, pp. 117-131.or you can choose to cite the website instead:  GAMA Platform website, http://gama-platform.orgA complete list of references (papers and PhD theses on or using GAMA) is available on the references page.",
        "url":"/wiki/Contribute.html"
      }
      ,
    
      "wiki-controlarchitecture-html": {
        "title": "Control Architectures",
        "content": "Control ArchitecturesGAMA allows to attach built-in control architecture to agents.These control architectures will give the possibility to the modeler to use for a species a specific control architecture in addition to the common behavior structure. Note that only one control architecture can be used per species.The attachment of a control architecture to a species is done through the facets control.For example, the given code allows to attach the fsm control architecture to the dummy species.species dummy control: fsm {}GAMA integrates several agent control architectures that can be used in addition to the common behavior structure:  fsm: finite state machine based behavior model. During its life cycle, the agent can be in several states. At any given time step, it is in one single state. Such an agent needs to have one initial state (the state in which it will be at its initialization)  weighted_tasks: task-based control architecture. At any given time, only the task only the task with the maximal weight is executed.  sorted_tasks: task-based control architecture. At any given time, the tasks are all executed in the order specified by their weights (highest first).  probabilistic_tasks: task-based control architecture. This architecture uses the weights as a support for making a weighted probabilistic choice among the different tasks. If all tasks have the same weight, one is randomly chosen at each step.  user_only: allows users to take control over an agent during the course of the simulation. With this architecture, only the user control the agents (no reflexes).  user_first: allows users to take control over an agent during the course of the simulation. With this architecture, the user actions are executed before the agent reflexes.  user_last: allows users to take control over an agent during the course of the simulation. With this architecture, the user actions are executed after the agent reflexes.Index  Finite State Machine          Declaration      State        Task Based          Declaration      Task        User Control Architecture          user_only, user_first, user_last      user_panel      user_controlled        Other Control ArchitecturesFinite State MachineFSM (Finite State Machine) is a finite state machine based behavior model. During its life cycle, the agent can be in several states. At any given time step, it is in one single state. Such an agent needs to have one initial state (the state in which it will be at its initialization).At each time step, the agent will:  first (only if he just entered in its current state) execute statement embedded in the enter statement,  then all the statements in the state statement  it will evaluate the condition of each embedded transition statements. If one condition is fulfilled, the agent execute the embedded statementsNote that an agent executes only one state at each step.DeclarationUsing the FSM architecture for a species require to use the control facet:species dummy control: fsm {   ...}StateAttributes  initial: a boolean expression, indicates the initial state of agent.  final: a boolean expression, indicates the final state of agent.Sub Statements  enter: a sequence of statements to execute upon entering the state.  exit: a sequence of statements to execute right before exiting the state. Note that the exit statement will be executed even if the fired transition points to the same state (the FSM architecture in GAMA does not implement ‘internal transitions’ like the ones found in UML state charts: all transitions, even “self-transitions”, follow the same rules).  transition: allows to define a condition that, when evaluated to true, will designate the next state of the life cycle. Note that the evaluation of transitions is short-circuited: the first one that evaluates to true, in the order in which they have been defined, will be followed. I.e., if two transitions evaluate to true during the same time step, only the first one will be triggered.Things worth to be mentioned regarding these sub-statements:  Obviously, only one definition of exit and enter is accepted in a given state  Transition statements written in the middle of the state statements will only be evaluated at the end, so, even if it evaluates to true, the remaining of the statements found after the definition of the transition will be nevertheless executed. So, despite the appearance, a transition written somewhere in the sequence will “not stop” the state at that point (but only at the end).DefinitionA state can contain several statements that will be executed, at each time step, by the agent. There are three exceptions to this rule:  statements enclosed in enter will only be executed when the state is entered (after a transition, or because it is the initial state).  Those enclosed in exit will be executed when leaving the state as a result of a successful transition (and before the statements enclosed in the transition).  Those enclosed in a transition will be executed when performing this transition (but after the exit sequence has been executed).For example, consider the following example:species dummy control: fsm {       \tstate state1 initial: true { \t\twrite string(cycle) + \":\" + name + \"-&gt;\" + \"state1\";\t\ttransition to: state2 when: flip(0.5) {\t\t\twrite string(cycle) + \":\" + name + \"-&gt;\" + \"transition to state1\";\t\t}\t\ttransition to: state3 when: flip(0.2) ; \t}\tstate state2 {\t\twrite string(cycle) + \":\" + name + \"-&gt;\" + \"state2\";\t\ttransition to: state1 when: flip(0.5) { \t\t\twrite string(cycle) + \":\" + name + \"-&gt;\" + \"transition to state1\";\t\t}\t\texit {\t\t\twrite string(cycle) + \":\" + name + \"-&gt;\" + \"leave state2\";\t\t}\t}\t\tstate state3 {\t\twrite string(cycle) + \":\" + name + \"-&gt;\" + \"state3\";\t\ttransition to: state1 when: flip(0.5)  {\t\t\twrite string(cycle) + \":\" + name + \"-&gt;\" + \"transition to state1\";\t\t}\t\ttransition to: state2 when: flip(0.2)  ;\t}   }the dummy agents start at state1. At each simulation step they have a probability of 0.5 to change their state to state2. If they do not change their state to state2, they have a probability of 0.2 to change their state to state3. In state2, at each simulation step, they have a probability of 0.5 to change their state to state1. At last, in step3, at each simulation step they have a probability of 0.5 to change their state to state1. If they do not change their state to state1, they have a probability of 0.2 to change their state to state2.Here a possible result that can be obtained with one dummy agent:0:dummy0-&gt;state10:dummy0-&gt;transition to state11:dummy0-&gt;state22:dummy0-&gt;state22:dummy0-&gt;leave state22:dummy0-&gt;transition to state13:dummy0-&gt;state13:dummy0-&gt;transition to state14:dummy0-&gt;state25:dummy0-&gt;state25:dummy0-&gt;leave state25:dummy0-&gt;transition to state16:dummy0-&gt;state17:dummy0-&gt;state38:dummy0-&gt;state2Task BasedGAMA integrated several task-based control architectures. Species can define any number of tasks within their body. At any given time, only one or several tasks are executed according to the architecture chosen:  weighted_tasks : in this architecture, only the task with the maximal weight is executed.  sorted_tasks : in this architecture, the tasks are all executed in the order specified by their weights (biggest first)  probabilistic_tasks: this architecture uses the weights as a support for making a weighted probabilistic choice among the different tasks. If all tasks have the same weight, one is randomly chosen each step.DeclarationUsing the Task architectures for a species require to use the control facet:species dummy control: weighted_tasks {   ...}species dummy control: sorted_tasks {   ...}species dummy control: probabilistic_tasks {   ...}TaskSub elementsBesides a sequence of statements like reflex, a task contains the following sub elements:  weight: Mandatory. The priority level of the task.DefinitionAs reflex, a task is a sequence of statements that can be executed, at each time step, by the agent. If an agent owns several tasks, the scheduler chooses a task to execute based on its current priority weight value.For example, consider the following example:species dummy control: weighted_tasks {   \ttask task1 weight: cycle mod 3 { \t\twrite string(cycle) + \":\" + name + \"-&gt;\" + \"task1\";\t}\ttask task2 weight: 2 { \t\twrite string(cycle) + \":\" + name + \"-&gt;\" + \"task2\";\t}}As the weighted_tasks control architecture was chosen, at each simulation step, the dummy agents execute only the task with the highest behavior. Thus,  when cycle modulo 3 is higher to 2, task1 is executed; when cycle modulo 3 is lower than 2, task2 is executed. In case when cycle modulo 3 is equal 2 (at cycle 2, 5, …), the only the first task defined (here task1) is executed.Here the result obtained with one dummy agent:0:dummy0-&gt;task21:dummy0-&gt;task22:dummy0-&gt;task13:dummy0-&gt;task24:dummy0-&gt;task25:dummy0-&gt;task16:dummy0-&gt;task2User Control Architectureuser_only, user_first, user_lastA specific type of control architecture has been introduced to allow users to take control over an agent during the course of the simulation. It can be invoked using three different keywords: user_only, user_first, user_last.species user control: user_only {   ...}If the control chosen is user_first, it means that the user controlled panel is opened first, and then the agent has a chance to run its “own” behaviors (reflexes, essentially, or “init” in the case of a “user_init” panel).If the control chosen is user_last, it is the contrary.user_panelThis control architecture is a specialization of the Finite State Machine Architecture where the “behaviors” of agents can be defined by using new constructs called user_panel (and one user_init), mixed with “states” or “reflexes”. This user_panel translates, in the interface, in a semi-modal view that awaits the user to choose action buttons, change attributes of the controlled agent, etc. Each user_panel, like a state in FSM, can have a enter and exit sections, but it is only defined in terms of a set of user_commands which describe the different action buttons present in the panel.user_commands can also accept inputs, in order to create more interesting commands for the user. This uses the user_input statement (and not operator), which is basically the same as a temporary variable declaration whose value is asked to the user. Example:As user_panel is a specialization of state, the modeler has the possibility to describe several panels and choose the one to open depending on some condition, using the same syntax than for finite state machines :  either adding transitions to the user_panels,  or setting the state attribute to a new value, from inside or from another agent.This ensures a great flexibility for the design of the user interface proposed to the user, as it can be adapted to the different stages of the simulation, etc…Follows a simple example, where, every 10 steps, and depending on the value of an attribute called “advanced”, either the basic or the advanced panel is proposed.species user control:user_only {   user_panel default initial: true {      transition to: \"Basic Control\" when: every (10) and !advanced_user_control;      transition to: \"Advanced Control\" when: every(10) and advanced_user_control;   }      user_panel \"Basic Control\" {      user_command \"Kill one cell\" {         ask (one_of(cell)){            do die;         }      }      user_command \"Create one cell\" {        create cell ;      }       transition to: default when: true;   }   user_panel \"Advanced Control\" {      user_command \"Kill cells\" {        user_input \"Number\" returns: number type: int &lt;- 10;        ask (number among cell){           do die;        }      }      user_command \"Create cells\" {        user_input \"Number\" returns: number type: int &lt;- 10;        create cell number: number ;      }       transition to: default when: true;   }}The panel marked with the “initial: true” facet will be the one run first when the agent is supposed to run. If none is marked, the first panel (in their definition order) is chosen.A special panel called user_init will be invoked only once when initializing the agent if it is defined.If no panel is described or if all panels are empty (i.e. no user_commands), the control view is never invoked. If the control is said to be “user_only”, the agent will then not run any of its behaviors.user_controlledFinally, each agent provided with this architecture inherits a boolean attribute called user_controlled. If this attribute becomes false, no panels will be displayed and the agent will run “normally” unless its species is defined with a user_only control.//: # (endConcept|user_control_architecture)Other Control ArchitecturesSome other control architectures are available in additional plugins. For instance, BDI (Belief, desire, intention) architecture is available. Feel free to read about it if you want to learn more.You need some other control architectures for your model ? Feel free to make your suggestion to the team of developer through the mailing list. Remember also that GAMA is an open-source platform, you can design your own control architecture easily. Go to the section Community/contribute if you want to jump into coding !",
        "url":"/wiki/ControlArchitecture.html"
      }
      ,
    
      "wiki-creatingareleaseofgama-html": {
        "title": "Product a release of GAMA",
        "content": "Product a release of GAMAFrom the productLocate the file named gama.product (in plugin ummisco.gama.product) and open it.On the first page, select the link Eclipse Product export wizard and follow the instructions in it. You can specify a root directory (under which the plugins will be copied) and an export directory on your hard drive where to export the whole application. Then click Finish and wait for a few minutes while Eclipse exports and packages your application. Once it is done, you can safely delete the Repository folder and the logs.zip file.Specific to MacOS XUse Gama.app as the name of the root directory. Failing to do so will leave you with a non-working application.[[/resources/images/Export_Mac.png]]This should result in a self-contained Gama.app application. However, the enclosed Info.plist lacks several key definitions. Open it (in a text editor) and paste the following items under the first  (replace existing double entries if necessary):\t&lt;key&gt;NSHighResolutionCapable&lt;/key&gt;\t&lt;string&gt;True&lt;/string&gt;\t&lt;key&gt;CFBundleExecutable&lt;/key&gt;\t&lt;string&gt;Gama&lt;/string&gt;\t&lt;key&gt;CFBundleGetInfoString&lt;/key&gt;\t&lt;string&gt;Gama 1.7.0b, Copyright UMMISCO IRD/UPMC and partners 2006-2016 http://gama-platform.org&lt;/string&gt;\t&lt;key&gt;CFBundleShortVersionString&lt;/key&gt;\t&lt;string&gt;1.7.0b&lt;/string&gt;\t&lt;key&gt;CFBundleSignature&lt;/key&gt;\t&lt;string&gt;GAMA&lt;/string&gt;\t&lt;key&gt;CFBundleVersion&lt;/key&gt;\t&lt;string&gt;1.7.0b&lt;/string&gt;If you also want the .gaml documents to be decorated with an icon and recognized when double-clicking on them, you can add:\t&lt;key&gt;CFBundleDocumentTypes&lt;/key&gt;\t&lt;array&gt;\t\t&lt;dict&gt;\t\t\t&lt;key&gt;CFBundleTypeExtensions&lt;/key&gt;\t\t\t&lt;array&gt;\t\t\t\t&lt;string&gt;gaml&lt;/string&gt;\t\t\t&lt;/array&gt;\t\t\t&lt;key&gt;CFBundleTypeIconFile&lt;/key&gt;\t\t\t&lt;string&gt;Model.icns&lt;/string&gt;\t\t\t&lt;key&gt;CFBundleTypeName&lt;/key&gt;\t\t\t&lt;string&gt;Gama Model&lt;/string&gt;\t\t\t&lt;key&gt;CFBundleTypeRole&lt;/key&gt;\t\t\t&lt;string&gt;Editor&lt;/string&gt;\t\t\t&lt;key&gt;CFBundleTypeOSTypes&lt;/key&gt;\t\t\t&lt;array&gt;\t\t\t\t&lt;string&gt;TEXT&lt;/string&gt;\t\t\t&lt;/array&gt;\t\t&lt;/dict&gt;\t&lt;/array&gt;You can additionally create an icon (Model.icns) for these files, which needs to reside in Gama.app/Contents/Resources next to icon.icns. An example of icon is available in the plugin msi.gama.application/macosx.On Windows OSNo specific step to do. After select the link Eclipse Product export wizard, choose the directory for the export by click on Browse button, in Destination section. Then, click on Finish.Configure your IDE in order to allow multi-platform builds  Open Eclipse Preferences  Navigate to Plugin Development Environment/Target Platform  Select your (active) target platform  Click Edit  Click Add  Select “Software Site”  Click Next  In “Work With” type: http://download.eclipse.org/eclipse/updates/4.5 (replace 4.5 with your current version)  Check “Eclipse RCP Target Components”  Check “Equinox Target Components”  Uncheck “Include required software” (IMPORTANT)  Check “Include all environments” (IMPORTANT)  Press Finish  Wait for the plugins to be downloaded and provisioned  Press Finish  Press OKOpen your product file and select the “Export” option. You will see that the “Export for multiple platforms” checkbox is available. The next page allows you to choose for which platform you’d like to export GAMA.",
        "url":"/wiki/CreatingAReleaseOfGama.html"
      }
      ,
    
      "wiki-data-importation-3d-shapefile-loading-html": {
        "title": "3D shapefile loading",
        "content": "3D shapefile loading_Author :  _Model which shows how to create a shape using a 3D Shapefile after this one has been loaded.Code of the model :model shapefile_loadingglobal {\t\t//file variable that will store the shape file\tfile shape_file_gis_3d_objects &lt;- shape_file('../includes/Mobilier.shp', 0);\tgeometry shape &lt;- envelope(shape_file_gis_3d_objects);\tinit {\t\tcreate gis_3d_object from: shape_file_gis_3d_objects;\t}}species gis_3d_object {\taspect base {\t\tdraw shape at:{world.shape.width/2,world.shape.height/2,0};\t}}experiment display_shape type: gui {\toutput {\t\tdisplay city_display type: opengl draw_env:false{\t\t\tspecies gis_3d_object aspect: base;\t\t}\t}}",
        "url":"/wiki/Data-Importation-3D-shapefile-Loading.html"
      }
      ,
    
      "wiki-data-importation-asc-file-import-html": {
        "title": "ESRI ASCII to grid model",
        "content": "ESRI ASCII to grid modelAuthor :  Patrick TaillandierModel which shows how to initialize a grid using a ESRI ASCII fileCode of the model :model ascimportglobal {\t//definiton of the file to import\tfile grid_data &lt;- file('../includes/hab10.asc') ;\t\t//computation of the environment size from the geotiff file\tgeometry shape &lt;- envelope(grid_data);\t}//definition of the grid from the asc file: the width and height of the grid are directly read from the asc file. The values of the asc file are stored in the grid_value attribute of the cells.grid cell file: grid_data{\tinit {\t\tcolor&lt;- grid_value = 0.0 ? #black  : (grid_value = 1.0  ? #green :   #yellow);\t}}experiment gridloading type: gui {\toutput {\t\tdisplay \"As DEM\" type: opengl{\t\t\tgrid cell lines: #gray elevation: grid_value * 300 ;\t\t}\t\t\t\tdisplay \"As 2D grid\"  type: java2D {\t\t\tgrid cell lines: #black;\t\t}\t} }",
        "url":"/wiki/Data-Importation-ASC-file-Import.html"
      }
      ,
    
      "wiki-data-importation-csv-agents-html": {
        "title": "CSV to Agents Model",
        "content": "CSV to Agents ModelAuthor :  Patrick TaillandierModel which shows how to create agents by importing data of a CSV file. The model read the CSV File and create an agent Iris for each line of the CSV, linking its attributes to columns of the CSV File.Code of the model :model CSVfileloadingglobal {\t\tinit {\t\t//create iris agents from the CSV file (use of the header of the CSV file), the attributes of the agents are initialized from the CSV files: \t\t//we set the header facet to true to directly read the values corresponding to the right column. If the header was set to false, we could use the index of the columns to initialize the agent attributes\t\tcreate iris from:csv_file( \"../includes/iris.csv\",true) with:\t\t\t[sepal_length::float(get(\"sepallength\")), \t\t\t\tsepal_width::float(get(\"sepalwidth\")), \t\t\t\tpetal_length::float(get(\"petallength\")),\t\t\t\tpetal_width::float(get(\"petalwidth\")), \t\t\t\ttype::string(get(\"type\"))\t\t\t];\t\t}}species iris {\tfloat sepal_length;\tfloat sepal_width;\tfloat petal_length;\tfloat petal_width;\tstring type;\trgb color ;\t\tinit {\t\tcolor &lt;- type =\"Iris-setosa\" ? #blue : ((type =\"Iris-virginica\") ? #red: #yellow);\t}\t\taspect default {\t\tdraw circle(petal_width) color: color; \t}}experiment main type: gui{\toutput {\t\tdisplay map {\t\t\tspecies iris;\t\t}\t}\t}",
        "url":"/wiki/Data-Importation-CSV-Agents.html"
      }
      ,
    
      "wiki-data-importation-csv-file-loading-html": {
        "title": "Convertion of CSV data to Matrix",
        "content": "Convertion of CSV data to MatrixAuthor :  Patrick TaillandierModel which shows how to initialize a matrix by using the content of a CSV File. The model load a CSV File, and write its content in the console.Code of the model :model CSVfileloadingglobal {\tfile my_csv_file &lt;- csv_file(\"../includes/iris.csv\",\",\");\t\tinit {\t\t//convert the file into a matrix\t\tmatrix data &lt;- matrix(my_csv_file);\t\t//loop on the matrix rows (skip the first header line)\t\tloop i from: 1 to: data.rows -1{\t\t\t//loop on the matrix columns\t\t\tloop j from: 0 to: data.columns -1{\t\t\t\twrite \"data rows:\"+ i +\" colums:\" + j + \" = \" + data[j,i];\t\t\t}\t\t\t}\t\t\t}}experiment main type: gui;",
        "url":"/wiki/Data-Importation-CSV-File-Loading.html"
      }
      ,
    
      "wiki-data-importation-contour-lines-html": {
        "title": "Contour Lines Import",
        "content": "Contour Lines ImportAuthor : Patrick TaillandierModel which imports a shapefile of contour lines, build triangles from these contour lines, compute their elevation by using the elevation attribute of the contour lines which had been linked to the elevation column of the shapefile.Code of the model :model contour_lines_importglobal {\t//the contour lines shapefile\tfile shape_file_cl &lt;- file('../includes/contourLines.shp') ;\t\t//define the size of the world from the countour line shapefile\tgeometry shape &lt;- envelope(shape_file_cl);\t\tinit {\t\t//create the contour line agents from the shapefile, and init the elevation for each agent\t\tcreate contour_line from: shape_file_cl with: [elevation:: float(read(\"ELEVATION\"))];\t\t\t\t//triangulate the contour lines\t\tlist&lt;geometry&gt; triangles  &lt;- triangulate (list(contour_line));\t\t\t\t//for each triangle geometry, create a triangle_ag agent and compute the elevation of each of its points (and modified their z value)\t\tloop tr over: triangles {\t\t\tcreate triangle_ag {\t\t\t\tshape &lt;- tr;\t\t\t\tloop i from: 0 to: length(shape.points) - 1{ \t\t\t\t\tfloat val &lt;- (contour_line closest_to (shape.points at i)).elevation;\t\t\t\t\tshape &lt;- shape set_z (i,val);\t\t\t\t}\t\t\t}\t\t}\t\t}}species contour_line {\tfloat elevation;\taspect default {\t\tdraw shape + 5.0 color: #red depth: 10 at: {location.x,location.y, elevation}; \t}}species triangle_ag {\taspect default {\t\tdraw shape color: #grey ; \t}}experiment contour_lines_import type: gui {\toutput {\t\tdisplay map type: opengl {\t\t\tspecies triangle_ag refresh: false;\t\t\tspecies contour_line refresh: false;\t\t}\t}}",
        "url":"/wiki/Data-Importation-Contour-Lines.html"
      }
      ,
    
      "wiki-data-importation-dxf-agents-html": {
        "title": "DXF to Agents Model",
        "content": "DXF to Agents ModelAuthor :  Patrick TaillandierModel which shows how to create agents by importing data of a DXF fileCode of the model :model DXFAgents global {\tfile house_file &lt;- file(\"../includes/house.dxf\");\t\t//compute the environment size from the dxf file envelope\tgeometry shape &lt;- envelope(house_file);\t\tinit {\t\t//create house_element agents from the dxf file and initialized the layer attribute of the agents from the the file\t\tcreate house_element from: house_file with: [layer::string(get(\"layer\"))];\t\t\t\tcreate house_element from: house_file with: [layer::string(get(\"layer\"))];\t\t\t\t\t\tcreate house_element from: house_file with: [layer::string(get(\"layer\"))];\t\t//define a random color for each layer\t\tmap layers &lt;- list(house_element) group_by each.layer;\t\tloop la over: layers.keys {\t\t\trgb col &lt;- rnd_color(255);\t\t\task layers[la] {color &lt;- col;}\t\t}\t}}species house_element {\tstring layer;\trgb color;\taspect default {\t\tdraw shape color: color;\t}} experiment DXFAgents type: gui {\toutput {\t\tdisplay map {\t\t\tspecies house_element;\t\t}\t\t\t\tdisplay \"As_Image\" {\t\t\tgraphics \"House\" {\t\t\t\tdraw house_file color: #brown ;\t\t\t}\t\t}\t}\t\t}",
        "url":"/wiki/Data-Importation-DXF-Agents.html"
      }
      ,
    
      "wiki-data-importation-geotiff-file-import-html": {
        "title": "GeoTIFF file to Grid of Cells",
        "content": "GeoTIFF file to Grid of CellsAuthor :  Patrick TaillandierModel which shows how to create a grid of cells by using a GeoTIFF File.Code of the model :model geotiffimportglobal {\t//definiton of the file to import\tfile grid_data &lt;- file('../includes/bogota_grid.tif') ;\t\t//computation of the environment size from the geotiff file\tgeometry shape &lt;- envelope(grid_data);\t\t\tfloat max_value;\tfloat min_value;\tinit {\t\tmax_value &lt;- cell max_of (each.grid_value);\t\tmin_value &lt;- cell min_of (each.grid_value);\t\task cell {\t\t\tint val &lt;- int(255 * ( 1  - (grid_value - min_value) /(max_value - min_value)));\t\t\tcolor &lt;- rgb(val,val,val);\t\t}\t}}//definition of the grid from the geotiff file: the width and height of the grid are directly read from the asc file. The values of the asc file are stored in the grid_value attribute of the cells.grid cell file: grid_data;experiment show_example type: gui {\toutput {\t\tdisplay test {\t\t\tgrid cell lines: #black;\t\t}\t} }",
        "url":"/wiki/Data-Importation-GEOTIFF-file-Import.html"
      }
      ,
    
      "wiki-data-importation-gis-export-html": {
        "title": "Shapefiles Import and Save",
        "content": "Shapefiles Import and SaveAuthor : Patrick TaillandierModel using shapefiles to create buildings, linking their height and type attributes to the height and nature columns of the shapefiles to finally save the data in an other shapefile.Code of the model :  model saveGISglobal {\tfile shape_file_buildings &lt;- file(\"../includes/buildings_simple.shp\");\tstring new_shape_file_buildings &lt;- \"../results/buildings_final.shp\";\t\t//definition of the geometry of the world agent (environment) as the envelope of the shapefile\tgeometry shape &lt;- envelope(shape_file_buildings);\t\tinit {\t\t//creation of the building agents from the shapefile: the height and type attributes of the building agents are initialized according to the HEIGHT and NATURE attributes of the shapefile\t\tcreate building from: shape_file_buildings with:[height::float(get(\"HEIGHT\")), type::string(get(\"NATURE\"))];\t}\t\t//when cycle = 5, save of the building agents in a shapefile with the attributes height, type and price.\treflex save_data when: cycle = 5 {\t\tsave building to: new_shape_file_buildings type:\"shp\" with:[height::\"HEIGHT\", type::\"NATURE\", price::\"PRICE\"];\t}}species building {\tfloat height;\tstring type;\tfloat price &lt;- (shape.area * height) * (type = \"Industrial\" ? 0.5: 1) update: price * (90 +rnd(20)) / 100; \trgb color &lt;- type = \"Industrial\" ? #pink : #gray;\t\taspect default {\t\tdraw shape depth: height color: color;\t}\t}experiment GIS_agentification type: gui {\toutput {\t\tdisplay city_display type: opengl {\t\t\tspecies building;\t\t}\t}}",
        "url":"/wiki/Data-Importation-GIS-Export.html"
      }
      ,
    
      "wiki-data-importation-grid-dem-html": {
        "title": "ASCII File to DEM Representation",
        "content": "ASCII File to DEM RepresentationAuthor : Arnaud GrignardModel to show how to import a ASCII File to make a DEM Representation and apply a Texture on it. In this model, three experiments are presented : DEM to show the grid elevation using the ASCII File as data for the height of the cells, and showing different 3D displays. GridDEMComplete shows more displays with the three of the previous experiment, the grid of the cells in a 2D Display, with the Elevation but without triangulation, and the grid with text values to show the content of the ASCII used by the cells. GraphicDEMComplete shows the use of the z_factor to amplify or reduces the difference between the z values of a Dem geometry.Code of the model :model gridloadingglobal {\tfile grid_data &lt;- file(\"../includes/DEM-Vulcano/vulcano_50.asc\");\tfile dem parameter: 'DEM' &lt;- file('../includes/DEM-Vulcano/DEM.png');\tfile texture parameter: 'Texture' &lt;- file('../includes/DEM-Vulcano/Texture.png');\tgeometry shape &lt;- envelope(200);\tinit\t{\t\task cell\t\t{\t\t\tfloat r;\t\t\tfloat g;\t\t\tfloat b;\t\t\tif(grid_value&lt;20)\t\t\t{\t\t\t\tr&lt;- 76+(26*(grid_value-7)/13);\t\t\t\tg&lt;- 153-(51*(grid_value-7)/13);\t\t\t\tb&lt;-0.0;\t\t\t}\t\t\telse\t\t\t{\t\t\t\tr&lt;- 102+(122*(grid_value-20)/19);\t\t\t\tg&lt;- 51+(173*(grid_value-20)/19);\t\t\t\tb&lt;- 224*(grid_value-20)/19;\t\t\t}\t\t\tself.color&lt;-rgb(r,g,b);\t\t}\t}}grid cell file: grid_data {\trgb color;\treflex decreaseValue {\t\tgrid_value &lt;- grid_value  + rnd (0.2) - 0.1;\t}}experiment DEM type: gui {\toutput {\t\t//Display the grid triangulated in 3D with the cell altitude corresponding to its grid_value and the color cells (if defined otherwise in black)\t\tdisplay gridWithElevationTriangulated type: opengl autosave: true{ \t\t\tgrid cell elevation: true triangulation: true ;\t\t}\t\t//Display the grid triangulated in 3D with the cell altitude corresponding to its grid_value and the color of cells as a gray value corresponding to grid_value / maxZ *255\t\tdisplay gridGrayScaledTriangulated type: opengl { \t\t\tgrid cell elevation: true grayscale: true triangulation: true;\t\t}\t\t//Display the textured grid in 3D with the cell altitude corresponding to its grid_value.\t\t\t\t\t\tdisplay gridTextured type: opengl { \t\t\tgrid cell texture: texture text: false triangulation: true elevation: true;\t\t}\t}}experiment GridDEMComplete type: gui {\toutput {\t//Display the grid on a plan with cell color (if defined otherwise in black)\t\tdisplay grid type: opengl { //Same as in java2D\t\t\tgrid cell;\t\t}\t\t//Display the grid in 3D with the cell altitude corresponding to its grid_value and the color cells (if defined otherwise in black)\t\tdisplay gridWithElevation type: opengl { \t\t\tgrid cell elevation: true;\t\t}\t\t//Display the grid triangulated in 3D with the cell altitude corresponding to its grid_value and the color cells (if defined otherwise in black)\t\tdisplay gridWithElevationTriangulated type: opengl { \t\t\tgrid cell elevation: true triangulation: true ;\t\t}\t\t//Display the grid in 3D with the cell altitude corresponding to its grid_value and the color of cells as a gray value corresponding to grid_value / maxZ *255\t\tdisplay gridGrayScaled type: opengl { \t\t\tgrid cell elevation: true grayscale: true;\t\t}\t\t//Display the grid triangulated in 3D with the cell altitude corresponding to its grid_value and the color of cells as a gray value corresponding to grid_value / maxZ *255\t\tdisplay gridGrayScaledTriangulated type: opengl { \t\t\tgrid cell elevation: true grayscale: true triangulation: true;\t\t}\t\t//Display the textured grid in 3D with the cell altitude corresponding to its grid_value.\t\t\t\t\t\tdisplay gridTextured type: opengl { \t\t\tgrid cell texture: texture text: false triangulation: false elevation: true;\t\t}\t\t//Display the textured triangulated grid in 3D with the cell altitude corresponding to its grid_value.\t\tdisplay gridTexturedTriangulated type: opengl { \t\t\tgrid cell texture: texture text: false triangulation: true elevation: true;\t\t}\t\tdisplay gridWithText type: opengl { \t\t\tgrid cell text: true elevation: true grayscale: true;\t\t}\t}}experiment GraphicDEMComplete type: gui {\toutput {\t\tdisplay VulcanoTexturedScaled type: opengl draw_env: false { \t\t\tgraphics 'GraphicPrimitive' {\t\t\t\tdraw dem(dem, texture, 0.1);\t\t\t}\t\t} \t\tdisplay VulcanoDEMScaled type: opengl draw_env: false { \t\t\tgraphics 'GraphicPrimitive' {\t\t\t\tdraw dem(dem, 0.1);\t\t\t}\t\t} \t\tdisplay VulcanoTextured type: opengl draw_env: false { \t\t\tgraphics 'GraphicPrimitive' {\t\t\t\tdraw dem(dem, texture);\t\t\t}\t\t} \t\tdisplay VulcanoDEM type: opengl draw_env: false { \t\t\tgraphics 'GraphicPrimitive' {\t\t\t\tdraw dem(dem);\t\t\t}\t\t}\t}}",
        "url":"/wiki/Data-Importation-Grid-DEM.html"
      }
      ,
    
      "wiki-data-importation-obj-file-drawing-html": {
        "title": "OBJ File to Geometry",
        "content": "OBJ File to GeometryAuthor :  Arnaud GrignardModel which shows how to use a OBJ File to draw a complex geometry. The geometry is simply used, in this case, to draw the agents.Code of the model :model obj_drawing   global {\tgeometry shape &lt;- square(40);\tinit { \t\tcreate object number: 30;\t}  } species object skills: [moving]{\trgb color &lt;- rgb(rnd(255),rnd(255),rnd(255));\tint size &lt;- rnd(10) + 1;\tint rot &lt;- 1000 + rnd(1000);\treflex m when: every(100) {\t\tdo wander amplitude: 30 speed: 0.001;\t}\taspect obj {\t\tdraw obj_file(\"../includes/teapot.obj\") color: color size: size rotate: cycle/rot::{0,1,0};\t}}\texperiment Display  type: gui {\toutput {\t\tdisplay ComplexObject type: opengl background:°orange{\t\t\tspecies object aspect:obj;\t\t\t\t\t\t}\t}}",
        "url":"/wiki/Data-Importation-OBJ-file-drawing.html"
      }
      ,
    
      "wiki-data-importation-obj-file-loading-html": {
        "title": "Complex Object Loading",
        "content": "Complex Object LoadingAuthor :  Arnaud GrignardProvides a  complex geometry to agents (svg,obj or 3ds are accepted). The geometry becomes that of the agents.Code of the model :model obj_loading   global {\tinit { \t\tcreate object;\t}  } species object skills:[moving]{\t\tgeometry shape &lt;- obj_file(\"../includes/teapot.obj\") as geometry;\t\treflex move{\t\tdo wander;\t}\taspect obj {\t\tdraw shape;\t}\t\t\t}\texperiment Display  type: gui {\toutput {\t\tdisplay complex  background:#gray type: opengl{\t\t  species object aspect:obj;\t\t\t\t\t\t}\t}}",
        "url":"/wiki/Data-Importation-OBJ-file-loading.html"
      }
      ,
    
      "wiki-data-importation-osm-loading-html": {
        "title": "OSM file to Agents",
        "content": "OSM file to AgentsAuthor :  Patrick TaillandierModel which shows how to import a OSM File in GAMA and use it to create Agents. In this model, a filter is done to take only into account the roads and the buildings contained in the file.Code of the model :model simpleOSMLoading  global{\t\t//map used to filter the object to build from the OSM file according to attributes. for an exhaustive list, see: http://wiki.openstreetmap.org/wiki/Map_Features\tmap filtering &lt;- map([\"highway\"::[\"primary\", \"secondary\", \"tertiary\", \"motorway\", \"living_street\",\"residential\", \"unclassified\"], \"building\"::[\"yes\"]]);\t//OSM file to load\tfile&lt;geometry&gt; osmfile &lt;-  file&lt;geometry&gt;(osm_file(\"../includes/rouen.gz\", filtering))  ;\t\t//compute the size of the environment from the envelope of the OSM file\tgeometry shape &lt;- envelope(osmfile);\t\tinit {\t\t//possibility to load all of the attibutes of the OSM data: for an exhaustive list, see: http://wiki.openstreetmap.org/wiki/Map_Features\t\tcreate osm_agent from:osmfile with: [highway_str::string(read(\"highway\")), building_str::string(read(\"building\"))];\t\t\t\t//from the created generic agents, creation of the selected agents\t\task osm_agent {\t\t\tif (length(shape.points) = 1 and highway_str != nil ) {\t\t\t\tcreate node_agent with: [shape ::shape, type:: highway_str]; \t\t\t} else {\t\t\t\tif (highway_str != nil ) {\t\t\t\t\tcreate road with: [shape ::shape, type:: highway_str];\t\t\t\t} else if (building_str != nil){\t\t\t\t\tcreate building with: [shape ::shape];\t\t\t\t}  \t\t\t}\t\t\t//do the generic agent die\t\t\tdo die;\t\t}\t}\t}species osm_agent {\tstring highway_str;\tstring building_str;} \tspecies road {\trgb color &lt;- rnd_color(255);\tstring type;\taspect default {\t\tdraw shape color: color; \t}} \tspecies node_agent {\tstring type;\taspect default { \t\tdraw square(3) color: #red ;\t}} \tspecies building {\taspect default { \t\tdraw shape color: rgb(200,200,200);\t}}  experiment load_OSM type: gui {\toutput {\t\tdisplay map type: opengl {\t\t\tspecies building refresh: false;\t\t\tspecies road refresh: false  ;\t\t\tspecies node_agent refresh: false ;\t\t}\t}}",
        "url":"/wiki/Data-Importation-OSM-Loading.html"
      }
      ,
    
      "wiki-data-importation-raster-image-import-html": {
        "title": "Raster File in a Grid of cells",
        "content": "Raster File in a Grid of cellsAuthor : Maroussia Vavasseur and Benoit GaudouModel which shows how to import a Raster file in GAMA and use it to initialize the color attributes of a grid of cells. This model represents a grid with a cell, each cell has a color, and this color is used for animals (izards) to be placed on a cell that verifies some conditions. The izards do not move once they have been placed.Code of the model :model HowToImportRasterglobal {\t\t// Constants \tint heightImg const: true &lt;- 5587;\tint widthImg const: true &lt;- 6201;\t \t  \t// Global variables\tint factorDiscret &lt;- 30 ;\tfile mntImageRaster &lt;- image_file('../images/mnt/testAG.jpg') ;\t\tint nbIzard &lt;- 250 ; \tfile izardShape &lt;- file('../images/icons/izard.gif');\t\t\t\t// Initialization of grid and creation of the izard agents\t// - we use the as_matrix operator to transform a image file into a matrix of colors \t// (Note that as_matrix takes a Point as right operand, this point specifies the number of lines and columns of the matrix)\t// - we then set the color built-in attribute of the cell with the value of the corresponding matrix cell     \tinit {\t\t// set mapColor value: mntImageRaster as_matrix {widthImg/factorDiscret,heightImg/factorDiscret} ;\t\task cell {\t\t\t\t\tcolor &lt;-rgb( (mntImageRaster) at {grid_x,grid_y}) ;\t\t}\t\tcreate izard number: nbIzard;     }} // We create izard agents and locate them on one'cell' among the list of cellules in which there is no izard // and with a color that is not white 'each.color != #white'// the shuffle operator is used to randomized the list of cellsspecies izard {\t\tinit{\t\tlocation &lt;- (shuffle(cell) first_with ((each.color != #white) and (empty(izard inside each)))).location ;\t}\t\t\taspect default{\t\tdraw square(1) color: #orange;\t}\taspect image{\t\tdraw izardShape size: 3;\t}}// We create a grid as environment with the same dimensions as the matrix in which we want to store the image// Note that the height (resp. the width) of the grid corresponds to the number of rows (resp. of columns) of the matrix:// - in the creation of a matrix: ([...] as_matrix {widthImg/factorDiscret,heightImg/factorDiscret} ;)// - in the creation of the grid: grid cellule width: widthImg/factorDiscret height: heightImg/factorDiscret;grid cell  width: widthImg/factorDiscret height: heightImg/factorDiscret;experiment main type: gui {\t\t// We display:\t// - the grid\t// - the original MNT image as background\t// - izard agents\t// We can thus compare the original MNT image and the discretized image in the grid.\t// For cosmetic need, we can choose to not display the grid. \toutput {\t\tdisplay HowToImportRaster {\t       grid cell;\t       image 'Background' file: mntImageRaster.path;\t       species izard aspect: image; \t    }   \t}\t}",
        "url":"/wiki/Data-Importation-Raster-Image-Import.html"
      }
      ,
    
      "wiki-data-importation-raster-images-and-shapefile-import-html": {
        "title": "Raster File and Shapefiles Import",
        "content": "Raster File and Shapefiles ImportAuthor : Maroussia Vavasseur and Benoit GaudouModel which imports data from a raster file and two shapefiles to initilalize a grid and two species. The roaster file initialize a grid attribute for the cells and the shapefiles a river species just with the same shape, and the managementUnit species with a link between the columns of the shapefile and the attributes of the species.Code of the model :model RasterAndShapefiles global {\t// Constants\tint heightImg const: true &lt;- 5587;\tint widthImg const: true &lt;- 6201;\t\tfile boundsMNT const: true &lt;- file(\"../images/mnt/boundsMNT.shp\"); \t\t// The environment bounds are defined using the hand-made boundsMNT shapefile.// This shapefile has been created as a georeferenced bounding box of the MNT raster image, using information of the .pgw file\tgeometry shape &lt;- envelope(boundsMNT);\t\t// Global variables related to the MNT\tfile mntImageRaster &lt;- image_file('../images/mnt/testAG.jpg') ;\tint factorDiscret  &lt;- 10;\t\t// Global variables  related to the Management units\t\tfile ManagementUnitShape &lt;- file('../images/ug/UGSelect.shp');\t\t// Global variables  related to the water network\tfile waterShape &lt;- file('../images/reseauHydro/reseauEau.shp');\t// Global variables  related to izard agents\tint nbIzard &lt;- 25 ;\tfile izardShape &lt;-file('../images/icons/izard.gif') ;\t\t\t// Initialization of grid and creation of the izard agents.\t// Creation of managmentUnit and rivers agents from the corresponding shapefile\tinit {\t\tcreate managementUnit from: ManagementUnitShape \t\t\t\twith: [MUcode::int(read('Code_UG')), MULabel::string(read('Libelle_UG')), pgeSAGE::string(read('PGE_SAGE'))] ;\t\t\t\t\t\tcreate river from: waterShape;\t\t\t\t\t\tmatrix&lt;int&gt; mapColor &lt;- matrix&lt;int&gt;(mntImageRaster as_matrix {widthImg/factorDiscret,heightImg/factorDiscret}) ;\t\task cell {\t\t\t\t\tcolor &lt;- rgb( mapColor at {grid_x,grid_y} );\t\t}\t\tcreate izard number: nbIzard; \t\t\t    }}species river {\taspect default{\t\tdraw shape color: #blue;\t}\t}species managementUnit{\tint MUcode;\tstring MULabel;\tstring pgeSAGE;\t\taspect default{\t\tdraw shape;\t}}\tspecies izard {\t\tinit{\t\tlocation &lt;- (shuffle(cell) first_with ((each.color != #white) and (empty(izard inside each)))).location ;\t}\t\taspect default{\t\tdraw square(5000) color: #orange;\t}\taspect image{\t\tdraw izardShape size: 5000;\t}}\t// We create a grid as environment with the same dimensions as the matrix in which we want to store the imagegrid cell width: widthImg/factorDiscret height: heightImg/factorDiscret;experiment main type: gui {\t\t// We display:\t// - the original MNT image as background\t// - the grid representing the MNT\t// - izard agents\t// - the management unit shapefile\t// - the river shapefile\t// We can thus compare the original MNT image and the discretized image in the grid.\t// For cosmetic need, we can choose to not display the grid. \toutput {\t\tdisplay HowToImportVectorial {\t        image 'Background' file: mntImageRaster.path;  \t\t\t       \tgrid cell;\t \t\tspecies managementUnit transparency: 0.5;\t \t\tspecies river ;\t \t\tspecies izard aspect: image;  \t\t}\t}}",
        "url":"/wiki/Data-Importation-Raster-Images-and-shapefile-Import.html"
      }
      ,
    
      "wiki-data-importation-html": {
        "title": "Data Importation",
        "content": "Data ImportationThis sub-section is composed of the following models :      3D shapefile loading        ESRI ASCII to grid model        Contour Lines Import        CSV to Agents Model        Convertion of CSV data to Matrix        DXF to Agents Model        GeoTIFF file to Grid of Cells         Shapefiles Import and Save        ASCII File to DEM Representation        OBJ File to Geometry        Complex Object Loading        OSM file to Agents        Raster File in a Grid of cells        Raster File and Shapefiles Import  ",
        "url":"/wiki/Data-Importation.html"
      }
      ,
    
      "wiki-datatypes-html": {
        "title": "Types",
        "content": "TypesA variable’s or expression’s type (or data type) determines the values it can take, plus the operations that can be performed on or with it. GAML is a statically-typed language, which means that the type of an expression is always known at compile time, and is even enforced with casting operations.There are 4 categories of types:  primitive types, declared as keyword in the language,  complex types, also declared as keyword in the language,  parametric types, a refinement of complex types (mainly children of container) that is dynamically constructed using an enclosing type, a contents type and a key type,  species types, dynamically constructed from the species declarations made by the modeler (and the built-in species present).The hierarchy of types in GAML (only primitive and complex types are displayed here, of course, as the other ones are model-dependent) is the following:Table of contents  Types (Under Construction)          Primitive built-in types                  bool          float          int          string                    Complex built-in types                  agent          container          file          geometry          graph          list          map          matrix          pair          path          point          rgb          species          Species names as types          topology                    Defining custom types      Primitive built-in typesbool  Definition: primitive datatype providing two values: true or false.  Litteral declaration: both true or false are interpreted as boolean constants.  Other declarations: expressions that require a boolean operand often directly apply a casting to bool to their operand. It is a convenient way to directly obtain a bool value.bool (0) -&gt; falseTop of the pagefloat  Definition: primitive datatype holding floating point values, its absolute value is comprised between 4.9E-324 and 1.8E308.  Comments: this datatype is internally backed up by the Java double datatype.  Litteral declaration: decimal notation 123.45 or exponential notation 123e45 are supported.  Other declarations: expressions that require an integer operand often directly apply a casting to float to their operand. Using it is a way to obtain a float constant.float (12) -&gt; 12.0Top of the pageint  Definition: primitive datatype holding integer values comprised between -2147483648 and 2147483647 (i.e. between -2^31 and 2^31 - 1.  Comments: this datatype is internally backed up by the Java int datatype.  Litteral declaration: decimal notation like 1, 256790 or hexadecimal notation like #1209FF are automatically interpreted.  Other declarations: expressions that require an integer operand often directly apply a casting to int to their operand. Using it is a way to obtain an integer constant.int (234.5) -&gt; 234.Top of the pagestring  Definition: a datatype holding a sequence of characters.  Comments: this datatype is internally backed up by the Java String class. However, contrary to Java, strings are considered as a primitive type, which means they do not contain character objects. This can be seen when casting a string to a list using the list operator: the result is a list of one-character strings, not a list of characters.  Litteral declaration: a sequence of characters enclosed in quotes, like ‘this is a string’ . If one wants to literally declare strings that contain quotes, one has to double these quotes in the declaration. Strings accept escape characters like \\n (newline), \\r (carriage return), \\t (tabulation), as well as any Unicode character (\\uXXXX).  Other declarations: see string  Example: see string operators.Top of the pageComplex built-in typesContrarily to primitive built-in types, complex types have often various attributes. They can be accessed in the same way as attributes of agents:complex_type nom_var &lt;- init_var;ltype_attr attr_var &lt;- nom_var.attr_name;For example:file fileText &lt;- file(\"../data/cell.Data\");bool fileTextReadable &lt;- fileText.readable;agent  Definition: a generic datatype that represents an agent whatever its actual species.  Comments: This datatype is barely used, since species can be directly used as datatypes themselves.  Declaration: the agent casting operator can be applied to an int (to get the agent with this unique index), a string (to get the agent with this name).Top of the pagecontainer  Definition: a generic datatype that represents a collection of data.  Comments:  a container variable can be a list, a matrix, a map… Conversely each list, matrix and map is a kind of container. In consequence every container can be used in container-related operators.  See also: Container operators  Declaration:    container c  &lt;- [1,2,3];container c  &lt;- matrix [[1,2,3],[4,5,6]];container c  &lt;- map [\"x\"::5, \"y\"::12];container c  &lt;- list species1;        Top of the page  file  Definition: a datatype that represents a file.  Built-in attributes:          name (type = string): the name of the represented file (with its extension)      extension(type = string): the extension of the file      path (type = string): the absolute path of the file      readable (type = bool, read-only): a flag expressing whether the file is readable      writable (type = bool, read-only): a flag expressing whether the file is writable      exists (type = bool, read-only): a flag expressing whether the file exists      is_folder (type = bool, read-only): a flag expressing whether the file is folder      contents (type = container): a container storing the content of the file        Comments: a variable with the file type can handle any kind of file (text, image or shape files…). The type of the content attribute will depend on the kind of file. Note that the allowed kinds of file are the followings:          text files: files with the extensions .txt, .data, .csv, .text, .tsv, .asc. The content is by default a list of string.      image files: files with the extensions .pgm, .tif, .tiff, .jpg, .jpeg, .png, .gif, .pict, .bmp. The content is by default a matrix of int.      shapefiles: files with the extension .shp. The content is by default a list of geometry.      properties files: files with the extension .properties. The content is by default a map of string::string.      folders. The content is by default a list of string.        Remark: Files are also a particular kind of container and can thus be read, written or iterated using the container operators and commands.  See also: File operators  Declaration: a file can be created using the generic file (that opens a file in read only mode and tries to determine its contents), folder or the new_folder (to open an existing folder or create a new one) unary operators. But things can be specialized with the combination of the read/write and image/text/shapefile/properties unary operators.folder(a_string)  // returns a file managing a existing folderfile(a_string) // returns any kind of file in read-only moderead(text(a_string)) // returns a text file in read-only moderead(image(a_string)) // does the same with an image file.write(properties(a_string)) // returns a property file which is available for writing                             // (if it exists, contents will be appended unless it is cleared                             // using the standard container operations).Top of the pagegeometry  Definition: a datatype that represents a vector geometry, i.e. a list of georeferenced points.  Built-in attributes:          location (type = point): the centroid of the geometry      area (type = float): the area of the geometry      perimeter (type = float): the perimeter of the geometry      holes (type = list of geometry): the list of the hole inside the given geometry      contour (type = geometry): the exterior ring of the given geometry and of his holes      envelope (type = geometry): the geometry bounding box      width (type = float): the width of the bounding box      height (type = float): the height of the bounding box      points (type = list of point): the set of the points composing the geometry        Comments: a geometry can be either a point, a polyline or a polygon. Operators working on geometries handle transparently these three kinds of geometry. The envelope (a.k.a. the bounding box) of the geometry depends on the kind of geometry:          If this Geometry is the empty geometry, it is an empty point.      If the Geometry is a point, it is a non-empty point.      Otherwise, it is a Polygon whose points are (minx, miny), (maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny).        See also: Spatial operators  Declaration: geometries can be built from a point, a list of points or by using specific operators (circle, square, triangle…).geometry varGeom &lt;- circle(5);geometry polygonGeom &lt;- polygon([{3,5}, {5,6},{1,4}]);Top of the pagegraph  Definition: a datatype that represents a graph composed of vertices linked by edges.  Built-in attributes:          edges(type = list of agent/geometry): the list of all edges      vertices(type = list of agent/geometry): the list of all vertices      circuit (type = path): an approximate minimal traveling salesman tour (hamiltonian cycle)      spanning_tree (type = list of agent/geometry): minimum spanning tree of the graph, i.e. a sub-graph such as every vertex lies in the tree, and as much edges lies in it but no cycles (or loops) are formed.      connected(type = bool): test whether the graph is connected        Remark:          graphs are also a particular kind of container and can thus be manipulated using the container operators and commands.      This algorithm used to compute the circuit requires that the graph be complete and the triangle inequality exists (if x,y,z are vertices then d(x,y)+d(y,z)&lt;d(x,z) for all x,y,z) then this algorithm will guarantee a hamiltonian cycle such that the total weight of the cycle is less than or equal to double the total weight of the optimal hamiltonian cycle.      The computation of the spanning tree uses an implementation of  the Kruskal’s minimum spanning tree algorithm. If the given graph is connected it computes the minimum spanning tree, otherwise it computes the minimum spanning forest.        See also: Graph operators  Declaration: graphs can be built from a list of vertices (agents or geometries) or from a list of edges (agents or geometries) by using specific operators. They are often used to deal with a road network and are built from a shapefile.create road from: shape_file_road;graph the_graph &lt;- as_edge_graph(road);graph([1,9,5])        --: ([1: in[] + out[], 5: in[] + out[], 9: in[] + out[]], [])graph([node(0), node(1), node(2)]      // if node is a speciesgraph(['a'::345, 'b'::13])  --:  ([b: in[] + out[b::13], a: in[] + out[a::345], 13: in[b::13] + out[], 345: in[a::345] + out[]], [a::345=(a,345), b::13=(b,13)])graph(a_graph)  --: a_graphgraph(node1)    --: nullTop of the pagelist  Definition: a composite datatype holding an ordered collection of values.  Comments: lists are more or less equivalent to instances of ArrayList in Java (although they are backed up by a specific class). They grow and shrink as needed, can be accessed via an index (see @ or index_of), support set operations (like union and difference), and provide the modeller with a number of utilities that make it easy to deal with collections of agents (see, for instance, shuffle, reverse,where,sort_by,…).  Remark: lists can contain values of any datatypes, including other lists. Note, however, that due to limitations in the current parser, lists of lists cannot be declared litteraly; they have to be built using assignments. Lists are also a particular kind of container and can thus be manipulated using the container operators and commands.  Litteral declaration: a set of expressions separated by commas, enclosed in square brackets, like [12, 14, ‘abc’, self]. An empty list is noted .  Other declarations: lists can be build litteraly from a point, or a string, or any other element by using the list casting operator.list (1) -&gt; [1]list&lt;int&gt; myList &lt;- [1,2,3,4]; myList[2] =&gt; 3Top of the pagemap  Definition: a composite datatype holding an ordered collection of pairs (a key, and its associated value).  Built-in attributes:          keys (type = list): the list of all keys      values (type = list): the list of all values      pairs (type = list of pairs): the list of all pairs key::value        Comments: maps are more or less equivalent to instances of Hashtable in Java (although they are backed up by a specific class).  Remark: maps can contain values of any datatypes, including other maps or lists. Maps are also a particular kind of container and can thus be manipulated using the container operators and commands.  Litteral declaration: a set of pair expressions separated by commas, enclosed in square brackets; each pair is represented by a key and a value sperarated by ‘::’. An example of map is [agentA::’big’, agentB::’small’, agentC::’big’]. An empty map is noted .  Other declarations: lists can be built litteraly from a point, or a string, or any other element by using the map casting operator.map (1) -&gt; [1::1]map ({1,5}) -&gt; [x::1, y::5][]   // empty map Top of the pagematrix  Definition: a composite datatype that represents either a two-dimension array (matrix) or a one-dimension array (vector), holding any type of data (including other matrices).  Comments: Matrices are fixed-size structures that can be accessed by index (point for two-dimensions matrices, integer for vectors).  Litteral declaration: Matrices cannot be defined literally. One-dimensions matrices can be built by using the matrix casting operator applied on a list. Two-dimensions matrices need to to be declared as variables first, before being filled.//builds a one-dimension matrix, of size 5matrix mat1 &lt;- matrix ([10, 20, 30, 40, 50]);//  builds a two-dimensions matrix with 10 columns and 5 rows, where each cell is initialized to 0.0matrix mat2 &lt;- 0.0 as_matrix({10,5}); // builds a two-dimensions matrix with 2 columns and 3 rows, with initialized cellsmatrix mat3 &lt;- matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]]);         -&gt; c11;c21       c12;c22       c13;c23Top of the pagepair  Definition: a datatype holding a key and its associated value.  Built-in attributes:          key (type = string): the key of the pair, i.e. the first element of the pair      value (type = string): the value of the pair, i.e. the second element of the pair        Remark: pairs are also a particular kind of container and can thus be manipulated using the container operators and commands.  Litteral declaration: a pair is defined by a key and a value sperarated by ‘::’.  Other declarations: a pair can also be built from:          a point,      a map (in this case the first element of the pair is the list of all the keys of the map and the second element is the list of all the values of the map),      a list (in this case the two first element of the list are used to built the pair)      pair testPair &lt;- \"key\"::56;pair testPairPoint &lt;- {3,5};             // 3::5pair testPairList2 &lt;- [6,7,8];           // 6::7pair testPairMap &lt;- [2::6,5::8,12::45];  // [12,5,2]::[45,8,6]Top of the pagepath  Definition: a datatype representing a path linking two agents or geometries in a graph.  Built-in attributes:          source (type = point): the source point, i.e. the first point of the path      target (type = point): the target point, i.e. the last point of the path      graph (type = graph): the current topology (in the case it is a spatial graph), null otherwise      edges (type = list of agents/geometries) :  the edges of the graph composing the path      vertices (type = list of agents/geometries) :  the vertices of the graph composing the path      segments (type = list of geometries): the list of the geometries composing the path      shape (type = geometry) : the global geometry of the path (polyline)        Comments: the path created between two agents/geometries or locations will strongly depends on the topology in which it is created.  Remark: a path is immutable, i.e. it can not be modified after it is created.  Declaration: paths are very barely defined litterally. We can nevertheless use the path unary operator on a list of points to build a path. Operators dedicated to the computation of paths (such as path_to or path_between) are often used to build a path.path([{1,5},{2,9},{5,8}]) // a path from {1,5} to {5,8} through {2,9}       geometry rect &lt;- rectangle(5);geometry poly &lt;- polygon([{10,20},{11,21},{10,21},{11,22}]);path pa &lt;- rect path_to poly;  // built a path between rect and poly, in the topolopy                                               // of the current agent (i.e. a line in a&amp; continuous topology,                                             // a path in a graph  in a graph topology )a_topology path_between a_container_of_geometries // idem with an explicit topology and the possiblity                                                   // to have more than 2 geometries                                                   // (the path is then built incrementally)path_between (a_graph, a_source, a_target) // idem with a the given graph as topologyTop of the pagepoint  Definition: a datatype normally holding two positive float values. Represents the absolute coordinates of agents in the model.  Built-in attributes:          x (type = float): coordinate of the point on the x-axis      y (type = float): coordinate of the point on the y-axis        Comments: point coordinates should be positive, if a negative value is used in its declaration, the point is built with the absolute value.  Remark: points are particular cases of geometries and containers. Thus they have also all the built-in attributes of both the geometry and the container datatypes and can be used with every kind of operator or command admitting geometry and container.  Litteral declaration: two numbers, separated by a comma, enclosed in braces, like {12.3, 14.5}  Other declarations: points can be built litteraly from a list, or from an integer or float value by using the point casting operator.point ([12,123.45]) -&gt; {12.0, 123.45} point (2) -&gt; {2.0, 2.0}Top of the pagergb  Definition: a datatype that represents a color in the RGB space.  Built-in attributes:          red(type = int): the red component of the color      green(type = int): the green component of the color      blue(type = int): the blue component of the color      darker(type = rgb): a new color that is a darker version of this color      brighter(type = rgb): a new color that is a brighter version of this color        Remark: rgbs are also a particular kind of container and can thus be manipulated using the container operators and commands.  Litteral declaration: there exist lot of ways to declare a color. We use the rgb casting operator applied to:          a string. The allowed color names are the constants defined in the Color Java class, i.e.: black, blue, cyan, darkGray, lightGray, gray, green, magenta, orange, pink, red, white, yellow.      a list. The integer value associated to the three first elements of the list are used to define the three red (element 0 of the list), green (element 1 of the list) and blue (element 2 of the list) components of the color.      a map. The red, green, blue compoenents take the value associated to the keys “r”, “g”, “b” in the map.      an integer &lt;- the decimal integer is translated into a hexadecimal &lt;- OxRRGGBB. The red (resp. green, blue) component of the color take the value RR (resp. GG, BB) translated in decimal.      Since GAMA 1.6.1, colors can be directly obtained like units, by using the ° or # symbol followed by the name in lowercase of one of the 147 CSS colors (see http://www.cssportal.com/css3-color-names/).        Declaration:rgb cssRed &lt;- #red;   // Since 1.6.1rgb testColor &lt;- rgb('white');                 // rgb [255,255,255]rgb test &lt;- rgb(3,5,67);                     // rgb [3,5,67]rgb te &lt;- rgb(340);                            // rgb [0,1,84]rgb tete &lt;- rgb([\"r\"::34, \"g\"::56, \"b\"::345]); // rgb [34,56,255]Top of the pagespecies  Definition: a generic datatype that represents a species  Built-in attributes:          topology (type=topology): the topology is which lives the population of agents        Comments: this datatype is actually a “meta-type”. It allows to manipulate (in a rather limited fashion, however) the species themselves as any other values.  Litteral declaration: the name of a declared species is already a litteral declaration of species.  Other declarations: the species casting operator, or its variant called species_of can be applied to an agent in order to get its species.Top of the pageSpecies names as typesOnce a species has been declared in a model, it automatically becomes a datatype. This means that :  It can be used to declare variables, parameters or constants,  It can be used as an operand to commands or operators that require species parameters,  It can be used as a casting operator (with the same capabilities as the built-in type agent)In the simple following example, we create a set of “humans” and initialize a random “friendship network” among them. See how the name of the species, human, is used in the create command, as an argument to the list casting operator, and as the type of the variable named friend.global {    init {         create human number: 10;         ask human {               friend &lt;- one_of (human - self);         }     }}entities {    species human {        human friend &lt;- nil;    }}Top of the pagetopology  Definition: a topology is basically on neighborhoods, distance,… structures in which agents evolves. It is the environment or the context in which all these values are computed. It also provides the access to the spatial index shared by all the agents. And it maintains a (eventually dynamic) link with the ‘environment’ which is a geometrical border.  Built-in attributes:          places(type = container): the collection of places (geometry) defined by this topology.      environment(type = geometry): the environment of this topology (i.e. the geometry that defines its boundaries)        Comments: the attributes places depends on the kind of the considered topolopy.  For continuous topologies, it is a list with their environment. For discrete topologies, it can be any of the container supporting the inclusion of geometries (list, graph, map, matrix)  Remark: There exist various kinds of topology: continuous topology and discrete topology (e.g. grid, graph…)  Declaration: To create a topology, we can use the topology unary casting operator applied to:          an agent: returns a continuous topology built from the agent’s geometry      a species name: returns the topology defined for this species population      a geometry: returns a continuous topology built on this geometry      a geometry container (list, map, shapefile): returns an half-discrete (with corresponding places), half-continuous topology (to compute distances…)      a geometry matrix (i.e. a grid): returns a grid topology which computes specifically neighborhood and distances      a geometry graph: returns a graph topology which computes specifically neighborhood and distancesMore complex topologies can also be built using dedicated operators, e.g. to decompose a geometry…      Top of the pageDefining custom typesSometimes, besides the species of agents that compose the model, it can be necessary to declare custom datatypes. Species serve this purpose as well, and can be seen as “classes” that can help to instantiate simple “objects”. In the following example, we declare a new kind of “object”, bottle, that lacks the skills habitually associated with agents (moving, visible, etc.), but can nevertheless group together attributes and behaviors within the same closure. The following example demonstrates how to create the species:species bottle {    float volume &lt;- 0.0 max:1 min:0.0;    bool is_empty -&gt; {volume = 0.0};    action fill {         volume &lt;- 1.0;    }}How to use this species to declare new bottles :create bottle {    volume &lt;- 0.5;}And how to use bottles as any other agent in a species (a drinker owns a bottle; when he gets thirsty, it drinks a random quantity from it; when it is empty, it refills it):species drinker {     ...    bottle my_bottle&lt;- nil;    float quantity &lt;- rnd (100) / 100;    bool thirsty &lt;- false update: flip (0.1);    ...    action drink {         if condition: ! bottle.is_empty {              bottle.volume &lt;-bottle.volume - quantity;              thirsty &lt;- false;         }    }    ...    init {          create bottle return: created_bottle;              volume &lt;- 0.5;          }          my_bottle &lt;- first(created_bottle);    }    ...    reflex filling_bottle when: bottle.is_empty {         ask  my_bottle {              do fill;         }    }    ...    reflex drinking when: thirsty {         do drink;    }}Top of the page",
        "url":"/wiki/DataTypes.html"
      }
      ,
    
      "wiki-database-usage-agents-from-database-in-mssql-html": {
        "title": "Agents from Database in MSSQL",
        "content": "Agents from Database in MSSQLAuthor : Benoit GaudouThis model does SQl query commands and create agents using the resultsCode of the model :model DB2agentMSSQLglobal {\tmap&lt;string,string&gt; BOUNDS &lt;- [\t//\"srid\"::\"32648\", // optinal\t\t\t\t\t\t\t\t\t\"host\"::\"localhost\",\t\t\t\t\t\t\t\t\t\"dbtype\"::\"sqlserver\",\t\t\t\t\t\t\t\t\t\"database\"::\"spatial_DB\",\t\t\t\t\t\t\t\t\t\"port\"::\"1433\",\t\t\t\t\t\t\t\t\t\"user\"::\"sa\",\t\t\t\t\t\t\t\t\t\"passwd\"::\"tmt\",\t\t\t\t\t\t\t\t  \t\"select\"::\"SELECT GEOM.STAsBinary() as GEOM FROM bounds;\" ];\tmap&lt;string,string&gt; PARAMS &lt;- [\t//\"srid\"::\"32648\", // optinal\t\t\t\t\t\t\t\t\t\"host\"::\"localhost\",\t\t\t\t\t\t\t\t\t\"dbtype\"::\"sqlserver\",\t\t\t\t\t\t\t\t\t\"database\"::\"spatial_DB\",\t\t\t\t\t\t\t\t\t\"port\"::\"1433\",\t\t\t\t\t\t\t\t\t\"user\"::\"sa\",\t\t\t\t\t\t\t\t\t\"passwd\"::\"tmt\"];\t\tstring QUERY &lt;- \"SELECT name, type, GEOM.STAsBinary() as GEOM FROM buildings ;\";\tgeometry shape &lt;- envelope(BOUNDS);\t\t  \t\tinit {\t\tcreate DB_accessor {\t\t\tcreate buildings from: (self select [params:: PARAMS, select:: QUERY]) \t\t\t\t\t\t\t with:[ \"name\"::\"name\",\"type\"::\"type\", \"shape\":: geometry(\"geom\")];\t\t }\t}}species DB_accessor skills: [SQLSKILL];\tspecies buildings {\tstring type;\taspect default {\t\tdraw shape color: #gray ;\t}\t}\texperiment DB2agentMSSQL type: gui {\toutput {\t\tdisplay fullView {\t\t\tspecies buildings aspect: default;\t\t}\t}}",
        "url":"/wiki/Database-Usage-Agents-from-Database-in-MSSQL.html"
      }
      ,
    
      "wiki-database-usage-agents-from-database-in-mysql-html": {
        "title": "Agents from Database in MySQL",
        "content": "Agents from Database in MySQLAuthor : Benoit GaudouThis model does SQl query commands and create agents using the resultsCode of the model :model DB2agentMySQLglobal {\tmap&lt;string,string&gt; BOUNDS &lt;- [\t//'srid'::'32648', // optinal\t\t\t\t\t\t\t\t\t'host'::'localhost',\t\t\t\t\t\t\t\t\t'dbtype'::'MySQL',\t\t\t\t\t\t\t\t\t'database'::'spatial_DB',\t\t\t\t\t\t\t\t\t'port'::'8889',\t\t\t\t\t\t\t\t\t'user'::'root',\t\t\t\t\t\t\t\t\t'passwd'::'root',\t\t\t\t\t\t\t\t  \t\"select\"::\"SELECT geom FROM bounds;\" ];\tmap&lt;string,string&gt; PARAMS &lt;- [\t//'srid'::'32648', // optinal\t\t\t\t\t\t\t\t\t'host'::'localhost',\t\t\t\t\t\t\t\t\t'dbtype'::'MySQL',\t\t\t\t\t\t\t\t\t'database'::'spatial_DB',\t\t\t\t\t\t\t\t\t'port'::'8889',\t\t\t\t\t\t\t\t\t'user'::'root',\t\t\t\t\t\t\t\t\t'passwd'::'root'];\t\tstring QUERY &lt;- \"SELECT name, type, geom FROM buildings ;\";\tgeometry shape &lt;- envelope(BOUNDS);\t\t  \t\t \t\tinit {\t\tcreate DB_accessor {\t\t\tcreate buildings from: list(self select [params:: PARAMS, select:: QUERY]) \t\t\t\t\t\t\t with:[ 'name'::\"name\",'type'::\"type\", 'shape':: geometry(\"geom\")];\t\t }\t}}species DB_accessor skills: [SQLSKILL];species buildings {\tstring type;\taspect default {\t\tdraw shape color: #gray ;\t}\t}\texperiment DB2agentSQLite type: gui {\toutput {\t\tdisplay fullView {\t\t\tspecies buildings aspect: default;\t\t}\t}}",
        "url":"/wiki/Database-Usage-Agents-from-Database-in-MySQL.html"
      }
      ,
    
      "wiki-database-usage-agents-from-database-in-postgis-html": {
        "title": "Agents from Database in PostGIS",
        "content": "Agents from Database in PostGISAuthor : Benoit GaudouThis model does SQL query commands and create agents using the resultsCode of the model :model DB2agentMySQL global {\tmap&lt;string,string&gt; BOUNDS &lt;- [\t//'srid'::'32648', // optinal\t \t\t\t\t\t\t\t\t'host'::'localhost',\t\t\t\t\t\t\t\t\t'dbtype'::'postgres',\t\t\t\t\t\t\t\t\t'database'::'spatial_DB',\t\t\t\t\t\t\t\t\t'port'::'5433',\t\t\t\t\t\t\t\t\t'user'::'postgres',\t\t\t\t\t\t\t\t\t'passwd'::'tmt',\t\t\t\t\t\t\t\t  \t'select'::'SELECT ST_AsBinary(geom) as geom FROM buildings;' ];\tmap&lt;string,string&gt; PARAMS &lt;- [\t//'srid'::'32648', // optinal\t\t\t\t\t\t\t\t\t'host'::'localhost',\t\t\t\t\t\t\t\t\t'dbtype'::'postgres',\t\t\t\t\t\t\t\t\t'database'::'spatial_DB',\t\t\t\t\t\t\t\t\t'port'::'5433',\t\t\t\t\t\t\t\t\t'user'::'postgres',\t\t\t\t\t\t\t\t\t'passwd'::'tmt'];\t\tstring QUERY &lt;- \"SELECT name, type, ST_AsBinary(geom) as geom FROM buildings ;\";\tgeometry shape &lt;- envelope(BOUNDS);\t\t  \t\t\t  \t\tinit {\t\tcreate DB_accessor {\t\t\tcreate buildings from: (self select [params:: PARAMS, select:: QUERY]) \t\t\t\t\t\t\t with:[ 'name'::\"name\",'type'::\"type\", 'shape':: geometry(\"geom\")];\t\t }\t}}species DB_accessor skills: [SQLSKILL];species buildings {\tstring type;\taspect default {\t\tdraw shape color: #gray ;\t}\t}\texperiment DB2agentSQLite type: gui {\toutput {\t\tdisplay fullView {\t\t\tspecies buildings aspect: default;\t\t}\t}}",
        "url":"/wiki/Database-Usage-Agents-from-Database-in-PostGIS.html"
      }
      ,
    
      "wiki-database-usage-agents-from-database-in-sqlite-html": {
        "title": "Agents from Database in SQLite",
        "content": "Agents from Database in SQLiteAuthor : Benoit GaudouThis model creates buildings agents from the sqlite database using the result of a queryCode of the model :model DB2agentSQLiteglobal {//\tfile buildingsShp &lt;- file('../../includes/building.shp');//\tfile boundsShp &lt;- file('../../includes/bounds.shp');//\tgeometry shape &lt;- envelope(boundsShp);\t\tmap&lt;string,string&gt; BOUNDS &lt;- [\"dbtype\"::\"sqlite\",\t\t\t\t\t\t\t\t  'database'::'../../includes/spatialite.db',\t\t\t\t\t\t\t\t //'srid'::'32648',\t\t\t\t\t\t\t\t  \"select\"::\"SELECT AsBinary(geom) as geom FROM bounds;\"\t\t\t\t\t\t\t\t  \t\t\t\t ];\tmap&lt;string,string&gt; PARAMS &lt;- [\"dbtype\"::\"sqlite\",\t\t\t\t\t\t\t\t  //'srid'::'32648',\t\t\t\t\t\t\t\t  'database'::'../../includes/spatialite.db'\t\t\t\t\t\t\t\t  ];\t\tstring QUERY &lt;- \"SELECT name, type, AsBinary(geom) as geom FROM buildings ;\";\tgeometry shape &lt;- envelope(BOUNDS);\t\t  \t\t  \t\tinit {\t\tcreate DB_accessor {\t\t\tcreate buildings from: list(self select [params:: PARAMS, select:: QUERY]) \t\t\t\t\t\t\t with:[ 'name'::\"name\",'type'::\"type\", 'shape':: geometry(\"geom\")];\t\t }\t}}species DB_accessor skills: [SQLSKILL];species buildings {\tstring type;\taspect default {\t\tdraw shape color: #gray ;\t}\t}\texperiment DB2agentSQLite type: gui {\toutput {\t\tdisplay fullView {\t\t\tspecies buildings aspect: default;\t\t}\t}}",
        "url":"/wiki/Database-Usage-Agents-from-Database-in-SQLite.html"
      }
      ,
    
      "wiki-database-usage-agents-from-database-in-sqlite-qgis-html": {
        "title": "Agents from Database in SQLite QGIS",
        "content": "Agents from Database in SQLite QGISAuthor : Truong Minh ThaiThis model loads data from vnm_adm2 that is created by QGis.      In this case we do not need using AsBinary() to convert blob data to WKB format.    In other case, if we load Geometry data that is created by using libspatialite library then we must use Asbinary()  to convert geometry to WKB format (see SQLite_libspatialite model)Code of the model :model Sqlite_QGis   global { \tmap BOUNDS &lt;- [//'srid'::'4326', // optinal\t\t\t\t  \"dbtype\"::\"sqlite\",\t\t\t\t  \"database\"::\"../../includes/spatialite.db\"\t\t\t\t  ,\"select\"::\t\"select geom  from bounds;\" \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  ]; \tmap PARAMS &lt;- [//'srid'::'4326', // optinal\t\t\t\t\t\"dbtype\"::\"sqlite\",\t\t\t\t\t\"database\"::\"../../includes/bph.db\"];\tstring QUERY &lt;- \"SELECT name, type, geom as geom FROM buildings ;\";\tgeometry shape &lt;- envelope(BOUNDS);\t\t  \t\t\t  \t\tinit {\t\tcreate DB_accessor {\t\t\tcreate buildings from: (self select [params:: PARAMS, select:: QUERY]) \t\t\t\t\t\t\t with:[ 'name'::\"name\",'type'::\"type\", 'shape':: geometry(\"geom\")];\t\t }\t}}species DB_accessor skills: [SQLSKILL];species buildings {\tstring type;\taspect default {\t\tdraw shape color: #gray ;\t}\t}\texperiment DB2agentSQLite type: gui {\toutput {\t\tdisplay fullView {\t\t\tspecies buildings aspect: default;\t\t}\t}}",
        "url":"/wiki/Database-Usage-Agents-from-Database-in-SQLite_QGis.html"
      }
      ,
    
      "wiki-database-usage-agents-to-database-in-mssql-html": {
        "title": "Agents to Database in MSSQL",
        "content": "Agents to Database in MSSQLAuthor : Truong Minh ThaiThis model shows how to Insert and Delete agents from a MSSQL DBCode of the model :model agent2DB_MSSQL   global {  \tfile buildingsShp &lt;- file('../../includes/building.shp');\tfile boundsShp &lt;- file('../../includes/bounds.shp');\tgeometry shape &lt;- envelope(boundsShp);\tmap&lt;string,string&gt; PARAMS &lt;- [//'srid'::'4326', // optinal\t\t\t\t\t\t\t\t  'host'::'127.0.0.1','dbtype'::'sqlserver','database'::'spatial_DB',\t\t\t\t\t\t\t\t  'port'::'1433','user'::'sa','passwd'::'tmt'];\tinit {\t\tcreate buildings from: buildingsShp with: [type::string(read ('NATURE'))];\t\tcreate bounds from: boundsShp;\t\t\t\tcreate DB_Accessor \t\t{ \t\t\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM buildings\";\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM bounds\";\t\t}\t\twrite \"Click on &lt;&lt;Step&gt;&gt; button to save data of agents to DB\";\t\t \t}}     species DB_Accessor skills: [SQLSKILL] ;   species bounds {\treflex printdata{\t\t write ' name : ' + (name) ;\t}\t\treflex savetosql{  // save data into MSSQL\t\twrite \"begin\"+ name;\t\task DB_Accessor {\t\t\tdo insert params: PARAMS into: \"bounds\"\t\t\t\t\t  columns: [\"geom\"]\t\t\t\t\t  values: [myself.shape];\t\t}\t    write \"finish \"+ name;\t}\t\t}species buildings {\tstring type;\t\treflex printdata{\t\t write ' name : ' + (name) + '; type: ' + (type) + \"shape:\" + shape;\t}\t\treflex savetosql{  // save data into MSSQL\t\twrite \"begin\"+ name;\t\task DB_Accessor {\t\t\tdo insert params: PARAMS into: \"buildings\"\t\t\t\t\t  columns: [\"name\", \"type\",\"geom\"]\t\t\t\t\t  values: [myself.name,myself.type,myself.shape];\t\t}\t    write \"finish \"+ name;\t}\t\t\taspect default {\t\tdraw shape color: #gray ;\t}}     experiment default_expr type: gui {\toutput {\t\t\t\tdisplay GlobalView {\t\t\tspecies buildings aspect: default;\t\t}\t}}",
        "url":"/wiki/Database-Usage-Agents-to-Database-in-MSSQL.html"
      }
      ,
    
      "wiki-database-usage-agents-to-database-in-mysql-html": {
        "title": "Agents to Database in MySQL",
        "content": "Agents to Database in MySQLAuthor : Truong Minh Thaiinit: Select data from table vnm_adm2 (Created via QGis software)  and create  agentssavetosql: Save data of agent into MySQL. transform= true because you need to transform geometry data from Absolute(GAMA) to GisNOTE: You should have imported the database (spatial_DB.sql) into the MySQL server in order that the model can run properly.Code of the model :model agent2DB_MySQL   global { \tfile buildingsShp &lt;- file('../../includes/building.shp');\tfile boundsShp &lt;- file('../../includes/bounds.shp');\tgeometry shape &lt;- envelope(boundsShp);\t\tmap&lt;string,string&gt; PARAMS &lt;- ['srid'::'4326',\t\t\t\t                  'host'::'localhost','dbtype'::'MySQL','database'::'spatial_DB',\t\t\t\t                  'port'::'8889','user'::'root','passwd'::'root'];\tinit {\t\tcreate buildings from: buildingsShp with: [type::string(read ('NATURE'))];\t\tcreate bounds from: boundsShp;\t\t\t\tcreate DB_Accessor number: 1  \t\t{ \t\t\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM buildings\";\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM bounds\";\t\t}\t\twrite \"Click on &lt;&lt;Step&gt;&gt; button to save data of agents to DB\";\t\t \t}}    species DB_Accessor skills: [SQLSKILL] ;   species bounds {\treflex printdata{\t\t write ' name : ' + (name) ;\t}\t\treflex savetosql{  // save data into MySQL\t\twrite \"begin\"+ name;\t\task DB_Accessor {\t\t\tdo insert params: PARAMS into: \"bounds\"\t\t\t\t\t  columns: [\"geom\"]\t\t\t\t\t  values: [myself.shape];\t\t}\t    write \"finish \"+ name;\t}\t\t}species buildings {\tstring type;\t\treflex printdata{\t\t write ' name : ' + (name) + '; type: ' + (type) + \"shape:\" + shape;\t}\t\treflex savetosql{  // save data into MySQL\t\twrite \"begin\"+ name;\t\task DB_Accessor {\t\t\tdo insert params: PARAMS into: \"buildings\"\t\t\t\t\t  columns: [\"name\", \"type\",\"geom\"]\t\t\t\t\t  values: [myself.name,myself.type,myself.shape];\t\t}\t    write \"finish \"+ name;\t}\t\t\taspect default {\t\tdraw shape color: #gray ;\t}}     experiment default_expr type: gui {\toutput {\t\t\t\tdisplay GlobalView {\t\t\tspecies buildings aspect: default;\t\t}\t}}",
        "url":"/wiki/Database-Usage-Agents-to-Database-in-MySQL.html"
      }
      ,
    
      "wiki-database-usage-agents-to-database-in-postgis-html": {
        "title": "Agents to Database in PostGIS",
        "content": "Agents to Database in PostGISAuthor : Truong Minh Thaiinit: Select data from table vnm_adm2 (Created via QGis software)  and create  agentssavetosql: Save data of agent into MySQL.transform= true because you need to transform geometry data from Absolute(GAMA) to GisNOTE: You should have imported the database (spatial_DB.sql) into the MySQL server in order that the model can run properly.Code of the model :model agent2DB_MySQL   global { \tfile buildingsShp &lt;- file('../../includes/building.shp');\tfile boundsShp &lt;- file('../../includes/bounds.shp');\tgeometry shape &lt;- envelope(boundsShp);\t \tmap&lt;string,string&gt; PARAMS &lt;-  [//'srid'::'4326', // optinal\t\t\t\t\t\t\t\t   'host'::'localhost','dbtype'::'Postgres','database'::'spatial_DB',\t\t\t\t\t\t\t\t   'port'::'5433','user'::'postgres','passwd'::'tmt'];\tinit {\t\tcreate buildings from: buildingsShp with: [type::string(read ('NATURE'))];\t\tcreate bounds from: boundsShp;\t\t\t\tcreate DB_Accessor\t\t{ \t\t\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM buildings\";\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM bounds\";\t\t}\t\twrite \"Click on &lt;&lt;Step&gt;&gt; button to save data of agents to DB\";\t\t \t}}     species DB_Accessor skills: [SQLSKILL] ;   species bounds {\treflex printdata{\t\t write \" name : \" + (name) ;\t}\t\treflex savetosql{  // save data into Postgres\t\twrite \"begin\"+ name;\t\task DB_Accessor {\t\t\tdo insert params: PARAMS into: \"bounds\"\t\t\t\t\t  columns: [\"geom\"]\t\t\t\t\t  values: [myself.shape];\t\t}\t    write \"finish \"+ name;\t}\t\t}species buildings {\tstring type;\t\treflex printdata{\t\twrite \" name : \" + (name) + \"; type: \" + (type) + \"shape:\" + shape;\t}\t\treflex savetosql{  // save data into Postgres\t\twrite \"begin\"+ name;\t\task DB_Accessor {\t\t\tdo insert params: PARAMS into: \"buildings\"\t\t\t\t\t  columns: [\"name\", \"type\",\"geom\"]\t\t\t\t\t  values: [myself.name,myself.type,myself.shape];\t\t}\t    write \"finish \"+ name;\t}\t\t\taspect default {\t\tdraw shape color: #gray ;\t}}   experiment default_expr type: gui {\toutput {\t\t\t\tdisplay GlobalView {\t\t\tspecies buildings aspect: default;\t\t}\t}}",
        "url":"/wiki/Database-Usage-Agents-to-Database-in-PostGIS.html"
      }
      ,
    
      "wiki-database-usage-agents-to-database-in-sqlite-html": {
        "title": "Agents to Database in SQLite",
        "content": "Agents to Database in SQLiteAuthor : Truong Minh Thaiinit: Select data from table vnm_adm2 (Created via QGis software)  and create  agents      savetosql: Save data of agent into MySQL.        transform= true because you need to transform geometry data from Absolute(GAMA) to Gis  Code of the model :model agent2DB_SQLite    global {  \tfile buildingsShp &lt;- file('../../includes/building.shp');\tfile boundsShp &lt;- file('../../includes/bounds.shp');\tgeometry shape &lt;- envelope(boundsShp);\t\tmap&lt;string,string&gt; PARAMS &lt;- [\t\t\t\t'dbtype'::'sqlite', \t\t\t\t//'srid'::'4326', // optinal\t\t\t\t'database'::'../../includes/spatialite.db'\t\t\t\t\t\t\t];\tinit {\t\tcreate buildings from: buildingsShp with: [type::string(read ('NATURE'))];\t\tcreate bounds from: boundsShp;\t\t\t\tcreate DB_Accessor  \t\t{ \t\t\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM buildings\";\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM bounds\";\t\t\t\t\t}\t\twrite \"Click on &lt;&lt;Step&gt;&gt; button to save data of agents to DB\";\t\t \t}}    species DB_Accessor skills: [SQLSKILL] ;   species bounds {\treflex printdata{\t\t write ' name : ' + (name) ;\t}\t \treflex savetosql{  // save data into SQLite\t\twrite \"begin bound\";\t\task DB_Accessor {\t\t\tdo insert params: PARAMS into: \"bounds\"\t\t\t\t\t  columns: [\"geom\"]\t\t\t\t\t  values: [myself.shape];\t\t}\t    write \"finish bound\";\t}\t\t}\tspecies buildings {\tstring type;\t\treflex printdata{\t\t write ' name : ' + (name) + '; type: ' + (type) + \"shape:\" + shape;\t}\t\treflex savetosql{  // save data into SQLite\t\twrite \"begin\"+ name;\t\task DB_Accessor {\t\t\tdo insert params: PARAMS into: \"buildings\"\t\t\t\t\t  columns: [\"name\", \"type\",\"geom\"]\t\t\t\t\t  values: [myself.name,myself.type,myself.shape];\t\t}\t    write \"finish \"+ name;\t}\t\t\taspect default {\t\tdraw shape color: #gray ;\t}}    experiment default_expr type: gui {\toutput {\t\t\t\tdisplay GlobalView {\t\t\tspecies buildings aspect: default;\t\t}\t}}",
        "url":"/wiki/Database-Usage-Agents-to-Database-in-SQLite.html"
      }
      ,
    
      "wiki-database-usage-connection-test-html": {
        "title": "SQLConnection",
        "content": "SQLConnectionAuthor : thaitruongminhHow to create a connection to a database in GAMACode of the model :model test_connectionglobal {\tmap&lt;string, string&gt; SQLSERVER &lt;- ['host'::'localhost', 'dbtype'::'sqlserver', 'database'::'', 'port'::'1433', 'user'::'sa', 'passwd'::'tmt'];\tmap&lt;string, string&gt; MySQL &lt;- ['host'::'localhost', 'dbtype'::'MySQL', 'database'::'', 'port'::'8889', 'user'::'root', 'passwd'::'root'];\tmap&lt;string, string&gt; ORACLE &lt;- ['host'::'localhost', 'dbtype'::'Oracle', 'database'::'', 'port'::'1433', 'user'::'sa', 'passwd'::'tmt'];\tmap&lt;string, string&gt; POSTGRES &lt;- ['host'::'localhost', 'dbtype'::'Postgres', 'database'::'bgaudou', 'port'::'5432', 'user'::'bgaudou', 'passwd'::''];\tmap&lt;string, string&gt; SQLITE &lt;- ['dbtype'::'sqlite', 'database'::'../../includes/meteo.db'];\tinit {\t\tcreate DB_connection_tester;\t}}species DB_connection_tester skills: [SQLSKILL] {\tinit {\t\twrite \"Current Time \" + self timeStamp [];\t\twrite \"Connection to SQLSERVER is \" + self testConnection [params::SQLSERVER];\t\twrite \"Connection to MySQL is \" + self testConnection [params::MySQL];\t\twrite \"Connection to SQLITE is \" + self testConnection [params::SQLITE];\t\twrite \"Connection to ORACLE is \" + self testConnection [params::ORACLE];\t\twrite \"Connection to POSTGRESQL is \" + self testConnection [params::POSTGRES];\t}}experiment default_expr type: gui {}  ",
        "url":"/wiki/Database-Usage-Connection-Test.html"
      }
      ,
    
      "wiki-database-usage-create-agents-and-insert-in-mysql-html": {
        "title": "create_agents_Insert_result_MySQL",
        "content": "create_agents_Insert_result_MySQLAuthor : Benoit GaudouThis model illustrates the use of the MySQL DBMS to:            create agents from a database                  store every cycle some results into a database            Note: this model could be used with any DBMS just by changing the PARAMS variable.    NOTE: YOU SHOULD HAVE ALREADY CREATED YOUR DATABASE (meteo_DB here) AND IMPORTED THE FILE (../../includes/meteo_DB_dump.sql)  IN ORDER THAT THE MODEL CAN RUN PROPERLY.Code of the model :model create_agents_Insert_result_MySQL global {\tstring res_DB &lt;- '`result_DB`';\tmap&lt;string, string&gt; PARAMS &lt;- ['host'::'localhost', 'dbtype'::'MySQL', 'database'::'meteo_DB', 'port'::'8889', 'user'::'root', 'passwd'::'root'];\tstring SQLquery_idPoint &lt;- \"SELECT `idPointgrille`, AVG(`RRmm`) AS RR, AVG(`Tmin`) AS Tmin, AVG(`Tmax`) AS Tmax, AVG(`Rglot`) AS Rglot, AVG(`ETPmm`) AS ETPmm    \t\t\tFROM meteo_table GROUP BY `idPointgrille`\";\tinit {\t\tcreate DB_accessor;\t\task DB_accessor {\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE `result_DB` (\t\t\t\t\t\t\t\t\t\t  `idPoint` varchar(16) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,\t\t\t\t\t\t\t\t\t\t  `valRnd` float NOT NULL DEFAULT '0',\t\t\t\t\t\t\t\t\t\t  `cycle` int(16) NOT NULL DEFAULT '0'\t\t\t\t\t\t\t\t\t\t) ENGINE=InnoDB DEFAULT CHARSET=utf8;\";\t\t}\t\tcreate idPoint from: list(first(DB_accessor) select [params::PARAMS, select::SQLquery_idPoint]) with:\t\t[name:: \"idPointgrille\", RRmm::float(\"RR\"), Tmin::float(\"Tmin\"), Tmax::float(\"Tmax\"), Rglot::float(\"Rglot\"), ETPmm::float(\"ETPmm\")];\t}\treflex endSimu when: (cycle = 10) {\t\task DB_accessor {\t\t\twrite \"Data: \" + (self select [params::PARAMS, select::\"select * FROM \" + res_DB]);\t\t\tdo executeUpdate params: PARAMS updateComm: \"DROP TABLE \" + res_DB;\t\t}\t\twrite \"DROP the result table\";\t\tdo halt; \t}}species idPoint {\tfloat RRmm;\tfloat Tmin;\tfloat Tmax;\tfloat Rglot;\tfloat ETPmm;\tfloat valRnd;\treflex compute_new_random_value {\t\tvalRnd &lt;- float(rnd(RRmm + Tmin + Tmax + Rglot + ETPmm));\t}\treflex store_valRnd {\t\twrite \" \" + self + \" inserts value \" + valRnd;\t\task (first(DB_accessor)) {\t\t\tdo executeUpdate params: PARAMS updateComm: \"INSERT INTO \" + res_DB + \" VALUES(?, ?, ?);\" values: [myself.name, myself.valRnd, cycle];\t\t}\t\twrite \" \" + self + \" inserts value \" + valRnd;\t}}species DB_accessor skills: [SQLSKILL] {\tlist listRes &lt;- [];\tinit {\t// Test of the connection to the database\t\tif (not (self testConnection [params::PARAMS])) {\t\t\twrite \"Connection impossible\";\t\t\task (world) {\t\t\t\tdo halt;\t\t\t}\t\t} else {\t\t\twrite \"Connection Database OK.\";\t\t}\t\twrite \"\" + list(self select [params::PARAMS, select::\"SELECT * FROM meteo_table\"]);\t\twrite \"\" + list(self select [params::PARAMS, select::SQLquery_idPoint]);\t}}experiment createInsertMySQL type: gui {}   ",
        "url":"/wiki/Database-Usage-Create-Agents-and-Insert-in-MySQL.html"
      }
      ,
    
      "wiki-database-usage-create-spatial-table-in-mssql-html": {
        "title": "CreateBuildingTableMSSQL",
        "content": "CreateBuildingTableMSSQLAuthor : Truong Minh ThaiThis model shows how to create a database and a table in MSSQL using GAMACode of the model :model CreateBuildingTable_MSSQLglobal{\tmap&lt;string, string&gt; PARAMS &lt;- ['host'::'127.0.0.1', 'dbtype'::'sqlserver', 'database'::'', 'port'::'1433', 'user'::'sa', 'passwd'::'tmt'];\tinit\t{\t\tcreate dummy;\t\task dummy\t\t{\t\t\tif (self testConnection [params::PARAMS])\t\t\t{\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE DATABASE spatial_DB\";\t\t\t\twrite \"spatial_BD database was created \";\t\t\t\tremove  \"database\" from: PARAMS;\t\t\t\tput \"spatial_DB\" key: \"database\" in: PARAMS;\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE bounds\" + \"( \" + \" geom GEOMETRY \" + \")\";\t\t\t\twrite \"bounds table was created \";\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE buildings \" + \"( \" + \" name VARCHAR(255), \" + \" type VARCHAR(255), \" + \" geom GEOMETRY \" + \")\";\t\t\t\twrite \"buildings table was created \";\t\t\t} else\t\t\t{\t\t\t\twrite \"Connection to MySQL can not be established \";\t\t\t}\t\t}\t}}species dummy skills: [SQLSKILL]{}experiment default_expr type: gui{}",
        "url":"/wiki/Database-Usage-Create-Spatial-Table-in-MSSQL.html"
      }
      ,
    
      "wiki-database-usage-create-spatial-table-in-mysql-html": {
        "title": "CreateBuildingTableMySQL",
        "content": "CreateBuildingTableMySQLAuthor : Truong Minh ThaiThis model shows how to create a database and a table in MySQL using GAMACode of the model :model CreateBuildingTableMySQLglobal{\tmap&lt;string, string&gt; PARAMS &lt;- ['host'::'localhost', 'dbtype'::'MySQL', 'database'::'', 'port'::'8889', 'user'::'root', 'passwd'::'root'];\tinit\t{\t\tcreate test_species number: 1;\t\task test_species\t\t{\t\t\tif (self testConnection [params::PARAMS])\t\t\t{\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE DATABASE spatial_DB_GAMA\";\t\t\t\twrite \"spatial_BD_GAMA database was created \";\t\t\t\tremove \"database\" from: PARAMS;\t\t\t\tput \"spatial_DB_GAMA\" key: \"database\" in: PARAMS;\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE bounds\" + \"( \" + \" geom GEOMETRY \" + \")\";\t\t\t\twrite \"bounds table was created \";\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE buildings \" + \"( \" + \" name VARCHAR(255), \" + \" type VARCHAR(255), \" + \" geom GEOMETRY \" + \")\";\t\t\t\twrite \"buildings table was created \";\t\t\t} else\t\t\t{\t\t\t\twrite \"Connection to MySQL can not be established \";\t\t\t}\t\t}\t}}species test_species skills: [SQLSKILL]{}experiment default_expr type: gui{}",
        "url":"/wiki/Database-Usage-Create-Spatial-Table-in-MySQL.html"
      }
      ,
    
      "wiki-database-usage-create-spatial-table-in-postgis-html": {
        "title": "CreateBuildingTablePostGIS",
        "content": "CreateBuildingTablePostGISAuthor : Truong Minh ThaiThis model shows how to create a database and a table in PostGIS using GAMACode of the model :model CreateBuildingTablePostGISglobal{\tmap&lt;string, string&gt; PARAMS &lt;- ['host'::'localhost', 'dbtype'::'Postgres', 'database'::'', 'port'::'5433', 'user'::'postgres', 'passwd'::'tmt'];\tinit\t{\t\tcreate dummy;\t\task dummy\t\t{\t\t\tif (self testConnection [params::PARAMS])\t\t\t{\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE DATABASE spatial_db with TEMPLATE = template_postgis;\";\t\t\t\twrite \"spatial_BD database was created \";\t\t\t\tremove \"database\" from: PARAMS;\t\t\t\tput \"spatial_db\" key: \"database\" in: PARAMS;\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE bounds\" + \"( \" + \" geom GEOMETRY \" + \")\";\t\t\t\twrite \"bounds table was created \";\t\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE buildings \" + \"( \" + \" name character varying(255), \" + \" type character varying(255), \" + \" geom GEOMETRY \" + \")\";\t\t\t\twrite \"buildings table was created \";\t\t\t} else\t\t\t{\t\t\t\twrite \"Connection to MySQL can not be established \";\t\t\t}\t\t}\t}}species dummy skills: [SQLSKILL]{}experiment default_expr type: gui{}",
        "url":"/wiki/Database-Usage-Create-Spatial-Table-in-PostGIS.html"
      }
      ,
    
      "wiki-database-usage-create-spatial-table-in-sqlite-html": {
        "title": "CreateBuildingTableSQLite",
        "content": "CreateBuildingTableSQLiteAuthor : Truong Minh ThaiThis model shows how to create a database and a table in SQLite using GAMACode of the model :model SQLite_selectNUpdate  global {\tmap PARAMS &lt;- ['dbtype'::'sqlite','database'::'../../includes/spatialite.db'];\tinit {\t\tcreate dummy ;\t\task (dummy)\t\t\t{ \t\t\tdo  executeUpdate params: PARAMS \t\t\t\t\tupdateComm: \"DROP TABLE bounds; \" ; \t\t\tdo  executeUpdate params: PARAMS  \t\t\t\t\tupdateComm: \"DROP TABLE buildings; \" ;   \t\t\twrite \"dropped tables!\";\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE bounds \" +                   \"(id INTEGER PRIMARY KEY, \" +\t\t\t\t   \" geom BLOB NOT NULL); \"  ; \t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE buildings \" +                   \"(id INTEGER PRIMARY KEY, \" +                   \" name TEXT NOT NULL,\" +                   \" type TEXT NOT NULL,\" +                   \" geom BLOB NOT NULL); \"  ;\t\t}\t}}  species dummy skills: [SQLSKILL] { } experiment default_expr type:gui {}     ",
        "url":"/wiki/Database-Usage-Create-Spatial-Table-in-SQLite.html"
      }
      ,
    
      "wiki-database-usage-simple-sql-command-in-sqlite-html": {
        "title": "Simple SQL Command in SQLIte",
        "content": "Simple SQL Command in SQLIteAuthor : Truong Minh ThaiThis model does SQl query commands:            Create table                  Insert data                  Select data                  Delete data                  Drop table        Note: the file emptyFile.db is only … an empty file.Code of the model :model SQLite_selectNUpdateglobal {\tmap&lt;string, string&gt; PARAMS &lt;- ['dbtype'::'sqlite', 'database'::'../../includes/emptyFile.db'];\tinit {\t\tcreate DB_Accessor;\t\t// Test of the connection to the database\t\tif (first(DB_Accessor) testConnection [params::PARAMS] = false) {\t\t\twrite \"Connection impossible\";\t\t\tdo halt;\t\t}\t\task (DB_Accessor) {\t\t\tdo executeUpdate params: PARAMS updateComm: \"CREATE TABLE registration\" + \"(id INTEGER PRIMARY KEY, \" + \" first TEXT NOT NULL, \" + \" last TEXT NOT NULL, \" + \" age INTEGER);\";\t\t\twrite \"REGISTRATION table has been created.\";\t\t\tdo executeUpdate params: PARAMS updateComm: \"INSERT INTO registration \" + \"VALUES(100, 'Zara', 'Ali', 18);\";\t\t\tdo executeUpdate params: PARAMS updateComm: \"INSERT INTO registration \" + \"VALUES(?, ?, ?, ?);\" values: [101, 'Mr', 'Mme', 45];\t\t\tdo insert params: PARAMS into: \"registration\" values: [102, 'Mahnaz', 'Fatma', 25];\t\t\tdo insert params: PARAMS into: \"registration\" columns: [\"id\", \"first\", \"last\"] values: [103, 'Zaid tim', 'Kha'];\t\t\tdo insert params: PARAMS into: \"registration\" columns: [\"id\", \"first\", \"last\"] values: [104, 'Bill', 'Clark'];\t\t\twrite \"Five records have been inserted.\";\t\t\twrite \"Click on &lt;&lt;Step&gt;&gt; button to view selected data\";\t\t}\t}}species DB_Accessor skills: [SQLSKILL] {\treflex select {\t\tlist&lt;list&gt; t &lt;- list&lt;list&gt; (self select [params::PARAMS, select::\"SELECT * FROM registration\"]);\t\twrite \"Select before updated \" + t;\t}\treflex update {\t\tdo executeUpdate params: PARAMS updateComm: \"UPDATE registration SET age = 30 WHERE id IN (100, 101)\";\t\tdo executeUpdate params: PARAMS updateComm: \"DELETE FROM registration where id=103 \";\t\tlist&lt;list&gt; t &lt;- list&lt;list&gt; (self select [params::PARAMS, select::\"SELECT * FROM registration\"]);\t\twrite \"Select after updated \" + t;\t}\treflex drop {\t\tdo executeUpdate params: PARAMS updateComm: \"DROP TABLE registration\";\t\twrite \"Registration table has been dropped.\";\t}}experiment simple_SQL_exp type: gui {}     ",
        "url":"/wiki/Database-Usage-Simple-SQL-Command-in-SQLite.html"
      }
      ,
    
      "wiki-database-usage-simple-species-mysql-html": {
        "title": "Simple Species MySql",
        "content": "Simple Species MySqlAuthor : Truong Minh ThaiThis model illustrates the use of the AgentDB species (instead of the SQLSKILL), and in particular following actions:            testConection                  isConnected                  close                  executeUpdate                  insert                  select                  getParameter            This model does SQl query commands:              Create table                  Insert data                  Select data                  Delete data                  Drop table        NOTE: YOU SHOULD HAVE ALREADY CREATED YOUR DATABASE (meteo_DB here) AND IMPORTED THE FILE (../../includes/meteo_DB_dump.sql)  IN ORDER THAT THE MODEL CAN RUN PROPERLY.Code of the model :model simpleSQL_DBSpecies_MySQLglobal {\tmap&lt;string, string&gt; PARAMS &lt;- ['host'::'localhost', 'dbtype'::'MySQL', 'database'::'meteo_DB', 'port'::'8889', 'user'::'root', 'passwd'::'root'];\tinit {\t\tcreate DB_Accessor number: 1 {\t\t\tif (self testConnection (params::PARAMS) = false) {\t\t\t\twrite \"Impossible connection\";\t\t\t} else {\t\t\t\twrite \"Connection of \" + self;\t\t\t\tdo connect params: PARAMS;\t\t\t}\t\t}\t\tif (first(DB_Accessor) isConnected [] = false) {\t\t\twrite \"No connection.\";\t\t\task (AgentDB) {\t\t\t\tdo close;\t\t\t}\t\t\tdo halt;\t\t} else {\t\t\twrite \"\" + first(DB_Accessor) getParameter ();\t\t}\t\task (DB_Accessor) {\t\t\tdo executeUpdate updateComm: \"CREATE TABLE registration\" + \"(id INTEGER PRIMARY KEY, \" + \" first TEXT NOT NULL, \" + \" last TEXT NOT NULL, \" + \" age INTEGER);\";\t\t\twrite \"REGISTRATION table has been created.\";\t\t\tdo executeUpdate updateComm: \"INSERT INTO registration \" + \"VALUES(100, 'Zara', 'Ali', 18);\";\t\t\tdo executeUpdate updateComm: \"INSERT INTO registration \" + \"VALUES(?, ?, ?, ?);\" values: [101, 'Mr', 'Mme', 45];\t\t\tdo insert into: \"registration\" values: [102, 'Mahnaz', 'Fatma', 25];\t\t\tdo insert into: \"registration\" columns: [\"id\", \"first\", \"last\"] values: [103, 'Zaid tim', 'Kha'];\t\t\tdo insert into: \"registration\" columns: [\"id\", \"first\", \"last\"] values: [104, 'Bill', 'Clark'];\t\t\twrite \"Five records have been inserted.\";\t\t\twrite \"Click on &lt;&lt;Step&gt;&gt; button to view selected data\";\t\t}\t}}species DB_Accessor parent: AgentDB {\treflex select {\t\tlist&lt;list&gt; t &lt;- list&lt;list&gt; (self select (select::\"SELECT * FROM registration\"));\t\twrite \"Select before updated \" + t;\t}\treflex update {\t\tdo executeUpdate updateComm: \"UPDATE registration SET age = 30 WHERE id IN (100, 101)\";\t\tdo executeUpdate updateComm: \"DELETE FROM registration where id=103 \";\t\tlist&lt;list&gt; t &lt;- list&lt;list&gt; (self select (select::\"SELECT * FROM registration\"));\t\twrite \"Select after updated \" + t;\t}\treflex drop {\t\tdo executeUpdate updateComm: \"DROP TABLE registration\";\t\twrite \"Registration table has been dropped.\";\t}}experiment simple_SQL_exp type: gui {}     ",
        "url":"/wiki/Database-Usage-Simple-Species-MySQL.html"
      }
      ,
    
      "wiki-database-usage-html": {
        "title": "Database Usage",
        "content": "Database UsageThis sub-section is composed of the following models :      SQLConnection         create_agents_Insert_result_MySQL         Simple Species MySql         Simple SQL Command in SQLIte         Agents from Database in MSSQL         Agents from Database in MySQL         Agents from Database in PostGIS         Agents from Database in SQLite          Agents from Database in SQLite QGIS         Agents to Database in MSSQL         Agents to Database in MySQL         Agents to Database in PostGIS         Agents to Database in SQLite         CreateBuildingTableMSSQL         CreateBuildingTableMySQL         CreateBuildingTablePostGIS         CreateBuildingTableSQLite  ",
        "url":"/wiki/Database-Usage.html"
      }
      ,
    
      "wiki-date-and-time-date-type-and-real-dates-html": {
        "title": "Use of the Date variables",
        "content": "Use of the Date variablesAuthor :  Patrick TaillandierA model to show how to use date variables and more particularly the starting_date and current_date global variables.Code of the model :model date_model global {\t\t//definition of the date of begining of the simulation - defining this date will allows to change the normal date management of the simulation by a more realistic one (using calendar) \tdate starting_date &lt;- date([2011,1,2,1,1,30]);\t\t//be careful, when real dates are used, modelers should not use the #month and #year values that are not consistent with them\tfloat step &lt;- 1#h;\t\t\tinit {\t\twrite \"starting_date: \" + starting_date;\t\t\t\t//there are several ways to define a date.\t\t//The simplest consists in using a list of int values: [year,month of the year,day of the month, hour of the day, minute of the hour, second of the minute]\t\tdate my_date &lt;- date([2010,3,23,17,30,10]); //correspond the 23th of March 2010, at 17:30:10\t\t\t\t//It is also possible to define a date through a string:\t\tdate my_date2 &lt;- date(\"2010-3-23T17:30:10+07:00\"); \t\twrite (my_date2);\t\t\t//it is possible to get the current date by using the \"now\" string:\t\tdate today &lt;- date(\"now\"); \t\twrite (today);\t\t\t\twrite \"\\n ----------------------------------------------- \" ;\t\t\t\t//GAMA provides several operator to manipulate dates:\t\t\t\t\t\t//for instance, it is possible to compute the duration in seconds between 2 dates:\t\tfloat d &lt;- starting_date - my_date;\t\twrite \"duration between \" + my_date + \" and \" + starting_date + \" : \" + d + \"s\";\t\t\t\twrite \"\\n ----------------------------------------------- \" ;\t\t\t\t//to add or subtract a duration (in secondes) to a date:\t\t write \"my_date2 + 10: \" + (my_date2 + 10);\t\t write \"my_date2 - 10: \" + (my_date2 - 10);\t\t \t\t write \"\\n ----------------------------------------------- \" ;\t\t \t\t \t\t //to add or subtract a duration (in years, months, weeks, days, hours, minutes,  secondes) to a date:\t\t  write \"my_date2 add_years 1: \" + (my_date2 add_years 1);\t\t  write \"my_date2 add_months 1: \" + (my_date2 add_months 1);\t\t  write \"my_date2 add_weeks 1: \" + (my_date2 add_weeks 1);\t\t  write \"my_date2 add_days 1: \" + (my_date2 add_days 1);\t\t  write \"my_date2 add_hours 1: \" + (my_date2 add_hours 1);\t\t  write \"my_date2 add_minutes 1: \" + (my_date2 add_minutes 1);\t\t  write \"my_date2 add_seconds 1: \" + (my_date2 add_seconds 1);\t\t  \t\t  write \"my_date2 subtract_years 1: \" + (my_date2 subtract_years 1);\t\t  write \"my_date2 subtract_months 1: \" + (my_date2 subtract_months 1);\t\t  write \"my_date2 subtract_weeks 1: \" + (my_date2 subtract_weeks 1);\t\t  write \"my_date2 subtract_days 1: \" + (my_date2 subtract_days 1);\t\t  write \"my_date2 subtract_hours 1: \" + (my_date2 subtract_hours 1);\t\t  write \"my_date2 subtract_minutes 1: \" + (my_date2 subtract_minutes 1);\t\t  write \"my_date2 subtract_seconds 1: \" + (my_date2 subtract_seconds 1);\t}\t\treflex info_date {\t\t//at each simulation step, the current_date is updated - its value can be seen in the top-left green info panel.\t\twrite \"current_date at cycle \" + cycle + \" : \" + current_date;\t}}experiment main type: gui;",
        "url":"/wiki/Date-and-Time-Date-type-and-real-dates.html"
      }
      ,
    
      "wiki-date-and-time-simple-time-definition-html": {
        "title": "Simple definition of time property in a model",
        "content": "Simple definition of time property in a modelAuthor : Patrick TaillandierShow how the time is managed is GAMA.Code of the model :model SimpleTimedefinitionglobal {\t//redifitiion of the duration of one simulation step to 1 hour. By default the duration is one second.\tfloat step &lt;- 1 #hour;\t\t\tinit {\t\t//GAMA provides different values for temporal unities - these values are given in seconds\t\twrite \"1#s: \" + 1#s;\t\twrite \"1#mn: \" + 1#mn;\t\twrite \"1#hour: \" + 1#hour;\t\twrite \"1#day: \" + 1#day;\t\twrite \"1#month: \" + 1#month;\t\twrite \"1#year: \" + 1#year;\t\t\t\t//Note that these values are constant: the value #month is always equal to 30 #day. \t}\treflex info_time {\t\twrite \"\\n-------------------------------------------\";\t\t//the global variable cycle gives the current step of the simulation\t\twrite \"cycle: \" + cycle;\t\t\t\t//the global variable time gives the current duration (in seconds) since the beginning of the simulation: time = cycle * step\t\t//The value of the time facet can be seen - in a date-time presentation - in the top-left green info panel (click on the number of cycle to see the time value).\t\t//When presenting the time value, a month is considered as being composed of 30 days. For a more realistic calendar, use the starting_date global value (see the Date type and Real dates model)\t\twrite \"time: \" + time;\t}}experiment SimpleTimedefinition type: gui ;",
        "url":"/wiki/Date-and-Time-Simple-Time-definition.html"
      }
      ,
    
      "wiki-date-and-time-html": {
        "title": "Date and Time",
        "content": "Date and TimeThis sub-section is composed of the following models :      Use of the Date variables        Simple definition of time property in a model  ",
        "url":"/wiki/Date-and-Time.html"
      }
      ,
    
      "wiki-defining3ddisplays-html": {
        "title": "Defining 3D Displays",
        "content": "Defining 3D DisplaysTable of contents  OpenGL display          Position      Size        Camera  Dynamic camera          Camera position      Camera direction (Look Position)      Camera orientation (Up Vector)                  Default view          First person view          Third Person view                      LightingOpenGL display  Define the attribute type of the display with type:opengl in the output of your model (or use the preferences-&gt;display windows to use it by default):    output {display DisplayName type:opengl {  species mySpecies;}      The opengl display share most of the feature that the java2D offers and that are described here.Using 3D display offers many way to represent a simulation. A layer can be positioned and scaled in a 3D world. It is possible to superpose layer on different z value and display different information on the model at different position on the screen.PositionLayer can be drawn on different position (x,y and z)  value using the position facetSizeLayer can be drawn with different size (x,y and z) using the size facetHere is an example of display using all the previous facet (experiment factice to add to the model Incremental Model 5). You can also dynamically change those value by showing the side bar in the display.experiment expe_test type:gui {\toutput {\t\tdisplay city_display type: opengl{\t\t\tspecies road aspect: geom refresh:false;\t\t\tspecies building aspect: geom transparency:0.5 ;\t\t\tspecies people aspect: sphere3D position:{0,0,0.1};\t\t\tspecies road aspect: geom size:{0.3,0.3,0.3};\t\t}\t}}Camera&lt;img src=’http://img.youtube.com/vi/rMIVQlul1Ag/0.jpg’ width=’425’ height=344 /&gt;Arcball CameraFreeFly CameraDynamic cameraUser have the possibility to set dynamically the parameter of the camera (observer). The basic camera properties are its position, the direction in which is pointing, and its orientation. Those 3 parameters can be set dynamically at each iteration of the simulation.Camera positionThe facet camera_pos(x,y,z) places the camera at the given position.The default camera positon is (world.width/2,world/height/2,world.maxDim*1.5) to place the camera at the middle of the environement at an altitude that enables to see the entire environment.Camera direction (Look Position)The facet camera_look_pos(x,y,z) points the camera toward the given position.  The default look position is (world.width/2,world/height/2,0) to look at the center of the environment.Camera orientation (Up Vector)The camera camera_up_vector(x,y,z) sets the up vector of the camera.The up vector direction in your scene is the up direction on your display screen.The default value is (0,1,0)Here are some examples that can be done using those 3 parameters. You can test it by running the following model:&lt;img src=’http://img.youtube.com/vi/lQVGD8aDKZY/0.jpg’ width=’425’ height=344 /&gt;Boids 3D Camera movementDefault viewdisplay RealBoids   type:opengl{...\t\t}First person viewYou can set the position as a first person shooter video game using:display FirstPerson  type:opengl camera_pos:{boids(1).location.x,-boids(1).location.y,10} camera_look_pos:{cos(boids(1).heading)*world.shape.width,-sin(boids(1).heading)*world.shape.height,0} camera_up_vector:{0.0,0.0,1.0}{...}Third Person viewYou can follow an agent during a simulation by positioning the camera above it using:display ThirdPerson  type:opengl camera_pos:{boids(1).location.x,-boids(1).location.y,250}  camera_look_pos:{boids(1).location.x,-boids(1).location.y,boids(1).location.z}{...} LightingIn a 3D scene once can define light sources. The way how light sources and 3D object interact is called lighting. Lighting is an important factor to render realistic scenes.In a real world, the color that we see depend on the interaction between color material surfaces, the light sources and the position of the viewer. There are four kinds of lighting called ambient, diffuse, specular and emissive.Gama handle ambient and diffuse light.  ambient_light: Allows to define the value of the ambient light either using an int (ambient_light:(125)) or a rgb color ((ambient_light:rgb(255,255,255)). default is rgb(125,125,125).  diffuse_light: Allows to define the value of the diffuse light either using an int (diffuse_light:(125)) or a rgb color ((diffuse_light:rgb(255,255,255)). default is rgb(125,125,125).  diffuse_light_pos: Allows to define the position of the diffuse light either using an point (diffuse_light_pos:{x,y,z}). default is {world.shape.width/2,world.shape.height/2,world.shape.width*2}.  is_light_on: Allows to enable/disable the light. Default is true.  draw_diffuse_light: Allows to enable/disable the drawing of the diffuse light. Default is false”)),Here is an example using all the available facet to define a diffuse light that rotate around the world.&lt;img src=’http://img.youtube.com/vi/op56elmEEYs/0.jpg’ width=’425’ height=344 /&gt;display View1  type:opengl draw_diffuse_light:true ambient_light:(0) diffuse_light:(255) diffuse_light_pos:{50+ 150*sin(time*2),50,150*cos(time*2){...}",
        "url":"/wiki/Defining3DDisplays.html"
      }
      ,
    
      "wiki-definingactionsandbehaviors-html": {
        "title": "Defining actions and behaviors",
        "content": "Defining actions and behaviorsBoth actions and behaviors can be seen as methods in OOP. They can be defined in any species.Index  Action          Declare an action      Call an action        Behavior  ExampleActionDeclare an actionAn action is a function run by an instance of species. An action can return a value (in that case, the type of return has to be specify just before the name of the action), or not (in that case, you just have to put the keyword action before the name of the action).species my_species {\tint action_with_return_value {\t\t// statements...\t\treturn 1;\t}\taction action_without_return_value {\t\t// statements...\t}}Arguments can also be mandated in your action. You have to specify the type and the name of the argument:action action_without_return_value (int argA, float argB) {\t// statements...}If you want to have some optional arguments in the list, you can give some by default values to turn them optional. Nb: it is better to define the optional arguments at the end of the list of argument.action my_action (int argA, float argB &lt;- 5.1, point argC &lt;- {0,0}) {\t// statements...}Call an actionTo call an action, you have to use the statement do. You can use the statement do different ways:  With facets : after specifying the name of your action, you can specify the values of your arguments as if the name of your arguments were facets:do my_action argA:5 argB:5.1;  With parenthesis : after specifying the name of your action, you can specify the values of your arguments in the same order they were declared, between parenthesis:do my_action (5,5.1);We incite you to promote the second writing. To catch the returned value, you can also skip the do statement, and store the value directly in a temporary variable:int var1 &lt;- my_action(5,5.1);BehaviorA behavior, or reflex, is an action which is called automatically at each time step by an agent.reflex my_reflex {\twrite (\"Executing the inconditional reflex\");// statements...}With the facet when, this reflex is only executed when the boolean expression evaluates to true. It is a convenient way to specify the behavior of agents.reflex my_reflex when:flip(0.5) {\twrite (\"Executing the conditional reflex\");// statements...}Reflex, unlike actions, cannot be called from another context. But a reflex can, of course, call actions.Nb : Init is a special reflex, that occurs only when the agent is created.ExampleTo practice a bit with those notions, we will build an easy example. Let’s build a model with a species balloon that has 2 attributes: balloon_size (float) and balloon_color (rgb). Each balloon has a random position and color, his aspect is a sphere. Each step, a balloon has a probability to spawn in the environment. Once a balloon is created, its size is 10cm, and each step, the size increases by 1cm. Once the balloon size reaches 50cm, the balloon has a probability to burst. Once 10 balloons are destroyed, the simulation stops. The volume of each balloon is displayed in the balloon position.Here is one of the multiple possible implementation:model burst_the_baloonglobal{\tfloat worldDimension &lt;- 5#m;\tgeometry shape &lt;- square(worldDimension);\tint nbBaloonDead &lt;- 0;\treflex buildBaloon when:(flip(0.1)) {\t\tcreate species:balloon number:1;\t}\t\treflex endSimulation when:nbBaloonDead&gt;10 {\t\tdo halt;\t}}species balloon {\tfloat balloon_size;\trgb balloon_color;\tinit {\t\tballoon_size &lt;- 0.1;\t\tballoon_color &lt;- rgb(rnd(255),rnd(255),rnd(255));\t}\treflex balloon_grow {\t\tballoon_size &lt;- balloon_size + 0.01;\t\tif (balloon_size &gt; 0.5) {\t\t\tif (flip(0.2)) {\t\t\t\tdo balloon_burst;\t\t\t}\t\t}\t}\t\tfloat balloon_volume (float diameter) {\t\tfloat exact_value &lt;- 2/3*#pi*diameter^3;\t\tfloat round_value &lt;- (round(exact_value*1000))/1000;\t\treturn round_value;\t}\t\taction balloon_burst {\t\twrite \"the baloon is dead !\";\t\tnbBaloonDead &lt;- nbBaloonDead + 1;\t\tdo die;\t}\t\taspect balloon_aspect {\t\tdraw circle(balloon_size) color:balloon_color;\t\tdraw text:string(balloon_volume(balloon_size)) color:#black;\t}}experiment my_experiment type:gui{\toutput{\t\tdisplay myDisplay {\t\t\tspecies balloon aspect:balloon_aspect;\t\t}\t}}",
        "url":"/wiki/DefiningActionsAndBehaviors.html"
      }
      ,
    
      "wiki-definingadvancedspecies-html": {
        "title": "Defining advanced species",
        "content": "Defining advanced speciesIn the previous chapter, we saw how to declare and manipulate regular species and the global species (as a reminder, the instance of the global species is the world agent).We will now see that GAMA provides you the possibility to declare some special species, such as grids or graphs, with their own built-in attributes and their own built-in actions. We will also see how to declare mirror species, which is a “copy” of a regular species, in order to give it an other representation. Finally, we will learn how to represent several agents through one unique agent, with multi-level architecture.",
        "url":"/wiki/DefiningAdvancedSpecies.html"
      }
      ,
    
      "wiki-definingcharts-html": {
        "title": "Defining Charts",
        "content": "Defining ChartsTo visualize result and make analysis about you model, you will certainly have to use charts. You can define 3 types of charts in GAML: histograms, pie, and series. For each type, you will have to determine the data you want to highlight.Index  Define a chart  Data definition  Different types of chartsDefine a chartTo define a chart, we have to use the chart statement. A chart has to be named (with the name facet), and the type has to be specified (with the type facet). The value of the type facet can be histogram, pie, series, scatter, xy. A chart has to be defined inside a display.experiment my_experiment type: gui {\toutput {\t\tdisplay \"my_display\" {\t\t\tchart \"my_chart\" type:pie {\t\t\t}\t\t}\t}}After declaring your chart, you have to define the data you want to display in your chart.Data definitionData can be specified with:  several data statements to specify each series  one datalist statement to give a list of series. It can be useful if the number of series is unknown, variable or too high.The data statement is used to specify which variable will be displayed. You have to give your data a name (that will be displayed in your chart), the value of the variable you want to follow (using the value facet). You can add come optional facets such as color to specify the color of your data.global{\tint numberA &lt;- 2 update:numberA*2;\tint numberB &lt;- 10000 update:numberB-1000;}experiment my_experiment type: gui {\toutput {\t\tdisplay \"my_display\" {\t\t\tchart \"my_chart\" type:pie {\t\t\t\tdata \"numberA\" value:numberA color:#red;\t\t\t\tdata \"numberB\" value:numberB color:#blue;\t\t\t}\t\t}\t}}(TODO_IMAGE)The datalist statement is used several variables in one statement.  Instead of giving simple values, datalist is used with lists.datalist [\"numberA\",\"numberB\"] value:[numberA,numberB] color:[#red,#blue];[TODO]Datalist provides you some additional facets you can use. If you want to learn more about them, please read the documentation [URL]Different types of chartAs we already said, you can display 3 types of graphs: the histograms, the pies and the series.The histograms[TODO]            //: # (endConcept      defining_charts)      ",
        "url":"/wiki/DefiningCharts.html"
      }
      ,
    
      "wiki-definingdisplaysgeneralities-html": {
        "title": "Defining displays (Generalities)",
        "content": "Defining displays (Generalities)Index  Displays and layers  Organize your layers  Example of layers          agents layer      species layer      image layer      text layer      graphics layer      Displays and layersA display is the graphical output of your simulation. You can define several displays related with what you want to represent from your model execution. To define a display, use the keyword display inside the output scope, and specify a name (name facet).experiment my_experiment type: gui {\toutput {\t\tdisplay \"display1\" {\t\t}\t\tdisplay name:\"display2\" {\t\t}\t}}Other facets are available when defining your display:  Use background to define a color for your background    display \"my_display\" background:#red        Use refresh if you want to refresh the display when a condition is true (to refresh your display every number of steps, use the operator every)    display \"my_display\" refresh:every(10)      You can choose between two types of displays, by using the facet type:  java2D displays will be used when you want to have 2D visualization. It is used for example when you manipulate charts. This is the default value for the facet type.  opengl displays allows you to have 3D visualization.You can save the display on the disk, as a png file, in the folder name_of_model/models/snapshots, by using the facet autosave. This facet takes one a boolean as argument (to allow or not to save each frame) or a point (to define the size of your image). By default, the resolution of the output image is 500x500px (note that when no unit is provided, the unit is #px (pixel) ).display my_display autosave:true type:java2D {}is equivalent to :display my_display autosave:{500,500} type:java2D {}Each display can be decomposed in one or several layers. Here is a screenshot (from the Toy Model Ant) to better understand those different notions we are about to tackle in this session.Organize your layersIn one 2D display, you will have several types of layers, giving what you want to display in your model. You have a large number of layers available. You already know some of them, such as species, agents, grid, but other specific layers such as image (to display image) and graphics (to freely draw shapes/geometries/texts without having to define a species) are also availableEach layer will be displayed in the same order as you declare them. The last declared layer will be above the others.Thus, the following code:experiment expe type:gui {    output {        display my_display {            graphics \"layer1\" {                draw square(20) at:{10,10} color:#gold;            }            graphics \"layer2\" {                draw square(20) at:{15,15} color:#darkorange;            }            graphics \"layer3\" {                draw square(20) at:{20,20} color:#cornflowerblue;            }        }    }}Will have this output:Most of the layers have the transparency facet in order to see the layers which are under.experiment expe type:gui {\toutput {\t\tdisplay my_display {\t\t\tgraphics \"layer1\" {\t\t\t\tdraw square(20) at:{10,10} color:#darkorange;\t\t\t}\t\t\tgraphics \"layer2\" transparency:0.5 {\t\t\t\tdraw square(20) at:{15,15} color:#cornflowerblue;\t\t\t}\t\t}\t}}To specify a position and a size for your layer, you can use the position and the size facets.The position facet is used with a point type, between {0,0} and {1,1}, which corresponds to the position of the upper left corner of your layer in percentage. Then, if you choose the point {0.5,0.5}, the upper left corner of your layer will be in the center of your display. By default, this value is {0,0}.The size facet is used with a point type, between {0,0} and {1,1} also. It corresponds to the size occupied by the layer in percentage. By default, this value is {1,1}.experiment expe type:gui {\toutput {\t\tdisplay my_display {\t\t\tgraphics \"layer1\" position:{0,0} size:{0.5,0.8} {\t\t\t\tdraw shape color:#darkorange;\t\t\t}\t\t\tgraphics \"layer2\" position:{0.3,0.1} size:{0.6,0.2} {\t\t\t\tdraw shape color:#cornflowerblue;\t\t\t}\t\t\tgraphics \"layer3\" position:{0.4,0.2} size:{0.3,0.8} {\t\t\t\tdraw shape color:#gold;\t\t\t}\t\t}\t}}NB : displays can have background, while graphics can’t. If you want to put a background for your graphics, a solution can be to draw the shape of the world (which is, by default, a square 100m*100m).A lot of other facets are available for the different layers. Please read the documentation of graphics for more information.Example of layersagents layeragents allows the modeler to display only the agents that fulfill a given condition.Please read the documentation about agents statement if you are interested.species layerspecies allows modeler to display all the agent of a given species in the current display. In particular, modeler can choose the aspect used to display them.Please read the documentation about species statement if you are interested.image layerimage allows modeler to display an image (e.g. as background of a simulation).Please read the documentation about image statement if you are interested.graphics layergraphics allows the modeler to freely draw shapes/geometries/texts without having to define a species.Please read the documentation about graphics statement if you are interested.            //: # (endConcept      2d_displays)      ",
        "url":"/wiki/DefiningDisplaysGeneralities.html"
      }
      ,
    
      "wiki-definingexportfiles-html": {
        "title": "Defining export files",
        "content": "Defining export filesIndex  The Save Statement  Export files in experiment  AutosaveThe Save StatementAllows to save data in a file. The type of file can be “shp”, “text” or “csv”. The save statement can be use in an init block, a reflex, an action or in a user command. Do not use it in experiments.Facets  to (string): an expression that evaluates to an string, the path to the file  data (any type), (omissible) : any expression, that will be saved in the file  crs (any type): the name of the projectsion, e.g. crs:”EPSG:4326” or its EPSG id, e.g. crs:4326. Here a list of the CRS codes (and EPSG id): http://spatialreference.org  rewrite (boolean): an expression that evaluates to a boolean, specifying whether the save will ecrase the file or append data at the end of it  type (an identifier): an expression that evaluates to an string, the type of the output file (it can be only “shp”, “text” or “csv”)  with (map):Usages  Its simple syntax is:save data to: output_file type: a_type_file;  To save data in a text file:save (string(cycle) + \"-&gt;\"  + name + \":\" + location) to: \"save_data.txt\" type: \"text\";  To save the values of some attributes of the current agent in csv file:save [name, location, host] to: \"save_data.csv\" type: \"csv\";  To save the geometries of all the agents of a species into a shapefile (with optional attributes):save species_of(self) to: \"save_shapefile.shp\" type: \"shp\" with: [name::\"nameAgent\", location::\"locationAgent\"] crs: \"EPSG:4326\";Export files in experimentDisplays are not the only output you can manage in GAMA. Saving data to a file during an experiment can also be achieved in several ways, depending on the needs of the modeler. One way is provided by the save statement, which can be used everywhere in a model or a species. The other way, described here, is to include an output_file statement in the output section.output_file name:\"file_name\" type:file_type data:data_to_write; with:file_type: text, csv or xmlfile_name: stringdata_to_write: stringExample:file name: \"results\" type: text data: time + \"; \" + nb_preys + \";\" + nb_predators refresh:every(2);  Each time step (or according to the frequency defined in the refresh facet of the file output), a new line will be added at the end of the file. If rewrite: false is defined in its facets, a new file will be created for each simulation (identified by a timestamp in its name).Optionally, a footer and a header can also be described with the corresponding facets (of type string).AutosaveImage files can be exported also through the autosave facet of the display, as explained in this previous part.//: # (endConcept|export_files)",
        "url":"/wiki/DefiningExportFiles.html"
      }
      ,
    
      "wiki-definingguiexperiment-html": {
        "title": "Defining GUI Experiment",
        "content": "Defining GUI ExperimentWhen you execute your simulation, you will often need to display some information. For each simulation, you can define some inputs and outputs:  The inputs will be composed of parameters manipulated by the user for each simulation.  The outputs will be composed of displays, monitors or output files. They will be define inside the scope output.experiment exp_name type: gui {   [input]   output {     [display statements]     [monitor statements]     [file statements]   }}You can define two types of experiment (through the facet type):  gui experiments (the default type) are used to play an experiment, and interpret its outputs.  batch experiments are used to play an experiment several times (usually with other input values), used for model exploration. We will come back to this notion a bit further in the tutorial.Inside experiment scope, you can access to some built-ins which can be useful, such as minimum_cycle_duration, to force the duration of one cycle.experiment my_experiment type: gui {\tfloat minimum_cycle_duration &lt;- 2.0#minute;}Other built-ins are available, to learn more about, go to the page experiment built-in.In this part, we will focus on the gui experiments. We will start with learning how to define input parameters, then we will study the outputs, such as displays, monitors and inspectors, and export files. We will finish this part with how to define user commands.//: # (endConcept|gui_experiments)",
        "url":"/wiki/DefiningGUIExperiment.html"
      }
      ,
    
      "wiki-definingmonitorsandinspectors-html": {
        "title": "Defining monitors and inspectors",
        "content": "Defining monitors and inspectorsOther outputs can be very useful to study better the behavior of your agents.Index  Define a monitor  Define an inspectorDefine a monitorA monitor allows to follow the value of an arbitrary expression in GAML. It will appear, in the User Interface, in a small window on its own and be recomputed every time step (or according to its refresh facet).Definition of a monitor:monitor monitor_name value: an_expression refresh:boolean_statement;with:  value: mandatory, the expression whose value will be displayed by the monitor.  refresh: bool statement, optional : the new value is computed if the bool statement returns true.Example:experiment my_experiment type: gui {\toutput {\t\tmonitor monitor_name value: cycle refresh:every(1);\t}}NB : you can also declare monitors during the simulation, by clicking on the button “Add new monitor”, and specifying the name of the variable you want to follow.Define an inspectorDuring the simulation, the user interface of GAMA provides the user the possibility to inspect an agent, or a group of agents. But you can also define the inspector you want directly from your model, as an output of the experiment.Use the statement inspect to define your inspector, in the output scope of your gui experiment. The inspector has to be named (using the facet name), a value has to be specified (with the value facet).inspect name:\"inspector_name\" value:the_value_you_want_to_display;Note that you can inspect any type of species (regular species, grid species, even the world…).The optional facet type is used to specify the type of your inspector. 2 values are possible :  agent (default value) if you want to display the information as a regular agent inspector. Note that if you want to inspect a large number of agents, this can take a lot of time. In this case, prefer the other type table  table if you want to display the information as an agent browserThe optional facet attribute is used to filter the attributes you want to be displayed in your inspector.Beware : only one agent inspector (type:agent) can be used for an experiment. Beside, you can add as many agent browser (type:table) as you want for your experiment.Example of implementation :model newglobal {\tinit {\t\tcreate my_species number:3;\t}}species my_species {\tint int_attr &lt;- 6;\tstring str_attr &lt;- \"my_value\";\tstring str_attr_not_important &lt;- \"blabla\";}grid my_grid_species width: 10 height: 10 {\tint rnd_value &lt;- rnd(5);}experiment my_experiment type:gui {\toutput {\t\tinspect name:\"my_species_inspector\" value:my_species attributes:[\"int_attr\",\"str_attr\"];\t\tinspect name:\"my_species_browser\" value:my_species type:table;\t\tinspect name:\"my_grid_species_browser\" value:5 among my_grid_species type:table;\t}}Another statement, browse, is doing a similar thing, but preferring the table type (if you want to browse an agent species, the default type will be the table type).//: # (endConcept|monitors_and_inspectors)",
        "url":"/wiki/DefiningMonitorsAndInspectors.html"
      }
      ,
    
      "wiki-definingparameters-html": {
        "title": "Defining Parameters",
        "content": "Defining ParametersWhen playing simulation, you have the possibility to define input parameters, in order to change them and replay the simulation. Defining parameters allows to make the value of a global variable definable by the user through the user graphic interface.Index  Defining parameters  Additional facetsDefining parametersYou can define parameters inside the global scope, when defining your global variables with the facet parameter:global{\tint my_integer_global_value &lt;- 5 parameter: \"My integer global value\";}When launching your experiment, the parameter will appear in your “Parameters” panel, with the name you chose for the parameter facet.You can also define your parameter inside the experiment, using the statement parameter. You have to specify first the name of your parameter, then the name of the global variable through the facet var.global{\tint my_integer_global_value &lt;- 5;}experiment MyExperiment type: gui {\tparameter “My integer global value” var:my_integer_global_value;}NB: This variable has to be initialized with a value. If you don’t want to initialize your value on the global scope, you can initialize the value directly on the parameter statement, using the facet init.global{\tint my_integer_global_value;}experiment MyExperiment type: gui {\tparameter \"My integer global value\" var:my_integer_global_value init:5;}Additional facetsYou can use some facets to arrange your parameters. For example, you can categorize your parameters under a label, using the facet category:global{\tint attr_1 &lt;- 5 parameter:\"attr 1\" category:\"category 1\";\tint attr_2 &lt;- 5 parameter:\"attr 2\" category:\"category 1\";\tint attr_3 &lt;- 5 parameter:\"attr 3\" category:\"category 2\";}You also can add some facets such as min, max or among to improve the declaration of the parameter.global{\tstring fruit &lt;- \"none\" among:[\"none\",\"apple\",\"banana\"] parameter:\"fruit\" category:\"food\";\tstring vegetable &lt;- \"none\" among:[\"none\",\"cabbage\",\"carrot\"] parameter:\"vegetable\" category:\"food\";\tint integer_variable &lt;- 5 parameter:\"integer variable\" min:0 max:100  category:\"other\";}experiment MyExperiment type: gui {}//: # (endConcept|define_parameters)",
        "url":"/wiki/DefiningParameters.html"
      }
      ,
    
      "wiki-defininguserinteraction-html": {
        "title": "Defining user interaction",
        "content": "Defining user interactionDuring the simulation, GAML provides you the possibility to define some function the user can execute during the execution. In this chapter, we will see how to define buttons to execute action during the simulation, how to catch click event, and how to use the user control architecture.Index  Catch Mouse Event  Define User command          … in the GUI Experiment scope      … in global or regular species      user_location      user_input        User Control ArchitectureCatch Mouse EventYou can catch mouse event during the simulation using the statement event. This statement has 2 required facets:  name (identifier) : Specify which event do you want to trigger (among the following values : mouse_down, mouse_down, mouse_move, mouse_enter, mouse_exit).  action (identifier) : Specify the name of the global action to call.event mouse_down action: my_action;The event statement has to be defined in the experiment/output/display scope. Once the event is triggered, the global action linked will be called. The action linked has to have 2 arguments : the location of the click (type point) and the list of agents which are displayed at this position.global{\taction my_action (point loc, list&lt;my_species&gt; selected_agents)\t{\t\twrite \"do action\";\t}}species my_species{}experiment my_experiment type: gui{\toutput\t{\t\tdisplay my_display\t\t{\t\t\tspecies my_species;\t\t\tevent mouse_down action: my_action;\t\t}\t}}Define User commandAnywhere in the global block, in a species or in an (GUI) experiment, user_command statements can be implemented. They can either call directly an existing action (with or without arguments) or be followed by a block that describes what to do when this command is run.Their syntax can be (depending of the modeler needs) either:user_command cmd_name action: action_without_arg_name;//oruser_command cmd_name action: action_name with: [arg1::val1, arg2::val2];//oruser_command cmd_name {   // statements}For instance:user_command kill_myself action: die;//oruser_command kill_myself action: some_action with: [arg1::5, arg2::3];//oruser_command kill_myself {    do die;}Defining User command in GUI Experiment scopeThe user command can be defined directly inside the GUI experiment scope. In that case, the implemented action appears as a button in the top of the parameter view.Here is a very short code example :model quick_user_command_modelglobal {\taction createAgent\t{\t\tcreate my_species;\t}}species my_species {\taspect base {\t\tdraw circle(1) color:#blue;\t}}experiment expe type:gui {\tuser_command cmd_inside_experiment action:createAgent;\toutput {\t\tdisplay my_display {\t\t\tspecies my_species aspect:base;\t\t}\t}}And here is screenshots of the execution :Defining User command in a global or regular speciesThe user command can also be defined inside a species scope (either global or regular one). Here is a quick example of model :model quick_user_command_modelglobal {\tinit {\t\tcreate my_species number:10;\t}}species my_species {\tuser_command cmd_inside_experiment action:die;\taspect base {\t\tdraw circle(1) color:#blue;\t}}experiment expe type:gui {\toutput {\t\tdisplay my_display {\t\t\tspecies my_species aspect:base;\t\t}\t}}During the execution, you have 2 ways to access to the action :  When the agent is inspected, they appear as buttons above the agents’ attributes  When the agent is selected by a right-click in a display, these command appear under the usual “Inspect”, “Focus” and “Highlight” commands in the pop-up menu.Remark: The execution of a command obeys the following rules:  when the command is called from right-click pop-menu, it is executed immediately  when the command is called from panels, its execution is postponed until the end of the current step and then executed at that time.user_locationIn the special case when the user_command is called from the pop-up menu (from a right-click on an agent in a display), the location chosen by the user (translated into the model coordinates) is passed to the execution scope under the name user_location.Example:global {   user_command \"Create agents here\" {      create my_species number: 10 with: [location::user_location];   }}This will allow the user to click on a display, choose the world (always present now), and select the menu item “Create agents here”.Note that if the world is inspected (this user_command appears thus as a button) and the user chooses to push the button, the agent will be created at a random location.user_inputAs it is also, sometimes, necessary to ask the user for some values (not defined as parameters), the user_input unary operator has been introduced. This operator takes a map [string::value] as argument (the key is the name of the chosen parameter, the value is the default value), displays a dialog asking the user for these values, and returns the same map with the modified values (if any). You can also add a text as first argument of the operator, which will be displayed as a title for your dialog popup. The dialog is modal and will interrupt the execution of the simulation until the user has either dismissed or accepted it. It can be used, for instance, in an init section like the following one to force the user to input new values instead of relying on the initial values of parameters.Here is an example of implementation:model quick_user_command_modelglobal {   init {      map values &lt;- user_input(\"choose a number of agent to create\",[\"Number\" :: 100]);      create my_species number : int(values at \"Number\");   }}species my_species {\taspect base {\t\tdraw circle(1) color:#blue;\t}}experiment expe type:gui {\toutput {\t\tdisplay my_display {\t\t\tspecies my_species aspect:base;\t\t}\t}}When running this model, you will first have to input a number:User Control ArchitectureAn other way to define user interaction is to use the user control architecture. Please jump directly to the section user control architecture if you want to learn more about this point.",
        "url":"/wiki/DefiningUserInteraction.html"
      }
      ,
    
      "wiki-developingcontrolarchitectures-html": {
        "title": "Developing architecture",
        "content": "Developing architectureIn addition to existing control architectures, developers can add new ones.Defining a new control architecture needs to create new statements of type behavior and included in species statements and to define how to manage their execution.ImplementationA control architecture is a Java class, that:  is annotated by the @skill annotation,  extends the AbstractArchitecture class (to get benefits of everything from the reflex-based control architecture, the ReflexArchitecture class can be extended instead).The AbstractArchitecture extends the ISkill and IStatement interfaces and add the 2 following methods:  public abstract boolean init(IScope scope) throws GamaRuntimeException;  public abstract void verifyBehaviors(ISpecies context);The three main methods to implement are thus:  public void setChildren(final List&lt;? extends ISymbol&gt; children): this method will be called at the compilation of the model. It allows to manage all the embeded statements (in children) and for example separate the statements that should be executed at the initialization only from the ones that should be executed at each simulation step. Following example allows to test the name of the all the embedded statements:    for ( final ISymbol c : children ) {   if( IKeyword.INIT.equals(c.getFacet(IKeyword.KEYWORD).literalValue()) ) {        public abstract boolean init(IScope scope) throws GamaRuntimeException: this method is called only once, at the initialization of the agent.  public Object executeOn(final IScope scope) throws GamaRuntimeException: this method is executed at each simulation step. It should manage the execution of the various embedded behaviors (e.g. their order or choose which one will be executed…)",
        "url":"/wiki/DevelopingControlArchitectures.html"
      }
      ,
    
      "wiki-developingextensions-html": {
        "title": "Developing Extensions",
        "content": "Developing ExtensionsGAMA accepts extensions to the GAML language, defined by external programmers and dynamically loaded by the platform each time it is run. Extensions can represent new built-in species, types, file-types, skills, operators, statements, new control architectures or even types of displays. Other internal structures of GAML will be progressively “opened” to this mechanism in the future: display layers (hardwired for the moment), new types of outputs (hardwired for the moment), scheduling policies (hardwired for the moment), random number generators (hardwired for the moment).The extension mechanism relies on two complementary techniques:  the first one consists in defining the GAML extensions in a plug-in (in the OSGI sense, see here) that will be loaded by GAMA at runtime and must “declare” that it is contributing to the platform.  the second one is to indicate to GAMA where to look for extensions, using Java annotations that are gathered at compile time (some being also used at runtime) and directly compiled into GAML structures.The following sections describe this extension process.            Installing the GIT version                  Architecture of GAMA                  Developing a Plugin                  Developing a Skill                  Developing a Statement                  Developing an Operator                  Developing a Type                  Developing a Species                  Developing a Control Architecture                  Index of annotations                  IScope      ",
        "url":"/wiki/DevelopingExtensions.html"
      }
      ,
    
      "wiki-developingiscope-html": {
        "title": "IScope interface",
        "content": "IScope interfaceAn object of type IScope represents the context of execution of an agent (including experiments, simulations, and “regular” agents). Everywhere it is accessible (either passed as a parameter or available as an instance variable in some objects), it provides an easy access to a number of features: the current active agent, the shared random number generator, the global clock, the current simulation and experiment agents, the local variables declared in the current block, etc.It also allows modifying this context, like changing values of local variables, adding new variables, although these functions should be reserved to very specific usages. Ordinarily, the scope is simply passed to core methods that allow to evaluate expressions, cast values, and so on.Use of an IScopeA variable scope of type IScope can be used to:  get the current agent with: scope.getAgentScope()    IAgent agent = scope.getAgentScope();        evaluate an expression in the current scope:    String mes = Cast.asString(scope, message.value(scope));        know whether the scope has been interrupted:    boolean b = scope.interrupted();      ",
        "url":"/wiki/DevelopingIScope.html"
      }
      ,
    
      "wiki-developingindexannotations-html": {
        "title": "Index of annotations",
        "content": "Index of annotationsAnnotations are used to link Java methods and classes to GAML language.@actionThis annotations is used to tag a method that will be considered as an action (or primitive) in GAML.The method must have the following signature: Object methodName(IScope) throws GamaRuntimeException and be contained in a class annotated with @species or @skill (or a related class, like a subclass or an interface).This annotation contains:  name (String): the name of the variable as it can be used in GAML.  virtual (boolean, false by default): if true the action is virtual, i.e. equivalent to abstract method in java.  args (set of @arg, empty by default): the list of arguments passed to this action. Each argument is an instance of arg.  doc (set of @doc, empty by default): the documentation associated to the action.@argThis annotations describes an argument passed to an action.This annotation contains:  name (String, “” by default): the name of the argument as it can be used in GAML.  type (set of ints, empty by default): An array containing the textual representation of the types that can be taken by the argument (see IType).  optional (boolean, true by default): whether this argument is optional or not.  doc (set of @doc, empty by default): the documentation associated to the argument.@constantThis annotation is used to annotate fields that are used as constants in GAML.This annotation contains:  category (set of Strings, empty by default): an array of strings, each representing a category in which this constant can be classified (for documentation indexes).  value (String): a string representing the basic keyword for the constant. Does not need to be unique throughout GAML.  altNames (set of Strings, empty by default): an Array of strings, each representing a possible alternative name for the constant. Does not need to be unique throughout GAML.  doc (set of @doc, empty by default): the documentation attached to this constant.@docIt provides a unified way of attaching documentation to the various GAML elements tagged by the other annotations. The documentation is automatically assembled at compile time and also used at runtime in GAML editors.This annotation contains:  value (String, “” by default): a String representing the documentation of a GAML element.  masterDoc (boolean, false by default): a boolean representing the fact that this instance of the operator is the master one, that is whether its value will subsume the value of all other instances of it.  deprecated (String, “” by default): a String indicating (if it is not empty) that the element is deprecated and defining, if possible, what to use instead.  returns (String, “” by default): the documentation concerning the value(s) returned by this element (if any)..  comment (String, “” by default): an optional comment that will appear differently from the documentation itself.  special_cases (set of Strings, empty by default): an array of String representing the documentation of the “special cases” in which the documented element takes part.  examples (set of @example, empty by default): an array of String representing some examples or use-cases about how to use this element.  usages (set of @usage, empty by default): An array of usages representing possible usage of the element in GAML.  see (set of Strings, empty by default): an array of String representing cross-references to other elements in GAML.@exampleThis facet describes an example, that can be used either in the documentation, as unit test or as pattern.This annotation contains:  value (String, “” by default): a String representing the expression as example.  var (String, “” by default): The variable that will be tested in the equals, if it is omitted a default variable will be used.  equals (String, “” by default): The value to which the value will be compared.  returnType (String, “” by default): The type of the value that should be tested.  isNot (String, “” by default): The value to which the value will be compared.  raises (String, “” by default): The exception or warning that the expression could raise.  isTestOnly (boolean, false by default): specifies that the example should not be included into the documentation.  isExecutable (boolean, true by default): specifies that the example is correct GAML code that can be executed.  test (boolean, true by default): specifies that the example is will be tested with the equals.  isPattern (boolean, false by default): whether or not this example should be treated as part of a pattern (see @usage). If true, the developers might want to consider writing the example line (and its associated lines) using template variables (e.g. ${my_agent}).@facetThis facet describes a facet in a list of facets.This annotation contains:  name (String): the name of the facet. Must be unique within a symbol.  type (set of int): the string values of the different types that can be taken by this facet.  values (set of Strings, empty by default): the values that can be taken by this facet. The value of the facet expression will be chosen among the values described here.  optional (boolean, false by default): whether or not this facet is optional or mandatory.  doc (set of @doc, empty by default): the documentation associated to the facet.@facetsThis annotation describes a list of facets used by a statement in GAML.This annotation contains:  value (set of @facet): array of @facet, each representing a facet name, type..  ommissible (string): the facet that can be safely omitted by the modeler (provided its value is the first following the keyword of the statement).@fileThis annotation is used to define a type of file.This annotation contains:  name (String): a (human-understandable) string describing this type of files, suitable for use in composed operator names (e.g. “shape”, “image”…). This name will be used to generate two operators: name+”_file” and “is“+name. The first operator may have variants taking one or several arguments, depending on the @builder annotations present on the class_.  extensions (set of Strings): an array of extensions (without the ‘.’ delimiter) or an empty array if no specific extensions are associated to this type of files (e.g. [“png”,”jpg”,”jpeg”…]). The list of file extensions allowed for this type of files. These extensions will be used to check the validity of the file path, but also to generate the correct type of file when a path is passed to the generic “file” operator.  buffer_content (int, ITypeProvider.NONE by default): the type of the content of the buffer. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the content type is searched using this provider).  buffer_index (int, ITypeProvider.NONE by default): the type of the index of the buffer. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the index type is searched using this provider).  buffer_type (int, ITypeProvider.NONE by default): the type of the buffer. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the type is searched using this provider).  doc (set of @doc, empty by default): the documentation attached to this operator.@getterThis annotations is used to indicate that a method is to be used as a getter for a variable defined in the class. The variable must be defined on its own (in vars).This annotation contains:  value (String): the name of the variable for which the annotated method is to be considered as a getter.  initializer (boolean, false by default): returns whether or not this getter shoud also be used as an initializer@insideThis annotation is used in conjunction with symbol. Provides a way to tell where this symbol should be located in a model (i.e. what its parents should be). Either direct symbol names (in symbols) or generic symbol kinds can be used.This annotation contains:  symbols (set of Strings, empty by default): symbol names of the parents.  kinds (set of int, empty by default): generic symbol kinds of the parents (see ISymbolKind.java for more details).@operatorThis annotation represents an “operator” in GAML, and is used to define its name(s) as well as some meta-data that will be used during the validation process.This annotation contains:  value (set of Strings, empty by default): names of the operator.  category (set of string, empty by default): categories to which the operator belong (for documentation purpose).  iterator (boolean, false by default): true if this operator should be treated as an iterator (i.e.requires initializing the special variable “each” of WorldSkill within the method).  can_be_const (boolean, false by default): if true: if the operands are constant, returns a constant value.  content_type (int, ITypeProvider.NONE by default): the type of the content if the returned value is a container. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the content type is searched using this provider).  index_type (int, ITypeProvider.NONE by default): the type of the index if the returned value is a container. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the index type is searched using this provider).  expected_content_type (set of int, empty by default): if the argument is a container, returns the types expected for its contents. Should be an array of IType.XXX.  type (int, ITypeProvider.NONE by default): the type of the expression if it cannot be determined at compile time (i.e. when the return type is “Object”). Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the type is searched using this provider)..  internal (boolean, false by default): returns whether this operator is for internal use only.  doc (set of @doc, empty by default): the documentation attached to this operator.@serializerIt allows to declare a custom serializer for Symbols (statements, var declarations, species ,experiments, etc.). This serializer will be called instead of the standard serializer, superseding this last one. Serializers must be subclasses of the SymbolSerializer class.  value (Class): the serializer class.@setterThis annotations is used to indicate that a method is to be used as a setter for a variable defined in the class. The variable must be defined on its own (in vars).This annotation contains:  value (String): the name of the variable for which the annotated method is to be considered as a setter.@skillThis annotations Allows to define a new skill (class grouping variables and actions that can be used by agents).This annotation contains:  name (String): a String representing the skill name in GAML (must be unique throughout GAML).  attach_to (set of strings): an array of species names to which the skill will be automatically added (complements the “skills” parameter of species).  internal (boolean, false by default): return whether this skill is for internal use only.  doc (set of @doc, empty by default): the documentation associated to the skill.@speciesThis annotation represents a “species” in GAML. The class annotated with this annotation will be the support of a species of agents.This annotation contains:  name (string): the name of the species that will be created with this class as base. Must be unique throughout GAML.  skills (set of strings, empty by default): An array of skill names that will be automatically attached to this species. Example:  @species(value=\"animal\" skills={\"moving\"})  internal (boolean, false by default): whether this species is for internal use only.  doc (set of @doc, empty by default): the documentation attached to this operator.@symbolThis annotation represents a “statement” in GAML, and is used to define its name(s) as well as some meta-data that will be used during the validation process.This annotation contains:  name (set of string, empty by default): names of the statement.  kind (int): the kind of the annotated symbol (see ISymbolKind.java for more details).  with_scope (boolean, true by default): indicates if the statement (usually a sequence) defines its own scope. Otherwise, all the temporary variables defined in it are actually defined in the super-scope.  with_sequence (boolean): indicates wether or not a sequence can or should follow the symbol denoted by this class.  with_args (boolean, false by default): indicates wether or not the symbol denoted by this class will accept arguments.  remote_context (boolean, false by default): indicates that the context of this statement is actually an hybrid context: although it will be executed in a remote context, any temporary variables declared in the enclosing scopes should be passed on as if the statement was executed in the current context.  doc (set of @doc, empty by default): the documentation attached to this symbol.  internal (boolean, false by default): returns whether this symbol is for internal use only.  unique_in_context (boolean, false by default): Indicates that this statement must be unique in its super context (for example, only one return is allowed in the body of an action)..  unique_name (boolean, false by default): Indicates that only one statement with the same name should be allowed in the same super context.@typeIt provides information necessary to the processor to identify a type.This annotation contains:  name (String, “” by default): a String representing the type name in GAML.  id (int, 0 by default): the unique identifier for this type. User-added types can be chosen between IType.AVAILABLE_TYPE and IType.SPECIES_TYPE (exclusive) (cf. IType.java).  wraps (tab of Class, null by default): the list of Java Classes this type is “wrapping” (i.e. representing). The first one is the one that will be used preferentially throughout GAMA. The other ones are to ensure compatibility, in operators, with compatible Java classes (for instance, List and GamaList).  kind (int, ISymbolKind.Variable.REGULAR by default): the kind of Variable used to store this type. See ISymbolKind.Variable.  internal (boolean, false by default): whether this type is for internal use only.  doc (set of @doc, empty by default): the documentation associated to the facet.@usageThis replaces @special_cases and @examples, and unifies the doc for operators, statements and others.An @usage can also be used for defining a template for a GAML structure, and in that case requires the following to be defined:  A name (attribute “name”), optional, but better  A description (attribute “value”), optional  A menu name (attribute “menu”), optional  A hierarchical path within this menu (attribute “path”), optional  A pattern (attribute “pattern” or concatenation of the @example present in “examples” that define “isPattern” as true)This annotation contains:  value (String): a String representing one usage of the keyword. Note that for usages aiming at defining templates, the description is displayed on a tooltip in the editor. The use of the path allows to remove unecessary explanations. For instance, instead of writing : description=”This template illustrates the use of a complex form of the “create” statement, which reads agents from a shape file and uses the tabular data of the file to initialize their attributes”, choose: name=”Create agents from shapefile” menu=STATEMENT; path={“Create”, “Complex forms”} description=”Read agents from a shape file and initialze their attributes”. If no description is provided, GAMA will try to grab it from the context where the template is defined (in the documentation, for example).  menu (String, “” by default): Define the top-level menu where this template should appear. Users are free to use other names than the provided constants if necessary (i.e. “My templates”). When no menu is defined, GAMA tries to guess it from the context where the template is defined.  path (set of Strings, empty be default): The path indicates where to put this template in the menu. For instance, the following annotation: “ menu = STATEMENT; path = {“Control”, “If”} will put the template in a menu called “If”, within “Control”, within the top menu “Statement”. When no path is defined, GAMA will try to guess it from the context where the template is defined (i.e. keyword of the statement, etc.)  name (String, “” by default): The name of the template should be both concise (as it will appear in a menu) and precise (to remove ambiguities between templates).  examples (set of @example, empty by default): An array of String representing some examples or use-cases about how to use this element, related to the particular usage above.  pattern (String, “” by default): Alternatively, the contents of the usage can be descried using a @pattern (rather than an array of @example). The formatting of this string depends entirely on the user (e.g. including \\n and \\t for indentation, for instance).@validatorIt allows to declare a custom validator for Symbols (statements, var declarations, species ,experiments, etc.). This validator, if declared on subclasses of Symbol, will be called after the standard validation is done. The validator must be subclass of IDescriptionValidator.  value (Class): the validator class.@varThis annotation is used to describe a single variable or field.This annotation contains:  name (String): the name of the variable as it can be used in GAML.  type (int): The textual representation of the type of the variable (see IType).  of (int, 0 by default): The textual representation of the content type of the variable (see IType#defaultContentType()).  index (int, 0 by default): The textual representation of the index type of the variable (see IType#defaultKeyType()).  constant (boolean, false by default): returns whether or not this variable should be considered as non modifiable.  init (String, “” by default): the initial value of this variable as a String that will be interpreted by GAML.  depend_on (set of Strings, empty by default): an array of String representing the names of the variables on which this variable depends (so that they are computed before).  internal (boolean, false by default): return whether this var is for internal use only.  doc (set of @doc, empty by default): the documentation associated to the variable.@varsThis annotation is used to describe a set of variables or fields.This annotation contains:  value (set of @var): an Array of var instances, each representing a variable.",
        "url":"/wiki/DevelopingIndexAnnotations.html"
      }
      ,
    
      "wiki-developingoperators-html": {
        "title": "Developing Operators",
        "content": "Developing OperatorsOperators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function. Developing a new operator allows, then, to add a new function to GAML.ImplementationA new operator can be any Java method that:  begins by the @operator (other fields can be added to the annotation): @operator(value = \"name_of_the_operator_gaml\"),    @operator(value = \"rgb\")public static GamaColor rgb(final int r, final int g, final int b, final double alpha) {\t      The method:  must return a value (that has to be one of the GAMA Type: Integer, Double, Boolean, String, IShape, IList, IGraph, IAgent…),  can define any number of parameters, defined using Java type,  can be either static or non-static:          in the case it is static, the number of parameters (except an IScope attribute) of the method is equal to the number of operands of the GAML operator.      in the case it is not static, a first operand is added to the operator with the type of the current class.        can have a IScope parameter, that will be taken into account as operand of the operator.Annotations@operatorThis annotation represents an “operator” in GAML, and is used to define its name(s) as well as some meta-data that will be used during the validation process.This annotation contains:  value (set of string, empty by default): names of the operator.  content_type (integer) : if the operator returns a container, type of elements contained in the container  can_be_const (boolean, false by default): if true: if the operands are constant, returns a constant value.  category (set of string, empty by default): categories to which the operator belong (for documentation purpose).  doc (set of @doc, empty by default): the documentation attached to this operator.@docIt provides a unified way of attaching documentation to the various GAML elements tagged by the other annotations. The documentation is automatically assembled at compile time and also used at runtime in GAML editors.  value (String, “” by default): a String representing the documentation of a GAML element.  deprecated (String, “” by default): a String indicating (if it is not empty) that the element is deprecated and defining, if possible, what to use instead.  returns (String, “” by default): the documentation concerning the value(s) returned by this element (if any)..  comment (String, “” by default): an optional comment that will appear differently from the documentation itself.  special_cases (set of Strings, empty by default): an array of String representing the documentation of the “special cases” in which the documented element takes part.  examples (set of Strings, empty by default): an array of String representing some examples or use-cases about how to use this element.  see (set of Strings, empty by default): an array of String representing cross-references to other elements in GAML.All these annotations are defined in the GamlAnnotations.java file of the msi.gama.processor plug-in.",
        "url":"/wiki/DevelopingOperators.html"
      }
      ,
    
      "wiki-developingplugins-html": {
        "title": "Developing Plugins",
        "content": "Developing PluginsThis page details how to create a new plug-in in order to extend the GAML language with new skills, species, displays or operators.It also details how to create a plug-in that can be  uploaded on an update site and can be installed into the GAMA release.We consider here that the developer version of GAMA has been installed (as detailled in this page).Creation of a plug-inHere are detailled steps to create and configure a new GAMA plug-in.  File &gt; New &gt; Project &gt; plug-in project  In the “New plug-in Project” / “Plug-in project” window:          Choose as name « name_of_the_plugin » (or anything else)      Check “Use défaut location”      Check “Create a Java Project”      The project should be targeted to run with Eclipse      working set is unchecked      Click on “Next”        In the “New plug-in Project” / “Content” window:          Id : could contain the name of your institution and/or your project, e.g. « irit.maelia.gaml.additions »      version 1.0.0.qualifier (this latter mention is important if you plan on distributing the plugin on GAMA update site)      Name « Additions to GAML from Maelia project »      Uncheck “Generate an activator, a Java class that controls the plug-in’s life cycle” ,      Uncheck “This plug-in will make contributions to the UI”      Check “No” when its asks “Would you like to create a rich client application ?”      Click on “Next”        In the “New plug-in Project” / “Templates” window:          Uncheck “Create a plug-in using one of the templates”      Click on “Finish”      Your plug-in has been created.  Edit the file “Manifest.MF”:          Overview pane:                  check « This plug-in is a singleton »                    Dependencies pane:                  add (at least minimum) the three plug-ins “msi.gama.core”, “msi.gama.ext” and “msi.gama.processor” in the “Required Plug-ins”. When you click on “Add”, a new window will appear without any plug-in. Just write the beginning of the plug-in name in the text field under “Select a plug-in”.                    Runtime pane:                  In exported Packages: nothing (but when you will have implemented new packages in the plug-in you should add them there)          Add in the classpath all the additional libraries (.jar files) used in the project.                    Extensions pane:                  “Add” “gaml.extension”                    Save the file. This should create a “plugin.xml” file.        Select the project and in menu Project &gt; Properties:          Java Compiler  &gt; Annotation Processing: check “Enable project specific settings”, then in “Generated Source Directory”, change “.apt_generated” in “gaml”,      Java Compiler  &gt; Annotation Processing &gt; Factory path: check “Enable project specific settings”, then “Add Jars” and choose “msi.gama.processor/processor/plugins/msi.gama.processor.1.4.0.jar”      Close the menu. It should compile the project and create the gaml directory.      Return in the Project &gt; Properties Menu.      In Java Buildpath  &gt; Source, check that the gaml directory has been added. Otherwise click on Add Folder and select the gaml directory      The plug-in is ready to accept any addition to the GAML language, e.g. skills, actions, operators.Do not forget to export the created packages that could be used by “clients”, especially the packages containing the code of the additions (in the plugin.xml of the new project, tab “Runtime”).To test the plug-in and use it into GAMA, developers have to define a new feature project containing your plugin and its dependencies, and adds this feature to the existing product (or a new .product file of your own).The use of feature is also mandatory to define a plug-in that can be uploaded on the update site and can be installed in the release of GAMA.Creation of a featureA feature is an Eclipse project dedicated to gather one or several plug-ins to integrate them into a product or to deploy them on the update site and install them from the GAMA release (a feature is mandatory in this case).Here are detailled steps to create and configure a new feature.  File &gt; New &gt; Feature project (or File &gt; New &gt; Project… then  Plug-in Development &gt; Feature Project)  In Feature properties          Choose a project name (e.g. “institution.gama.feature.pluginsName”)      Click on “Next”        In Referenced Plug-ins and fragments          Check “Initialize from the plug-ins list:”      Choose the plug-ins that have to be gathered in the feature      Click on “Finish”        A new project has been created. The “feature.xml” file will configure the feature.          In “Information pane”:                  You can add description of the various plug-ins of the feature, define the copyright notice and the licence.                    In “Plug-ins and Fragments”                  In the Plug-ins and Fragments, additional plug-ins can be added.                    Addition of a feature to the productIn the product, e.g. gama.product in the ummisco.gama.product project:  Contents pane          Click on Add button      In the window select the feature      Click on OK.      Remark: To check whether the new plug-in has been taken into account by GAMA, after GAMA launch, it should appear in the Eclipse console in a line beginning by “» GAMA bundle loaded in “.How to make a plug-in available at GAMA update site for the GAMA releaseConsidering a working GAMA plugin named institution.gama.pluginsNameConfigure plugin to be available for Mavena/ Add pom.xml for plugin institution.gama.pluginsName :  Right click -&gt; Configure -&gt; Convert to maven project to add pom.xml:  Set:          Group id: institution.gama.pluginsName      Artifact id: institution.gama.pluginsName      Version: 1.0.0-SNAPSHOT // must have -SNAPSHOT if the plugin version is x.x.x.qualifier      Packaging: eclipse-plugin        Finishb/ Configure pom.xml to recognize the parent pom.xml for Maven builds  Open pom.xml in institution.gama.pluginsName  Tab overview, Parent section, type in:          Group id: msi.gama      Artifact id: msi.gama.experimental.parent      Version: 1.7.0-SNAPSHOT      Relative path: ../msi.gama.experimental.parent        Savec/ Update maven cache in eclipse (optional)It will fix this compilation error “Project configuration is not up-to-date with pom.xml. Select: Maven-&gt;Update Project… from the project context menu or use Quick Fix.”  Right click -&gt; Maven -&gt; Update projectCreate a feature for the plugina/ Create new feature  New -&gt; Project -&gt; type in : feature -&gt; Select “Feature Project”  Set:          Project name: institution.gama.feature.pluginsName      Uncheck use default location, type in: {current git repository}\\aaa.bbb.feature.ccc      Feature Version: 1.0.0.qualifier      Update Site URL: http://updates.gama-platform.org/experimental      Update Site Name: GAMA 1.7.x Experimental Plugins Update Site        Click Next          Initialize from the plugin list -&gt; check all plugins needed:institution.gama.pluginsName (1.0.0.qualifier)        Finishb/  Add pom.xml for feature institution.gama.feature.pluginsName :  Right click -&gt; Configure -&gt; Convert to maven project (to add pom.xml)  Set:          Group id: institution.gama.feature.pluginsName      Artifact id: institution.gama.feature.pluginsName      Version: 1.0.0-SNAPSHOT      Packaging: eclipse-feature        Finishc/ Configure pom.xml to recognize the parent pom.xml for Maven builds  Open pom.xml in institution.gama.pluginsName  Tab overview, Parent section, type in:          Group id: msi.gama      Artifact id: msi.gama.experimental.parent      Version: 1.7.0-SNAPSHOT      Relative path: ../msi.gama.experimental.parent        Saved/ Update maven cache in eclipse (optional)It will fix this compilation error “Project configuration is not up-to-date with pom.xml. Select: Maven-&gt;Update Project… from the project context menu or use Quick Fix.”  Right click -&gt; Maven -&gt; Update projectUpdate p2updatesite category.xml (this step will be done automatically by travis, soon)Open msi.gama.experimental.p2updatesite  Tab Managing the Categories -&gt; Add feature -&gt; institution.gama.feature.pluginsNameHow to make a plug-in available as an extension for the GAMA release (obsolete)Once the plug-in has been tested in the GAMA SVN version, it can be made available for GAMA release users.First, the update_site should be checked out from the SVN repository:  File &gt; New &gt; Other… &gt; SVN &gt; Project from SVN  In Checkout Project from SVN repository          Use existing repository location (it is the same location as for the GAMA code)      Next        In Select resource:          Browse                  choose svn &gt; update_site                    Finish        FinishNow the update_site project is available in the project list (in Package Explorer).The sequel describes how to add a new feature to the update site.  Open the site.xml file  In update site Map:          Click on Extensions      click on the Add Feature… button                  Choose the feature to be added          It should appear in Extensions                    Select the added feature and click on the Synchronize… button                  Check Synchronize selected features only          Finish                    Select the added feature and click on the Build button        All the files and folder of the update_site project have been modified.  Commit all the modifications on the SVN repository          Richt-click on the project, Team &gt; Update      Richt-click on the project, Team &gt; Commit…      The plug-in is now available as an extension from the GAMA release.More details about the update of the GAMA realease are available on the dedicated page.",
        "url":"/wiki/DevelopingPlugins.html"
      }
      ,
    
      "wiki-developingskills-html": {
        "title": "Developing a New Skill",
        "content": "Developing a New SkillA skill adds new features (attributes) and new capabilities (actions) to the instances of the species that use it.Defining the classA Skill is basically a singleton and stateless Java class that:  extends the abstract class Skill,  begins by the annotation @skill: @skill(name = \"name_of_the_skill_in_gaml\").Note: GAMA annotations are classes defined into the msi.gama.precompiler.GamlAnnotations class.Defining new attributesTo add new attributes to the species that declares this skill, developers have to define them before the class using the @vars and @var annotations.The @vars annotation contains a set of @var elements.In a @var element, one has to define the name, the type and the default value of the attribute. For example in MovingSkill:@vars({  @var(name = IKeyword.SPEED, type = IType.FLOAT, init = \"1.0\"),  @var(name = IKeyword.HEADING, type = IType.INT, init = \"rnd(359)\")})In order to detail how to access these new attributes (if needed), developers have to define a getter (using @getter) and a setter (using @setter) methods.If no getter (and setter) is defined, the attribute can nevertheless be set and get, using implicit by default getter and setter. But as soon as a getter and/or a setter is defined, they replace the implicit default ones.For example:@getter(var = IKeyword.SPEED)public double getSpeed(final IAgent agent) {    return (Double) agent.getAttribute(IKeyword.SPEED);}@setter(IKeyword.SPEED)public void setSpeed(final IAgent agent, final double s) {    agent.setAttribute(IKeyword.SPEED, s);}Defining new actionsAn action (also called primitive) is basically a Java method that can be called from the GAML language using the same syntax as the one used for calling actions defined in a model. The method should be annotated with @action, supplying the name of the action as it will be available in GAML.The developer can also define parameters for this action using the annotation @arg will a set of parameters names. For example, the action goto of the MovingSkill is defined as follows:@action(name=\"goto\", args={     @arg(name = \"target\", type = { IType.AGENT, IType.POINT,IType.GEOMETRY }, optional = false),    @arg(name = IKeyword.SPEED, type = IType.FLOAT, optional = true),    @arg(name = \"on\", type = { IType.GRAPH }, optional = true)    })public IPath primGoto(final IScope scope) throws GamaRuntimeException {...}It is called in GAMA models with:do goto (target: the_target, on: the_graph);orpath path_followed &lt;- self goto (target: the_target, on: the_graph, return_path: true);Access to parameters in actionsTo get the value of the arguments passed in GAML to the Java code, two methods can be useful:  scope.hasArg(\"name_of_argument\") returns a boolean value testing whether the argument “name_of_argument” has been defined by the modeler, since all the arguments to actions should be considered as optional.  getArg(name_arg,IType), getFloatArg(name_param_of_float), getIntArg(name_param_of_int) and their variants return the value of the given parameter using a given (or predefined) type to cast it.WarningsDevelopers should notice that:  the method associated with an action has to return a non-void object.  the method should have only one parameter: the scope (type IScope).  the method can only throw GamaRuntimeExceptions. Other exceptions should be caught in the method and wrapped in a GamaRuntimeException before being thrown.Annotations@skillThis annotations Allows to define a new skill (class grouping variables and actions that can be used by agents).This annotation contains:  name (String): a String representing the skill name in GAML (must be unique throughout GAML).  attach_to (set of strings): an array of species names to which the skill will be automatically added (complements the “skills” parameter of species).  internal (boolean, false by default): return whether this skill is for internal use only.  doc (set of @doc, empty by default): the documentation associated to the skill.@varThis annotations is used to describe a single variable or field.This annotation contains:  name (String): the name of the variable as it can be used in GAML.  type (int): The textual representation of the type of the variable (see IType).  of (int, 0 by default): The textual representation of the content type of the variable (see IType#defaultContentType()).  index (int, 0 by default): The textual representation of the index type of the variable (see IType#defaultKeyType()).  constant (int, false by default): returns whether or not this variable should be considered as non modifiable.  init (String, “” by default): the initial value of this variable as a String that will be interpreted by GAML.  depend_on (set of Strings, empty by default): an array of String representing the names of the variables on which this variable depends (so that they are computed before).  internal (boolean, false by default): return whether this var is for internal use only.  doc (set of @doc, empty by default): the documentation associated to the variable.@docIt provides a unified way of attaching documentation to the various GAML elements tagged by the other annotations. The documentation is automatically assembled at compile time and also used at runtime in GAML editors.  value (String, “” by default): a String representing the documentation of a GAML element.  deprecated (String, “” by default): a String indicating (if it is not empty) that the element is deprecated and defining, if possible, what to use instead.  returns (String, “” by default): the documentation concerning the value(s) returned by this element (if any)..  comment (String, “” by default): an optional comment that will appear differently from the documentation itself.  special_cases (set of Strings, empty by default): an array of String representing the documentation of the “special cases” in which the documented element takes part.  examples (set of Strings, empty by default): an array of String representing some examples or use-cases about how to use this element.  see (set of Strings, empty by default): an array of String representing cross-references to other elements in GAML.@getterThis annotations is used to indicate that a method is to be used as a getter for a variable defined in the class. The variable must be defined on its own (in vars).This annotation contains:  value (String): the name of the variable for which the annotated method is to be considered as a getter.  initializer (boolean, false by default): returns whether or not this getter should also be used as an initializer@setterThis annotations is used to indicate that a method is to be used as a setter for a variable defined in the class. The variable must be defined on its own (in vars).This annotation contains:  value (String): the name of the variable for which the annotated method is to be considered as a setter.@actionThis annotations is used to tag a method that will be considered as an action (or primitive) in GAML.The method must have the following signature: Object methodName(IScope) throws GamaRuntimeException and be contained in a class annotated with @species or @skill (or a related class, like a subclass or an interface).This annotation contains:  name (String): the name of the variable as it can be used in GAML.  virtual (boolean, false by default): if true the action is virtual, i.e. equivalent to abstract method in java.  args (set of arg, empty by default): the list of arguments passed to this action. Each argument is an instance of arg.  doc (set of @doc, empty by default): the documentation associated to the action.@argThis annotations describes an argument passed to an action.This annotation contains:  name (String, “” by default): the name of the argument as it can be used in GAML.  type (set of ints, empty by default): An array containing the textual representation of the types that can be taken by the argument (see IType).  optional (boolean, true by default): whether this argument is optional or not.  doc (set of @doc, empty by default): the documentation associated to the argument.All these annotations are defined in the GamlAnnotations.java file of the msi.gama.processor plug-in.",
        "url":"/wiki/DevelopingSkills.html"
      }
      ,
    
      "wiki-developingspecies-html": {
        "title": "Developing Species",
        "content": "Developing SpeciesAdditional built-in species can be defined in Java in order to be used in GAML models. Additional attributes and actions can be defined. It could be very useful in order to define its behavior thanks to external libraries (e.g. mulit-criteria decision-making, database connection…).A new built-in species extends the GamlAgent class, which defines the basic GAML agents. As a consequence, new built-in species have all the attributes (name, shape, …) and actions (die…) of regular species.ImplementationA new species can be any Java class that:  extends the GamlAgent class,  begins by the @species: @species(name = \"name_of_the_species_gaml\"),    @species(name = \"multicriteria_analyzer\")public class MulticriteriaAnalyzer extends GamlAgent {      Similarly to skills, a species can define additional attributes and actions.Additional attributesDefining new attributes needs:  to add @vars (and one embedded @var per additional attribute) annotation on top of the class,  to define @setter and @getter annotations to the accessors methods.For example, regular species are defined with the following annotation:@vars({ @var(name = IKeyword.NAME, type = IType.STRING), @var(name = IKeyword.PEERS, type = IType.LIST),\t@var(name = IKeyword.HOST, type = IType.AGENT),\t@var(name = IKeyword.LOCATION, type = IType.POINT, depends_on = IKeyword.SHAPE),\t@var(name = IKeyword.SHAPE, type = IType.GEOMETRY) })And accessors are defined using:@getter(IKeyword.NAME)public abstract String getName();@setter(IKeyword.NAME)public abstract void setName(String name);Additional actionsAn additional action is a method annotated by the @action annotation.@action(name = ISpecies.stepActionName)public Object _step_(final IScope scope) {Annotations@speciesThis annotation represents a “species” in GAML. The class annotated with this annotation will be the support of a species of agents.This annotation contains:  name (string): the name of the species that will be created with this class as base. Must be unique throughout GAML.  skills (set of strings, empty by default): An array of skill names that will be automatically attached to this species. Example:  @species(value=\"animal\" skills={\"moving\"})  internal (boolean, false by default): whether this species is for internal use only.  doc (set of @doc, empty by default): the documentation attached to this operator.All these annotations are defined in the GamlAnnotations.java file of the msi.gama.processor plug-in.",
        "url":"/wiki/DevelopingSpecies.html"
      }
      ,
    
      "wiki-developingstatements-html": {
        "title": "Developing Statements",
        "content": "Developing StatementsStatements are a fundamental part of GAML, as they represent both commands (imperative programming style) or declarations (declarative programming style). Developing a new statement allows, then, to add a new instruction to GAML.Defining the classA new statement must be a Java class that:  either implements the interface IStatement or extends an existing implementation of this interface (like AbstractStatement or AbstractSequenceStatement).  begins by the 2 following mandatory annotations:          @symbol: @symbol(name = \"name_of_the_statement_gaml\", kind = \"kind_of_statement\", with_sequence = true/false),      @inside: @symbol(kinds = {\"kind_of_statement_1\",\"kind_of_statement_2\",\"...\"}      In addition the 4 following optional annotations can be added:  @facets: to describe the set of @facet annotations,  @doc: to document the statement.  @serializer: in addition, statements can benefit from a custom serializer, by declaring @serializer(CustomSerializer.class), with a class extending SymbolSerializer.  @validator: in addition, statements can benefit from a custom validation during the validation process, by declaring @validator(CustomValidator.class) with a class implementing IDescriptionValidator as value. This class will receive the IDescription of the statement and be able to execute further validations on the type of expressions, etc. or even to change the IDescription  (by adding new information, changing the value of facets, etc.).Note: GAMA annotations are classes defined into the msi.gama.precompiler.GamlAnnotations class.ExamplesThe write statementThe write statement is an example of a SINGLE_STATEMENT (i.e. statement that does not embed a sequence of statements).It can used inside a BEHAVIOR statement (i.e. reflex, init…), a SEQUENCE_STATEMENT (e.g. loop, ask, if…) or a LAYER statement.It defines a single facet (“message”) mandatory and omissible.@symbol(name = IKeyword.WRITE, kind = ISymbolKind.SINGLE_STATEMENT, with_sequence = false)@inside(kinds = { ISymbolKind.BEHAVIOR, ISymbolKind.SEQUENCE_STATEMENT, ISymbolKind.LAYER })@facets(value = {         @facet(name = IKeyword.MESSAGE, type = IType.NONE, optional = false)    }, omissible = IKeyword.MESSAGE)public class WriteStatement extends AbstractStatement {The aspect statementThe aspect statement defines an example of BEHAVIOR statement (i.e. a statement that can written at the same level as init, reflex…), containing a sequence of embedded statements. It can only be used inside a species statement (i.e. the definition of a new species) and the global block. It defines a single facet name mandatory and omissible.@symbol(name = { IKeyword.ASPECT }, kind = ISymbolKind.BEHAVIOR, with_sequence = true, unique_name = true)@inside(kinds = { ISymbolKind.SPECIES, ISymbolKind.MODEL })@facets(value = { @facet(name = IKeyword.NAME, type = IType.ID, optional = true)    }, omissible = IKeyword.NAME)public class AspectStatement extends AbstractStatementSequence {The action statementThe action statement defines an example of ACTION statement containing a sequence of embedded statements and that can have arguments.It can be used (to define an action) in any species, experiment or global statement. It defines several facets and uses a custom validator and a custom serializer.@symbol(name = IKeyword.ACTION, kind = ISymbolKind.ACTION, with_sequence = true, with_args = true, unique_name = true)@inside(kinds = { ISymbolKind.SPECIES, ISymbolKind.EXPERIMENT, ISymbolKind.MODEL })@facets(value = {\t@facet(name = IKeyword.NAME, type = IType.ID, optional = false),\t@facet(name = IKeyword.TYPE, type = IType.TYPE_ID, optional = true, internal = true),\t@facet(name = IKeyword.OF, type = IType.TYPE_ID, optional = true, internal = true),\t@facet(name = IKeyword.INDEX, type = IType.TYPE_ID, optional = true, internal = true),\t@facet(name = IKeyword.VIRTUAL, type = IType.BOOL, optional = true)     }, omissible = IKeyword.NAME)@validator(ActionValidator.class)@serializer(ActionSerializer.class)public class ActionStatement extends AbstractStatementSequenceWithArgs {ImplementationAll the statements inherits from the abstract class AbstractStatement. Statements with a sequence of embedded statements inherit from the class AbstractStatementSequence (which extends AbstractStatement).The main methods of a statement class are:  its constructor, that is executed at the compilation of the model.  executeOn(final IScope scope), it executes the statement on a given scope. This method is executed at each call of the statement in the model,  privateExecuteIn(IScope scope): the executeOn(final IScope scope) method implemented in AbstractStatement does some verification and call the privateExecuteIn(IScope scope) method to perform the statement. The execution of any statement should be redefined in this method.Define a SINGLE_STATEMENT statementTo define a SINGLE_STATEMENT statement that can be executed in any behavior and sequence of statements and with 2 facets, we first define a new Java class that extends AbstractStatement such as:@symbol(name = \"testStatement\", kind = ISymbolKind.SINGLE_STATEMENT, with_sequence = false)@inside(kinds = { ISymbolKind.BEHAVIOR, ISymbolKind.SEQUENCE_STATEMENT})@facets(value = {         @facet(name = IKeyword.NAME, type = IType.NONE, optional = false),        @facet(name = \"test_facet\", type = IType.NONE, optional = true)        }, omissible = IKeyword.NAME)public class SingleStatementExample extends AbstractStatement {The class should at least implement:  a constructor: the constructor is called at the compilation. It is usually used to get the expressions given to the facets (using the getFacet(String) method) and to store it into an attribute of the class.```final IExpression name;public SingleStatementExample(final IDescription desc) {\tsuper(desc);\tname = getFacet(IKeyword.NAME);}  * the **method privateExecuteIn**: this method is executed each time the statement is called in the model.protected Object privateExecuteIn(IScope scope) throws GamaRuntimeException { \tIAgent agent = stack.getAgentScope();\tString nameStr = null;\tif ( agent != null &amp;&amp; !agent.dead() ) {\t\tnameStr = Cast.asString(stack, name.value(stack));\t\tif ( nameStr == null ) {\t\t\tnameStr = “nil”;\t\t}\t\tGuiUtils.informConsole(nameStr);\t}\treturn nameStr;}The variable `scope` of type `IScope` can be used to:  * get the current agent with: `scope.getAgentScope()`  * evaluate an expression in the current scope: `Cast.asString(scope, message.value(scope))`### Define a statement with sequenceThis kind of statements includes SEQUENCE\\_STATEMENT (e.g. `if`, `loop`,...), BEHAVIOR (e.g. `reflex`,...)...Such a statement is defined in a class extending the `AbstractStatementSequence` class, e.g.:@symbol(name = { IKeyword.REFLEX, IKeyword.INIT }, kind = ISymbolKind.BEHAVIOR, with_sequence = true, unique_name = true)@inside(kinds = { ISymbolKind.SPECIES, ISymbolKind.EXPERIMENT, ISymbolKind.MODEL })@facets(value = { @facet(name = IKeyword.WHEN, type = IType.BOOL, optional = true),\t@facet(name = IKeyword.NAME, type = IType.ID, optional = true) }, omissible = IKeyword.NAME)@validator(ValidNameValidator.class)public class ReflexStatement extends AbstractStatementSequence {This class should only implement a constructor. The class `AbstractStatementSequence` provides a generic implementation for:  * `privateExecuteIn(IScope scope)`: it executes each embedded statement with the scope.  * `executeOn(final IScope scope)`: it executes the statement with a given scope.### Additional methods that can implementedThe following methods have a default implementation, but can be overridden if necessary:  * the **`String getTrace(final IScope scope)` method** is called to trace the execution of statements using [trace statement](Statements#trace).public String getTrace(final IScope scope) {\t// We dont trace write statements\treturn “”;}```  the setChildren(final List&lt;? extends ISymbol&gt; commands) is used to define which are the statement children to the sequence statement. By default, all the embedded statements are taken as childrenAnnotations@symbolThis annotation represents a “statement” in GAML, and is used to define its name(s) as well as some meta-data that will be used during the validation process.This annotation contains:  name (set of string, empty by default): names of the statement.  kind (int): the kind of the annotated symbol (see ISymbolKind.java for more details).  with_scope (boolean, true by default): indicates if the statement (usually a sequence) defines its own scope. Otherwise, all the temporary variables defined in it are actually defined in the super-scope.  with_sequence (boolean): indicates wether or not a sequence can or should follow the symbol denoted by this class.  with_args (boolean, false by default): indicates wether or not the symbol denoted by this class will accept arguments.  remote_context (boolean, false by default): indicates that the context of this statement is actually an hybrid context: although it will be executed in a remote context, any temporary variables declared in the enclosing scopes should be passed on as if the statement was executed in the current context.  doc (set of @doc, empty by default): the documentation attached to this symbol.@insideThis annotation is used in conjunction with symbol. Provides a way to tell where this symbol should be located in a model (i.e. what its parents should be). Either direct symbol names (in symbols) or generic symbol kinds can be used.This annotation contains:  symbols (set of Strings, empty by default): symbol names of the parents.  kinds (set of int, empty by default): generic symbol kinds of the parents (see ISymbolKind.java for more details).@facetsThis annotation describes a list of facets used by a statement in GAML.This annotation contains:  value (set of @facet): array of @facet, each representing a facet name, type..  ommissible (string): the facet that can be safely omitted by the modeler (provided its value is the first following the keyword of the statement).@facetThis facet describes a facet in a list of facets.This annotation contains:  name (String): the name of the facet. Must be unique within a symbol.  type (set of Strings): the string values of the different types that can be taken by this facet.  values (set of Strings): the values that can be taken by this facet. The value of the facet expression will be chosen among the values described here.  optional (boolean, false by default): whether or not this facet is optional or mandatory.  doc (set of @doc, empty by default): the documentation associated to the facet.@docIt provides a unified way of attaching documentation to the various GAML elements tagged by the other annotations. The documentation is automatically assembled at compile time and also used at runtime in GAML editors.  value (String, “” by default): a String representing the documentation of a GAML element.  deprecated (String, “” by default): a String indicating (if it is not empty) that the element is deprecated and defining, if possible, what to use instead.  returns (String, “” by default): the documentation concerning the value(s) returned by this element (if any)..  comment (String, “” by default): an optional comment that will appear differently from the documentation itself.  special_cases (set of Strings, empty by default): an array of String representing the documentation of the “special cases” in which the documented element takes part.  examples (set of Strings, empty by default): an array of String representing some examples or use-cases about how to use this element.  see (set of Strings, empty by default): an array of String representing cross-references to other elements in GAML.@serializerIt allows to declare a custom serializer for Symbols (statements, var declarations, species ,experiments, etc.). This serializer will be called instead of the standard serializer, superseding this last one. Serializers must be sublasses of the SymbolSerializer class.  value (Class): the serializer class.@validatorIt allows to declare a custom validator for Symbols (statements, var declarations, species ,experiments, etc.). This validator, if declared on subclasses of Symbol, will be called after the standard validation is done. The validator must be subclass of IDescriptionValidator.  value (Class): the validator class.All these annotations are defined in the GamlAnnotations.java file of the msi.gama.processor plug-in.",
        "url":"/wiki/DevelopingStatements.html"
      }
      ,
    
      "wiki-developingtypes-html": {
        "title": "Developing Types",
        "content": "Developing TypesGAML provides a given number of built-in simple types (int, bool…) and more complex ones (path, graph…).Developing a new type allows, then, to add a new data structure to GAML.ImplementationDeveloping a new type requiers the implementation of 2 Java files:  the first one that describes the data structure (e.g.: GamaColor.java to define a type color)  the second one that implements the type itself, wrapping the data structure file (e.g.: GamaColorType.java), and providing accessors to data structure attributes.The data structure fileThe class representing the data structure is a Java class annotated by:  a @vars annotation to describe the attributes of a complex type. The @vars annotation contains a set of @var elements.    @vars({ @var(name = IKeyword.COLOR_RED, type = IType.INT), @var(name = IKeyword.COLOR_GREEN, type = IType.INT),@var(name = IKeyword.COLOR_BLUE, type = IType.INT), @var(name = IKeyword.ALPHA, type = IType.INT),@var(name = IKeyword.BRIGHTER, type = IType.COLOR), @var(name = IKeyword.DARKER, type = IType.COLOR) })public class GamaColor extends Color implements IValue {      It can contain setter and/or getter for each of its attributes. Setters and getters are methods annotated by the @getter or @setter annotations.@getter(IKeyword.COLOR_RED)public Integer red() {\treturn super.getRed();}In addition it is recommended that this class implements the IValue interface. It provides a clean way to give a string representation of the type and thus eases good serialization of the object.To this purpose the following method needs to be implemented:public abstract String stringValue(IScope scope) throws GamaRuntimeException;The type fileThe class representing the type is a Java class such that:  the class should be annotated by the @type annotation,  the class should extend the class GamaType&lt;DataStructureFile&gt; (and thus implement its 3 methods),Example (from GamaFloatType.java):@type(name = IKeyword.FLOAT, id = IType.FLOAT, wraps = { Double.class, double.class }, kind = ISymbolKind.Variable.NUMBER)Inheritance from the GamaType&lt;T&gt; classEach java class aiming at implement a type should inherit from the GamaType abstract class.Example (from GamaColorType.java):public class GamaColorType extends GamaType&lt;GamaColor&gt;This class imposes to implement the three following methods (with the example of the GamaColorType):  public boolean canCastToConst()  public GamaColor cast(IScope scope, Object obj, Object param): the way to cast any object in the type,  public GamaColor getDefault(): to define the default value of a variable of the current type.Remark: for each type, an unary operator is created with the exact name of the type. It can be used to cast any expression in the given type.This operator calls the previous cast method.Annotations@typeIt provides information necessary to the processor to identify a type.This annotation contains:  name (String, “” by default): a String representing the type name in GAML.  id (int, 0 by default): the unique identifier for this type. User-added types can be chosen between IType.AVAILABLE_TYPE and IType.SPECIES_TYPE (exclusive) (cf. IType.java).  wraps (tab of Class, null by default): the list of Java Classes this type is “wrapping” (i.e. representing). The first one is the one that will be used preferentially throughout GAMA. The other ones are to ensure compatibility, in operators, with compatible Java classes (for instance, List and GamaList).  kind (int, ISymbolKind.Variable.REGULAR by default): the kind of Variable used to store this type. See ISymbolKind.Variable.  internal (boolean, false by default): whether this type is for internal use only.  doc (set of @doc, empty by default): the documentation associated to the facet.All these annotations are defined in the file GamlAnnotations.java.",
        "url":"/wiki/DevelopingTypes.html"
      }
      ,
    
      "wiki-diffusion-statement-anisotropic-diffusion-simple-html": {
        "title": "Anisotropic diffusion (Simple)",
        "content": "Anisotropic diffusion (Simple)Author : Benoit GaudouThis model is used to show how to construct an anisotropic diffusion through a grid. The cell at the center of the grid emit a pheromon at each step, which is spread through the grid thanks to the diffusion mechanism, using a particular matrix of diffusion. == $0Code of the model :model anisotropic_diffusionglobal {\tint size &lt;- 64; // better to have a pow of 2 for the size of the grid  \tgeometry shape &lt;- envelope(square(size) * 10);  \tcells selected_cells;  \t  \t// Declare the anisotropic matrix (diffuse to the left-upper direction)\tmatrix&lt;float&gt; mat_diff &lt;- matrix([\t\t\t\t\t\t\t\t\t[4/9,2/9,0/9],\t\t\t\t\t\t\t\t\t[2/9,1/9,0.0],\t\t\t\t\t\t\t\t\t[0/9,0.0,0.0]]);\t\treflex diff { \t\tdiffuse var: phero on: cells matrix:mat_diff;\t}\t// Initialize the emiter cell as the cell at the center of the word\tinit {\t\tselected_cells &lt;- location as cells;\t}\treflex new_Value {\t\task selected_cells {\t\t\tphero &lt;- 1.0;\t\t}\t}}grid cells height: size width: size {\t// \"phero\" is the variable storing the value of the diffusion\tfloat phero  &lt;- 0.0;\t// the color of the cell is linked to the value of \"phero\".\trgb color &lt;- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);\t// Update the \"grid_value\", which will be used for the elevation of the cell\tfloat grid_value update: phero * 100;} experiment diffusion type: gui {\toutput {\t\tdisplay a type: opengl {\t\t\t// Display the grid with elevation\t\t\tgrid cells elevation: true triangulation: true;\t\t}\t}}",
        "url":"/wiki/Diffusion-Statement-Anisotropic-Diffusion-(Simple).html"
      }
      ,
    
      "wiki-diffusion-statement-anisotropic-diffusion-toroidal-html": {
        "title": "Anisotropic diffusion (Toroidal)",
        "content": "Anisotropic diffusion (Toroidal)Author : Benoit GaudouThis model is used to show how to construct an anisotropic diffusion through a grid. The cell at the center of the grid emit a pheromon at each step, which is spread through the grid thanks to the diffusion mechanism, using a particular matrix of diffusion, in a toroidal world. == $0Code of the model :model anisotropic_diffusion_torusglobal torus: true {\tint size &lt;- 64; // better to have a pow of 2 for the size of the grid  \tgeometry shape &lt;- envelope(square(size) * 10);  \tcells selected_cells;  \tmatrix&lt;float&gt; mat_diff &lt;- matrix([\t\t\t\t\t\t\t\t\t[4/9,2/9,0/9],\t\t\t\t\t\t\t\t\t[2/9,1/9,0.0],\t\t\t\t\t\t\t\t\t[0/9,0.0,0.0]]);\tinit {\t\tselected_cells &lt;- location as cells;\t}\treflex new_Value {\t\task selected_cells{\t\t\tphero &lt;- 1.0;\t\t}  \t}\treflex diff {\t\tdiffuse var: phero on: cells matrix: mat_diff method:dot_product;\t\t}}grid cells height: size width: size  {\tfloat phero  &lt;- 0.0;\trgb color &lt;- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);\tfloat grid_value update: phero * 100;} experiment diffusion type: gui {\toutput {\t\tdisplay a type: opengl {\t\t\tgrid cells elevation: true triangulation: true;\t\t}\t}}",
        "url":"/wiki/Diffusion-Statement-Anisotropic-Diffusion-(Toroidal).html"
      }
      ,
    
      "wiki-diffusion-statement-anisotropic-diffusion-various-methods-html": {
        "title": "Anisotropic diffusion with several computation method",
        "content": "Anisotropic diffusion with several computation methodAuthor : Benoit GaudouThis model is used to show two different computation methods to use diffusion : with the dot product method and with the convolution method. The cell at the center of the grid emit a pheromon at each step, which is spread through the grid thanks to the diffusion mechanism, using a particular matrix of diffusion. == $0 == $0Code of the model :model diffusion_computation_methodglobal{\tint size &lt;- 64; // better to have a pow of 2 for the size of the grid  \tgeometry shape &lt;- envelope(square(size) * 10);  \tcells_dot selected_cells_dot;  \tcells_convol selected_cells_convol;  \t// Declare the anisotropic matrix (diffuse to the left-upper direction)  \tmatrix&lt;float&gt; mat_diff &lt;- matrix([\t\t\t\t\t\t\t\t\t[2/9,2/9,1/9],\t\t\t\t\t\t\t\t\t[2/9,1/9,0.0],\t\t\t\t\t\t\t\t\t[1/9,0.0,0.0]]);\t// Initialize the emiter cell as the cell at the center of the word\tinit {\t\tselected_cells_dot &lt;- location as cells_dot;  \t\tselected_cells_convol &lt;- location as cells_convol;\t}\treflex new_Value {\t\task(selected_cells_dot){\t\t\tphero &lt;- 1.0;\t\t}\t\task(selected_cells_convol){\t\t\tphero &lt;- 1.0;\t\t}\t\t\t}\treflex diff {\t\t// Declare a diffusion on the grid \"cells_dot\" (with a dot product computation) and on \"cells_convol\" (with a convol computation). \t\t// The value of the diffusion will be store in the new variable \"phero\" of the cell.\t\tdiffuse var: phero on: cells_dot matrix: mat_diff method: \"dot_product\";\t\t\tdiffuse var: phero on: cells_convol matrix: mat_diff method: \"convolution\";\t\t\t\t}}grid cells_dot height: size width: size {\t// \"phero\" is the variable storing the value of the diffusion\tfloat phero  &lt;- 0.0;\t// The color of the cell is linked to the value of \"phero\".\trgb color &lt;- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);\t// Update the \"grid_value\", which will be used for the elevation of the cell\tfloat grid_value update: phero * 100;} grid cells_convol height: size width: size {\t// \"phero\" is the variable storing the value of the diffusion\tfloat phero  &lt;- 0.0;\t// The color of the cell is linked to the value of \"phero\".\trgb color &lt;- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);\t// Update the \"grid_value\", which will be used for the elevation of the cell\tfloat grid_value update: phero * 100;} experiment diffusion type: gui {\toutput {\t\tdisplay dot type: opengl {\t\t\t// Display the grid with elevation\t\t\tgrid cells_dot elevation: true triangulation: true;\t\t}\t\tdisplay convol type: opengl {\t\t\t// Display the grid with elevation\t\t\tgrid cells_convol elevation: true triangulation: true;\t\t}\t}}",
        "url":"/wiki/Diffusion-Statement-Anisotropic-Diffusion-(Various-Methods).html"
      }
      ,
    
      "wiki-diffusion-statement-blend-color-in-a-cuve-multiple-signals-html": {
        "title": "Blend color in a cuve",
        "content": "Blend color in a cuveAuthor : Julien MazarsThis model is used to show how we can diffuse several variables in the same grid. At the cycle 0, 3 different pheromons are emited in 3 of the 4 corners of the cuve (each one associated to a color). Thanks to the diffusion mechanism, all the 3 colors will blend each other. The process is accelerated by using the facet “cycle_length”. The “avoid_mask” facet is used in order to have a constant sum of pheromon. == $0Code of the model :model cycle_lengthglobal {\tint size &lt;- 64; // better to have a pow of 2 for the size of the grid\tint cycle_length &lt;- 5;  \tgeometry shape &lt;- envelope(square(size));  \tlist&lt;cells&gt; top_left_cells;  \tlist&lt;cells&gt; top_right_cells;  \tlist&lt;cells&gt; bot_left_cells;  \t// Declare the uniform matrix  \tmatrix&lt;float&gt; mat_diff &lt;- matrix([\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9],\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9],\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9]]);\t// Initialize the emiter cells\tinit {\t\ttop_left_cells &lt;- list&lt;cells&gt;(cells where (each.grid_x &lt; location.x\t\t\tand each.grid_x &gt; cycle_length\t\t\tand each.grid_y &lt; location.y\t\t\tand each.grid_y &gt; cycle_length\t\t));\t\ttop_right_cells &lt;- list&lt;cells&gt;(cells where (each.grid_x &lt; size-cycle_length\t\t\tand each.grid_x &gt; location.x\t\t\tand each.grid_y &lt; location.y\t\t\tand each.grid_y &gt; cycle_length\t\t));\t\tbot_left_cells &lt;- list&lt;cells&gt;(cells where (each.grid_x &lt; location.x\t\t\tand each.grid_x &gt; cycle_length\t\t\tand each.grid_y &lt; size-cycle_length\t\t\tand each.grid_y &gt; location.y\t\t));\t}\treflex init_value when:cycle=0 {\t\task(top_left_cells){\t\t\tphero1 &lt;- 1.0;\t\t}\t\task(top_right_cells){\t\t\tphero2 &lt;- 1.0;\t\t}\t\task(bot_left_cells){\t\t\tphero3 &lt;- 1.0;\t\t}\t\t}\treflex diff {\t\t// Declare a diffusion on the grid \"cells\" for each one of the pheromons. \t\t// In order to not loosing phero value, we apply a hand made mask (with the operator \"where\") and we turn the \"avoid_mask\" facet to true.\t\tlist cells_where_diffuse &lt;- cells where (each.grid_x &lt; size-cycle_length and each.grid_x &gt; cycle_length and each.grid_y &lt; size-cycle_length and each.grid_y &gt; cycle_length);\t\tdiffuse var: phero1 on: cells_where_diffuse matrix: mat_diff avoid_mask: true method:dot_product cycle_length:cycle_length;\t\tdiffuse var: phero2 on: cells_where_diffuse matrix: mat_diff avoid_mask: true method:dot_product cycle_length:cycle_length;\t\tdiffuse var: phero3 on: cells_where_diffuse matrix: mat_diff avoid_mask: true method:dot_product cycle_length:cycle_length;\t}}grid cells height: size width: size {\t// \"phero1\", \"phero2\", \"phero3\" are the variables storing the value of the diffusion\tfloat phero1  &lt;- 0.0;\tfloat phero2  &lt;- 0.0;\tfloat phero3  &lt;- 0.0;\t// The color of the cell is construct using the 3 pheromons.\trgb color &lt;- rgb(phero1*256,phero2*256,phero3*256) update: rgb(phero1*256,phero2*256,phero3*256);} experiment diffusion type: gui {\toutput {\t\tdisplay a type: opengl {\t\t\t// Display the grid with elevation\t\t\tgrid cells elevation: (phero1+phero2+phero3)*10 triangulation: true;\t\t}\t}}",
        "url":"/wiki/Diffusion-Statement-Blend-color-in-a-cuve-(Multiple-Signals).html"
      }
      ,
    
      "wiki-diffusion-statement-diffusion-in-a-cuve-cycle-length-html": {
        "title": "Diffusion in a cuve (Cycle length)",
        "content": "Diffusion in a cuve (Cycle length)Author : Julien MazarsThis model is used to show how to use diffusion on a grid, and how to accelerate the process by computing several times the diffusion at each step. The cells at the center of the grid emit a pheromon at the cycle 0, which is spread through the grid thanks to the diffusion mechanism, using a particular matrix of diffusion. The “avoid_mask” facet is used in order to have a constant sum of pheromon. == $0 == $0Code of the model :model cycle_lengthglobal {\tint size &lt;- 64; // better to have a pow of 2 for the size of the grid\tint cycle_length &lt;- 5;  \tgeometry shape &lt;- envelope(square(size));  \tlist&lt;cells&gt; selected_cells;  \tlist&lt;quick_cells&gt; selected_quick_cells;  \t// Declare an uniform diffusion matrix  \tmatrix&lt;float&gt; mat_diff &lt;- matrix([\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9],\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9],\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9]]);\t\t\t\t\t\t\t\t\t\tint impulse_area_size &lt;- 6;\t// Initialize the emiter cells as the cells at the center of the word\tinit {\t\tselected_cells &lt;- list&lt;cells&gt;(cells where (each.grid_x &lt; location.x+impulse_area_size\t\t\tand each.grid_x &gt; location.x-impulse_area_size\t\t\tand each.grid_y &lt; location.y+impulse_area_size\t\t\tand each.grid_y &gt; location.y-impulse_area_size\t\t));\t\tselected_quick_cells &lt;- list&lt;quick_cells&gt;(quick_cells where (each.grid_x &lt; location.x+impulse_area_size\t\t\tand each.grid_x &gt; location.x-impulse_area_size\t\t\tand each.grid_y &lt; location.y+impulse_area_size\t\t\tand each.grid_y &gt; location.y-impulse_area_size\t\t));\t}\treflex init_value when:cycle=0 {\t\task(selected_cells){\t\t\tphero &lt;- 1.0;\t\t}\t\task(selected_quick_cells){\t\t\tphero &lt;- 1.0;\t\t}\t\t\t}\treflex diff {\t\t// Declare a diffusion on the grid \"cells\" and on \"quick_cells\". The diffusion declared on \"quick_cells\" will make 5 computations at each step to accelerate the process. \t\t// The value of the diffusion will be store in the new variable \"phero\" of the cell.\t\t// In order to not loosing phero value, we apply a hand made mask (with the operator \"where\") and we turn the \"avoid_mask\" facet to true.\t\tlist cells_where_diffuse &lt;- cells where (each.grid_x &lt; size-cycle_length and each.grid_x &gt; cycle_length and each.grid_y &lt; size-cycle_length and each.grid_y &gt; cycle_length);\t\tdiffuse var: phero on: cells_where_diffuse matrix: mat_diff avoid_mask: true method:dot_product;\t\t\tlist quick_cells_where_diffuse &lt;- quick_cells where (each.grid_x &lt; size-cycle_length and each.grid_x &gt; cycle_length and each.grid_y &lt; size-cycle_length and each.grid_y &gt; cycle_length);\t\tdiffuse var: phero on: quick_cells_where_diffuse matrix: mat_diff avoid_mask: true cycle_length: 10 method:dot_product;\t}}grid cells height: size width: size {\t// \"phero\" is the variable storing the value of the diffusion\tfloat phero  &lt;- 0.0;\t// The color of the cell is linked to the value of \"phero\".\trgb color &lt;- (phero = 0) ? #black : hsb(phero,1.0,1.0) update: (phero = 0) ? #black : hsb(phero,1.0,1.0);} grid quick_cells height: size width: size {\t// \"phero\" is the variable storing the value of the diffusion\tfloat phero  &lt;- 0.0;\t// The color of the cell is linked to the value of \"phero\".\trgb color &lt;- (phero = 0) ? #black : hsb(phero,1.0,1.0) update: (phero = 0) ? #black : hsb(phero,1.0,1.0);} experiment diffusion type: gui {\toutput {\t\tdisplay a type: opengl {\t\t\t// Display the grid with elevation\t\t\tgrid cells elevation: phero*10 triangulation: true;\t\t}\t\tdisplay quick type: opengl {\t\t\t// Display the grid with elevation\t\t\tgrid quick_cells elevation: phero*10 triangulation: true;\t\t}\t}}",
        "url":"/wiki/Diffusion-Statement-Diffusion-in-a-cuve-(Cycle-length).html"
      }
      ,
    
      "wiki-diffusion-statement-kernel-matrix-generation-html": {
        "title": "Generate diffusion matrix with parameters",
        "content": "Generate diffusion matrix with parametersAuthor : Julien MazarsThis model shows how to create a diffusion matrix by using the 4 parameters variation, proportion, radius and min-value. Manipulate the parameters to see in real time the result. The number displayed in each cells are the ratio of the initial signal diffused at the end of a step. == $0Code of the model :model kernelmatrixgenerationglobal {\t// parameters\tfloat variation &lt;- 0.0;\tfloat proportion &lt;- 1.0;\tint radius &lt;- 1;\tfloat min_value &lt;- 0.0;\tint cycle_length &lt;- 1;\t\t// global variables\tint cell_max_size &lt;- 51;\tint x_min &lt;- cell_max_size;\tint x_max &lt;- 0;\tint y_min &lt;- cell_max_size;\tint y_max &lt;- 0;\t\tfloat world_size &lt;- 100.0;\tgeometry shape &lt;- cube(world_size);\t\tbuffer_cells selected_cells;\t\t// init the emiter cell as the one in the center of the world.\tinit {\t\tselected_cells &lt;- location as buffer_cells;\t\t// no need to have a faster display. Let's cool down your computer a bit ;)\t\tminimum_cycle_duration &lt;- 200#ms;\t}\t\treflex update {\t\tx_min &lt;- cell_max_size;\t\tx_max &lt;- 0;\t\ty_min &lt;- cell_max_size;\t\ty_max &lt;- 0;\t\t// copy the values of the buffer_cells (of the previous step) to the grid which will be displayed.\t\task cells {\t\t\tvalue &lt;- (location as buffer_cells).value;\t\t}\t\task buffer_cells {\t\t\t// find the boundaries of the diffusion\t\t\tif (value != 0.0) {\t\t\t\tif (grid_x &gt; x_max) {\t\t\t\t\tx_max &lt;- grid_x;\t\t\t\t}\t\t\t\tif (grid_x &lt; x_min) {\t\t\t\t\tx_min &lt;- grid_x;\t\t\t\t}\t\t\t\tif (grid_y &gt; y_max) {\t\t\t\t\ty_max &lt;- grid_y;\t\t\t\t}\t\t\t\tif (grid_y &lt; y_min) {\t\t\t\t\ty_min &lt;- grid_y;\t\t\t\t}\t\t\t}\t\t}\t\t// re-initialize the value of the buffer grid to 0, and the value of the central cell to 1.\t\task buffer_cells {\t\t\tvalue &lt;- 0.0;\t\t\tif (self = selected_cells) {\t\t\t\tvalue &lt;- 1.0;\t\t\t}\t\t}\t\t// diffuse the value over the buffer grid, according to the parameters choosen.\t\tdiffuse var:value on:buffer_cells variation:variation proportion:proportion radius:radius cycle_length:cycle_length min_value:min_value;\t}}// the buffer grid will be used to compute the diffusion at each step.grid buffer_cells height:cell_max_size width:cell_max_size {\t// the diffused variable\tfloat value &lt;- 0.0;}// this grid is the copy of the buffer grid at the end of each step. Indeed, we have to display the grid once the diffusion has been done.grid cells height:cell_max_size width:cell_max_size {\t// the diffused variable\tfloat value &lt;- 0.0;\t\taspect base {\t\t// we only display the cells wich contains a non null value\t\tif (grid_x &lt;= x_max and grid_x &gt;= x_min and grid_y &lt;= y_max and grid_y &gt;= y_min)\t\t{\t\t\t// compute dynamically the size of the current cell.\t\t\tfloat size_cell &lt;- world_size/(x_max-x_min+1);\t\t\t// compute dynamically the position of the current cell.\t\t\tpoint pos &lt;- {(grid_x-x_min+1)*size_cell-0.5*size_cell,(grid_y-y_min+1)*size_cell-0.5*size_cell};\t\t\t// display each cell as a square. The color is linked to the value of the diffused variable.\t\t\tdraw square(size_cell) color:hsb(value,1.0,1.0) border:#black at:pos;\t\t\t// display the ratio in each square.\t\t\tdraw string(value) at: pos + {-size_cell/3,0} color: °black font: font(\"Helvetica\", size_cell * #zoom * 2/3, #bold) perspective:true;\t\t}\t}}experiment my_experiment type:gui {\tparameter \"proportion\" var:proportion;\tparameter \"variation\" var:variation;\tparameter \"min_value\" var:min_value;\tparameter \"radius\" var:radius;\tparameter \"cycle_length\" var:cycle_length;\toutput {\t\tdisplay my_display {\t\t\tspecies cells aspect:base;\t\t}\t}}",
        "url":"/wiki/Diffusion-Statement-Kernel-matrix-generation.html"
      }
      ,
    
      "wiki-diffusion-statement-uniform-diffusion-html": {
        "title": "Uniform diffusion",
        "content": "Uniform diffusionAuthor : Benoit GaudouThis model is used to show how a diffusion works with a uniform matrix of diffusion in a grid. The cell at the center of the grid emit a pheromon at each step, which is spread through the grid thanks to the diffusion mechanism. Without passing a diffusion matrix, the default diffusion matrix is a uniform matrix 3x3, with value 1/nb_neighbors. == $0 == $0Code of the model :model uniform_diffusionglobal {\tint size &lt;- 64; // better to have a pow of 2 for the size of the grid  \tgeometry shape &lt;- envelope(square(size) * 10);  \tcells_eight_nb selected_cells_8;  \tcells_four_nb selected_cells_4;\t// Initialize the emiter cell as the cell at the center of the word\tinit {\t\tselected_cells_8 &lt;- location as cells_eight_nb;\t\tselected_cells_4 &lt;- location as cells_four_nb;\t}\treflex new_Value {\t\task selected_cells_4 {\t\t\tphero &lt;- 1.0;\t\t}\t\task selected_cells_8 {\t\t\tphero &lt;- 1.0;\t\t}\t}\treflex diff {\t\t// Declare a diffusion on the grid \"cells\", with a uniform matrix of diffusion. The value of the diffusion\t\t// will be store in the new variable \"phero\" of the cell.\t\tdiffuse var: phero on: cells_eight_nb ;\t\tdiffuse var: phero on: cells_four_nb ;\t}}grid cells_eight_nb height: size width: size neighbors: 8 {\t// \"phero\" is the variable storing the value of the diffusion\tfloat phero  &lt;- 0.0;\t// the color of the cell is linked to the value of \"phero\".\trgb color &lt;- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);\t// Update the \"grid_value\", which will be used for the elevation of the cell\tfloat grid_value update: phero * 100;} grid cells_four_nb height: size width: size neighbors: 4 {\t// \"phero\" is the variable storing the value of the diffusion\tfloat phero  &lt;- 0.0;\t// the color of the cell is linked to the value of \"phero\".\trgb color &lt;- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);\t// Update the \"grid_value\", which will be used for the elevation of the cell\tfloat grid_value update: phero * 100;} experiment diffusion type: gui {\toutput {\t\tdisplay uniform_diffusion_in_8_neighbors_grid type: opengl {\t\t\t// Display the grid with elevation\t\t\tgrid cells_eight_nb elevation: true triangulation: true;\t\t}\t\tdisplay uniform_diffusion_in_4_neighbors_grid type: opengl {\t\t\t// Display the grid with elevation\t\t\tgrid cells_four_nb elevation: true triangulation: true;\t\t}\t}}",
        "url":"/wiki/Diffusion-Statement-Uniform-Diffusion.html"
      }
      ,
    
      "wiki-diffusion-statement-uniform-diffusion-with-mask-avoid-mask-html": {
        "title": "Uniform diffusion with mask (Avoid mask)",
        "content": "Uniform diffusion with mask (Avoid mask)Author : Julien MazarsThis model is used to show how a uniform diffusion can be used with a mask. The cell at the center of the grid emit a pheromon at each step, which is spread through the grid thanks to the diffusion mechanism. A mask is used to restrict the diffusion to a “corridor” (the white part of the bmp image). The first display shows a diffusion avoiding the masked cells (the value is redistributed to the neighboring cells, to have a constant number of pheromon), the second display shows a diffusion without avoiding the masked cells (the value is diffused in the masked cell, and never rediffused again). == $0 == $0Code of the model :model diffusion_with_maskglobal {\tint grid_size &lt;- 64; // better to have a pow of 2 for the size of the grid  \tgeometry shape &lt;- envelope(square(grid_size) * 10);  \tcells_avoid_mask selected_cells1;  \tcells_diffuse_on_mask selected_cells2;  \t// Load the image mask as a matrix. The white part of the image is the part where diffusion will work, and the black part is where diffusion will be blocked.  \tmatrix mymask &lt;- file(\"../includes/complex_mask.bmp\") as_matrix({grid_size,grid_size});  \t// Declare a uniform diffusion matrix  \tmatrix&lt;float&gt; mat_diff &lt;- matrix([\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9],\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9],\t\t\t\t\t\t\t\t\t[1/9,1/9,1/9]]);\t// Initialize the emiter cell as the cell at the center of the word\tinit {\t\tselected_cells1 &lt;- location as cells_avoid_mask;\t\tselected_cells2 &lt;- location as cells_diffuse_on_mask;\t}\treflex new_Value {\t\task selected_cells1 {\t\t\tphero &lt;- 1.0;\t\t}\t\task selected_cells2 {\t\t\tphero &lt;- 1.0;\t\t}\t}\treflex diff {\t\t// Declare a diffusion on the grid \"cells\". The value of the diffusion will be store in the new variable \"phero\" of the cell.\t\tdiffuse var: phero on: cells_avoid_mask matrix: mat_diff mask: mymask avoid_mask: true;\t\tdiffuse var: phero on: cells_diffuse_on_mask matrix: mat_diff mask: mymask;\t\t}}grid cells_avoid_mask height: grid_size width: grid_size {\t// \"phero\" is the variable storing the value of the diffusion\tfloat phero &lt;- 0.0;\t// the color of the cell is linked to the value of \"phero\".\trgb color &lt;- (((mymask row_at grid_y) at grid_x) &lt; -1) ? #black : hsb(phero,1.0,1.0) update: (((mymask row_at grid_y) at grid_x) &lt; -1) ? #black : hsb(phero,1.0,1.0);\t// Update the \"grid_value\", which will be used for the elevation of the cell\tfloat grid_value update: phero * 100;} grid cells_diffuse_on_mask height: grid_size width: grid_size {\t// \"phero\" is the variable storing the value of the diffusion\tfloat phero &lt;- 0.0;\t// the color of the cell is linked to the value of \"phero\".\trgb color &lt;- (((mymask row_at grid_y) at grid_x) &lt; -1) ? #black : hsb(phero,1.0,1.0) update: (((mymask row_at grid_y) at grid_x) &lt; -1) ? #black : hsb(phero,1.0,1.0);\t// Update the \"grid_value\", which will be used for the elevation of the cell\tfloat grid_value update: phero * 100;} experiment diffusion type: gui {\toutput {\t\tdisplay a type: opengl {\t\t\t// Display the grid with elevation\t\t\tgrid cells_avoid_mask elevation: true triangulation: true;\t\t}\t\tdisplay b type: opengl {\t\t\t// Display the grid with elevation\t\t\tgrid cells_diffuse_on_mask elevation: true triangulation: true;\t\t}\t}}",
        "url":"/wiki/Diffusion-Statement-Uniform-diffusion-with-mask-(Avoid-mask).html"
      }
      ,
    
      "wiki-diffusion-statement-html": {
        "title": "Diffusion Statement",
        "content": "Diffusion StatementThis sub-section is composed of the following models :  Anisotropic diffusion (Simple) == $0  Anisotropic diffusion (Toroidal) == $0  Anisotropic diffusion with several computation method == $0 == $0  Blend color in a cuve == $0  Diffusion in a cuve (Cycle length) == $0 == $0  Generate diffusion matrix with parameters == $0  Uniform diffusion with mask (Avoid mask) == $0 == $0  Uniform diffusion == $0 == $0",
        "url":"/wiki/Diffusion-Statement.html"
      }
      ,
    
      "wiki-diffusion-html": {
        "title": "Implementing diffusion",
        "content": "Implementing diffusionGAMA provides you the possibility to represent and simulate the diffusion of a variable through a grid topology.Index  Diffuse statement  Diffusion with matrix          Diffusion matrix      Gradient matrix      Compute multiple propagations at the same step      Executing several diffusion matrix        Diffusion with parameters  Computation methods          Convolution      Dot Product        Use mask          Generalities      Tips        Pseudo codeDiffuse statementThe statement to use for the diffusion is diffuse. It has to be used in a grid species. The diffuse uses the following facets:  var (an identifier), (omissible) : the variable to be diffused  on (any type in [container, species]): the list of agents (in general cells of a grid), on which the diffusion will occur  avoid_mask (boolean): if true, the value will not be diffused in the masked cells, but will be restitute to the neighboring cells, multiplied by the variation value (no signal lost). If false, the value will be diffused in the masked cells, but masked cells won’t diffuse the value afterward (lost of signal). (default value : false)  cycle_length (int): the number of diffusion operation applied in one simulation step  mask (matrix): a matrix masking the diffusion (matrix created from a image for example). The cells corresponding to the values smaller than “-1” in the mask matrix will not diffuse, and the other will diffuse.  matrix (matrix): the diffusion matrix (“kernel” or “filter” in image processing). Can have any size, as long as dimensions are odd values.  method (an identifier), takes values in: {convolution, dot_product}: the diffusion method  min_value (float): if a value is smaller than this value, it will not be diffused. By default, this value is equal to 0.0. This value cannot be smaller than 0.  propagation (a label), takes values in: {diffusion, gradient}: represents both the way the signal is propagated and the way to treat multiple propagation of the same signal occurring at once from different places. If propagation equals ‘diffusion’, the intensity of a signal is shared between its neighbors with respect to ‘proportion’, ‘variation’ and the number of neighbours of the environment places (4, 6 or 8). I.e., for a given signal S propagated from place P, the value transmitted to its N neighbors is : S’ = (S / N / proportion) - variation. The intensity of S is then diminished by S * proportion on P. In a diffusion, the different signals of the same name see their intensities added to each other on each place. If propagation equals ‘gradient’, the original intensity is not modified, and each neighbors receives the intensity : S / proportion - variation. If multiple propagation occur at once, only the maximum intensity is kept on each place. If ‘propagation’ is not defined, it is assumed that it is equal to ‘diffusion’.  proportion (float): a diffusion rate  radius (int): a diffusion radius (in number of cells from the center)  variation (float): an absolute value to decrease at each neighborsTo write a diffusion, you first have to declare a grid, and declare a special attribute for the diffusion. You will then have to write the diffuse statement in an other scope (such as the global scope for instance), which will permit the values to be diffused at each step. There, you will specify which variable you want to diffuse (through the var facet), on which species or list of agents you want the diffusion (through the on facet), and how you want this value to be diffused (through all the other facets, we will see how it works with matrix and with special parameters just after).Here is the template of code we will use for the next following part of this page:global {\tint size &lt;- 64; // the size has to be a power of 2.  \tcells selected_cells;\t// Initialize the emiter cell as the cell at the center of the word\tinit {\t\tselected_cells &lt;- location as cells;\t}\t// Affecting \"1\" to each step\treflex new_Value {\t\task(selected_cells){\t\t\tphero &lt;- 1.0;\t\t}\t\t}\treflex diff {\t\t// Declare a diffusion on the grid \"cells\" and on \"quick_cells\". The diffusion declared on \"quick_cells\" will make 10 computations at each step to accelerate the process. \t\t// The value of the diffusion will be store in the new variable \"phero\" of the cell.\t\tdiffuse var: phero on: cells /*HERE WRITE DOWN THE DIFFUSION PROPERTIES*/;\t\t\t\t}}grid cells height: size width: size {\t// \"phero\" is the variable storing the value of the diffusion\tfloat phero  &lt;- 0.0;\t// The color of the cell is linked to the value of \"phero\".\trgb color &lt;- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);}experiment diffusion type: gui {\toutput {\t\tdisplay a type: opengl {\t\t\t// Display the grid with elevation\t\t\tgrid cells elevation: phero * 10 triangulation: true;\t\t}\t}}This model will simulate a diffusion through a grid at each step, affecting 1 to the center cell diffusing variable value. The diffusion will be seen during the simulation through a color code, and through the elevation of the cell.Diffusion with matrixA first way of specifying the behavior of your diffusion is using diffusion matrix. A diffusion matrix is a 2 dimension matrix [n][m] with float values, where both n and m have to be pair values. The most often, diffusion matrix are square matrix, but you can also declare rectangular matrix.Example of matrix:matrix&lt;float&gt; mat_diff &lt;- matrix([\t\t[1/9,1/9,1/9],\t\t[1/9,1/9,1/9],\t\t[1/9,1/9,1/9]]);In the diffuse statement, you than have to specify the matrix of diffusion you want in the facet matrix.diffuse var: phero on: cells matrix:mat_diff;Using the facet propagation, you can specify if you want the value to be propagated as a diffusion or as a gratient.Diffusion matrixA diffusion (the default value of the facet propagation) will spread the values to the neighbors cells according to the diffusion matrix, and all those values will be added together, as it is the case in the following example :Note that the sum of all the values diffused at the next step is equal to the sum of the values that will be diffused multiply by the sum of the values of the diffusion matrix. That means that if the sum of the values of your diffusion matrix is larger than 1, the values will increase exponentially at each step. The sum of the value of a diffusion matrix is usually equal to 1.Here are some example of matrix you can use, played with the template model:Gradient matrixA gradient (use facet : propagation:gradient) is an other type of propagation. This time, only the larger value diffused will be chosen as the new one.Note that unlike the diffusion propagation, the sum of your matrix can be greater than 1 (and it is the case, most often !).Here are some example of matrix with gradient propagation:Compute multiple propagations at the same stepYou can compute several times the propagation you want by using the facet cycle_length. GAMA will compute for you the corresponding new matrix, and will apply it.Writing those two thinks are exactly equivalent (for diffusion):\tmatrix&lt;float&gt; mat_diff &lt;- matrix([\t\t\t[1/81,2/81,3/81,2/81,1/81],\t\t\t[2/81,4/81,6/81,4/81,2/81],\t\t\t[3/81,6/81,1/9,6/81,3/81],\t\t\t[2/81,4/81,6/81,4/81,2/81],\t\t\t[1/81,2/81,3/81,2/81,1/81]]);\treflex diff {\t\tdiffuse var: phero on: cells matrix:mat_diff;\tmatrix&lt;float&gt; mat_diff &lt;- matrix([\t\t\t[1/9,1/9,1/9],\t\t\t[1/9,1/9,1/9],\t\t\t[1/9,1/9,1/9]]);\treflex diff {\t\tdiffuse var: phero on: cells matrix:mat_diff cycle_length:2;Executing several diffusion matrixIf you execute several times the statement diffuse with different matrix on the same variable, their values will be added (and centered if their dimension is not equal).Thus, the following 3 matrix will be combined to create one unique matrix:Diffusion with parametersSometimes writing diffusion matrix is not exactly what you want, and you may prefer to just give some parameters to compute the correct diffusion matrix. You can use the following facets in order to do that : propagation, variation and radius.Depending on which propagation you choose, and how many neighbors your grid have, the propagation matrix will be compute differently. The propagation matrix will have the size : range*2+1.Let’s note P for the propagation value, V for the variation, R for the range and N for the number of neighbors.  With diffusion propagationFor diffusion propagation, we compute following the following steps:(1) We determine the “minimale” matrix according to N (if N = 8, the matrix will be [[P/9,P/9,P/9][P/9,1/9,P/9][P/9,P/9,P/9]]. if N = 4, the matrix will be [[0,P/5,0][P/5,1/5,P/5][0,P/5,0]]).(2) If R != 1, we propagate the matrix R times to obtain a [2*R+1][2*R+1] matrix (same computation as for cycle_length).(3) If V != 0, we substract each value by V*DistanceFromCenter (DistanceFromCenter depends on N).Ex with the default values (P=1, R=1, V=0, N=8):  With gradient propagationThe value of each cell will be equal to P/POW(N,DistanceFromCenter)-DistanceFromCenter*V. (DistanceFromCenter depends on N).Ex with R=2, other parameters default values (R=2, P=1, V=0, N=8):Note that if you declared a diffusion matrix, you cannot use those 3 facets (it will raise a warning). Note also that if you use parameters, you will only have uniform matrix.Computation methodsYou can compute the output matrix using two computation methods by using the facet method : the dot product and the convolution. Note that the result of those two methods is exactly the same (except if you use the avoid_mask facet, the results can be slightly differents between the two computations).Convolutionconvolution is the default computation method for the diffusion. For every output cells, we will multiply the input values and the flipped kernel together, as shown in the following image :Pseudo-code (k the kernel, x the input matrix, y the output matrix) :for (i = 0 ; i &lt; y.nbRows ; i++)  for (j = 0 ; j &lt; y.nbCols ; j++)    for (m = 0 ; m &lt; k.nbRows ; m++)      for (n = 0 ; n &lt; k.nbCols ; n++)        y[i,j] += k[k.nbRows - m - 1, k.nbCols - n - 1]             * x[i - k.nbRows/2 + m, j - k.nbCols/2 + n]Dot Productdot_product method will compute the matrix using a simple dot product between the matrix. For every input cells, we multiply the cell by the kernel matrix, as shown in the following image :Pseudo-code (k the kernel, x the input matrix, y the output matrix) :for (i = 0 ; i &lt; y.nbRows ; i++)  for (j = 0 ; j &lt; y.nbCols ; j++)    for (m = 0 ; m &lt; k.nbRows ; m++)      for (n = 0 ; n &lt; k.nbCols ; n++)        y[i - k.nbRows/2 + m, j - k.nbCols/2 + n] += k[m, n] * x[i, j]Using maskGeneralitiesIf you want to propagate some values in an heterogeneous grid, you can use some mask to forbid some cells to propagate their values.You can pass a matrix to the facet mask. All the values smaller than -1 will not propagate, and all the values greater or equal to -1 will propagate.A simple way to use mask is by loading an image :Note that when you use the on facet for the diffuse statement, you can choose only some cells, and not every cells. In fact, when you restrain the values to be diffuse, it is exactly the same process as if you were defining a mask.When your diffusion is combined with a mask, the default behavior is that the non-masked cells will diffuse their values in all existing cells (that means, even the masked cells !). To change this behavior, you can use the facet avoid_mask. In that case, the value which was supposed to be affected to the masked cell will be redistributed to the neighboring non-masked cells.TipsMasks can be used to simulate a lot of environments. Here are some ideas for your models:Wall blocking the diffusionIf you want to simulate a wall blocking a uniform diffusion, you can declare a second diffusion matrix that will be applied only on the cells where your wall will be. This diffusion matrix will “push” the values outside from himself, but conserving the values (the sum of the values of the diffusion still have to be equal to 1) :matrix&lt;float&gt; mat_diff &lt;- matrix([\t\t\t[1/9,1/9,1/9],\t\t\t[1/9,1/9,1/9],\t\t\t[1/9,1/9,1/9]]);\t\t\t\t\t\t\t\tmatrix&lt;float&gt; mat_diff_left_wall &lt;- matrix([\t\t\t[0.0,0.0,2/9],\t\t\t[0.0,0.0,4/9],\t\t\t[0.0,0.0,2/9]]);reflex diff { \tdiffuse var: phero on: (cells where(each.grid_x&gt;30)) matrix:mat_diff;\tdiffuse var: phero on: (cells where(each.grid_x=30)) matrix:mat_diff_left_wall;}Note that almost the same result can be obtained by using the facet avoid_mask : the value of all masked cells will remain at 0, and the value which was supposed to be affected to the masked cell will be distributed to the neighboring cells. Notice that the results can be slightly different if you are using the convolution or the dot_product method : the algorithm of redistribution of the value to the neighboring cells is a bit different. We advise you to use the dot_product with the avoid_mask facet, the results are more accurates.Wind pushing the diffusionLet’s simulate a uniform diffusion that is pushed by a wind from “north” everywhere in the grid. A wind from “west” as blowing at the top side of the grid. We will here have to build 2 matrix : one for the uniform diffusion, one for the “north” wind and one for the “west” wind. The sum of the values for the 2 matrix meant to simulate the wind will be equal to 0 (as it will be add to the diffusion matrix).matrix&lt;float&gt; mat_diff &lt;- matrix([\t\t[1/9,1/9,1/9],\t\t[1/9,1/9,1/9],\t\t[1/9,1/9,1/9]]);\t\t\t\t\t\t\t\tmatrix&lt;float&gt; mat_wind_from_west &lt;- matrix([\t\t[-1/9,0.0,1/9],\t\t[-1/9,0.0,1/9],\t\t[-1/9,0.0,1/9]]);\t\t\t\t\t\t\t\tmatrix&lt;float&gt; mat_wind_from_north &lt;- matrix([\t\t[-1/9,-1/9,-1/9],\t\t[0.0,0.0,0.0],\t\t[1/9,1/9,1/9]]);reflex diff { \tdiffuse var: phero on: cells matrix:mat_diff;\tdiffuse var: phero on: cells matrix:mat_wind_from_north;\tdiffuse var: phero on: (cells where (each.grid_y&gt;=32)) matrix:mat_wind_from_west;}Endless worldNote that when your world is not a torus, it has the same effect as a mask, since all the values outside from the world cannot diffuse some values back :You can “fake” the fact that your world is endless by adding a different diffusion for the cells with grid_x=0 to have almost the same result :matrix&lt;float&gt; mat_diff &lt;- matrix([\t\t\t[1/9,1/9,1/9],\t\t\t[1/9,1/9,1/9],\t\t\t[1/9,1/9,1/9]]);\t\t\t\t\t\t\t\tmatrix&lt;float&gt; mat_diff_upper_edge &lt;- matrix([\t\t\t[0.0,0.0,0.0],\t\t\t[1/9+7/81,2/9+1/81,1/9+7/81],\t\t\t[1/9,1/9,1/9]]);reflex diff { \tdiffuse var: phero on: (cells where(each.grid_y&gt;0)) matrix:mat_diff;\tdiffuse var: phero on: (cells where(each.grid_y=0)) matrix:mat_diff_upper_edge;}Pseudo codeThis section is more for a better understanding of the source code.Here is the pseudo code for the computation of diffusion :1) : Execute the statement diffuse, store the diffusions in a map (from class DiffusionStatement to class GridDiffuser) :- Get all the facet values- Compute the \"real\" mask, from the facet \"mask:\" and the facet \"on:\".  - If no value for \"mask:\" and \"on:\" all the grid, the mask is equal to null.- Compute the matrix of diffusion  - If no value for \"matrix:\", compute with \"nb_neighbors\", \"is_gradient\", \"proportion\", \"propagation\", \"variation\", \"range\".  - Then, compute the matrix of diffusion with \"cycle_length\".- Store the diffusion properties in a map  - Map : [\"method_diffu\", \"is_gradient\", \"matrix\", \"mask\", \"min_value\"] is value, [\"var_diffu\", \"grid_name\"] is key.  - If the key exists in the map, try to \"mix\" the diffusions    - If \"method_diffu\", \"mask\" and \"is_gradient\" equal for the 2 diffusions, mix the diffusion matrix.2) : At the end of the step, execute the diffusions (class GridDiffuser) :- For each key of the map,  - Load the couple \"var_diffu\" / \"grid_name\"  - Build the \"output\" and \"input\" array with the dimension of the grid.   - Initialize the \"output\" array with -Double.MAX_VALUE.  - For each value of the map for that key,    - Load all the properties : \"method_diffu\", \"is_gradient\", \"matrix\", \"mask\", \"min_value\"    - Compute :      - If the cell is not masked, if the value of input is &gt; min_value, diffuse to the neighbors.        - If the value of the cell is equal to -Double.MAX_VALUE, remplace it by input[idx] * matDiffu[i][j].        - Else, do the computation (gradient or diffusion).    - Finish the diffusion :      - If output[idx] &gt; -Double.MAX_VALUE, write the new value in the cell.",
        "url":"/wiki/Diffusion.html"
      }
      ,
    
      "wiki-displays-html": {
        "title": "Displays",
        "content": "DisplaysGAMA allows modelers to define several and several kinds of displays in a GUI experiment:  java 2D displays  OpenGL displaysThese 2 kinds of display allows the modeler to display the same objects (agents, charts, texts …). The OpenGL display offers extended features in particular in terms of 3D visualisation.The OpenGL displays offers in addition better performance when zooming in and out.Table of contents  Displays          Classical displays (java2D)      OpenGL displays      Classical displays (java2D)The classical displays displaying any kind of content can be manipulated via the mouse (if no mouse event has been defined):  the mouse left press and move allows to move the camera (in 2D),  the mouse right click opens a context menu allowing the modeler to inspect displayed agents,  the wheel allows the modeler to zoom in or out.Each display provides several buttons to manipulate the display (from left to right):  Show/hide side bar,  Show/hide overlay,  Browse through all displayed agents: open a context menu to inspect agents,  Update every X step: configure the refresh frequence of the display,  Pause the-display: when pressed, the display will not be displayed anymore, the simulation is still running,  Synchronize the display and the execution of the model,  Zoom in,  Zoom to fit view,  Zoom out,  Take a snapshot: take a snapshot saved as a png image in the snapshots folder of the models folder.The Show/Hide side bar button opens a side panel in the display allowing the modeler to configure:  Properties of the display: background and highlight color, display the scale bar  For each layer, we can configure visibility, transparency, position and size of the layer. For grid layers, we can in addition show/hide grids. For species layers, we can also configure the displayed aspect. For text layers, we can the expression displayed with the color and the font.The bottom overlay bar displays information about the way it is displayed:  the position of the mouse in the display,  the zoom ratio,  the scale of the display (depending on the zoom).OpenGL displaysThe OpenGL display has an additional button 3D Options providing 3D features:  Use FreeFly camera/Use Arcball camera: switch between cameras, the default camera is the Arcball one,  Use mouse to rotate/Use mouse to drag (only with Arcball camera): use left click for one of the 2 actions, left click + Ctrl for the other of the 2 actions.  Apply inertia (only with Arcball camera): in inertia mode, when the modeler stops moving the camera, there is no straight halt but a kind of inertia.  Rotate scene: rotate the scene around an axis orthogonal to the scene,  Split layers/Merge layers: display each layer at a distinct height,  Triangulate scene: display the polygon primitives.In addition, the bottom overlay bar provides the Camera position in 3D.FreeFly camera commands            Key      Function                  Double Click      Zoom Fit              +      Zoom In              -      Zoom Out              Up      Move forward              Down      Move backward              Left      Strafe left              Right      Strafe right              SHIFT+Up      Look up              SHIFT+Down      Look down              SHIFT+Left      Look left              SHIFT+Right      Look right              MOUSE      Makes the camera look up, down, left and right              MouseWheel      Zoom-in/out to the current target (center of the screen)      ArcBall camera commands            Key      Function                  Double Click      Zoom Fit              +      Zoom In              -      Zoom Out              Up      Horizontal movement to the top              Down      Horizontal movement to the bottom              Left      Horizontal movement to the left              Right      Horizontal movement to the right              SHIFT+Up      Rotate the model up (decrease the phi angle of the spherical coordinates)              SHIFT+Down      Rotate the model down (increase the phi angle of the spherical coordinates)              SHIFT+Left      Rotate the model left (increase the theta angle of the spherical coordinates)              SHIFT+Right      Rotate the model right (decrease the theta angle of the spherical coordinates)              SPACE      Reset the pivot to the center of the envelope              KEYPAD 2,4,6,8      Quick rotation (increase/decrease phi/theta by 30°)              CMD+MOUSE1      Makes the camera rotate around the model              ALT+LEFT_MOUSE      Enables ROI Agent Selection              SHIFT+LEFT_MOUSE      Enables ROI Zoom              SCROLL      Zoom-in/out to the current target (center of the sphere)              WHEEL CLICK      Reset the pivot to the center of the envelope      ",
        "url":"/wiki/Displays.html"
      }
      ,
    
      "wiki-documentation-html": {
        "title": "Table of contents",
        "content": "Table of contents  Requirements          Configuration      Generated files location        Workflow to generate wiki files  Workflow to generate PDF files  Workflow to generate unit tests  Main internal steps          Generate wiki files      Generate pdf files      Generate unit test files        How to document          The @doc annotation      the @example annotation      How to document operators      How to document statements      How to document skills        How to change the processor  General workflow of file generationDocumentationThe GAMA documentation comes in 2 formats: a set of wiki files availaible from the wiki section of the GitHub website and a PDF file. The PDF file is produced from the wiki files.In the wiki files, some are hand-written by the GAMA community and some others are generated automatically from the Java code and the associated java annotations.The section summarizes:  how to generate this wiki files,  how to generate the PDF documentation,  how to generate the unit tests from the java annotations,  how to add documentation in the java code.RequirementsTo generate automatically the documentation, the GAMA Git version is required. See Install Git version for more details.Among all the GAMA plugins, the following ones are related to documentation generation:  msi.gama.processor: the java preprocessor is called during java compilation of the various plugins and extract information from the java code and the java annotations. For each plugin it produces the docGAMA.xml file in the gaml directory.  msi.gama.documentation: it contains all the java classes needed to gather all the docGAMA.xml files and generate wiki, pdf or unit test files.In addition, the folder containing the wiki files is required. In the GitHub architecture, the wiki documentation is stored in a separate Git repository https://github.com/gama-platform/gama.wiki.git. A local clone of this repository should thus be created:  Open the Git perspective:          Windows &gt; Open Perspective &gt; Other…      Choose Git        Click on “Clone a Git repository”          In Source Git repository window:              Fill in the URI label with: https://github.com/gama-platform/gama.wiki.git      Other fields will be automatically filled in.      * In Branch Selection windows,      check the master branch      Next      * In Local Destination windows,      Choose the directory in which the gama Git repository has been cloned      Everything else should be unchecked      Finish        In the Git perspective and the Git Repositories view, Right-Click on “Working Directory” inside the gama.wiki repository, and choose “Import projects”          In the Select a wizard to use for importing projects window:              “Import existing projects” should be checked      “Working Directory” should be selected      * In Import Projects window:      Uncheck « Search for nested project »      Check the project gama.wiki      Finish        Go back to the Java perspective: a gama.wiki plugin should have been added.In order to generate the PDF file from the wiki files, we use an external application named Pandoc.Follow the Pandoc installation instructions to install it. Specify the path to the pandoc folder in the file “Constants.java”, in the static constant CMD_PANDOC : “yourAbsolutePathToPandoc/pandoc”.Note that Latex should be installed in order to be able to generate PDF files. Make sure you have already installed Miktex (for OS Windows and Mac). Specify the path to the miktex folder in the file “Constants.java”, in the static constant CMD_PDFLATEX : “yourAbsolutePathToMiktex/pdflatex”.ConfigurationThe location where the files are generated (and other constants used by the generator) are defined in the file msi.gama.documentation/src/msi/gama/doc/util/Constants.java.The use of Pandoc (path to the application and so on) is defined in the file msi.gama.documentation/src/msi/gama/doc/util/ConvertToPDF.java. This should be changed in the future…Generated files locationThe generated files are (by default) generated in various locations depending on their type:  wiki files: they are generated in the plugin gama.wiki.  pdf file: they are generated in the plugin msi.gama.documentation, in the folder files/gen/pdf.  unit test files: they are generated in the plugin msi.gama.models, in the folder models/Tests.Workflow to generate wiki filesThe typical workflow to generate the wiki files is as follow:  Clean and Build all the GAMA projects,  Run the MainGenerateWiki.java file in the msi.gama.documentation,  The wiki files are generated in the gama.wiki plugin.Workflow to generate PDF filesThe typical workflow to generate the wiki files is as follow:  Clean and Build all the GAMA projects,  In the file mytemplate.tex, specify the absolute path to your “gama_style.tex” (it should be just next to this file)  Run the MainGeneratePDF.java file in the msi.gama.documentation, accepting all the packages install of latex,  The wiki files are generated in the msi.gama.documentation plugin.Note that generating the PDF takes a lot of time. Please be patient !If you want to update the file “gama_style.sty” (for syntax coloration), you have to turn the flag “generateGamaStyle” to “true” (and make sure the file “keywords.xml” is already generated).Workflow to generate unit testsThe typical workflow to generate the wiki files is as follow:  Clean and Build all the GAMA projects,  Run the MainGenerateUnitTest.java file in the msi.gama.documentation,  The wiki files are generated in the msi.gama.models plugin.Main internal steps  Clean and Build all the GAMA projects will create a docGAMA.xml file in the gaml directory of each plugin,  The MainGenerateXXX.java files then perform the following preparatory tasks:          they prepare the gen folder by deleting the existing folders and create all the folders that may contain intermediary generated folders      they merge all the docGAMA.xml files in a docGAMAglobal.xml file, created in the files/gen/java2xml folder. Only the plugins that are referred in the product files are merged.      After these common main first steps, each generator (wiki, pdf or unit test) performs specific tasks.Generate wiki files  The docGamaglobal.xml is parsed in order to generate 1 wiki file per kind of keyword:          operators,      statements,      skills,      architectures,      built-in species,      constants and units.      in addition an index wiki file containing all the GAML keywords is generated.        One wiki file is generated for each extension plugin, i.e. plugin existing in the Eclipse workspace but not refered in the product.Generate pdf filesThe pdf generator uses the table of content (toc) file located in the files/input/toc folder (msi.gama.documetation plugin) to organize the wiki files in a pdf file.  MainGeneratePDF.java file parsers the toc file and create the associated PDF file using the wiki files associated to each element of the toc. The generation is tuned using files located in the files/input/pandocPDF folder.Generate unit test files  MainGenerateUnitTest.java creates GAMA model files for each kind of keyword from the docGAMAglobal.xml file.How to documentThe documentation is generate from the Java code thanks to the Java additional processor, using mainly information from Java classes or methods and from the Java annotations. (see the list of all annotations for more details about annotations).The @doc annotationMost of the annotations can contain a @doc annotation, that can contain the main part of the documentation.For example, the inter (inter) operator is commented using:@doc(  value = \"the intersection of the two operands\",  comment = \"both containers are transformed into sets (so without duplicated element, cf. remove_deplicates operator) before the set intersection is computed.\",  usages = {    @usage(value = \"if an operand is a graph, it will be transformed into the set of its nodes\"),    @usage(value = \"if an operand is a map, it will be transformed into the set of its values\", examples = {      @example(value = \"[1::2, 3::4, 5::6] inter [2,4]\", equals = \"[2,4]\"),      @example(value = \"[1::2, 3::4, 5::6] inter [1,3]\", equals = \"[]\") }),    @usage(value = \"if an operand is a matrix, it will be transformed into the set of the lines\", examples =      @example(value = \"matrix([[1,2,3],[4,5,4]]) inter [3,4]\", equals = \"[3,4]\")) },  examples = {     @example(value = \"[1,2,3,4,5,6] inter [2,4]\", equals = \"[2,4]\"),    @example(value = \"[1,2,3,4,5,6] inter [0,8]\", equals = \"[]\") },  see = { \"remove_duplicates\" })This @docannotation contains 5 parts:  value: describes the documented element,  comment: a general comment about the documented element,  usages: a set of ways to use the documented element, each of them being in a @usage annotation. The usage contains mainly a description and and set of examples,  examples: a set of examples that are not related to a particular usage,  see: other related keywords.the @example annotationThis annotation contains a particular use example of the documented element. It is also used to generate unit test and patterns.The simplest way to use it:@example(value = \"[1::2, 3::4, 5::6] inter [2,4]\", equals = \"[2,4]\")In this example:  value contains an example of use of the operator,  equals contains the expected results of expression in value.This will become in the documentation:list var3 &lt;- [1::2, 3::4, 5::6] inter [2,4];    // var3 equals [2,4]When no variable is given in the annotation, an automatic name is generated. The type of the variable is determined thanks to the return type of the operator with these parameters.This example can also generate a unit test model. In this case, the value in the variable will be compared to the equals part.By default, the @example annotation has the following default values:  isTestOnly = false, meaning that the example will be added to the documentation too,  isExecutable = true, meaning that content of value can be added in a model and can be compiled (it can be useful to switch it to false, in a documentation example containing name of species that have not been defined),  test = true, meaning that the content of value will be tested to the content of equals,  isPattern = false.How to document operatorsA GAML operator is defined by a Java method annoted by the @operator annotation (see the list of all annotations for more details about annotations). In the core of GAMA, most of the operators are defined in the plugin msi.gama.core and in the package msi.gaml.operators.The documentation generator will use information from:  the @operator annotation:          value: it provides the name(s) of the operator (if an operator has several names, the other names will be considered as alternative names)      category: it is used to classified the operators in categories        the @doc annotation,  the method definition:          the return value type      parameters and their type (if the method is static, the IScope attribute is not taken into account)      How to document statementsA GAML statement is defined by a Java class annoted by the @symbol annotation (see the list of all annotations for more details about annotations). In the core of GAMA, most of the statements are defined in the plugin msi.gama.core and in the package msi.gaml.statements.The documentation generator will use information from:  @symbol annotation,  @facets annotation (each facet can contain a documentation in a @doc annotation),  @inside annotation (where the statement can be used),  @doc annotationHow to document skillsA GAML skill is defined by a Java class annoted by the @skill annotation (see the list of all annotations for more details about annotations). In the core of GAMA, most of the skills are defined in the plugin msi.gama.core and in the package msi.gaml.skills.The documentation generator will use information from:  @skill annotation,  @vars annotation (each var can contain a documentation in a @doc annotation),  @doc annotationHow to change the processorIf you make some modifications in the plugin processor, you have to rebuild the .jar file associated to the processor to take in account the changes.Here are the several steps you have to do :  In the “processor” plugin, open the plugin.xml.  In exporting (from the Overview tab), click on Export Wizard.  In the tab “Destination”, choose processor/plugins for the directory. In the tab “Options”, delete the field Qualifier replacement. Click “finish”.  Right click on the folder “processor” to refresh.–&gt; It’s ok !General workflow of file generationThis following diagram explains roughly the workflow for the generation of the different files : ",
        "url":"/wiki/Documentation.html"
      }
      ,
    
      "wiki-download-html": {
        "title": "Download GAMA",
        "content": "Download GAMAGAMA 1.7 Continuous ReleaseGAMA 1.6.1 (Archived)  GAMA for Windows 64 bits Download  GAMA for Windows 32 bits Download  GAMA for OSX 64 bits  Download  GAMA for OSX 32 bits Download  GAMA for Linux 64 bits Download  GAMA for Linux 32 bits Download",
        "url":"/wiki/Download.html"
      }
      ,
    
      "wiki-driving-skill-osm-loading-driving-html": {
        "title": "OSM Loading Driving",
        "content": "OSM Loading DrivingAuthor : Patrick TaillandierModel to show how to import OSM Files, using them to create agents for a road network, and saving the different agents in shapefiles. The first goal of this model is to prepare data for the driving skill models.Code of the model :model OSMdata_to_shapefile  global{\t//map used to filter the object to build from the OSM file according to attributes. for an exhaustive list, see: http://wiki.openstreetmap.org/wiki/Map_Features\tmap filtering &lt;- map([\"highway\"::[\"primary\", \"secondary\", \"tertiary\", \"motorway\", \"living_street\",\"residential\", \"unclassified\"]]);\t\t//OSM file to load\tfile&lt;geometry&gt; osmfile &lt;-  file&lt;geometry&gt;(osm_file(\"../includes/rouen.gz\", filtering))  ;\t\tgeometry shape &lt;- envelope(osmfile);\tgraph the_graph; \tmap&lt;point, intersection&gt; nodes_map;\t\t\tinit {\t\twrite \"OSM file loaded: \" + length(osmfile) + \" geometries\";\t\t\t\t//from the OSM file, creation of the selected agents\t\tloop geom over: osmfile {\t\t\tif (shape covers geom) {\t\t\t\tstring highway_str &lt;- string(geom get (\"highway\"));\t\t\t\tif (length(geom.points) = 1 ) {\t\t\t\t\tif ( highway_str != nil ) {\t\t\t\t\t\tstring crossing &lt;- string(geom get (\"crossing\"));\t\t\t\t\t\tcreate intersection with: [shape ::geom, type:: highway_str, crossing::crossing] {\t\t\t\t\t\t\tnodes_map[location] &lt;- self;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t} else {\t\t\t\t\tstring oneway &lt;- string(geom get (\"oneway\"));\t\t\t\t\tfloat maxspeed_val &lt;- float(geom get (\"maxspeed\"));\t\t\t\t\tstring lanes_str &lt;- string(geom get (\"lanes\"));\t\t\t\t\tint lanes_val &lt;- empty(lanes_str) ? 1 : ((length(lanes_str) &gt; 1) ? int(first(lanes_str)) : int(lanes_str));\t\t\t\t\tcreate road with: [shape ::geom, type:: highway_str, oneway::oneway, maxspeed::maxspeed_val, lanes::lanes_val] {\t\t\t\t\t\tif lanes &lt; 1 {lanes &lt;- 1;} //default value for the lanes attribute\t\t\t\t\t\tif maxspeed = 0 {maxspeed &lt;- 50.0;} //default value for the maxspeed attribute\t\t\t\t\t}\t\t\t\t}\t\t\t\t}\t\t}\t\twrite \"Road and node agents created\";\t\t\t\task road {\t\t\tpoint ptF &lt;- first(shape.points);\t\t\tif (not(ptF in nodes_map)) {\t\t\t\tcreate intersection with:[location::ptF] {\t\t\t\t\tnodes_map[location] &lt;- self;\t\t\t\t}\t\t\t\t}\t\t\tpoint ptL &lt;- last(shape.points);\t\t\tif (not(ptL in nodes_map)) {\t\t\t\tcreate intersection with:[location::ptL] {\t\t\t\t\tnodes_map[location] &lt;- self;\t\t\t\t}\t\t\t}\t\t}\t\t\t\t\twrite \"Supplementary node agents created\";\t\task intersection {\t\t\tif (empty (road overlapping (self))) {\t\t\t\tdo die;\t\t\t}\t\t}\t\t\t\twrite \"node agents filtered\";\t\t\t\t//Save all the road agents inside the file with the path written, using the with: facet to make a link between attributes and columns of the resulting shapefiles. \t\tsave road type:\"shp\" to:\"../includes/roads.shp\" with:[lanes::\"lanes\",maxspeed::\"maxspeed\", oneway::\"oneway\"] ;\t\tsave intersection type:\"shp\" to:\"../includes/nodes.shp\" with:[type::\"type\", crossing::\"crossing\"] ;\t\twrite \"road and node shapefile saved\";\t}}\tspecies road{\trgb color &lt;- rgb(rnd(255),rnd(255),rnd(255));\tstring type;\tstring oneway;\tfloat maxspeed;\tint lanes;\taspect base_ligne {\t\tdraw shape color: color; \t}\t} \tspecies intersection {\tstring type;\tstring crossing;\taspect base { \t\tdraw square(3) color: #red ;\t}} \texperiment fromOSMtoShapefiles type: gui {\toutput {\t\tdisplay map type: opengl {\t\t\tgraphics \"world\" {\t\t\t\tdraw world.shape.contour;\t\t\t}\t\t\tspecies road aspect: base_ligne  refresh: false  ;\t\t\tspecies intersection aspect: base   refresh: false ;\t\t}\t}}",
        "url":"/wiki/Driving-Skill-OSM-Loading-Driving.html"
      }
      ,
    
      "wiki-driving-skill-road-traffic-advanced-html": {
        "title": "Complex Road Network",
        "content": "Complex Road NetworkAuthor : Patrick TaillandierModel to show how to use the driving skill to represent the traffic on a road network generated thanks to shapefiles, with intersections and traffic lights going from red to green to let people move or stop. Two experiments are presented : experiment_2D to display the model in 2D and which better display the orientation of roads and experiment_3D to display the model in 3D.Code of the model :model RoadTrafficComplex global {   \tbool simple_data &lt;- false;\t\t//Check if we use simple data or more complex roads\tfile shape_file_roads  &lt;- simple_data ? file(\"../includes/RoadCircleLanes.shp\"): file(\"../includes/ManhattanRoads.shp\") ;\tfile shape_file_nodes  &lt;- simple_data ? file(\"../includes/NodeCircleLanes.shp\") : file(\"../includes/ManhattanNodes.shp\");\tfile shape_file_bounds &lt;- simple_data ? file(\"../includes/BoundsLaneRoad.shp\") :file(\"../includes/ManhattanRoads.shp\");\tgeometry shape &lt;- envelope(shape_file_bounds) + 50.0;\t\tgraph road_network;  \tint nb_people &lt;- simple_data ? 20 : 500;\t \tinit {  \t\t//create the intersection and check if there are traffic lights or not by looking the values inside the type column of the shapefile and linking\t\t// this column to the attribute is_traffic_signal. \t\tcreate intersection from: shape_file_nodes with:[is_traffic_signal::(read(\"type\") = \"traffic_signals\")];\t\t\t\t//create road agents using the shapefile and using the oneway column to check the orientation of the roads if there are directed\t\tcreate road from: shape_file_roads with:[lanes::int(read(\"lanes\")), oneway::string(read(\"oneway\"))] {\t\t\tgeom_display &lt;- shape + (2.5 * lanes);\t\t\tmaxspeed &lt;- (lanes = 1 ? 30.0 : (lanes = 2 ? 50.0 : 70.0)) °km/°h;\t\t\tswitch oneway {\t\t\t\tmatch \"no\" {\t\t\t\t\tcreate road {\t\t\t\t\t\tlanes &lt;- max([1, int (myself.lanes / 2.0)]);\t\t\t\t\t\tshape &lt;- polyline(reverse(myself.shape.points));\t\t\t\t\t\tmaxspeed &lt;- myself.maxspeed;\t\t\t\t\t\tgeom_display  &lt;- myself.geom_display;\t\t\t\t\t\tlinked_road &lt;- myself;\t\t\t\t\t\tmyself.linked_road &lt;- self;\t\t\t\t\t}\t\t\t\t\tlanes &lt;- int(lanes /2.0 + 0.5);\t\t\t\t}\t\t\t\tmatch \"-1\" {\t\t\t\t\tshape &lt;- polyline(reverse(shape.points));\t\t\t\t}\t\t\t\t}\t\t}\t\t\tmap general_speed_map &lt;- road as_map (each::(each.shape.perimeter / each.maxspeed));\t\t\t\t//creation of the road network using the road and intersection agents\t\troad_network &lt;-  (as_driving_graph(road, intersection))  with_weights general_speed_map;\t\t\t\t//initialize the traffic light\t\task intersection {\t\t\tdo initialize;\t\t}\t\t\t\tcreate people number: nb_people { \t\t\tmax_speed &lt;- 160 °km/°h;\t\t\tvehicle_length &lt;- 5.0 °m;\t\t\tright_side_driving &lt;- true;\t\t\tproba_lane_change_up &lt;- 0.1 + (rnd(500) / 500);\t\t\tproba_lane_change_down &lt;- 0.5+ (rnd(500) / 500);\t\t\tlocation &lt;- one_of(intersection where empty(each.stop)).location;\t\t\tsecurity_distance_coeff &lt;- 5/9 * 3.6 * (1.5 - rnd(1000) / 1000);  \t\t\tproba_respect_priorities &lt;- 1.0 - rnd(200/1000);\t\t\tproba_respect_stops &lt;- [1.0];\t\t\tproba_block_node &lt;- 0.0;\t\t\tproba_use_linked_road &lt;- 0.0;\t\t\tmax_acceleration &lt;- 5/3.6;\t\t\tspeed_coeff &lt;- 1.2 - (rnd(400) / 1000);\t\t\tthreshold_stucked &lt;-int ( (1 + rnd(5))°mn);\t\t\tproba_breakdown &lt;- 0.00001;\t\t\t\t\t}\t\t}\t} //species that will represent the intersection node, it can be traffic lights or not, using the skill_road_node skillspecies intersection skills: [skill_road_node] {\tbool is_traffic_signal;\tlist&lt;list&gt; stop;\tint time_to_change &lt;- 100;\tint counter &lt;- rnd (time_to_change) ;\tlist&lt;road&gt; ways1;\tlist&lt;road&gt; ways2;\tbool is_green;\trgb color_fire;\t\taction initialize {\t\tif (is_traffic_signal) {\t\t\tdo compute_crossing;\t\t\tstop&lt;&lt; [];\t\t\tif (flip(0.5)) {\t\t\t\tdo to_green;\t\t\t} else {\t\t\t\tdo to_red;\t\t\t}\t\t\t}\t}\t\taction compute_crossing{\t\tif  (length(roads_in) &gt;= 2) {\t\t\troad rd0 &lt;- road(roads_in[0]);\t\t\tlist&lt;point&gt; pts &lt;- rd0.shape.points;\t\t\t\t\t\t\t\t\tfloat ref_angle &lt;-  float( last(pts) direction_to rd0.location);\t\t\tloop rd over: roads_in {\t\t\t\tlist&lt;point&gt; pts2 &lt;- road(rd).shape.points;\t\t\t\t\t\t\t\t\t\tfloat angle_dest &lt;-  float( last(pts2) direction_to rd.location);\t\t\t\tfloat ang &lt;- abs(angle_dest - ref_angle);\t\t\t\tif (ang &gt; 45 and ang &lt; 135) or  (ang &gt; 225 and ang &lt; 315) {\t\t\t\t\tways2&lt;&lt; road(rd);\t\t\t\t}\t\t\t}\t\t}\t\tloop rd over: roads_in {\t\t\tif not(rd in ways2) {\t\t\t\tways1 &lt;&lt; road(rd);\t\t\t}\t\t}\t}\t\taction to_green {\t\tstop[0] &lt;- ways2 ;\t\tcolor_fire &lt;- #green;\t\tis_green &lt;- true;\t}\t\taction to_red {\t\tstop[0] &lt;- ways1;\t\tcolor_fire &lt;- #red;\t\tis_green &lt;- false;\t}\treflex dynamic_node when: is_traffic_signal  {\t\tcounter &lt;- counter + 1;\t\tif (counter &gt;= time_to_change) { \t\t\tcounter &lt;- 0;\t\t\tif is_green {do to_red;}\t\t\telse {do to_green;}\t\t} \t}\t\taspect base {\t\tif (is_traffic_signal) {\t\t\t\tdraw circle(5) color: color_fire;\t\t}\t}\t\taspect base3D {\t\tif (is_traffic_signal) {\t\t\t\tdraw box(1,1,10) color:#black;\t\t\tdraw sphere(5) at: {location.x,location.y,12} color: color_fire;\t\t}\t}}//species that will represent the roads, it can be directed or not and uses the skill skill_roadspecies road skills: [skill_road] { \tgeometry geom_display;\tstring oneway;\taspect base {    \t\tdraw shape color: #gray end_arrow: 10;\t} \taspect base3D {    \t\tdraw geom_display color: #gray ;\t} }//People species that will move on the graph of roads to a target and using the skill advanced_drivingspecies people skills: [advanced_driving] { \trgb color &lt;- rgb(rnd(255), rnd(255), rnd(255)) ;\tint counter_stucked &lt;- 0;\tint threshold_stucked;\tbool breakdown &lt;- false;\tfloat proba_breakdown ;\tintersection target;\t\treflex breakdown when: flip(proba_breakdown){\t\tbreakdown &lt;- true;\t\tmax_speed &lt;- 1 °km/°h;\t}\t\treflex time_to_go when: final_target = nil {\t\ttarget &lt;- one_of(intersection where not each.is_traffic_signal);\t\tcurrent_path &lt;- compute_path(graph: road_network, target: target );\t\tif (current_path = nil ) {\t\t\tfinal_target &lt;- nil;\t\t}\t}\treflex move when: current_path != nil and final_target != nil {\t\tdo drive;\t\tif real_speed &lt; 5°km/°h {\t\t\tcounter_stucked&lt;- counter_stucked + 1;\t\t\tif (counter_stucked mod threshold_stucked = 0) {\t\t\t\tproba_use_linked_road &lt;- min([1.0,proba_use_linked_road + 0.1]);\t\t\t}\t\t} else {\t\t\tcounter_stucked&lt;- 0;\t\t\tproba_use_linked_road &lt;- 0.0;\t\t}\t}\taspect base { \t\tdraw breakdown ? square(15) : triangle(15) color: color rotate:heading + 90;\t} \taspect base3D {\t\tpoint loc &lt;- calcul_loc();\t\tdraw box(vehicle_length, 1,1) at: loc rotate:  heading color: color;\t\t\t\tdraw triangle(0.5) depth: 1.5 at: loc rotate:  heading + 90 color: color;\t\t\t\tif (breakdown) {\t\t\tdraw circle(2) at: loc color: #red;\t\t}\t} \t\tpoint calcul_loc {\t\tif (current_road = nil) {\t\t\treturn location;\t\t} else {\t\t\tfloat val &lt;- (road(current_road).lanes - current_lane) + 0.5;\t\t\tval &lt;- on_linked_road ? val * - 1 : val;\t\t\tif (val = 0) {\t\t\t\treturn location; \t\t\t} else {\t\t\t\treturn (location + {cos(heading + 90) * val, sin(heading + 90) * val});\t\t\t}\t\t}\t}\t} experiment experiment_2D type: gui {\tparameter \"if true, simple data (simple track), if false complex one (Manhattan):\" var: simple_data category: \"GIS\" ;\toutput {\t\tdisplay city_display {\t\t\tspecies road aspect: base ;\t\t\tspecies intersection aspect: base;\t\t\tspecies people aspect: base;\t\t}\t}}experiment experiment_3D type: gui {\tparameter \"if true, simple data (simple track), if false complex one (Manhattan):\" var: simple_data category: \"GIS\" ;\toutput {\t\tdisplay carte_principale type: opengl {\t\t\tspecies road aspect: base3D refresh: true;\t\t\tspecies intersection aspect: base3D;\t\t\tspecies people aspect: base3D ; \t\t}\t}}",
        "url":"/wiki/Driving-Skill-Road-Traffic-advanced.html"
      }
      ,
    
      "wiki-driving-skill-road-traffic-simple-city-html": {
        "title": "Simple Road Network",
        "content": "Simple Road NetworkAuthor : Patrick TaillandierModel using shapefiles to create buildings and a road graph, with people going from their living place to their work place depending on the hour. The traffic jam is also taken into account to slow the people agents when they are too much on the same road. The experiment shows a display of the city, with people agents, buildings and roads, a display of the traffic jam occuring on the roads, and a chart display showing two charts : one for the traffic jam coefficients, and an other for the objectives of the people agents.Code of the model :  model RoadTrafficCity    global {   \t\t//Shapefiles for the buildings, the roads and the bounds of the environment\tfile shape_file_roads parameter: \"Shapefile for the roads:\" category: \"GIS\" &lt;- file(\"../includes/ManhattanRoads.shp\") ;\tfile shape_file_bounds parameter: \"Shapefile for the bounds:\" category: \"GIS\" &lt;- file(\"../includes/ManhattanBounds.shp\") ;\tfile shape_file_buildings parameter: \"Shapefile for the buildings:\" category: \"GIS\" &lt;- file(\"../includes/ManhattanBuildings.shp\") ;\tgeometry shape &lt;- envelope(shape_file_bounds);\t\t//Stock the number of times agents reached their goal (their house or work place)\tint nbGoalsAchived &lt;- 0;\t\t//represent the day time for the agent to inform them to go work or home\tint day_time update: cycle mod 144 ;\t\t//Variables to manage the minimal and maximal time to start working\tint min_work_start &lt;- 36;\tint max_work_start &lt;- 60;\t\t//Number of people created\tint nb_people &lt;- 500;\t\t//Variables to manage the minimal and maximal time to go home\tint min_work_end &lt;- 84; \tint max_work_end &lt;- 132; \t\t//Manage the speed allowed in the model for the people agents\tfloat min_speed &lt;- 50.0;\tfloat max_speed &lt;- 100.0; \t\t//Graph of the road network\tgraph the_graph;\t\t \tinit {  \t\t\t\t//creation of the agents of road and building species using the shapefile and linking the \t\tcreate road from: shape_file_roads with:[nbLanes::int(read(\"lanes\"))];\t\tcreate building from: shape_file_buildings;\t\t\t\t//Increase the shape of roads according to the number of lanes it has\t\task road as list {\t\t\tvisu_geom &lt;- shape + (2 * nbLanes);\t\t\t}\t\t//Initliazation of the graph with the road species\t\tthe_graph &lt;-  (as_edge_graph(road));\t\t\t\t//Initialization of nb_people agents of people species\t\t// and definition of their living and working places\t\tcreate people number: nb_people { \t\t\tliving_space &lt;- 3.0;\t\t\ttolerance &lt;- 0.1;\t\t\tlanes_attribute &lt;- \"nbLanes\";\t\t\tobstacle_species &lt;- [species(self)]; \t\t\tspeed &lt;- min_speed + rnd (max_speed - min_speed) ;\t\t\tstart_work &lt;- min_work_start + rnd (max_work_start - min_work_start) ;\t\t\tend_work &lt;- min_work_end + rnd (max_work_end - min_work_end) ;\t\t\tliving_place &lt;- one_of(building) ;\t\t\tworking_place &lt;- one_of(building) ;\t\t\tlocation &lt;- living_place.location; \t\t}   \t}\t\t//Update of the graph every 10 Cycles to take into account the traffic jam of the road in the weights of the graph\treflex update_graph when:every(10){\t\tmap&lt;road,float&gt; weights_map &lt;- road as_map (each:: (each.shape.perimeter * each.coeff_traffic));\t\tthe_graph &lt;- the_graph with_weights weights_map;\t}\t} \tspecies road  { \tint nbLanes;\tint indexDirection; \tbool blocked &lt;- false;\trgb color &lt;- #black;\tfloat coeff_traffic &lt;- 1.0 update: 1 + (float(length(people at_distance 1.0)) / shape.perimeter * 200 / nbLanes);\tgeometry visu_geom;\t\taspect base { \t\tdraw shape color: #black ;\t} \t\t\t//Command that the user can execute to remove or add a road\t\tuser_command \"Remove a road\" action: remove;\tuser_command \"Add a road\" action: add;\t\t \taction remove {\t\tblocked &lt;- true;\t\tthe_graph &lt;-  (as_edge_graph(road where (!each.blocked))) ;\t\tmap&lt;road,float&gt; weights_map &lt;- road as_map (each:: each.coeff_traffic);\t\tthe_graph &lt;- the_graph  with_weights weights_map;\t\tcolor &lt;- #magenta;\t}\t\t\taction add {\t\tblocked &lt;- false;\t\tthe_graph &lt;-  (as_edge_graph(road where (!each.blocked)));\t\tmap&lt;road,float&gt; weights_map &lt;- road as_map (each:: each.coeff_traffic);\t\tthe_graph &lt;- the_graph  with_weights weights_map;\t\tcolor &lt;- #black;\t}\t\t\taspect road_width {  \t\tdraw visu_geom color: color ;\t}\t\taspect traffic_jam {  \t\tif (coeff_traffic &gt; 0.025) {\t\t\tdraw shape + (coeff_traffic / 4.0) color: #red ;\t\t}\t} \t\t}\tspecies building  { \trgb color &lt;- #gray;\taspect base { \t\tdraw shape color: color ;\t}}\tspecies people skills: [driving]{ \tfloat speed; \trgb color &lt;- rgb([rnd(255),rnd(255),rnd(255)]) ;\tpoint targetBis &lt;- nil ; \tpoint previousLoc &lt;- nil;\tbool normalMove &lt;- true;\tfloat evadeDist &lt;- 500.0;\tbuilding living_place &lt;- nil ;\tbuilding working_place &lt;- nil ;\tint start_work ;\tint end_work  ;\tstring objective ; \tpoint the_target &lt;- nil ;\t\t\t//Reflex to make the agent move while it had a target and normalMove equals true\treflex move when: the_target != nil and normalMove{\t\tpreviousLoc &lt;- copy(location);\t\tdo goto_driving target: the_target on: the_graph speed: speed ; \t\tswitch location { \t\t\tmatch the_target {\t\t\t\tthe_target &lt;- nil;\t\t\t\tnbGoalsAchived &lt;- nbGoalsAchived +1;\t\t\t}\t\t\tmatch previousLoc {\t\t\t\ttargetBis &lt;- last((one_of(road where (each distance_to self &lt; evadeDist)).shape).points);\t\t\t\tnormalMove &lt;- false;\t\t\t}\t\t}\t}\t\t\t//Reflex to make the agent move when it is not normal moving \treflex EvadeMove when: !(normalMove){\t\tpreviousLoc &lt;- copy(location);\t\tdo goto_driving target: targetBis on: the_graph speed: speed ; \t\tswitch location { \t\t\tmatch targetBis {\t\t\t\tnormalMove &lt;- true;\t\t\t}\t\t\tmatch previousLoc {\t\t\t\ttargetBis &lt;- last((one_of(road where (each distance_to self &lt; evadeDist)).shape).points);\t\t\t}\t\t}\t}\t\t//Reflex to make the agent go to its working place when it's time to go work\treflex time_to_work when: day_time = start_work {\t\tobjective &lt;- \"working\" ;\t\tthe_target &lt;- any_location_in (working_place);\t}\t\t//Reflex to make the agent go to its living place when it's time to go home\treflex time_to_go_home when: day_time = end_work {\t\tobjective &lt;- \"go home\" ;\t\tthe_target &lt;- any_location_in (living_place); \t}  \t\taspect base {\t\tdraw circle(20) color: color;\t}}experiment traffic type: gui {\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" ;\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" ;\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" ;\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" ;\tparameter \"minimal speed\" var: min_speed category: \"People\" ;\tparameter \"maximal speed\" var: max_speed category: \"People\" ;\t\toutput {\t\tdisplay city_display {\t\t\tspecies road aspect: road_width ;\t\t\tspecies building aspect: base;\t\t\tspecies people aspect: base;\t\t}\t\tdisplay traffic_jam_display {\t\t\tspecies road aspect: base ;\t\t\tspecies road aspect: traffic_jam ;\t\t}\t\tdisplay chart_display refresh: every(10) {\t\t\tchart \"Traffic jam\" type: series size: {0.9, 0.4} position: {0.05, 0.05} {\t\t\t\tdata \"Mean road traffic coefficient\" value: mean (road collect each.coeff_traffic) style: line color: #green ;\t\t\t\tdata \"Max road traffic coefficient\" value: road max_of (each.coeff_traffic) style: line color: #red ;\t\t\t}\t\t\tchart \"People Objectif\" type: pie style: exploded size: {0.9, 0.4} position: {0.05, 0.55} {\t\t\t\tdata \"Working\" value: length ((people as list) where (each.objective=\"working\")) color: #green ;\t\t\t\tdata \"Staying home\" value: length ((people as list) where (each.objective=\"go home\")) color: #blue ;\t\t\t}\t\t}\t\tmonitor \"Number of goals achieved\" value: nbGoalsAchived ;\t}}",
        "url":"/wiki/Driving-Skill-Road-Traffic-simple-(City).html"
      }
      ,
    
      "wiki-driving-skill-road-traffic-simple-simple-track-html": {
        "title": "Easy Road Network",
        "content": "Easy Road NetworkAuthor : Patrick TaillandierModel using shapefiles to create roads using shapefiles with people driving on these roads. The model take into account the number of lanes of the roads.Code of the model :   model RoadTrafficSimple   global {  \tfile shape_file_roads  &lt;- file(\"../includes/RoadCircleLanes.shp\") ;\tfile shape_file_bounds &lt;- file(\"../includes/BoundsLaneRoad.shp\") ;\tgeometry shape &lt;- envelope(shape_file_bounds);\t\tgraph the_graph;  \tlist roadsList of: road ; \t\t\t\tinit {  \t\tcreate road from: shape_file_roads with: [nbLanes::int(read(\"lanes\"))] {\t\t\tgeom_visu &lt;- shape + nbLanes;\t\t}\t\tthe_graph &lt;- as_edge_graph(road);\t}   \t\treflex createPeople when: cycle mod 20 = 0 and cycle &lt; 400{\t\troadsList &lt;- (road as list);  \t\tcreate people number: 1 { \t\t\tspeed &lt;-  (2.0 + 2 * length(people as list)) ;\t\t\tcurrentRoad &lt;- first (roadsList);\t\t\tsource &lt;- first((currentRoad.shape).points);\t\t\tlocation &lt;- source; \t\t\ttarget &lt;- last((currentRoad.shape).points);\t\t\tliving_space &lt;- 10.0;\t\t\ttolerance &lt;- 0.1;\t\t\tlanes_attribute &lt;- \"nbLanes\";\t\t\tobstacle_species &lt;- [species(self)]; \t\t}  \t}   } \tspecies road  { \tint nbLanes; \tgeometry geom_visu;\taspect base {    \t\tdraw geom_visu color: #black ;\t} }species people skills: [driving]{ \tfloat speed; \trgb color &lt;- rgb(rnd(255),rnd(255),rnd(255)) ; \tpoint target &lt;- nil ; \tpoint source &lt;- nil;\troad currentRoad &lt;- nil;\treflex move when: target != nil {\t\tdo goto_driving target: target on: the_graph speed: speed ; \t\tswitch target { \t\t\tmatch location {\t\t\t\tcurrentRoad &lt;- (roadsList select (each != currentRoad)) with_min_of (each distance_to self);\t\t\t\tsource &lt;- location;\t\t\t\tlist&lt;point&gt; rls &lt;- (currentRoad.shape).points;\t\t\t\ttarget &lt;- first (rls) = source ? last(rls):first(rls);\t\t\t}\t\t}\t}\t\t\taspect base {\t\tdraw circle(10) color: color;\t}}experiment Simple type: gui {\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\t\toutput {\t\tdisplay city_display {\t\t\tspecies road aspect: base ;\t\t\tspecies people aspect: base;\t\t}\t}}",
        "url":"/wiki/Driving-Skill-Road-Traffic-simple-(Simple-track).html"
      }
      ,
    
      "wiki-driving-skill-html": {
        "title": "Driving Skill",
        "content": "Driving SkillThis sub-section is composed of the following models :      OSM Loading Driving        Complex Road Network         Simple Road Network         Easy Road Network   ",
        "url":"/wiki/Driving-Skill.html"
      }
      ,
    
      "wiki-editingmodels-html": {
        "title": "Editing models",
        "content": "Editing modelsEditing models in GAMA is very similar to editing programs in a modern IDE like Eclipse. After having successfully launched the program, the user has two fundamental concepts at its disposal: a workspace, which contains models or links to models organized like a hierarchy of files in a filesystem, and the workbench (aka, the main window), which contains the tools to create, modify and experiment these models.Understanding how to navigate in the workspace is covered in another section and, for the purpose of this section, we just need to understand that it is organized in projects, which contain models and their associated data. Projects are further categorized, in GAMA, into three categories : Models Library (built-in models shipped with GAMA and automatically linked from the workspace), Shared Models, and User Models.This section covers the following sub-sections :            GAML Editor Generalities                  GAML Editor Toolbar                  Validation of Models                  Graphical Editor      ",
        "url":"/wiki/EditingModels.html"
      }
      ,
    
      "wiki-epidemiology-sir-abm-vs-ebm-html": {
        "title": "comparison_ABM_EBM_SIR",
        "content": "comparison_ABM_EBM_SIR_Author : Benoit Gaudou _Comparison between an agent-based and an equation-based model of the SIR model. The ABM use a grid to place the agents, and each cell will be the location of an agent, while the EBM is only using a ODE System and no geographical representation.Code of the model :model comparison_ABM_EBM_SIRglobal {\t//Number of susceptible individuals\tint number_S &lt;- 499; \t//Number of infectious individuals\tint number_I &lt;- 1; \t//Number of Resistant individuals\tint number_R &lt;- 0; \t//Beta parameter used for the infection of susceptible individuals\tfloat beta &lt;- 0.1; \t//Gamma parameter used for the resistance gained by the infectious individuals\tfloat gamma &lt;- 0.01;\t//Size of the neighbours\tint neighbours_size &lt;- 2;\t//Total number of individuals\tint N &lt;- number_S + number_I + number_R;\t//Number of hosts (for ABM)\tint nb_hosts &lt;- number_S + number_I + number_R update: length(Host);\t//Number of infected hosts (for ABM)\tint nb_infected &lt;- number_I update:  Host count (each.is_infected);\tfloat hKR4 &lt;- 0.7;\tgeometry shape &lt;- square(50);\tinit {\t\t//Create the number of hosts susceptibles\t\tcreate Host number: number_S {\t\t\tis_susceptible &lt;- true;\t\t\tis_infected &lt;- false;\t\t\tis_immune &lt;- false;\t\t\tcolor &lt;- #green;\t\t}\t\t//Create the number of hosts infectious\t\tcreate Host number: number_I {\t\t\tis_susceptible &lt;- false;\t\t\tis_infected &lt;- true;\t\t\tis_immune &lt;- false;\t\t\tcolor &lt;- #red;\t\t}\t\t//Create the node agent for the SIR ODE System\t\tcreate node_agent number: 1 {\t\t\tS &lt;- float(number_S);\t\t\tI &lt;- float(number_I);\t\t\tR &lt;- float(number_R);\t\t}\t}}//Grid that will be used to discretize spacegrid sir_grid width: 50 height: 50 {\t\trgb color &lt;- #black;\t\tlist&lt;sir_grid&gt; neighbours &lt;- (self neighbors_at neighbours_size) of_species sir_grid;\t}\t//Species host which represents the host of the diseasespecies Host {\t\t//Different booleans to know in which state is the host\tbool is_susceptible &lt;- true;\tbool is_infected &lt;- false;\tbool is_immune &lt;- false;\t\t//Color of the host\trgb color &lt;- #green;\t\t//Location of the agent among the grid\tsir_grid myPlace;\t//Count of neighbors infected     int ngb_infected_number function: {self neighbors_at(neighbours_size) count(each.is_infected)};\t\tinit {\t\t//The location is chosen randomly\t\tmyPlace &lt;- one_of(sir_grid);\t\tlocation &lt;- myPlace.location;\t}\t//Reflex to move the agent in the neighbours cells\treflex basic_move {\t\tmyPlace &lt;- one_of(myPlace.neighbours);\t\tlocation &lt;- myPlace.location;\t}\t//Reflex to pass the agent to the state infected \treflex become_infected when: is_susceptible {\t\t\t//Probability of being infected according to the number of infected among the neighbours    \t\tif (flip(1 - (1 - beta)  ^ ngb_infected_number)) {        \t\tis_susceptible &lt;-  false;\t            \tis_infected &lt;-  true;\t            \tis_immune &lt;-  false;\t            \tcolor &lt;-  #red;       \t\t\t\t\t\t}    \t\t\t\t\t}\t//Reflex to pass the agent to the state immune\treflex become_immune when: (is_infected and flip(gamma)) {\t\tis_susceptible &lt;- false;\t\tis_infected &lt;- false;\t\tis_immune &lt;- true;\t\tcolor &lt;- #blue;\t} \t\taspect basic {\t\tdraw circle(1) color: color;\t}}//Species node agent that will represent the SIR Ordinary differential equations systemspecies node_agent {\tfloat t;\tfloat I;\tfloat S;\tfloat R;\tequation eqSIR type: SIR vars: [S, I, R, t] params: [N, beta, gamma];\treflex solving {solve eqSIR method: rk4 step: 1;}\t}experiment Simulation_ABM_EBM type: gui {\tparameter 'Number of Susceptible' type: int var: number_S &lt;- 495 category: \"Initial population\";\tparameter 'Number of Infected' type: int var: number_I &lt;- 5 category: \"Initial population\";\tparameter 'Number of Removed' type: int var: number_R &lt;- 0 category: \"Initial population\";\tparameter 'Beta (S-&gt;I)' type: float var: beta &lt;- 0.1 category: \"Parameters\";\tparameter 'Gamma (I-&gt;R)' type: float var: gamma &lt;- 0.01 category: \"Parameters\";\tparameter 'Size of the neighbours' type: int var: neighbours_size &lt;- 1 min: 1 max: 5 category: \"Infection\";\toutput {\t\tdisplay sir_display { \t\t\tgrid sir_grid lines: #black;\t\t\tspecies Host aspect: basic;\t\t\t}\t\tdisplay ABM { \t\t\tchart 'Susceptible' type: series background: #lightgray style: exploded {\t\t\t\tdata 'susceptible' value: (Host as list) count (each.is_susceptible) color: #green;\t\t\t\tdata 'infected' value: (Host as list) count (each.is_infected) color: #red;\t\t\t\tdata 'immune' value: (Host as list) count (each.is_immune) color: #blue;\t\t\t}\t\t}\t\tdisplay EBM { \t\t\tchart \"SIR\" type: series background: #white {\t\t\t\tdata 'S' value: first(node_agent).S color: #green;\t\t\t\tdata 'I' value: first(node_agent).I color: #red;\t\t\t\tdata 'R' value: first(node_agent).R color: #blue;\t\t\t}\t\t}\t\tdisplay ABM_EBM  { \t\t\tchart 'Susceptible' type: series background: #lightgray style: exploded {\t\t\t\tdata 'susceptible' value: (Host as list) count (each.is_susceptible) color: #green-50;\t\t\t\tdata 'infected' value: (Host as list) count (each.is_infected) color: #red-50;\t\t\t\tdata 'immune' value: (Host as list) count (each.is_immune) color: #blue-50;\t\t\t\tdata 'S' value: first(node_agent).S color: #green+50;\t\t\t\tdata 'I' value: first(node_agent).I color: #red+50;\t\t\t\tdata 'R' value: first(node_agent).R color: #blue+50;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Epidemiology-SIR-(ABM-vs-EBM).html"
      }
      ,
    
      "wiki-epidemiology-sir-built-in-html": {
        "title": "simple_ODE_SIR_Predefined",
        "content": "simple_ODE_SIR_Predefined_Author : hqnghi _A simple example of ODE use into agents with the example of the SIR equation system.Code of the model : model simple_ODE_SIR_Predefinedglobal {\tinit {\t\tcreate predefined_ODE_SIR_agent number: 1;\t}}//Species which represent the Ordinary Differential Equations System species predefined_ODE_SIR_agent {\t//Variable to represent the discrete time for integration\tfloat t; \t//Total Population    \tint N &lt;- 500;   \t//Number of infected\tfloat I &lt;- 1.0; \t//Number of susceptible\tfloat S &lt;- N - I; \t//Number of recovered\tfloat R &lt;- 0.0; \t//Rate of transmission success for each infected  \tfloat beta &lt;- 0.4;  \t//Rate of passing to resistant   \tfloat gamma &lt;- 0.01;    \t\t   \tfloat h &lt;- 0.1;\t// Parameters must follow exact order S, I, R, t  and N,beta,gamma\t\t\tequation eqSIR type:SIR vars: [S,I,R,t] params: [N,beta,gamma] ;\treflex solving {solve eqSIR method:rk4 step:h ;}//cycle_length:int(1/h);}}experiment mysimulation type: gui {\toutput {\t\t\tdisplay display_charts {\t\t\tchart 'SIR_agent' type: series background: #lightgray {\t\t\t\tdata \"S\" value: first(predefined_ODE_SIR_agent).S color: #green;\t\t\t\tdata \"I\" value: first(predefined_ODE_SIR_agent).I color: #red;\t\t\t\tdata \"R\" value: first(predefined_ODE_SIR_agent).R color: #blue;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Epidemiology-SIR-(Built-In).html"
      }
      ,
    
      "wiki-epidemiology-sir-split-in-agents-html": {
        "title": "SIR_split_in_agents",
        "content": "SIR_split_in_agents_Author : hqnghi _This model illustrates the possibility to split an equation system into several agents. All the equations are solve together thanks to the simultaneously facet of the equation statement. We also compare the split model with the simple SIR one.Code of the model :model SIR_split_in_agentsglobal {\tint number_S &lt;- 495 ; // The number of susceptible\tint number_I &lt;- 5   ; // The number of infected\tint number_R &lt;- 0   ; // The number of removed \tfloat beta  &lt;- 1.0  ; // The parameter Beta\tfloat delta &lt;- 0.01 ; // The parameter Delta\t\t// Note that N will remain constant as demography is not taken into account in the SIR model.\tint N &lt;- number_S + number_I + number_R ;\tfloat hKR4 &lt;- 0.07 ;\tinit {\t\t//Creation of the representation of the susceptible agents\t\tcreate S_agt {\t\t\tSsize &lt;- float(number_S) ;\t\t\tself.beta &lt;- myself.beta ;\t\t}\t\t//Creation of the representation of the infected agents\t\tcreate I_agt {\t\t\tIsize &lt;- float(number_I) ;\t\t\tself.beta &lt;- myself.beta ;\t\t\tself.delta &lt;- myself.delta ;\t\t}\t\t//Creation of the representation of the recovered agents\t\tcreate R_agt {\t\t\tRsize &lt;- float(number_R) ;\t\t\tself.delta &lt;- myself.delta ;\t\t}\t\t//Creation of the representation of the SIR agent representing the non split system\t\tcreate SIR_agt {\t\t\tself.Sm &lt;- float(number_S) ;\t\t\tself.Im &lt;- float(number_I) ;\t\t\tself.Rm &lt;- float(number_R) ;\t\t\t\t\t\tself.beta &lt;- myself.beta ;\t\t\tself.delta &lt;- myself.delta ;\t\t}\t}}//Species which represent the susceptible agents compartimentspecies S_agt {\tfloat t ;\t\t\tfloat Ssize ; //number of susceptible\t\tfloat beta ;\t//Equation that will be solved simultaneously with the two other equations systems\tequation evol simultaneously: [  ( I_agt ) ,  ( R_agt ) ] {\t\tdiff ( first ( S_agt ) . Ssize , t ) = \t\t\t( - beta * first ( S_agt ) . Ssize * first (\tI_agt ) . Isize / N ) ;\t}\t\treflex solving {solve evol method: \"rk4\" step: 0.01 ;}}//Species which represent the infected agents compartimentspecies I_agt {\tfloat t ;\tfloat Isize ; // number of infected\t\tfloat beta ;\tfloat delta ;\t//Equation that will be solved simultaneously with the two other equations systems\tequation evol simultaneously: [  ( S_agt ) ,  ( R_agt ) ] {\t\tdiff ( first ( I_agt ) . Isize , t ) = \t\t\t( beta * first ( S_agt ) . Ssize * first ( I_agt ) . Isize / N ) \t\t\t- ( delta * first ( I_agt ) . Isize ) ;\t}}//Species which represent the resistant agents compartimentspecies R_agt {\tfloat t ;\t\t\tfloat Rsize ; //number of resistant\t\tfloat delta ;\t//Equation that will be solved simultaneously with the two other equations systems\tequation evol simultaneously: [ ( S_agt ) + ( I_agt ) ] {\t\tdiff ( first ( R_agt ) . Rsize , t ) = \t\t\t( delta * first ( I_agt ) . Isize ) ;\t}}//Species which represent the ordinary differential equations systemspecies SIR_agt {\tfloat t ;\tfloat Im ;\tfloat Sm ;\tfloat Rm ;\t\tfloat beta ;\tfloat delta ;\t\tequation SIR {\t\tdiff ( Sm , t ) = ( - beta * Sm * Im / N ) ; \t\tdiff ( Im , t ) = ( beta * Sm\t* Im / N ) - ( delta * Im ) ; \t\tdiff ( Rm , t ) = ( delta * Im ) ;\t}\t\treflex solving {solve SIR method: \"rk4\" step: 0.01 ;}}experiment Simulation type: gui {\tparameter 'Number of Susceptible' type: int var: number_S &lt;- 495 category: \"Initial population\"; // The initial number of susceptibles\tparameter 'Number of Infected'    type: int var: number_I &lt;- 5   category: \"Initial population\";\tparameter 'Number of Removed'     type: int var: number_R &lt;- 0   category: \"Initial population\";\tparameter 'Beta (S-&gt;I)'  type: float var: beta &lt;- 1.0   category: \"Parameters\";\tparameter 'Delta (I-&gt;R)' type: float var: delta &lt;- 0.01 category: \"Parameters\";\t\toutput {\t\tdisplay \"split system\" {\t\t\tchart 'Susceptible' type: series background: rgb ( 'lightGray' ) {\t\t\t\tdata 'susceptible' value: first ( S_agt ) . Ssize color: rgb ( 'green' ) ;\t\t\t\tdata 'infected' value: first ( I_agt ) . Isize color: rgb ( 'red' ) ;\t\t\t\tdata 'removed' value: first ( R_agt ) . Rsize color: rgb ( 'blue' ) ;\t\t\t}\t\t}\t\tdisplay \"unified system\"{\t\t\tchart 'Susceptible' type: series background: rgb ( 'lightGray' ) {\t\t\t\tdata 'susceptible_maths' value: first( SIR_agt ).Sm color: rgb ( 'green' ) ;\t\t\t\tdata 'infected_maths' value: first( SIR_agt ).Im color: rgb ( 'red' ) ;\t\t\t\tdata 'removed_maths' value: first( SIR_agt ).Rm color: rgb ( 'blue' ) ;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Epidemiology-SIR-(Split-in-Agents).html"
      }
      ,
    
      "wiki-epidemiology-sir-switch-html": {
        "title": "SIR_switch",
        "content": "SIR_switch_Author : tri and hqnghi _A model which show how to implement ODE system, IBM model, and to switch from one to another using a threshold. Another interesting point seen in this model is the the minimization of the execution time by reducing the number of agents to compute infections.Code of the model :model SIR_switchglobal {\t// Parameters\tint initial_S &lt;- 495 ; // The number of susceptible\tint initial_I &lt;- 5   ; // The number of infected\tint initial_R &lt;- 0   ; // The number of removed \tfloat beta &lt;- 0.1   ; // The parameter Beta \tfloat delta &lt;- 0.01 ; // The parameter Delta\t\t\tint switch_threshold &lt;- 120 ; // threshold for switching models\tbool local_infection &lt;- true ;\tint neighbours_range &lt;- 2 ;\tbool local_random_walk &lt;- true ; \t\t\t// Global variables\tint grid_size &lt;- 50;geometry shape &lt;- square(grid_size);\tint number_Hosts &lt;- initial_S + initial_I + initial_R; // Total number of individuals\tSIR_model current_model; // serves as an interface, it is transparent to user if model is maths or IBM\tfloat beta_maths;\tint gridSize &lt;- 1; //size of the grid\tfloat neighbourhoodSize &lt;- 1.0; // average size of the neighbourhood (in number of cells)\t\tfloat adjust &lt;- 0.721; // to adjust math model to ABM when using random walk\tbool computeInfectionFromS &lt;- initial_S &lt; initial_I; // if true, use the S list to compute infections. If false, use I list.\t// the purpose is to minimize the number of evaluation by using the smallest list.\t\tinit {\t\tcreate new_scheduler;\t\t/* determine the size of the neighbourhood and the average count of hosts neighbours */\t\tgridSize &lt;- length(sir_grid);\t\tint nbCells &lt;- 0;\t\t\t\tloop cell over: sir_grid {\t\t\tnbCells &lt;- nbCells + length(cell.neighbours);\t\t}\t\tneighbourhoodSize &lt;- nbCells / gridSize + 1; // +1 to count itself in the neighbourhood;\t\tbeta_maths &lt;- beta * neighbourhoodSize * number_Hosts / gridSize * adjust;\t\t\t\twrite 'Switch will happen at population sizes around ' +switch_threshold;\t\twrite 'Basic Reproduction Number (R0): ' + string(beta / delta) + '\\n';\t\t\t\t//Creation of the switch_model agent that will manage the switch between the mathematical and the individual based models\t\tcreate switch_model {\t\t\tthreshold_to_IBM &lt;- switch_threshold;\t\t\tthreshold_to_Maths &lt;- switch_threshold;\t\t}\t\t//Creation of the model according to the one to begin with\t\tif (first(switch_model).start_with_IBM) {\t\t//\t\twrite 'Starting with IBM model';\t\t\tcreate IBM_model;\t\t\tcurrent_model &lt;- first(IBM_model);\t\t} else {\t\t//\t\twrite 'Starting with Maths model';\t\t\tcreate Math_model;\t\t\tcurrent_model &lt;- first(Math_model);\t\t}\t\t//Initialization of the Susceptible, Infected, Resistant and Total Compartiment\t\tcurrent_model.S &lt;- float(initial_S);\t\tcurrent_model.I &lt;- float(initial_I);\t\tcurrent_model.R &lt;- float(initial_R);\t\tcurrent_model.N &lt;- number_Hosts;\t\t\t\t//Ask to the model to initialize itself according to the value initialized\t\task current_model {\t\t\tdo initialize;\t\t}\t\t\t\t//Create the SIR maths with ODE to compare\t\tcreate my_SIR_maths {\t\t\tself.S &lt;- float(myself.initial_S);\t\t\tself.I &lt;- float(myself.initial_I);\t\t\tself.R &lt;- float(myself.initial_R);\t\t\tself.N &lt;- number_Hosts;\t\t\tself.beta1 &lt;- beta * neighbourhoodSize * (N / gridSize)* adjust;\t\t\tself.alpha &lt;- delta;\t\t}\t}\treflex infection_computation_method {\t/* computing infection from S has a complexity of S*ngb, where ngb is the size of the neighbourhood.\t * computing infection from I has a complexity of I*ngb.\t * this reflex determine which method has the lowest cost.\t * */\t\tcomputeInfectionFromS &lt;- (Host count (each.is_susceptible)) &lt; (Host count (each.is_infected));\t}}//Grid which represent the discretized space for the host agents\tgrid sir_grid width: grid_size height: grid_size {\t\trgb color &lt;- #black;\t\tlist&lt;sir_grid&gt; neighbours &lt;- (self neighbors_at neighbours_range) of_species sir_grid;\t}//Species which allows the execution of only Host, IBM_model, Math_model and switch_model at each cyclespecies new_scheduler schedules: (Host + IBM_model + Math_model + switch_model) ;//Species which represent the manager between IBM and Math modelspecies switch_model schedules: [] {\tint threshold_to_IBM &lt;- 45; // threshold under which the model swith to IBM\tint threshold_to_Maths &lt;- 50; // threshold under which the model swith to Maths model \tbool start_with_IBM function: { (initial_S &lt; threshold_to_IBM or initial_I &lt; threshold_to_IBM) };\t//Switch the model used to IBM when the threshold is higher than the population\treflex switch_to_IBM when: (current_model.model_type = 'Maths') {\t\tif (current_model.S &lt; threshold_to_IBM or current_model.I &lt; threshold_to_IBM) {\t\t\twrite 'Switch to IBM model at cycle ' + string(cycle);\t\t\tcreate IBM_model {\t\t\t\tself.S &lt;- current_model.S;\t\t\t\tself.I &lt;- current_model.I;\t\t\t\tself.R &lt;- current_model.R;\t\t\t\tself.N &lt;- current_model.N;\t\t\t\tdo initialize;\t\t\t}\t\t\task current_model {\t\t\t\tdo remove_model;\t\t\t}\t\t\tcurrent_model &lt;- first(IBM_model);\t\t}\t}\t//Switch the model used to Maths when the threshold is lower than the population\treflex switch_to_Maths when: (current_model.model_type = 'IBM') {\t\tif (current_model.S &gt; threshold_to_Maths and current_model.I &gt; threshold_to_Maths) {\t\t\twrite 'Switch to Maths model at cycle ' + cycle;\t\t\tcreate Math_model {\t\t\t\tself.S &lt;- current_model.S;\t\t\t\tself.I &lt;- current_model.I;\t\t\t\tself.R &lt;- current_model.R;\t\t\t\tself.N &lt;- current_model.N;\t\t\t\tdo initialize;\t\t\t}\t\t\task current_model {\t\t\t\tdo remove_model;\t\t\t}\t\t\tcurrent_model &lt;- first(Math_model);\t\t}\t}}//Species which represent the SIR model used by the IBM and the Math models species SIR_model schedules: [] {\tfloat S;\tfloat I;\tfloat R;\tint N;\tstring model_type &lt;- 'none';\t\taction remove_model {\t\tdo die;\t}\taction initialize ;}//Species IBM Model which represent the Individual based model, derivated from SIR_modelspecies IBM_model schedules: [] parent: SIR_model {\tstring model_type &lt;- 'IBM';\t\t//Action to initialize the Model with SIR compartiments\taction initialize {\t\t\t\twrite 'Initializing IBM model with S=' + round(S) + ', I=' + round(I) + ', R=' + round(R) + '\\n';\t\t//Creation of the host agents\t\tcreate Host number: round(S) {\t\t\tis_susceptible &lt;- true;\t\t\tis_infected &lt;- false;\t\t\tis_immune &lt;- false;\t\t\tcolor &lt;- #green;\t\t}\t\tcreate Host number: round(I) {\t\t\tis_susceptible &lt;- false;\t\t\tis_infected &lt;- true;\t\t\tis_immune &lt;- false;\t\t\tcolor &lt;- #red;\t\t}\t\tcreate Host number: round(R) {\t\t\tis_susceptible &lt;- false;\t\t\tis_infected &lt;- false;\t\t\tis_immune &lt;- true;\t\t\tcolor &lt;- #yellow;\t\t}\t\tdo count;\t}\treflex count {\t\tdo count;\t}\t//Action to update the different compartiments\taction count {\t\tS &lt;- float(Host count (each.is_susceptible));\t\tI &lt;- float(Host count (each.is_infected));\t\tR &lt;- float(Host count (each.is_immune));\t}\t//Action to remove the model and kill all the agents it contains\taction remove_model {\t\task Host {\t\t\tdo die;\t\t}\t\tdo die;\t}}//Species Math Model which represent the mathematical Ordinary Differential Equations model, derivated from SIR_modelspecies Math_model schedules: [] parent: SIR_model {\tstring model_type &lt;- 'Maths';\tfloat t;\t\taction initialize {\t\twrite 'Initializing Maths model with S=' + S + ', I=' + I + ', R=' + R + '\\n';\t}\tequation SIR {\t\tdiff(S, t) = (-beta_maths * S * I / N);\t\tdiff(I, t) = (beta_maths * S * I / N) - (delta * I);\t\tdiff(R, t) = (delta * I);\t}\treflex solving {solve SIR method: \"rk4\" step: 0.01 ;}}//Species host used by the Individual Based Model which move from one cell to anotherspecies Host schedules: [] skills: [moving] {\tbool is_susceptible &lt;- true;\tbool is_infected &lt;- false;\tbool is_immune &lt;- false;\trgb color &lt;- #green;\tsir_grid myPlace;\t\t/* next function computes the number of neighbours of the agent */\tint ngb_number function: {\t\tlength(((self) neighbors_at (2)) of_species Host) - 1 // -1 is because the agent counts itself\t};\t\tinit {\t\tmyPlace &lt;- one_of(sir_grid as list);\t\tlocation &lt;- myPlace.location;\t}\t//Reflex to move the agents among the cells\treflex basic_move {\t\tif (!local_random_walk) {\t\t/* random walk among neighbours */\t\t\tmyPlace &lt;- one_of(myPlace.neighbours);\t\t\tlocation &lt;- myPlace.location;\t\t} else {\t\t/* move agent to a random place anywhere in the grid */\t\t\tmyPlace &lt;- any(sir_grid);\t\t\tlocation &lt;- myPlace.location;\t\t}\t}\t//Reflex to make the agent infected when the infection is computed from S for a better execution time\treflex become_infected when: (is_susceptible and computeInfectionFromS) {\t\tif (flip(1 - (1 - beta) ^ (((self) neighbors_at (2)) of_species Host) count (each.is_infected))) {\t\t\tis_susceptible &lt;- false;\t\t\tis_infected &lt;- true;\t\t\tis_immune &lt;- false;\t\t\tcolor &lt;- #red;\t\t}\t}\t//Reflex to make the agent infect others when the infection is not computed from S for a better execution time\treflex infecte_others when: (is_infected and not (computeInfectionFromS)) {\t\tloop hst over: ((self) neighbors_at (2)) {\t\t\tif (hst.is_susceptible) {\t\t\t\tif (flip(beta)) {\t\t\t\t\thst.is_susceptible &lt;- false;\t\t\t\t\thst.is_infected &lt;- true;\t\t\t\t\thst.is_immune &lt;- false;\t\t\t\t\thst.color &lt;- #red;\t\t\t\t}\t\t\t}\t\t}\t}\t//Reflex to make the agent resistant\treflex become_immune when: (is_infected and flip(delta)) {\t\tis_susceptible &lt;- false;\t\tis_infected &lt;- false;\t\tis_immune &lt;- true;\t\tcolor &lt;- #yellow;\t}\taspect basic {\t\tdraw circle(1) color: color;\t}}//Species which represent the SIR mathematical model species my_SIR_maths {\tfloat t;\tfloat I &lt;- float(iInit);\tfloat S &lt;- N - I;\tfloat R &lt;- 0.0;\t\t\t\tfloat alpha &lt;- 0.01 min: 0.0 max: 1.0;\tfloat beta1 &lt;- 0.1 min: 0.0 max: 1000.0;\tint N &lt;- 500 min: 1 max: 3000;\tint iInit &lt;- 1;\tequation SIR {\t\tdiff(S, t) = (-beta1 * S * I / N);\t\tdiff(I, t) = (beta1 * S * I / N) - (alpha * I);\t\tdiff(R, t) = (alpha * I);\t}\t\treflex solving {solve SIR method:\"rk4\" step:0.01;}}experiment mysimulation type: gui {\tparameter 'Number of Susceptible' type: int var: initial_S &lt;- 495 category: \"Initial population\"; \tparameter 'Number of Infected'    type: int var: initial_I &lt;- 5   category: \"Initial population\";\tparameter 'Number of Removed'     type: int var: initial_R &lt;- 0   category: \"Initial population\";\tparameter 'Beta (S-&gt;I)'  type: float var: beta &lt;- 1.0   category: \"Parameters\";\tparameter 'Delta (I-&gt;R)' type: float var: delta &lt;- 0.01 category: \"Parameters\";\t\t\tparameter 'Is the infection is computed locally?' type: bool var: local_infection &lt;- true category: \"Infection\";\tparameter 'Size of the neighbours' type: int var: neighbours_range &lt;- 2 min:1 max: 5 category: \"Infection\";\tparameter 'Local Random Walk' type: bool var: local_random_walk &lt;- true category: \"Agents\";\t\t\tparameter 'Switch models at' type: int var: switch_threshold &lt;- 120 category: \"Model\";\t\toutput {\t\tdisplay 'sir display' {\t\t\tgrid sir_grid lines: #black;\t\t\tspecies Host aspect: basic;\t\t}\t\t\tdisplay 'Switch model' {\t\t\tchart 'Susceptible' type: series background: #lightgray style: exploded {\t\t\t\tdata 'susceptible' value: current_model.S color: #green;\t\t\t\tdata 'infected' value: current_model.I color: #red;\t\t\t\tdata 'immune' value: current_model.R color: #yellow;\t\t\t}\t\t}\t\tdisplay SI_maths  {\t\t\tchart \"SI\" type: series background: #white {\t\t\t\tdata 'S' value: first((my_SIR_maths)).S color: #green;\t\t\t\tdata 'I' value: first((my_SIR_maths)).I color: #red;\t\t\t\tdata 'R' value: first((my_SIR_maths)).R color: #yellow;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Epidemiology-SIR-(Switch).html"
      }
      ,
    
      "wiki-epidemiology-susceptible-infected-si-html": {
        "title": "SI without ODE",
        "content": "SI without ODE_Author : _A simple SI model without Ordinary Differential Equations showing agents moving randomly among a grid and becoming infectedCode of the model :model siglobal { \t    int number_S &lt;- 495;  // The number of susceptible    int number_I &lt;- 5 ;\t// The number of infected    float survivalProbability &lt;- 1/(70*365) ; // The survival probability\tfloat beta &lt;- 0.05 ; \t// The parameter Beta\tfloat nu &lt;- 0.001 ;\t// The parameter Nu\tint numberHosts &lt;- number_S+number_I; //Total number of hosts\tbool local_infection &lt;- true ; //Infection spread locally or not\tint neighbours_size &lt;- 2 ; //Size of the neighbourhood\tgeometry shape &lt;- square(50);\tinit { \t\t//Creation of all the susceptible hosts\t\tcreate Host number: number_S {        \tis_susceptible &lt;- true;        \tis_infected &lt;-  false;            is_immune &lt;-  false;             color &lt;-  #green;        }        //Creation of all the infected hosts        create Host number: number_I {            is_susceptible &lt;-  false;             is_infected &lt;-  true;            is_immune &lt;-  false;             color &lt;-  #red;         }   }   //Reflex to update the number of infected hosts   reflex compute_nb_infected {   \t\tnumber_I &lt;- Host count (each.is_infected);   }  }//Grid to discretize spacegrid si_grid width: 50 height: 50 use_individual_shapes: false use_regular_agents: false frequency: 0{\trgb color &lt;- #black;\tlist&lt;si_grid&gt; neighbours &lt;- (self neighbors_at neighbours_size) ;       }//Species host which represent the possible hosts of a diseasespecies Host  {\t//Booleans to represent the state of the agent\tbool is_susceptible &lt;- true;\tbool is_infected &lt;- false;    bool is_immune &lt;- false;    rgb color &lt;- #green;    int sic_count &lt;- 0;    si_grid myPlace;        //The agent is placed randomly among the grid    init {    \tmyPlace &lt;- one_of (si_grid as list);    \tlocation &lt;- myPlace.location;    }            //Reflex to move the agents in its neighbourhood    reflex basic_move {    \tmyPlace &lt;- one_of (myPlace.neighbours) ;        location &lt;- myPlace.location;    }    //Reflex to infect the agent if it is susceptible and according to the other infected agents    reflex become_infected when: is_susceptible {    \tfloat rate &lt;- 0.0;    \tif(local_infection) {    \t\tint nb_hosts &lt;- 0;    \t\tint nb_hosts_infected &lt;- 0;    \t\tloop hst over: ((myPlace.neighbours + myPlace) accumulate (Host overlapping each)) {    \t\t\tnb_hosts &lt;- nb_hosts + 1;    \t\t\tif (hst.is_infected) {    \t\t\t\tnb_hosts_infected &lt;- nb_hosts_infected + 1;    \t\t\t}    \t\t}    \t\trate &lt;- nb_hosts_infected / nb_hosts;    \t} else {    \t\trate &lt;- number_I / numberHosts;    \t}    \tif (flip(beta * rate)) {        \tis_susceptible &lt;-  false;            is_infected &lt;-  true;            is_immune &lt;-  false;            color &lt;-  #red;            }    }    //Reflex to kill the agent according to the death rate    reflex shallDie when: flip(nu) {\t\tcreate species(self) {\t\t\tmyPlace &lt;- myself.myPlace ;\t\t\tlocation &lt;- myself.location ; \t\t}       \tdo die;    }                aspect basic {        draw circle(1) color: color;     }}experiment Simulation type: gui {  \tparameter \"Number of Susceptible\" var: number_S ;// The number of susceptible    parameter \"Number of Infected\" var: number_I ;\t// The number of infected    parameter \"Survival Probability\" var: survivalProbability ; // The survival probability\tparameter \"Beta (S-&gt;I)\" var:beta; \t// The parameter Beta\tparameter \"Mortality\" var:nu ;\t// The parameter Nu\tparameter \"Is the infection is computed locally?\" var:local_infection ;\tparameter \"Size of the neighbours\" var:neighbours_size ;\t \toutput { \t    display si_display {\t        grid si_grid lines: #black;\t        species Host aspect: basic;\t    }\t        \t    display chart refresh: every(10) {\t\t\tchart \"Susceptible\" type: series background: #lightgray style: exploded {\t\t\t\tdata \"susceptible\" value: Host count (each.is_susceptible) color: #green;\t\t\t\tdata \"infected\" value: Host count (each.is_infected) color: #red;\t\t\t}\t\t}\t\t\t\t}}",
        "url":"/wiki/Epidemiology-Susceptible-Infected-(SI).html"
      }
      ,
    
      "wiki-epidemiology-susceptible-infected-recovered-sir-html": {
        "title": "SIR without ODE",
        "content": "SIR without ODE_Author : _A simple SIR model without Ordinary Differential Equations showing agents moving randomly among a grid and becoming infected then resistant to a diseaseCode of the model :model siglobal { \t//Number of susceptible host at init    int number_S &lt;- 495;    //Number of infected host at init    int number_I &lt;- 5 ;    //Number of resistant host at init    int number_R &lt;- 0 ;    //Rate for the infection success \tfloat beta &lt;- 0.05 ;\t//Mortality rate for the host\tfloat nu &lt;- 0.001 ;\t//Rate for resistance \tfloat delta &lt;- 0.01;\t//Number total of hosts\tint numberHosts &lt;- number_S+number_I+number_R;\t//Boolean to represent if the infection is computed locally\tbool local_infection &lt;- true parameter: \"Is the infection is computed locally?\";\t//Range of the cells considered as neighbours for a cell\tint neighbours_size &lt;- 2 min:1 max: 5 parameter:\"Size of the neighbours\";\t\tfloat R0 ;\tgeometry shape &lt;- square(50);\t\tinit {\t\t//Creation of all the susceptible Host\t\tcreate Host number: number_S {        \tis_susceptible &lt;- true;        \tis_infected &lt;-  false;            is_immune &lt;-  false;             color &lt;-  #green;        }        //Creation of all the infected Host        create Host number: number_I {            is_susceptible &lt;-  false;            is_infected &lt;-  true;            is_immune &lt;-  false;             color &lt;-  #red;        }       //Creation of all the resistant Host       create Host number: number_R {            is_susceptible &lt;-  false;            is_infected &lt;-  false;            is_immune &lt;-  true;             color &lt;-  #blue;        }                     R0 &lt;- beta/(delta+nu);\t\twrite \"Basic Reproduction Number: \"+ R0;   }      //Reflex to update the number of infected   reflex compute_nb_infected {   \t\tnumber_I &lt;- Host count (each.is_infected);   }       }//Grid used to discretize space grid sir_grid width: 50 height: 50 use_individual_shapes: false use_regular_agents: false frequency: 0{\trgb color &lt;- #black;\tlist&lt;sir_grid&gt; neighbours &lt;- (self neighbors_at neighbours_size) ;       }//Species host which represent the Host of the diseasespecies Host  {\t//Booleans to represent the state of the host agent\tbool is_susceptible &lt;- true;\tbool is_infected &lt;- false;    bool is_immune &lt;- false;    rgb color &lt;- #green;    sir_grid myPlace;        init {    \t//Place the agent randomly among the grid    \tmyPlace &lt;- one_of (sir_grid as list);    \tlocation &lt;- myPlace.location;    }         //Reflex to make the agent move       reflex basic_move {    \tmyPlace &lt;- one_of (myPlace.neighbours) ;        location &lt;- myPlace.location;    }    //Reflex to make the agent infected if it is susceptible    reflex become_infected when: is_susceptible {    \tfloat rate  &lt;- 0.0;    \t//computation of the infection according to the possibility of the disease to spread locally or not    \tif(local_infection) {    \t\tint nb_hosts  &lt;- 0;    \t\tint nb_hosts_infected  &lt;- 0;    \t\tloop hst over: ((myPlace.neighbours + myPlace) accumulate (Host overlapping each)) {    \t\t\tnb_hosts &lt;- nb_hosts + 1;    \t\t\tif (hst.is_infected) {nb_hosts_infected &lt;- nb_hosts_infected + 1;}    \t\t}    \t\trate &lt;- nb_hosts_infected / nb_hosts;    \t} else {    \t\trate &lt;- number_I / numberHosts;    \t}    \tif (flip(beta * rate)) {        \tis_susceptible &lt;-  false;            is_infected &lt;-  true;            is_immune &lt;-  false;            color &lt;-  #red;            }    }    //Reflex to make the agent recovered if it is infected and if it success the probability    reflex become_immune when: (is_infected and flip(delta)) {    \tis_susceptible &lt;- false;    \tis_infected &lt;- false;        is_immune &lt;- true;        color &lt;- #blue;    }    //Reflex to kill the agent according to the probability of dying    reflex shallDie when: flip(nu) {    \t//Create another agent\t\tcreate species(self)  {\t\t\tmyPlace &lt;- myself.myPlace ;\t\t\tlocation &lt;- myself.location ; \t\t}       \tdo die;    }                aspect basic {        draw circle(1) color: color;     }}experiment Simulation type: gui {  \tparameter \"Number of Susceptible\" var: number_S ;// The number of susceptible    parameter \"Number of Infected\" var: number_I ;\t// The number of infected    parameter \"Number of Resistant\" var:number_R ;\t// The number of removed\tparameter \"Beta (S-&gt;I)\" var:beta; \t// The parameter Beta\tparameter \"Mortality\" var:nu ;\t// The parameter Nu\tparameter \"Delta (I-&gt;R)\" var: delta; // The parameter Delta\tparameter \"Is the infection is computed locally?\" var:local_infection ;\tparameter \"Size of the neighbours\" var:neighbours_size ; \toutput { \t    display sir_display {\t        grid sir_grid lines: #black;\t        species Host aspect: basic;\t    }\t        \t    display chart refresh: every(10) {\t\t\tchart \"Susceptible\" type: series background: #lightgray style: exploded {\t\t\t\tdata \"susceptible\" value: Host count (each.is_susceptible) color: #green;\t\t\t\tdata \"infected\" value: Host count (each.is_infected) color: #red;\t\t\t\tdata \"immune\" value: Host count (each.is_immune) color: #blue;\t\t\t}\t\t}\t\t\t\t}}",
        "url":"/wiki/Epidemiology-Susceptible-Infected-Recovered-(SIR).html"
      }
      ,
    
      "wiki-epidemiology-html": {
        "title": "Epidemiology",
        "content": "EpidemiologyThis sub-section is composed of the following models :      comparison_ABM_EBM_SIR        simple_ODE_SIR_Predefined        SIR_split_in_agents        SIR_switch        SI without ODE        SIR without ODE  ",
        "url":"/wiki/Epidemiology.html"
      }
      ,
    
      "wiki-equations-html": {
        "title": "Using Equations",
        "content": "Using EquationsIntroductionODEs (Ordinary Differential Equations) are often used in ecology or in epidemiology to describe the macroscopic evolution over time of a population. Generally the whole population is split into several compartments. The state of the population is described by the number of individuals in each compartment. Each equation of the ODE system describes the evolution of the number of individual in a compartment. In such an approach individuals are not taken into account individually, with own features and behaviors. In contrary they are aggregated in a compartment and reduced to a number.A classical example is the SIR epidemic model representing the spreading of a disease in a population. The population is split into 3 compartments: S (Susceptible), I (Infected), R (Recovered). (see below for the equation)In general the ODE systems cannot be analytically solved, i.e. it is not possible to find the equation describing the evolution of the number of S, I or R. But these systems can be numerically integrated in order to get the evolution. A numerical integration computes step after step the value of S, I and R. Several integration methods exist (e.g. Euler, Runge-Kutta…), each of them being a compromise between accuracy and computation time. The length of the integration step has also a huge impact on precision. These models are deterministic.This approach makes a lot of strong hypotheses. The model does not take into account space. The population is considered has infinite and homogeneously mixed, so that any agent can interact with any other one.Example of a SIR modelIn the SIR model, the population is split into 3 compartments: S (Susceptible), I (Infected), R (Recovered). This can be represented by the following Forrester diagram: boxes represent stocks (i.e. compartments) and arrows are flows. Arrows hold the rate of a compartment population flowing to another compartment.The corresponding ODE system contains one equation per stock. For example, the I compartment evolution is influenced by an inner (so positive) flow from the S compartment and an outer (so negative) flow to the R compartment.Integrating this system using the Runge-Kutta 4 method provides the evolution of S, I and R over time. The initial values are:  S = 499  I = 1  R = 0  beta = 0.4  gamma = 0.1  h = 0.1Why and when can we use ODE in agent-based models ?These hypotheses are very strong and cannot be fulfilled in agent-based models.But in some multi-scale models, some entities can be close. For example if we want to implement a model describing the worldwide epidemic spread and the impact of air traffic on it, we cannot simulate the 7 billions people. But we can represent only cities with airports and airplanes as agents. In this case, cities are entities with a population of millions inhabitants, that will not been spatially located. As we are only interested in the disease spread, we are only interested in the number of infected people in the cities (and susceptibles and recovered too). As a consequence, it appears particularly relevant to describe the evolution of the disease in the city using a ODE system.In addition these models have the advantage to not be sensible to population size in the integration process. Dozens or billions people does not bring a computation time increase, contrarily to agent-based models.Use of ODE in a GAML modelA stereotypical use of ODE in a GAMA agent-based model is to describe species where some agents attributes evolution is described using an ODE system.As a consequence, the GAML language has been increased by two main concepts (as two statements):  equations can be written with the equation statement. An equation block is composed of a set of diff statement describing the evolution of species attributes.  an equation can be numerically integrated using the solve statementequationDefining an ODE systemDefining a new ODE system needs to define a new equation block in a species. As example, the following eqSI system describes the evolution of a population with 2 compartments (S and I) and the flow from S to I compartment:species userSI {\tfloat t ;\tfloat I ; \tfloat S ; \tint N ;\tfloat beta&lt;-0.4 ;\tfloat h ;\t\tequation eqSI {\t\tdiff(S,t) = -beta * S * I / N ;\t\tdiff(I,t) = beta * S * I / N ;\t}}\t\t\tThis equation has to be defined in a species with t, S and I attributes. beta (and other similar parameters) can be defined either in the specific species (if it is specific to each agents) or in the global if it is a constant.Note: the t attribute will be automatically updated using the solve statement ; it contains the time elapsed in the equation integration.Using a built-in ODE systemIn order to ease the use of very classical ODE system, some built-in systems have been implemented in GAMA. For example, the previous SI system can be written as follows. Three additional facets are used to define the system:  type: the identifier of the built-in system (here SI) (the list of all built-in systems are described below),  vars: this facet is expecting a list of variables of the species, that will be matched with the variables of the system,  params: this facet is expecting a list of variables of the species (of of the global), that will be matched with the parameters of the system.    equation eqBuiltInSI type: SI vars: [S,I,t] params: [N,beta] ;      Split a system into several agentsAn equation system can be split into several species and each part of the system are synchronized using the simultaneously facet of equation. The system split into several agents can be integrated using a single call to the solve statement. Notice that all the equation definition must have the same name.For example the SI system presented above can be defined in two different species S_agt (containing the equation defining the evolution of the S value) and I_agt (containing the equation defining the evolution of the I value). These two equations are linked using the simultaneously facet of the equation statement. This facet expects a set of agents. The integration is called only once in a simulation step, e.g. in the S_agt agent.species S_agt {\tfloat t ;\t\t\tfloat Ssize ;\t\tequation evol simultaneously: [ I_agt ] {\t\tdiff(Ssize, t) = (- sum(I_agt accumulate [each.beta * each.Isize]) * self.Ssize / N);\t}\t\treflex solving {solve evol method : rk4 step : hKR4 ;}\t}species I_agt {\tfloat t ;\tfloat Isize ; // number of infected\t\tfloat beta ;\tequation evol simultaneously : [ S_agt ] {\t\tdiff(Isize, t) = (beta * first(S_agt).Ssize * Isize / N);\t}}The interest is that the modeler can create several agents for each compartment, which different values. For example in the SI model, the modeler can choose to create 1 agent S_agt and 2 agents I_agt. The beta attribute will have different values in the two agents, in order to represent 2 different strains.global {\tint number_S &lt;- 495 ; // The number of susceptible\tint number_I &lt;- 5   ; // The number of infected\tint nb_I &lt;- 2;\tfloat gbeta  &lt;- 0.3  ; // The parameter Beta\t\tint N &lt;- number_S + nb_I * number_I ;\tfloat hKR4 &lt;- 0.1 ;\tinit {\t\tcreate S_agt {\t\t\tSsize &lt;- float(number_S) ;\t\t}\t\tcreate I_agt number: nb_I {\t\t\tIsize &lt;- float(number_I) ;\t\t\tself.beta &lt;- myself.gbeta + rnd(0.5) ;\t\t}\t}}The results are computed using the RK4 method with:  number_S = 495  number_I = 5  nb_I = 2  gbeta = 0.3  hKR4 = 0.1solve an equationThe solve statement has been added in order to integrate numerically the equation system. It should be add into a reflex. At each simulation step, a step of the integration is executed, the length of the integration step is defined in the step facet. The solve statement will update the variables used in the equation system. The chosen integration method (defined in method) is Runge-Kutta 4 (which is very often a good choice of integration method in terms of accuracy).reflex solving {\tsolve eqSI method:rk4 step:h;}With a smaller integration step, the integration will be faster but less accurate.More detailsDetails about the solve statementThe solve statement can have a huge set of facets (see [S_Statements#solve] for more details). The basic use of the solve statement requiers only the equation identifier. By default, the integration method is Runge-Kutta 4 with an integration step of 1, which means that at each simulation step the equation integration is made over 1 unit of time (which is implicitly defined by the system parameter value).solve eqSI ;2 integration methods can be used:  method: rk4 will use the Runge-Kutta 4 integration method  method: dp853 will use the Dorman-Prince 8(5,3) integration method. The advantage of this method compared to Runge-Kutta is that it has an evaluation of the error and can use it to adapt the integration step size.In order to synchronize the simulation step and the equation integration step, 2 facets can be used:  step: number  cycle_length: numbercycle_length (int): length of simulation cycle which will be synchronize with step of integrator (default value: 1)step (float): integration step, use with most integrator methods (default value: 1)time_final (float): target time for the integration (can be set to a value smaller than t0 for backward integration)time_initial (float): initial timediscretizing_step (int): number of discret beside 2 step of simulation (default value: 0)integrated_times (list): time interval inside integration processintegrated_values (list): list of variables’s value inside integration processSome facets are specific to the DP853 integration methods: max_step, min_step, scalAbsoluteTolerance and scalRelativeTolerance.Example of the influence of the integration stepThe step and cycle_length facets of the integration method may have a huge influence on the results. step has an impact on the result accuracy. In addition, it is possible to synchronize the step of the (agent-based) simulation and the (equation) integration step in various ways (depending on the modeler purpose) using the cycle_length facet: e.g. cycle_length: 10 means that 10 simulation steps are equivalent to 1 unit of time of the integration method.      solve SIR method: \"rk4\" step: 1.0 cycle_length: 1.0 ;         solve SIR method: \"rk4\" step: 0.1 cycle_length: 10.0 ;         solve SIR method: \"rk4\" step: 0.01 cycle_length: 100.0 ;   List of built-in ODE systemsSeveral built-in equations have been defined.equation eqBuiltInSI type: SI vars: [S,I,t] params: [N,beta];This system is equivalent to:equation eqSI {\tdiff(S,t) = -beta * S * I / N ;\tdiff(I,t) = beta * S * I / N ;}The results are provided using the Runge-Kutta 4 method using following initial values:  S = 499  I = 1  beta = 0.4  h = 0.1equation eqSIS type: SIS vars: [S,I,t] params: [N,beta,gamma];This system is equivalent to:equation eqSIS {\tdiff(S,t) = -beta * S * I / N + gamma * I;\tdiff(I,t) = beta * S * I / N - gamma * I;}The results are provided using the Runge-Kutta 4 method using following initial values:  S = 499  I = 1  beta = 0.4  gamma = 0.1  h = 0.1equation eqSIR type:SIR vars:[S,I,R,t] params:[N,beta,gamma] ;This system is equivalent to:equation eqSIR {\tdiff(S,t) = (- beta * S * I / N);\tdiff(I,t) = (beta * S * I / N) - (gamma * I);\tdiff(R,t) = (gamma * I);}The results are provided using the Runge-Kutta 4 method using following initial values:  S = 499  I = 1  R = 0  beta = 0.4  gamma = 0.1  h = 0.1equation eqSIRS type: SIRS vars: [S,I,R,t] params: [N,beta,gamma,omega,mu] ;This system is equivalent to:equation eqSIRS {\t diff(S,t) = mu * N + omega * R + - beta * S * I / N - mu * S ;\t diff(I,t) = beta * S * I / N - gamma * I - mu * I ;\t diff(R,t) = gamma * I - omega * R - mu * R ;}The results are provided using the Runge-Kutta 4 method using following initial values:  S = 499  I = 1  R = 0  beta = 0.4  gamma = 0.01  omega = 0.05  mu = 0.01  h = 0.1equation eqSEIR type: SEIR vars: [S,E,I,R,t] params: [N,beta,gamma,sigma,mu] ;This system is equivalent to:equation eqSEIR {\tdiff(S,t) = mu * N - beta * S * I / N - mu * S ;\tdiff(E,t) = beta * S * I / N - mu * E - sigma * E ;\tdiff(I,t) = sigma * E - mu * I - gamma * I;\tdiff(R,t) = gamma * I - mu * R ;}The results are provided using the Runge-Kutta 4 method using following initial values:  S = 499  E = 0  I = 1  R = 0  beta = 0.4  gamma = 0.01  sigma = 0.05  mu = 0.01  h = 0.1equation eqLV type: LV vars: [x,y,t] params: [alpha,beta,delta,gamma] ;This system is equivalent to:equation eqLV { \tdiff(x,t) =   x * (alpha - beta * y);\tdiff(y,t) = - y * (delta - gamma * x);}\tThe results are provided using the Runge-Kutta 4 method using following initial values:  x = 2  y = 2  alpha = 0.8  beta = 0.3  gamma = 0.2  delta = 0.85  h = 0.1//: # (endConcept|equation)",
        "url":"/wiki/Equations.html"
      }
      ,
    
      "wiki-errorsview-html": {
        "title": "Errors View",
        "content": "Errors ViewWhenever a runtime error, or a warning, is issued by the currently running experiment, a view called “Errors” is opened automatically. This view provides, together with the error/warning itself, some contextual information about who raised the error (i.e. which agent(s)) and where (i.e. in which portion of the model code). As with other “status” in GAMA, errors will appear in red color and warnings in orange.Since an error appearing in the code is likely to be raised by several agents at once, GAMA groups similar errors together, simply indicating which agent(s) raised them. Note that, unless the error is raised by the experiment agent itself, its message will indicate that at least 2 agents raised it: the original agent and the experiment in which it is plunged.",
        "url":"/wiki/ErrorsView.html"
      }
      ,
    
      "wiki-evacuation-continuous-move-html": {
        "title": "continuous_move",
        "content": "continuous_moveAuthor : Patrick TaillandierA 3D model which show how to represent an evacuation system with obstacles, cohesion factor and velocity. The people are placed randomly and have to escape by going to a target pointCode of the model :model continuous_move global { \t//Shapefile of the buildings\tfile building_shapefile &lt;- file(\"../includes/building.shp\");\t//Shape of the environment\tgeometry shape &lt;- envelope(building_shapefile);\tint maximal_turn &lt;- 90; //in degree\tint cohesion_factor &lt;- 10;\t//Size of the people\tfloat people_size &lt;- 2.0;\t//Space without buildings\tgeometry free_space;\t//Number of people agent\tint nb_people &lt;- 500;\t//Point to evacuate\tpoint target_point &lt;- {world.location.x, 0};\tinit { \t\t\t\tfree_space &lt;- copy(shape);\t\t//Creation of the buildinds\t\tcreate building from: building_shapefile {\t\t\t//Creation of the free space by removing the shape of the different buildings existing\t\t\tfree_space &lt;- free_space - (shape + people_size);\t\t}\t\t//Simplification of the free_space to remove sharp edges\t\tfree_space &lt;- free_space simplification(1.0);\t\t//Creation of the people agents\t\tcreate people number: nb_people {\t\t\t//People agents are placed randomly among the free space\t\t\tlocation &lt;- any_location_in(free_space);\t\t\ttarget_loc &lt;-  target_point;\t\t} \t\t \t\t}\t}//Species which represent the building species building {\t//Height of the buildings\tfloat height &lt;- 3.0 + rnd(5);\taspect default {\t\tdraw shape color: #gray depth: height;\t}}//Species people which move to the evacuation point using the skill movingspecies people skills:[moving]{\t//Target point to evacuate\tpoint target_loc;\t//Speed of the agent\tfloat speed &lt;- 0.5 + rnd(1000) / 1000;\t//Velocity of the agent\tpoint velocity &lt;- {0,0};\t//Direction of the agent taking in consideration the maximal turn an agent is able to make\tint heading max: heading + maximal_turn min: heading - maximal_turn;\t\t//Size of the agent\tfloat size &lt;- people_size;\trgb color &lt;- rgb(rnd(255),rnd(255),rnd(255));\t\t\t//Reflex to kill the agent when it has evacuated the area\treflex end when: location distance_to target_loc &lt;= 2 * people_size{\t\twrite name + \" is arrived\";\t\tdo die;\t}\t//Reflex to compute the velocity of the agent considering the cohesion factor\treflex follow_goal  {\t\tvelocity &lt;- velocity + ((target_loc - location) / cohesion_factor);\t}\t//Reflex to apply separation when people are too close from each other\treflex separation {\t\tpoint acc &lt;- {0,0};\t\task (people at_distance size)  {\t\t\tacc &lt;- acc - (location - myself.location);\t\t}  \t\tvelocity &lt;- velocity + acc;\t}\t//Reflex to avoid the different obstacles\treflex avoid { \t\tpoint acc &lt;- {0,0};\t\tlist&lt;building&gt; nearby_obstacles &lt;- (building at_distance people_size);\t\tloop obs over: nearby_obstacles {\t\t\tacc &lt;- acc - (obs.location - location);\t\t}\t\tvelocity &lt;- velocity + acc; \t}\t//Reflex to move the agent considering its location, target and velocity\treflex move {\t\tpoint old_location &lt;- copy(location);\t\tdo goto target: location + velocity ;\t\tif (not empty(building overlapping self )) {\t\t\tlocation &lt;- point((location closest_points_with free_space)[1]);\t\t}\t\tvelocity &lt;- location - old_location;\t}\t\taspect default {\t\tdraw pyramid(size) color: color;\t\tdraw sphere(size/3) at: {location.x,location.y,size} color: color;\t}}experiment main type: gui {\tparameter \"nb people\" var: nb_people min: 1 max: 1000;\toutput {\t\tdisplay map type: opengl {\t\t\tspecies building refresh: false;\t\t\tspecies people;\t\t\tgraphics \"exit\" refresh: false {\t\t\t\tdraw sphere(2 * people_size) at: target_point color: #green;\t\t\t\t}\t\t}\t}}",
        "url":"/wiki/Evacuation-Continuous-Move.html"
      }
      ,
    
      "wiki-evacuation-goto-on-grid-html": {
        "title": "evacuationgoto",
        "content": "evacuationgotoAuthor : Patrick TaillandierA 3D model with walls and exit, and people agents trying to evacuate from the area to a exit location, avoiding the walls with a discretized space by a gridCode of the model :model evacuationgotoglobal {\t//Shapefile of the walls\tfile wall_shapefile &lt;- shape_file(\"../includes/walls.shp\");\t//Shapefile of the exit\tfile exit_shapefile &lt;- shape_file(\"../includes/exit.shp\");\t//DImension of the grid agent\tint nb_cols &lt;- 50;\tint nb_rows &lt;- 50;\t\t//Shape of the world initialized as the bounding box around the walls\tgeometry shape &lt;- envelope(wall_shapefile);\t\tinit {\t\t//Creation of the wall and initialization of the cell is_wall attribute\t\tcreate wall from: wall_shapefile {\t\t\task cell overlapping self {\t\t\t\tis_wall &lt;- true;\t\t\t}\t\t}\t\t//Creation of the exit and initialization of the cell is_exit attribute\t\tcreate exit from: exit_shapefile {\t\t\task (cell overlapping self) where not each.is_wall{\t\t\t\tis_exit &lt;- true;\t\t\t}\t\t}\t\t//Creation of the people agent\t\tcreate people number: 50{\t\t\t//People agent are placed randomly among cells which aren't wall\t\t\tlocation &lt;- one_of(cell where not each.is_wall).location;\t\t\t//Target of the people agent is one of the possible exits\t\t\ttarget &lt;- one_of(cell where each.is_exit).location;\t\t}\t}}//Grid species to discretize spacegrid cell width: nb_cols height: nb_rows neighbors: 8 {\tbool is_wall &lt;- false;\tbool is_exit &lt;- false;\trgb color &lt;- #white;\t}//Species exit which represent the exitspecies exit {\taspect default {\t\tdraw shape color: #blue;\t}}//Species which represent the wallspecies wall {\taspect default {\t\tdraw shape color: #black depth: 10;\t}}//Species which represent the people moving from their location to an exit using the skill movingspecies people skills: [moving]{\t//Evacuation point\tpoint target;\trgb color &lt;- rnd_color(255);\t\t//Reflex to move the agent \treflex move {\t\t//Make the agent move only on cell without walls\t\tdo goto target: target speed: 1 on: (cell where not each.is_wall) recompute_path: false;\t\t//If the agent is close enough to the exit, it dies\t\tif (self distance_to target) &lt; 2.0 {\t\t\tdo die;\t\t}\t}\taspect default {\t\tdraw pyramid(2) color: color;\t\tdraw sphere(1) at: {location.x,location.y,2} color: color;\t}}experiment evacuationgoto type: gui {\toutput {\t\tdisplay map type: opengl{\t\t\timage \"../images/floor.jpg\";\t\t\tspecies wall refresh: false;\t\t\tspecies exit refresh: false;\t\t\tspecies people;\t\t\t\t\t}\t}}",
        "url":"/wiki/Evacuation-Goto-on-Grid.html"
      }
      ,
    
      "wiki-evacuation-move-on-grid-html": {
        "title": "grid_move",
        "content": "grid_move_Author : _A 3D model which show how to represent an evacuation system with obstacles, cohesion factor and velocity. The people are placed randomly and have to escape by going to a target point, within a discretized space by a grid. The agents don’t use the skill moving to move.Code of the model :model grid_moveglobal {\t//Shapefile of the buildings\tfile building_shapefile &lt;- file(\"../includes/building.shp\");\t//Shape of the world\tgeometry shape &lt;- envelope(building_shapefile);\t//Maximum memory of the agent to avoid loop of the agents\tint max_memory &lt;- 5;\t//Size of the people agents\tfloat people_size &lt;- 2.0;\t//Number of people agents\tint nb_people &lt;- 500;\t//Evacuation point for the people agents\tpoint target_point &lt;- {world.location.x, 0};\t\tinit {\t\t//Creation of the building agents using the shapefile\t\tcreate building from: building_shapefile\t\t{\t\t\t//Initialization of the cell is_obstacle attribute\t\t\task cell overlapping self {\t\t\t\tis_obstacle &lt;- true;\t\t\t\tcolor &lt;- #black;\t\t\t}\t\t}\t\tlist&lt;cell&gt; free_cell &lt;- cell where not (each.is_obstacle);\t\tcell the_target_cell &lt;- cell closest_to target_point;\t\t//Creation of the people agent\t\tcreate people number: nb_people {\t\t\t//People agent are placed randomly among the cells which haven't people or obstacle\t\t\tcurrent_cell &lt;- one_of(free_cell);\t\t\tcurrent_cell.is_free &lt;- false;\t\t\tremove current_cell from: free_cell;\t\t\tlocation &lt;- current_cell.location;\t\t\ttarget_cell &lt;- the_target_cell;\t\t\tmemory &lt;&lt; current_cell;\t\t\t\t\t}\t}}//Species which represent the buildingsspecies building {\tfloat height &lt;- 3.0 + rnd(5);\taspect default {\t\tdraw shape color: #gray depth: height;\t}}//Species which represent the people agent moving from one cell to its neighboursspecies people {\t//Current cell of the agent\tcell current_cell;\t//Evacuation cell of the agent\tcell target_cell;\t//List of the cells already passed by the agents and mesmorized\tlist&lt;cell&gt; memory;\t//Size of the agent\tfloat size &lt;- people_size;\trgb color &lt;- rgb(rnd(255),rnd(255),rnd(255));\t\t\t//Reflex to kill the agent once it is close enough to an evacuation point\treflex end when: location distance_to target_cell.location &lt;= 2 * people_size {\t\tcurrent_cell.is_free &lt;- true;\t\tdo die;\t}\t//Reflex to move the agent\treflex move {\t\t//List of all the cells possible (which aren't obstacles, without people on it and on which the agent hasn't already passed\t\tlist&lt;cell&gt; possible_cells &lt;- current_cell neighbors_at 1 where (not (each.is_obstacle) and each.is_free and not (each in memory));\t\t//If there is possible cell, the agent move on the closest one to the evacuation point\t\tif not empty(possible_cells) {\t\t\tcurrent_cell.is_free &lt;- true;\t\t\tcurrent_cell &lt;- shuffle(possible_cells) with_min_of (each.location distance_to target_cell.location);\t\t\tlocation &lt;- current_cell.location;\t\t\tcurrent_cell.is_free &lt;- false;\t\t\t//Management of the memory of the agents\t\t\tmemory &lt;&lt; current_cell; \t\t\tif (length(memory) &gt; max_memory) {\t\t\t\tremove memory[0] from: memory;\t\t\t}\t\t}\t}\t\taspect default {\t\tdraw pyramid(size) color: color;\t\tdraw sphere(size/3) at: {location.x,location.y,size} color: color;\t}}//Grid species to discretize spacegrid cell width: 150 height: 150  neighbors: 8 frequency: 0 {\tbool is_obstacle &lt;- false;\tbool is_free &lt;- true;\trgb color &lt;- #white;}experiment main type: gui {\tparameter \"nb people\" var: nb_people min: 1 max: 1000;\toutput {\t\tdisplay map type: opengl camera_pos: {world.location.x,-world.shape.height*1.5,70}                        camera_look_pos:{world.location.x,0,0}    {\t\t\timage '../images/soil.jpg';\t\t\tspecies building refresh: false;\t\t\tspecies people;\t\t\tgraphics \"exit\" refresh: false {\t\t\t\tdraw sphere(2 * people_size) at: target_point color: #green;\t\t\t\t}\t\t}\t}}",
        "url":"/wiki/Evacuation-Move-on-Grid.html"
      }
      ,
    
      "wiki-evacuation-continuous-move-html": {
        "title": "continuous_move",
        "content": "continuous_moveAuthor : Patrick TaillandierA 3D model which show how to represent an evacuation system with obstacles, cohesion factor and velocity. The people are placed randomly and have to escape by going to a target pointCode of the model :model continuous_move global { \t//Shapefile of the buildings\tfile building_shapefile &lt;- file(\"../includes/building.shp\");\t//Shape of the environment\tgeometry shape &lt;- envelope(building_shapefile);\tint maximal_turn &lt;- 90; //in degree\tint cohesion_factor &lt;- 10;\t//Size of the people\tfloat people_size &lt;- 2.0;\t//Space without buildings\tgeometry free_space;\t//Number of people agent\tint nb_people &lt;- 500;\t//Point to evacuate\tpoint target_point &lt;- {world.location.x, 0};\tinit { \t\t\t\tfree_space &lt;- copy(shape);\t\t//Creation of the buildinds\t\tcreate building from: building_shapefile {\t\t\t//Creation of the free space by removing the shape of the different buildings existing\t\t\tfree_space &lt;- free_space - (shape + people_size);\t\t}\t\t//Simplification of the free_space to remove sharp edges\t\tfree_space &lt;- free_space simplification(1.0);\t\t//Creation of the people agents\t\tcreate people number: nb_people {\t\t\t//People agents are placed randomly among the free space\t\t\tlocation &lt;- any_location_in(free_space);\t\t\ttarget_loc &lt;-  target_point;\t\t} \t\t \t\t}\t}//Species which represent the building species building {\t//Height of the buildings\tfloat height &lt;- 3.0 + rnd(5);\taspect default {\t\tdraw shape color: #gray depth: height;\t}}//Species people which move to the evacuation point using the skill movingspecies people skills:[moving]{\t//Target point to evacuate\tpoint target_loc;\t//Speed of the agent\tfloat speed &lt;- 0.5 + rnd(1000) / 1000;\t//Velocity of the agent\tpoint velocity &lt;- {0,0};\t//Direction of the agent taking in consideration the maximal turn an agent is able to make\tint heading max: heading + maximal_turn min: heading - maximal_turn;\t\t//Size of the agent\tfloat size &lt;- people_size;\trgb color &lt;- rgb(rnd(255),rnd(255),rnd(255));\t\t\t//Reflex to kill the agent when it has evacuated the area\treflex end when: location distance_to target_loc &lt;= 2 * people_size{\t\twrite name + \" is arrived\";\t\tdo die;\t}\t//Reflex to compute the velocity of the agent considering the cohesion factor\treflex follow_goal  {\t\tvelocity &lt;- velocity + ((target_loc - location) / cohesion_factor);\t}\t//Reflex to apply separation when people are too close from each other\treflex separation {\t\tpoint acc &lt;- {0,0};\t\task (people at_distance size)  {\t\t\tacc &lt;- acc - (location - myself.location);\t\t}  \t\tvelocity &lt;- velocity + acc;\t}\t//Reflex to avoid the different obstacles\treflex avoid { \t\tpoint acc &lt;- {0,0};\t\tlist&lt;building&gt; nearby_obstacles &lt;- (building at_distance people_size);\t\tloop obs over: nearby_obstacles {\t\t\tacc &lt;- acc - (obs.location - location);\t\t}\t\tvelocity &lt;- velocity + acc; \t}\t//Reflex to move the agent considering its location, target and velocity\treflex move {\t\tpoint old_location &lt;- copy(location);\t\tdo goto target: location + velocity ;\t\tif (not empty(building overlapping self )) {\t\t\tlocation &lt;- point((location closest_points_with free_space)[1]);\t\t}\t\tvelocity &lt;- location - old_location;\t}\t\taspect default {\t\tdraw pyramid(size) color: color;\t\tdraw sphere(size/3) at: {location.x,location.y,size} color: color;\t}}experiment main type: gui {\tparameter \"nb people\" var: nb_people min: 1 max: 1000;\toutput {\t\tdisplay map type: opengl camera_pos: {world.location.x,-world.shape.height*1.5,70}                        camera_look_pos:{world.location.x,0,0}    {\t\t\timage '../images/soil.jpg';\t\t\tspecies building refresh: false;\t\t\tspecies people;\t\t\tgraphics \"exit\" refresh: false {\t\t\t\tdraw sphere(2 * people_size) at: target_point color: #green;\t\t\t\t}\t\t}\t}}",
        "url":"/wiki/Evacuation-continuous_move.html"
      }
      ,
    
      "wiki-evacuation-grid-goto-html": {
        "title": "evacuationgoto",
        "content": "evacuationgotoAuthor : Patrick TaillandierA 3D model with walls and exit, and people agents trying to evacuate from the area to a exit location, avoiding the walls with a discretized space by a gridCode of the model :model evacuationgotoglobal {\t//Shapefile of the walls\tfile wall_shapefile &lt;- shape_file(\"../includes/walls.shp\");\t//Shapefile of the exit\tfile exit_shapefile &lt;- shape_file(\"../includes/exit.shp\");\t//DImension of the grid agent\tint nb_cols &lt;- 50;\tint nb_rows &lt;- 50;\t\t//Shape of the world initialized as the bounding box around the walls\tgeometry shape &lt;- envelope(wall_shapefile);\t\tinit {\t\t//Creation of the wall and initialization of the cell is_wall attribute\t\tcreate wall from: wall_shapefile {\t\t\task cell overlapping self {\t\t\t\tis_wall &lt;- true;\t\t\t}\t\t}\t\t//Creation of the exit and initialization of the cell is_exit attribute\t\tcreate exit from: exit_shapefile {\t\t\task (cell overlapping self) where not each.is_wall{\t\t\t\tis_exit &lt;- true;\t\t\t}\t\t}\t\t//Creation of the people agent\t\tcreate people number: 50{\t\t\t//People agent are placed randomly among cells which aren't wall\t\t\tlocation &lt;- one_of(cell where not each.is_wall).location;\t\t\t//Target of the people agent is one of the possible exits\t\t\ttarget &lt;- one_of(cell where each.is_exit).location;\t\t}\t}}//Grid species to discretize spacegrid cell width: nb_cols height: nb_rows neighbors: 8 {\tbool is_wall &lt;- false;\tbool is_exit &lt;- false;\trgb color &lt;- #white;\t}//Species exit which represent the exitspecies exit {\taspect default {\t\tdraw shape color: #blue;\t}}//Species which represent the wallspecies wall {\taspect default {\t\tdraw shape color: #black depth: 10;\t}}//Species which represent the people moving from their location to an exit using the skill movingspecies people skills: [moving]{\t//Evacuation point\tpoint target;\trgb color &lt;- rnd_color(255);\t\t//Reflex to move the agent \treflex move {\t\t//Make the agent move only on cell without walls\t\tdo goto target: target speed: 1 on: (cell where not each.is_wall) recompute_path: false;\t\t//If the agent is close enough to the exit, it dies\t\tif (self distance_to target) &lt; 2.0 {\t\t\tdo die;\t\t}\t}\taspect default {\t\tdraw pyramid(2) color: color;\t\tdraw sphere(1) at: {location.x,location.y,2} color: color;\t}}experiment evacuationgoto type: gui {\toutput {\t\tdisplay map type: opengl{\t\t\timage \"../images/floor.jpg\";\t\t\tspecies wall refresh: false;\t\t\tspecies exit refresh: false;\t\t\tspecies people;\t\t\t\t\t}\t}}",
        "url":"/wiki/Evacuation-grid_goto.html"
      }
      ,
    
      "wiki-evacuation-grid-move-html": {
        "title": "grid_move",
        "content": "grid_move_Author : _A 3D model which show how to represent an evacuation system with obstacles, cohesion factor and velocity. The people are placed randomly and have to escape by going to a target point, within a discretized space by a grid. The agents don’t use the skill moving to move.Code of the model :model grid_moveglobal {\t//Shapefile of the buildings\tfile building_shapefile &lt;- file(\"../includes/building.shp\");\t//Shape of the world\tgeometry shape &lt;- envelope(building_shapefile);\t//Maximum memory of the agent to avoid loop of the agents\tint max_memory &lt;- 5;\t//Size of the people agents\tfloat people_size &lt;- 2.0;\t//Number of people agents\tint nb_people &lt;- 500;\t//Evacuation point for the people agents\tpoint target_point &lt;- {world.location.x, 0};\t\tinit {\t\t//Creation of the building agents using the shapefile\t\tcreate building from: building_shapefile\t\t{\t\t\t//Initialization of the cell is_obstacle attribute\t\t\task cell overlapping self {\t\t\t\tis_obstacle &lt;- true;\t\t\t\tcolor &lt;- #black;\t\t\t}\t\t}\t\tlist&lt;cell&gt; free_cell &lt;- cell where not (each.is_obstacle);\t\tcell the_target_cell &lt;- cell closest_to target_point;\t\t//Creation of the people agent\t\tcreate people number: nb_people {\t\t\t//People agent are placed randomly among the cells which haven't people or obstacle\t\t\tcurrent_cell &lt;- one_of(free_cell);\t\t\tcurrent_cell.is_free &lt;- false;\t\t\tremove current_cell from: free_cell;\t\t\tlocation &lt;- current_cell.location;\t\t\ttarget_cell &lt;- the_target_cell;\t\t\tmemory &lt;&lt; current_cell;\t\t\t\t\t}\t}}//Species which represent the buildingsspecies building {\tfloat height &lt;- 3.0 + rnd(5);\taspect default {\t\tdraw shape color: #gray depth: height;\t}}//Species which represent the people agent moving from one cell to its neighboursspecies people {\t//Current cell of the agent\tcell current_cell;\t//Evacuation cell of the agent\tcell target_cell;\t//List of the cells already passed by the agents and mesmorized\tlist&lt;cell&gt; memory;\t//Size of the agent\tfloat size &lt;- people_size;\trgb color &lt;- rgb(rnd(255),rnd(255),rnd(255));\t\t\t//Reflex to kill the agent once it is close enough to an evacuation point\treflex end when: location distance_to target_cell.location &lt;= 2 * people_size {\t\tcurrent_cell.is_free &lt;- true;\t\tdo die;\t}\t//Reflex to move the agent\treflex move {\t\t//List of all the cells possible (which aren't obstacles, without people on it and on which the agent hasn't already passed\t\tlist&lt;cell&gt; possible_cells &lt;- current_cell neighbors_at 1 where (not (each.is_obstacle) and each.is_free and not (each in memory));\t\t//If there is possible cell, the agent move on the closest one to the evacuation point\t\tif not empty(possible_cells) {\t\t\tcurrent_cell.is_free &lt;- true;\t\t\tcurrent_cell &lt;- shuffle(possible_cells) with_min_of (each.location distance_to target_cell.location);\t\t\tlocation &lt;- current_cell.location;\t\t\tcurrent_cell.is_free &lt;- false;\t\t\t//Management of the memory of the agents\t\t\tmemory &lt;&lt; current_cell; \t\t\tif (length(memory) &gt; max_memory) {\t\t\t\tremove memory[0] from: memory;\t\t\t}\t\t}\t}\t\taspect default {\t\tdraw pyramid(size) color: color;\t\tdraw sphere(size/3) at: {location.x,location.y,size} color: color;\t}}//Grid species to discretize spacegrid cell width: 150 height: 150  neighbors: 8 frequency: 0 {\tbool is_obstacle &lt;- false;\tbool is_free &lt;- true;\trgb color &lt;- #white;}experiment main type: gui {\tparameter \"nb people\" var: nb_people min: 1 max: 1000;\toutput {\t\tdisplay map type: opengl camera_pos: {world.location.x,-world.shape.height*1.5,70}                        camera_look_pos:{world.location.x,0,0}    {\t\t\timage '../images/soil.jpg';\t\t\tspecies building refresh: false;\t\t\tspecies people;\t\t\tgraphics \"exit\" refresh: false {\t\t\t\tdraw sphere(2 * people_size) at: target_point color: #green;\t\t\t\t}\t\t}\t}}",
        "url":"/wiki/Evacuation-grid_move.html"
      }
      ,
    
      "wiki-evacuation-html": {
        "title": "Evacuation",
        "content": "EvacuationThis sub-section is composed of the following models :      continuous_move        evacuationgoto        grid_move  ",
        "url":"/wiki/Evacuation.html"
      }
      ,
    
      "wiki-event-cc15-reorganization-html": {
        "title": "Introduction",
        "content": "IntroductionLe but est de proposer une réorganisation des plug-ins de GamaCf. page Google Doc: https://docs.google.com/document/d/1gd4nlJH8ns4_iKqiIdw3LSa__Sk9yUccX9TEbzr2PW0/edit?usp=sharing",
        "url":"/wiki/Event__CC15_Reorganization.html"
      }
      ,
    
      "wiki-event-cp12archi-html": {
        "title": "GAMA Architecture",
        "content": "GAMA Architecture",
        "url":"/wiki/Event__CP12Archi.html"
      }
      ,
    
      "wiki-event-cp12batch-html": {
        "title": "Batch Experiments",
        "content": "Batch ExperimentsBy the Batch PeoplePhilippe Caillou,Thomas Louail,Nicolas Marilleau,Huynh Quang Nghi,Serge Stinckwich,Patrick Taillandier,Jean-Daniel ZuckerWhat do we have?Define an experiment, batch mode (but same capabilities as GUI mode)·         Parameter exploration:  Param elemento   Explicito   List with step·         Method Elemento   Exhaustiveo   Hill climbingo   Simulated annealingo   Tabu Searcho   Reactive Tabu Searcho   Genetic Algorithm·         File exporto   FileHow does it work?·         The experiment (the plan) creates the simulation (future: Headless mode)What would be great in Gama 12.4?·         Export agent/simulation data in the fileo   =&gt;Define code in the experiment (loop over agents)·         Put rules for variable explorationo   Ex: explore b={1,2,3}. if a=2 explore b={2,3} onlyo   How? Put code in the exploring loop =&gt; put real GAML code in the agento   =&gt; reflex “method” or “explore”o   Some existing exploration actions can be used with a ParameterSet (Map?) parameter·         Show plots in batcho   Define output with the code/variable of the experiment agento   Require a getVariable() operator that gets the last simulation variables values·         Compare agent trajectorieso   Stats a posteriorio   (not possible inside a simulation because there is no end)o   =&gt; action « aftersimulation » défined by the usero   Require a getVariable() operator that gets the last simulation variables values (to be able to loop on agents)·         Define more parameters/variables in the file (CSV)o   =&gt; use of the Save already working·         Launch parallel simulation on multicore/clusterso   =&gt; special action “runSimulation” parameter to launch 4 in parallel?·         “Generate” agentso   Define agent parameters by using global/previous variables/fileso   Use of an “initSimulation” action before the “runSimulation” to  be able to change manually the simulation parameters·         Définition graphique de l’espace de valeur, éventuellement en 2D et disjointo   Specific OutPutThe SolutionDefine a new Experimenter agent and put real code/reflexes/actions… GAML code inside the Experimenter.One simple example of what would be great:experiment InteliExplore type: batch repeat: 2 keep_seed: true until: ( time &gt; 200 ) {      int nbprey init:0;      int nbpredator init:0;      init      {            //for example read experiment plan from file                 }           reflex method      {            loop prm over:prey_max            {                   do: createsimulation                   setParameter(\"nb_preys_init\",pr)                   do: initsimulation                   if (prey_max&lt;100)                   setParameter(\"nb_predators_init\",200)                   if (prey_max&gt;100)                   setParameter(\"nb_predators_init\",200)                   do: runsimulation;                   do: aftersimulation;                              }      }      action aftersimulation      {            loop over getVariable(agents)            {                   log(\"everything dans file\");      //with the save function?            }           }      chart name: 'Species evolution' type: series background: rgb('white') size: {1,0.4} position: {0, 0.05}      {      data initial_number_of_preys value: getValue(\"nb_preys_init\") color: rgb('blue') ;        data final_number_of_predator value: getValue(\"nb_predators\") color: rgb('red') ;      }    file name: 'logsimple' type: text data: 'simulation: '+ step                                  +'; allparams' + getAllParamters // PROBLEME comment sauver tous les parametres?                                   + '; nbPreys: ' + getValue(\"nb_preys_init\")                                    + '; finalPredators: ' + getValue(\"nb_preys\") ;}TODOAnd Alexis did almost all this in less than a day……. But how does he do that??      A new type of Custom Experiment        In this experiment block, an ExperimenterAgent manages the simulations        Init() may have to create a Simulation to get a Scheduler (?) and/or a World(?)        He must have a Scheduler to be able to stop/wait in a loop for the end of a Simulation (contradiction with previous point…)        Its most important function is to be able to call Simulation.step()  =&gt;Create a Simulation Type which has a Step() operator      Create a ExperimentatorSkill with a lot of usefull actions (Step(int), …)        Check that it is possible to define plots, logs, …  ",
        "url":"/wiki/Event__CP12Batch.html"
      }
      ,
    
      "wiki-event-cp12development-html": {
        "title": "GAMA Development",
        "content": "GAMA Development",
        "url":"/wiki/Event__CP12Development.html"
      }
      ,
    
      "wiki-event-cp12doc-html": {
        "title": "Online &amp; Local Documentation",
        "content": "Online &amp; Local Documentation",
        "url":"/wiki/Event__CP12Doc.html"
      }
      ,
    
      "wiki-event-cp12fipa-html": {
        "title": "FIPA-ACL Skill",
        "content": "FIPA-ACL Skill",
        "url":"/wiki/Event__CP12FIPA.html"
      }
      ,
    
      "wiki-event-cp12git-html": {
        "title": "Gama on Git",
        "content": "Gama on Githttp://eclipselabs.org/p/gamaDetails",
        "url":"/wiki/Event__CP12Git.html"
      }
      ,
    
      "wiki-event-cp12graph-html": {
        "title": "Graph operators and indicators",
        "content": "Graph operators and indicatorsgoalsload graphs from files generate graphs using generatorsoperators for graph manipulation (including stats) graphs displaydoneload graphs from fileFor parsing network files, we use the graphstream library which supports the top- 10 file formats. All these formats are supported by GAMA now.Till now, the GAML langage does not enables an easy way to create primitives that both take more than 3 args as an input and return an object. Thus loading a graph is defined as an action of a skill; one has to create an instance of agent with this skill for loading the network.global {  \tvar mongraphe type:graph;\tgraph_manager graph_util;\tinit { \t\tcreate graph_manager returns: graph_util;\t\task graph_util {\t\t\t\t\t\tset mongraphe value:load_graph_from_dgs_old(self, [edge_species::edgeSpecy, vertex_species::nodeSpecy,file::\"../includes/BarabasiGenerated.dgs\"]);\t\t\t\t}\t}  }graph manipulatorsThe structure for the manipulation of graphs is based on the existing GAMA graph type. As a consequence, novel algorithms, operators and visualizations will be usable for both spatial graphs (loading from GIS for instance, like roads) and more abstract graphs (not spatialized).Patrick did some interesting work for searching shortest pathes and so on.Novel operators should still be defined.graph visualizationFirst of all, we had to disturb many GAMA-gurus for undertanding how to create a novel View (that is, another tab in the simulation perspective) from GAML. A novel display is defined for displaying a network.output {\tgraphdisplay nameOfMyDisplay graph: mongraphe {\t \t}}This line indicates that we would like to display a graph defined in the variable “mongraphe”. This simple line will open the display.Roadmapprovide another (simpler !) syntax for loading networks visu:  implement prefuse instead of graphstream for the visualisation  map GAML aspects to the view of the networkimplement operators for graph manipulation add generators for simple graphs generation (with a simple syntax as well)",
        "url":"/wiki/Event__CP12Graph.html"
      }
      ,
    
      "wiki-event-cp12headless-html": {
        "title": "Headless operation",
        "content": "Headless operationBe able to launch a simulation without any interface.Basic example:$gama.jar test.gaml input.xml",
        "url":"/wiki/Event__CP12Headless.html"
      }
      ,
    
      "wiki-event-cp12ide-html": {
        "title": "Enhancement of the IDE",
        "content": "Enhancement of the IDE",
        "url":"/wiki/Event__CP12IDE.html"
      }
      ,
    
      "wiki-event-cp12library-html": {
        "title": "Library of models",
        "content": "Library of models",
        "url":"/wiki/Event__CP12Library.html"
      }
      ,
    
      "wiki-event-cp12multiscale-html": {
        "title": "Improvement of the Multi-scale framework",
        "content": "Improvement of the Multi-scale framework",
        "url":"/wiki/Event__CP12MultiScale.html"
      }
      ,
    
      "wiki-event-cp12opengl-html": {
        "title": "OpenGL Display",
        "content": "OpenGL DisplayIntegrate OpenGL (jogl) view in Gama.Have a display using OpenGL (Jogl: http://jogamp.org/jogl/www/) libraries implement as a gama plug-ins.plugin name: ` msi.gama.jogl`msi.gama.jogl will depend on msi.gama.application and msi.gama.coreCurrent work:  A new output symbol has been defined in order to call a new display in gamlDefinition of the symbol in msi.gama.core/src/msi/gama/opengl/GLOutput.java@symbol(name = IKeyword.DISPLAY_GL, kind = ISymbolKind.OUTPUT)@facets(value = {\t//@facet(name = IKeyword.DISPLAY_GRAPH, type = IType.STRING_STR, optional = false),\t@facet(name = IKeyword.NAME, type = IType.STRING_STR, optional = true)\t}, omissible = IKeyword.NAME)@with_sequence@inside(symbols = IKeyword.OUTPUT)Use of the symbol in msi.gama.models/models/graph/model/testSIG.gaml :output {\tgraphdisplaygl {\t\t\t}  A new view in msi.gama.jogl plugin.xml    &lt;extension          point=\"org.eclipse.ui.views\"&gt;           &lt;view allowMultiple=\"true\"            category=\"msi.gama.gui.category.gama\"            class=\"msi.gama.jogl.GLView\"            icon=\"icons/view_console.png\"            id=\"msi.gama.jogl.GLView\"            name=\"GL\"            restorable=\"true\"&gt;          &lt;/view&gt;    &lt;/extension&gt;This view is implemented in /Users/macbookpro/Projects/GamaDev/msi.gama.jogl/src/msi/gama/jogl/GLView.javaThe view ID must also be defined src/msi/gama/common/util/GuiUtils.javapublic static final String GL_VIEW_ID = \"msi.gama.jogl.GLView\";",
        "url":"/wiki/Event__CP12OpenGL.html"
      }
      ,
    
      "wiki-event-cp12sld-html": {
        "title": "SLD-based aspects",
        "content": "SLD-based aspectsNot chosen as a work theme for the coding camp…",
        "url":"/wiki/Event__CP12SLD.html"
      }
      ,
    
      "wiki-event-cp12stats-html": {
        "title": "Statistical Tools in GAMA",
        "content": "Statistical Tools in GAMA",
        "url":"/wiki/Event__CP12Stats.html"
      }
      ,
    
      "wiki-event-cp12test-html": {
        "title": "Test Models &amp; Language",
        "content": "Test Models &amp; Language      A Coding Dojo (5 people) was organized in order to sensibilize developpers about unit tests.The produced code is available here: https://github.com/SergeStinckwich/TennisKataTamCocThe usual retrospective done after a Dojo is here: https://github.com/SergeStinckwich/TennisKataTamCoc/tree/master/README        Some very simple models has been done in the “multi-scale” group with An. At that occasion, we didn’t define real tests, but the idea was the same: define models as simple as possible that illustrate some basic concepts. The same work should be done for all aspects (skills, operators, actions, GAML architecture, …).        Difficult and boring to introduce tests in the GAMA platform at the moment. It is easier to introduce tests in ongoing developments. For example, Serge and Samuel do some unit tests for the new GraphSkill based on GraphStream.  ",
        "url":"/wiki/Event__CP12Test.html"
      }
      ,
    
      "wiki-event-cp12water-html": {
        "title": "Water-management tutorial",
        "content": "Water-management tutorialWe did not work on this theme, but we made some decisions :  Plenary talk 1h10 : 1h : introduction to agent-based modeling; 20 minutes : MAELIA  a meeting will be organized just after the WAT-GAME training (the 26th of April at Toulouse).Deadlines :  30 march: Biographies  13 april: short synopsis of the plenary talk (5 to 10 lines)  13 april: short synopsis of the workshop (5 to 10 lines)  25 may: final synopsis of the plenary talk  25 may: presentation (ppt) of the plenary talk  25 may (if translated) (optional) : paper concerning the plenary talk (max 10 pages, text longer in English - not translated into vietnamese)  25 may (if translated) (optional) : paper concerning the workshop (max 10 pages, text longer in English - not translated into vietnamese)  8 june: final synopsis of the workshop  8 june: presentation (ppt) of the workshop",
        "url":"/wiki/Event__CP12Water.html"
      }
      ,
    
      "wiki-event-cp12traffic-html": {
        "title": "Traffic simulation and Physics constraints operators",
        "content": "Traffic simulation and Physics constraints operatorsTraffic simulationA first task that we done was to define a new plug-in in order to take into account the fact that a road has a limited number of lanes.We propose a plug-in that contains the driving plug-in. This plug-in extends the moving skill. In particular, it proposes a new primitive “gotoTraffic” that integrates a collision avoiding algorithm.2 models (in “models/experimental models”) were proposed to illustrate the use of our plug-in.DrivingSkill.java implements a new skill in package msi.gaml.extensions.traffic@skill(\"driving\")public class DrivingSkill extends MovingSkill{...}New model in msi.gama.models/experimental_models/trafficPhysics constraints operatorsA second plugin is under development concerning physic computation. In particular, it allows to handle collisions between two convex polygons. A first toy model concerning pool game was developed.Library used: http://www.jbox2d.org/src/msi/gaml/extensions/physics/PhysicsSkill.java implements a new skill in package msi.gaml.extensions.physics@skill(\"physical\")public class PhysicsSkill extends Skill{        @setter(\"physical_world\")        public void setWorldAgent(final IAgent _agent, final IAgent _world){                if(_world == null)                        return;                                        PhysicalWorldAgent pwa = (PhysicalWorldAgent)_world;                pwa.registerAgent(_agent);        }",
        "url":"/wiki/Event__CP12traffic.html"
      }
      ,
    
      "wiki-event-codingcamp2012-html": {
        "title": "Coding Activities Summary",
        "content": "March 19-24th 2012Coding Activities Summary            Physics constraints operators      Water-management tutorial      Test Models &amp; Language                  Library of models      FIPA-ACL Skill      Git repository              SLD-based aspects      Headless operation      Batch Experiments              OpenGL Display      Enhancement of the IDE      GAMA Architecture              Improvement of the Multi-scale framework      GAMA Development      Online &amp; Local Documentation              Statistical Tools in GAMA      Graph operators and indicators             and some “working” images…",
        "url":"/wiki/Event__CodingCamp2012.html"
      }
      ,
    
      "wiki-event-codingcampfall2012-html": {
        "title": "Introduction",
        "content": "IntroductionThe Fall GAMA Coding Camp 2012 will take place from the 17th to the 19th of November in the hotel called “Hon Trem Resort &amp; Spa “. You can find more information about it here : http://www.hontremresort-spa.com.Departure will take place from Ninh Kieu 3 hotel in Can Tho at 3:30 PM, Friday the 16th of November, and we expect to arrive in Hon Trem resort at around 9:00 PM (dinner will be taken on the road).A summary of the Spring GAMA Coding Camp 2012 can be found here.WorkThe use of the last version of GAMA will be necessary, the development version should thus be installed. See the documentation for the Installation procedure.Some ideas of tasks that could be investigated during the camp (feel free to add anything you think about)COUPLING GAMA WITH OTHER TOOLS  Coupling GAMA with hydrodynamics simulators (for water flows, etc.)          Participants: Thanh, Tuu, Benoit, Nghi, Quang, M.Thai        Integration of EDP solver into GAMA          Participants: Benoit      Plug-in needed: maps.gama.extensions        Calling statistical libraries of R in GAMA: Basic statistics, geostatistics (maptools, gstat), Gaussian process (tgp, gptk)          Participants: M.Thai, Viet        Integration of SimAnalyzer          Participants: Philippe, Javier        Improving SQL features in GAMA          Participants: M.Thai        Improving the physics engine          Participants: Javier, Philippe, Arnaud, Patrick      Plug-in needed: simtools.gaml.extensions.physics        IMPROVEMENTS / ENHANCEMENTS              Improving and simplifying the syntax of GAML          Participants: Nicolas, Alexis, Nghi        Documenting and enhancing the command line version          Participants: Nicolas, Nghi      Plug-in needed: msi.gama.headless        Improving the user interaction possibilities          Participants: Nghi, Nicolas, Arnaud        Torus environment (at least, grid)          Participants: Patrick, Viet        Enhancement of the IDE          Participants: Nghi (implement first-step of GUI-GAML)        Communication Skill          Participants: Benoit, An, Philippe      Plugin-needed: msi.gaml.extensions.fipa        Update of the Trust Skill to Gama 1.5          Participants: Quang Anh        Multicore runner in Headless Mode to Gama 1.5          Participants: Nicolas, Nhan, Nghi        Driving skill in 2D (skill: driving2d)          Participants: Minh        BUG FIXES              Eliminating bugs found in the 1.5 version          Participants: Benoit, Patrick (for spatial/geometry related bugs). Arnaud for Opengl bug        MODELS              Adding 3D to the models          Participants: Arnaud, Patrick, Nghi        OTHER              Documentation          Participants: (Benoit)      Plug-in needed: msi.gama.documentation      Requirements: Python (CPython) and PyDev Eclipse plugin: see this page for details about the installation      ",
        "url":"/wiki/Event__CodingCampFall2012.html"
      }
      ,
    
      "wiki-event-codingcampfall2012-bug-html": {
        "title": "Eliminating bugs found in the 1.5 version",
        "content": "Eliminating bugs found in the 1.5 version  Arnaud: Opengl is now working with Java2D (possibility to define n opengl display and n java2D display in the same output)http://code.google.com/p/gama-platform/issues/detail?id=190no more seg fault when running a simulation with opengl while the update is done on the all modelhttp://code.google.com/p/gama-platform/issues/detail?id=233  Communication Skills http://code.google.com/p/gama-platform/issues/detail?id=271",
        "url":"/wiki/Event__CodingCampFall2012_bug.html"
      }
      ,
    
      "wiki-event-codingcampfall2012-coupling-html": {
        "title": "Coupling GAMA with hydrodynamics simulators",
        "content": "Coupling GAMA with hydrodynamics simulatorsIntegration of EDP solver into GAMAThe maps.gaml.extensions has been extended in order to allow modeler to write its own equation systems (as simple strings), specify parameters with their values and variables and “solve”/integrate them either step by step or N steps by N steps.An example has been implemented on the Lokta-Voltera equation system.Possible extension:  parse the equations to detect errors  rename the skill has EDO, because we consider only variables depending on time  extends to solve EDP  add some methods/algorithms in order to “resolve” the system, in a sense of finding some equilibria (asymptots or oscillation equilibrium…)R in GAMAResults: Verifying the old operators (A simple example “CallingR” is uploaded in the model list); Applying these statistical operators on the data loaded from RDBMS.SQL features in GAMAResults:  1.Added PostgresSQL driver into SQSKILL and AgentDB.  2.Wrote example models for testing.  Now,GAMA supported query features for MySQL, MSSQL, PostgresSQL and SQLite.Physics engineIntegration of a 3D Physics Engine Library (http://jbullet.advel.cz/) in simtools.gaml.extensions.physicsThis has been implemented as a new skill.species myPhysicsAgent skills: [physical3D]More details: 3D Physics Engine",
        "url":"/wiki/Event__CodingCampFall2012_coupling.html"
      }
      ,
    
      "wiki-event-codingcampfall2012-improvements-html": {
        "title": "Possibility to directly create agents from a CSV file",
        "content": "Improvements and EnhancementsPossibility to directly create agents from a CSV fileThe create statement has been extended in order to let the possibility to create agents of specified species directly from a CSV file.An agent is created by line of the CSV file. It is also possible to read the different column of the file using the read operator: read (column_index) (start at 0)read(1)For example:create people from: \"data_file.csv\" with: [speed::read(0), age:: read(1)];It is also possible to specify that the CSV file has a header that can give the name of the different column using the header facet (boolean). It this case, it is possible to directly use this name to read the column value: read(“attribute1”).For example:create people from: \"data_file.csv\" with: [speed::read(\"SPEED\"), age:: read(\"AGE\")] header: true;Improving and simplifying the syntax of GAMLNew features:  Possibility to define 3D points with the {x,y,z} syntax:    let pt type: point &lt;- {2, 5, 3};        Documenting and enhancing the command line version  #summary One-sentence summary of this page.The aim of this feature is to run models and experiments on a grid or a cluster without GUI and to take advantages of High Performance Computing. It promises efficient running by accelerating each simulation and experiment plan computing. The GUI is not loaded and managed. Several simulations could be run in parallel, at same time.There is two ways to run a GAMA experiment in headless mode: using command-line launcher or Java command line. These commands take 2 arguments: an experiment file and an output directory.For the command-line : sh gamaHeadless.sh $1 $2  with:          $1 input parameter file : an xml file determining experiment parameters and attended outputs      $2 output directory path : a directory which contains simulation results (numerical data and simulation snapshot)      go to headless documentationTorus environmentIt is now possible to use toroidal environment for grid and continuous environments (even with complex GIS geometries).  The only thing to do is to use the torus facet.For a grid:grid cell width: 5 height: 5 neighbours: 8 torus: true For the continuous environment:environment bounds: {50,50} torus: true;Be careful concerning toroidal continuous environment: the computation required by these environment is high, thus they should be used only when they are really necessary.A demonstration of a continuous toroidal environment is given in the experimental model: testTorus-&gt; continuous_torus.Communication SkillPlugin-needed: msi.gaml.extensions.fipaThe communicating skill now re-works on GAMA 1.5. Sample toy models are found in “models/fipa”.Update of the Trust Skill to Gama 1.5Hexgonal geometry and gridIt is now possible to create a hexagon of with the given width and height (point) thanks to the operator hexagon({width, height})hexagon({3,4})In the same way, an operator has been defined in order to decomposed a geometry into a set of hexagons of a given a number of columns and rows. This operator returns a set of hexagons: geometry as_hexagonal_grid({nb_cols, nb_rows})shape as_hexagonal_grid({50, 40})At last, it is now possible to define a hexagonal grid. To do so, the neighbors should is set to 6. It is possible to use torus environment with hexagonal grid.grid cell width: 20 height: 20 neighbours: 6 torus: true;Using HSB colorAdd HSB color to be able to iterate through colors and use it to represent qualitative data.Example:The association of the orientation of agents is enhanced by mapping the orientation of the agent to a hue.color hsb_to_rgb ([heading/360,1.0,1.0]);In the following example boids are represented by a triangle with the colors depending on their heading. Multicore runner in Headless ModeResults: distribution of command-line version on multicore machine, integration with GAMA interface, visualisation of outputs.Defining interaction in a modelOne statement have been added to facilitate the proposal of serious game on which user could interact through a map. It is now possible to catch event done on 2D display in order to do an action and to modify clicked agent attributes.Attributes  name (omissible) ` [mouse_down , mouse_up] `  action name of the action to be runDefinitionAllows to interact with the simulation by capturing mouse event and do an action. This action could apply a change on environment or on agents, according to the goal.Events are determine for a display. Thus, they can be play a different behaviorevent [event_type] action: myAction  event_type (mouse_down or mouse_up  myAction is an action written in the global block. This action have to follow the specification below. global {   ...   action myAction    {     arg location type: point; // contains le location of the click in the environment     arg selected_agents type: list; // contains agents clicked by the event        ... //code written by the authors ...   }  } experiment Simple type:gui {\tparameter 'Evaporation Rate:' var: evaporation_rate;\tparameter 'Diffusion Rate:' var: diffusion_rate;\toutput { \t\tdisplay Ants refresh_every: 2 { \t\t\tgrid ant_grid;\t\t\tspecies ant aspect: default;\t\t\ttext tt value: string ( food_remaining ) size: 24.0 position: { 20 , 20 } color: rgb ( 'white' );\t\t\tevent mouse_up action: myAction;\t\t}  ...Driving skill in 2D (skill: driving2d)A skill (inherited from moving skill) permits agent to move to the target and avoid the others.Attributes  heading initial heading of agent  obstacle_species list of species to avoid  background_species list of species on which agent moveActionThe action inherits the “goto” action of moving skill.do vehicle_goto target: target on: the_graph speed: speed target_type: true returns: moving_status;  target the goal (in type of location) for agent to go  speed maximum of moving distance for each step  on the topology on which agent moves. By default, the topology is the graph and agent uses the shortest path algorithm to move  target_type if “true”, agent goes to the exact location of the target. Otherwise (in the case of false target), agent go to an point on the topology that is nearest to the target.  returns the action returns an integer with the meaning: -1: failed to move; 0: success to move closer and closer to the target; 1: arrive the false target; 2: arrive the target reflex move_with_vehicle_goto when: target != nil{\t\t\tlet moving_status type: int &lt;- -1;\t\t\tdo vehicle_goto target: target on: the_graph speed: speed target_type: true returns: moving_status;\t\t\tif (int(moving_status) &gt; 0){\t\t\t\tlet temp_targets &lt;- list(targetpoint) - target;\t\t\t\tset target &lt;- one_of(temp_targets);\t\t\t}\t\t\t\t\t}",
        "url":"/wiki/Event__CodingCampFall2012_improvements.html"
      }
      ,
    
      "wiki-event-codingcampfall2012-models-html": {
        "title": "3D River morphology display",
        "content": "3D River morphology displayDisplay the channel bed of a river in 3D from synthetic data and can be applied directly to real data.Models using the 3D Physics EngineIntegration of a 3D Physics Engine Library (http://jbullet.advel.cz/) in simtools.gaml.extensions.physicsThis has been implemented as a new skill.species myPhysicsAgent skills: [physical3D]Some toy model has been added inmsi.gama.models/models/3D/3D_Engine**hello_World_falling  Ball falling (due to the gravity) on a floor.**pool3D.gaml",
        "url":"/wiki/Event__CodingCampFall2012_models.html"
      }
      ,
    
      "wiki-event-events-html": {
        "title": "Coding Camps",
        "content": "Coding CampsList of GAMA Coding Camps :  Coding Camp March 2012  Fall Coding Camp 2012  Programme doctoral internationale 2012",
        "url":"/wiki/Event__Events.html"
      }
      ,
    
      "wiki-event-mimscop2012-html": {
        "title": "Introduction",
        "content": "IntroductionThe MIMSCOP Summer school 2012 (Modélisation Informatique et Mathématique des Systèmes Complexes de Pêcherie took place from the 16th to the 21th of July in the AIMS-IRD Campus at Mbour (Senegal).Developed models  Baye Cheikh MBAYE and Fatou Nene DIOP Modélisation de l’impat de l’environnement sur la migration de sardinella aurita le long de la côte sénégalo-mauritanienne : outil de suivi et de prévision du stock pour la pêche (Slidehow)  Macire Thieba TOURE and ￼Harouna DIOUF Impact de la gestion sur la biomasse de la thonine pêchée au Sénégal (Slideshow)  Mansour NDOUR and Thierno DIOP Modélisation Impacts des AMP sur la biomasse et les captures en fonction du site et du mode de gestion (Slideshow)  Sidy DIOP and Papa Baba FALL L’impact de la pollution sur les espèces halieutiques (slideshow)  Sana KEITA and  Serigne Mbacke GUEYE Comparaison de la pêche sélective et non sélective sur la petite côte (Slideshow  Siny NDOYE and Erick FARGEAS  Une alternative à la baisse de la biomasse : « l’aquaculture, solution de développement durable » (Slideshow)  Abdoulaye THIAM and Mouhamadou Baidy DIA Evolution de poissons dans les AMP et dans l’aquaculture (Slideshow)Trainers  Auger Pierre - UMMISCO, IRD-UCAD  Bah Alassane - UMMISCO, ESP, UCAD  Diouf Niokhor - IUPA, UCAD  Guy Gohier - CRAMS  Marilleau Nicolas - UMMISCO, IRD-UPMC  Ndiaye\t Samba - UMMISCO, FST, UCAD  Seck Diaraf - UMMISCO, FAESG, UCADLearners  Badji Insa - AIMS  Dia Mouhamadou Baidy - AIMS  Diop Sidy -  AIMS  Diop Thierno - \tAIMS  Diouf Harouna - IUPA, UCAD  Fall Papa Baba - LTI, FST, UCAD  Fargeas Eric - LTI, FST, UCAD  Gueye Serigne Mbacké - LID, FST, UCAD  Keita Sana - AIMS  Ly Sidy - LGA, FST, UCAD  Mansal Fulgurence - LGA, FST, UCAD  Mbaye Baye Cheikh - LPAO-SF, ESP, UCAD  Ndour Mansour - IUPA, UCAD  Ndoye Siny - LPAO-SF, ESP, UCAD  Thiam Abdoulaye - AIMS  Touré Macire Thieba - AIMSThe participants",
        "url":"/wiki/Event__MIMSCOP2012.html"
      }
      ,
    
      "wiki-event-pdi2012-html": {
        "title": "Introduction",
        "content": "IntroductionDuring the PDI2012 nearly 50 PhD students were working together on different topic related to complex system modeling.At the end of the formation, each student (by groups of 2 or 3) had to present a model in a mini-projet. The purpose of this mii-project was to use a platform and to create a model related to their respective research topics. Here is an overview of the model that has been implemented with Gama. Some of those projects has been presenting in COMMISCO 2012ProjectsFirst year (promo2012)Siny  Ndoye - Quang Truong Chi Modelisation of the land use applied to the commune of My An-Ben Tre in the Delta Mekong.Since 1999, Vietnam has transformed 380 000 ha of rice agriculture into aquaculture. It has different impact like the fall of the rice agriculture, forest destruction and demographic increase near aqua farm. The shrimp culture is responsible of the destruction of the mangrove swamp since the 90’s. The aim of this model was to study the impact of a government aid for rice producer on this problem.Cedrigue Djiongo - Abdelkarim Ed-Darraz Modelisation of the different  land use in the forest.The model study the dynamic of forest parcel over the time according to the activity of nomad paysans. The parcel can have different state such as primary forest, chromolaena forest, bush fallow, forest crop field or secondary forest).Souleymane Sy - Nghi Huynh Quang Impact of the dynamic of the vegetation of the rain in west africaWest africa is one of the part of the world that faced the most climate variability during the second half of the 20th century. To understand the origin on the variability on the amount of rain Gama is used to study the impact of the vegetation dynamic on the rain using a retroactivity between vegetation and atmosphereHédia Zardi - Tran Thi Cam Giang Modelisation of the SEIR model by GAMAUntil today, many infectious diseases in the world such as measles, tuberculosis, dengue … still exist. These diseases are one of the main causes of infant mortality in most countries of Asis, Africa, etc.Therefore, we want to present these infectious diseases in the computer models, after we want to find the periods of diseases to provide positive solutions that allow us to turn them off.Second year (promo2011)Ahmed Tidjane Cisse - Arnaud Grignard Vector disease modélisation- Multi point of view approach and visualization.Propose a meta-model applied to vector disease. Gama has been used to study the rift valley fever disease according to a meta-model previously defined. The idea is to define basic or macro behavior for host, environment and  infectious agent on which a vector is moving and then to implement those meta-agent for a specific vector disease (in this case the rift valey fever).Third year (promo2010)Moussa Gueye - Inès Hassoumi - Zineb Belarbi Impact of the dispersion of air pollutants: applied to the city of TunisThis project study the impact of pollutants on the environment on the health. The goal is to identify where new urban zone can be created by taking in account the concentration of each pollutants in the city. The main interest of the model is the coupling of the data coming from numerical equation of the advection-diffusion process using finite element method and then include those results on a grid created in Gama on which the value of each pollutants is extrapolated.",
        "url":"/wiki/Event__PDI2012.html"
      }
      ,
    
      "wiki-event-traininsessionpdi2011-html": {
        "title": "&lt;font color='blue'&gt;Context&lt;/font&gt;",
        "content": "ContextTraining session on GAMA 1.4 at IRD Bondy (France) the 5th of December, 2011.List of presentationsHere, the list of the different presentations (in French) given during the training session:  Introduction to GAMA  GAMA and GIS  Multi-scale ModelingModelsthe models used during the training session are all provided with the last version of GAMA (1.4)",
        "url":"/wiki/Event__TraininSessionPDI2011.html"
      }
      ,
    
      "wiki-event-trainingsessionhanoi2009-html": {
        "title": "&lt;font color='blue'&gt;Context&lt;/font&gt;",
        "content": "ContextTraining session on agent-based modeling and a tutorial on GAMA 1.1 organized at the IFI from the 26th to the 28th of October, 2009List of presentationsHere the list of the different presentations given during the training session:  Introduction to Agent Based Modeling  An introduction to GAMA  Tutorial: Forest fires  Tutorial: Segregation  GIS in GAMA: part1  GIS in GAMA: part2  Exploring Models",
        "url":"/wiki/Event__TrainingSessionHanoi2009.html"
      }
      ,
    
      "wiki-events-html": {
        "title": "References",
        "content": "ReferencesThis page references the events that are linked to GAMA.If you happen to participate to an event linked to GAMA, please let us know, so that we can include it in this list.Events linked to GAMAList of GAMA Coding Camps :  Coding Camp March 2014 (photos)  Coding Camp March 2012  Fall Coding Camp 2012  Programme doctoral internationale 2012",
        "url":"/wiki/Events.html"
      }
      ,
    
      "wiki-experimentbuiltin-html": {
        "title": "The 'experiment' built-in species (Under Construction)",
        "content": "The ‘experiment’ built-in species (Under Construction)As described in the presentation of GAML, any experiment attached to a model is a species (introduced by the keyword experiment which directly or indirectly inherits from an abstract species called experiment itself. This abstract species (sub-species of agent) defines several attributes and actions that can then be used in any experiment.experiment attributesexperiment defines several attributes, which, in addition to the attributes inherited from agent, form the minimal set of knowledge any experiment will have access to.experiment actions",
        "url":"/wiki/ExperimentBuiltIn.html"
      }
      ,
    
      "wiki-experimentsuserinterface-html": {
        "title": "Experiments User Interface",
        "content": "Experiments User InterfaceAs soon as an experiment is launched, the modeler is facing a new environment (with different menus and views) called the Simulation Perspective). The Navigator is still opened in this perspective, though, and it is still possible to edit models in it, but it is considered as good practice to use each perspective for what is has been designed for. Switching perspectives is easy. The small button in the top-left corner of the window allows to switch back and forth the two perspectives.The actual contents of the simulation perspective will depend on the experiment being run and the outputs it defines. The next sections will present the most common ones (inspectors, monitors and displays), as well as the views that are not defined in outputs, like the Parameters or Errors view. An overview of the menus and commands specific to the simulation perspective is also available.",
        "url":"/wiki/ExperimentsUserInterface.html"
      }
      ,
    
      "wiki-explorationmethods-html": {
        "title": "Exploration Methods",
        "content": "Exploration MethodsSeveral batch methods are currently available. Each is described below.Table of contents  The method element  Exhaustive exploration of the parameter space  Hill Climbing  Simulated Annealing  Tabu Search  Reactive Tabu Search  Genetic AlgorithmThe method elementThe optional method element controls the algorithm which drives the batch.If this element is omitted, the batch will run in a classical way, changing one parameter value at each step until all the possible combinations of parameter values have been covered. See the Exhaustive exploration of the parameter space for more details.When used, this element must contain at least a name attribute to specify the algorithm to use. It has theses facets:  minimize or a maximize (mandatory for optimization method): a attribute defining the expression to be optimized.  aggregation (optional): possible values (“min”, “max”). Each combination of parameter values is tested repeat times. The aggregated fitness of one combination is by default the average of fitness values obtained with those repetitions. This facet can be used to tune this aggregation function and to choose to compute the aggregated fitness value as the minimum or the maximum of the obtained fitness values.  other parameters linked to exploration method (optional) : see below for a description of these parameters.Exemples of use of the method elements:method exhaustive minimize: nb_infected ;method genetic pop_dim: 3 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 5  minimize: nb_infected aggregation: \"max\";Exhaustive exploration of the parameter spaceParameter definitions accepted: List with step and Explicit List.Parameter type accepted: all.This is the standard batch method. The exhaustive mode is defined by default when there is no method element present in the batch section. It explores all the combination of parameter values in a sequential way.Example (models/ants/batch/ant_exhaustive_batch.xml):experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time &gt; 400 ) {\tparameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)';\tparameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;}The order of the simulations depends on the order of the param. In our example, the first combinations will be the followings:  evaporation_rate = 0.1, diffusion_rate = 0.1, (2 times)  evaporation_rate = 0.1, diffusion_rate = 0.4, (2 times)  evaporation_rate = 0.1, diffusion_rate = 0.7, (2 times)  evaporation_rate = 0.1, diffusion_rate = 1.0, (2 times)  evaporation_rate = 0.2, diffusion_rate = 0.1, (2 times)  …Note: this method can also be used for optimization by adding an method element with maximize or a minimize attribute:experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time &gt; 400 ) {\tparameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)';\tparameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;\tmethod exhaustive maximize: food_gathered;}Hill ClimbingName: hill_climbingParameter definitions accepted: List with step and Explicit List.Parameter type accepted: all.This algorithm is an implementation of the Hill Climbing algorithm. See the wikipedia article.Algorithm: Initialization of an initial solution s  iter = 0 While iter &lt;= iter_max, do:   Choice of the solution s' in the neighborhood of s that maximize the fitness function   If f(s') &gt; f(s)     s = s'   Else     end of the search process   EndIf   iter = iter + 1 EndWhileMethod parameters:  iter_max: number of iterationsExample (models/ants/batch/ant_hill_climbing_batch.xml):experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time &gt; 400 ) {\tparameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)';\tparameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;\tmethod hill_climbing iter_max: 50 maximize : food_gathered;}Simulated AnnealingName: annealingParameter definitions accepted: List with step and Explicit List.Parameter type accepted: all.This algorithm is an implementation of the Simulated Annealing algorithm. See the wikipedia article.Algorithm: Initialization of an initial solution s  temp = temp_init While temp &gt; temp_end, do:   iter = 0   While iter &lt; nb_iter_cst_temp, do:     Random choice of a solution s2 in the neighborhood of s       df = f(s2)-f(s)     If df &gt; 0        s = s2     Else,       rand = random number between 0 and 1       If rand &lt; exp(df/T)         s = s2       EndIf     EndIf     iter = iter + 1   EndWhile   temp = temp * nb_iter_cst_temp EndWhileMethod parameters:  temp_init: Initial temperature  temp_end: Final temperature  temp_decrease: Temperature decrease coefficient  nb_iter_cst_temp: Number of iterations per level of temperatureExample (models/ants/batch/ant_simulated_annealing_batch.xml):experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time &gt; 400 ) {\tparameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)';\tparameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;\tmethod annealing temp_init: 100  temp_end: 1 temp_decrease: 0.5 nb_iter_cst_temp: 5 maximize: food_gathered;}Tabu SearchName: tabuParameter definitions accepted: List with step and Explicit List.Parameter type accepted: all.This algorithm is an implementation of the Tabu Search algorithm. See the wikipedia article.Algorithm: Initialization of an initial solution s  tabuList = {} iter = 0 While iter &lt;= iter_max, do:   Choice of the solution s2 in the neighborhood of s such that:     s2 is not in tabuList     the fitness function is maximal for s2   s = s2   If size of tabuList = tabu_list_size     removing of the oldest solution in tabuList    EndIf   tabuList = tabuList + s   iter = iter + 1 EndWhileMethod parameters:  iter_max: number of iterations  tabu_list_size: size of the tabu listexperiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time &gt; 400 ) {\tparameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)';\tparameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;\tmethod tabu iter_max: 50 tabu_list_size: 5 maximize: food_gathered;}Reactive Tabu SearchName: reactive_tabuParameter definitions accepted: List with step and Explicit List.Parameter type accepted: all.This algorithm is a simple implementation of the Reactive Tabu Search algorithm ((Battiti et al., 1993)). This Reactive Tabu Search is an enhance version of the Tabu search. It adds two new elements to the classic Tabu Search. The first one concerns the size of the tabu list: in the Reactive Tabu Search, this one is not constant anymore but it dynamically evolves according to the context. Thus, when the exploration process visits too often the same solutions, the tabu list is extended in order to favor the diversification of the search process. On the other hand, when the process has not visited an already known solution for a high number of iterations, the tabu list is shortened in order to favor the intensification of the search process. The second new element concerns the adding of cycle detection capacities. Thus, when a cycle is detected, the process applies random movements in order to break the cycle.Method parameters:  iter_max: number of iterations  tabu_list_size_init: initial size of the tabu list  tabu_list_size_min: minimal size of the tabu list  tabu_list_size_max: maximal size of the tabu list  nb_tests_wthout_col_max: number of movements without collision before shortening the tabu list  cycle_size_min: minimal size of the considered cycles  cycle_size_max: maximal size of the considered cyclesexperiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time &gt; 400 ) {\tparameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)';\tparameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;\tmethod reactive_tabu iter_max: 50 tabu_list_size_init: 5 tabu_list_size_min: 2 tabu_list_size_max: 10 nb_tests_wthout_col_max: 20 cycle_size_min: 2 cycle_size_max: 20 maximize: food_gathered;}Genetic AlgorithmName: geneticParameter definitions accepted: List with step and Explicit List.Parameter type accepted: all.This is a simple implementation of Genetic Algorithms (GA). See the wikipedia article. The principle of GA is to search an optimal solution by applying evolution operators on an initial population of solutions There are three types of evolution operators:  Crossover: Two solutions are combined in order to produce new solutions  Mutation: a solution is modified  Selection: only a part of the population is kept. Different techniques can be applied for this selection. Most of them are based on the solution quality (fitness).Representation of the solutions:  Individual solution: {Param1 = val1; Param2 = val2; …}  Gene: Parami = valiInitial population building: the system builds nb_prelim_gen random initial populations composed of pop_dim individual solutions. Then, the best pop_dim solutions are selected to be part of the initial population.Selection operator: roulette-wheel selection: the probability to choose a solution is equals to: fitness(solution)/ Sum of the population fitness. A solution can be selected several times. Ex: population composed of 3 solutions with fitness (that we want to maximize) 1, 4 and 5. Their probability to be chosen is equals to 0.1, 0.4 and 0.5.Mutation operator: The value of one parameter is modified. Ex: The solution {Param1 = 3; Param2 = 2} can mute to {Param1 = 3; Param2 = 4}Crossover operator: A cut point is randomly selected and two new solutions are built by taking the half of each parent solution. Ex: let {Param1 = 4; Param2 = 1} and {Param1 = 2; Param2 = 3} be two solutions. The crossover operator builds two new solutions: {Param1 = 2; Param2 = 1} and {Param1 = 4; Param2 = 3}.Method parameters:  pop_dim: size of the population (number of individual solutions)  crossover_prob: crossover probability between two individual solutions  mutation_prob: mutation probability for an individual solution  nb_prelim_gen: number of random populations used to build the initial population  max_gen: number of generationsexperiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time &gt; 400 ) {\tparameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)';\tparameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;\tmethod genetic maximize: food_gathered pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 20; }",
        "url":"/wiki/ExplorationMethods.html"
      }
      ,
    
      "wiki-exploringmodels-html": {
        "title": "Exploring Models",
        "content": "Exploring ModelsWe just learnt how to launch GUI Experiments from GAMA. A GUI Experiment will start with a particular set of input, compute several outputs, and will stop at the end (if asked).In order to explore models (by automatically running the Experiment using several configurations to analyze the outputs), a first approach is to run several simulations from the same experiment, considering each simulation as an agent. A second approach, much more efficient for larger explorations, is to run an other type of experiment : the Batch Experiment.We will start this part by learning how to run several simulations from the same experiment. Then, we will see how batch experiments work, and we will focus on how to use those batch experiments to explore models by using exploration methods.",
        "url":"/wiki/ExploringModels.html"
      }
      ,
    
      "wiki-expressions-html": {
        "title": "Expressions",
        "content": "ExpressionsExpressions in GAML are the value part of the statements’ facets. They represent or compute data that will be used as the value of the facet when the statement will be executed.An expression can be either a literal, a unit, a constant, a variable, an attribute or the application of one or several operators to compose a complex expression.",
        "url":"/wiki/Expressions.html"
      }
      ,
    
      "wiki-extension-html": {
        "title": "Extensions",
        "content": "ExtensionsThis file is automatically generated from java files. Do Not Edit It.IntroductionThis page provides a link to each of the extension pages. Extensions are the additional GAMA plugins that exist in the GAMA GitHub repository but will not be packaged with the release. These extensions are not maintained by GAMA core team but by their authors.  idees.gama.weka  ummisco.gaml.extensions.stats  miat.gama.extension.ifcfile  ummisco.gaml.extensions.sound  simtools.graphanalysis.fr  ummisco.gaml.extensions.rjava",
        "url":"/wiki/Extension.html"
      }
      ,
    
      "wiki-extension-cenres-gaml-extensions-hydro-html": {
        "title": "Extension",
        "content": "Extensioncenres.gaml.extensions.hydroTable of ContentsOperatorswater_area_for, water_level_for, water_polylines_for,StatementsSkillsArchitecturesSpeciesOperatorswater_area_forPossible use:  geometry water_area_for float —&gt;  float  water_area_for (geometry , float) —&gt;  floatSpecial cases:  if the left operand is a polyline and the right operand a float for the water y coordinate, returrns the area of the water (water flow area)Examples:waterarea &lt;- my_river_polyline water_area_for my_height_valuewater_level_forPossible use:  geometry water_level_for float —&gt;  float  water_level_for (geometry , float) —&gt;  floatSpecial cases:  if the left operand is a polyline and the right operand a float for the area, returrns the y coordinate of the water (water level)Examples:waterlevel &lt;- my_river_polyline water_level_for my_area_valuewater_polylines_forPossible use:  geometry water_polylines_for float —&gt;  msi.gama.util.IList&lt;msi.gama.util.IList&lt;msi.gama.metamodel.shape.GamaPoint&gt;&gt;  water_polylines_for (geometry , float) —&gt;  msi.gama.util.IList&lt;msi.gama.util.IList&lt;msi.gama.metamodel.shape.GamaPoint&gt;&gt;Special cases:  if the left operand is a polyline and the right operand a float for the water y coordinate, returrns the shapes of the river sections (list of list of points)Examples:waterarea &lt;- my_river_polyline water_area_for my_height_valueSkillsStatementsSpeciesArchitectures",
        "url":"/wiki/Extension_cenres.gaml.extensions.hydro.html"
      }
      ,
    
      "wiki-extension-cict-gaml-extensions-netcdf-html": {
        "title": "Extension",
        "content": "Extensioncict.gaml.extensions.netcdfTable of ContentsOperatorsis_netcdf, netcdf_file, reduce_dimension,StatementsSkillsArchitecturesSpeciesOperatorsis_netcdfPossible use:  is_netcdf (any) —&gt;  boolResult:Tests whether the operand is a netcdf file.netcdf_filePossible use:  netcdf_file (string) —&gt;  fileResult:Constructs a file of type netcdf. Allowed extensions are limited to ncreduce_dimensionPossible use:  string reduce_dimension container —&gt;  container  reduce_dimension (string , container) —&gt;  containerResult:general operator to manipylate multidimension netcdf data.SkillsStatementsSpeciesArchitectures",
        "url":"/wiki/Extension_cict.gaml.extensions.netcdf.html"
      }
      ,
    
      "wiki-extension-dream-gama-opengis-html": {
        "title": "Extension",
        "content": "Extensiondream.gama.opengisTable of ContentsOperatorsgml_from_wfs, image_from_direct_wms, image_from_wms, read_json_rest,StatementsSkillsArchitecturesSpeciesOperatorsgml_from_wfsPossible use:  gml_from_wfs (string, string, string) —&gt;  msi.gama.util.IList&lt;msi.gama.util.IList&lt;java.lang.Object&gt;&gt;Result:WMS: A simple call to WFS/GML2image_from_direct_wmsPossible use:  string image_from_direct_wms string —&gt;  file  image_from_direct_wms (string , string) —&gt;  fileResult:WMS: A simple call to WMSimage_from_wmsPossible use:  image_from_wms (string, string, int, int, int, float, float, float, float) —&gt;  fileResult:WMS: A simple call to WMSread_json_restPossible use:  string read_json_rest string —&gt;  msi.gama.util.IList&lt;msi.gama.util.IList&lt;java.lang.Object&gt;&gt;  read_json_rest (string , string) —&gt;  msi.gama.util.IList&lt;msi.gama.util.IList&lt;java.lang.Object&gt;&gt;Result:REST: Read data from RESTServiceSkillsStatementsSpeciesArchitectures",
        "url":"/wiki/Extension_dream.gama.opengis.html"
      }
      ,
    
      "wiki-extension-idees-gama-mapcomparison-html": {
        "title": "Extension",
        "content": "Extensionidees.gama.mapcomparisonTable of ContentsOperatorsfuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,StatementsSkillsArchitecturesSpeciesOperatorsfuzzy_kappaPossible use:  fuzzy_kappa (list&lt;agent&gt;, list, list, list&lt;float&gt;, list, matrix&lt;float&gt;, float) —&gt;  float  fuzzy_kappa (list&lt;agent&gt;, list, list, list&lt;float&gt;, list, matrix&lt;float&gt;, float, list) —&gt;  floatResult:fuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling &amp; Software, 21fuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance, weights). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling &amp; Software, 21Examples:fuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2)fuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2, [1.0,3.0,2.0,2.0,4.0])fuzzy_kappa_simPossible use:  fuzzy_kappa_sim (list&lt;agent&gt;, list, list, list, list&lt;float&gt;, list, matrix&lt;float&gt;, float) —&gt;  float  fuzzy_kappa_sim (list&lt;agent&gt;, list, list, list, list&lt;float&gt;, list, matrix&lt;float&gt;, float, list) —&gt;  floatResult:fuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800, fuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance, weights). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800,Examples:fuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2)fuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2,[1.0,3.0,2.0,2.0,4.0])kappaPossible use:  kappa (list, list, list) —&gt;  float  kappa (list, list, list, list) —&gt;  floatResult:kappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20.kappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories, weights). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20.Examples:kappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3])float var1 &lt;- kappa([1,3,5,1,5],[1,1,1,1,5],[1,3,5]); \t// var1 equals the similarity between 0 and 1float var2 &lt;- kappa([1,1,1,1,5],[1,1,1,1,5],[1,3,5]); \t// var2 equals 1.0kappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3], [1.0, 2.0, 3.0, 1.0, 5.0])kappa_simPossible use:  kappa_sim (list, list, list, list) —&gt;  float  kappa_sim (list, list, list, list, list) —&gt;  floatResult:kappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories, weights). Reference: van Vliet, J., Bregt, A.K. &amp; Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8)kappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories). Reference: van Vliet, J., Bregt, A.K. &amp; Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8).Examples:kappa([cat1,cat1,cat2,cat2,cat2],[cat2,cat1,cat2,cat1,cat3],[cat2,cat1,cat2,cat3,cat3], [cat1,cat2,cat3],[1.0, 2.0, 3.0, 1.0, 5.0])kappa([cat1,cat1,cat2,cat2,cat2],[cat2,cat1,cat2,cat1,cat3],[cat2,cat1,cat2,cat3,cat3], [cat1,cat2,cat3])percent_absolute_deviationPossible use:  list&lt;float&gt; percent_absolute_deviation list&lt;float&gt; —&gt;  float  percent_absolute_deviation (list&lt;float&gt; , list&lt;float&gt;) —&gt;  floatResult:percent absolute deviation indicator for 2 series of values: percent_absolute_deviation(list_vals_observe,list_vals_sim)Examples:percent_absolute_deviation([200,300,150,150,200],[250,250,100,200,200])SkillsStatementsSpeciesArchitectures",
        "url":"/wiki/Extension_idees.gama.mapcomparison.html"
      }
      ,
    
      "wiki-extension-idees-gama-weka-html": {
        "title": "Extension",
        "content": "Extensionidees.gama.wekaTable of ContentsOperatorsclustering_cobweb, clustering_DBScan, clustering_em, clustering_farthestFirst, clustering_simple_kmeans, clustering_xmeans,StatementsSkillsArchitecturesSpeciesOperatorsclustering_cobwebPossible use:  clustering_cobweb (list&lt;agent&gt;, list&lt;string&gt;, map&lt;string,unknown&gt;) —&gt;  list&lt;list&lt;agent&gt;&gt;Result:A list of agent groups clusteredby CobWeb Algorithm based on the given attributes. Some paremeters can be defined: acuity: minimum standard deviation for numeric attributes; cutoff: category utility threshold by which to prune nodes seedExamples:list&lt;list&lt;agent&gt;&gt; var0 &lt;- clustering_cobweb([ag1, ag2, ag3, ag4, ag5],[\"size\",\"age\", \"weight\"],[\"acuity\"::3.0, \"cutoff\"::0.5); \t// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]See also:clustering_xmeans, clustering_em, clustering_farthestFirst, clustering_simple_kmeans, clustering_cobweb,clustering_DBScanPossible use:  clustering_DBScan (list&lt;agent&gt;, list&lt;string&gt;, map&lt;string,unknown&gt;) —&gt;  list&lt;list&lt;agent&gt;&gt;Result:A list of agent groups clustered by DBScan Algorithm based on the given attributes. Some paremeters can be defined: distance_f: The distance function to use for instances comparison (euclidean or manhattan); min_points: minimun number of DataObjects required in an epsilon-range-queryepsilon: epsilon – radius of the epsilon-range-queriesExamples:list&lt;list&lt;agent&gt;&gt; var0 &lt;- clustering_DBScan([ag1, ag2, ag3, ag4, ag5],[\"size\",\"age\", \"weight\"],[\"distance_f\"::\"manhattan\"]); \t// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]See also:clustering_xmeans, clustering_em, clustering_farthestFirst, clustering_simple_kmeans, clustering_cobweb,clustering_emPossible use:  clustering_em (list&lt;agent&gt;, list&lt;string&gt;, map&lt;string,unknown&gt;) —&gt;  list&lt;list&lt;agent&gt;&gt;Result:A list of agent groups clustered by EM Algorithm based on the given attributes. Some paremeters can be defined: max_iterations: the maximum number of iterations to perform;num_clusters: the number of clusters; minStdDev: minimum allowable standard deviationExamples:list&lt;list&lt;agent&gt;&gt; var0 &lt;- clustering_em([ag1, ag2, ag3, ag4, ag5],[\"size\",\"age\", \"weight\"],[\"max_iterations\"::10, \"num_clusters\"::3]); \t// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]See also:clustering_xmeans, clustering_simple_kmeans, clustering_farthestFirst, clustering_DBScan, clustering_cobweb,clustering_farthestFirstPossible use:  clustering_farthestFirst (list&lt;agent&gt;, list&lt;string&gt;, map&lt;string,unknown&gt;) —&gt;  list&lt;list&lt;agent&gt;&gt;Result:A list of agent groups clustered by Farthest First Algorithm based on the given attributes. Some paremeters can be defined: num_clusters: the number of clustersExamples:list&lt;list&lt;agent&gt;&gt; var0 &lt;- clustering_farthestFirst([ag1, ag2, ag3, ag4, ag5],[\"size\",\"age\", \"weight\"],[\"num_clusters\"::3]); \t// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]See also:clustering_xmeans, clustering_simple_kmeans, clustering_em, clustering_DBScan, clustering_cobweb,clustering_simple_kmeansPossible use:  clustering_simple_kmeans (list&lt;agent&gt;, list&lt;string&gt;, map&lt;string,unknown&gt;) —&gt;  list&lt;list&lt;agent&gt;&gt;Result:A list of agent groups clustered by K-Means Algorithm based on the given attributes. Some paremeters can be defined: distance_f: The distance function to use. 4 possible distance functions: euclidean (by default) ; ‘chebyshev’, ‘manhattan’ or ‘levenshtein’; dont_replace_missing_values: if false, replace missing values globally with mean/mode; max_iterations: the maximum number of iterations to perform;num_clusters: the number of clustersExamples:list&lt;list&lt;agent&gt;&gt; var0 &lt;- clustering_simple_kmeans([ag1, ag2, ag3, ag4, ag5],[\"size\",\"age\", \"weight\"],[\"distance_f\"::\"manhattan\", \"num_clusters\"::3]); \t// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]See also:clustering_xmeans, clustering_em, clustering_farthestFirst, clustering_DBScan, clustering_cobweb,clustering_xmeansPossible use:  clustering_xmeans (list&lt;agent&gt;, list&lt;string&gt;, map&lt;string,unknown&gt;) —&gt;  list&lt;list&lt;agent&gt;&gt;Result:A list of agent groups clustered by X-Means Algorithm based on the given attributes. Some paremeters can be defined: bin_value: value given for true value of boolean attributes; cut_off_factor: the cut-off factor to use;distance_f: The distance function to use. 4 possible distance functions: euclidean (by default) ; ‘chebyshev’, ‘manhattan’ or ‘levenshtein’; max_iterations: the maximum number of iterations to perform; max_kmeans: the maximum number of iterations to perform in KMeans; max_kmeans_for_children: the maximum number of iterations KMeans that is performed on the child centers;max_num_clusters: the maximum number of clusters; min_num_clusters: the minimal number of clustersExamples:list&lt;list&lt;agent&gt;&gt; var0 &lt;- clustering_xmeans([ag1, ag2, ag3, ag4, ag5],[\"size\",\"age\", \"weight\", \"is_male\"],[\"bin_value\"::1.0, \"distance_f\"::\"manhattan\", \"max_num_clusters\"::10, \"min_num_clusters\"::2]); \t// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]See also:clustering_simple_kmeans, clustering_em, clustering_farthestFirst, clustering_DBScan, clustering_cobweb,SkillsStatementsSpeciesArchitectures",
        "url":"/wiki/Extension_idees.gama.weka.html"
      }
      ,
    
      "wiki-extension-irit-maelia-gaml-additions-html": {
        "title": "Extension",
        "content": "Extensionirit.maelia.gaml.additionsTable of ContentsOperatorsStatementsSkillsArchitecturesSpeciesOperatorsSkillsStatementsSpeciesArchitectures",
        "url":"/wiki/Extension_irit.maelia.gaml.additions.html"
      }
      ,
    
      "wiki-extension-miat-gama-extension-ifcfile-html": {
        "title": "Extension",
        "content": "Extensionmiat.gama.extension.ifcfileTable of ContentsOperatorseleldkdjxuxsnel, ifc_file, is_ifc,StatementsSkillsArchitecturesSpeciesOperatorseleldkdjxuxsnelPossible use:  rgb eleldkdjxuxsnel rgb —&gt;  string  eleldkdjxuxsnel (rgb , rgb) —&gt;  stringifc_filePossible use:  ifc_file (string) —&gt;  fileResult:Constructs a file of type ifc. Allowed extensions are limited to ifcis_ifcPossible use:  is_ifc (any) —&gt;  boolResult:Tests whether the operand is a ifc file.SkillsStatementsSpeciesArchitectures",
        "url":"/wiki/Extension_miat.gama.extension.ifcfile.html"
      }
      ,
    
      "wiki-extension-msi-gaml-extensions-cplex-html": {
        "title": "Extension",
        "content": "Extensionmsi.gaml.extensions.cplexTable of ContentsOperatorsStatementsSkillsArchitecturesSpeciesOperatorsSkillsStatementsSpeciesArchitectures",
        "url":"/wiki/Extension_msi.gaml.extensions.cplex.html"
      }
      ,
    
      "wiki-extension-msi-gaml-extensions-humanmoving-html": {
        "title": "Extension",
        "content": "Extensionmsi.gaml.extensions.humanmovingTable of ContentsOperatorsStatementsSkillsArchitecturesSpeciesOperatorsSkillsStatementsSpeciesArchitectures",
        "url":"/wiki/Extension_msi.gaml.extensions.humanmoving.html"
      }
      ,
    
      "wiki-extension-msi-gaml-extensions-traffic2d-html": {
        "title": "Extension",
        "content": "Extensionmsi.gaml.extensions.traffic2dTable of ContentsOperatorsStatementsSkillsArchitecturesSpeciesOperatorsSkillsStatementsSpeciesArchitectures",
        "url":"/wiki/Extension_msi.gaml.extensions.traffic2d.html"
      }
      ,
    
      "wiki-extension-simtools-graphanalysis-fr-html": {
        "title": "Extension",
        "content": "Extensionsimtools.graphanalysis.frTable of ContentsOperatorsStatementslayout_forceatlas2, layout_yifanhu,SkillsArchitecturesSpeciesOperatorsSkillsStatementslayout_forceatlas2Facets  graph (graph), (omissible) : the graph to apply the layout.  approximate_repulsion (boolean): Barnes Hut optimization: n2 complexity to n.ln(n); allows larger graphs. default: false  approximation (float): Theta of the Barnes Hut optimization. default: 1.2  bounded_point1 (point): The new nodes positions are bounded within the two bound points if both are not null. default: null  bounded_point2 (point): The new nodes positions are bounded within the two bound points if both are not null. default: null  dissuade_hubs (boolean): Distributes attraction along outbound edges. Hubs attract less and thus are pushed to the borders (default: false).  edge_weight_influence (float): How much influence you give to the edges wight. 0 is no influence, 1 is normal. default: 1.0  gravity (float): Attracts nodes to the center. Prevents islands from drifting away. default: 1.0  linlog_mode (boolean): Switch model from lin-lin to lin-log. Makes clusters more tight (default: false).  nb_steps (int): The number of steps of the algorithm to perform (default 1).  prevent_overlap (boolean): Should not be used with approximate_repulsion default: false  scaling (float): How much repulsion you want. More makes a more sparse graph. default: 2.0  stronger_gravity (boolean): A stronger gravity law default: false  thread_number (int): More threads means more speed (default: 1).  tolerance (float): How much swinging you allow. Above 1 discouraged. Lower gives less speed and more precision. default: 0.1Embedments  The layout_forceatlas2 statement is of type: Single statement  The layout_forceatlas2 statement can be embedded into: Behavior, Sequence of statements or action,  The layout_forceatlas2 statement embeds statements:layout_yifanhuFacets  graph (graph), (omissible) : the graph to apply the layout.  bounded_point1 (point): The new nodes positions are bounded within the two bound points if both are not null. default: null  bounded_point2 (point): The new nodes positions are bounded within the two bound points if both are not null. default: null  nb_steps (int): The number of steps of the algorithm to perform (default 1).  optimal_distance (float): the natural length of the springs. Bigger values mean nodes will be farther apart (default: 100).  quadtree_max_level (int): The maximum level to be used in the quadtree representation. Greater values mean more accuracy (default: 10).  relative_strength (float): The relative strength between electrical force (repulsion) and spring force (attriaction). default: 0.2  step_size (float): The step size used in the algorithm. It has to be a meaningful size compared to the optimal distance (e.g. 10%). default: 10  theta (float): The theta parameter for Barnes-Hut opening criteria. Smaller values mean more accuracy (default: 1.2).Embedments  The layout_yifanhu statement is of type: Single statement  The layout_yifanhu statement can be embedded into: Behavior, Sequence of statements or action,  The layout_yifanhu statement embeds statements:SpeciesArchitectures",
        "url":"/wiki/Extension_simtools.graphanalysis.fr.html"
      }
      ,
    
      "wiki-extension-ummisco-gama-communicator-html": {
        "title": "Extension",
        "content": "Extensionummisco.gama.communicatorTable of ContentsOperatorsStatementsSkillsArchitecturesSpeciesOperatorsSkillsStatementsSpeciesArchitectures",
        "url":"/wiki/Extension_ummisco.gama.communicator.html"
      }
      ,
    
      "wiki-extension-ummisco-gama-gpu-html": {
        "title": "Extension",
        "content": "Extensionummisco.gama.gpuTable of ContentsOperatorsCPU_path_between, GPU_path_between,StatementsSkillsArchitecturesSpeciesOperatorsCPU_path_betweenPossible use:  CPU_path_between (graph, geometry, geometry) —&gt;  pathResult:The shortest path between a list of two objects in a graph computed with CPUExamples:path var0 &lt;- my_graph CPU_path_between (ag1:: ag2); \t// var0 equals A path between ag1 and ag2GPU_path_betweenPossible use:  GPU_path_between (graph, geometry, geometry) —&gt;  pathResult:The shortest path between a list of two objects in a graph computed with GPUExamples:path var0 &lt;- my_graph GPU_path_between (ag1:: ag2); \t// var0 equals A path between ag1 and ag2SkillsStatementsSpeciesArchitectures",
        "url":"/wiki/Extension_ummisco.gama.gpu.html"
      }
      ,
    
      "wiki-extension-ummisco-gaml-extensions-rjava-html": {
        "title": "Extension",
        "content": "Extensionummisco.gaml.extensions.rjavaTable of ContentsOperatorsStatementsSkillsArchitecturesSpeciesOperatorsSkillsStatementsSpeciesArchitectures",
        "url":"/wiki/Extension_ummisco.gaml.extensions.rjava.html"
      }
      ,
    
      "wiki-extension-ummisco-gaml-extensions-sound-html": {
        "title": "Extension",
        "content": "Extensionummisco.gaml.extensions.soundTable of ContentsOperatorsStatementspause_sound, resume_sound, start_sound, stop_sound,SkillsArchitecturesSpeciesOperatorsSkillsStatementspause_soundFacetsEmbedments  The pause_sound statement is of type: Sequence of statements or action  The pause_sound statement can be embedded into: Behavior, Sequence of statements or action,  The pause_sound statement embeds statements:resume_soundFacetsEmbedments  The resume_sound statement is of type: Sequence of statements or action  The resume_sound statement can be embedded into: Behavior, Sequence of statements or action,  The resume_sound statement embeds statements:start_soundFacets  source (string): The path to music file. This path is relative to the path of the model.  mode (an identifier), takes values in: {overwrite, ignore}: Mode of  repeat (boolean):Embedments  The start_sound statement is of type: Sequence of statements or action  The start_sound statement can be embedded into: Behavior, Sequence of statements or action,  The start_sound statement embeds statements:stop_soundFacetsEmbedments  The stop_sound statement is of type: Sequence of statements or action  The stop_sound statement can be embedded into: Behavior, Sequence of statements or action,  The stop_sound statement embeds statements:SpeciesArchitectures",
        "url":"/wiki/Extension_ummisco.gaml.extensions.sound.html"
      }
      ,
    
      "wiki-extension-ummisco-gaml-extensions-stats-html": {
        "title": "Extension",
        "content": "Extensionummisco.gaml.extensions.statsTable of ContentsOperatorsauto_correlation, beta, binomial_coeff, binomial_complemented, binomial_sum, chi_square, chi_square_complemented, correlation, covariance, dnorm, durbin_watson, gamma, gamma_distribution, gamma_distribution_complemented, incomplete_beta, incomplete_gamma, incomplete_gamma_complement, kurtosis, lgamma, log_gamma, moment, normal_area, normal_density, normal_inverse, pbinom, pchisq, percentile, pgamma, pnorm, pValue_for_fStat, pValue_for_tStat, quantile, quantile_inverse, rank_interpolated, rms, skew, student_area, student_t_inverse, variance,StatementsSkillsArchitecturesSpeciesOperatorsauto_correlationPossible use:  container auto_correlation int —&gt;  float  auto_correlation (container , int) —&gt;  floatResult:Returns the auto-correlation of a data sequencebetaPossible use:  float beta float —&gt;  float  beta (float , float) —&gt;  floatResult:Returns the beta function with arguments a, b.binomial_coeffPossible use:  int binomial_coeff int —&gt;  float  binomial_coeff (int , int) —&gt;  floatResult:Returns n choose k as a double. Note the integerization of the double return value.binomial_complementedPossible use:  binomial_complemented (int, int, float) —&gt;  floatResult:Returns the sum of the terms k+1 through n of the Binomial probability density, where n is the number of trials and P is the probability of success in the range 0 to 1.binomial_sumPossible use:  binomial_sum (int, int, float) —&gt;  floatResult:Returns the sum of the terms 0 through k of the Binomial probability density, where n is the number of trials and p is the probability of success in the range 0 to 1.chi_squarePossible use:  float chi_square float —&gt;  float  chi_square (float , float) —&gt;  floatResult:Returns the area under the left hand tail (from 0 to x) of the Chi square probability density function with df degrees of freedom.chi_square_complementedPossible use:  float chi_square_complemented float —&gt;  float  chi_square_complemented (float , float) —&gt;  floatResult:Returns the area under the right hand tail (from x to infinity) of the Chi square probability density function with df degrees of freedom.correlationPossible use:  container correlation container —&gt;  float  correlation (container , container) —&gt;  floatResult:Returns the correlation of two data sequencescovariancePossible use:  container covariance container —&gt;  float  covariance (container , container) —&gt;  floatResult:Returns the covariance of two data sequencesdnormSame signification as normal_densitydurbin_watsonPossible use:  durbin_watson (container) —&gt;  floatResult:Durbin-Watson computationgammaPossible use:  gamma (float) —&gt;  floatResult:Returns the value of the Gamma function at x.gamma_distributionPossible use:  gamma_distribution (float, float, float) —&gt;  floatResult:Returns the integral from zero to x of the gamma probability density function.Comment:incomplete_gamma(a,x) is equal to pgamma(a,1,x).gamma_distribution_complementedPossible use:  gamma_distribution_complemented (float, float, float) —&gt;  floatResult:Returns the integral from x to infinity of the gamma probability density function.incomplete_betaPossible use:  incomplete_beta (float, float, float) —&gt;  floatResult:Returns the regularized integral of the beta function with arguments a and b, from zero to x.incomplete_gammaPossible use:  float incomplete_gamma float —&gt;  float  incomplete_gamma (float , float) —&gt;  floatResult:Returns the regularized integral of the Gamma function with argument a to the integration end point x.incomplete_gamma_complementPossible use:  float incomplete_gamma_complement float —&gt;  float  incomplete_gamma_complement (float , float) —&gt;  floatResult:Returns the complemented regularized incomplete Gamma function of the argument a and integration start point x.kurtosisPossible use:  kurtosis (container) —&gt;  float  float kurtosis float —&gt;  float  kurtosis (float , float) —&gt;  floatResult:Returns the kurtosis (aka excess) of a data sequenceReturns the kurtosis (aka excess) of a data sequencelgammaSame signification as log_gammalog_gammaPossible use:  log_gamma (float) —&gt;  floatResult:Returns the log of the value of the Gamma function at x.momentPossible use:  moment (container, int, float) —&gt;  floatResult:Returns the moment of k-th order with constant c of a data sequencenormal_areaPossible use:  normal_area (float, float, float) —&gt;  floatResult:Returns the area to the left of x in the normal distribution with the given mean and standard deviation.normal_densityPossible use:  normal_density (float, float, float) —&gt;  floatResult:Returns the probability of x in the normal distribution with the given mean and standard deviation.normal_inversePossible use:  normal_inverse (float, float, float) —&gt;  floatResult:Returns the x in the normal distribution with the given mean and standard deviation, to the left of which lies the given area. normal.Inverse returns the value in terms of standard deviations from the mean, so we need to adjust it for the given mean and standard deviation.pbinomSame signification as binomial_sumpchisqSame signification as chi_squarepercentileSame signification as quantile_inversepgammaSame signification as gamma_distributionpnormSame signification as normal_areapValue_for_fStatPossible use:  pValue_for_fStat (float, int, int) —&gt;  floatResult:Returns the P value of F statistic fstat with numerator degrees of freedom dfn and denominator degress of freedom dfd. Uses the incomplete Beta function.pValue_for_tStatPossible use:  float pValue_for_tStat int —&gt;  float  pValue_for_tStat (float , int) —&gt;  floatResult:Returns the P value of the T statistic tstat with df degrees of freedom. This is a two-tailed test so we just double the right tail which is given by studentT of -|tstat|.quantilePossible use:  container quantile float —&gt;  float  quantile (container , float) —&gt;  floatResult:Returns the phi-quantile; that is, an element elem for which holds that phi percent of data elements are less than elem. The quantile need not necessarily be contained in the data sequence, it can be a linear interpolation.quantile_inversePossible use:  container quantile_inverse float —&gt;  float  quantile_inverse (container , float) —&gt;  floatResult:Returns how many percent of the elements contained in the receiver are &lt;= element. Does linear interpolation if the element is not contained but lies in between two contained elements.rank_interpolatedPossible use:  container rank_interpolated float —&gt;  float  rank_interpolated (container , float) —&gt;  floatResult:Returns the linearly interpolated number of elements in a list less or equal to a given element. The rank is the number of elements &lt;= element. Ranks are of the form {0, 1, 2,…, sortedList.size()}. If no element is &lt;= element, then the rank is zero. If the element lies in between two contained elements, then linear interpolation is used and a non integer value is returned.rmsPossible use:  int rms float —&gt;  float  rms (int , float) —&gt;  floatResult:Returns the RMS (Root-Mean-Square) of a data sequence. The RMS of data sequence is the square-root of the mean of the squares of the elements in the data sequence. It is a measure of the average size of the elements of a data sequence.skewPossible use:  skew (container) —&gt;  float  float skew float —&gt;  float  skew (float , float) —&gt;  floatResult:Returns the skew of a data sequence.Returns the skew of a data sequence, which is moment(data,3,mean) / standardDeviation3student_areaPossible use:  float student_area int —&gt;  float  student_area (float , int) —&gt;  floatResult:Returns the area to the left of x in the Student T distribution with the given degrees of freedom.student_t_inversePossible use:  float student_t_inverse int —&gt;  float  student_t_inverse (float , int) —&gt;  floatResult:Returns the value, t, for which the area under the Student-t probability density function (integrated from minus infinity to t) is equal to x.variancePossible use:  variance (float) —&gt;  float  variance (int, float, float) —&gt;  floatResult:Returns the variance from a standard deviation.Returns the variance of a data sequence. That is (sumOfSquares - mean*sum) / size with mean = sum/size.SkillsStatementsSpeciesArchitectures",
        "url":"/wiki/Extension_ummisco.gaml.extensions.stats.html"
      }
      ,
    
      "wiki-extension-ummisco-miro-extension-html": {
        "title": "Extension",
        "content": "Extensionummisco.miro.extensionTable of ContentsOperatorsStatementsSkillsArchitecturesSpeciesOperatorsSkillsStatementsSpeciesArchitectures",
        "url":"/wiki/Extension_ummisco.miro.extension.html"
      }
      ,
    
      "wiki-extension-ummisco-miro-extension-traffic-html": {
        "title": "Extension",
        "content": "Extensionummisco.miro.extension.trafficTable of ContentsOperatorsStatementsSkillsArchitecturesSpeciesOperatorsSkillsStatementsSpeciesArchitectures",
        "url":"/wiki/Extension_ummisco.miro.extension.traffic.html"
      }
      ,
    
      "wiki-faq-html": {
        "title": "FAQ (Frequently Asked Questions)",
        "content": "FAQ (Frequently Asked Questions)Can we record a video from an experiment ?No, we cannot directly. But you have two alternatives :  With the set of images generated with the autosave facet of an experiment, you can construct your own video file using powerful software such as ffmpeg.  You can directly record the video stream using software such as VLC Media Player or QuickTime.",
        "url":"/wiki/FAQ.html"
      }
      ,
    
      "wiki-fipa-skill-fipa-cfp-1-html": {
        "title": "FIPA Contract Net",
        "content": "FIPA Contract NetThis model demonstrates a use-case of the FIPA Contract Net interaction protocol. One initiator sends a ‘cfp’ message to other participants. All participants reply with a ‘refuse’ messages which end the interaction protocol.Code of the model :model cfp_cfp_1global {\tint nbOfParticipants &lt;- 5;\t\tinit {\t\tcreate initiator;\t\tcreate participant number: nbOfParticipants;\t\twrite 'Please step the simulation to observe the outcome in the console';\t}}species initiator skills: [fipa] { \t\treflex send_cfp_to_participants when: (time = 1) {\t\t//list&lt;participant&gt; participants &lt;- list(participant);\t\t\t\twrite '(Time ' + time + '): ' + name + ' sends a cfp message to all participants';\t\tdo start_conversation (to: list(participant), protocol: 'fipa-contract-net', performative: 'cfp', contents: ['Go swimming']);\t}\t\treflex receive_refuse_messages when: !empty(refuses) {\t\twrite '(Time ' + time + '): ' + name + ' receives refuse messages';\t\t\t\tloop r over: refuses {\t\t\twrite '\\t' + name + ' receives a refuse message from ' + r.sender + ' with content ' + r.contents ;\t\t}\t}}species participant skills: [fipa] {\t\treflex receive_cfp_from_initiator when: !empty(cfps) {\t\t\t\tmessage proposalFromInitiator &lt;- cfps[0];\t\twrite '(Time ' + time + '): ' + name + ' receives a cfp message from ' + agent(proposalFromInitiator.sender).name + ' and replies with a refuse message';\t\tdo refuse (message: proposalFromInitiator, contents: ['I am busy today'] );\t\t\t}}experiment test type: gui { \toutput {\t\t\t}}",
        "url":"/wiki/FIPA-Skill-FIPA-CFP-(1).html"
      }
      ,
    
      "wiki-fipa-skill-fipa-cfp-2-html": {
        "title": "FIPA Contract Net (2)",
        "content": "FIPA Contract Net (2)This model demonstrates a use-case of the FIPA Contract Net interaction protocol.One initiator sends a ‘cfp’ message to 5 participants.The first participants (participant0) replies with a refuse message.Four participants (participant1, participant2, participant3, participant4) reply with four propose messages.When the initiator receives the propose messages, it proceeds as follows:The initiator replies the participant1 with a reject_proposal message.The initiator replies participant2, participant3, participant4 with three accept_proposal messages respectively.When participant2, participant3 and participant4 receive the accept_proposal messages from the initiator, they proceed as follows:Participant2 replies with a failure message.Participant3 replies with an inform_done message.Participant4 replies with an inform_result message.Code of the model :model cfp_cfp_2global {\tint nbOfParticipants &lt;- 5;\tparticipant refuser;\tlist&lt;participant&gt; proposers;\tparticipant reject_proposal_participant;\tlist&lt;participant&gt; accept_proposal_participants ;\tparticipant failure_participant;\tparticipant inform_done_participant;\tparticipant inform_result_participant;\t\t\tinit {\t\tcreate initiator;\t\tcreate participant number: nbOfParticipants returns: ps;\t\t\t\trefuser &lt;- ps[0];\t\t\t\tadd ps all: true to: proposers;\t\tremove refuser from: proposers;\t\t\t\treject_proposal_participant &lt;- proposers[0];\t\t\t\tadd proposers all: true to: accept_proposal_participants;\t\tremove reject_proposal_participant from: accept_proposal_participants;\t\t\t\tfailure_participant &lt;- accept_proposal_participants[0];\t\tinform_done_participant &lt;- accept_proposal_participants[1];\t\tinform_result_participant &lt;- accept_proposal_participants[2];\t\t\t\twrite 'Please step the simulation to observe the outcome in the console';\t}}species initiator skills: [fipa] {\t\treflex send_cfp_to_participants when: (time = 1) {\t\t\t\twrite '(Time ' + time + '): ' + name + ' sends a cfp message to all participants';\t\tdo start_conversation with: [ to :: list(participant), protocol :: 'fipa-contract-net', performative :: 'cfp', contents :: ['Go swimming'] ];\t}\t\treflex receive_refuse_messages when: !empty(refuses) {\t\twrite '(Time ' + time + '): ' + name + ' receives refuse messages';\t\t\t\tloop r over: refuses {\t\t\twrite '\\t' + name + ' receives a refuse message from ' + agent(r.sender).name + ' with content ' + r.contents ;\t\t}\t}\t\treflex receive_propose_messages when: !empty(proposes) {\t\twrite '(Time ' + time + '): ' + name + ' receives propose messages';\t\t\t\tloop p over: proposes {\t\t\twrite '\\t' + name + ' receives a propose message from ' + agent(p.sender).name + ' with content ' + p.contents ;\t\t\t\t\t\tif (p.sender = reject_proposal_participant) {\t\t\t\twrite '\\t' + name + ' sends a reject_proposal message to ' + p.sender;\t\t\t\tdo reject_proposal with: [ message :: p, contents :: ['Not interested in your proposal'] ];\t\t\t} else {\t\t\t\twrite '\\t' + name + ' sends a accept_proposal message to ' + p.sender;\t\t\t\tdo accept_proposal with: [ message :: p, contents :: ['Interesting proposal. Go do it'] ];\t\t\t}\t\t}\t}\t\treflex receive_failure_messages when: !empty(failures) {\t\tmessage f &lt;- failures[0];\t\twrite '\\t' + name + ' receives a failure message from ' + agent(f.sender).name + ' with content ' + f.contents ;\t}\t\treflex receive_inform_messages when: !empty(informs) {\t\twrite '(Time ' + time + '): ' + name + ' receives inform messages';\t\t\t\tloop i over: informs {\t\t\twrite '\\t' + name + ' receives a inform message from ' + agent(i.sender).name + ' with content ' + i.contents ;\t\t}\t}}species participant skills: [fipa] {\t\treflex receive_cfp_from_initiator when: !empty(cfps) {\t\t\t\tmessage proposalFromInitiator &lt;- cfps[0];\t\twrite '(Time ' + time + '): ' + name + ' receives a cfp message from ' + agent(proposalFromInitiator.sender).name + ' with content ' + proposalFromInitiator.contents;\t\t\t\tif (self = refuser) {\t\t\twrite '\\t' + name + ' sends a refuse message to ' + agent(proposalFromInitiator.sender).name;\t\t\tdo refuse with: [ message :: proposalFromInitiator, contents :: ['I am busy today'] ];\t\t}\t\t\t\tif (self in proposers) {\t\t\twrite '\\t' + name + ' sends a propose message to ' + agent(proposalFromInitiator.sender).name;\t\t\tdo propose with: [ message :: proposalFromInitiator, contents :: ['Ok. That sound interesting'] ];\t\t}\t}\t\treflex receive_reject_proposals when: !empty(reject_proposals) {\t\tmessage r &lt;- reject_proposals[0];\t\twrite '(Time ' + time + '): ' + name + ' receives a reject_proposal message from ' + agent(r.sender).name + ' with content ' + r.contents;\t}\t\treflex receive_accept_proposals when: !empty(accept_proposals) {\t\tmessage a &lt;- accept_proposals[0];\t\twrite '(Time ' + time + '): ' + name + ' receives a accept_proposal message from ' + agent(a.sender).name + ' with content ' + a.contents;\t\t\t\tif (self = failure_participant) {\t\t\twrite '\\t' + name + ' sends a failure message to ' + agent(a.sender).name;\t\t\tdo failure with: [ message :: a, contents :: ['Failure'] ];\t\t}\t\t\t\tif (self = inform_done_participant) {\t\t\twrite '\\t' + name + ' sends an inform_done message to ' + agent(a.sender).name;\t\t\tdo inform with: [ message :: a, contents :: ['Inform done'] ];\t\t}\t\t\t\tif (self = inform_result_participant) {\t\t\twrite '\\t' + name + ' sends an inform_result message to ' + agent(a.sender).name;\t\t\tdo inform with: [ message :: a, contents :: ['Inform result'] ];\t\t}\t}}experiment test type: gui {\toutput {\t\t\t}}",
        "url":"/wiki/FIPA-Skill-FIPA-CFP-(2).html"
      }
      ,
    
      "wiki-fipa-skill-fipa-no-protocol-html": {
        "title": "FIPA no protocol",
        "content": "FIPA no protocolThis model demonstrates a usecase of ‘no-protocol’ interaction protocol.‘no-protocol’ is a freestyle intecraction protocol in which the modeller(1) can send whatever type of message (i.e., message performative) in the corresponding conversation(2) is responsible for marking the end of the conversation by sending a message with ‘end_conversation’ performative.Code of the model :model no_protocol_1global {\tParticipant p;\t\tinit {\t\tcreate Initiator;\t\tcreate Participant returns: ps;\t\t\t\tp &lt;- ps at 0;\t\t\t\twrite 'Step the simulation to observe the outcome in the console';\t}}species Initiator skills: [fipa] {\treflex print_debug_infor {\t\twrite name + ' with conversations: ' + (string(conversations)) + '; mailbox: ' + (string(mailbox));\t}\treflex say_hello when: (time = 1) {\t\tdo start_conversation with: [ to :: [p], protocol :: 'no-protocol', performative :: 'inform', contents :: [ ('Hello from ' + name)] ];\t}\t\treflex read_hello_from_participant when: (time = 3) {\t\tloop i over: informs {\t\t\twrite name + ' receives message with content: ' + (string(i.contents));\t\t\tdo inform with: [ message :: i, contents :: [ ('Goodbye from ' + name)] ];\t\t}\t}\t\treflex read_rebound_goodbye when: (time = 5) {\t\tloop i over: mailbox {\t\t\twrite name + ' receives message with content: ' + (string(i.contents));\t\t}\t}}species Participant skills: [fipa] {\treflex print_debug_infor {\t\twrite name + ' with conversations: ' + (string(conversations)) + '; mailbox: ' + (string(mailbox));\t}\treflex reply_hello when: (time = 2) {\t\tloop m over: informs {\t\t\twrite name + ' receives message with content: ' + (string(m.contents));\t\t\tdo inform with: [ message :: m, contents :: [ ('Rebound hello from ' + name) ] ];\t\t}\t}\t\treflex read_goodbye when: (time = 4) {\t\tloop i over: informs {\t\t\twrite name + ' receives message with content: ' + (string(i.contents));\t\t\tdo end_conversation with: [ message :: i, contents :: [ ('Rebound goodbye from' + name) ] ];\t\t}\t}}experiment test_no_protocol type: gui {}",
        "url":"/wiki/FIPA-Skill-FIPA-No-Protocol.html"
      }
      ,
    
      "wiki-fipa-skill-fipa-propose-1-html": {
        "title": "FIPA Propose",
        "content": "FIPA ProposeThis model demontrates a usecase of the FIPA Propose interaction protocol. (Please see http://www.fipa.org/specs/fipa00036/SC00036H.html for the detail description of this protocol).The Initiator agent begins the conversation/interaction protocol by sending a ‘propose’ message to the Participant agent with ‘Go swimming?’ as content.On receiving the ‘propose’ message, the participant agent replies with an ‘accept_proposal’ message indicating that it agrees to go swimming.After the Initiator agent reads the ‘accept_proposal’ message, the conversation ends.Code of the model :model fipa_propose_1global {\tParticipant p;\t\tinit {\t\tcreate Initiator;\t\tcreate Participant returns: ps;\t\t\t\tp &lt;- ps at 0;\t\t\t\twrite 'Step the simulation to observe the outcome in the console';\t}}species Initiator skills: [fipa] {\treflex send_propose_message when: (time = 1) {\t\twrite name + ' sends a propose message';\t\tdo start_conversation ( to : [p], protocol : 'fipa-propose', performative : 'propose', contents : ['Go swimming?'] );\t}\t\treflex read_accept_proposals when: !(empty(accept_proposals)) {\t\twrite name + ' receives accept_proposal messages';\t\tloop i over: accept_proposals {\t\t\twrite 'accept_proposal message with content: ' + (string(i.contents));\t\t}\t}\t}species Participant skills: [fipa] {\treflex accept_proposal when: !(empty(proposes)) {\t\tmessage proposalFromInitiator &lt;- proposes at 0;\t\t\t\tdo accept_proposal ( message : proposalFromInitiator, contents : ['OK! It \\'s hot today!'] );\t}}experiment test_propose_interaction_protocol type: gui {}",
        "url":"/wiki/FIPA-Skill-FIPA-Propose-(1).html"
      }
      ,
    
      "wiki-fipa-skill-fipa-propose-2-html": {
        "title": "FIPA Propose (2)",
        "content": "FIPA Propose (2)This model demontrates a usecase of the FIPA Propose interaction protocol. (Please see http://www.fipa.org/specs/fipa00036/SC00036H.html for the detail description of this protocol).The Initiator agent begins the conversation/interaction protocol by sending a ‘propose’ message to the Participant agent with ‘Go swimming?’ as content.On receiving the ‘propose’ message, the participant agent replies with an ‘reject_proposal’ message indicating that it refuses to go swimming.After the Initiator agent reads the ‘reject_proposal’ message, the conversation ends.Code of the model :model fipa_propose_2global {\tParticipant p;\t\tinit {\t\tcreate Initiator;\t\tcreate Participant returns: ps;\t\t\t\t p &lt;- ps at 0;\t\t\t\twrite 'Step the simulation to observe the outcome in the console';\t}}species Initiator skills: [fipa] {\treflex send_propose_message when: (time = 1) {\t\twrite name + ' sends a propose message';\t\tdo start_conversation with: [ to :: [p], protocol :: 'fipa-propose', performative :: 'propose', contents :: ['Go swimming?'] ];\t}\treflex read_accept_proposals when: !(empty(reject_proposals)) {\t\twrite name + ' receives reject_proposal messages';\t\tloop i over: reject_proposals {\t\t\twrite 'reject_proposal message with content: ' + (string(i.contents));\t\t}\t}}species Participant skills: [fipa] {\treflex accept_proposal when: !(empty(proposes)) {\t\tmessage proposalFromInitiator &lt;- proposes at 0;\t\t\t\tdo reject_proposal with: [ message :: proposalFromInitiator, contents :: ['No! It \\'s too cold today!'] ];\t}}experiment test_propose_interaction_protocol type: gui {}",
        "url":"/wiki/FIPA-Skill-FIPA-Propose-(2).html"
      }
      ,
    
      "wiki-fipa-skill-fipa-query-1-html": {
        "title": "FIPA Query",
        "content": "FIPA QueryThis model demontrates a usecase of the FIPA Query interaction protocol. (Please see http://www.fipa.org/specs/fipa00027/SC00027H.html for the detail description of this protocol).The Initiator agent begins the ‘fipa-query’ conversation/interaction protocol by sending a ‘query’ message to the Participant agent with ‘your name?’ as content.On receiving the ‘query’ message, the Participant agent replies with two consecutive messages :(1) an ‘agree’ message indicating that the Participant agent accepts to execute the query of the Initiator agent,(2) an ‘inform’ message informing the Initiation agent of Participant agent’s name.After the Initiator agent read the ‘inform’ message from the Participant agent, the conversation ends.Code of the model :model fipa_query_1global {\tParticipant p;\t\tinit {\t\tcreate Initiator;\t\tcreate Participant returns: ps;\t\t\t\t p &lt;- ps at 0;\t\t\t\twrite 'Step the simulation to observe the outcome in the console';\t}}species Initiator skills: [fipa] {\treflex send_query_message when: (time = 1) {\t\twrite name + ' sends query message';\t\tdo start_conversation with: [ to :: [p], protocol :: 'fipa-query', performative :: 'query', contents :: ['your name?'] ];\t}\t\treflex read_inform_message when: !(empty(informs)) {\t\twrite name + ' reads inform messages';\t\tloop i over: informs {\t\t\twrite 'inform message with content: ' + (string(i.contents));\t\t}\t}}species Participant skills: [fipa] {\treflex reply_query_messages when: !(empty(queries)) {\t\tmessage queryFromInitiator &lt;- queries at 0;\t\t\t\twrite name + ' reads a query message with content : ' + (string(queryFromInitiator.contents));\t\t\t\tdo agree with: [ message :: queryFromInitiator, contents :: ['OK, I will answer you'] ];\t\t\t\tdo inform with: [ message :: queryFromInitiator, contents :: [ 'My name is ' + name ] ];\t}}experiment test_query_interaction_protocol type: gui {}",
        "url":"/wiki/FIPA-Skill-FIPA-Query-(1).html"
      }
      ,
    
      "wiki-fipa-skill-fipa-query-2-html": {
        "title": "FIPA Query (2)",
        "content": "FIPA Query (2)This model demontrates a usecase of the FIPA Query interaction protocol. (Please see http://www.fipa.org/specs/fipa00027/SC00027H.html for the detail description of this protocol).The Intiator agent begins the ‘fipa-query’ conversation/interaction protocol by sending a ‘query’ message to the Participant agent with ‘your name?’ as content.On receiving the ‘query’ message, the Participant agent replies with a ‘refuse’ message indicating that its name is a secret!After the Initiator agent reads the ‘refuse’ message, the conversation ends.Code of the model :model fipa_query_2global {\tParticipant p;\t\tinit {\t\tcreate Initiator;\t\tcreate Participant returns: ps;\t\t\t\t p &lt;- ps at 0;\t\t\t\twrite 'Step the simulation to observe the outcome in the console';\t}}species Initiator skills: [fipa] {\treflex send_query_message when: (time = 1) {\t\twrite name + ' sends a query message';\t\tdo start_conversation (to :: [p], protocol :: 'fipa-query', performative :: 'query', contents :: ['your name?']);\t}\t\treflex read_refuse_messages when: !(empty(refuses)) {\t\twrite name + ' receives refuse messages';\t\tloop i over: refuses {\t\t\twrite 'refuse message with content: ' + (string(i.contents));\t\t}\t}}species Participant skills: [fipa] {\treflex reply_query_messages when: !(empty(queries)) {\t\tmessage queryFromInitiator  &lt;- queries at 0;\t\t\t\twrite name + ' reads a query message with content : ' + (string(queryFromInitiator.contents));\t\t\t\tdo refuse with: [ message :: queryFromInitiator, contents :: ['No! That is a secret!'] ];\t\t\t}}experiment test_query_interaction_protocol type: gui {}",
        "url":"/wiki/FIPA-Skill-FIPA-Query-(2).html"
      }
      ,
    
      "wiki-fipa-skill-fipa-request-1-html": {
        "title": "FIPA Request",
        "content": "FIPA RequestThis model demontrates a usecase of the FIPA Request interaction protocol. (Please see http://www.fipa.org/specs/fipa00026/index.html for the detail description of this protocol).The Initiator agent begins the ‘fipa-request’ conversation/interaction protocol by sending a ‘request’ message to the Participant agent with ‘go sleeping’ as content.On receiving the ‘request’ message, the Participant agent replies with a ‘refuse’ message.After the Initiator reads the ‘refuse’ message, the ‘fipa-request’ conversation ends.Code of the model :model fipa_request_1global {\tParticipant p;\t\tinit {\t\tcreate Initiator;\t\tcreate Participant returns: ps;\t\t\t\t p &lt;- ps at 0;\t\t\t\twrite 'Step the simulation to observe the outcome in the console';\t}}species Initiator skills: [fipa] {\treflex print_debug_infor {\t\twrite name + ' with conversations: ' + (string(conversations)) + '; messages: ' + (string(mailbox));\t}\t\treflex send_request when: (time = 1) {\t\twrite 'send message';\t\tdo start_conversation with: [ to :: [p], protocol :: 'fipa-request', performative :: 'request', contents :: ['go sleeping'] ];\t}\t\treflex read_refuse_message when: !(empty(refuses)) {\t\twrite 'read refuse messages';\t\tloop r over: refuses {\t\t\twrite 'refuse message with content: ' + string(r.contents);\t\t}\t}}species Participant skills: [fipa] {\treflex print_debug_infor {\t\twrite name + ' with conversations: ' + (string(conversations)) + '; messages: ' + (string(mailbox));\t}\treflex reply_messages when: (!empty(mailbox)) {\t\twrite name + ' sends a refuse message';\t\tdo refuse with: [ message :: (mailbox at 0), contents :: ['I don\\'t want'] ];\t}}experiment test_request_interaction_protocol type: gui {}",
        "url":"/wiki/FIPA-Skill-FIPA-Request-(1).html"
      }
      ,
    
      "wiki-fipa-skill-fipa-request-2-html": {
        "title": "FIPA Request (2)",
        "content": "FIPA Request (2)This model demontrates a usecase of the FIPA Request interaction protocol. (Please see http://www.fipa.org/specs/fipa00026/index.html for the detail description of this protocol).The Initiator agent begins the ‘fipa-request’ conversation/interaction protocol by sending a ‘request’ message to the Participant agent with ‘go sleeping’ as content.On receiving the ‘request’ message, the Participant agent replies with two consecutive messages : (1) an ‘agree’ message indicating that the Participant agent accepts to execute the request of the Initiator agent, (2) a ‘failure’ message indicating that the Participant agent fails to (can not) execute the requestion of the Initiator agent (in this case, the Participant agent says that it can not go sleeping because the bed is broken!).After the Initiator reads the ‘failure’ message from the Participant, the corresponding conversation ends.Code of the model :model fipa_request_2global {\tParticipant p;\t\tinit {\t\tcreate Initiator;\t\tcreate Participant returns: ps;\t\t\t\t p &lt;- ps at 0;\t\t\t\twrite 'Step the simulation to observe the outcome in the console';\t}}species Initiator skills: [fipa] {\treflex print_debug_infor {\t\twrite name + ' with conversations: ' + (string(conversations)) + '; messages: ' + (string(mailbox));\t}\t\treflex send_request when: (time = 1) {\t\twrite 'send message';\t\tdo start_conversation (to :: [p], protocol :: 'fipa-request', performative :: 'request', contents :: ['go sleeping'] );\t}\t\treflex read_agree_message when: !(empty(agrees)) {\t\twrite 'read agree messages';\t\tloop a over: agrees {\t\t\twrite 'agree message with content: ' + string(a.contents);\t\t}\t}\t\treflex read_failure_message when: !(empty(failures)) {\t\twrite 'read failure messages';\t\tloop f over: failures {\t\t\twrite 'failure message with content: ' + (string(f.contents));\t\t}\t}}species Participant skills: [fipa] {\treflex print_debug_infor {\t\twrite name + ' with conversations: ' + (string(conversations)) + '; messages: ' + (string(mailbox));\t}\treflex reply_messages when: (!empty(mailbox)) {\t\tmessage requestFromInitiator &lt;- (mailbox at 0);\t\twrite 'agree message';\t\tdo agree with: (message: requestFromInitiator, contents: ['I will']);\t\t\t\twrite 'inform the initiator of the failure';\t\tdo failure (message: requestFromInitiator, contents: ['The bed is broken']);\t}}experiment test_request_interaction_protocol type: gui {}",
        "url":"/wiki/FIPA-Skill-FIPA-Request-(2).html"
      }
      ,
    
      "wiki-fipa-skill-fipa-request-3-html": {
        "title": "FIPA Request (3)",
        "content": "FIPA Request (3)This model demontrates a usecase of the FIPA Request interaction protocol. (Please see http://www.fipa.org/specs/fipa00026/index.html for the detail description of this protocol).The Initiator agent begins the ‘fipa-request’ conversation/interaction protocol by sending a ‘request’  message to the Participant agent with ‘go sleeping’ as content.On receiving the ‘request’ message, the Participant replies with two consecutive messages :(1) an ‘agree’ message indicating that the Participant agent accepts to execute the request of the Initiator agent,(2) an ‘inform’ message indicating that the Participant agent has already executed the request of the Initiator agent (in this case, the ‘inform’ message informs the Initiator that the Participant agent has already gone to bed!).After the Initiator agent reads the ‘inform’ message, the conversation ends.Code of the model :model fipa_request_3global {\tParticipant p;\t\tinit {\t\tcreate Initiator;\t\tcreate Participant returns: ps;\t\t\t\tp &lt;- ps at 0;\t\t\t\twrite 'Step the simulation to observe the outcome in the console';\t}}species Initiator skills: [fipa] {\treflex print_debug_infor {\t\twrite name + ' with conversations: ' + (string(conversations)) + '; messages: ' + (string(mailbox));\t}\t\treflex send_request when: (time = 1) {\t\twrite 'send message';\t\tdo start_conversation (to :: [p], protocol :: 'fipa-request', performative :: 'request', contents :: ['go sleeping'] );\t}\treflex read_agree_message when: !(empty(agrees)) {\t\twrite 'read agree messages';\t\tloop a over: agrees {\t\t\twrite 'agree message with content: ' + string(a.contents);\t\t}\t}\t\treflex read_inform_message when: !(empty(informs)) {\t\twrite 'read inform messages';\t\tloop i over: informs {\t\t\twrite 'inform message with content: ' + (string(i.contents));\t\t}\t}}species Participant skills: [fipa] {\treflex print_debug_infor {\t\twrite name + ' with conversations: ' + (string(conversations)) + '; messages: ' + (string(mailbox));\t}\treflex reply_messages when: (!empty(mailbox)) {\t\tmessage requestFromInitiator &lt;- (mailbox at 0);\t\twrite 'agree message';\t\tdo agree with: [ message :: requestFromInitiator, contents :: ['I will'] ];\t\t\t\twrite 'inform the initiator';\t\tdo inform with: [ message :: requestFromInitiator, contents :: ['I\\'m in bed already'] ];\t}}experiment test_request_interaction_protocol type: gui {}",
        "url":"/wiki/FIPA-Skill-FIPA-Request-(3).html"
      }
      ,
    
      "wiki-fipa-skill-fipa-request-4-html": {
        "title": "FIPA Request (4)",
        "content": "FIPA Request (4)This model demontrates a usecase of the FIPA Request interaction protocol.      (Please see http://www.fipa.org/specs/fipa00026/index.html for the detail description of this protocol).    The Initiator agent begins the ‘fipa-request’ conversation/intaction protocol by sending a ‘request’      message to the Participant agent with ‘go sleeping’ as content.    On receiving a ‘request’ message, the Participant agent replies with an ‘inform’ message.  According to the specification of the FIPA Requestion interaction protocol, the next possible messages  after receiving a ‘request’ message are either ‘refuse’ message or ‘agree’ message.  Hence replying with an ‘inform’ message upon receiving a ‘request’ message violates the protocol specification.  GAMA will hence raise a GamaRuntimeException.  A conversation is automatically ended in case of GamaRuntimeException raised. Hence this conversation ends.Code of the model :model fipa_request_4global {\tParticipant p;\t\tinit {\t\tcreate Initiator;\t\tcreate Participant returns: ps;\t\t\t\tp &lt;- ps at 0;\t\t\t\twrite 'Step the simulation to observe the outcome in the console';\t}}species Initiator skills: [fipa] {\treflex print_debug_infor {\t\twrite name + ' with conversations: ' + (string(conversations)) + '; messages: ' + (string(mailbox));\t}\t\treflex send_request when: (time = 1) {\t\twrite 'send message';\t\tdo start_conversation with: [ to :: [p], protocol :: 'fipa-request', performative :: 'request', contents :: ['go sleeping'] ];\t}\t\treflex read_refuse_message when: !(empty(refuses)) {\t\twrite 'read refuse messages';\t\tloop r over: refuses {\t\t\twrite 'refuse message with content: ' + string(r.contents);\t\t}\t}}species Participant skills: [fipa] {\treflex print_debug_infor {\t\twrite name + ' with conversations: ' + (string(conversations)) + '; messages: ' + (string(mailbox));\t}\treflex reply_messages when: (!empty(mailbox)) {\t\twrite name + ' sends an inform message';\t\t\t\t\t\twrite 'A GamaRuntimeException is raised to inform that the message\\'s performative doesn\\'t respect the \\'request\\' interaction protocol\\' specification';\t\tdo inform with: [ message :: (mailbox at 0), contents :: ['I don\\'t want'] ]; // Attention: note that GAMA will raise an exception because an 'inform' message is not appropriate here.\t}}experiment test_request_interaction_protocol type: gui {}",
        "url":"/wiki/FIPA-Skill-FIPA-Request-(4).html"
      }
      ,
    
      "wiki-fipa-skill-html": {
        "title": "FIPA Skill",
        "content": "FIPA SkillThis sub-section is composed of the following models :      FIPA Contract Net        FIPA Contract Net (2)        FIPA no protocol        FIPA Propose        FIPA Propose (2)        FIPA Query        FIPA Query (2)        FIPA Request        FIPA Request (2)        FIPA Request (3)        FIPA Request (4)  ",
        "url":"/wiki/FIPA-Skill.html"
      }
      ,
    
      "wiki-features-html": {
        "title": "Features",
        "content": "FeaturesThis section is composed of the following sub-section :      3D Visualization        Agent movement        Batch        Charts        Clustering        Co-model Usage        Color        Data Importation        Database Usage        Date and Time        Driving Skill        Graphs        Init Action        Map comparison        Multi-Level Usage        Multi-simulation        Multicriteria decision        Overlay        Save statement        Spatial Operators        Statistics        Unit Test        User Interaction  ",
        "url":"/wiki/Features.html"
      }
      ,
    
      "wiki-filetypes-html": {
        "title": "File Types",
        "content": "File TypesGAMA provides modelers with a generic type for files called file. It is possible to load a file using the file operator:file my_file &lt;- file(\"../includes/data.csv\");However, internally, GAMA makes the difference between the different types of files.Indeed, for instance:global {\tinit {\t\tfile my_file &lt;- file(\"../includes/data.csv\");\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}will give:sepallengthsepalwidthpetallengthpetalwidthtype5.13.51.40.2Iris-setosa4.93.01.40.2Iris-setosa...Indeed, the content of CSV file is a matrix: each row of the matrix is a line of the file; each column of the matrix is value delimited by the separator (by default “,”).In contrary:global {\tinit {\t\tfile my_file &lt;- file(\"../includes/data.shp\");\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}will give:PolygonPolygonPolygonPolygonPolygonPolygonPolygonThe content of a shapefile is a list of geometries corresponding to the objects of the shapefile.In order to know how to load a file, GAMA analyzes its extension. For instance for a file with a “.csv” extension, GAMA knows that the file is a csv one and will try to split each line with the , separator. However, if the modeler wants to split each line with a different separator (for instance ;) or load it as a text file, he/she will have to use a specific file operator.Indeed, GAMA integrates specific operators corresponding to different types of files.Table of contents  File Types          Text File                  Extensions          Content          Operators                    CSV File                  Extensions          Content          Operators                    Shapefile                  Extensions          Content          Operators                    OSM File                  Extensions          Content          Operators                    Grid File                  Extensions          Content          Operators                    Image File                  Extensions          Content          Operators                    SVG File                  Extensions          Content          Operators                    Property File                  Extensions          Content          Operators                    R File                  Extensions          Content          Operators                    3DS File                  Extensions          Content          Operators                    OBJ File                  Extensions          Content          Operators                    Text FileExtensionsHere the list of possible extensions for text file:  “txt”  “data”  “csv”  “text”  “tsv”  “xml”Note that when trying to define the type of a file with the default file loading operator (file), GAMA will first try to test the other type of file. For example, for files with “.csv” extension, GAMA will cast them as csv file and not as text file.ContentThe content of a text file is a list of string corresponding to each line of the text file.For example:global {\tinit {\t\tfile my_file &lt;- text_file(\"../includes/data.txt\");\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}will give:sepallength,sepalwidth,petallength,petalwidth,type5.1,3.5,1.4,0.2,Iris-setosa4.9,3.0,1.4,0.2,Iris-setosa4.7,3.2,1.3,0.2,Iris-setosaOperatorsList of operators related to text files:  text_file(string path): load a file (with an authorized extension) as a text file.  text_file(string path, list content): load a file (with an authorized extension) as a text file and fill it with the given content.  is_text(op): tests whether the operand is a text fileCSV FileExtensionsHere the list of possible extensions for csv file:    * “csv”    * “tsv”ContentThe content of a csv file is a matrix of string: each row of the matrix is a line of the file; each column of the matrix is value delimited by the separator (by default “,”).For example:global {\tinit {\t\tfile my_file &lt;- csv_file(\"../includes/data.csv\");\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}will give:sepallengthsepalwidthpetallengthpetalwidthtype5.13.51.40.2Iris-setosa4.93.01.40.2Iris-setosa...OperatorsList of operators related to csv files:  csv_file(string path): load a file (with an authorized extension) as a csv file with default separator (“,”).  csv_file(string path, string separator): load a file (with an authorized extension) as a csv file with the given separator.    file my_file &lt;- csv_file(\"../includes/data.csv\", \";\");        csv_file(string path, matrix content): load a file (with an authorized extension) as a csv file and fill it with the given content.  is_csv(op): tests whether the operand is a csv fileShapefileShapefiles are classical GIS data files. A shapefile is not simple file, but a set of several files (source: wikipedia):  Mandatory files :          .shp — shape format; the feature geometry itself      .shx — shape index format; a positional index of the feature geometry to allow seeking forwards and backwards quickly      .dbf — attribute format; columnar attributes for each shape, in dBase IV format        Optional files :          .prj — projection format; the coordinate system and projection information, a plain text file describing the projection using well-known text format      .sbn and .sbx — a spatial index of the features      .fbn and .fbx — a spatial index of the features for shapefiles that are read-only      .ain and .aih — an attribute index of the active fields in a table      .ixs — a geocoding index for read-write shapefiles      .mxs — a geocoding index for read-write shapefiles (ODB format)      .atx — an attribute index for the .dbf file in the form of shapefile.columnname.atx (ArcGIS 8 and later)      .shp.xml — geospatial metadata in XML format, such as ISO 19115 or other XML schema      .cpg — used to specify the code page (only for .dbf) for identifying the character encoding to be used      More details about shapefiles can be found here.ExtensionsHere the list of possible extension for shapefile:  “shp”ContentThe content of a shapefile is a list of geometries corresponding to the objects of the shapefile.For example:global {\tinit {\t\tfile my_file &lt;- shape_file(\"../includes/data.shp\");\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}will give:PolygonPolygonPolygonPolygonPolygonPolygonPolygon...Note that the attributes of each object of the shapefile is stored in their corresponding GAMA geometry. The operator “get” (or “read”) allows to get the value of a corresponding attributes.For example:file my_file &lt;- shape_file(\"../includes/data.shp\");write \"my_file: \" + my_file.contents;loop el over: my_file {\twrite (el get \"TYPE\");}OperatorsList of operators related to shapefiles:  shape_file(string path): load a file (with an authorized extension) as a shapefile with default projection (if a prj file is defined, use it, otherwise use the default projection defined in the preference).  shape_file(string path, string code): load a file (with an authorized extension) as a shapefile with the given projection (GAMA will automatically decode the code. For a list of the possible projections see: http://spatialreference.org/ref/)  shape_file(string path, int EPSG_ID): load a file (with an authorized extension) as a shapefile with the given projection (GAMA will automatically decode the epsg code. For a list of the possible projections see: http://spatialreference.org/ref/)    file my_file &lt;- shape_file(\"../includes/data.shp\", \"EPSG:32601\");        shape_file(string path, list content): load a file (with an authorized extension) as a shapefile and fill it with the given content.  is_shape(op): tests whether the operand is a shapefileOSM FileOSM (Open Street Map) is a collaborative project to create a free editable map of the world. The data produced in this project (OSM File)  represent physical features on the ground (e.g., roads or buildings) using tags attached to its basic data structures (its nodes, ways, and relations). Each tag describes a geographic attribute of the feature being shown by that specific node, way or relation (source: openstreetmap.org).More details about OSM data can be found here.ExtensionsHere the list of possible extension for shapefile:  “osm”  “pbf”  “bz2”  “gz”ContentThe content of a OSM data is a list of geometries corresponding to the objects of the OSM file.For example:global {\tinit {\t\tfile my_file &lt;- osm_file(\"../includes/data.gz\");\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}will give:PointPointPointPointPointLineStringLineStringPolygonPolygonPolygon...Note that like for shapefiles, the attributes of each object of the osm file is stored in their corresponding GAMA geometry. The operator “get” (or “read”) allows to get the value of a corresponding attributes.OperatorsList of operators related to osm file:  osm_file(string path): load a file (with an authorized extension) as a osm file with default projection (if a prj file is defined, use it, otherwise use the default projection defined in the preference). In this case, all the nodes and ways of the OSM file will becomes a geometry.  osm_file(string path, string code): load a file (with an authorized extension) as a osm file with the given projection (GAMA will automatically decode the code. For a list of the possible projections see: http://spatialreference.org/ref/). In this case, all the nodes and ways of the OSM file will becomes a geometry.  osm_file(string path, int EPSG_ID): load a file (with an authorized extension) as a osm file with the given projection (GAMA will automatically decode the epsg code. For a list of the possible projections see: http://spatialreference.org/ref/). In this case, all the nodes and ways of the OSM file will becomes a geometry.    file my_file &lt;- osm_file(\"../includes/data.gz\", \"EPSG:32601\");        osm_file(string path, map filter): load a file (with an authorized extension) as a osm file with default projection (if a prj file is defined, use it, otherwise use the default projection defined in the preference). In this case, only the elements with the defined values are loaded from the file.```//map used to filter the object to build from the OSM file according to attributes. map filtering &lt;- map([“highway”::[“primary”, “secondary”, “tertiary”, “motorway”, “living_street”,”residential”, “unclassified”], “building”::[“yes”]]);//OSM file to loadfile osmfile &lt;-  file&lt;geometry (osm_file(\"../includes/rouen.gz\", filtering))  ;  * **osm\\_file(string path, map filter, string code)**: load a file (with an authorized extension) as a osm file with the given projection (GAMA will automatically decode the code. For a list of the possible projections see: http://spatialreference.org/ref/). In this case, only the elements with the defined values are loaded from the file.  * **osm\\_file(string path, map filter, int EPSG\\_ID)**: load a file (with an authorized extension) as a osm file with the given projection (GAMA will automatically decode the epsg code. For a list of the possible projections see: http://spatialreference.org/ref/). In this case, only the elements with the defined values are loaded from the file.  * **is\\_osm(op)**: tests whether the operand is a osm file## Grid FileEsri ASCII Grid files are classic text raster GIS data.More details about Esri ASCII grid file can be found [here](http://en.wikipedia.org/wiki/Esri_grid).Note that grid files can be used to initialize a grid species. The number of rows and columns will be read from the file. Similarly, the values of each cell contained in the grid file will be accessible through the **grid\\_value** attribute.grid cell file: grid_file {}### ExtensionsHere the list of possible extension for grid file:  * \"asc\"### ContentThe content of a grid file is a list of geometries corresponding to the cells of the grid.For example:global {\tinit {\t\tfile my_file &lt;- grid_file(“../includes/data.asc”);\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}will give:PolygonPolygonPolygonPolygonPolygonPolygonPolygon…Note that the values of each cell of the grid file is stored in their corresponding GAMA geometry (**grid\\_value** attribute). The operator \"get\" (or \"read\") allows to get the value of this attribute.For example:file my_file &lt;- grid_file(“../includes/data.asc”);write “my_file: “ + my_file.contents;loop el over: my_file {\twrite el get “grid_value”;}### OperatorsList of operators related to shapefiles:  * **grid\\_file(string path)**: load a file (with an authorized extension) as a grid file with default projection (if a prj file is defined, use it, otherwise use the default projection defined in the preference).  * **grid\\_file(string path, string code)**: load a file (with an authorized extension) as a grid file with the given projection (GAMA will automatically decode the code. For a list of the possible projections see: http://spatialreference.org/ref/)  * **grid\\_file(string path, int EPSG\\_ID)**: load a file (with an authorized extension) as a grid file with the given projection (GAMA will automatically decode the epsg code. For a list of the possible projections see: http://spatialreference.org/ref/)file my_file &lt;- grid_file(“../includes/data.shp”, “EPSG:32601”);  * **is\\_grid(op)**: tests whether the operand is a grid file.## Image File### ExtensionsHere the list of possible extensions for image file:  * \"tif\"  * \"tiff\"  * \"jpg\"  * \"jpeg\"  * \"png\"  * \"gif\"  * \"pict\"  * \"bmp\"### ContentThe content of an image file is a matrix of int: each pixel is a value in the matrix.For example:global {\tinit {\t\tfile my_file &lt;- image_file(“../includes/DEM.png”);\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}will give:-9671572-9671572-9671572-9671572-9934744-9934744-9868951-9868951-10000537-10000537…### OperatorsList of operators related to csv files:  * **image\\_file(string path)**: load a file (with an authorized extension) as an image file.  * **image\\_file(string path, matrix content)**: load a file (with an authorized extension) as an image file and fill it with the given content.  * **is\\_image(op)**: tests whether the operand is an image file## SVG FileScalable Vector Graphics (SVG) is an XML-based vector image format for two-dimensional graphics with support for interactivity and animation. Note that interactivity and animation features are not supported in GAMA.More details about SVG file can be found [here](http://en.wikipedia.org/wiki/Scalable_Vector_Graphics).### ExtensionsHere the list of possible extension for SVG file:  * \"svg\"### ContentThe content of a SVG file is a list of geometries.For example:global {\tinit {\t\tfile my_file &lt;- svg_file(“../includes/data.svg”);\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}will give:Polygon### OperatorsList of operators related to svg files:  * **shape\\_file(string path)**: load a file (with an authorized extension) as a SVG file.  * **shape\\_file(string path, point size)**: load a file (with an authorized extension) as a SVG file with the given size:file my_file &lt;- svg_file(“../includes/data.svg”, {5.0,5.0});  * **is\\_svg(op)**: tests whether the operand is a SVG file## Property File### ExtensionsHere the list of possible extensions for property file:  * \"properties\"### ContentThe content of a property file is a map of string corresponding to the content of the file.For example:global {\tinit {\t\tfile my_file &lt;- property_file(“../includes/data.properties”);\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}with the given property file:sepallength = 5.0sepalwidth = 3.0petallength = 4.0petalwidth = 2.5type = Iris-setosawill give:3.04.05.0Iris-setosa2.5### OperatorsList of operators related to text files:  * **property\\_file(string path)**: load a file (with an authorized extension) as a property file.  * **is\\_property(op)**: tests whether the operand is a property file## R FileR is a free software environment for statistical computing and graphics. GAMA allows to execute R script (if R is installed on the computer).More details about R can be found [here](http://www.r-project.org/).Note that GAMA also integrates some operators to manage R scripts:  * [R\\_compute](Operators#R_compute)  * [R\\_compute\\_param](Operators#R_compute_param)### ExtensionsHere the list of possible extensions for R file:  * \"r\"### ContentThe content of a R file corresponds to the results of the application of the script contained in the file.For example:global {\tinit {\t\tfile my_file &lt;- R_file(“../includes/data.r”);\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}will give:3.0### OperatorsList of operators related to R files:  * **R\\_file(string path)**: load a file (with an authorized extension) as a R file.  * **is\\_R(op)**: tests whether the operand is a R file.## 3DS File3DS is one of the file formats used by the Autodesk 3ds Max 3D modeling, animation and rendering software. 3DS files can be used in GAMA to load 3D geometries.More details about 3DS file can be found [here](http://en.wikipedia.org/wiki/.3ds).### ExtensionsHere the list of possible extension for 3DS file:  * \"3ds\"  * \"max\"### ContentThe content of a 3DS file is a list of geometries.For example:global {\tinit {\t\tfile my_file &lt;- threeds_file(“../includes/data.3ds”);\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}will give:Polygon### OperatorsList of operators related to 3ds files:  * **threeds\\_file(string path)**: load a file (with an authorized extension) as a 3ds file.  * **is\\_threeds(op)**: tests whether the operand is a 3DS file## OBJ FileOBJ file is a geometry definition file format first developed by Wavefront Technologies for its Advanced Visualizer animation package. The file format is open and has been adopted by other 3D graphics application vendors.More details about Obj file can be found [here](http://en.wikipedia.org/wiki/Wavefront_.obj_file).### ExtensionsHere the list of possible extension for OBJ files:  * \"obj\"### ContentThe content of a OBJ file is a list of geometries.For example:global {\tinit {\t\tfile my_file &lt;- obj_file(“../includes/data.obj”);\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}will give:Polygon```OperatorsList of operators related to obj files:  obj_file(string path): load a file (with an authorized extension) as a obj file.  is_obj(op): tests whether the operand is a OBJ file//: # (endConcept|load_complex_datas)",
        "url":"/wiki/FileTypes.html"
      }
      ,
    
      "wiki-flood-simulation-hydrological-model-html": {
        "title": "Hydrological Model",
        "content": "Hydrological ModelAuthor : Patrick TaillandierA model showing how to represent a flooding system with dykes and buildings. It uses a grid to discretize space, and has a 3D display. The water can flow from one cell to another considering the height of the cells, and the water pressure. It is also possible to delete dyke by clicking on one of them in the display.Code of the model :model hydroglobal {   //Shapefile for the river   file river_shapefile &lt;- file(\"../includes/RedRiver.shp\");   //Shapefile for the dykes   file dykes_shapefile &lt;- file(\"../includes/Dykes.shp\");   //Shapefile for the buildings   file buildings_shapefile &lt;- file(\"../includes/Building.shp\");      //Data elevation file   file dem_file &lt;- file(\"../includes/mnt50.asc\");     //Diffusion rate   float diffusion_rate &lt;- 0.6;   //Height of the dykes   float dyke_height &lt;- 15.0;   //Width of the dyke   float dyke_width &lt;- 15.0;       //Shape of the environment using the dem file   geometry shape &lt;- envelope(dem_file);      //List of the drain and river cells   list&lt;cell&gt; drain_cells;   list&lt;cell&gt; river_cells;           float step &lt;- 1°h;      init {   \t //Initialization of the cells      do init_cells;     //Initialization of the water cells      do init_water;     //Initialization of the river cells     river_cells &lt;- cell where (each.is_river);     //Initialization of the drain cells      drain_cells &lt;- cell where (each.is_drain);     //Initialization of the obstacles (buildings and dykes)      do init_obstacles;      //Set the height of each cell      ask cell {         obstacle_height &lt;- compute_highest_obstacle();         do update_color;      }   }   //Action to initialize the altitude value of the cell according to the dem file   action init_cells {      ask cell {         altitude &lt;- grid_value;         neighbour_cells &lt;- (self neighbors_at 1) ;      }   }   //action to initialize the water cells according to the river shape file and the drain   action init_water {      geometry river &lt;- geometry(river_shapefile);      ask cell overlapping river {         water_height &lt;- 10.0;         is_river &lt;- true;         is_drain &lt;- grid_y = matrix(cell).rows - 1;      }   }   //initialization of the obstacles (the buildings and the dykes)   action init_obstacles{      create buildings from: buildings_shapefile  {         do update_cells;      }      create dyke from: dykes_shapefile;      ask dyke {          shape &lt;-  shape + dyke_width;            do update_cells;      }   }   //Reflex to add water among the water cells   reflex adding_input_water {   \t  float water_input &lt;- rnd(100)/100;      ask river_cells {         water_height &lt;- water_height + water_input;      }   }   //Reflex to flow the water according to the altitute and the obstacle   reflex flowing {      ask cell {already &lt;- false;}      ask (cell sort_by ((each.altitude + each.water_height + each.obstacle_height))) {         do flow;      }   }   //Reflex to update the color of the cell   reflex update_cell_color {      ask cell {         do update_color;      }   }   //Reflex for the drain cells to drain water   reflex draining {      ask drain_cells {         water_height &lt;- 0.0;      }   }   }//Species which represent the obstacle   species obstacle {   \t  //height of the obstacle      float height min: 0.0;      //Color of the obstacle      rgb color;      //Pressure of the water      float water_pressure update: compute_water_pressure();            //List of cells concerned      list&lt;cell&gt; cells_concerned ;      //List of cells in the neighbourhood       list&lt;cell&gt; cells_neighbours;            //Action to compute the water pressure      float compute_water_pressure {      \t//If the obstacle doesn't have height, then there will be no pressure         if (height = 0.0) {            return 0.0;         } else {         \t//The leve of the water is equals to the maximul level of water in the neighbours cells            float water_level &lt;- cells_neighbours max_of (each.water_height);            //Return the water pressure as the minimal value between 1 and the water level divided by the height            return min([1.0,water_level / height]);         }       }            //Action to update the cells      action update_cells {      \t//All the cells concerned by the obstacle are the ones overlapping the obstacle         cells_concerned &lt;- (cell overlapping self);        \task cells_concerned {        \t//Add the obstacles to the obstacles of the cell            add myself to: obstacles;            water_height &lt;- 0.0;         }         //Cells neighbours are all the neighbours cells of the cells concerned         cells_neighbours &lt;- cells_concerned + cells_concerned accumulate (each.neighbour_cells);         //The height is now computed      \t do compute_height();         if (height &gt; 0.0) {            \t//We compute the water pressure again            water_pressure &lt;- compute_water_pressure();         } else {water_pressure &lt;- 0.0;}      }      action compute_height;      aspect geometry {         int val &lt;- int( 255 * water_pressure);         color &lt;- rgb(val,255-val,0);         draw shape color: color depth: height*5 border: color;      }   }   //Species buildings which is derivated from obstacle   species buildings parent: obstacle {   \t //The building has a height randomly chosed between 2 and 10      float height &lt;- 2.0 + rnd(8);   }   //Species dyke which is derivated from obstacle   species dyke parent: obstacle{   \t       int counter_wp &lt;- 0;       int breaking_threshold &lt;- 24;            //Action to represent the break of the dyke       action break{         ask cells_concerned {            do update_after_destruction(myself);         }         do die;      }      //Action to compute the height of the dyke as the dyke_height without the mean height of the cells it overlaps      action compute_height       {      \t   height &lt;- dyke_height - mean(cells_concerned collect (each.altitude));            }            //Reflex to break the dynamic of the water      reflex breaking_dynamic {      \tif (water_pressure = 1.0) {      \t\tcounter_wp &lt;- counter_wp + 1;      \t\tif (counter_wp &gt; breaking_threshold) {      \t\t\tdo break;      \t\t}      \t} else {      \t\tcounter_wp &lt;- 0;      \t}      }      //user command which allows the possibility to destroy the dyke for the user      user_command \"Destroy dyke\" action: break;    }   //Grid cell to discretize space, initialized using the dem file   grid cell file: dem_file neighbors: 8 frequency: 0  use_regular_agents: false use_individual_shapes: false use_neighbors_cache: false {      //Altitude of the cell      float altitude;      //Height of the water in the cell      float water_height &lt;- 0.0 min: 0.0;      //Height of the cell      float height;      //List of the neighbour cells      list&lt;cell&gt; neighbour_cells ;      //Boolean to know if it is a drain cell      bool is_drain &lt;- false;      //Boolean to know if it is a river cell      bool is_river &lt;- false;      //List of all the obstacles overlapping the cell      list&lt;obstacle&gt; obstacles;      //Height of the obstacles      float obstacle_height &lt;- 0.0;      bool already &lt;- false;            //Action to compute the highest obstacle among the obstacles      float compute_highest_obstacle {         if (empty(obstacles))         {            return 0.0;          } else {            return obstacles max_of(each.height);         }      }      //Action to flow the water       action flow {      \t//if the height of the water is higher than 0 then, it can flow among the neighbour cells         if (water_height &gt; 0) {         \t//We get all the cells already done            list&lt;cell&gt; neighbour_cells_al &lt;- neighbour_cells where (each.already);            //If there are cells already done then we continue            if (!empty(neighbour_cells_al)) {               //We compute the height of the neighbours cells according to their altitude, water_height and obstacle_height               ask neighbour_cells_al {height &lt;- altitude + water_height + obstacle_height;}               //The height of the cell is equals to its altitude and water height               height &lt;-  altitude +  water_height;               //The water of the cells will flow to the neighbour cells which have a height less than the height of the actual cell               list&lt;cell&gt; flow_cells &lt;- (neighbour_cells_al where (height &gt; each.height)) ;               //If there are cells, we compute the water flowing               if (!empty(flow_cells)) {                  loop flow_cell over: shuffle(flow_cells) sort_by (each.height){                     float water_flowing &lt;- max([0.0, min([(height - flow_cell.height), water_height * diffusion_rate])]);                      water_height &lt;- water_height - water_flowing;                     flow_cell.water_height &lt;-flow_cell.water_height +  water_flowing;                     height &lt;- altitude + water_height;                  }                  }            }         }         already &lt;- true;      }        //Update the color of the cell      action update_color {          int val_water &lt;- 0;         val_water &lt;- max([0, min([255, int(255 * (1 - (water_height / 12.0)))])]) ;           color &lt;- rgb([val_water, val_water, 255]);         grid_value &lt;- water_height + altitude;      }      //action to compute the destruction of the obstacle      action update_after_destruction(obstacle the_obstacle){         remove the_obstacle from: obstacles;         obstacle_height &lt;- compute_highest_obstacle();      }          }experiment main_gui type: gui {   parameter \"Shapefile for the river\" var:river_shapefile category:\"Water data\";   parameter \"Shapefile for the dykes\" var:dykes_shapefile category:\"Obstacles\";   parameter \"Shapefile for the buildings\" var:buildings_shapefile category:\"Obstacles\";   parameter \"Height of the dykes\" var:dyke_height category:\"Obstacles\";   parameter \"Diffusion rate\" var:diffusion_rate category:\"Water dynamic\";   output {       display map type: opengl {         grid cell triangulation: true;         species buildings aspect: geometry;         species dyke aspect: geometry ;      }      display chart_display refresh: every(24) {          chart \"Pressure on Dykes\" type: series {            data \"Mean pressure on dykes \" value: mean(dyke collect (each.water_pressure)) style: line color: #magenta ;            data \"Rate of dykes with max pressure\" value: (dyke count (each.water_pressure = 1.0))/ length(dyke) style: line color: #red ;            data \"Rate of dykes with high pressure\" value: (dyke count (each.water_pressure &gt; 0.5))/ length(dyke) style: line color: #orange ;            data \"Rate of dykes with low pressure\" value: (dyke count (each.water_pressure &lt; 0.25))/ length(dyke) style: line color: #green ;         }      }   }}",
        "url":"/wiki/Flood-Simulation-Hydrological-Model.html"
      }
      ,
    
      "wiki-flood-simulation-html": {
        "title": "Flood Simulation",
        "content": "Flood SimulationThis sub-section is composed of the following models :  Hydrological Model",
        "url":"/wiki/Flood-Simulation.html"
      }
      ,
    
      "wiki-g-blankpage-html": {
        "title": "",
        "content": "",
        "url":"/wiki/G__BlankPage.html"
      }
      ,
    
      "wiki-gamanalyzer-html": {
        "title": "Using GAMAnalyzer",
        "content": "Using GAMAnalyzerInstallGo to Git View -&gt; Click on Import ProjectsAdd the dependencies in ummisco.gama.feature.dependenciesGamAnalyzer is a tool to monitor several multi-agents simulationThe “agent_group_follower” goal is to monitor and analyze a group of agent during several simulation. This group of agent can be chosen by the user according to criteria chosen by the user. The monitoring process and analysis of these agents involves the extraction, processing and visualization of their data at every step of the simulation.  The data for each simulation are pooled and treated commonly for their graphic representation or clusters.Built-in Variable      varmap: All variable that can be analyzed or displayed in a graph.        numvarmap: Numerical variable (on this variable all the aggregator numeric are computed).        qualivarmap: All non numerical variable. Could be used for BDI to analyze beliefs.        metadatahistory: See updateMetaDataHistory. This matrice store all the metadata like getSimulationScope(), getClock().getCycle(), getUniqueSimName(scope), rule, scope.getAgentScope().getName(), this.getName(), this.agentsCourants.copy(scope), this.agentsCourants.size(), this.getGeometry().        lastdetailedvarvalues: store all the value (in varmap) for all the followed agent for the last iteration.    averagehistory: Average value for each of the numvar  stdevhistory: Std deviation value for each of the numvar  minhistory: Min deviation value for each of the numvar  maxhistory: Max deviation value for each of the numvar  distribhistoryparams: Gives the interval of the distribution described in distribhistory      distribhistory: Distribution of numvarmap    multi_metadatahistory: Aggregate each metadatahistory for each experimentExampleThis example is based on a toy model which is only composed of wandering people. In this example we will use GamAnalyzer to follow the agent people.###agent_group_follower peoplefollower;create agentfollower {  do analyse_cluster species_to_analyse:\"people\";  peoplefollower&lt;-self;}expGlobalNoneNo clustering only the current agent follower is displayedaspect base {  display_mode &lt;-\"global\";  clustering_mode &lt;-\"none\";  draw shape color: #red;}expSimGlobalNoneThe agent_group_follower corresponding to the current iteration and all the already launch experiments are displayed.aspect simglobal{  display_mode &lt;-\"simglobal\";  clustering_mode &lt;-\"none\";  draw shape color: #red;  int curColor &lt;-0;  loop geom over: allSimShape{    draw geom color:SequentialColors[curColor] at:{location.x,location.y,curColor*10};    curColor &lt;- curColor+1;  }}expClusterThe agent group follower is divided in cluster computed thanks to a dbscan algorithm. Only the current agent_group_follower is displayedaspect cluster {  display_mode &lt;-\"global\";  clustering_mode &lt;-\"dbscan\";  draw shape color: #red;}expClusterSimGlobalThe agent_group_follower (made of different cluster) corresponding to the current iteration and all the already launch experiments are displayed.aspect clusterSimGlobal {  display_mode &lt;-\"simglobal\";  clustering_mode &lt;-\"dbscan\";  draw shape color: #red;  int curColor &lt;-0;  loop geom over: allSimShape{    draw geom color:SequentialColors[curColor] at:{location.x,location.y,curColor*10};    curColor &lt;- curColor+1;  } }",
        "url":"/wiki/GamAnalyzer.html"
      }
      ,
    
      "wiki-gamaarchitecture-html": {
        "title": "Architecture of GAMA",
        "content": "Architecture of GAMAGAMA is made of a number of Eclipse Java projects, some representing the core projects without which the platform cannot be run, others additional plugins adding functionalities or concepts to the platform.Vocabulary:Each project is either designed as a plugin (containing an xml file “plugin.xml”) or as a feature (containing an xml file “feature.xml”).  A plugin can be seen as a module (or bundle in the OSGI architecture), which can be necessary (the GAMA platform can’t run without it) or optional (providing new functionalities to the platform). This decomposition between several plugins ensure the cohesion between functional blocks, each plugin has to be as independent as he can.  A feature is a group of one or several modules (or plugin), which can be loaded. NB : Unlike a plugin, a feature does not include source code, but only two files : a build.properties and a feature.xml.To see how to create a plugin and a feature, please read this page.Table of contents  Architecture of GAMA          The minimal configuration      Optional Plugins                  Plugins present in the release version          Plugins not present by default in the release version          Plugins not designated to be in the release version                    Unmaintained projects      Features      Models      Plugins overview      The minimal configurationHere is the list of projects which have to be imported in order to run the GAMA platform, and to execute a simple model in gaml language:  msi.gama.core : Encapsulates the core of the modeling and simulation facilities offered by the platform : runtime, simulation, meta-model, data structures, simulation kernel, scheduling, etc. It contains 2 main packages :          msi.gama      msi.gaml, wich defines the GAML modeling language: keywords, operators, statements, species, skills�        msi.gama.application : Describes the graphical user interface (msi.gama.gui package). This project also contains the file gama1.7.Eclipse3_8_2.product, when you can configure the application (and also launch the application). It contains the following sub-packages :          msi.gama.gui.displays      msi.gama.gui.navigator      msi.gama.gui.parameters      msi.gama.gui.swt      msi.gama.gui.views      msi.gama.gui.wizards      msi.gama.gui.viewers        msi.gama.ext : Gathers all the external libraries upon which GAMA relies upon          msi.gama.lang.gaml : Contains the gaml.xtext file which defines the GAML grammar      msi.gama.lang.gaml.ui : Contains the GAML Editor (syntax highlighting, code completion�)        msi.gama.processor : Is responsible for processing the annotations made in the Java source code and producing additions to GAML (Java, properties and documentation files), which are added into a source package called “gaml.additions” (containing two main generated files: GamlAdditions.java and GamlDocumentation.java). These additions are loaded automatically when GAMA launches, allowing extensions made by developers in other plugins to be recognized when their plugin is added to the platform.  ummisco.gaml.editbox : Project used to define the edit boxes in the gaml ui.Minimal configuration projects dependencies:Optional PluginsPlugins present in the release versionFrom this minimal configuration, it is possible to add some features. Here is the list of the features installed by default in the release version:  idees.gama.mapcomparison : Contains some useful tools to do map comparaison  msi.gaml.extensions.fipa : Provides some operators for communication between agents, using the FIPA standards  msi.gama.headless : Enables to run simulations in console mode  simtools.gaml.extensions.traffic : Provides operators and skills for traffic simulation  simtools.gaml.extensions.physics : Physics engine, collision modelling, using the library JBullet  ummisco.gaml.extensions.maths : Solving differential equation, using Euler methods and Runge Kutta.  irit.gaml.extensions.database : Provides database manipulation tools, using SQL requests  irit.gaml.extensions.test : Add unitary test statements  ummisco.gama.opengl : Provide a 3D visualization using OpenGL.  simtools.gamanalyzer.fr : Adding tools for the analysis of several execution result of a simulation (in order to find some correlations).  dream.gama.opengis : Used to load some geographic information datas from online GIS server.  simtools.graphanalysis.fr : Advanced graph operatorsPlugins not present by default in the release versionSome other plugins are not present by default in the release version (because their use is very specific), but it’s possible to install them through features.Here is the list of those plugins:  idees.gama.weka : Data-mining operators, using the library Weka.  msi.gaml.architecture.simplebdi : Architecture for using the Belief-Desire-Intention software model.  ummisco.gaml.extensions.sound : Use of sound in simulations  ummisco.gaml.extensions.stats : Advanced statistics operators  ummisco.gama.communicator : Communication between several instances of GAMA  ummisco.gaml.extensions.rjava : Adding the R language into GAMA for data miningPlugins not designated to be in the release versionOther plugins will never be on the released version, and will never be loaded during the gama execution. They are just used in the “developer” version:  msi.gama.documentation : Generate automatically the documentation in the wiki form (and also a pdf file)Unmaintained projectsSome other projects are still in the git repository in case we need to work on it one day, but they are either unfinished, obsolete, or used in very rare situations (They are not delivered in release versions, of course). Here is the list :  cenres.gaml.extensions.hydro : Provide some tools in order to create hydrology models  msi.gaml.extensions.traffic2d : Provide some tools for traffic in 2 dimensions (depreciated, now replace by msi.gaml.extensions.traffic)  msi.gaml.extensions.humainmoving : Provide a skill to represent human movement  ummisco.gama.gpu : Computation directly on the GPU for more efficiency. Results or not concluant, slower than using CPU.  msi.gama.hpc : “High Power Computing” to execute gama simulation in several computer.  msi.gaml.extensions.cplex : Originaly designed to be able to run CPLEX function in GAMA. The CPLEX is a proprietary library, we can’t deliver it in the project. Instead, we use a stub, “cplex.jar”, that you can replace by the real cplex.jar file.  irit.maelia.gaml.additions : Used for the project “Maelia”. Provide the possibility to represent the computing time in a simulation.  msi.gama.display.web : Originaly designed to run some GAMA simulation in a browser, inside gama application, using WebGL. Does not work for the moment  ummisco.miro.extension : Once used for the “miro” project, no longer used.  ummisco.miro.extension.traffic : Once used for the “miro” project, no longer used.Features  ummisco.gama.feature.audio : sound plugin  ummisco.feature.stats : stats plugin  ummisco.gama.feature.opengl.jogl2 : gathers physics and opengl plugins  simtools.graphlayout.feature : gathers core, ext, processor and graphanalysis plugins  ummisco.gama.feature.core : gathers mapcomparison, database, test, application, core, ext, headless, gaml, gaml.ui, processor, fipa, traffic and maths plugins  ummisco.gama.feature.dependencies : a bunch of libraries and plugins  other.gama.feature.plugins gathers hydro, opengis, addition, web, hpc, cplex, traffic2d, communicator, gpu, stats, extensions and traffic plugins  ummisco.gama.feature.models : model plugin  idees.gama.features.weka : weka plugin  ummisco.gama.feature.jogl2.product : gathering of the following features : core, dependencies, models, jogl2  ummisco.gama.feature.product : gathering of the following features : core, dependencies, models, jogl1ModelsBeside those plugins and features, a project dedicated to gather a bunch of examples is also in the git repository. It contains gaml code:  msi.gama.modelsPlugins overviewGlobal architecture of GAMA (nb : the features graphlayout, core, dependencies, plugins, jogl2.product and product are not represented here)",
        "url":"/wiki/GamaArchitecture.html"
      }
      ,
    
      "wiki-gamleditorgeneralities-html": {
        "title": "The GAML Editor - Generalities",
        "content": "The GAML Editor - GeneralitiesThe GAML Editor is a text editor that proposes several services to support the modeler in writing correct models: an integrated live validation system, a ribbon header that gives access to experiments, information, warning and error markers.Table of contents  The GAML Editor - Generalities          Creating a first model      Status of models in editors      Editor Preferences      Multiple editors      Local history      Creating a first modelEditing a model requires that at least one project is created in User Models. If there is none, right-click on User Models and choose “New… &gt; Gama Project…” (if you already have user projects and want to create a model in one of them, skip the next step).A dialog is then displayed, offering you to enter the name of the project as well as its location on the filesystem. Unless you are absolutely sure of what you are doing, keep the “Use default location” option checked. An error will be displayed if the project name already exists in the workspace, in which case you will have to change it. Two projects with similar names can not coexist in the workspace (even if they belong to different categories).Once the project is created (or if you have an existing project), navigate to it and right-click on it. This time, choose “New…&gt;Model file…” to create a new model.A new dialog is displayed, which asks for several required or optional information. The Container is normally the name of the project you have selected, but you can choose to place the file elsewhere. An error will be displayed if the container does not exist (yet) in the workspace. You can then choose whether you want to use a template or not for producing the initial file, and you are invited to give this file a name. An error is displayed if this name already exists in this project. The name of the model, which is by default computed with respect to the name of the file, can be actually completely different (but it may not contain white spaces or punctuation characters). The name of the author, as well as the textual description of the model and the creation of an HTML documentation, are optional.Status of models in editorsOnce this dialog is filled and accepted, GAMA will display the new “empty” model.Although GAML files are just plain text files, and can therefore be produced or modified in any text processor, using the dedicated GAML editor offers a number of advantages, among which the live display of errors and model statuses. A model can actually be in four different states, which are visually accessible above the editing area: Functional (orange color), Experimentable (green color), InError (red color), InImportedError_(yellow color). See the section on model compilation for more precise information about these statuses._In its initial state, a model is always in the Functional state, which means it compiles without problems, but cannot be used to launch experiments. The InError state, depicted below, occurs when the file contains errors (syntactic or semantic ones).While the file is not saved, these errors remain displayed in the editor and nowhere else. If you save the file, they are now considered as “workspace errors” and get displayed in the “Problems” view below the editor.Reaching the Experimentable state requires that all errors are eliminated and that at least one experiment is defined in the model, which is the case now in our toy model. The experiment is immediately displayed as a button in the toolbar, and clicking on it will allow to launch this experiment on your model. See the section about running experiments for more information on this point.Experiment buttons are updated in real-time to reflect what’s in your code. If more than one experiment is defined, corresponding buttons will be displayed in addition to the first one.Editor PreferencesText editing in general, and especially in Eclipse-based editors, sports a number of options and preferences. You might want to turn off/on the numbering of the lines, change the fonts used, change the colors used to highlight the code, etc. All of these preferences are accessible from the “Preferences…” item of the editor contextual menu.Explore the different items present there, keeping in mind that these preferences will apply to all the editors of GAMA and will be stored in your workspace.Additional informations in the EditorYou can choose to display or not some informations in your EditorOne particular option, shipped by default with GAMA, is the possibility to not only highlight the code of your model, but also its structure (complementing, in that sense, the Outline view). It is a slightly modified version of a plugin called EditBox, which can be activated by clicking on the “green square” icon in the toolbar.The Default theme of EditBox might not suit everyone’s tastes, so the preferences allow to entirely customize how the “boxes” are displayed and how they can support the modeler in better understanding “where” it is in the code. The “themes” defined in this way are stored in the workspace, but can also be exported for reuse in other workspaces, or sharing them with other modelers.Multiple editorsGAMA inherits from Eclipse the possibility to entirely configure the placement of the views, editors, etc. This can be done by rearranging their position using the mouse (click and hold on an editor’s title and move it around). In particular, you can have several editors side by side, which can be useful for viewing the documentation while coding a model.Local historyAmong the various options present to work with models, which you are invited to try out and test at will, one, called Local history is particularly interesting and worth a small explanation. When you edit models, GAMA keeps in the background all the successive versions you save (the history duration is configurable in the preferences), whether or not you are using a versioning system like SVN or Git. This local history is accessible from different places in GAMA (the Navigator, the Views menu, etc.), including the contextual menu of the editor.This command invokes the opening of a new view, which you can see on the figure below, and which lists the different versions of your file so far. You can then choose one and, right-clicking on it, either open it in a new editor, or compare it to your current version.This allows you to precisely pinpoint the modifications brought to the file and, in case of problems, to revert them easily, or even revert the entire file to a previous version. Never lose your work again !This short introduction to GAML editors is now over. You might want to take a look, now, at how the models you edit are parsed, validated and compiled, and how this information is accessible to the modeler.",
        "url":"/wiki/GamlEditorGeneralities.html"
      }
      ,
    
      "wiki-gamleditortoolbar-html": {
        "title": "The GAML Editor Toolbar",
        "content": "The GAML Editor ToolbarThe GAML Editor provide some tools to make the editing easier, covering a lot of functionalities, such as tools for changes of visualization, tools for navigation through your model, tools to format your code, or also tools to help you finding the correct keywords to use in a given context.Table of contents  The GAML Editor Toolbar  \t* Visualization tools in the editor  \t* Navigation tools in the editor  \t* Format tools in the editor  \t* Vocabulary tools in the editorVisualization tools in the editorYou can choose to display or not some informations in your Editor. Here are the different features for this part:Display the number of linesThe first toggle is used to show / hide the number of lines.Expand / Collapse linesThe second toggle provides you the possibility to expand or collapse lines in your model depending on the indentation. This feature can be very useful for big models, to collapse the part you have already finished.Mark the occurrencesThis third toggle is used to show occurrences when your cursor is pointing on one word.Display colorization of code sectionOne particular option, shipped by default with GAMA, is the possibility to not only highlight the code of your model, but also its structure (complementing, in that sense, the Outline view). It is a slightly modified version of a plugin called EditBox, which can be activated by clicking on the “green square” icon in the toolbar.The Default theme of EditBox might not suit everyone’s tastes, so the preferences allow to entirely customize how the “boxes” are displayed and how they can support the modeler in better understanding “where” it is in the code. The “themes” defined in this way are stored in the workspace, but can also be exported for reuse in other workspaces, or sharing them with other modelers.Change the font sizeThe two last tools of this section are used to increase / decrease the size of the displayed text.Navigation tools in the editorIn the Editor toolbar, you have some tools for search and navigation through the code. Here are the explanation for each functionalities:The search engineIn order to search an occurrence of a word (or the part of a word), you can type your search in the field, and the result will be highlighted automatically in the text editor.With the left / right arrows, you can highlight the previous / next occurrence of the word. The two toggles just in the right side of the search field are used to constraint the results as “case sensitive” or “whole word”. If you prefer the eclipse interface for the search engine, you can also access to the tool by taping Ctrl+F.Previous / Next locationThe two arrow shape buttons that are coming after are used to jump from the current location of your cursor to the last position, even if the last position was in an other file (and even if this file has been closed !).Show outlineThis last tool of this section is used to show the global architecture of your model, with explicit icons for each section. A search field is also available, if you want to search a specific section. By double clicking one line of the outline, you can jump directly to the chosen section. This feature can be useful if you have big model to manipulate.Format tools in the editorSome other tools are available in the toolbar to help for the indentation of the model:Shift left / shift rightThose two first buttons are used to shift a line (or a group of lines) on the left or the right.FormatThis useful feature re-indent automatically all your model.Re-serializeRe-serialize your model.CommentThe two last buttons of this section are useful to comment a line (or a group of lines).Vocabulary tools in the editorThe last group of buttons are used to search the correct way to write a certain keyword.TemplatesThe templates button is used to insert directly a code snippet in the current position of the cursor. Some snippets are already available, ordered by scope. You can custom the list of template as much as you want, it is very easy to add a new template.Built-in attributes, built-in actionsWith this feature, you can easily know the list of built-in attributes and built-in actions you can use in such or such context. With this feature, you can also insert some templates to help you, for example to insert a pre-made species using a particular skill, as it is shown it the following screenshot:… will generate the following code:All the comments are generated automatically from the current documentation.OperatorsOnce again, this powerful feature is used to generate example of structures for all the operators, ordered by categories.ColorsHere is the list of the name for the different pre-made colors you can use. You can also add some custom colors.",
        "url":"/wiki/GamlEditorToolbar.html"
      }
      ,
    
      "wiki-gamllanguage-html": {
        "title": "GAML",
        "content": "GAMLModels that users want to simulate in GAMA have to be written in a special language, called GAML (short for GAma Modeling Language)GAML is born from the necessity to have a high-level declarative way of defining and reusing structures found in almost all agent-based models. See here for more information about its background.Although this choice requires users to learn a new programming (or better, modeling) language, everything has been made in GAMA to support a short learning curve, so that they can become almost autonomous in a limited time (informal measures taken at the different events centered on GAMA have shown that one day is enough to acquire sufficient skills in writing complete models in GAML).The documentation on GAML is organized in 5 main points:  Description of the general structure of a model: see this page  Description of the declaration of species (and all their components): see this page and all its subpages  Description of the declaration of experiments: see this page for regular experiments and this one for batch experiments.  Reference of the language regarding all the structures provided to modelers  Recipes of how to use special or advanced features offered in GAML: see this page.In addition, some of the fundamental concepts behind GAML are also described in detail, both on the modeling infrastructure and the runtime infrastructure on which GAML is relying to run experiments on models.",
        "url":"/wiki/GamlLanguage.html"
      }
      ,
    
      "wiki-gamlreferences-html": {
        "title": "Gaml Reference",
        "content": "Gaml ReferenceThe following pages introduce the various constructs that are made available to the modelers in GAML. All these constructs are built-in, i.e. defined in Java, either in the core of GAMA or in its extensions. They include species, skills, control architectures, statements, data types, and various types of expressions, including a long and quite exhaustive list of operators.This set of pages is to be used as a reference, which means its role is not to explain how to properly use these constructs but to detail their structures and components.If you are not familiar yet with GAML language, please read carefully the section Learn GAML Step by Step before.",
        "url":"/wiki/GamlReferences.html"
      }
      ,
    
      "wiki-globalspecies-html": {
        "title": "The global species",
        "content": "The global speciesWe will start this chapter by studying a special species: the global species. In the global species you can define the attributes, actions and behaviors that describe the world agent. There is one unique world agent per simulation: it is this agent that is created when a user runs an experiment and that initializes the simulation through its init scope. The global species is a species like other and can be manipulated as them. In addition, the global species automatically inherits from several of built-in variables and actions. Note that a specificity of the global species is that all its attributes can be referred by all agents of the simulation.Index  Declaration  Environment Size  Built-in Attributes  Built-in Actions  The init statementDeclarationA GAMA model contains a unique global section that defines the global species.global {\t// definition of global attributes, actions, behaviours}global can use facets, such as the torus facet, to make the environment a torus or not (if it is a torus, all the agents going out of the environment will appear in the other side. If it’s not, the agents won’t be able to go out of the environment). By default, the environment is not a torus.global torus:true {\t// definition of global attributes, actions, behaviours}Other facets such as control or schedules are also available, but we will explain them later.Directly in the global scope, you have to declare all your global attributes (can be seen as “static members” in Java or C++). To declare them, proceed exactly as for declaring basic variables. Those attributes are accessible wherever you want inside the species scope.Environment sizeIn the global context, you have to define a size and a shape for your environment. In fact, an attribute already exists for the global species: it’s called shape, and its type is a geometry. By default, shape is equal to a 100m*100m square. You can change the geometry of the shape by affecting another value:geometry shape &lt;- circle(50#mm);geometry shape &lt;- rectangle(10#m,20#m);geometry shape &lt;- polygon([{1°m,2°m},{3°m,50°cm},{3.4°m,60°dm}]);nb: there are just examples. Try to avoid mixing dimensions! If no dimensions are specify, it’ll be meter by default.Built-in attributesSome attributes exist by default for the global species. The attribute shape is one of them (refers to the shape of the environment). Here is the list of the other built-in attributes:Like the other attributes of the global species, global built-in attributes can be accessed (and sometimes modified) by the world agent and every other agents in the model.world  represents the sole instance of the model species (i.e. the one defined in the global section). It is accessible from everywhere (including experiments) and gives access to built-in or user-defined global attributes and actions.cycle  integer, read-only, designates the (integer) number of executions of the simulation cycles. Note that the first cycle is the cycle with number 0.To learn more about time, please read the recipe about dates.step  float,  is the length, in model time, of an interval between two cycles, in seconds. Its default value is 1 (second). Each turn, the value of time is incremented by the value of step. The definition of step must be coherent with that of the agents’ variables like speed. The use of time unit is particularly relevant for its definition.To learn more about time, please read the recipe about dates.global {...    float step &lt;- 10°h;...}time  float, read-only, represents the current simulated time in seconds (the default unit). It is time in the model time. Begins at zero. Basically, we have:   time = cycle * step  .global {...    int nb_minutes function: { int(time / 60)};...}To learn more about time, please read the recipe about dates.duration  string, read-only, represents the value that is equal to the duration in real machine time of the last cycle.total_duration  string, read-only, represents the sum of duration since the beginning of the simulation.average_duration  string, read-only, represents the average of duration since the beginning of the simulation.machine_time  float, read-only, represents the current machine time in milliseconds.agents  list, read-only, returns a list of all the agents of the model that are considered as “active” (i.e. all the agents with behaviors, excluding the places). Note that obtaining this list can be quite time consuming, as the world has to go through all the species and get their agents before assembling the result. For instance, instead of writing something like:ask agents of_species my_species {...}one would prefer to write (which is much faster):ask my_species {...}Note that any agent has the agents attribute, representing the agents it contains. So to get all the agents of the simulation, we need to access the agents of the world using: world.agents.Built-in ActionsThe global species is provided with two specific actions.halt  stops the simulation.global {     ...     reflex halting when: empty (agents) {            do halt;     }}pause  pauses the simulation, which can then be continued by the user.global {     ...     reflex toto when: time = 100 {            do pause;     }}The init statementAfter declaring all the global attributes and defining your environment size, you can define an initial state (before launching the simulation). Here, you normally initialize your global variables, and you instantiate your species. We will see in the next session how to initialize a regular species. //: # (endConcept|global_species)",
        "url":"/wiki/GlobalSpecies.html"
      }
      ,
    
      "wiki-graphspecies-html": {
        "title": "Graph Species",
        "content": "Graph SpeciesUsing a graph species enables to easily show interaction between agents of a same species. This kind of species is particularly useful when trying to show the interaction (especially the non-spatial one) that exist between agents.Index  Declaration          Declare a graph with handmade agents      Declare a graph by using an geometry file      Declare a graph with nodes and edges        Useful operators with graph          Knowing the degree of a node      Get the neighbors of a node      Compute the shortest path      Control the weight in graph        ExampleDeclarationDeclare a graph with handmade agentsTo instantiate this graph species, several steps must be followed. First the graph species must inherit from the abstract species graph_node, then the method related_to must be redefined and finally an auxiliary species that inherits from base_edge used to represent the edges of the generated graph must be declared.A graph node is an abstract species that must redefine one method called related_to.species graph_agent parent: graph_node edge_species: edge_agent{  bool related_to(graph_agent other){  \treturn true;  }}species edge_agent parent: base_edge {}The method related_to returns a boolean, and take the agents from the current species in argument. If the method returns true, the two agents (the current instance and the one as argument) will be linked.global{\tint number_of_agents &lt;- 5;\tinit {\t\tcreate graph_agent number:number_of_agents;\t}}species graph_agent parent: graph_node edge_species: edge_agent{  bool related_to(graph_agent other){  \treturn true;  }  aspect base {  \tdraw circle(1) color:#green;  }}species edge_agent parent: base_edge {\taspect base {  \tdraw shape color:#blue;  }}experiment MyExperiment type: gui {    output {        display MyDisplay type: java2D {            species graph_agent aspect:base;            species edge_agent aspect:base;        }    }}You can for example link 2 agents when they are closer than a certain distance.Beware: The topology used in graph species is the graph topology, and not the continuous topology. You can force the use of the continuous topology with the action using as follow:bool related_to(graph_agent other){  \tusing topology:topology(world) {  \t\treturn (self.location distance_to other.location &lt; 20);  \t}}The abstract mother species “graph_node” has an attribute “my_graph”, with the type “graph”. The graph type represent a graph composed of vertices linked with edges. This type has built-in attributes such as edges (the list of all the edges agents), or vertices (the list of all the vertices agents).Declare a graph by using an geometry fileIn most cases, you will have to construct a graph from an existing file (example: a “shp” file). In that case, you will have to first instantiate a species from the shape file (with the create statement, using the facet from). When, you will have to extract a graph from the agent, using the operator as_edge_graph.model load_shape_file  global {\tfile roads_shapefile &lt;- file(\"../includes/road.shp\");\tgeometry shape &lt;- envelope(roads_shapefile);\tgraph road_network;\tinit {\t\tcreate road from: roads_shapefile;\t\troad_network &lt;- as_edge_graph(road);\t}}species road {\taspect geom {\t\tdraw shape color: #black;\t}}experiment main_experiment type:gui{\toutput {\t\tdisplay map {\t\t\tspecies road aspect:geom;\t\t\t\t}\t}}Declare a graph with nodes and edgesAnother way to create a graph is building it manually nodes by nodes, and then edges by edges, without using agent structures. Use the add_node operator and the add_edge operator to do so. Here is an example of how to do:add point(0.0,0.0) to:nodes;add point(90.0,90.0) to:nodes;add point(20.0,20.0) to:nodes;add point(40.0,50.0) to:nodes;add point(100.0,0.0) to:nodes;loop nod over:nodes {\tmy_graph &lt;- my_graph add_node(nod);}\t\tmy_graph &lt;- my_graph add_edge (nodes at 0::nodes at 2);my_graph &lt;- my_graph add_edge (nodes at 2::nodes at 3);my_graph &lt;- my_graph add_edge (nodes at 3::nodes at 1);my_graph &lt;- my_graph add_edge (nodes at 0::nodes at 4);my_graph &lt;- my_graph add_edge (nodes at 4::nodes at 1);Using this solution, my_graph can have two types: it can be an a-spatial graph, or a spatial graph. The spatial graph will have a proper geometry, with segments that follow the position of your graph (you can access to the segments by using the built-in “segments”). The a-spatial graph will not have any shape.global{\tgraph my_spatial_graph&lt;-spatial_graph([]);\tgraph my_aspatial_graph&lt;-graph([]);\t\tinit {\t\tpoint node1 &lt;- {0.0,0.0};\t\tpoint node2 &lt;- {10.0,10.0};\t\tmy_spatial_graph &lt;- my_spatial_graph add_node(node1);\t\tmy_spatial_graph &lt;- my_spatial_graph add_node(node2);\t\tmy_spatial_graph &lt;- my_spatial_graph add_edge(node1::node2);\t\twrite my_spatial_graph.edges;\t\t// the output is [polyline ([{0.0,0.0,0.0},{10.0,10.0,0.0}])]\t\tmy_aspatial_graph &lt;- my_aspatial_graph add_node(node1);\t\tmy_aspatial_graph &lt;- my_aspatial_graph add_node(node2);\t\tmy_aspatial_graph &lt;- my_aspatial_graph add_edge(node1::node2);\t\twrite my_aspatial_graph.edges;\t\t// the output is [{0.0,0.0,0.0}::{10.0,10.0,0.0}]\t}}Useful operators with graphKnowing the degree of a nodeThe operator degree_of returns the number of edge attached to a node. To use it, you have to specify a graph (on the left side of the operator), and a node (on the right side of the operator).The following code (to put inside the node species) displays the number of edges attached to each node:aspect base{\tdraw text:string(my_graph degree_of node(5)) color:# black;\tstatus &lt;- 0;}Get the neighbors of a nodeTo get the list of neighbors of a node, you should use the neighbors_of operator. On the left side of the operator, specify the graph you are using, and on the right side, specify the node. The operator returns the list of nodes located at a distance inferior or equal to 1, considering the graph topology.species graph_agent parent: graph_node edge_species: edge_agent{  list&lt;graph_agent&gt; list_neighbors &lt;- list&lt;graph_agent&gt;(my_graph neighbors_of (self));}Here is an example of model using those two previous concepts (a random node is chosen each step, displayed in red, and his neighbors are displayed in yellow):model graph_modelglobal{\tint number_of_agents &lt;- 50;\tinit\t{\t\tcreate graph_agent number: number_of_agents;\t}\t\treflex update {\t\task graph_agent(one_of(graph_agent)) {\t\t\tstatus &lt;- 2;\t\t\tdo update_neighbors;\t\t}\t}}species graph_agent parent: graph_node edge_species: edge_agent{\tint status &lt;- 0;\tlist&lt;int&gt; list_connected_index;\t\tinit {\t\tint i&lt;-0;\t\tloop over:graph_agent {\t\t\tif (flip(0.1)) {\t\t\t\tadd i to:list_connected_index;\t\t\t}\t\t\ti &lt;- i+1;\t\t}\t}\t\tbool related_to(graph_agent other){\t  \tif (list_connected_index contains (graph_agent index_of other)) {\t  \t\treturn true;\t  \t}\t  \treturn false;\t}\t\taction update_neighbors {\t\tlist&lt;graph_agent&gt; list_neighbors &lt;- list&lt;graph_agent&gt;(my_graph neighbors_of (self));\t\tloop neighb over:list_neighbors {\t\t\tneighb.status &lt;- 1;\t\t}\t}\taspect base\t{\t\tif (status = 0) {\t\t\tdraw circle(2) color: # green;\t\t}\t\telse if (status = 1) {\t\t\tdraw circle(2) color: # yellow;\t\t}\t\telse if (status = 2) {\t\t\tdraw circle(2) color: # red;\t\t}\t\tdraw text:string(my_graph degree_of self) color:# black size:4 at:point(self.location.x-1,self.location.y-2);\t\tstatus &lt;- 0;\t}}species edge_agent parent: base_edge{\taspect base\t{\t\tdraw shape color: # blue;\t}}experiment MyExperiment type: gui{\toutput\t{\t\tdisplay MyDisplay type: java2D\t\t{\t\t\tspecies graph_agent aspect: base;\t\t\tspecies edge_agent aspect: base;\t\t}\t}}Compute the shortest pathTo compute the shortest path to go from a point to another, pick a source and a destination among the vertices you have for your graph. Store those values as point type.point source;point destination;source &lt;- point(one_of(my_graph.vertices));destination &lt;- point(one_of(my_graph.vertices));Then, you can use the operator path_between to return the shortest path. To use this action, you have to give the graph, then the source point, and the destination point. This action returns a path type.path shortest_path;shortest_path &lt;- path_between (my_graph, source,destination);Another operator exists, paths_between, that returns a list of shortest paths between two points. Please read the documentation to learn more about this operator.Here is an example of code that show the shortest path between two points of a graph:model graph_modelglobal{\tint number_of_agents &lt;- 50;\tpoint source;\tpoint target;\tgraph my_graph;\tpath shortest_path;\t\t\tinit\t{\t\tcreate graph_agent number: number_of_agents;\t}\t\treflex pick_two_points {\t\tif (my_graph=nil) {\t\t\task graph_agent {\t\t\t\tmyself.my_graph &lt;- self.my_graph;\t\t\t\tbreak;\t\t\t}\t\t}\t\tshortest_path &lt;- nil;\t\tloop while:shortest_path=nil {\t\t\tsource &lt;- point(one_of(my_graph.vertices));\t\t\ttarget &lt;- point(one_of(my_graph.vertices));\t\t\tif (source != target) {\t\t\t\tshortest_path &lt;- path_between (my_graph, source,target);\t\t\t}\t\t}\t}}species graph_agent parent: graph_node edge_species: edge_agent{\tlist&lt;int&gt; list_connected_index;\t\tinit {\t\tint i&lt;-0;\t\tloop over:graph_agent {\t\t\tif (flip(0.1)) {\t\t\t\tadd i to:list_connected_index;\t\t\t}\t\t\ti &lt;- i+1;\t\t}\t}\t\tbool related_to(graph_agent other) {\t  \tusing topology:topology(world) {  \t\t\treturn (self.location distance_to other.location &lt; 20);  \t\t}\t}\taspect base\t{\t\tdraw circle(2) color: # green;\t}}species edge_agent parent: base_edge{\taspect base\t{\t\tdraw shape color: # blue;\t}}experiment MyExperiment type: gui {\toutput {\t\tdisplay MyDisplay type: java2D {\t\t\tspecies graph_agent aspect: base;\t\t\tspecies edge_agent aspect: base;\t\t\tgraphics \"shortest path\" {\t\t\t\tif (shortest_path != nil) {\t\t\t\t\tdraw circle(3) at: source color: #yellow;\t\t\t\t\tdraw circle(3) at: target color: #cyan;\t\t\t\t\tdraw (shortest_path.shape+1) color: #magenta;\t\t\t\t}\t\t\t}\t\t}\t}}Control the weight in graphYou can add a map of weight for the edges that compose the graph. Use the operator with_weights to put weights in your graph. The graph has to be on the left side of the operator, and the map has to be on the right side. In the map, you have to put edges as key, and the weight for that edge as value. One common use is to put the distance as weight:my_graph &lt;- my_graph with_weights (my_graph.edges as_map (each::geometry(each).perimeter));The calculation of shortest path can change according to the weight you choose for your edges. For example, here is the result of the calculation of the shortest path when all the edges have 1 as weight value (it is the default graph topology), and when the edges have their length as weight.Here is an example of implementation:model shortest_path_with_weightglobal{\tgraph my_graph&lt;-spatial_graph([]);\tpath shortest_path;\tlist&lt;point&gt; nodes;\t\t\tinit\t{\t\tadd point(10.0,10.0) to:nodes;\t\tadd point(90.0,90.0) to:nodes;\t\tadd point(40.0,20.0) to:nodes;\t\tadd point(80.0,50.0) to:nodes;\t\tadd point(90.0,20.0) to:nodes;\t\tloop nod over:nodes {\t\t\tmy_graph &lt;- my_graph add_node(nod);\t\t}\t\t\t\tmy_graph &lt;- my_graph add_edge (nodes at 0::nodes at 2);\t\tmy_graph &lt;- my_graph add_edge (nodes at 2::nodes at 3);\t\tmy_graph &lt;- my_graph add_edge (nodes at 3::nodes at 1);\t\tmy_graph &lt;- my_graph add_edge (nodes at 0::nodes at 4);\t\tmy_graph &lt;- my_graph add_edge (nodes at 4::nodes at 1);\t\t\t\t// comment/decomment the following line to see the difference.\t\tmy_graph &lt;- my_graph with_weights (my_graph.edges as_map (each::geometry(each).perimeter));\t\t\t\tshortest_path &lt;- path_between(my_graph,nodes at 0, nodes at 1);\t}}experiment MyExperiment type: gui {\toutput {\t\tdisplay MyDisplay type: java2D {\t\t\tgraphics \"shortest path\" {\t\t\t\tif (shortest_path != nil) {\t\t\t\t\tdraw circle(3) at: point(shortest_path.source) color: #yellow;\t\t\t\t\tdraw circle(3) at: point(shortest_path.target) color: #cyan;\t\t\t\t\tdraw (shortest_path.shape+1) color: #magenta;\t\t\t\t}\t\t\t\tloop edges over: my_graph.edges {\t\t\t\t\tdraw edges color: #black;\t\t\t\t}\t\t\t}\t\t}\t}}",
        "url":"/wiki/GraphSpecies.html"
      }
      ,
    
      "wiki-graphicaleditor-html": {
        "title": "The Graphical Editor",
        "content": "The Graphical EditorThe graphical editor that allow to build diagram (gadl files) is based on the Graphiti Eclipse plugin. It allows to define a GAMA model through a graphical interface. It a allows as well to produce a graphical model (diagram) from a gaml model.Table of contents  The Graphical Editor          Installing the graphical editor      Creating a first model      Status of models in editors      Diagram definition framework      Features                  agents                          species              grid              Inheriting link              world                                agent features                          action              reflex              aspect                                experiment                          GUI experiment              display              batch experiment                                          Pictogram color modification      GAML Model generation      Installing the graphical editorUsing the graphical editor requires to install the graphical modeling plug-in. See here for information about plug-ins and their installation.The graphical editor plug-in is called Graphical_modeling and is directly available from GAMA update site https://gama-platform.googlecode.com/svn/update_site/*.Note that the graphical editor is still under development. Updates of the plug-in will be add to the GAMA website. After installing the plug-in (and periodically), check for updates for this plug-in: in the “Help” menu, choose “Check for Updates” and install the proposed updates for the graphical modeling plug-in.Creating a first modelA new diagram can be created in a new GAMA project. First, right click on a project, then select “New” on the contextual menu.In the New Wizard, select “GAMA -&gt; Model Diagram”, then “Next&gt;”In the next Wizard dialog, select the type of diagram (Empty, Skeleton or Example) then the name of the file and the author.Skeleton and Example diagram types allow to add to the diagram some basic features.Status of models in editorsSimilarly to GAML editor, the graphical editor proposes a live display of errors and model statuses. A graphical model can actually be in three different states, which are visually accessible above the editing area: Functional (orange color), Experimentable (green color) and InError (red color). See the section on model compilation for more precise information about these statuses.In its initial state, a model is always in the Functional state, which means it compiles without problems, but cannot be used to launch experiments. The InError state occurs when the file contains errors (syntactic or semantic ones).Reaching the Experimentable state requires that all errors are eliminated and that at least one experiment is defined in the model. The experiment is immediately displayed as a button in the toolbar, and clicking on it will allow to launch this experiment on your model.Experiment buttons are updated in real-time to reflect what’s in your code. If more than one experiment is defined, corresponding buttons will be displayed in addition to the first one.Diagram definition frameworkThe following figure presents the editing framework:FeaturesagentsspeciesThe species feature allows to define a species with a continuous topology. A species is always a micro-species of another species. The top level (macro-species of all species) is the world species.  source: a species (macro-species)  target: -gridThe grid feature allows to define a species with a grid topology. A grid is always a micro-species of another species.  source: a species (macro-species)  target: -Inheriting linkThe inheriting link feature allows to define an inheriting link between two species.  source: a species (parent)  target: a species (child)worldWhen a model is created, a world species is always defined. It represent the global part of the model. The world species, which is unique, is the top level species. All other species are micro-species of the world species.agent featuresactionThe action feature allows to define an action for a species.  source: a species (owner of the action)  target: -reflexThe reflex feature allows to define a reflex for a species.  source: a species (owner of the reflex)  target: -aspectThe aspect feature allows to define an aspect for a species.  source: a species (owner of the aspect)  target: -experimentGUI experimentThe GUI Experiment feature allows to define a GUI experiment.  source: world species  target: -displayThe display feature allows to define a display.  source: GUI experiment  target: -batch experimentThe Batch Experiment feature allows to define a Batch experiment.  source: world species  target: -Pictogram color modificationIt is possible to change the color of a pictogram.  Right click on a pictogram, then select the “Chance the color”.GAML Model generationIt is possible to automatically generate a Gaml model from a diagram.  Right click on the graphical framework (where the diagram is defined), then select the “Generate Gaml model”.A new GAML model with the same name as the diagram is created (and open).",
        "url":"/wiki/GraphicalEditor.html"
      }
      ,
    
      "wiki-graphs-3d-graph-html": {
        "title": "3D Graph",
        "content": "3D GraphAuthor : Arnaud GrignardModel using a 3D Graph and updating it at each step according to the location and the degree of each sphere. An arc is created between two adjacent spheres. Two different experiments are proposed : one with a dynamic size for the spheres according to their degree, one simpler with no update of the size.Code of the model :  model graph3Dglobal {\tint number_of_agents parameter: 'Number of Agents' min: 1 &lt;- 200 category: 'Initialization';\tint width_and_height_of_environment parameter: 'Dimensions' min: 100 &lt;- 500 category: 'Initialization';\t\t//Distance to know if a sphere is adjacent or not with an other\tint distance parameter: 'distance ' min: 1 &lt;- 100;\t\t\tint degreeMax &lt;- 1;\tgeometry shape &lt;- cube(width_and_height_of_environment);\t\t\tgraph my_graph;\tinit {\t\t\t\t//creation of the node agent ie the spheres with a random location in the environment\t\tcreate node_agent number: number_of_agents {\t\t\tlocation &lt;- { rnd(width_and_height_of_environment), rnd(width_and_height_of_environment), rnd(width_and_height_of_environment) };\t\t}\t\t\t\tdo degreeMax_computation;\t\t\t\task node_agent {\t\t\tdo compute_degree;\t\t}\t}\t\treflex updateDegreeMax {\t\tdo degreeMax_computation;\t}\taction degreeMax_computation {\t\tmy_graph &lt;- node_agent as_distance_graph(distance);\t\tdegreeMax &lt;- 1;\t\task node_agent {\t\t\tif ((my_graph) degree_of (self) &gt; degreeMax) {\t\t\t\tdegreeMax &lt;- (my_graph) degree_of (self);\t\t\t}\t\t}\t}}species node_agent skills: [moving3D] {\tint degree;\tfloat radius;\trgb color ;\tfloat speed &lt;- 5.0;\treflex move {\t\t//make the agent move randomly\t\tdo wander;\t\t//compute the degree of the agent\t\tdo compute_degree;\t}\t\t\taction compute_degree {\t\tdegree &lt;- my_graph = nil ? 0 : (my_graph) degree_of (self);\t\tradius &lt;- ((((degree + 1) ^ 1.4) / (degreeMax))) * 5;\t\tcolor &lt;- hsb(0.66,degree / (degreeMax + 1), 0.5);\t}    aspect base {\t\tdraw sphere(10) color:°black;\t}\t\taspect dynamic {\t\tdraw sphere(radius) color: color;\t}}experiment Display type: gui {\toutput {\t\tdisplay WanderingSphere type: opengl { \t\t\tspecies node_agent aspect: dynamic;\t\t\tgraphics \"edges\" {\t\t\t\t//Creation of the edges of adjacence\t\t\t\tif (my_graph != nil) {\t\t\t\t\tloop eg over: my_graph.edges {\t\t\t\t\t\tgeometry edge_geom &lt;- geometry(eg);\t\t\t\t\t\tfloat val &lt;- 255 * edge_geom.perimeter / distance; \t\t\t\t\t\tdraw line(edge_geom.points, 0.5)  color: rgb(val,val,val);\t\t\t\t\t}\t\t\t\t}\t\t\t\t\t\t\t}\t\t}\t}}experiment SimpleDisplay type: gui {\toutput {\t\tdisplay WanderingSphere type: opengl { \t\t\tspecies node_agent aspect: base;\t\t\tgraphics \"edges\" {\t\t\t\tif (my_graph != nil) {\t\t\t\t\tloop eg over: my_graph.edges {\t\t\t\t\t\tgeometry edge_geom &lt;- geometry(eg);\t\t\t\t\t\tfloat val &lt;- 255 * edge_geom.perimeter / distance; \t\t\t\t\t\tdraw line(edge_geom.points) color:°black;\t\t\t\t\t}\t\t\t\t}\t\t\t\t\t\t\t}\t\t}\t}}",
        "url":"/wiki/Graphs-3D-Graph.html"
      }
      ,
    
      "wiki-graphs-classic-graph-generation-html": {
        "title": "Graph Generation",
        "content": "Graph GenerationAuthor : Patrick TaillandierModel which shows how to create three kind of graphs : a scale-free graph, a small-world graph, a complete graph and a complete graph with a radius.Code of the model :model classicgraphgenerationglobal {\tgraph the_graph ;\tstring graph_type &lt;- \"small-world\";\tint nb_nodes &lt;- 500;\tfloat p &lt;- 0.0;\tint k &lt;- 4;\tint m &lt;- 4;\tint radius &lt;- 20;\t\tinit {\t\tswitch graph_type {\t\t\tmatch \"scale-free\" {\t\t\t\tthe_graph &lt;- generate_barabasi_albert(node_agent, edge_agent, nb_nodes,m, true);\t\t\t\t}\t\t\tmatch \"small-world\" {\t\t\t\tthe_graph &lt;- generate_watts_strogatz(node_agent, edge_agent, nb_nodes, p, k, true);\t\t\t\t}\t\t\tmatch \"complete\" {\t\t\t\tthe_graph &lt;- generate_complete_graph(node_agent, edge_agent, nb_nodes,true);\t\t\t\t}\t\t\tmatch \"complete-with-radius\" {\t\t\t\tthe_graph &lt;- generate_complete_graph(node_agent, edge_agent, nb_nodes, radius,true);\t\t\t\t}\t\t\t\t}\t\twrite the_graph;\t\twrite \"Edges : \"+length(the_graph.edges);\t\twrite \"Nodes : \"+length(the_graph.vertices);\t}\t}species edge_agent {\taspect default {\t\t\tdraw shape color: #black;\t}}species node_agent {\taspect default {\t\t\tdraw circle(1) color: #red;\t}}experiment loadgraph type: gui {\tparameter \"Graph type\" var: graph_type among: [ \"scale-free\", \"small-world\", \"complete\"];\tparameter \"Number of nodes\" var: nb_nodes min: 5 ;\tparameter \"Probability to rewire an edge (beta)\" var: p min: 0.0 max: 1.0 category: \"small-world\";\tparameter \"Base degree of each node. k must be even\" var: k min: 2 max: 10 category: \"small-world\";\tparameter \"Number of edges added per novel node\" var: m min: 1 max: 10 category: \"scale-free\";\t\toutput {\t\tdisplay map type: opengl{\t\t\tspecies edge_agent ;\t\t\tspecies node_agent ;\t\t}\t}}",
        "url":"/wiki/Graphs-Classic-Graph-Generation.html"
      }
      ,
    
      "wiki-graphs-graph-building-from-agents-html": {
        "title": "Graph Generation using Agents",
        "content": "Graph Generation using AgentsAuthor : Patrick TaillandierModel which shows how to create a graph using agents of a species as vertices. Two kinds of generations are presented : one where the distance taken into account to link two vertices by an edge, an other where the intersections of two vertices joins these vertices by an edge.Code of the model :model graphbuildingglobal {\tgraph&lt;geometry, geometry&gt; the_graph ;\tstring graph_builing_type &lt;- \"distance\";\tfloat distance &lt;- 20.0;\tfloat tolerance &lt;- 0.0;\tinit {\t\tcreate dummy_agent number: 30; \t\tswitch graph_builing_type {\t\t\tmatch \"distance\" {\t\t\t\tthe_graph &lt;- as_distance_graph(dummy_agent, distance);\t\t\t\t}\t\t\tmatch \"intersection\" {\t\t\t\tthe_graph &lt;- as_intersection_graph(dummy_agent, tolerance);\t\t\t\t}\t\t\t}\t\twrite \"nb vertices: \" + length(the_graph.vertices);\t\twrite \"nb edges: \" + length(the_graph.edges);\t}\t}species dummy_agent {\tgeometry shape &lt;- square (5);\taspect default {\t\t\tdraw shape color: #red;\t}}experiment loadgraph type: gui {\tparameter \"Method to build the graph\" var: graph_builing_type among: [ \"distance\", \"intersection\"];\tparameter \"Tolerance\" var: tolerance min: 0.0 max: 2.0 category: \"Intersection\";\tparameter \"Distance\" var: distance min: 1.0 max: 50.0 category: \"Distance\";\toutput {\t\tdisplay map {\t\t\tspecies dummy_agent ;\t\t\tgraphics \"the graph\" {\t\t\t\tloop edge over: the_graph.edges {\t\t\t\t\tdraw edge color: #blue;\t\t\t\t}\t\t\t}\t\t}\t}}",
        "url":"/wiki/Graphs-Graph-Building-From-Agents.html"
      }
      ,
    
      "wiki-graphs-graph-loading-layout-html": {
        "title": "Graph from DGS File and Layout Changed",
        "content": "Graph from DGS File and Layout ChangedAuthor : Patrick TaillandierModel which shows how to load a graph from a DGS File, and change is layout.Code of the model :model graphloadinglayoutglobal {\tgraph the_graph ;\tstring barabasi_file &lt;- \"../includes/ProteinSimple.dgs\";\tgeometry shape &lt;- rectangle(500,500);\tstring layout_type &lt;- \"forcedirected\";\tint layout_time &lt;- 1000;\t\t//The operator load_graph_from_file generates the graph from the file, and chose the vertices as agents of node_agent \t//species, and edges as edge_agent agents\tinit {\t\tthe_graph &lt;- load_graph_from_file(barabasi_file, node_agent, edge_agent);\t}\t\t//In case the layout type is forcedirected or random, the reflex will change at each step the layout of the graph\treflex layout_graph {\t\tthe_graph &lt;- layout(the_graph, layout_type, layout_time);\t}}species edge_agent {\taspect default {\t\t\tdraw shape color: #black;\t}}species node_agent {\taspect default {\t\t\tdraw circle(2) color: #red;\t}}experiment loadgraph type: gui {\tparameter \"Layout type\" var: layout_type among: [ \"forcedirected\", \"random\", \"radialtree\", \"circle\"];\tparameter \"layout time\" var: layout_time min: 1 max: 100000;\toutput {\t\tdisplay map type: opengl{\t\t\tspecies edge_agent ;\t\t\tspecies node_agent ;\t\t}\t}}",
        "url":"/wiki/Graphs-Graph-Loading-Layout.html"
      }
      ,
    
      "wiki-graphs-graph-operators-html": {
        "title": "Graph Operators",
        "content": "Graph OperatorsAuthor : Patrick TaillandierModel to show how to use the different existing operators for the graph speciesCode of the model :model graphoperatorsglobal {\tgraph&lt;geometry,geometry&gt; the_graph;\tlist&lt;list&gt; cliques;\tinit {\t\tcreate people number: 50;\t\t\t\t//creation of the graph: all vertices that are at distance &lt;= 20 are connected\t\tthe_graph &lt;- as_distance_graph(people, 20);\t\t\t\t//compute the betweenness_centrality of each vertice\t\tmap&lt;people,float&gt; bc &lt;- map&lt;people, float&gt;(betweenness_centrality(the_graph));\t\tfloat max_centrality &lt;- max(bc.values);\t\tfloat min_centrality &lt;- min(bc.values);\t\task people {\t\t\tcentrality &lt;- (bc[self] - min_centrality) / (max_centrality - min_centrality);\t\t\tcentrality_color &lt;- rgb(255, int(255 * (1 - centrality)), int(255 * (1 - centrality)));\t\t}\t\twrite \"mean vertice degree: \" + mean(the_graph.vertices collect (the_graph degree_of each));\t\twrite \"nb_cycles: \" + nb_cycles(the_graph);\t\twrite \"alpha_index: \" + alpha_index(the_graph);\t\twrite \"beta_index: \" + beta_index(the_graph);\t\twrite \"gamma_index: \" + gamma_index(the_graph);\t\twrite \"connectivity_index: \" + connectivity_index(the_graph);\t\twrite \"connected_components_of: \" + length(connected_components_of(the_graph));\t\t\t\twrite \"connected_components_of: \" + length(connected_components_of(the_graph));\t\t\t\twrite \"maximal_cliques_of:\" + (maximal_cliques_of(the_graph) collect (length(each)));\t\twrite \"biggest_cliques_of:\" + (biggest_cliques_of(the_graph) collect (length(each)));\t}}species people {\tfloat centrality;\trgb centrality_color;\taspect centrality{\t\tdraw circle(1) color: centrality_color;\t\t\t}}experiment graphoperators type: gui {\t\toutput {\t\t\t\tdisplay map background:#lightgray{\t\t\tgraphics \"edges\" {\t\t\t\tloop edge over: the_graph.edges {\t\t\t\t\tdraw edge color: #black;\t\t\t\t} \t\t\t} \t\t\tspecies people aspect: centrality;\t\t}\t}}",
        "url":"/wiki/Graphs-Graph-Operators.html"
      }
      ,
    
      "wiki-graphs-hand-made-graph-html": {
        "title": "Hand Made Graph",
        "content": "Hand Made GraphAuthor : Patrick TaillandierModel to show how to build a graph from scratch using three ways : by putting a list of edges as parameter of as_edge_graph, by adding a node or an edge manually using facet to or by changing the graph itself after adding a node or an edge. The experiment has two displays : one for the first graph created from the list of edges, an other for the graph creating by adding the nodes and edges manually using add operator.Code of the model :@no_warningmodel handMadeGraphglobal {\tgraph&lt;geometry, geometry&gt; the_graph1 ;\tgraph&lt;geometry, geometry&gt; the_graph2;\t\tinit {\t\tthe_graph1 &lt;- as_edge_graph([edge({10,5}, {20,3}), edge({10,5}, {30,30}),edge({30,30}, {80,35}),edge({80,35}, {40,60}),edge({80,35}, {10,5}), node ({50,50})]);\t\t\t\t\tthe_graph2 &lt;- graph&lt;geometry, geometry&gt;([]);\t\t//first way to add nodes and edges\t\tthe_graph2 &lt;&lt; node({50,50}) ;\t\tthe_graph2 &lt;&lt; edge({10,10},{90,50});\t\t\t\t//second way to add nodes and edges\t\tthe_graph2 &lt;- the_graph2 add_node {10,40} ;\t\tthe_graph2 &lt;- the_graph2 add_edge ({35,50}:: {50,50}) ;\t}\t}species edge_agent {\taspect default {\t\t\tdraw shape color: #black;\t}}species node_agent {\taspect default {\t\t\tdraw circle(1) color: #red;\t}}experiment create_graph type: gui {\t\toutput {\t\tdisplay graph1 type: opengl{\t\t\tgraphics \"the graph 1\" {\t\t\t\tloop e over: the_graph1.edges {\t\t\t\t\tdraw e color: °blue; \t\t\t\t}\t\t\t\tloop n over: the_graph1.vertices {\t\t\t\t\tdraw circle(2) at: point(n) color: °blue; \t\t\t\t}\t\t\t}\t\t}\t\tdisplay graph2 type: opengl{\t\t\tgraphics \"the graph 2\" {\t\t\t\tloop e over: the_graph2.edges {\t\t\t\t\tdraw e color: °red; \t\t\t\t}\t\t\t\tloop n over: the_graph2.vertices {\t\t\t\t\tdraw circle(2) at: point(n) color: °red; \t\t\t\t}\t\t\t}\t\t}\t}}",
        "url":"/wiki/Graphs-Hand-Made-Graph.html"
      }
      ,
    
      "wiki-graphs-multigraph-html": {
        "title": "Multigraph",
        "content": "MultigraphAuthor : Patrick TaillandierThis model shows how to build a graph on which people agents will move with GIS Shapefile, but also to generate an other graph representing the friendship between the people agents, people agents trying to be closer spatially to each otherCode of the model :model multigraphglobal {\tfile shape_file_in &lt;- file('../includes/road.shp') ;\tfile shape_file_bounds &lt;- file('../includes/bounds.shp') ;\tgeometry shape &lt;- envelope(shape_file_bounds);\t\t//spatial graph representing the road network\tgraph road_graph; \t\t//social graph (not spatial) representing the frienship links between people\tgraph friendship_graph &lt;- graph([]);\t\tinit {\t\tcreate road from: shape_file_in;\t\t\t\t//creation of th road graph from the road agents\t\troad_graph &lt;- as_edge_graph(road);\t\t\t\t//creation of 50 people agent, and add each people agent as a node in the friendship graph\t\tcreate people number: 50 {\t\t\tadd node(self) to: friendship_graph;\t\t}\t\t\t\t//creation of 50 friendship link between people agents\t\tloop times: 50 {\t\t\tpeople p1 &lt;- one_of(people);\t\t\tpeople p2 &lt;- one_of(list(people) - p1);\t\t\tcreate friendship_link  {\t\t\t\tadd edge (p1, p2, self) to: friendship_graph;\t\t\t\tshape &lt;- link(p1,p2);\t\t\t}\t\t}\t}}species people skills: [moving]{\tpoint location &lt;- any_location_in(one_of(road));\tpeople target_people &lt;- one_of(people);\tpoint target &lt;- target_people.location;\tfloat size &lt;- 3.0;\t\t//action that make recompute the size of the agents as the distance between it and its target people in the friendship graph (the farthest, the biggest)\taction updateSize {\t\tpath friendship_path &lt;- path_between(friendship_graph,self,target_people);\t\tif (friendship_path != nil) {\t\t\tsize &lt;-max([2,length( friendship_path.edges)]) as float;\t\t}\t}\t\t//the agent moves toward its target, when reaching it, it chooses another target as the location of one of the people agent\treflex movement {\t\tif (location distance_to target &lt; 5.0) {\t\t\ttarget_people &lt;- one_of(people);\t\t\ttarget &lt;- target_people.location;\t\t\tdo updateSize;\t\t}\t\tdo goto on:road_graph target:target speed:1 + rnd(2);\t}\taspect default {\t\tdraw circle(size) color: #red;\t}\t}\tspecies friendship_link {\t\taspect default {\t\tdraw shape color: #blue;\t}}\tspecies road  {\taspect default {\t\tdraw shape color:#black ;\t}} experiment multigraph type: gui {\toutput {\t\tdisplay friendship type: opengl{\t\t\tspecies road ;\t\t\tspecies friendship_link ;\t\t\tspecies people;\t\t}\t}}",
        "url":"/wiki/Graphs-Multigraph.html"
      }
      ,
    
      "wiki-graphs-shortest-paths-html": {
        "title": "ShortestPath",
        "content": "ShortestPathAuthor : Patrick TaillandierThis model shows how get the shortest path from one point to another on a graph. The experiment proposes two displays : one to show the shortest path, an other to show the first k shortest paths.Code of the model :model ShortestPathglobal {\tfile shape_file_in &lt;- file('../includes/road.shp') ;\tfile shape_file_bounds &lt;- file('../includes/bounds.shp') ;\tgeometry shape &lt;- envelope(shape_file_bounds);\tgraph road_graph; \tpoint source;\tpoint target;\tpath shortest_path;\tlist&lt;path&gt; k_shortest_paths;\tint k &lt;- 3; \tlist&lt;rgb&gt; colors &lt;- [#red,#green,#blue,#pink,#cyan,#magenta,#yellow];\tbool save_shortest_paths &lt;- false;\tbool load_shortest_paths &lt;- false;\tstring shortest_paths_file &lt;- \"../includes/shortest_paths.csv\";\t\tinit {\t\tcreate road from: shape_file_in;\t\troad_graph &lt;- as_edge_graph(road);\t\t\t\t//computes all the shortest paths, puts them in a matrix, then saves the matrix in a file\t\tif save_shortest_paths {\t\t\tmatrix ssp &lt;- all_pairs_shortest_path(road_graph);\t\t\twrite \"Matrix of all shortest paths: \" + ssp;\t\t\tsave ssp type:\"text\" to:shortest_paths_file;\t\t\t\t\t//loads the file of the shortest paths as a matrix and uses it to initialize all the shortest paths of the graph\t\t} else if load_shortest_paths {\t\t\troad_graph &lt;- road_graph load_shortest_paths matrix(file(shortest_paths_file));\t\t}\t}\t\treflex compute_shortest_paths {\t\tsource &lt;- point(one_of(road_graph.vertices));\t\ttarget &lt;- point(one_of(road_graph.vertices));\t\tif (source != target) {\t\t\tshortest_path &lt;- path_between (road_graph, source,target);\t\t\tk_shortest_paths &lt;- list&lt;path&gt;(paths_between(road_graph,source::target,k));\t\t\t}\t}}species road  {\taspect base {\t\tdraw shape color: #black ;\t} }experiment ShortestPath type: gui {\tparameter \"number of shortest paths (k)\" var: k min: 1 max: 7;\tparameter \"Computed all the shortest paths and save the results\" var: save_shortest_paths;\tparameter \"Load the shortest paths from the file\" var: load_shortest_paths;\t\toutput {\t\tdisplay map_shortest_path {\t\t\tspecies road aspect: base;\t\t\tgraphics \"shortest path\" {\t\t\t\tif (shortest_path != nil) {\t\t\t\t\tdraw circle(5) at: source color: #green;\t\t\t\t\tdraw circle(5) at: target color: #cyan;\t\t\t\t\tdraw (shortest_path.shape + 2.0) color: #magenta;\t\t\t\t}\t\t\t}\t\t}\t\tdisplay map_k_shortest_paths {\t\t\tspecies road aspect: base;\t\t\tgraphics \"k shortest paths\" {\t\t\t\tif (shortest_path != nil) {\t\t\t\t\tdraw circle(5) at: source color: #green;\t\t\t\t\tdraw circle(5) at: target color: #cyan;\t\t\t\t\tloop i from: 0 to: length(k_shortest_paths) - 1{\t\t\t\t\t\tdraw ((k_shortest_paths[i]).shape + 2.0) color: colors[i];\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t}}",
        "url":"/wiki/Graphs-Shortest-paths.html"
      }
      ,
    
      "wiki-graphs-html": {
        "title": "Graphs",
        "content": "GraphsThis sub-section is composed of the following models :      3D Graph        Graph Generation        Graph Generation using Agents        Graph from DGS File and Layout Changed        Graph Operators        Hand Made Graph        Multigraph        ShortestPath  ",
        "url":"/wiki/Graphs.html"
      }
      ,
    
      "wiki-gridspecies-html": {
        "title": "Grid Species",
        "content": "Grid SpeciesA grid is a particular species of agents. Indeed, a grid is a set of agents that share a grid topology (until now, we only saw species with continuous topology). As other agents, a grid species can have attributes, attributes, behaviors, aspectsHowever, contrary to regular species, grid agents are created automatically at the beginning of the simulation. It is thus not necessary to use the create statement to create them.Moreover, in addition to classic built-in variables, grid a provided with a set of additional built-in variables.Index  Declaration  Built-in attributes  Access to cells  Display grid  Grid with matrix  ExampleDeclarationInstead of using the species keyword, use the keyword grid to declare a grid species. The grid species has exactly the same facets of the regular species, plus some others.To declare a grid, you have to specify the number of columns and rows first. You can do it two different ways:Using the two facets width: and height: to fix the number of cells (the size of each cells will be determined thanks to the environment dimension).grid my_grid width:8 height:10 {// my_grid has 8 columns and 10 rows}Using the two facets cell_width: and cell_height: to fix the size of each cells (the number cells will be determined thanks to the environment dimension).grid my_grid cell_width:3 cell_height:2 {// my_grid has cells with dimension 3m width by 2m height}By default, a grid is composed by 100 rows and 100 columns.Another facet exists for grid only, very useful. It is the neighbors facet, used to determine how many neighbors has each cell. You can choose among 3 values: 4 (Von Neumann), 6 (hexagon) or 8 (Moore).A grid can also be provided with specific facets that allows to optimize the computation time and the memory space, such as use_regular_agents, use_indivitual_shapes and use_neighbours_cache. Please refer to the GAML Reference for more explanation about those particular facets.Built-in attributesgrid_xThis variable stores the column index of a cell.   grid cell width: 10 height: 10 neighbors: 4 {        init {             write \"my column index is:\" + grid_x;        }   }grid_yThis variable stores the row index of a cell.   grid cell width: 10 height: 10 neighbors: 4 {        init {             write \"my row index is:\" + grid_y;        }   }agentsreturn the set of agents located inside the cell. Note the use of this variable is deprecated.It is preferable to use the inside operator://: # (keyword|operator_inside) grid cell width: 10 height: 10 neighbors: 4 {         list&lt;bug&gt; bugs_inside -&gt; {bug inside self};   }colorThe color built-in variable is used by the optimized grid display. Indeed, it is possible to use for grid agents an optimized aspect by using in a display the grid keyword. In this case, the grid will be displayed using the color defined by the color variable. The border of the cells can be displayed with a specific color by using the lines facet.Here an example of the display of a grid species named cell with black border.experiment main_xp type: gui{\toutput {\t\tdisplay map {\t\t\tgrid cell lines: rgb(\"black\") ;\t\t}\t}}neighborsThe neighbors built-in variable returns the list of cells at a distance of 1.grid my_grid {  reflex writeNeighbors {    write neighbors;  }}grid_valueThe grid_value built-in variable is used when initializing a grid from grid file (see later). It is also used for the 3D representation of DEM.Access to a cellthere are several ways to access to a specific cell:  by a location: by casting a location to a cell (the unity (#m, #cm, etc…) is defined when you choose your environment size, in the global species.   global {         init {             write \"cell at {57.5, 45} :\" + cell({57.5, 45});         }   }   grid cell width: 10 height: 10 neighbors: 4 {   }  by the row and column indexes: like matrix, it is possible to directly access to a cell from its indexes   global {         init {             write \"cell [5,8] :\" + cell[5,8];         }   }   grid cell width: 10 height: 10 neighbors: 4 {   }The operator grid_at also exists to get a particular cell. You just have to specify the index of the cell you want (in x and y):   global {         init {             agent cellAgent &lt;- cell grid_at {5,8};             write \"cell [5,8] :\" + cellAgent;         }   }   grid cell width: 10 height: 10 neighbors: 4 {   }Display GridYou can easily display your grid in your experiment as followed :experiment MyExperiment type: gui {    output {        display MyDisplay type: opengl {            grid MyGrid;        }    }}The grid will be displayed, using the color you defined for each cell (with the “color” built-in attribute). You can also show border of each cell by using the facet “line:” and choosing a rgb color:grid MyGrid line:#black;An other way to display a grid will be to define an aspect in your grid agent (the same way as for a regular species), and define your grid as a regular species then in your experiment, choosing your aspect :grid MyGrid {    aspect firstAspect {        draw square(1);    }    aspect secondAspect {        draw circle(1);    }}experiment MyExperiment type: gui {    output {        display MyDisplay type: opengl {            species MyGrid aspect:firstAspect;        }    }}Beware : don’t use this second display when you have large grids : it’s much slower.Grid from a matrixAn easy way to load some values in a grid is to use matrix data. A matrix is a type of container (we invite you to learn some more about this useful type here). Once you have declared your matrix, you can set the values of your cells using the ask statement :global {  init {    matrix data &lt;- matrix([[0,1,1],[1,2,0]]);    ask cell {      grid_value &lt;- float(data[grid_x, grid_y]);    }   }}Declaring larger matrix in GAML can be boring as you can imagine. You can load your matrix directly from a csv file with the operator matrix (used for the contruction of the matrix).file my_file &lt;- csv_file(\"path/file.csv\",\"separator\");matrix my_matrix &lt;- matrix(my_file);You can try to read the following csv :0,0,0,0,0,0,0,0,0,0,00,0,0,1,1,1,1,1,0,0,00,0,1,1,0,0,0,1,1,0,00,1,1,0,0,0,0,0,0,0,00,1,1,0,0,1,1,1,1,0,00,0,1,1,0,0,1,1,1,0,00,0,0,1,1,1,1,0,1,0,00,0,0,0,0,0,0,0,0,0,0With the following model :model import_csvglobal {  file my_csv_file &lt;- csv_file(\"../includes/test.csv\",\",\");  init {    matrix data &lt;- matrix(my_csv_file);    ask my_gama_grid {      grid_value &lt;- float(data[grid_x,grid_y]);      write data[grid_x,grid_y];    }  }}grid my_gama_grid width: 11 height: 8 {  reflex update_color {    write grid_value;    color &lt;- (grid_value = 1) ? #blue : #white;  }}experiment main type: gui{  output {    display display_grid {      grid my_gama_grid;    }  }}For more complicated models, you can read some other files, such as ASCII files (asc), DEM files…            //: # (endConcept      grid)      ExampleTo practice a bit those notions, we will build a quick model. A “regular” species will move randomly on the environment. A grid is displayed, and its cells becomes red when an instance of the regular species is waking inside this cell, and yellow when the regular agent is in the surrounding of this cell. If no regular agent is on the surrounding, the cell turns green.Here is an example of implementation:model my_grid_modelglobal{\tfloat max_range &lt;- 5.0;\tint number_of_agents &lt;- 5;\tinit {\t\tcreate my_species number:number_of_agents;\t}\treflex update {\t\task my_species {\t\t\tdo wander amplitude:180;\t\t\t\task my_grid at_distance(max_range)\t\t\t{\t\t\t\tif(self overlaps myself)\t\t\t\t{\t\t\t\t\tself.color_value &lt;- 2;\t\t\t\t}\t\t\t\telse if (self.color_value != 2)\t\t\t\t{\t\t\t\t\tself.color_value &lt;- 1;\t\t\t\t}\t\t\t}\t\t}\t\task my_grid {\t\t\tdo update_color;\t\t}\t\t}}species my_species skills:[moving] {\tfloat speed &lt;- 2.0;\taspect default {\t\tdraw circle(1) color:#blue;\t}}grid my_grid width:30 height:30 {\tint color_value &lt;- 0;\taction update_color {\t\tif (color_value = 0) {\t\t\tcolor &lt;- #green;\t\t}\t\telse if (color_value = 1) {\t\t\tcolor &lt;- #yellow;\t\t}\t\telse if (color_value = 2) {\t\t\tcolor &lt;- #red;\t\t}\t\tcolor_value &lt;- 0;\t}}experiment MyExperiment type: gui {    output {        display MyDisplay type: java2D {            grid my_grid lines:#black;            species my_species aspect:default;         }    }}",
        "url":"/wiki/GridSpecies.html"
      }
      ,
    
      "wiki-headless-mode-for-dummies-html": {
        "title": "Overview",
        "content": "OverviewThis tutorial presents the headless mode usage of GAMA. We will execute the Predator-Prey model, already presented in this tutorial.Headless mode is documented here, with the same model as an example. Here, we focus on the definition of an experiment plan, where the model is run several times. We only consider the shell script execution, not the java command execution.In headless-mode, GAMA can be seen as any shell command, whose behavior is controlled by passing arguments to it.You must provide 2 arguments :  an **input experiment file **, used to describe the execution plan of your model, its inputs and the expected outputs.  an ** output directory **, where the results of the execution are storedHeadless-mode is a little bit more technical to handle than the general GAMA use-case, and the following commands and code have been solely tested on a Linux Ubuntu 15.04 machine, x86_64 architecture, with kernel 3.19.0-82-generic.Java version is 1.8.0_121 (java version “1.8.0_121”)You may have to perform some adjustments (such as paths definition) according to your machine, OS, java and GAMA versions and so on.SetupGAMA versionHeadless mode is frequently updated by GAMA developers, so you have to get the very latest build version of GAMA. You can download it here  https://github.com/gama-platform/gama/releases Be sure to pick the ** Continuous build **  version (The name looks like GAMA1.7_Linux_64_02.26.17_da33f5b.zip) and ** not ** the major release, e.g. GAMA1.7_Linux_64.zip.gama-headless.sh script setupThe gama-headless.sh script can be found under the headless directory, in GAMA installation directory e.g. : `~/GAMA/headless/Modifying the script (a little bit)The original script looks like this :#! /bin/bashmemory=2048mdeclare -i i\ti=0echo ${!i}\tfor ((i=1;i&lt;=$#;i=$i+1))doif test ${!i} = \"-m\"then    i=$i+1    memory=${!i}else    PARAM=$PARAM\\ ${!i}    i=$i+1    PARAM=$PARAM\\ ${!i}fidone\techo \"******************************************************************\"echo \"* GAMA version 1.7.0 V7                                          *\"echo \"* http://gama-platform.org                                       *\"echo \"* (c) 2007-2016 UMI 209 UMMISCO IRD/UPMC &amp; Partners              *\"echo \"******************************************************************\"passWork=.work$RANDOM\tjava -cp ../plugins/org.eclipse.equinox.launcher*.jar -Xms512m -Xmx$memory  -Djava.awt.headless=true org.eclipse.core.launcher.Main  -application msi.gama.headless.id4 -data $passWork $PARAM $mfull $outputFilerm -rf $passWorkNotice the final command of the script rm -rf $passWork. It is intended to remove the temporary file used during the execution of the script. For now, we should comment this commmand, in order to check the logs if an error appears : #rm -rf $passWorkSetting the experiment fileHeadless mode uses a XML file to describe the execution plan of a model. An example is given in the headless mode documentation page.The script looks like this :** N.B. this version of the script, given as an example, is deprecated**&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;Experiment_plan&gt;&lt;Simulation id=\"2\" sourcePath=\"./predatorPrey/predatorPrey.gaml\" finalStep=\"1000\" experiment=\"predPrey\"&gt;\t&lt;Parameters&gt;\t\t&lt;Parameter name=\"nb_predator_init\" type=\"INT\" value=\"53\" /&gt;\t\t&lt;Parameter name=\"nb_preys_init\" type=\"INT\" value=\"621\" /&gt;\t&lt;/Parameters&gt;\t&lt;Outputs&gt;\t\t&lt;Output id=\"1\" name=\"main_display\" framerate=\"10\" /&gt;\t\t&lt;Output id=\"2\" name=\"number_of_preys\" framerate=\"1\" /&gt;\t\t&lt;Output id=\"3\" name=\"number_of_predators\" framerate=\"1\" /&gt;\t\t&lt;Output id=\"4\" name=\"duration\" framerate=\"1\" /&gt;\t&lt;/Outputs&gt;&lt;/Simulation&gt;&lt;/Experiment_plan&gt;As you can see, you need to define 3 things in this minimal example :  Simulation:  its id, path to the model , finalStep (or stop condition), and name of the experiment  Parameters name, of the model for * this * simulation (i.e. Simulation of id= 2)  Outputs of the model: their id, name, type, and the rate (expressed in cycles) at which they are logged in the results file during the simulationWe now describe how to constitute your experiment file.Experiment File : SimulationidFor now, we only consider one single execution of the model, so the simulation id is not critical, let it unchanged.Later example will include different simulations in the same experiment file.Simulation id is a string. Don’t introduce weird symbols into it.sourcePathsourcePath is the relative (or absolute) path to the model file you want to execute headlessly.Here we want to execute the fourth model of the Predator Prey tutorial suite, located in ~/GAMA/plugins/msi.gama.models_1.7.0.XXXXXXXXXXXX/models/Tutorials/Predator Prey/models (with XXXXXXXXXXXX replaced by the number of the release you downloaded)So we set sourcePath=”../plugins/msi.gama.models_1.7.0.201702260518/models/Tutorials/Predator Prey/models/Model 07.gaml”  (Remember that the headless script is located in ~/GAMA/headless/)Depending on the directory you want to run the gama-headless.sh script, sourcePath must me modified accordingly.Another workaround for shell more advanced users is to define a  $GAMA_PATH, $MODEL_PATH and $OUPUT_PATH in gama-headless.sh script.Don’t forget the quotes \" around your path.finalStepThe duration, in cycles, of the simulation.experimentThis is the name of (one of) the experiment statement at the end of the model code.In our case there is only one, called prey_predator and  it looks like this :experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: base ;\t\t}\t\tmonitor \"Number of preys\" value: nb_preys ;\t}}  So we are now able to constitute the entire Simulation tag :&lt;Simulation id=\"2\" sourcePath=\"~/GAMA/plugins/msi.gama.models_1.7.0.201702260518/models/Tutorials/Predator Prey/models/Model 01.gaml\" finalStep=\"1000\" experiment=\"prey_predator\"&gt;N.B. the numbers after msi.gama.models (the number of your GAMA release actually) have to be adapted to your own release of GAMA number.The path to the GAMA installation directory has also to be adapted of course.Experiment File : ParametersThe parameters section of the experiment file describes the parameters names, types and values to be passed to the model for its execution.Let’s say we want to fix the number of preys and their max energy  for this simulation.We look at the experiment section of the model code and use their ** title **. The title of a parameter is the name that comes right after the parameter statement. In our case,  the strings “Initial number of preys: “ and “Prey max energy: “ (Mind the spaces, quotes and colon)The parameters section of the file would look like :&lt;Parameters&gt;\t&lt;Parameter name=\"Initial number of preys: \" type=\"INT\" value=\"621\" /&gt;\t&lt;Parameter name=\"Prey max energy: \" type=\"FLOAT\" value=\"1.0\" /&gt;&lt;/Parameters&gt;Any declared parameter can be set this way, yet you don’t have to set all of them, provided they are initialized with a default value in the model (see the global statement part of the model code).Experiment File : OutputsOutput section of the experiment file is pretty similar to the previous one, except for the id that have to be set for each of the outputs .We can log some of the declared outputs  : main_display and number_of_preys.The outputs section would look like the following:&lt;Outputs&gt;\t&lt;Output id=\"1\" name=\"main_display\" framerate=\"10\" /&gt;\t&lt;Output id=\"2\" name=\"Number of preys\" framerate=\"1\" /&gt;&lt;/Outputs&gt;Outputs must have an id, a name, and a framerate.  id is a number that identifies the output  framerate is the rate at which the output is written in the result file. It’s a number of cycle of simulation (integer). In this example the display is saved every 10 cycle  name is either the “title” of the corresponding monitor. In our case, the second output’s is the title of the monitor \"Number of preys\", i.e. “Number of preys”We also save a **display ** output, that is an image of the simulation graphical display named main_display in the code of the model. Theses images is what you would have seen if you had run the model in the traditional GUI mode.Execution and resultsOur new version of the experiment file is ready :\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tExecutionWe have to launch the gama-headless.sh script and provide two arguments : the experiment file we just completed and the path of a directory where the results will be written.** Warning ** In this example ,we are lazy and define the source path as the absolute path to the model we want to execute. If you want to use a relative path, note that it has to be define relatively to the location of your ** ExperimentFile.xml location ** (and the location where you launched the script)In a terminal, position yourself in the headless directory : `~/GAMA/headless/’.Then type the following command :bash gama-headless.sh -v ~/a/path/to/MyExperimentFile.xml  /path/to/the/desired/output/directory  And replace paths by the location of your ExperimentFile and output directoryYou should obtain the following output in the terminal :******************************************************************* GAMA version 1.7.0 V7                                          ** http://gama-platform.org                                       ** (c) 2007-2016 UMI 209 UMMISCO IRD/UPMC &amp; Partners              *******************************************************************&gt;GAMA plugin loaded in 2927 ms: \tmsi.gama.core&gt;GAMA plugin loaded in 67 ms: \tummisco.gama.network&gt;GAMA plugin loaded in 56 ms: \tsimtools.gaml.extensions.traffic&gt;GAMA plugin loaded in 75 ms: \tsimtools.gaml.extensions.physics&gt;GAMA plugin loaded in 1 ms: \tirit.gaml.extensions.test&gt;GAMA plugin loaded in 75 ms: \tummisco.gaml.extensions.maths&gt;GAMA plugin loaded in 47 ms: \tmsi.gaml.extensions.fipa&gt;GAMA plugin loaded in 92 ms: \tummisco.gama.serialize&gt;GAMA plugin loaded in 49 ms: \tirit.gaml.extensions.database&gt;GAMA plugin loaded in 2 ms: \tmsi.gama.lang.gaml&gt;GAMA plugin loaded in 1 ms: \tmsi.gama.headless&gt;GAMA plugin loaded in 103 ms: \tummisco.gama.java2d&gt;GAMA plugin loaded in 189 ms: \tmsi.gaml.architecture.simplebdi&gt;GAMA plugin loaded in 129 ms: \tummisco.gama.opengl&gt;GAMA building GAML artefacts&gt;GAMA total load time 4502 ms. in 714 mscpus :8Simulation is running.......................................................................................................Simulation duration: 7089msResultsThe results are stored in the output directory you provided as the second argument of the script.3 items have appeared :  A console_output.txt file, containing the output of the GAMA console of the model execution if any  a XML file simulation-outputXX.xml, where XX is the id number of your simulation. In our case it should be 2.  the folder snapshots containing the screenshots coming from the second declared output : main_display. image name format is main_display[id]_[cycle].png.The values of the monitor “Number of preys” are stored in the xml file simulation-outputXX.xmlCommon error messagesException in thread \"Thread-7\" No parameter named prey_max_energy in experiment prey_predatorProbably a typo in the name or the title of a parameter. check spaces, capital letters, symbols and so on.java.io.IOException: Model file does not exist: /home/ubuntu/dev/tutoGamaHeadless/../plugins/msi.gama.models_1This may be a relative path mistake; try with absolute path.java.lang.NumberFormatException: For input string: “1.0”This may be a problem of type declaration in the parameter section.Going furtherExperiments of several simulationYou can launch several simulation by replicating the simulation declaration in your ExperimentFile.xml and varying the values of the parameters.Since you will have to edit the experiment file by hand, you should do that only for a reasonable number of simulations (e.g. &lt;10 )Design of experiments plansFor more systematic parameter values samples, you should turn towards a more adapted tool such as GAMAR, to generate a ExperimentFile.xml with a huge number of simulations.",
        "url":"/wiki/Headless-mode-for-dummies.html"
      }
      ,
    
      "wiki-headless-html": {
        "title": "Headless Mode",
        "content": "Headless ModeThe aim of this feature is to be able to run one or multiple instances of GAMA without any user interface, so that models and experiments can be launched on a grid or a cluster. Without GUI, the memory footprint, as well as the speed of the simulations, are usually greatly improved.In this mode, GAMA can only be used to run experiments and that editing or managing models is not possible. In order to launch experiments and still benefit from a user interface (which can be used to prepare headless experiments), launch GAMA normally (see here) and refer to this page for instructions.Table of contents  Headless Mode          Command                  Shell Script          Java Command                    Experiment Input File                  Heading          Parameters          Outputs                    Output Directory      Simulation Output                  Step          Variable                    Snapshot files      CommandThere are two ways to run a GAMA experiment in headless mode: using a dedicated shell script (recommended) or directly from the command line. These commands take 2 arguments: an experiment file and an output directory.Shell ScriptIt can be found in the headless directory located inside Gama. Its name is gama-headless.sh on MacOSX and Linux, and gama-headless.bat on Windows. sh gama-headless.sh [m/c/t/hpc/v] $1 $2  with:          $1 input parameter file : an xml file determining experiment parameters and attended outputs      $2 output directory path : a directory which contains simulation results (numerical data and simulation snapshot)      options [-m/c/t/hpc/v]                  -m memory : memory allocated to gama          -c : console mode, the simulation description could be written with the stdin          -t : tunneling mode, simulation description are read from the stdin, simulation results are printed out in stdout          -hpc nb_of_cores : allocate a specific number of cores for the experiment plan          -v : verbose mode. trace are displayed in the console                      For example (using the provided sample), navigate in your terminal to the GAMA root folder and type :sh headless/gama-headless.sh headless/samples/predatorPrey.xml outputHeadLessAs specified in predatorPrey.xml, this command runs the prey - predator model for 1000 steps and record a screenshot of the main display every 5 steps. The screenshots are recorded in the directory outputHeadLess (under the GAMA root folder).Not that the current directory to run gama-headless command must be $GAMA_PATH/headlessJava Commandjava -cp $GAMA_CLASSPATH -Xms512m -Xmx2048m -Djava.awt.headless=true org.eclipse.core.launcher.Main -application msi.gama.headless.id4 $1 $2  with:          $GAMA_CLASSPATH gama classpath: contains relative or absolute path of jars inside the gama plugin directory and jars created by users      $1 input parameter file: an xml file determining experiment parameters and attended outputs      $2 output directory path: a directory which contains simulation results (numerical data and simulation snapshot)      Note that the output directory is created during the experiment and should not exist before.Experiment Input FileThe XML input file contains for example:&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;Experiment_plan&gt; &lt;Simulation id=\"2\" sourcePath=\"./predatorPrey/predatorPrey.gaml\" finalStep=\"1000\" experiment=\"predPrey\"&gt;  &lt;Parameters&gt;    &lt;Parameter name=\"nb_predator_init\" type=\"INT\" value=\"53\" /&gt;    &lt;Parameter name=\"nb_preys_init\" type=\"INT\" value=\"621\" /&gt;  &lt;/Parameters&gt;  &lt;Outputs&gt;    &lt;Output id=\"1\" name=\"main_display\" framerate=\"10\" /&gt;    &lt;Output id=\"2\" name=\"number_of_preys\" framerate=\"1\" /&gt;    &lt;Output id=\"3\" name=\"number_of_predators\" framerate=\"1\" /&gt;    &lt;Output id=\"4\" name=\"duration\" framerate=\"1\" /&gt;  &lt;/Outputs&gt; &lt;/Simulation&gt;&lt;/Experiment_plan&gt;Note that several simulations could be determined in one experiment plan. These simulations are run in parallel according to the number of allocated cores.Heading&lt;Simulation id=\"2\" sourcePath=\"./predatorPrey/predatorPrey.gaml\" finalStep=\"1000\" experiment=\"predPrey\"&gt;  with:          id: permits to prefix output files for experiment plan with huge simulations.      sourcePath: contains the relative or absolute path to read the gaml model.      finalStep: determines the number of simulation step you want to run.      experiment: determines which experiment should be run on the model. This experiment should exist, otherwise the headless mode will exit.      ParametersOne line per parameter you want to specify a value to:&lt;Parameter name=\"nb_predator_init\" type=\"INT\" value=\"53\" /&gt;  with:          name:  name of the parameter in the gaml model      type:  type of the parameter (INT, FLOAT, BOOLEAN, STRING)      value: the chosen value      OutputsOne line per output value you want to retrieve. Outputs can be names of monitors or displays defined in the ‘output’ section of experiments, or the names of attributes defined in the experiment or the model itself (in the ‘global’ section).    ... with the name of a monitor defined in the 'output' section of the experiment...    &lt;Output id=\"2\" name=\"number_of_preys\" framerate=\"1\" /&gt;    ... with the name of a (built-in) variable defined in the experiment itself...    &lt;Output id=\"4\" name=\"duration\" framerate=\"1\" /&gt;  with:          name : name of the output in the ‘output’/’permanent’ section in the experiment or name of the experiment/model attribute to retrieve      framerate : the frequency of the monitoring (each step, each 2 steps,  each 100 steps…).        Note that :          the lower the framerate value the longer the experiment.      if the chosen output is a display, an image is produced and the output file contains the path to access this image      Output DirectoryDuring headless experiments, a directory is created with the following structure:Outputed-directory-path/    |-simulation-output.xml    |- snapshot          |- main_display2-0.png          |- main_display2-10.png          |- ...  with:          simulation-output.xml: containing the results      snapshot: containing the snapshots produced during the simulation      Is it possible to change the output directory for the images by adding the attribute “output_path” in the xml :If we write &lt;Output id=\"1\" name=\"my_display\" file:\"/F:/path/imageName\" framerate=\"10\" /&gt;, then the display “my_display” will have the name “imageName-stepNb.png” and will be written in the folder “/F:/path/”Simulation OutputA file named simulation-output.xml is created with the following contents when the experiment runs.&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;Simulation id=\"2\" &gt;\t&lt;Step id='0' &gt;\t\t&lt;Variable name='main_display' value='main_display2-0.png'/&gt;\t\t&lt;Variable name='number_of_preys' value='613'/&gt;\t\t&lt;Variable name='number_of_predators' value='51'/&gt;                &lt;Variable name='duration' value='6' /&gt;\t&lt;/Step&gt;\t&lt;Step id='1' &gt;\t\t&lt;Variable name='main_display' value='main_display2-0.png'/&gt;\t\t&lt;Variable name='number_of_preys' value='624'/&gt;\t\t&lt;Variable name='number_of_predators' value='51'/&gt;                &lt;Variable name='duration' value='5' /&gt;\t&lt;/Step&gt;        &lt;Step id='2'&gt;...  With:          &lt;Simulation id=\"2\" &gt; : block containing results of the simulation 2 (this Id is identified in the Input Experiment File)      &lt;Step id='1' &gt; ... &lt;/Step&gt;: one block per step done. The id corresponds to the step number      Step\t&lt;Step id='1' &gt;\t\t&lt;Variable name='main_display' value='main_display2-0.png'/&gt;\t\t&lt;Variable name='number_of_preys' value='624'/&gt;\t\t&lt;Variable name='number_of_predators' value='51'/&gt;                &lt;Variable name='duration' value='6' /&gt;\t&lt;/Step&gt;There is one Variable block per Output identified in the output experiment file.Variable &lt;Variable name='main_display' value='main_display2-0.png'/&gt;  with:          name: name of the output, the model variable      value: the current value of model variable.      Note that the value of an output is repeated according to the framerate defined in the input experiment file.Snapshot filesThis directory contains images generated during the experiment. There is one image per displayed output per step (according to the framerate). File names follow a naming convention, e.g:   [outputName][SimulationID]_[stepID].png -&gt; main_display2-20.pngNote that images are saved in ‘.png’ format.",
        "url":"/wiki/Headless.html"
      }
      ,
    
      "wiki-home-html": {
        "title": "Multiple application domains",
        "content": "The new website of GAMA is now available at this address : gama-platform.orgGAMA is a modeling and simulation development environment for building spatially explicit agent-based simulations.  Multiple application domains : Use GAMA for whatever application domain you want.  High-level and Intuitive Agent-based language : Write your models easily using GAML, a high-level and intuitive agent-based language.  GIS and Data-Driven models : Instantiate agents from any dataset, including GIS data, and execute large-scale simulations (up to millions of agents).  Declarative user interface : Declare interfaces supporting deep inspections on agents, user-controlled action panels, multi-layer 2D/3D displays &amp; agent aspects.Its latest version, 1.7, can be freely downloaded or built from source, and comes pre-loaded with several models, tutorials and a complete on-line documentation.Multiple application domainsGAMA has been developed with a very general approach, and can be used for many application domains. Some additional plugins had been developed to fit with particular needs.Example of application domains where GAMA is mostly present :  Transport  Urban planning  Epidemiology  EnvironmentSome training sessions about topics such as “urban management”, “epidemiology”, “risk management” are also provided by the team.Since GAMA is an open-source software that continues to grow, if you have any particular needs of improvement, feel free to share it to its active community !High level and intuitive languageThanks to its high-level and intuitive language, GAMA has been developed to be used by non-computer scientists. You can declare your species, giving them some special behaviors, create them in your world, and display them in less than 10 minutes.GAML is the language used in GAMA, coded in Java. It is an agent-based language, that provides you the possibility to build your model with several paradigms of modeling. Once your model is ready, some features allows you to explore and calibrate it, using the parameters you defined as input of your simulation.We provides you a continual support through the active mailing list where the team will answer your questions. Besides, you can learn GAML on your own, following the step by step tutorial, or personal learning path in order reach the point you are interested in.GIS and Data-Driven modelsGAMA (GIS Agent-based Modeling Architecture) provides you, since its creation, the possibility to load easily GIS (Geographic Information System).You can import a large number of data types, such as text, files, CSV, shapefile, OSM (open street map data), grid, images, SVG, but also 3D files, such as 3DS or OBJ, with their texture.Some advanced features provides you the possibility to connect GAMA to databases, and also to use powerful statistical tools such as R.GAMA has been used in large-scale projects, using a great number of agents (up to millions of agents).Declarative user interfaceGAMA provides you the possibility to have multiple displays for the same model. You can add as much visual representations as you want for the same model, in order to highlight a certain aspect of your simulation. Add easily new visual aspects to your agents.Advanced 3D displays are provided : you can control lights, cameras, and also adding textures to your 3D objects. In an other hand, dedicated statements allows you to define easily charts, such as series, histogram, or pies.During the simulations, some advanced features are available to inspect the population of your agents. To make your model more interactive, you can add easily some user-controlled action panels, or mouse events.GAMA is developed by several teams under the umbrella of the IRD/UPMC international research unit UMMISCO:  MSI Research Team, Vietnam National University, Hanoi, Vietnam (2007 - 2015)  UMR 6228 IDEES, CNRS/University of Rouen, France (2010 - 2015)  UMR 5505 IRIT, CNRS/University of Toulouse 1, France (2010 - 2015)  DREAM Research Team, University of Can Tho, Vietnam (2011 - 2015)  UMR 8623 LRI, CNRS/University Paris-Sud, France (2011 - 2015)Acknowledgement:YourKit supports open source projects with its full-featured Java Profiler.YourKit, LLC is the creator of YourKit Java Profilerand YourKit .NET Profiler,innovative and intelligent tools for profiling Java and .NET applications.",
        "url":"/wiki/Home.html"
      }
      ,
    
      "wiki-importingmodels-html": {
        "title": "Importing Models",
        "content": "Importing ModelsImporting a model refers to making a model file (or a complete project) available for edition and experimentation in the workspace. With the exception of headless experiments, GAMA requires that models be manageable in the current workspace to be able to validate them and eventually experiment them.There are many situations where a model needs to be imported by the user: someone sent it to him/her by mail, it has been attached to an issue report, it has been shared on the web or an SVN server, or it belongs to a previous workspace after the user has switched workspace. The instructions below apply equally to all these situations.Since model files need to reside in a project to be managed by GAMA, it is usually preferable to import a whole project rather than individual files (unless, of course, the corresponding models are simple enough to not require any additional resources, in which case, the model file can be imported with no harm into an existing project). GAMA will then try to detect situations where a model file is imported alone and, if a corresponding project can be found (for instance, in the upper directories of this file), to import the project instead of the file. As the last resort, GAMA will import orphan model files into a generic project called “Unclassified Models” (which will be created if it does not exist yet).Table of contents  Importing Models          The “Import…” Menu Command      Silent import      Drag’n Drop / Copy-Paste Limitations      The “Import…” Menu CommandThe simplest, safest and most secure way to import a project into the workspace is to use the built-in “Import…” menu command, available in the “File” menu or in the contextual menu of the Navigator.When invoked, this command will open a dialog asking the user to choose the source of the importation. It can be a directory in the filesystem (in which GAMA will look for existing projects), a zip file, a SVN site, etc. It is safer in any case to choose “Existing Projects into Workspace”.Note that when invoked from the contextual menu, “Import…” will directly give access to a shortcut of this source in a submenu.Both options will lead the user to a last dialog where he/she will be asked to:  Enter a location (or browse to a location) containing the GAMA project(s) to import  Choose among the list of available projects (computed by GAMA) the ones to effectively import  Indicate whether or not these projects need to be copied to or linked from the workspace (the latter is done by default)Silent importAnother (possibly simpler, but less controllable) way of importing projects and models is to either pass a path to a model when launching GAMA from the command line or to double-click on a model file (ending in .gaml) in the Explorer or Finder (depending on your OS).If the file is not already part of an imported project in the current workspace, GAMA will:  silently import the project (by creating a link to it),  open an editor on the file selected.This procedure may fail, however, if a project of the same name (but in a different location) already exists in the workspace, in which case GAMA will refuse to import the project (and hence, the file). The solution in this case is to rename the project to import (or to rename the existing project in the workspace).Drag’n Drop / Copy-Paste LimitationsCurrently, there is no way to drag and drop an entire project into GAMA Navigator (or to copy a project in the filesystem and paste it in the Navigator). Only individual model files, folders or resources can be moved this way (and they have to be dropped or pasted into existing projects).This limitation might be removed some time in the future, however, allowing users to use the Navigator as a project drop or paste target, but it is not the case yet.",
        "url":"/wiki/ImportingModels.html"
      }
      ,
    
      "wiki-incremental-model-incremental-model-1-html": {
        "title": "Simple SI Model",
        "content": "Simple SI ModelFirst part of the tutorial : Incremental ModelCode of the model :model SI_cityglobal{ \tint nb_people &lt;- 500;\tfloat infection_distance &lt;- 2.0 #m;\tfloat proba_infection &lt;- 0.05;\tint nb_infected_init &lt;- 5;\tfloat step &lt;- 1 #minutes;\tgeometry shape&lt;-envelope(square(500 #m));\t\tinit{\t\tcreate people number:nb_people {\t\t\tspeed &lt;- 5.0 #km/#h;\t\t}\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t}\t}species people skills:[moving]{\t\t\tbool is_infected &lt;- false;\treflex move{\t\tdo wander;\t}\treflex infect when: is_infected{\t\task people at_distance infection_distance {\t\t\tif flip(proba_infection) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(5) color:is_infected ? #red : #green;\t}}experiment main_experiment type:gui{\tparameter \"Infection distance\" var: infection_distance;\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\tparameter \"Nb people infected at init\" var: nb_infected_init ;\toutput {\t\tdisplay map {\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t}}",
        "url":"/wiki/Incremental-Model-Incremental-Model-1.html"
      }
      ,
    
      "wiki-incremental-model-incremental-model-2-html": {
        "title": "Charts",
        "content": "ChartsSecond part of the tutorial : Incremental ModelCode of the model :model SI_cityglobal{\tint nb_people &lt;- 500;\tfloat step &lt;- 1 #minutes;\tgeometry shape&lt;-envelope(square(500 #m));\tfloat infection_distance &lt;- 2.0 #m;\tfloat proba_infection &lt;- 0.05;\tint nb_infected_init &lt;- 5;\tint current_hour update: (cycle / 60) mod 24;\tint nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected);\tint nb_people_not_infected &lt;- nb_people - nb_infected_init update: nb_people - nb_people_infected;\tfloat infected_rate update: nb_people_infected/length(people);\t\tinit{\t\tcreate people number:nb_people {\t\t\tspeed &lt;- 5.0 #km/#h;\t\t}\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t}\treflex end_simulation when: infected_rate = 1.0 {\t\tdo halt;\t}}species people skills:[moving]{\t\t\tbool is_infected &lt;- false;\treflex move{\t\tdo wander;\t}\treflex infect when: is_infected{\t\task people at_distance infection_distance {\t\t\tif flip(proba_infection) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(5) color:is_infected ? #red : #green;\t}}experiment main_experiment type:gui{\tparameter \"Infection distance\" var: infection_distance;\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\tparameter \"Nb people infected at init\" var: nb_infected_init ;\toutput {\t\tmonitor \"Current hour\" value: current_hour;\t\tmonitor \"Infected people rate\" value: infected_rate;\t\tdisplay map {\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t\tdisplay chart refresh: every(10) {\t\t\tchart \"Disease spreading\" type: series {\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Incremental-Model-Incremental-Model-2.html"
      }
      ,
    
      "wiki-incremental-model-incremental-model-3-html": {
        "title": "Integration of GIS Data",
        "content": "Integration of GIS Datathird part of the tutorial : Incremental ModelCode of the model :model model3  global {\tint nb_people &lt;- 500;\tfloat step &lt;- 1 #minutes;\tfloat infection_distance &lt;- 2.0 #m;\tfloat proba_infection &lt;- 0.05;\tint nb_infected_init &lt;- 5;\tfile roads_shapefile &lt;- file(\"../includes/road.shp\");\tfile buildings_shapefile &lt;- file(\"../includes/building.shp\");\tgeometry shape &lt;- envelope(roads_shapefile);\tint current_hour update: (cycle / 60) mod 24;\tint nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected);\tint nb_people_not_infected &lt;- nb_people - nb_infected_init update: nb_people - nb_people_infected;\t\tfloat infected_rate update: nb_people_infected/length(people);\tinit {\t\tcreate road from: roads_shapefile;\t\tcreate building from: buildings_shapefile;\t\tcreate people number:nb_people {\t\t\tspeed &lt;- 5.0 #km/#h;\t\t\tbuilding bd &lt;- one_of(building);\t\t\tlocation &lt;- any_location_in(bd);\t\t}\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t}\treflex end_simulation when: infected_rate = 1.0 {\t\tdo halt;\t}}species people skills:[moving]{\t\t\tbool is_infected &lt;- false;\t\t\treflex move{\t\tdo wander;\t}\treflex infect when: is_infected{\t\task people at_distance infection_distance {\t\t\tif flip(proba_infection) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(5) color:is_infected ? #red : #green;\t}}species road {\taspect geom {\t\tdraw shape color: #black;\t}}species building {\taspect geom {\t\tdraw shape color: #gray;\t}}experiment main_experiment type:gui{\tparameter \"Infection distance\" var: infection_distance;\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\tparameter \"Nb people infected at init\" var: nb_infected_init ;\toutput {\t\tmonitor \"Current hour\" value: current_hour;\t\tmonitor \"Infected people rate\" value: infected_rate;\t\tdisplay map {\t\t\tspecies road aspect:geom;\t\t\tspecies building aspect:geom;\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t\tdisplay chart refresh: every(10) {\t\t\tchart \"Disease spreading\" type: series {\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Incremental-Model-Incremental-Model-3.html"
      }
      ,
    
      "wiki-incremental-model-incremental-model-4-html": {
        "title": "Movement on Graph",
        "content": "Movement on Graph4th part of the tutorial : Incremental ModelCode of the model : model model4  global {\tint nb_people &lt;- 500;\tfloat step &lt;- 1 #minutes;\tfloat infection_distance &lt;- 2.0 #m; \tfloat proba_infection &lt;- 0.05;\tint nb_infected_init &lt;- 5;\tfile roads_shapefile &lt;- file(\"../includes/road.shp\");\tfile buildings_shapefile &lt;- file(\"../includes/building.shp\");\tgeometry shape &lt;- envelope(roads_shapefile);\tint current_hour update: (cycle / 60) mod 24;\tgraph road_network;\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));\tint nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected);\tint nb_people_not_infected &lt;- nb_people - nb_infected_init update: nb_people - nb_people_infected;\t\tfloat infected_rate update: nb_people_infected/length(people);\tinit {\t\tcreate road from: roads_shapefile;\t\troad_network &lt;- as_edge_graph(road);\t\tcreate building from: buildings_shapefile; \t\tcreate people number:nb_people {\t\t\tspeed &lt;- 5.0 #km/#h;\t\t\tbuilding bd &lt;- one_of(building); \t\t\tlocation &lt;- any_location_in(bd);\t\t}\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t}\treflex end_simulation when: infected_rate = 1.0 {\t\tdo halt;\t}  }species people skills:[moving]{\t\t\tbool is_infected &lt;- false;\tpoint target;\tint staying_counter;\treflex staying when: target = nil {\t\tstaying_counter &lt;- staying_counter + 1;\t\tif flip(staying_counter / staying_coeff) {\t\t\ttarget &lt;- any_location_in (one_of(building));\t\t}\t}\t\t\treflex move when: target != nil{\t\tdo goto target:target on: road_network;\t\tif (location = target) {\t\t\ttarget &lt;- nil;\t\t\tstaying_counter &lt;- 0;\t\t} \t}\treflex infect when: is_infected{\t\task people at_distance infection_distance {\t\t\tif flip(proba_infection) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(5) color:is_infected ? #red : #green;\t}}species road {\taspect geom {\t\tdraw shape color: #black;\t}}species building {\taspect geom {\t\tdraw shape color: #gray;\t}}experiment main_experiment type:gui{\tparameter \"Infection distance\" var: infection_distance;\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\tparameter \"Nb people infected at init\" var: nb_infected_init ;\toutput {\t\tmonitor \"Current hour\" value: current_hour;\t\tmonitor \"Infected people rate\" value: infected_rate;\t\tdisplay map {\t\t\tspecies road aspect:geom;\t\t\tspecies building aspect:geom;\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t\tdisplay chart refresh: every(10) {\t\t\tchart \"Disease spreading\" type: series {\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Incremental-Model-Incremental-Model-4.html"
      }
      ,
    
      "wiki-incremental-model-incremental-model-5-html": {
        "title": "3D visualization",
        "content": "3D visualization5th part of the tutorial : Incremental ModelCode of the model :model model5  global {\tint nb_people &lt;- 500;\tfloat step &lt;- 1 #minutes;\tfloat infection_distance &lt;- 2.0 #m;\tfloat proba_infection &lt;- 0.05;\tint nb_infected_init &lt;- 5;\tfile roads_shapefile &lt;- file(\"../includes/road.shp\");\tfile buildings_shapefile &lt;- file(\"../includes/building.shp\");\tgeometry shape &lt;- envelope(roads_shapefile);\tgraph road_network;\tint current_hour update: (cycle / 60) mod 24;\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));\tint nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected);\tint nb_people_not_infected &lt;- nb_people - nb_infected_init update: nb_people - nb_people_infected;\tbool is_night &lt;- true update: current_hour &lt; 7 or current_hour &gt; 20;\t\tfloat infected_rate update: nb_people_infected/length(people);\tinit {\t\tcreate road from: roads_shapefile;\t\troad_network &lt;- as_edge_graph(road);\t\tcreate building from: buildings_shapefile;\t\tcreate people number:nb_people {\t\t\tspeed &lt;- 5.0 #km/#h;\t\t\tbuilding bd &lt;- one_of(building);\t\t\tlocation &lt;- any_location_in(bd);\t\t}\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t}\treflex end_simulation when: infected_rate = 1.0 {\t\tdo halt;\t}}species people skills:[moving]{\t\t\tbool is_infected &lt;- false;\tpoint target;\tint staying_counter;\treflex stay when: target = nil {\t\tstaying_counter &lt;- staying_counter + 1;\t\tif flip(staying_counter / staying_coeff) {\t\t\ttarget &lt;- any_location_in (one_of(building));\t\t}\t}\t\t\treflex move when: target != nil{\t\tdo goto target:target on: road_network;\t\tif (location = target) {\t\t\ttarget &lt;- nil;\t\t\tstaying_counter &lt;- 0;\t\t} \t}\treflex infect when: is_infected{\t\task people at_distance infection_distance {\t\t\tif flip(proba_infection) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(5) color:is_infected ? #red : #green;\t}\taspect sphere3D{\t\tdraw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green;\t}}species road {\tgeometry display_shape &lt;- shape + 2.0;\taspect geom {\t\tdraw display_shape color: #black depth: 3.0;\t}}species building skills:[moving] {\tfloat height &lt;- 10#m + rnd(10) #m;\taspect geom {\t\tdraw shape color: #gray depth: height;\t}}experiment main_experiment type:gui{\tparameter \"Infection distance\" var: infection_distance;\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\tparameter \"Nb people infected at init\" var: nb_infected_init ;\toutput {\t\tmonitor \"Current hour\" value: current_hour;\t\tmonitor \"Infected people rate\" value: infected_rate;\t\tdisplay map_3D type: opengl {\t\t\tlight 1 color:(is_night ? 50 : 255) update:true;\t\t\timage \"../includes/soil.jpg\";\t\t\tspecies road aspect:geom;\t\t\tspecies people aspect:sphere3D;\t\t\t\t\t\tspecies building aspect:geom transparency: 0.5;\t\t}\t\tdisplay chart refresh: every(10) {\t\t\tchart \"Disease spreading\" type: series {\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Incremental-Model-Incremental-Model-5.html"
      }
      ,
    
      "wiki-incremental-model-incremental-model-6-html": {
        "title": "Multi-level",
        "content": "Multi-level6th part of the tutorial : Incremental ModelCode of the model :model model6  global  {\tint nb_people &lt;- 500;\tfloat step &lt;- 1 #minutes;\tfloat infection_distance &lt;- 2.0 #m;\tfloat proba_infection &lt;- 0.05;\tint nb_infected_init &lt;- 5;\tfile roads_shapefile &lt;- file(\"../includes/road.shp\");\tfile buildings_shapefile &lt;- file(\"../includes/building.shp\");\tgeometry shape &lt;- envelope(roads_shapefile);\tgraph road_network;\tint current_hour update: (cycle / 60) mod 24;\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));\t\tlist&lt;people_in_building&gt; list_people_in_buildings update: (building accumulate each.people_inside) where (not dead(each));\tint nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected) + (empty(list_people_in_buildings) ? 0 : list_people_in_buildings count (each.is_infected));\t\tint nb_people_not_infected &lt;- nb_people - nb_infected_init update: nb_people - nb_people_infected;\tbool is_night &lt;- true update: current_hour &lt; 7 or current_hour &gt; 20;\t\tfloat infected_rate update: nb_people_infected/nb_people;\tinit {\t\tcreate road from: roads_shapefile;\t\troad_network &lt;- as_edge_graph(road);\t\tcreate building from: buildings_shapefile;\t\tcreate people number:nb_people {\t\t\tspeed &lt;- 5.0 #km/#h;\t\t\tbuilding bd &lt;- one_of(building);\t\t\tlocation &lt;- any_location_in(bd);\t\t}\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t\t\t}\treflex end_simulation when: infected_rate = 1.0 {\t\t\t\tdo halt;\t}}species people skills:[moving]{\t\t\tbool is_infected &lt;- false;\tpoint target;\tint staying_counter;\t\t\treflex move when: target != nil{\t\tdo goto target:target on: road_network;\t\tif (location = target) {\t\t\ttarget &lt;- any_location_in (one_of(building));\t\t\ttarget &lt;- nil;\t\t\tstaying_counter &lt;- 0;\t\t} \t}\treflex infect when: is_infected{\t\task people at_distance infection_distance {\t\t\tif flip(proba_infection) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(5) color:is_infected ? #red : #green;\t}\taspect sphere3D{\t\tdraw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green;\t}}species road {\tgeometry display_shape &lt;- shape + 2.0;\taspect geom {\t\tdraw display_shape color: #black depth: 3.0;\t}}species building {\tfloat height &lt;- 10#m + rnd(10) #m;\tlist&lt;people_in_building&gt; people_inside -&gt; {members collect people_in_building(each)};\t\taspect geom {\t\tint nbI &lt;- members count people_in_building(each).is_infected;\t\tint nbT &lt;- length(members);\t\tdraw shape color:nbT = 0 ? #gray : (float(nbI)/nbT &gt; 0.5 ? #red : #green) depth: height;\t}\t\tspecies people_in_building parent: people schedules: [] {\t\taspect circle{}\t\taspect sphere3D{}\t}\t\treflex let_people_leave  {\t\task members as: people_in_building{\t\t\tstaying_counter &lt;- staying_counter + 1;\t\t}\t\tlist&lt;people_in_building&gt; leaving_people &lt;- list&lt;people_in_building&gt;(members where (flip(people_in_building(each).staying_counter / staying_coeff)));\t\tif not (empty (leaving_people)) {\t\t\trelease leaving_people as: people in: world returns: released_people;\t\t\task released_people {\t\t\t\ttarget &lt;- any_location_in (one_of(building));\t\t\t}\t\t}\t}\treflex let_people_enter {\t\tlist&lt;people&gt; entering_people &lt;- people inside self where (each.target = nil);\t\tif not (empty (entering_people)) {\t\t\tcapture entering_people as: people_in_building ; \t\t}\t}}experiment main_experiment type:gui{\tparameter \"Infection distance\" var: infection_distance;\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\tparameter \"Nb people infected at init\" var: nb_infected_init ;\toutput {\t\tmonitor \"Current hour\" value: current_hour;\t\tmonitor \"Infected people rate\" value: infected_rate;\t\tdisplay map_3D type: opengl {\t\t\tlight 1 color:(is_night ? 50 : 255) update:true;\t\t\timage \"../includes/soil.jpg\";\t\t\tspecies road aspect:geom;\t\t\tspecies people aspect:sphere3D;\t\t\t\t\t\tspecies building aspect:geom transparency: 0.5;\t\t}\t\tdisplay chart refresh: every(10) {\t\t\tchart \"Disease spreading\" type: series {\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Incremental-Model-Incremental-Model-6.html"
      }
      ,
    
      "wiki-incremental-model-incremental-model-7-html": {
        "title": "Differential Equation",
        "content": "Differential Equation7th part of the tutorial : Incremental ModelCode of the model :model model7 global  {\tint nb_people &lt;- 500;\tfloat step &lt;- 1 #minutes;\tfloat infection_distance &lt;- 2.0 #m;\tfloat proba_infection &lt;- 0.05;\tint nb_infected_init &lt;- 5;\tfile roads_shapefile &lt;- file(\"../includes/road.shp\");\tfile buildings_shapefile &lt;- file(\"../includes/building.shp\");\tgeometry shape &lt;- envelope(roads_shapefile);\tgraph road_network;\tint current_hour update: (cycle / 60) mod 24;\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));\tfloat beta &lt;- 0.01;\tfloat h&lt;-0.1;\tlist&lt;people_in_building&gt; list_people_in_buildings update: (building accumulate each.people_inside) where (not dead(each));\tint nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected) + (empty(list_people_in_buildings) ? 0 : list_people_in_buildings count (each.is_infected));\t\tint nb_people_not_infected &lt;- nb_people - nb_infected_init update: nb_people - nb_people_infected;\tbool is_night &lt;- true update: current_hour &lt; 7 or current_hour &gt; 20;\t\tfloat infected_rate update: nb_people_infected/nb_people;\tinit {\t\tcreate road from: roads_shapefile;\t\troad_network &lt;- as_edge_graph(road);\t\tcreate building from: buildings_shapefile;\t\tcreate people number:nb_people {\t\t\tspeed &lt;- 5.0 #km/#h;\t\t\tbuilding bd &lt;- one_of(building);\t\t\tlocation &lt;- any_location_in(bd);\t\t}\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t\t\t}\treflex end_simulation when: infected_rate = 1.0 {\t\t\t\tdo halt;\t}}species people skills:[moving]{\t\t\tbool is_infected &lt;- false;\tpoint target;\tint staying_counter;\t\t\treflex move when: target != nil{\t\tdo goto target:target on: road_network;\t\tif (location = target) {\t\t\ttarget &lt;- any_location_in (one_of(building));\t\t\ttarget &lt;- nil;\t\t\tstaying_counter &lt;- 0;\t\t} \t}\treflex infect when: is_infected{\t\task people at_distance infection_distance {\t\t\tif flip(proba_infection) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(5) color:is_infected ? #red : #green;\t}\taspect sphere3D{\t\tdraw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green;\t}}species road {\tgeometry display_shape &lt;- shape + 2.0;\taspect geom {\t\tdraw display_shape color: #black depth: 3.0;\t}}species building {\tfloat height &lt;- 10#m + rnd(10) #m;\tlist&lt;people_in_building&gt; people_inside -&gt; {members collect people_in_building(each)};\tfloat I;\tfloat S;\tfloat T;   \tfloat t;      \tfloat I_to1;    \t\taspect geom {\t\tint nbI &lt;- members count people_in_building(each).is_infected;\t\tint nbT &lt;- length(members);\t\tdraw shape color:nbT = 0 ? #gray : (float(nbI)/nbT &gt; 0.5 ? #red : #green) depth: height;\t}\t\tspecies people_in_building parent: people schedules: [] {\t\taspect circle{}\t\taspect sphere3D{}\t}\t\treflex let_people_leave  {\t\task members as: people_in_building{\t\t\tstaying_counter &lt;- staying_counter + 1;\t\t}\t\tlist&lt;people_in_building&gt; leaving_people &lt;- list&lt;people_in_building&gt;(members where (flip(people_in_building(each).staying_counter / staying_coeff)));\t\tif not (empty (leaving_people)) {\t\t\trelease leaving_people as: people in: world returns: released_people;\t\t\task released_people {\t\t\t\ttarget &lt;- any_location_in (one_of(building));\t\t\t}\t\t}\t}\treflex let_people_enter {\t\tlist&lt;people&gt; entering_people &lt;- people inside self where (each.target = nil);\t\tif not (empty (entering_people)) {\t\t\tcapture entering_people as: people_in_building ; \t\t}\t}\tequation SIR{ \t\tdiff(S,t) = (- beta * S * I / T) ;\t\tdiff(I,t) = (  beta * S * I / T) ;\t}\treflex epidemic when: not empty(members){ \t\t\tT &lt;- float(length(members));\t\tlist&lt;people_in_building&gt; S_members &lt;- list&lt;people_in_building&gt;(members where not (people_in_building(each).is_infected));    \tS &lt;- float(length(S_members));    \tI &lt;- T-S;    \tfloat I0 &lt;- I;    \tif (I &gt; 0 and S &gt; 0) {    \t\tsolve SIR method: \"rk4\" step: h;    \t\tI_to1 &lt;- I_to1 + (I - I0);    \t\tint I_int &lt;- min([int(S),int(I_to1)]);\t    \tI_to1 &lt;- I_to1 - I_int;\t    \task(I_int among S_members){\t    \t\tis_infected &lt;- true;\t    \t}    \t}    }  }experiment main_experiment type:gui{\tparameter \"Infection distance\" var: infection_distance;\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\tparameter \"Nb people infected at init\" var: nb_infected_init ;\toutput {\t\tmonitor \"Current hour\" value: current_hour;\t\tmonitor \"Infected people rate\" value: infected_rate;\t\tdisplay map_3D type: opengl {\t\t\tlight 1 color:(is_night ? 50 : 255) update:true;\t\t\timage \"../includes/soil.jpg\";\t\t\tspecies road aspect:geom;\t\t\tspecies people aspect:sphere3D;\t\t\t\t\t\tspecies building aspect:geom transparency: 0.5;\t\t}\t\tdisplay chart refresh: every(10) {\t\t\tchart \"Disease spreading\" type: series {\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Incremental-Model-Incremental-Model-7.html"
      }
      ,
    
      "wiki-incremental-model-html": {
        "title": "Incremental Model",
        "content": "Incremental ModelThis sub-section is composed of the following models :      Simple SI Model        Charts        Integration of GIS Data        Movement on Graph        3D visualization        Multi-level        Differential Equation  ",
        "url":"/wiki/Incremental-Model.html"
      }
      ,
    
      "wiki-incrementalmodel-html": {
        "title": "Incremental Model",
        "content": "Incremental ModelThis tutorial has for goal to give an overview all most of the capabilities of GAMA. In particular, it presents how to build a simple model and the use of GIS data, graphs, 3D visualization, multi-level modeling and differential equations. All the files related to this tutorial (images and models) are available in the Models Library (project Tutorials/Incremental Model).Model OverviewThe model built in this tutorial concerns the study of the spreading of a disease in a small city.Three type of entities are taken into account: the people, the buildings and the roads.We made the following modeling choice:  Simulation step: 1 minute  People are moving on the roads from building to building  People use the shortest path to move between buildings  All people have the same speed and move at constant speed  Each time, people arrived at a building they are staying a certain time  The staying time depends on the current hour (lower at 9h - go to work - at 12h go to lunch - at 18h - go back home)  Infected people are never curedStep ListThis tutorial is composed of 7 steps corresponding to 7 models. For each step we present its purpose, an explicit formulation and the corresponding GAML code.  Simple SI Model  Charts  Integration of GIS Data  Movement on Graph  Visualizing in 3D  Multi-Level  Differential Equations",
        "url":"/wiki/IncrementalModel.html"
      }
      ,
    
      "wiki-incrementalmodel-step1-html": {
        "title": "1. Simple SI Model",
        "content": "1. Simple SI ModelThis first step Illustrates how to write a model in GAMA. In particular, it describes how to structure a model and how to define species - that are the key components of GAMA models.Formulation  Definition of the people species with a variable (is_infected) , an aspect (base) and two behaviors (move and infect)  Definition of nb_infected_init, distance_infection and proba_infection parameters  Creation of 500 people agents randomly located in the environment (size: 500x500)  Definition a display to visualize the people agents.Model Definitionmodel structureA GAMA model is composed of three type of sections:  global : this section, that is unique, defines the “world” agent, a special agent of a GAMA model. It represents all that is global to the model: dynamics, variables, actions. In addition, it allows to initialize the simulation (init block).  species : these sections define the species of agents composing the model.  experiment : these sections define a context of execution of the simulations. In particular, it defines the input (parameters) and output (displays, files…) of a model.More details about the different sections of a GAMA model can be found here.speciesA species represents a «prototype» of agents: it defines their common properties.A species includes several sub-definitions:  the internal state of its agents (attributes)  their behavior  how they are displayed (aspects)GAMA provides as well the possibility to give skills to species of agents. A skillI is a module integrating variables and actions coded in Java.Concerning our model, we will give the moving skill to the people agents: it will give to the people agents supplementary variables (speed, heading, destination) and actions (follow, goto, move, wander).species people skills:[moving]{}Concerning the internal state, a attribute is defined as follows: type of the attribute (int (integer), float (floating point number), string, bool (boolean, true or false), point (coordinates), list, pair, map, file, matrix, espèce d’agents, rgb (color), graph, path…) + name  Optional facets: &lt;- (initial value), update (value recomputed at each step of the simulation), function:{..} (value computed each time the variable is used), min, maxNote that all the species inherit from predefined built-in variables:  A name (name)  A shape (shape)  A location (location) : the centroid of its shape.We will give a variable to people agents: is_infected (bool):species people skills:[moving]{\t\t\tbool is_infected &lt;- false;}Concerning the display of an agent, aspects have to be defined. An aspect represents a possible way to display the agents of a species : aspect aspect_name {…}In the block of an aspect, it is possible to draw :  A geometry :  for instance, the shape of the agent  An image : to draw icons  A text : to draw a textWe define an aspect for this species. In this model, we want to display for each people agent a circle of radius 5 and red or green according to the value of is_infected (if infected: red, green otherwise). We then use the keyword draw with a circle shape. To define the color that depends on is_infected, we use the tertiary operator condition ? val1 : val2. If the condition is true, this operator will return val1, otherwise val2. Note that it is possible to get a color value by using the symbol # + color name: e.g. #blue, #red, #white, #yellow, #magenta, #pink…species people skills:[moving]{\t\t\t...\taspect circle{\t\tdraw circle(5) color:is_infected ? #red : #green;\t}}Concerning the behavior of agents, the simplest way to define it is through reflexes. A reflex is a block of statements (that can be defined in global or any species) that will be automatically executed at each simulation step if its condition is true. A reflex is defined as follows:   reflex reflex_name when: condition {...}The when facet is optional: when it is omitted, the reflex is activated at each time step. Note that if several reflexes are defined for a species, the reflexes will be activated following their definition order.We define a first reflex called move that allows the people agents to move using the wander action (provided by the moving skill) that allows to randomly move (with taking into account the agent speed)species people {        ...        reflex move{\t\tdo wander;\t}}Note that an action is a capability available to the agents of a species (what they can do). It is a block of statements that can be used and reused whenever needed. Some actions, called primitives, are directly coded in Java: for instance, the wander action defined in the moving skill.  An action can accept arguments. For instance, write takes an argument called message.  An action can return a result.There are two ways to call an action: using a statement or as part of an expression  for actions that do not return a result:    do action_name arg1: v1 arg2: v2;        for actions that return a result:    my_var &lt;- self action_name (arg1:v1, arg2:v2);      The second reflex we have to define is the infect one. This reflex will be activated only if is_infected is true. This reflex consists is asking all the people agents at a distance lower or equal to infection_distance to become infected with a probability proba_infection.species people skills:[moving]{\t\t\t...\treflex infect when: is_infected{\t\task people at_distance infection_distance {\t\t\tif flip(proba_infection) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\t...}Note that we used the ask statement. This statement allows to make a remote agent executes a list of statements. We used as well the flip operator that allows to test a probability.global sectionThe global section represents the definition of the species of a specific agent (called world).The world agent represents everything that is global to the model: dynamics, variables…It allows to init simulations (init block): the world is always created and initialized first when a simulation is launched. The geometry (shape) of the world agent is by default a square with 100m for side size, but can be redefined if necessary. In the same way, the modeler can redefined the step variable that represent the duration of a simulation step and that is by default 1 second.global variableFor our model, we define 4 global variables: nb_people (int, init value: 500), infection distance (float value, init value: 2 meters), proba_infection (float, init value: 0.05) and nb_infected_init (int, init value: 5). In addition, we redefine the geometry of the world by a square of 500 meters size and a simulation step of 1 minute.global{ \tint nb_people &lt;- 500;\tfloat infection_distance &lt;- 2.0 #m;\tfloat proba_infection &lt;- 0.05;\tint nb_infected_init &lt;- 5;\tfloat step &lt;- 1 #minutes;\tgeometry shape&lt;-square(500 #m);}Model initializationThe init section of the global block allows to initialize the model.The statement create allows to create agents of a specific species: create species_name + :  number : number of agents to create (int, 1 by default)  from : GIS file to use to create the agents (string or file)  returns: list of created agents (list)For our model, definition of the init block in order to create nb_people people agents. We set the init value of the speed variable (given by the moving skill) to 5km/h.  In addition we ask nb_infected_init people to become infected (use of the nb among list to randomly draw nb elements of the list).  global{ \t...\tinit{\t\tcreate people number:nb_people {\t\t\tspeed &lt;- 5.0 #km/#h;\t\t}\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t}}  experimentAn experiment block defines how a model can be simulated (executed). Several experiments can be defined for a model. They are defined using : experiment exp_name type: gui/batch {[input] [output]}  gui : experiment with a graphical interface, which displays its input parameters and outputs.  batch : Allows to setup a series of simulations (w/o graphical interface).In our model, we define a gui experiment called main_experiment :experiment main_experiment type: gui {}inputExperiments can define (input) parameters. A parameter definition allows to make the value of a global variable definable by the user through the graphic interface.A parameter is defined as follows:parameter title var: global_var category: cat;  title : string to display  var : reference to a global variable (defined in the global section)  category : string used to «store» the operators on the UI - optional  &lt;- : init value - optional  min : min value - optional  max : min value - optionalNote that the init, min and max values can be defined in the global variable definition.In the experiment, definition of three parameters from the the global variable infection_distance, proba_infection and nb_infected_init :experiment main_experiment type:gui{\tparameter \"Infection distance\" var: infection_distance;\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\tparameter \"Nb people infected at init\" var: nb_infected_init ;\t...}outputOutput blocks are defined in an experiment and define how to visualize a simulation (with one or more display blocks that define separate windows). Each display can be refreshed independently by defining the facet refresh_every: nb (int) (the display will be refreshed every nb steps of the simulation).Each display can include different layers (like in a GIS) :  Agents lists : agents layer_name value: agents_list aspect: my_aspect;  Agents species : species  my_species aspect: my_aspect  Images: image layer_name file: image_file;  Texts : texte layer_name value: my_text;  Charts : see later.Note that it is possible to define a opengl display (for 3D display) by using the facet type: opengl.In our model, we define a display to draw the people agents with their circle aspect.experiment main_experiment type:gui{\t...        output {\t\tdisplay map {\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t}}Complete Modelmodel SI_cityglobal{ \tint nb_people &lt;- 500;\tfloat agent_speed &lt;- 5.0 #km/#h;\tfloat infection_distance &lt;- 2.0 #m;\tfloat proba_infection &lt;- 0.05;\tint nb_infected_init &lt;- 5;\tfloat step &lt;- 1 #minutes;\tgeometry shape&lt;-square(500 #m);\t\tinit{\t\tcreate people number:nb_people;\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t}\t}species people skills:[moving]{\t\t\tfloat speed &lt;- agent_speed;\tbool is_infected &lt;- false;\treflex move{\t\tdo wander;\t}\treflex infect when: is_infected{\t\task people at_distance infection_distance {\t\t\tif flip(proba_infection) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(5) color:is_infected ? #red : #green;\t}}experiment main_experiment type:gui{\tparameter \"Infection distance\" var: infection_distance;\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\tparameter \"Nb people infected at init\" var: nb_infected_init ;\toutput {\t\tdisplay map {\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t}}",
        "url":"/wiki/IncrementalModel_step1.html"
      }
      ,
    
      "wiki-incrementalmodel-step2-html": {
        "title": "2. Charts",
        "content": "2. ChartsThis step Illustrates how define monitors and charts in GAMA. In addition, it illustrates how to define a stopping condition for the simulation.Formulation  Definition of new global variables: current_hour, nb_people_infected, nb_people_not_infected, infected_rate  Definition of a monitor to follow the current hour and the nb of people infected  Definition of a series chart to follow the number of people infected and not infected  Definition of a stopping condition (when infected rate = 1)Model Definitionglobal variablesIn order to define dynamic variable able to update itself, we use the update facet of variable definition.Indeed, at each simulation step, all the agents (and the world agent) apply for each dynamic variable (in their definition order) its update expression.We define 4 new variables:  current hour (int) : current simulation step (cycle) / 60 mod 24  nb_people_infected (int): nb of people with is_infected = true (use of the list count condition operator that count the number of elements of the list for which the condition is true)  nb_people_not_infected (int): nb_people - nb of people infected  infected_rate (float): nb of people infected / nb of people    global{...    int current_hour update: (cycle / 60) mod 24;int nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected);int nb_people_not_infected &lt;- nb_people - nb_infected_init update: nb_people - nb_people_infected;float infected_rate update: nb_people_infected/nb_people;...}        stopping condition  We add a new reflex that stops the simulation if the infected_rate is equal to 1. To stop the simulation, we apply the halt action.global {   ...        reflex end_simulation when: infected_rate = 1.0 {\t\tdo halt;\t}}Note that it would have been possible to use the pause action that pauses the simulation instead of the halt action that stops the simulation.monitorA monitor allows to follow the value of an arbitrary expression in GAML. It has to be defined in an output section. A monitor is defined as follows:      monitor monitor_name value: an_expression refresh:every(nb_steps);With:  value: mandatory, its value will be displayed in the monitor.  refresh: bool, optional : if the expression is true, compute (default is true).In this model, we define 2 monitors to follow the value of the variable current_hour and infected_rate:experiment main_experiment type:gui{\t...\toutput {\t\tmonitor \"Current hour\" value: current_hour;\t\tmonitor \"Infected people rate\" value: infected_rate;\t\t...\t}}chartGAMA can display various chart types:  Time series  Pie charts  HistogramsA chart must be defined in a display : it behaves exactly like any other layer.Definition of a chart :chart chart_name type: chart_type  {     [data]}The data to draw are define inside the chart block:   data data_legend value: data_valueWe add a new display called chart refresh every 10 simulation steps.Inside this display, we define a chart of type series:  “Species evolution”; background : white; size : {1, 0.5}; position : {0, 0}          data1: susceptible; color : green      data2: infected; color : red      experiment main_experiment type:gui{\t...\toutput {\t\t...\t\tdisplay chart refresh:every(10) {\t\t\tchart \"Disease spreading\" type: series {\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\t\t\t}\t\t}\t}}Complete Modelmodel SI_cityglobal{\tint nb_people &lt;- 500;\tfloat step &lt;- 1 #minutes;\tgeometry shape&lt;-envelope(square(500 #m));\tfloat infection_distance &lt;- 2.0 #m;\tfloat proba_infection &lt;- 0.05;\tint nb_infected_init &lt;- 5;\tint current_hour update: (cycle / 60) mod 24;\tint nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected);\tint nb_people_not_infected &lt;- nb_people - nb_infected_init update: nb_people - nb_people_infected;\tfloat infected_rate update: nb_people_infected/length(people);\t\tinit{\t\tcreate people number:nb_people {\t\t\tspeed &lt;- 5.0 #km/#h;\t\t}\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t}\treflex end_simulation when: infected_rate = 1.0 {\t\tdo halt;\t}}species people skills:[moving]{\t\t\tbool is_infected &lt;- false;\treflex move{\t\tdo wander;\t}\treflex infect when: is_infected{\t\task people at_distance infection_distance {\t\t\tif flip(proba_infection) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(5) color:is_infected ? #red : #green;\t}}experiment main_experiment type:gui{\tparameter \"Infection distance\" var: infection_distance;\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\tparameter \"Nb people infected at init\" var: nb_infected_init ;\toutput {\t\tmonitor \"Current hour\" value: current_hour;\t\tmonitor \"Infected people rate\" value: infected_rate;\t\tdisplay map {\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t\tdisplay chart refresh:every(10) {\t\t\tchart \"Disease spreading\" type: series {\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\t\t\t}\t\t}\t}}",
        "url":"/wiki/IncrementalModel_step2.html"
      }
      ,
    
      "wiki-incrementalmodel-step3-html": {
        "title": "3. Integration of GIS Data",
        "content": "3. Integration of GIS DataThis step Illustrates how load and agentry GIS data.Formulation  Load, agentify and display two layers of GIS data (building and road)  Modify the initialization of the people agents to put them inside buildingsModel DefinitionspeciesWe have to define two species of agents: the building agents and the road ones. These agents will not have a particular behavior, they will just be displayed.We define an aspect for these species. In this model, we want to represent the geometry of the agent, we then use the keyword draw that allow to draw a given geometry. In order to draw the geometry of the agent we use the attribute shape (which is a built-in attribute of all agents).species building {\taspect geom {\t\tdraw shape color: #gray;\t}}species road {\taspect geom {\t\tdraw shape color: #black;\t}}parametersGAMA allows to automatically read GIS data that are formatted as shapefiles. In order to let the user chooses his/her shapefiles, we define two parameters. One allowing the user to choose the road shapefile, one allowing him/her to choose the building shapefile.Definition of the two global variables of type file concerning the GIS files:global {   file shape_file_buildings &lt;- file(\"../includes/building.shp\");   file shape_file_roads &lt;- file(\"../includes/road.shp\");}agentification of GIS dataIn GAMA, the agentification of GIS data is very straightforward: it only requires to use the create command with the from facet to pass the shapefile. Each object of the shapefile will be directly used to instantiate an agent of the specified species.We modify the init section of the global block in order to create road and building agents from the shape files. Then, we define the initial location of people as a point inside one of the building.global {  ...       init {\t\tcreate road from: roads_shapefile;\t\tcreate building from: buildings_shapefile;\t\tcreate people number:nb_people {\t\t\tspeed &lt;- 5.0 #km/#h;\t\t\tbuilding bd &lt;- one_of(building);\t\t\tlocation &lt;- any_location_in(bd);\t\t}\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}        }} We defined here a local variable called bd of type building that is a one of the building (randomly chosen). Note that the name of a species can be used to obtain all the agents of this species (here building returns the list of all the buildings). The any_location_in returns a random point inside a geometry or an agent geometry.environmentBuilding a GIS environment in GAMA requires nothing special, just to define the bounds of the environment, i.e. the geometry of the world agent. It is possible to use a shapefile to automatically define it by computing its envelope. In this model, we use the road shapefile to define it.global {  ...  geometry shape &lt;- envelope(shape_file_roads);   ...}displayWe add to the map display the road and building agents.In the experiment block:output {   display map {\tspecies road aspect:geom;\tspecies building aspect:geom;\tspecies people aspect:circle;\t\t\t    }    ...}Complete Modelmodel model3  global {\tint nb_people &lt;- 500;\tfloat step &lt;- 1 #minutes;\tfloat infection_distance &lt;- 2.0 #m;\tfloat proba_infection &lt;- 0.05;\tint nb_infected_init &lt;- 5;\tfile roads_shapefile &lt;- file(\"../includes/road.shp\");\tfile buildings_shapefile &lt;- file(\"../includes/building.shp\");\tgeometry shape &lt;- envelope(roads_shapefile);\tint current_hour update: (cycle / 60) mod 24;\tint nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected);\tint nb_people_not_infected &lt;- nb_people - nb_infected_init update: nb_people - nb_people_infected;\t\tfloat infected_rate update: nb_people_infected/length(people);\tinit {\t\tcreate road from: roads_shapefile;\t\tcreate building from: buildings_shapefile;\t\tcreate people number:nb_people {\t\t\tspeed &lt;- 5.0 #km/#h;\t\t\tbuilding bd &lt;- one_of(building);\t\t\tlocation &lt;- any_location_in(bd);\t\t}\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t}\treflex end_simulation when: infected_rate = 1.0 {\t\tdo halt;\t}}species people skills:[moving]{\t\t\tbool is_infected &lt;- false;\t\t\treflex move{\t\tdo wander;\t}\treflex infect when: is_infected{\t\task people at_distance infection_distance {\t\t\tif flip(proba_infection) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(5) color:is_infected ? #red : #green;\t}}species road {\taspect geom {\t\tdraw shape color: #black;\t}}species building {\taspect geom {\t\tdraw shape color: #gray;\t}}experiment main_experiment type:gui{\tparameter \"Infection distance\" var: infection_distance;\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\tparameter \"Nb people infected at init\" var: nb_infected_init ;\toutput {\t\tmonitor \"Current hour\" value: current_hour;\t\tmonitor \"Infected people rate\" value: infected_rate;\t\tdisplay map {\t\t\tspecies road aspect:geom;\t\t\tspecies building aspect:geom;\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t\tdisplay chart refresh:every(10) {\t\t\tchart \"Disease spreading\" type: series {\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\t\t\t}\t\t}\t}}",
        "url":"/wiki/IncrementalModel_step3.html"
      }
      ,
    
      "wiki-incrementalmodel-step4-html": {
        "title": "4. Movement on Graph",
        "content": "4. Movement on GraphThis step illustrates how load a graph and use it for the displacement of our species.Formulation  definition of a global graph to represent the road network  definition of a new global variable: staying_coeff to represent the fact that people move more near 9h, 12h and 18h  definition of two new variables for the people agents: target and staying_counter  definition of a new reflex for people agents: stay  modification of the move reflex of the people agentsModel Definitionglobal variablesWe define two new global variables:  road_network (graph) : represents the graph that will be built from the road network  staying_coeff (float) : represents the fact that people have more chance to move from their current building near 9h (go to work), 12h (lunch time) and 18h (go home). This variable is updated at each simulation step (use of the update facet). global{\t....        graph road_network;\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));\t....}initializationWe need to compute from the road agents, a graph for the moving of the people agents. The operator as_edge_graph allows to do that. It automatically builds from a set of agents or geometries a graph where the agents are the edges of the graph, a node represent the extremities of the agent geometry. The weight of each edge corresponds to the length of the road.global {   ...   init {      ...      create road from: roads_shapefile;      road_network &lt;- as_edge_graph(road);\t      ...   }}people agentFirst, we add two new variables for the people agents:  target (point): the target location that the people want to reach (a point inside a building)  staying_counter (int): the number of cycles since the agent arrived at its buildingWe define a new reflex called stay that is activated when the agent has no target (target = nil), i.e. when the agent is inside a building. This reflex increments the staying_counter, then it test the probability to leave that is computed from the staying_counter (longer the agent is inside the building, more it has a chance to leave) and the staying_coeff (closer to 9h, 12h and 18h, more the agent has a chance to leave).If the agents decide to leave, it computes a new target as a random point inside one of the buildings (randomly chosen).species people skills:[moving]{\t\t\t...\treflex stay when: target = nil {\t\tstaying_counter &lt;- staying_counter + 1;\t\tif flip(staying_counter / staying_coeff) {\t\t\ttarget &lt;- any_location_in (one_of(building));\t\t}\t}\t...}We modify the move reflex. Now, this reflex is activated only when the agent has a target (target != nil). In this case the agent moves in direction to its target using the goto action. Note that we specified a graph (road_network) to constraint the moving of the agents on the road network with the facet on. The agent uses the shortest path (according to the graph) to go to the target point. When the agent arrives at destination (location = location), the target is set to nil (the agent will stop moving) and the staying_counter is set to 0.species people skills:[moving]{\t\t\t...\treflex move when: target != nil{\t\tdo goto target:target on: road_network;\t\tif (location = target) {\t\t\ttarget &lt;- nil;\t\t\tstaying_counter &lt;- 0;\t\t} \t}}Complete Modelmodel model4  global {\tint nb_people &lt;- 500;\tfloat step &lt;- 1 #minutes;\tfloat infection_distance &lt;- 2.0 #m;\tfloat proba_infection &lt;- 0.05;\tint nb_infected_init &lt;- 5;\tfile roads_shapefile &lt;- file(\"../includes/road.shp\");\tfile buildings_shapefile &lt;- file(\"../includes/building.shp\");\tgeometry shape &lt;- envelope(roads_shapefile);\tint current_hour update: (cycle / 60) mod 24;\tgraph road_network;\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));\tint nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected);\tint nb_people_not_infected &lt;- nb_people - nb_infected_init update: nb_people - nb_people_infected;\t\tfloat infected_rate update: nb_people_infected/length(people);\tinit {\t\tcreate road from: roads_shapefile;\t\troad_network &lt;- as_edge_graph(road);\t\tcreate building from: buildings_shapefile;\t\tcreate people number:nb_people {\t\t\tspeed &lt;- 5.0 #km/#h;\t\t\tbuilding bd &lt;- one_of(building);\t\t\tlocation &lt;- any_location_in(bd);\t\t}\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t}\treflex end_simulation when: infected_rate = 1.0 {\t\tdo halt;\t}}species people skills:[moving]{\t\t\tbool is_infected &lt;- false;\tpoint target;\tint staying_counter;\treflex staying when: target = nil {\t\tstaying_counter &lt;- staying_counter + 1;\t\tif flip(staying_counter / staying_coeff) {\t\t\ttarget &lt;- any_location_in (one_of(building));\t\t}\t}\t\t\treflex move when: target != nil{\t\tdo goto target:target on: road_network;\t\tif (location = target) {\t\t\ttarget &lt;- nil;\t\t\tstaying_counter &lt;- 0;\t\t} \t}\treflex infect when: is_infected{\t\task people at_distance infection_distance {\t\t\tif flip(proba_infection) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(5) color:is_infected ? #red : #green;\t}}species road {\taspect geom {\t\tdraw shape color: #black;\t}}species building {\taspect geom {\t\tdraw shape color: #gray;\t}}experiment main_experiment type:gui{\tparameter \"Infection distance\" var: infection_distance;\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\tparameter \"Nb people infected at init\" var: nb_infected_init ;\toutput {\t\tmonitor \"Current hour\" value: current_hour;\t\tmonitor \"Infected people rate\" value: infected_rate;\t\tdisplay map {\t\t\tspecies road aspect:geom;\t\t\tspecies building aspect:geom;\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t\tdisplay chart refresh:every(10) {\t\t\tchart \"Disease spreading\" type: series {\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\t\t\t}\t\t}\t}}",
        "url":"/wiki/IncrementalModel_step4.html"
      }
      ,
    
      "wiki-incrementalmodel-step5-html": {
        "title": "5. Visualizing in 3D",
        "content": "5. Visualizing in 3DThis step Illustrates how to define a 3D displayFormulation  add a variable (height: int from 10m to 20m) and modify the aspect of buildings to display them in 3D  add a variable (display_shape: geometry; shape with a buffer of 2m) and modify the aspect of the roads to display them with this new shape.  add a new global variable that indicate if it is night or not (bool: night before 7h and after 20h).  define a new aspect (sphere3D) for people to display them as sphere.  modify the display to use this new aspect.Model DefinitionbuildingFirst, we add a new variable for buildings (height) of type float from 10m to 20m. Then we modify the aspect in order to specify a depth for the geometry (using the depth facet).species building {\tfloat height &lt;- 10#m + rnd(10) #m;\taspect geom {\t\tdraw shape color: #gray depth: height;\t}}roadConcerning the road,  we add a new variable (display_shape) of type geometry that correspond to the shape of the road with a buffer of 2 meters. Then we modify the aspect in order to display this geometry instead of the shape of the agent. In order to avoid “z-fighting” problems, we add a depth to the geometry (of 3 meters).species road {\tgeometry display_shape &lt;- shape + 2.0;\taspect geom {\t\tdraw display_shape color: #black depth: 3.0;\t}}global variableWe define a new global variable called is_night of type bool to indicate if it is night or not. This variable will be update at each simulation step and will be true if the current_hour is lower than 7h or higher than 20h.global{\t...        bool is_night &lt;- true update: current_hour &lt; 7 or current_hour &gt; 20;       ...}peopleWe define a new aspect for the people agent called sphere3D. This aspect draw people agent as a 3m sphere. In order to avoid to cut the sphere in half, we translate the centroid of the drawn sphere to 3m along the z axis.species people skills:[moving]{\t\t\t...\taspect sphere3D{\t\tdraw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green;\t}}displayThe element that we have to modify is the display. We change its name to map_3D to better reflect its visual aspect.In order to get a 3D aspect, we specify that this display will be an opengl one. For that, we just have to add the facet type: opengl. In addition, to get a different light between night and day : The statement light allows us to declare a light. We can change up to 7 lights, called through the facet “id”. The default light is a white light, directional, with the id=1. You can set the intensity of the light through the facet “color” (you can pass a color, or an integer between 0 and 255). To have a nice effect night / day, we will set the intensity of the light to 50 during the night, and 255 for the day. To learn more about light, please read this page.Then, we add a new layer that consists in an image (soil.jpg) by using the image statement.In order to see the people inside the building, we add transparency to the building (0.5). The transparency of a layer is a float value between 0 (solid) and 1 (totally transparent). In order to be able to manage this transparency aspect, opengl has to draw the people agents before the building, thus we modify the order of drawing of the different layers (people agents before building agents). At last, we modify the aspect of the people agents by the new one: sphere3D.experiment main_experiment type:gui{\t...\toutput {\t\t...\t\tdisplay map_3D type: opengl {\t\t\tlight 1 color:(is_night ? 50 : 255);\t\t\timage \"../includes/soil.jpg\";\t\t\tspecies road aspect:geom;\t\t\tspecies people aspect:sphere3D;\t\t\t\t\t\tspecies building aspect:geom transparency: 0.5;\t\t}\t\t...\t}}Complete Modelmodel model5  global {\tint nb_people &lt;- 500;\tfloat step &lt;- 1 #minutes;\tfloat infection_distance &lt;- 2.0 #m;\tfloat proba_infection &lt;- 0.05;\tint nb_infected_init &lt;- 5;\tfile roads_shapefile &lt;- file(\"../includes/road.shp\");\tfile buildings_shapefile &lt;- file(\"../includes/building.shp\");\tgeometry shape &lt;- envelope(roads_shapefile);\tgraph road_network;\tint current_hour update: (cycle / 60) mod 24;\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));\tint nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected);\tint nb_people_not_infected &lt;- nb_people - nb_infected_init update: nb_people - nb_people_infected;\tbool is_night &lt;- true update: current_hour &lt; 7 or current_hour &gt; 20;\t\tfloat infected_rate update: nb_people_infected/length(people);\tinit {\t\tcreate road from: roads_shapefile;\t\troad_network &lt;- as_edge_graph(road);\t\tcreate building from: buildings_shapefile;\t\tcreate people number:nb_people {\t\t\tspeed &lt;- 5.0 #km/#h;\t\t\tbuilding bd &lt;- one_of(building);\t\t\tlocation &lt;- any_location_in(bd);\t\t}\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t}\treflex end_simulation when: infected_rate = 1.0 {\t\tdo halt;\t}}species people skills:[moving]{\t\t\tbool is_infected &lt;- false;\tpoint target;\tint staying_counter;\treflex stay when: target = nil {\t\tstaying_counter &lt;- staying_counter + 1;\t\tif flip(staying_counter / staying_coeff) {\t\t\ttarget &lt;- any_location_in (one_of(building));\t\t}\t}\t\t\treflex move when: target != nil{\t\tdo goto target:target on: road_network;\t\tif (location = target) {\t\t\ttarget &lt;- nil;\t\t\tstaying_counter &lt;- 0;\t\t} \t}\treflex infect when: is_infected{\t\task people at_distance infection_distance {\t\t\tif flip(proba_infection) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(5) color:is_infected ? #red : #green;\t}\taspect sphere3D{\t\tdraw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green;\t}}species road {\tgeometry display_shape &lt;- shape + 2.0;\taspect geom {\t\tdraw display_shape color: #black depth: 3.0;\t}}species building {\tfloat height &lt;- 10#m + rnd(10) #m;\taspect geom {\t\tdraw shape color: #gray depth: height;\t}}experiment main_experiment type:gui{\tparameter \"Infection distance\" var: infection_distance;\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\tparameter \"Nb people infected at init\" var: nb_infected_init ;\toutput {\t\tmonitor \"Current hour\" value: current_hour;\t\tmonitor \"Infected people rate\" value: infected_rate;\t\tdisplay map_3D type: opengl {\t\t\tlight 1 color:(is_night ? 50 : 255);\t\t\timage \"../includes/soil.jpg\";\t\t\tspecies road aspect:geom;\t\t\tspecies people aspect:sphere3D;\t\t\t\t\t\tspecies building aspect:geom transparency: 0.5;\t\t}\t\tdisplay chart refresh:every(10) {\t\t\tchart \"Disease spreading\" type: series {\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\t\t\t}\t\t}\t}}",
        "url":"/wiki/IncrementalModel_step5.html"
      }
      ,
    
      "wiki-incrementalmodel-step6-html": {
        "title": "6. Multi-Level",
        "content": "6. Multi-LevelThis step Illustrates how to define a multi-level modelFormulationWe propose to let the buildings manage what happens when the people are inside buildings. In this context, we will use the multi-level properties of GAMA: when a people agent will be inside a building, it will be captured by it and its species will be modified. It will be not anymore the people agent that will decide when to leave the building, but the building itself.We will need to:  define a micro-species of people inside the building species (people_in_buildings)  define a new variable for the building agent (_people_inbuilding)  define two new behaviors for building: let_people_leave and let_people_enter  modify the aspect of the building  modify some global variables for counting the number of infected people_Model DefinitionbuildingFirst, we define a new species called people_in_building inside the building species. Thus, a building could have agents of this species as members and control them. The people_in_building species has for parent the people species, which means that a people_in_building agent has all the properties, aspect and behaviors of a people agent.In our case, we want the once a people agent inside a building, this people agent does nothing. Then, we use the schedules facet of the species to remove the people_in_building from the scheduler.species building {\t...        species people_in_building parent: people schedules: [] {\t}\t...}We define a new dynamic variable for building agent: people_inside that will correspond to the list of people_in_building agents inside the building. Note that we use the syntax -&gt; {…} to make the variable dynamic. However, instead of update that allows a variable to be recomputed at each simulation step, the syntax -&gt; {…} allows the variable to be recomputed each time it is called (and thus avoid outdated problems). To compute this variable, we use the members built-in variable that corresponds to the list of micro-agents captured by the macro-agent.species building {\t...        list&lt;people_in_building&gt; people_inside -&gt; {members collect people_in_building(each)};\t...}We define a first reflex for the buildings that will be activated at each simulation step and that will allow the building to capture all the people that are inside its geometry and that are not moving (target = nil). Capturing agents means putting them inside its members list and changing their species: here the people agents become people_in_building agents.species building {\t...      reflex let_people_enter {\t\tlist&lt;people&gt; entering_people &lt;- people inside self where (each.target = nil);\t\tif not (empty (entering_people)) {\t\t\tcapture entering_people as: people_in_building ; \t\t}\t}        ....}We define a second reflex for the buildings that will be activated at each simulation step and that will allow the building to release some of the people_in_building agents. First, it increments the staying counter of all the people_in_building agents. Then it builds the list of leaving people by testing the same probability as before for all the people_in_building agents. Finally, if this list is not empty, it releases them as people agents (and gives them a new target point).species building {\t...       reflex let_people_leave  {\t\task members as: people_in_building{\t\t\tstaying_counter &lt;- staying_counter + 1;\t\t}\t\tlist&lt;people_in_building&gt; leaving_people &lt;- list&lt;people_in_building&gt;(members where (flip(people_in_building(each).staying_counter / staying_coeff)));\t\tif not (empty (leaving_people)) {\t\t\trelease leaving_people as: people in: world returns: released_people;\t\t\task released_people {\t\t\t\ttarget &lt;- any_location_in (one_of(building));\t\t\t}\t\t}\t}        ....}At last, we refine the aspect of the buildings: if there is not people inside the building, we draw it with gray color. If the number of people_in_building infected is higher than the number of people_in_building not infected, we draw it in red; otherwise in green.species building {\t...        aspect geom {\t \tint nbI &lt;- members count people_in_building(each).is_infected;\t\tint nbT &lt;- length(members);\t\tdraw shape color:nbT = 0 ? #gray : (float(nbI)/nbT &gt; 0.5 ? #red : #green) depth: height;\t}}global variablesIn order to take into account the people that are inside the buildings for the computation of nb_people_infected, we first build the list of people_in_building. As people_in_building is a macro species of building, we cannot compute it directly like for the other species, we then aggregate all the list people_inside of all building in a single list (list_people_in_buildings). Then, we compute the number of infected people as the number of people infected outside the building + the number of people infected inside them.global  {\t...\tlist&lt;people_in_building&gt; list_people_in_buildings update: (building accumulate each.people_inside) where (not dead(each));\tint nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected) + (empty(list_people_in_buildings) ? 0 : list_people_in_buildings count (each.is_infected));        ...}Complete Model global  {\tint nb_people &lt;- 500;\tfloat step &lt;- 1 #minutes;\tfloat infection_distance &lt;- 2.0 #m;\tfloat proba_infection &lt;- 0.05;\tint nb_infected_init &lt;- 5;\tfile roads_shapefile &lt;- file(\"../includes/road.shp\");\tfile buildings_shapefile &lt;- file(\"../includes/building.shp\");\tgeometry shape &lt;- envelope(roads_shapefile);\tgraph road_network;\tint current_hour update: (cycle / 60) mod 24;\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));\t\tlist&lt;people_in_building&gt; list_people_in_buildings update: (building accumulate each.people_inside) where (not dead(each));\tint nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected) + (empty(list_people_in_buildings) ? 0 : list_people_in_buildings count (each.is_infected));\t\tint nb_people_not_infected &lt;- nb_people - nb_infected_init update: nb_people - nb_people_infected;\tbool is_night &lt;- true update: current_hour &lt; 7 or current_hour &gt; 20;\t\tfloat infected_rate update: nb_people_infected/nb_people;\tinit {\t\tcreate road from: roads_shapefile;\t\troad_network &lt;- as_edge_graph(road);\t\tcreate building from: buildings_shapefile;\t\tcreate people number:nb_people {\t\t\tspeed &lt;- 5.0 #km/#h;\t\t\tbuilding bd &lt;- one_of(building);\t\t\tlocation &lt;- any_location_in(bd);\t\t}\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t\t\t}\treflex end_simulation when: infected_rate = 1.0 {\t\t\t\tdo halt;\t}}species people skills:[moving]{\t\t\tbool is_infected &lt;- false;\tpoint target;\tint staying_counter;\t\t\treflex move when: target != nil{\t\tdo goto target:target on: road_network;\t\tif (location = target) {\t\t\ttarget &lt;- any_location_in (one_of(building));\t\t\ttarget &lt;- nil;\t\t\tstaying_counter &lt;- 0;\t\t} \t}\treflex infect when: is_infected{\t\task people at_distance infection_distance {\t\t\tif flip(proba_infection) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(5) color:is_infected ? #red : #green;\t}\taspect sphere3D{\t\tdraw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green;\t}}species road {\tgeometry display_shape &lt;- shape + 2.0;\taspect geom {\t\tdraw display_shape color: #black depth: 3.0;\t}}species building {\tfloat height &lt;- 10#m + rnd(10) #m;\tlist&lt;people_in_building&gt; people_inside -&gt; {members collect people_in_building(each)};\t\taspect geom {\t\tint nbI &lt;- members count people_in_building(each).is_infected;\t\tint nbT &lt;- length(members);\t\tdraw shape color:nbT = 0 ? #gray : (float(nbI)/nbT &gt; 0.5 ? #red : #green) depth: height;\t}\t\tspecies people_in_building parent: people schedules: [] {\t\taspect circle{}\t\taspect sphere3D{}\t}\t\tspecies people_in_2 parent: people schedules: [] {\t\taspect circle{}\t\taspect sphere3D{}\t}\t\treflex let_people_leave  {\t\task members as: people_in_building{\t\t\tstaying_counter &lt;- staying_counter + 1;\t\t}\t\tlist&lt;people_in_building&gt; leaving_people &lt;- list&lt;people_in_building&gt;(members where (flip(people_in_building(each).staying_counter / staying_coeff)));\t\tif not (empty (leaving_people)) {\t\t\trelease leaving_people as: people in: world returns: released_people;\t\t\task released_people {\t\t\t\ttarget &lt;- any_location_in (one_of(building));\t\t\t}\t\t}\t}\treflex let_people_enter {\t\tlist&lt;people&gt; entering_people &lt;- people inside self where (each.target = nil);\t\tif not (empty (entering_people)) {\t\t\tcapture entering_people as: people_in_building ; \t\t}\t}}experiment main_experiment type:gui{\tparameter \"Infection distance\" var: infection_distance;\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\tparameter \"Nb people infected at init\" var: nb_infected_init ;\toutput {\t\tmonitor \"Current hour\" value: current_hour;\t\tmonitor \"Infected people rate\" value: infected_rate;\t\tdisplay map_3D type: opengl {\t\t\tlight 1 color:(is_night ? 50 : 255);\t\t\timage \"../includes/soil.jpg\";\t\t\tspecies road aspect:geom;\t\t\tspecies people aspect:sphere3D;\t\t\t\t\t\tspecies building aspect:geom transparency: 0.5;\t\t}\t\tdisplay chart refresh:every(10) {\t\t\tchart \"Disease spreading\" type: series {\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\t\t\t}\t\t}\t}}",
        "url":"/wiki/IncrementalModel_step6.html"
      }
      ,
    
      "wiki-incrementalmodel-step7-html": {
        "title": "7. Differential Equations",
        "content": "7. Differential EquationsThis step Illustrates how to use differential equationsFormulationWe are interested by the spreading of the disease inside the buildings. In order to model it, we will use differential equations. So, we will need to:  add two global variables to define the building epidemic properties (beta and h).  add new variables for the buildings (I, S, T, t, I_to_1);  define differential equations for disease spreading inside buildings  add a behavior for buildings for the spreading of the disease.Model Definitionglobal variablesWe define two new global variables that will be used disease spreading dynamic inside the buildings.global  {\t...\tfloat beta &lt;- 0.01;\tfloat h&lt;-0.1;        ...}buildingIn order to define the disease spreading dynamic, we define several variables that will be used by the differential equations:  I : float, number of people infected in the building  S : float, number of people not infected in the building  T : float, total number of people in the building  t : float, current time          I_to1 : float, remaining number of people infected (float number lower between 0 and 1 according to the differential equations).        species building {....float I;float S;float T; \tfloat t;    \tfloat I_to1;   ...}                    Then, we define the differential equations that will use for the disease spreading dynamic. Note that to define a differential equation system we use the block equation + name. These equations are the classic ones used by SI mathematical models.species building {\t....\tequation SI{ \t\tdiff(S,t) = (- beta * S * I / T) ;\t\tdiff(I,t) = (  beta * S * I / T) ;\t}       ...}At last, we define a new reflex for the building called epidemic that will be activated only when there is someone inside the building. This reflex first compute the number of people inside the building (T), then the number of not infected people (S) and finally the number of infected ones (I).If there is at least one people infected and one people not infected, the differential equations is integrated (according to the discretisation step value h) with the method Runge-Kutta 4 to compute the new value of infected people. We then sum the old value of I_to_1 with the number of people newly infected (this value is a float and not an integer). Finally, we cast this value as an integer, ask the corresponding number of not infected people to become infected, and decrement this integer value to I_to1.species building {\t....\treflex epidemic when: not empty(members){ \t\t\tT &lt;- float(length(members));\t\tlist&lt;people_in_building&gt; S_members &lt;- list&lt;people_in_building&gt;(members where not (people_in_building(each).is_infected));    \t        S &lt;- float(length(S_members));    \t        I &lt;- T-S;    \t        float I0 &lt;- I;    \t        if (I &gt; 0 and S &gt; 0) {    \t\t       solve SI method: \"rk4\" step: h;    \t\t       I_to1 &lt;- I_to1 + (I - I0);    \t\t       int I_int &lt;- min([int(S),int(I_to1)]);\t    \t       I_to1 &lt;- I_to1 - I_int;\t    \t       ask(I_int among S_members){\t    \t\t     is_infected &lt;- true;\t    \t      }               }    \t}       ...}Complete Modelmodel model7 global  {\tint nb_people &lt;- 500;\tfloat step &lt;- 1 #minutes;\tfloat infection_distance &lt;- 2.0 #m;\tfloat proba_infection &lt;- 0.05;\tint nb_infected_init &lt;- 5;\tfile roads_shapefile &lt;- file(\"../includes/road.shp\");\tfile buildings_shapefile &lt;- file(\"../includes/building.shp\");\tgeometry shape &lt;- envelope(roads_shapefile);\tgraph road_network;\tint current_hour update: (cycle / 60) mod 24;\tfloat staying_coeff update: 10.0 ^ (1 + min([abs(current_hour - 9), abs(current_hour - 12), abs(current_hour - 18)]));\tfloat beta &lt;- 0.01;\tfloat h&lt;-0.1;\tlist&lt;people_in_building&gt; list_people_in_buildings update: (building accumulate each.people_inside) where (not dead(each));\tint nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected) + (empty(list_people_in_buildings) ? 0 : list_people_in_buildings count (each.is_infected));\t\tint nb_people_not_infected &lt;- nb_people - nb_infected_init update: nb_people - nb_people_infected;\tbool is_night &lt;- true update: current_hour &lt; 7 or current_hour &gt; 20;\t\tfloat infected_rate update: nb_people_infected/nb_people;\tinit {\t\tcreate road from: roads_shapefile;\t\troad_network &lt;- as_edge_graph(road);\t\tcreate building from: buildings_shapefile;\t\tcreate people number:nb_people {\t\t\tspeed &lt;- 5.0 #km/#h;\t\t\tbuilding bd &lt;- one_of(building);\t\t\tlocation &lt;- any_location_in(bd);\t\t}\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t\t\t}\treflex end_simulation when: infected_rate = 1.0 {\t\t\t\tdo halt;\t}}species people skills:[moving]{\t\t\tbool is_infected &lt;- false;\tpoint target;\tint staying_counter;\t\t\treflex move when: target != nil{\t\tdo goto target:target on: road_network;\t\tif (location = target) {\t\t\ttarget &lt;- any_location_in (one_of(building));\t\t\ttarget &lt;- nil;\t\t\tstaying_counter &lt;- 0;\t\t} \t}\treflex infect when: is_infected{\t\task people at_distance infection_distance {\t\t\tif flip(proba_infection) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(5) color:is_infected ? #red : #green;\t}\taspect sphere3D{\t\tdraw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green;\t}}species road {\tgeometry display_shape &lt;- shape + 2.0;\taspect geom {\t\tdraw display_shape color: #black depth: 3.0;\t}}species building {\tfloat height &lt;- 10#m + rnd(10) #m;\tlist&lt;people_in_building&gt; people_inside -&gt; {members collect people_in_building(each)};\tfloat I;\tfloat S;\tfloat T;   \tfloat t;      \tfloat I_to1;    \t\taspect geom {\t\tint nbI &lt;- members count people_in_building(each).is_infected;\t\tint nbT &lt;- length(members);\t\tdraw shape color:nbT = 0 ? #gray : (float(nbI)/nbT &gt; 0.5 ? #red : #green) depth: height;\t}\t\tspecies people_in_building parent: people schedules: [] {\t}\t\treflex let_people_leave  {\t\task members as: people_in_building{\t\t\tstaying_counter &lt;- staying_counter + 1;\t\t}\t\tlist&lt;people_in_building&gt; leaving_people &lt;- list&lt;people_in_building&gt;(members where (flip(people_in_building(each).staying_counter / staying_coeff)));\t\tif not (empty (leaving_people)) {\t\t\trelease leaving_people as: people in: world returns: released_people;\t\t\task released_people {\t\t\t\ttarget &lt;- any_location_in (one_of(building));\t\t\t}\t\t}\t}\treflex let_people_enter {\t\tlist&lt;people&gt; entering_people &lt;- people inside self where (each.target = nil);\t\tif not (empty (entering_people)) {\t\t\tcapture entering_people as: people_in_building ; \t\t}\t}\tequation SI{ \t\tdiff(S,t) = (- beta * S * I / T) ;\t\tdiff(I,t) = (  beta * S * I / T) ;\t}\treflex epidemic when: not empty(members){ \t\t\tT &lt;- float(length(members));\t\tlist&lt;people_in_building&gt; S_members &lt;- list&lt;people_in_building&gt;(members where not (people_in_building(each).is_infected));    \tS &lt;- float(length(S_members));    \tI &lt;- T-S;    \tfloat I0 &lt;- I;    \tif (I &gt; 0 and S &gt; 0) {    \t\tsolve SI method: \"rk4\" step: h;    \t\tI_to1 &lt;- I_to1 + (I - I0);    \t\tint I_int &lt;- min([int(S),int(I_to1)]);\t    \tI_to1 &lt;- I_to1 - I_int;\t    \task(I_int among S_members){\t    \t\tis_infected &lt;- true;\t    \t}    \t}    }  }experiment main_experiment type:gui{\tparameter \"Infection distance\" var: infection_distance;\tparameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;\tparameter \"Nb people infected at init\" var: nb_infected_init ;\toutput {\t\tmonitor \"Current hour\" value: current_hour;\t\tmonitor \"Infected people rate\" value: infected_rate;\t\tdisplay map_3D type: opengl {\t\t\tlight 1 color:(is_night ? 50 : 255);\t\t\timage \"../includes/soil.jpg\";\t\t\tspecies road aspect:geom;\t\t\tspecies people aspect:sphere3D;\t\t\t\t\t\tspecies building aspect:geom transparency: 0.5;\t\t}\t\tdisplay chart refresh:every(10) {\t\t\tchart \"Disease spreading\" type: series {\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\t\t\t}\t\t}\t}}",
        "url":"/wiki/IncrementalModel_step7.html"
      }
      ,
    
      "wiki-index-html": {
        "title": "Exhaustive list of GAMA Keywords",
        "content": "Exhaustive list of GAMA KeywordsThis file is automatically generated from java files. Do Not Edit It.Operators-, :, ::, !, !=, ?, /, ., [^](OperatorsAC#^), @, [](OperatorsAC#), +, &lt;, &lt;=, &lt;&gt;, =, &gt;, &gt;=, abs, accumulate, acos, action, add_days, add_edge, add_hours, add_minutes, add_months, add_ms, add_node, add_point, add_seconds, add_weeks, add_years, adjacency, after, agent, agent_closest_to, agent_farthest_to, agent_from_geometry, agents_at_distance, agents_inside, agents_overlapping, all_pairs_shortest_path, alpha_index, among, and, and, angle_between, any, any_location_in, any_point_in, append_horizontally, append_vertically, arc, around, as, as_4_grid, as_distance_graph, as_driving_graph, as_edge_graph, as_grid, as_hexagonal_grid, as_int, as_intersection_graph, as_map, as_matrix, as_path, asin, at, at_distance, at_location, atan, atan2, attributes, BDIPlan, before, beta_index, between, betweenness_centrality, biggest_cliques_of, binomial, blend, bool, box, brewer_colors, brewer_palettes, buffer, build, ceil, centroid, char, circle, clean, closest_points_with, closest_to, collect, column_at, columns_list, command, cone, cone3D, connected_components_of, connectivity_index, container, contains, contains_all, contains_any, contains_edge, contains_vertex, conversation, convex_hull, copy, copy_between, corR, cos, cos_rad, count, covers, cross, crosses, crs, CRS_transform, csv_file, cube, curve, cylinder, date, dbscan, dead, degree_of, dem, det, determinant, diff, diff2, directed, direction_between, direction_to, disjoint_from, distance_between, distance_to, distinct, distribution_of, distribution2d_of, div, dxf_file, edge, edge_between, edge_betweenness, edges, eigenvalues, electre_DM, ellipse, emotion, empty, enlarged_by, envelope, eval_gaml, eval_when, even, every, every_cycle, evidence_theory_DM, exp, fact, farthest_point_to, farthest_to, file, file_exists, first, first_of, first_with, flip, float, floor, folder, font, frequency_of, from, fuzzy_kappa, fuzzy_kappa_sim, gaml_file, gamma_index, gamma_rnd, gauss, generate_barabasi_albert, generate_complete_graph, generate_watts_strogatz, geojson_file, geometric_mean, geometry, geometry_collection, get, get_about, get_agent, get_agent_cause, get_decay, get_dominance, get_familiarity, get_intensity, get_lifetime, get_liking, get_praiseworthiness, get_priority, get_solidarity, get_super_intention, gif_file, gini, graph, grayscale, grid_at, grid_cells_to_graph, grid_file, group_by, harmonic_mean, hexagon, hierarchical_clustering, hsb, hypot, IDW, image_file, in, in_degree_of, in_edges_of, indented_by, index_by, index_of, inside, int, inter, interleave, internal_at, internal_integrated_value, internal_zero_order_equation, intersection, intersects, inverse, inverse_distance_weighting, is, is_csv, is_dxf, is_finite, is_gaml, is_geojson, is_gif, is_grid, is_image, is_json, is_number, is_obj, is_osm, is_pgm, is_property, is_R, is_shape, is_skill, is_svg, is_text, is_threeds, is_URL, is_xml, json_file, kappa, kappa_sim, kmeans, kurtosis, last, last_index_of, last_of, last_with, layout, length, line, link, list, list_with, ln, load_graph_from_file, load_shortest_paths, log, lower_case, map, masked_by, material, matrix, matrix_with, max, max_of, maximal_cliques_of, mean, mean_deviation, mean_of, meanR, median, message, milliseconds_between, min, min_of, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_seconds, minus_weeks, minus_years, mod, months_between, moran, mul, nb_cycles, neighbors_at, neighbors_of, new_emotion, new_folder, new_predicate, new_social_link, node, nodes, norm, not, obj_file, of, of_generic_species, of_species, one_of, or, or, osm_file, out_degree_of, out_edges_of, overlapping, overlaps, pair, partially_overlaps, path, path_between, path_to, paths_between, percent_absolute_deviation, pgm_file, plan, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_seconds, plus_weeks, plus_years, point, points_along, points_at, points_on, poisson, polygon, polyhedron, polyline, polyplan, predecessors_of, predicate, predict, product, product_of, promethee_DM, property_file, pyramid, R_correlation, R_file, R_mean, range, read, rectangle, reduced_by, regression, remove_duplicates, remove_node_from, replace, replace_regex, reverse, rewire_n, rgb, rgb_to_xyz, rnd, rnd_choice, rnd_color, rotated_by, round, row_at, rows_list, sample, scaled_by, scaled_to, select, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_liking, set_solidarity, set_truth, set_z, shape_file, shuffle, signum, simple_clustering_by_distance, simple_clustering_by_envelope_distance, simplification, sin, sin_rad, since, skeletonize, skew_gauss, skewness, skill, smooth, social_link, solid, sort, sort_by, source_of, spatial_graph, species, species_of, sphere, split_at, split_geometry, split_lines, split_with, sqrt, square, squircle, standard_deviation, string, subtract_days, subtract_hours, subtract_minutes, subtract_months, subtract_ms, subtract_seconds, subtract_weeks, subtract_years, successors_of, sum, sum_of, svg_file, tan, tan_rad, tanh, target_of, teapot, text_file, TGauss, threeds_file, to, to_GAMA_CRS, to_gaml, to_rectangles, to_squares, to_triangles, tokenize, topology, touches, towards, trace, transformed_by, translated_by, translated_to, transpose, triangle, triangulate, truncated_gauss, undirected, union, unknown, until, upper_case, URL_file, use_cache, user_input, using, variance, variance_of, voronoi, weight_of, weighted_means_DM, where, with_lifetime, with_max_of, with_min_of, with_optimizer_type, with_praiseworthiness, with_precision, with_priority, with_values, with_weights, without_holes, writable, xml_file, years_between,Statements=, action, add, agents, annealing, ask, aspect, assert, benchmark, break, camera, capture, chart, conscious_contagion, create, data, datalist, default, diffuse, display, display_grid, display_population, do, draw, else, emotional_contagion, enter, equation, error, event, exhaustive, exit, experiment, export, focus, focus_on, genetic, graphics, highlight, hill_climbing, if, image, inspect, let, light, loop, match, migrate, monitor, output, output_file, overlay, parameter, perceive, permanent, plan, put, reactive_tabu, reflex, release, remove, return, rule, run, save, save_batch, set, setup, simulate, socialize, solve, species, state, status, switch, tabu, task, test, trace, transition, unconscious_contagion, user_command, user_init, user_input, user_panel, using, Variable_container, Variable_number, Variable_regular, warn, write,Architecturesfsm, parallel_bdi, probabilistic_tasks, reflex, simple_bdi, sorted_tasks, user_first, user_last, user_only, weighted_tasks,Constants and colors#aliceblue, #antiquewhite, #aqua, #aquamarine, #azure, #beige, #bisque, #black, #blanchedalmond, #blue, #blueviolet, #bold, #brown, #burlywood, #cadetblue, #camera_location, #camera_orientation, #camera_target, #chartreuse, #chocolate, #cl (#centiliter,#centiliters), #cm (#centimeter,#centimeters), #coral, #cornflowerblue, #cornsilk, #crimson, #custom, #cyan, #cycle (#cycles), #darkblue, #darkcyan, #darkgoldenrod, #darkgray, #darkgreen, #darkgrey, #darkkhaki, #darkmagenta, #darkolivegreen, #darkorange, #darkorchid, #darkred, #darksalmon, #darkseagreen, #darkslateblue, #darkslategray, #darkslategrey, #darkturquoise, #darkviolet, #day (#days), #deeppink, #deepskyblue, #dimgray, #dimgrey, #display_height, #display_width, #dl (#deciliter,#deciliters), #dm (#decimeter,#decimeters), #dodgerblue, #e, #epoch, #firebrick, #flat, #floralwhite, #foot (#feet,#ft), #forestgreen, #fuchsia, #gainsboro, #ghostwhite, #gold, #goldenrod, #gram (#grams), #gray, #green, #greenyellow, #grey, #h (#hour,#hours), #hl (#hectoliter,#hectoliters), #honeydew, #horizontal, #hotpink, #inch (#inches), #indianred, #indigo, #infinity, #iso_local, #iso_offset, #iso_zoned, #italic, #ivory, #kg (#kilo,#kilogram,#kilos), #khaki, #km (#kilometer,#kilometers), #l (#liter,#liters,#dm3), #lavender, #lavenderblush, #lawngreen, #lemonchiffon, #lightblue, #lightcoral, #lightcyan, #lightgoldenrodyellow, #lightgray, #lightgreen, #lightgrey, #lightpink, #lightsalmon, #lightseagreen, #lightskyblue, #lightslategray, #lightslategrey, #lightsteelblue, #lightyellow, #lime, #limegreen, #linen, #longton (#lton), #m (#meter,#meters), #m2, #m3, #magenta, #maroon, #max_float, #max_int, #mediumaquamarine, #mediumblue, #mediumorchid, #mediumpurple, #mediumseagreen, #mediumslateblue, #mediumspringgreen, #mediumturquoise, #mediumvioletred, #midnightblue, #mile (#miles), #min_float, #min_int, #mintcream, #minute (#minutes,#mn), #mistyrose, #mm (#milimeter,#milimeters), #moccasin, #month (#months), #msec (#millisecond,#milliseconds,#ms), #nan, #navajowhite, #navy, #none, #now, #oldlace, #olive, #olivedrab, #orange, #orangered, #orchid, #ounce (#oz,#ounces), #palegoldenrod, #palegreen, #paleturquoise, #palevioletred, #papayawhip, #peachpuff, #peru, #pi, #pink, #pixels (#px), #plain, #plum, #pound (#lb,#pounds,#lbm), #powderblue, #purple, #red, #rosybrown, #round, #royalblue, #saddlebrown, #salmon, #sandybrown, #seagreen, #seashell, #sec (#second,#seconds,#s), #shortton (#ston), #sienna, #silver, #skyblue, #slateblue, #slategray, #slategrey, #snow, #split, #springgreen, #sqft (#square_foot,#square_feet), #sqin (#square_inch,#square_inches), #sqmi (#square_mile,#square_miles), #square, #stack, #steelblue, #stone (#st), #tan, #teal, #thistle, #to_deg, #to_rad, #tomato, #ton (#tons), #transparent, #turquoise, #user_location, #vertical, #violet, #week (#weeks), #wheat, #white, #whitesmoke, #yard (#yards), #year (#years,#y), #yellow, #yellowgreen, #zoom,Skillsadvanced_driving, driving, fipa, GAMASQL, grid, MDXSKILL, messaging, moving, moving3D, network, physics, skill_road, skill_road_node, SQLSKILL,Speciesagent, AgentDB, base_edge, experiment, graph_edge, graph_node, model, physical_world,    \tworldActionsinit, step, isConnected, close, timeStamp, connect, testConnection, select, executeUpdate, getParameter, setParameter, insert, update_outputs, related_to, pause, halt, compute_forces, advanced_follow_driving, is_ready_next_road, test_next_road, compute_path, path_from_nodes, drive_random, drive, external_factor_impact, speed_choice, lane_choice, follow_driving, goto_driving, start_conversation, send, reply, accept_proposal, agree, cancel, cfp, end_conversation, failure, inform, propose, query, refuse, reject_proposal, request, subscribe, testConnection, read, SqlObject, timeStamp, testConnection, select, send, wander, move, follow, goto, move, execute, connect, fetch_message, has_more_message, leave_the_group, register, unregister, timeStamp, getCurrentDateTime, getDateOffset, testConnection, executeUpdate, insert, select, list2Matrix,Variablesspeed, real_speed, current_path, final_target, current_target, current_index, targets, security_distance_coeff, current_lane, vehicle_length, speed_coeff, max_acceleration, current_road, on_linked_road, proba_lane_change_up, proba_lane_change_down, proba_respect_priorities, proba_respect_stops, proba_block_node, proba_use_linked_road, right_side_driving, max_speed, distance_to_goal, segment_index_on_road, living_space, lanes_attribute, tolerance, obstacle_species, speed, conversations, accept_proposals, agrees, cancels, cfps, failures, informs, proposes, queries, refuses, reject_proposals, requests, requestWhens, subscribes, color, neighbors, grid_value, bands, grid_x, grid_y, mailbox, location, speed, heading, current_path, current_edge, real_speed, destination, speed, heading, pitch, roll, destination, network_name, network_groups, network_server, space, density, mass, velocity, collisionBound, motor, agents_on, all_agents, source_node, target_node, lanes, linked_road, maxspeed, roads_in, priority_roads, roads_out, stop, block,Pseudo-Variablesself, myself, eachTypesbool, float, int, string, agent, container, file, geometry, graph, list, map, matrix, pair, path, point, rgb, color, species, topologythe worldtorus, Environment Size, world, timecycle, step, time, duration, total_durationaverage_duration, machine_time, agents, stop, halt, pause, schedulingGridgrid_x, grid_y, agents, color, grid_valueOther conceptsscheduling, step, Key concepts, [KeyConcepts#Vocabulary_correspondance_with_the_agent-based_paradigm_as_in_Ne correspondance GAMA Netlogo], operators statements type species",
        "url":"/wiki/Index.html"
      }
      ,
    
      "wiki-inheritance-html": {
        "title": "Inheritance",
        "content": "InheritanceAs for multiple programming language, inheritance can be used in GAML. It is used to structure better your code, when you have some complex models.Index  Mother species / child species  Virtual actions  Get all the subspecies from a speciesMother species / child speciesTo make a species inherit from a mother species, you have to add the facet parent, and specify the mother species.species mother_species {}species child_species parent:mother_species {}Thus, all the attributes, actions and reflex of the mother species are inherited to the child species.species mother_species {\tint attribute_A;\taction action_A {}}species child_species parent:mother_species {\tinit {\t\tattribute_A &lt;- 5;\t\tdo action_A;\t}}If the mother species has a particular skill, its children will inherit all the attributes and actions.species mother_species skills:[moving] {}species child_species parent:mother_species {\tinit {\t\tspeed &lt;- 2.0;\t}\treflex update {\t\tdo wander;\t}}You can redefine an action or a reflex by declaring an action or a reflex with the same name.Virtual actionYou have also the possibility to declare a virtual action in the mother species, which means an action without implementation, by using the facet virtual:action virtual_action virtual:true;When you declare an action as virtual in a species, this species becomes abstract, which means you cannot instantiate agent from it. All the children of this species has to implement this virtual action.species virtual_mother_species {\taction my_action virtual:true;}species child_species parent:virtual_mother_species {\taction my_action {\t\t// some statements\t}}Get all the subspecies from a speciesIf you declare a “mother” species, you create a “child” agent, then “mother” will return the population of agents “mother” and not the population of agents “child”, as it is shown in the following example :global{    init {        create child number:2;        create mother number:1;    }    reflex update {        write length(mother); // will write 1 and not 3    }}species mother {}species child parent:mother {}We reminds you that “subspecies” is a built-in attribute of the agent. Using this attribute, you can easily get all the subspecies agents of the mother species by writing the following gaml function :global{    init {        create child number:2;        create mother number:1;    }    reflex update {        write length(get_all_instances(mother)); // will write 3 (1+2)    }    list&lt;agent&gt; get_all_instances(species&lt;agent&gt; spec) {        return spec.population +  spec.subspecies accumulate (get_all_instances(each));    }}species mother {}species child parent:mother {}",
        "url":"/wiki/Inheritance.html"
      }
      ,
    
      "wiki-init-action-init-action-html": {
        "title": "InitAction",
        "content": "InitActionAuthor : Alexis DrogoulThis simple example shows how to use the init callback action to build a simulation with some parameters, without declaring them as parametersCode of the model :model InitActionglobal {\tint agent_number &lt;- 100;\trgb agent_color &lt;- #red;\t\tinit {\t\tcreate my_agents number: agent_number;\t}}species my_agents {\taspect default {\t\tdraw square(5) color: agent_color;\t}}experiment InitAction type: gui {\t\taction _init_ {\t\tmap&lt;string, int&gt; params &lt;- user_input([\"Number of agents\"::100, \"Color\"::#red, \"2D\"::true]);\t\tcreate InitAction_model with: [agent_number::params[\"Number of agents\"], agent_color::rgb(params[\"Color\"])];\t}\t\toutput {\t\tdisplay Simple {\t\t\tspecies my_agents;\t\t}\t}\t}",
        "url":"/wiki/Init-Action-Init-Action.html"
      }
      ,
    
      "wiki-init-action-html": {
        "title": "Init Action",
        "content": "Init ActionThis sub-section is composed of the following models :  InitAction",
        "url":"/wiki/Init-Action.html"
      }
      ,
    
      "wiki-inspectorsandmonitors-html": {
        "title": "Inspectors and monitors",
        "content": "Inspectors and monitorsGAMA offers some tools to obtain informations about one or several agents. There are two kinds of tools :  agent browser  agent inspectorGAMA offers as well a tool to get the value of a specific expression: monitors.Table of contents  Inspectors and monitors          Agent Browser      Agent Inspector      Monitor      Agent BrowserThe species browser provides informations about all or a selection of agents of a species.The agent browser is available through the Agents menu or by right clicking on a display (screenshots from the ).It displays in a table all the values of the agent variables of the considered species; each line corresponding to an agent. The list of attributes is displayed on the left side of the view, and you can select the attributes you want to be displayed, simply by clicking on it (Ctrl + Click for multi-selection).By clicking on the right mouse button on a line, it is possible to do some action for the corresponding agent.Agent InspectorThe agent inspector provides information about one specific agent. It also allows to change the values of its variables during the simulation. The agent inspector is available from the Agents menu, by right_clicking on a display, in the species inspector or when inspecting another agent.It is possible to «highlight» the selected agent.To change the color of the highlighted agent, go to Preferences/Display.MonitorMonitors allow to follow the value of a GAML expression. For instance the following monitor allow to follow the number of infected people agents during the simulation. The monitor is updated at each simulation step.It is possible to define a monitor inside a model (see this page). It is also possible to define a monitor through the graphical interface.To define a monitor, first choose Add Monitor in the Views menu (or by clicking on the icon in the Monitor view), then define the display legend and the expression to monitor.In the following example, we defined a monitor with the legend “Number initial of preys” and that has for value the global variable “nb_preys_init”.The expression should be written with the GAML language. See this page for more details about the GAML language.",
        "url":"/wiki/InspectorsAndMonitors.html"
      }
      ,
    
      "wiki-installation-html": {
        "title": "Installation",
        "content": "InstallationGAMA 1.7 comes in 5 different versions (32 &amp; 64 bits for Windows &amp; Linux, and 64 bits for MacOS X). You first need to determine which version to use (it depends on your computer, which may, or not, support 64 bits instructions, but also on the version of Java already installed, as the number of bits of the two versions must match).You can then download the right version from the Downloads page, expand the zip file wherever you want on your machine, and launch GAMA.Table of contents  Installation          System Requirements      Installation of Java                  On MacOS X          On Windows          On Ubuntu &amp; Linux                    System RequirementsGAMA 1.7 requires that Java 1.8 be installed on your machine, approximately 200MB of disk space and a minimum of 4GB of RAM (to increase the portion of memory usable by GAMA, please refer to these instructions).MacOSIn some cases, “Archive utility.app” in MacOS may damage the files when extracting them from the zip or tar.gz archive files. This problem manifests itself by a dialog opening and explaining that the application is damaged and cannot be launched (see Issue 2082 and also this thread. In that case, to expand the files, consider using a different utility, like the free Stuffit Expander or directly from the command line.MacOS Sierra has introduced a series of issues linked to the so-called “quarantine” mode (where applications downloaded from Internet prevent to use and update their internal components, such as the models of the library or the self-updating of the application). See this page for background information. To be certain that Gama will work, and until we find an easier solution, the installation should follow these steps:  Download the GAMA zip file  Unzip it (possibly with another archive utility, see above)  Copy and paste Gama in the Applications folder  Launch Terminal.app  Type cd /Applications and hit return.  Type xattr -d -r com.apple.quarantine Gama.app/ and hit return to remove the quarantine attributeFrom now on, Gama should be fully functional.Installation of JavaOn all environments, the recommended Java Virtual Machine under which GAMA has been tested is the one distributed by Oracle (http://www.java.com/en/download/manual.jsp). It may work with others — or not. For better performances, you may also want to install the JDK version of the JVM (and not the standard JRE), although is it not mandatory  (GAMA should run fine, but slower, under a JRE).On MacOSThe latest version of GAMA requires a JVM (or JDK or JRE) compatible with Java 1.8 to run.Note for GAMA 1.6.1 users: if you plan to keep a copy of GAMA 1.6.1, you will need to have both Java 1.6 (distributed by Apple) and Java 1.8 (distributed by Oracle) installed at the same time. Because of this bug in SWT (https://bugs.eclipse.org/bugs/show_bug.cgi?id=374199), GAMA 1.6.1 will not run correctly under Java 1.8 (all the displays will appear empty). To install the JDK 1.6 distributed by Apple, follow the instructions here : http://support.apple.com/kb/DL1572. Alternatively, you might want to go to https://developer.apple.com/downloads and, after a free registration step if you’re not an Apple Developer, get the complete JDK from the list of downloads.On WindowsPlease notice that, by default, Internet Explorer and Chrome browsers will download a 32 bits version of the JRE. Running GAMA 32 bits for Windows is ok, but you may want to download the latest JDK instead, in order to both improve the performances of the simulator and be able to run GAMA 64 bits.  To download the appropriate java version, follow this link: http://www.java.com/en/download/manual.jsp  Execute the downloaded file  You can check that a Java\\jre8 folder has been installed at the location C:\\Program Files\\In order for Java to be found by Windows, you may have to modify environment variables:  Go to the Control Panel  In the new window, go to System  On the left, click on Advanced System parameters  In the bottom, click on Environment Variables  In System Variables, choose to modify the Path variable  At the end, add ;C:\\Program Files\\Java\\jre8\\bin (or jre8\\bin)On Ubuntu &amp; LinuxTo have a complete overview of java management on Ubuntu, have a look at:  Ubuntu Java documentation  for French speaking users: http://doc.ubuntu-fr.org/java#installations_alternativesBasically, you need to do:sudo add-apt-repository ppa:webupd8team/javasudo apt-get updatesudo apt-get install oracle-java8-installer You can then switch between java version using:sudo update-alternatives --config javaSee the troubleshooting page for more information on workaround for problems on Unbuntu.",
        "url":"/wiki/Installation.html"
      }
      ,
    
      "wiki-installationandlaunching-html": {
        "title": "Installation and Launching",
        "content": "Installation and LaunchingThe GAMA platform can be easily installed in your machine, either if you are using Windows, Mac OS or Ubuntu. GAMA can then be extended by using a number of additional plugins.This part is dedicated to explain how to install GAMA, launching GAMA and extend the platform by installing additional plugins. All the known issues concerning installation are also explain. The GAMA team provides you a continuous support by proposing corrections to some serious issues through updating patchs. In this part, we will also present you briefly an other way to launch GAMA without any GUI : the headless mode.  Installation  Launching GAMA  Headless Mode  Updating GAMA  Installing Plugins  Troubleshooting",
        "url":"/wiki/InstallationAndLaunching.html"
      }
      ,
    
      "wiki-installinggitversion-html": {
        "title": "Installing the GIT version",
        "content": "Installing the GIT versionTested on MacOS X (10.9 to 10.11), Windows (8 to 10) and Ubuntu 15.04 (Vivid)Important note: the current Git version is not compatible with the GAMA 1.6.1 release: if you plan to create plugins for this release, please download the source at revision r11988 (on Google Code) and Eclipse following this procedureInstall Eclipse Mars SR2Download the “Eclipse IDE for Java and DSL Developers” version (If Java is not installed on your computer you can download it here).Unpack it and launch it. Please refer to this link for more information on running Eclipse.One important step required for GAMA to correctly produce its supporting files once it will have been installed is to set the default encoding of the workspace to UTF-8. It can be done by selecting, in the Preferences, “General”, then “Workspace”, then “Text file encoding” and choosing “UTF-8” in the drop-down menu available in “Other:”.Install GAMA source codeThe source is to be downloaded from GitHub in two steps: by creating a local clone of the GitHub repository and then importing the different projects that constitute GAMA into the Eclipse workspace.  Open the Git perspective:          Windows &gt; Perspective &gt; Open Perspective &gt; Other…      Choose Git        Click on “Clone a Git repository”          In Source Git repository window:              Fill in the URI label with: https://github.com/gama-platform/gama.git      Other fields will be automatically filled in.        * In Branch Selection windows,      check the master branch      Next      Note: If you are using Ubuntu 16 and you did not find any branch in this windows, may be your eclipse has a bug related with the OS. The workaround should be:                  Close eclipse          Open eclipse.ini          Add these 2 lines before –launcher.appendVmargs:                –launcher.GTK_version   2                  Change required version of java from : -Dosgi.requiredJavaVersion=1.7 into -Dosgi.requiredJavaVersion=1.8          Remove this line: -XX:MaxPermSize=256m          Save and close eclipse.ini          Start eclipse and redo from step 1                      In Local Destination windows,          Choose a Directory (where the source files will be downloaded).      Everything else should be unchecked      FinishThis can take a while…      Import projects into workspaceYou have now to import projects into the workspace (notice that the folders downloaded during the clone will neither be copied nor moved).  In the Git perspective and the Git Repositories view, Right-Click on “Working Tree” inside the gama repository, and choose “Import projects”          In the Select a wizard to use for importing projects window:              “Import existing projects” should be checked      “Working Tree” should be selected        * In Import Projects window:      Uncheck « Search for nested project »      Check the projects you want to import      Finish        Go back to the Java perspective  Clean project (Project menu &gt; Clean …)If you have errors…If errors continue to show on in the different projects, be sure to correctly set the JDK used in the Eclipse preferences. GAMA is targeting JDK 1.8, and Eclipse will produce errors if it not found in your environment. So, either you set the compatibility to 1.8 by default (in Preferences &gt; Java &gt; Compiler &gt; Compiler Compliance Level) or you change the error produced by Eclipse to a warning only (in Preferences &gt; Java &gt; Compiler &gt; Building &gt; “No strictly compatible JRE for execution environment available).Run GAMA  In the ummisco.gama.product plugin, open the gama.runtime.product file (gama.product is used to produce the release).  Go to “Contents” tab and click on “Add required”  Go to “Overview” tab and click on Synchronize  Click on Launch an Eclipse Application###GIT TutorialsFor those who want learn more about Git and Egit, please consult the following tutorials/papers  EGIT/User Guide http://wiki.eclipse.org/EGit/User_Guide  Git version control with Eclipse (EGIT) - Tutorial http://www.vogella.com/tutorials/EclipseGit/article.html  10 things I hate about Git http://stevebennett.me/2012/02/24/10-things-i-hate-about-git/  Learn Git and GitHub Tutorial https://www.youtube.com/playlist?list=PL1F56EA413018EEE1",
        "url":"/wiki/InstallingGitVersion.html"
      }
      ,
    
      "wiki-installingplugins-html": {
        "title": "Installing Plugins",
        "content": "Installing PluginsBesides the plugins delivered by the developers of the GAMA platform, which can be installed and updated as explained here, there are a number of additional plugins that can be installed to add new functionalities to GAMA or enhance the existing ones. GAMA being based on Eclipse, a number of plugins developed for Eclipse are then available (a complete listing of Eclipse plugins can be found in the so-called Eclipse MarketPlace).There are, however, three important restrictions:  The current version of GAMA is based on Eclipse Juno (version number 3.8.2), which excludes de facto all the plugins targeting solely the 4.3 (Kepler) or 4.4 (Luna) versions of Eclipse. These will refuse to install anyway.  The Eclipse foundations in GAMA are only a subset of the complete Eclipse platform, and a number of libraries or frameworks (for example the Java Development Toolkit) are not (and will never be) installed in GAMA. So plugins relying on their existence will refuse to install as well.  Some components of GAMA rely on a specific version of other plugins and will refuse to work with other versions, essentially because their compatibility will not be ensured anymore. For instance, the parser and validator of the GAML language in GAMA 1.6.1 require XText v. 2.4.1 to be installed (and neither XText 2.5.4 nor XText 2.3 will satisfy this dependency).With these restrictions in mind, it is however possible to install interesting additional plugins. We propose here a list of some of these plugins (known to work with GAMA), but feel free to either add a comment if you have tested plugins not listed here or create an issue if a plugin does not work, in order for us to see what the requirements to make it work are and how we can satisfy them (or not) in GAMA.Table of contents  Installing Plugins          Installation      Selected Plugins                  Overview          Git          [CKEditor] (#ckeditor)          Startexplorer          Pathtools          CSV Edit          Quickimage                    InstallationInstalling new plugins is a process identical to the one described when updating GAMA, with one exception: the update site to enter is normally provided by the vendor of the additional plugin and must be entered instead of GAMA’s one in the dialog. Let us suppose, for instance, that we want to install a RSS feed reader available on this site.An excerpt from the page reads that :  All plugins are installed with the standard update manager of Eclipse. It will guide you through the installation process and also eases keeping your plugins up-to-date. Just add the update site: http://www.junginger.biz/eclipse/So we just have to follow these instructions, which leads us to the following dialog, in which we select “RSS view” and click “Next”.The initial dialog is followed by two other ones, a first to report that the plugin satisfies all the dependencies, a second to ask the user to accept the license agreement.||||—|—|Once we dismiss the warning that the plugin is not signed and accept to restart GAMA, we can test the new plugin by going to the “Views” menu.The new RSS view is available in the list of views that can be displayed in GAMA.And we can enjoy (after setting some preferences available in its local menu) monitoring the Issues of GAMA from within GAMA itself !Selected PluginsIn addition to the RSS reader described above, below is a list of plugins that have been tested to work with GAMA. There are many others so take the time to explore them !Overview  A very useful plugin for working with large model files. It renders an overview of the file in a separate view (with a user selectable font size), allowing to know where the edition takes place, but also to navigate very quickly and efficiently to different places in the model.  Update site: http://sandipchitaleseclipseplugins.googlecode.com/svn/trunk/text.overview.updatesite/site.xml  After installing the plugin, an error might happen when closing GAMA. It is harmless. After restarting GAMA, go to Views &gt; Open View &gt; Others… &gt; Overview &gt;.Git  Git is a version control system (like CVS or SVN, extensively used in GAMA) http://git-scm.com/. Free sharing space are provided on GitHub among others. Installing Git allows to share or gather models that are available in Git repositories.  Update site (general): http://download.eclipse.org/releases/mars/ (Alternatively, you can use http://download.eclipse.org/egit/updates)  Select the two following plugins:          Eclipse EGit      Git Team Provider Core      CKEditor  CKEditor is a lightweight and powerful web-based editor, perfect for almost WYSIWYG edition of HTML files. It can be installed, directly in GAMA, in order to edit .html, .htm, .xml, .svg, etc. files directly without leaving the platform. No other dependencies are required. A must !  Update site: http://kosz.bitbucket.org/eclipse-ckeditor/update-siteStartexplorer  A nice utility that allows the user to select files, folders or projects in the Navigator and open them in the filesystem (either the UI Explorer, Finder, whatever, or in a terminal).  Update site: http://basti1302.github.com/startexplorer/update/Pathtools  Same purpose as StartExplorer, but much more complete, and additionally offers the possibility to add new commands to handle files (open them in specific editors, execute external programs on them, etc.). Very nice and professional. Works flawlessly in GAMA except that contributions to the toolbar are not accepted (so you have to rely on the commands present in the Navigator pop-up menu).  Update site: http://pathtools.googlecode.com/svn/trunk/PathToolsUpdateSite/site.xml  Website: https://pathtools.googlecode.comCSV Edit  An editor for CSV files. Quite handy if you do not want to launch Excel every time you need to inspect or change the CSV data files used in models.  Update site: http://csvedit.googlecode.com/svn/trunk/csvedit.updateTM Terminal  A powerful, yet simple, terminal which can connect locally or via ssh or other methods.  Update site (general): http://download.eclipse.org/releases/mars/  Select the following plugin: TM TerminalQuickimage  A lightweight viewer of images, which can be useful when several images are used in a model.  Update site: http://psnet.nu/eclipse/updates",
        "url":"/wiki/InstallingPlugins.html"
      }
      ,
    
      "wiki-installingsvnoldversions-html": {
        "title": "Installing the SVN version",
        "content": "Installing the SVN versionThese installation procedures have been tested on MacOS X 10.6 to 10.9, and Windows 8. On Mac OS X 10.10 (Yosemite), please have a look here: install Java on Yosemite for details about the Java version to use. Eclipse 3.8.2 is the recommended Eclipse version to install GAMA. Kepler install is still experimental.Important note: the current SVN version is no more compatible with the GAMA 1.6.1 release.  If you plan to create plugin that should be compatible with the release, please download the GAMA code source at revision r11988 (on Google Code).  If you want to have the last GAMA version (new GUI and APIs), you can download the head revision. The eclipse install should also be updated:          EMF should be updated to the latest release available (2.10.2 in Apr. 2015)      Xtext should be updated to the latest release (2.8.2 in April 2015)      SWT 4.4      ummisco.gaml.editbox plugin is now mandatory.      Detailed Instructions for Eclipse 4.4.2 (Luna SR2)Get and configure Eclipse Luna  Download the Eclipse Modeling Tools version of Luna SR2    * https://eclipse.org/downloads/packages/eclipse-modeling-tools/lunasr2  Unpack it anywhere and run it  Choose a new workspace    * A workspace is a folder in which Eclipse stores all your projects.  Install the required plugins. � Help � -&gt; � Install new software �    * In “work with”, write “http://download.eclipse.org/modeling/tmf/xtext/updates/composite/releases/”, click on “Add” and choose a name (e.g. Xtext)          In “Xtext”, install the following one:                  Xtext Complete SDK\t2.8.2.v201504100559                    Get code source from GitHubIn Eclipse:  Windows &gt; Open Perspective &gt; Other�    * Git  Click on “Clone a Git repository”    * First window:          URI: https://github.com/gama-platform/gama.git                  Branch Selection:                    Check master      Next                  Local Destination                    Choose a Directory      Finish      You have then to import projects:  Right-Click on Working Directory &gt; Import projects    * Select a wizard to use for importing projects:          “Import existing projects” should be  checked      “Working Directory” should be selected      Next                  In Import Projects:                    Uncheck ��Search for nested project��      Check the projects you want to import      Finish      Go back to the Java perspectiveDetailed Instructions for Eclipse 3.7.2 (Indigo)PLEASE NOTE THAT SUPPORT FOR THIS INSTALLATION HAS BEEN STOPPED. IF YOU CANNOT RUN A NEWER VERSION OF ECLIPSE, THEN YOU HAVE TO CHECKOUT THE LATEST VERSION OF GAMA WORKING IN INDIGO (r11438 (on Google Code)).  Download the Eclipse Modeling Tools version of Indigo    * http://www.eclipse.org/downloads/packages/eclipse-modeling-tools/indigosr2  Unpack it anywhere and run it  Choose a new workspace    * A workspace is a folder in which Eclipse stores all your projects.  Install the required plugins. � Help � -&gt; � Install new software �    * In “Work with”, type “http://download.eclipse.org/technology/subversive/0.7/update-site/” and install:          In “Subversive SVN Team Provider Plugin (Incubation)”                  Subversive SVN Team Provider (Incubation)\t0.7.9.I20120520-1700          In “work with”, write “http://download.eclipse.org/modeling/tmf/xtext/updates/composite/releases/”, click on “Add” and choose a name (e.g. Xtext)                    In “Xtext-2.4.1”   (to see it, you have to uncheck the “Show only the latest versions of available software”)                  Xtext SDK\t2.4.1.v201304180855          If you plan to build a release version, in “work with”, write “http://download.eclipse.org/tools/orbit/downloads/drops/R20110523182458/repository/”, click on “Add” and choose a name (e.g. ICU)                    Type ‘icu’ in the text filter.      The site should propose you a list of plugins. Choose (if this version is not available, untick (“Show only the latest versions”).                  International Components for Unicode for Java (ICU4J) Replacement plug-in\t4.4.2.v20110208                      Eclipse proposes to restart -&gt; Restart now  Add SVN repository exploring perspective    * To activate this perspective, choose Window / Open Perspective / Other… and select “SVN Repository Exploring”    * A popup appears (Discovery of SVN connector)    * Choose: SVN Kit 1.7.x          Popup Unsigned content -&gt; ok                  Popup -&gt; restart now                      Configure a new repository location:    * File &gt; New &gt; Other… &gt; SVN &gt; Repository Location    * URL: https://gama-platform.googlecode.com/svn    * Finish (&amp; wait)  Checkout of the GAMA code source    * In the SVN repository view, navigate to the directory “branches/GAMA_CURRENT” and select “Find/Checkout As…” from the contectual menu.    * Choose “Find projects in the children of the selected resource” and follow the indications.    * Pop-up “Check Out projects”, all projects should be selected. Finish.    * Once the checkout is finished, switch to Java Perspective.To compile and run GAMA properly, you will need to configure your Eclipse IDE and the GAMA .product file.  By default, Eclipse uses Java 7 when it is installed whereas GAMA only needs Java 6. On MacOS X in particular, we may have to change the version of the JDK to ensure that GAMA will run smoothly.    * Window-&gt;Preferences    * In: Java / Compiler: set “Compiler compliance level” to 1.6    * In: Java / Installed JREs -&gt; Add -&gt; Standard VM -&gt; JRE home -&gt; Directory and choose the directory of a Java 6 JDK (preferable) or a Java 7 JDK (except for MacOS X, see Installation).          Download the JDK 6 (for Windows &amp; Linux) here      Download the JDK 7 (for Windows &amp; Linux) here.      Download the JDK 6 (for Mac OS X) here. To switch between 1.7 and 1.6 (if both are installed), look at the use of java-home on this page.                  In: Java / Installed JREs -&gt; select Java 1.6 (for Mac) or 1.7 (on Windows &amp; Linux).                      You should configure the GAMA .product file depending on your OS.    * In the msi.gama.application project, open the gama1.6.1.feature_based_release.product file.    * In: the “Launching” tab: check whether the launching options are correct          In particular, for a 32bits OS, you have to change in “VM Arguments” “-Xmx1536m” into “-Xmx1024m”      For 64bits OS, check that the option “-d32” is not in the “VM Arguments” (otherwise delete it) in the “macosx” specific tab.        Compile and Run GAMA    * Do a “Project -&gt; Clean… (clean all projects)”    * In the .product file, in “Overview” tab:          click on the � Synchronize � link. This will ensure your product has updated the inclusion of the plugins (from both Eclipse and the new XText). Do not forget to save it.      The product, or some of the included features, may complain about missing plugins (identified by an error icon on the plugin icon in the dependencies view). It is normal for “fragments” that apply to another OS than yours and it is harmless in this case. If you are, however, concerned about this, you can install the “delta-pack” for Eclipse 3.7.2 or Eclipse 3.8.2 (follow these steps: http://ugosan.org/eclipse-rcp-delta-pack/. The delta pack itself can be downloaded from here).      If one of the missing plugins happens to be “com.ibm.icu.base” (and you did not want to install it as told above), you can replace it by “com.ibm.icu” without worries.      As of GAMA 1.6.1, we use a version of the SWT binary fragments that is not the one shipped with Eclipse Indigo nor Juno. Although it is not mandatory to use it, it is required if you plan to produce release versions of GAMA from your product. To install it, simply download this file and install it like the delta pack above.      click on the � Launch an Eclipse application � link. Note that a run configuration will be automatically created allowing to only click on the run button for future runs.      If the GAMA launch crashes:  Open Run configurations….  In Eclipse Application / gama1.6.1.feature_based_release.product configuration, open the plug-ins pane  After Launch with: , choose “all workspace and enable plug-ins”.Detailed Instructions for Eclipse 3.8.2First note that GAMA will not work with the packaged Juno version (in fact version 4.2 of Eclipse). Instead, you will need to download the core Eclipse package (Eclipse SDK) from http://archive.eclipse.org/eclipse/downloads/drops/R-3.8.2-201301310800/ , and to install additional plugins using this repository: http://download.eclipse.org/releases/juno/ . Among these additional plugins, only the EMF (Eclipse Modeling Framework) components should be necessary. In “Modeling”:  EMF - Eclipse Modeling Framework SDK  EMF Validation Frameworkd SDKThe same instructions (than for Eclipse 3.7.2) can then be applied to this installation, with three differences :  The delta-pack for Juno is available here.  The name of the product to use is  gama1.6.1.feature_based_Eclipse3_8_2_updatable_release.product  The version of XText to use is 2.8.2 and it should be obtained from here, as this site will also provide updates for EMF and other components necessary for XText to work (you may need to install these components first, notably EMF ones, if the installation of XText does not work).Detailed Instructions for Eclipse 4.3.2 (Kepler)  Download the Eclipse Modeling Tools version          http://www.eclipse.org/downloads/packages/eclipse-modeling-tools/keplersr2                  Unpack it anywhere and run it          Choose a new workspace                            A workspace is a folder in which Eclipse stores all your projects.                  Install the required plugins. � Help � -&gt; � Install new software �                    In “Work with”, type “http://download.eclipse.org/technology/subversive/0.7/update-site/” and install:                  In “Subversive SVN Team Provider Plugin (Incubation)”                          Subversive SVN Team Provider (Incubation)\t0.7.9.I20120520-1700                                          In “work with”, write “http://download.itemis.de/updates/”, click on “Add” and choose a name (e.g. Xtext)                  In “Xtext-2.5.3”                          Xtext SDK\t2.5.3.v20140220820                                In “Xtext Antlr-2.1.0”                          Xtext Antlr SDK 2.1.0.v201308291703                                          If you plan to build a release version, in “work with”, write “http://download.eclipse.org/tools/orbit/downloads/drops/R20110523182458/repository/”, click on “Add” and choose a name (e.g. ICU)                  Type ‘icu’ in the text filter.          The site should propose you a list of plugins. Choose (if this version is not available, untick (“Show only the latest versions”).                          International Components for Unicode for Java (ICU4J) Replacement plug-in\t4.4.2.v20110208     1. Eclipse proposes to restart -&gt; Restart now     1. Add SVN repository exploring perspective                                          To activate this perspective, choose Window / Open Perspective / Other… and select “SVN Repository Exploring”      A popup appears (Discovery of SVN connector)      Choose: SVN Kit 1.7.x                  Popup Unsigned content -&gt; ok                    Popup -&gt; restart now                  New &gt; repository location                    https://gama-platform.googlecode.com/svn      Finish (&amp; wait)                  Checkout of the GAMA code source                    In the SVN repository view, navigate to the directory “branches/GAMA_CURRENT” and select “Find/Checkout As…” from the contectual menu.      Choose “Find projects in the children of the selected resource” and follow the indications.      Pop-up “Check Out projects”, all projects should be selected. Select “Check out as a folders into workspace”. Click “Next” and then “Finish”.      Once the checkout is finished, switch to Java Perspective.                  Configure Build path of all projects :                    In the Properties of project, Java build path category, Libraries tab, click on JRE System Libray to change Excution environment from Java 1.6 to Java 1.7                  Configure the GAMA .product file (gama1.6.1.feature_based_release.jogl2.product) :                    In the msi.gama.application project, open the gama1.6.1.feature_based_release.jogl2.product file      In the “Dependencies” tab:                  Choose all org.eclipse.equinox.* plugins and remove them.                    Click Add button, type in org.eclipse.equinox and add all displayed packages.      Click Add button, type in org.eclipse.e4, then select all and click OK.      Click Add Required button, this will add two more: org.eclipse.emf.ecore and org.eclipse.emf.common                  Configure ummisco.gama.feature.dependencies project:                    In the ummisco.gama.feature.dependencies project, open the feature.xml file      In: the “Plugin” tab:                  Click Add and type in org.w3c.dom, choose org.w3c.dom.events and org.w3c.dom.smil, click OK.                          Compile and Run GAMA                                          Do a “Project -&gt; Clean… (clean all projects)”      In gama1.6.1.feature_based_release.jogl2.product file, in “Overview” tab.                  click on the � Synchronize � link. This will ensure your product has updated the inclusion of the plugins (from both Eclipse 3.7 and the new XText). Do not forget to save it.          click on the � Launch an Eclipse application � link. Note that a run configuration will be automatically created allowing to only click on the run button for future runs.Have fun!                    Install additional plug-insInstall the Graphical Modeling FrameworkThis installation procedure has been tested on a macbook pro with macosx 10.6 64 bits.Important note: for the moment, the plug-in works only with Eclipse Indigo and graphiti 0.8. Some modifications will be made later to make it works with the latest version of Eclipse and graphiti.DetailsThe graphical modeling framework is based on the Graphiti plug-in.  The first step consists in installing the graphiti plug-ins : � Help � -&gt; � Install new software �In “Work with”, choose “Indigo - http://download.eclipse.org/releases/indigo” and install: Graphiti, Graphiti Export, Graphiti SDK and Graphiti SDK Plus.  Eclipse proposes to restart -&gt; Restart now  � Help � -&gt; � Check of Updates �  Install the proposed updates  Eclipse proposes to restart -&gt; Restart now  From the GAMA SVN, checkout the idees.gama.graphicalmodeling, idees.gama.emf.metamodel and idees.gama.feature.graphical_modeling projects.    * In the SVN repository view, navigate to the directory “branches/GAMA_CURRENT” and select the three mentioned projects and select “Find/Checkout As…” from the contectual menu.    * Choose “Find projects in the children of the selected resource” and follow the indications.    * Pop-up “Check Out projects”, all projects should be selected. Finish.    * Once the checkout is finished, switch to Java Perspective.  You have to add the plugin to the GAMA .product file .    * In the msi.gama.application project, open the gama1.6.1.feature_based_release.product file    * In: the “Dependencies” tab: click on “Add …” and select the idees.gama.feature.graphical_modeling plugin    * In: the “Dependencies” tab: click on “Add Required plug-ins” then save the file  Compile and Run GAMA    * Do a “Project -&gt; Clean… (clean all projects)”    * In gama1.6.1.feature_based_release.product file, in “Overview” tab.          click on the � Synchronize � link. This will ensure your product has updated the inclusion of the plugins. Do not forget to save it.      click on the � Launch an Eclipse application � link. Note that, a run configuration will be automatically created allowing to only click on the run button for future runs.      NoteIf you have some errors on the META-INF/MANIFEST.MF file (in particular on the line  org.eclipse.draw2d;bundle-version=\"3.8.3\"), you can follow next steps.  Fix the MANIFEST.MF error (if any)    * In the plug-in idees.gama.graphicalmodeling, open the file : META-INF/MANIFEST.MF    * In the ‘Dependencies’ pane,          Select org.eclipse.draw2d (3.8.1) and click on the ‘Properties’ button      In ‘Available version to match’, select the one you have (mine is the v 3.7.2), and click on ‘Match’ and ‘OK’                  Save the file          Repeat Step 8 (clean, synchronize…)                    Install additional plug-ins to generate the documentation  A plug-in to use Python should be installed as additional plug-ins: � Help � -&gt; � Install new software �In “Work with”, choose “http://pydev.org/updates” and install: PyDev for Eclipse.  Configure the Python Interpreters:Eclipse -&gt; Preferences -&gt; PyDev -&gt; Interpreters -&gt; Python Interpreter: Quick auto-config.",
        "url":"/wiki/InstallingSvnOldVersions.html"
      }
      ,
    
      "wiki-interactionbetweenagents-html": {
        "title": "Interaction between agents",
        "content": "Interaction between agentsIn this part, we will learn how interaction between agents works. We will also present you a bunch of operators useful for your modelling.Index  The ask statement  Pseudo variables  Some useful interaction operators  ExampleThe ask statementThe ask statement can be used in any reflex or action scope. It is used to specify the interaction between the instances of your species and the other agents. You only have to specify the species of the agents you want to interact with. Here are the different ways of calling the ask statement:  If you want to interact with one particular agent (for example, defined as an attribute of your species):species my_species {\tagent target;\treflex update {\t\task target {\t\t\t// statements\t\t}\t}}  If you want to interact with a group of agents:species my_species {\tlist&lt;agent&gt; targets;\treflex update {\t\task targets {\t\t\t// statements\t\t}\t}}  If you want to interact with agents, as if they were instance of a certain species (can raise an error if it’s not the case!):species my_species {\tlist&lt;agent&gt; targets;\treflex update {\t\task targets as:my_species {\t\t\t// statements\t\t}\t}}  If you want to interact with all the agent of a species:species my_species {\tlist&lt;agent&gt; targets;\treflex update {\t\task other_species {\t\t\t// statements\t\t}\t}}species other_species {}Note that you can use the attribute population of species if you find it more explicit:ask other_species.population  If you want to interact with all the agent of a particular species from a list of agents (for example, using the global variable “agents”):species my_specie {\treflex update {\t\task species of_species my_specie {\t\t\t// statements\t\t}\t}}Pseudo variablesOnce you are in the ask scope, you can use some pseudo variables to refer to the receiver agent (the one specify just after the ask statement) or the transmitter agent (the agent which is asking). We use the pseudo variable self to refer to the receiver agent, and the pseudo variable myself to refer to the transmitter agent. The pseudo variable self can be omitted when calling actions or attributes.species speciesA {\tinit {\t\tname &lt;- \"speciesA\";\t}\treflex update {\t\task speciesB {write name; // output : \"speciesB\"\t\t\twrite self.name; // output : \"speciesB\"\t\t\twrite myself.name; // output : \"speciesA\"\t\t}\t}}species speciesB {\tinit {\t\tname &lt;- \"speciesB\";\t}}Now, if we introduce a third species, we can write an ask statement inside another.species speciesA {\tinit {\t\tname &lt;- \"speciesA\";\t}\treflex update {\t\task speciesB {\t\t\twrite self.name; // output : \"speciesB\"\t\t\twrite myself.name; // output : \"speciesA\"\t\t\task speciesC {\t\t\t\twrite self.name; // output : \"speciesC\"\t\t\t\twrite myself.name; // output : \"speciesB\"\t\t\t}\t\t}\t}}species speciesB {\tinit {\t\tname &lt;- \"speciesB\";\t}}species speciesC {\tinit {\t\tname &lt;- \"speciesC\";\t}}Nb: try to avoid multiple imbrications of ask statements. Most of the time, there is another way to do the same thing.Some useful interaction operatorsThe operator at_distance can be used to know the list of agents that are in a certain distance from another agent.species my_species {\treflex update {\t\tlist&lt;agent&gt; neighbours &lt;- agents at_distance(5);\t\t// neighbours contains the list of all the agents located at a distance &lt;= 5 from the caller agent.\t}}The operator closest_to returns the closest agent of a position among a container.species my_species {\treflex update {\t\tagent agentA &lt;- agents closest_to(self);\t\t// agentA contains the closest agent from the caller agent.\t\tagent agentB &lt;- other_specie closest_to({2,3});\t\t// agentB contains the closest instance of other_specie from the location {2,3}.\t}}species other_specie {}ExampleTo practice those notions, here is a short basic example. Let’s build a model with a fix number of agents with a circle shape. They can move randomly on the environment, and when they are close enough from another agent, a line is displayed between them. This line is destroyed when the distance between the two agents is too important.Hint: use the operator polyline to construct a line. List the points between angle brackets [].Here is one example of implementation:model connect_the_neighboursglobal{\tfloat speed &lt;- 0.2;\tfloat distance_to_intercept &lt;- 10.0;\tint number_of_circle &lt;- 100;\tinit {\t\tcreate my_species number:number_of_circle;\t}}species my_species {\treflex move {\t\tlocation &lt;- {location.x+rnd(-speed,speed),location.y+rnd(-speed,speed)};\t}\taspect default {\t\tdraw circle(1);\t\task my_species at_distance(distance_to_intercept) {\t\t\tdraw polyline([self.location,myself.location]) color:#black;\t\t}\t}}experiment my_experiment type:gui{\toutput{\t\tdisplay myDisplay {\t\t\tspecies my_species aspect:default;\t\t}\t}}",
        "url":"/wiki/InteractionBetweenAgents.html"
      }
      ,
    
      "wiki-introduction-html": {
        "title": "Introduction",
        "content": "IntroductionGAML is an agent-oriented language dedicated to the definition of agent-based simulations. It takes its roots in object-oriented languages like Java or Smalltalk, but extends the object-oriented programming approach with powerful concepts (like skills, declarative definitions or agent migration) to allow for a better expressivity in models.It is of course very close to agent_based modeling languages like, e.g., NetLogo, but, in addition to enriching the traditional representation of agents with modern computing notions like inheritance, type safety or multi-level agency, and providing the possibility to use different behavioral architectures for programming agents, GAML extends the agent-based paradigm to eliminate the boundaries between the domain of a model (which, in ABM, is represented with agents) and the experimental processes surrounding its simulations (which are usually not represented with agents), including, for example, visualization processes. This paper (Drogoul A., Vanbergue D., Meurisse T., Multi-Agent Based Simulation: Where are the Agents ?, Multi-Agent Based Simulation 3, pp. 1-15, LNCS, Springer-Verlag. 2003) was in particular foundational in the definition of the concepts on which GAMA (and GAML) are based today.This orientation has several conceptual consequences among which at least two are of immediate practical interest for modelers:  Since simulations, or experiments, are represented by agents, GAMA is bound to support high-level model compositionality, i.e. the definition of models that can use other models as inner agents, leveraging multi-modeling or multi-paradigm modeling as particular cases of composition.  The visualization of models can be expressed by models of visualization, composed of agents entirely dedicated to visually represent other agents, allowing for a clear separation of concerns between a simulation and its representation and, hence, the possibility to play with multiple representations of the same model at once.Table of contents  Key Concepts (Under construction)          Lexical semantics of GAML      Translation into a concrete syntax      Vocabulary correspondance with the object-oriented paradigm as in Java      Vocabulary correspondance with the agent-based paradigm as in NetLogo      Lexical semantics of GAMLThe vocabulary of GAML is described in the following sentences, in which the meaning and relationships of the important words of the language (in bold face) are summarized.  The role of GAML is to support modelers in writing models, which are specifications of simulations that can be executed and controlled during experiments, themselves specified by experiment plans.  The agent-oriented modeling paradigm means that everything “active” (entities of a model, systems, processes, activities, like simulations and experiments) can be represented in GAML as an agent (which can be thought of as a computational component owning its own data and executing its own behavior, alone or in interaction with other agents).  Like in the object-oriented paradigm, where the notion of class is used to supply a specification for objects, agents in GAML are specified by their species, which provide them with a set of attributes (what they know), actions (what they can do), behaviors (what they actually do) and also specifies properties of their population, for instance its topology (how they are connected) or schedule (in which order and when they should execute).  Any species can be nested in another species (called its macro-species), in which case the populations of its instances will imperatively be hosted by an instance of this macro-species. A species can also inherit its properties from another species (called its parent species), creating a relationship similar to specialization in object-oriented design. In addition to this, species can be constructed in a compositional way with the notion of skills, bundles of attributes and actions that can be shared between different species and inherited by their children.  Given that all agents are specified by a species, simulations and experiments are then instances of two species which are, respectively, called model and experiment plan. Think of them as “specialized” categories of species.  The relationships between species, models and experiment plans are codified in the meta-model of GAML in the form of a framework composed of three abstract species respectively called agent (direct or indirect parent of all species), model (parent of all species that define a model) and experiment (parent of all species that define an experiment plan). In this meta-model, instances of the children of agent know the instance of the child of model in which they are hosted as their world, while the instance of experiment plan identifies the same agent as one of the simulations it is in charge of. The following diagram summarizes this framework:Putting this all together, writing a model in GAML then consists in defining a species which inherits from model, in which other species, inheriting (directly or not) from agent and representing the entities that populate this model, will be nested, and which is itself nested in one or several experiment plans among which a user will be able to choose which experiment he/she wants to execute.At the operational level, i.e. when running an experiment in GAMA,Translation into a concrete syntaxThe concepts presented above are expressed in GAML using a syntax which bears resemblances with mainstream programming languages like Java, while reusing some structures from Smalltalk (namely, the syntax of facets or the infix notation of operators). While this syntax is fully described in the subsequent sections of the documentation, we summarize here the meaning of its most prominent structures and their correspondance (when it exists) with the ones used in Java and NetLogo.  A model is composed of a header, in which it can refer to other models, and a sequence of species and experiments declarations, in the form of special declarative statements of the language.  A statement can be either a declaration or a command. It is always composed of a keyword followed by an optional expression, followed by a sequence of facets, each of them composed of a keyword (terminated by a ‘:’) and an expression.  facets allow to pass arguments to statements. Their value is an expression of a given type. An expression can be a literary constant, the name of an attribute, variable or pseudo-variable, the name of a unit or constant of the language, or the application of an operator.  A type can be a primitive type, a species type or a parametric type (i.e. a composition of types).  Some statements can include sub-statements in a block (sequence of statements enclosed in curly brackets).  declarative statements support the definition of special constructs of the language: for instance, species (including global and experiment species), attributes, actions, behaviors, aspects, variables, parameters and outputs of experiments.  imperative statements that execute something or control the flow of execution of actions, behaviors and aspects are called commands.  A species declaration (global, species or grid keywords) can only include 6 types of declarative statements : attributes, actions, behaviors, aspects, equations and (nested) species. In addition, experiment species allow to declare parameters, outputs and batch methods.Vocabulary correspondance with the object-oriented paradigm as in Java| GAML | Java ||:–|:–|| species | class || micro-species | nested class || parent species | superclass || child species | subclass || model | program || experiment | (main) class || agent | object || attribute | member || action | method || behavior | collection of methods || aspect | collection of methods, mixed with the behavior || skill | interface (on steroids) || statement | statement || type | type || parametric type | generics |Vocabulary correspondance with the agent-based paradigm as in NetLogo| GAML | NetLogo ||:–|:–|| species | breed   || micro-species | -       || parent species | -       || child species | - (only from ‘turtle’) || model | model   || experiment | observer || agent | turtle/observer || attribute | ‘breed’-own || action | global function applied only to one breed || behavior | collection of global functions applied to one breed || aspect | only one, mixed with the behavior || skill | -       || statement | primitive || type | type    || parametric type | -       |",
        "url":"/wiki/Introduction.html"
      }
      ,
    
      "wiki-knownissues-html": {
        "title": "Known issues",
        "content": "Known issuesCrash when using openGL on WindowsIf you are using GAMA with Windows, and your video card is a Radeon AMD, then GAMA can crash while running a simulation using OpenGL. To avoid this issue, you have to disable your video card. This will slow down a bit the performances, but at least you will be able to run GAMA without those annoying crashes.To disable your video card, open the control panel, click on Hardware and Sound / Devices and Printers / Device manager, and then right click on your video card (as shown in the following image)Grid not displayed right using openGLWhen you try to display a grid with opengl, the cells have not a regular shape (as it is shown in the following image)The reason of this problem is that we can only map a grid of 2^n*2^n cells in the plan. Here are some solutions for this problem :  Choose a grid with 2^n*2^n dimension (such as 16x16, or 32x32)  Display the grid in java2D  Display the grid as species, and not as grid (note that the difference in term of performance between displaying a grid as a grid and as a species is not so important for opengl displays. It has originally been done for java2D displays)",
        "url":"/wiki/KnownIssues.html"
      }
      ,
    
      "wiki-launching-html": {
        "title": "Launching GAMA",
        "content": "Launching GAMARunning GAMA for the first time requires that you launch the application (Gama.app on MacOS X, Gama.exe on Windows, Gama on Linux, located in the folder called Gama once you have unzipped the archive). Other folders and files are present here, but you don’t have to care about them for the moment. In case you are unable to launch the application, of if error messages appear, please refer to the installation or troubleshooting instructions.Table of contents  Launching GAMA          Launching the Application      Choosing a Workspace      Welcome Page      Launching the ApplicationNote that GAMA can also be launched in two different other ways:  In a so-called headless mode (i.e. without user interface, from the command line, in order to conduct experiments or to be run remotely). Please refer to the corresponding instructions.  From the terminal, using a path to a model file and the name or number of an experiment, in order to allow running this experiment directly (note that the two arguments are optional: if the second is omitted, the file is imported in the workspace if not already present and opened in an editor; if both are omitted, GAMA is launched as usual):  Gama.app/Contents/MacOS/Gama path_to_a_model_file#experiment_name_or_number on MacOS X  Gama path_to_a_model_file#experiment_name_or_number on Linux  Gama.exe path_to_a_model_file#experiment_name_or_number on WindowsChoosing a WorkspacePast the splash screen, GAMA will ask you to choose a workspace in which to store your models and their associated data and settings. The workspace can be any folder in your filesystem on which you have read/write privileges. If you want GAMA to remember your choice next time you run it (it can be handy if you run Gama from the command line), simply check the corresponding option. If this dialog does not show up when launching GAMA, it probably means that you inherit from an older workspace used with GAMA 1.6 or 1.5.1 (and still “remembered”). In that case, a warning will be produced to indicate that the models library is out of date, offering you the possibility to create a new workspace.You can enter its address or browse your filesystem using the appropriate button. If the folder already exists, it will be reused (after a warning if it is not already a workspace). If not, it will be created. It is always a good idea, when you launch a new version of GAMA for the first time, to create a new workspace. You will then, later, be able to import your existing models into it. Failing to do so might lead to odd errors in the various validation processes.Welcome PageAs soon as the workspace is created, GAMA will open and you will be presented with its first window. GAMA is based on Eclipse and reuses most of its visual metaphors for organizing the work of the modeler. The main window is then composed of several parts, which can be views or editors, and are organized in a perspective. GAMA proposes 2 main perspectives: Modeling, dedicated to the creation of models, and Simulation, dedicated to their execution and exploration. Other perspectives are available if you use shared models.The default perspective in which GAMA opens is Modeling. It is composed of a central area where GAML editors are displayed, which is surrounded by a Navigator view on the left-hand side of the window, an Outline view (linked with the open editor) and the Problems view, which indicates errors and warnings present in the models stored in the workspace.In the absence of previously open models, GAMA will display a Welcome page (actually a web page), from which you can find links to the website, current documentation, tutorials, etc. This page can be kept open (for instance if you want to display the documentation when editing models) but it can also be safely closed (and reopened later from the “Views” menu).From this point, you are now able to edit a new model, navigate in the models libraries, or import an existing model.",
        "url":"/wiki/Launching.html"
      }
      ,
    
      "wiki-launchingexperiments-html": {
        "title": "Launching Experiments from the User Interface",
        "content": "Launching Experiments from the User InterfaceGAMA supports multiple ways of launching experiments from within the Modeling Perspective, in editors or in the navigator.Table of contents  Launching Experiments from the User Interface          From an Editor      From the Navigator      Running Experiments Automatically      Running Several Simulations      From an EditorAs already mentioned on this page, GAML editors will provide the easiest way to launch experiments. Whenever a model that contains the definition of experiments is validated, these experiments will appear as distinct buttons, in the order in which they are defined in the file, in the header ribbon above the text. Simply clicking one of these buttons launches the corresponding experiment.For each of those launching buttons, you can see 2 different pictograms, showing the type of experiment. An experiment can either be a GUI Experiment or a Batch Experiment.From the NavigatorYou can also launch your experiments from the navigator, by expanding a model and double clicking on one of the experiments available (The number of experiments for each model is visible also in the navigator). As for the editor, the two types of experimentations (gui and batch) are differentiated by a pictogram.Running Experiments AutomaticallyOnce an experiment has been launched (unless it is run in headless mode, of course), it normally displays its views and waits from an input from the user, usually a click on the “Run” or “Step” buttons (see here).It is however possible to make experiments run directly once launched, without requiring any intervention from the user.  To install this feature, open the preferences of GAMA. On the first tab, simply check “Auto-run experiments when they are launched” (which is unchecked by default) and hit “OK” to dismiss the dialog. Next time you’ll launch an experiment, it will run automatically (this option also applies to experiments launched from the command line).Running Several SimulationsIt is possible in GAMA to run several simulations. Each simulation will be launched with the same seed (which means that if the parameters are the same, then the result will be exactly the same). All those simulations are synchronized in the same cycle.To run several experiments, you have to write it directly in your model.",
        "url":"/wiki/LaunchingExperiments.html"
      }
      ,
    
      "wiki-learngamlstepbystep-html": {
        "title": "Learn GAML Step by Step",
        "content": "Learn GAML Step by StepThis large progressive tutorial has been designed to help you to learn GAML (GAma Modeling Language).It will cover the main part of the possibilities provided by GAML, and guide you to learn some more.How to proceed to learn better ?As you will progress in the tutorial, you will see several links (written in blue) to makes you jump to another part. You can click on them if you want to learn directly about a specific topic, but we do not encourage to do this, because you can get easily lost by reading this tutorial this way. As it is named, we encourage you to follow this tutorial “step by step”. For each chapter, some links are available in the “search” tab, if you want to learn more about this subject.Although, if you really want to learn about a specific topic, our advise is to use the “learning graph” interface, in the website, so that you can choose your area of interest, and a learning path will be automatically design for you to assimilate the specific concept better.Good luck with your reading, and please do not hesitate to contact us through the mailing list if you have a question/suggestion !",
        "url":"/wiki/LearnGAMLStepByStep.html"
      }
      ,
    
      "wiki-learning-mas-kmeans-html": {
        "title": "Agent Based Clustering",
        "content": "Agent Based ClusteringAuthor : Jean-Danie Zucker with Patrick Taillandier’s and Arnaud Grignard’s HelpCode of the model :model MASKMEANSglobal{// the number of classes to create (kmeans)// It corresponds to the centroids\tint k &lt;- 4;\t// the number of points\tint N &lt;- 100;\t//number of dimensions\tint dimensions;\tinit\t{\t//create datapoints agents\t\tcreate datapoints number: N\t\t{\t\t\tif (dimensions = 3)\t\t\t{\t\t\t\tlocation &lt;- { rnd(100), rnd(100), rnd(100) };\t\t\t}\t\t\tif (dimensions = 2)\t\t\t{\t\t\t\tlocation &lt;- { rnd(100), rnd(100) };\t\t\t}\t\t}\t\t//create centroid agents\t\tcreate centroids number: k\t\t{\t\t\tif (dimensions = 3)\t\t\t{\t\t\t\tlocation &lt;- { rnd(100), rnd(100), rnd(100) };\t\t\t}\t\t\tif (dimensions = 2)\t\t\t{\t\t\t\tlocation &lt;- { rnd(100), rnd(100) };\t\t\t}\t\t}\t\t//give a random color to each centroid (i.e. to each datapoints agents of the group)\t\tloop c over: centroids\t\t{\t\t\trgb col &lt;- rnd_color(255);\t\t\task c\t\t\t{\t\t\t\tcolor_kmeans &lt;- col;\t\t\t}\t\t}\t}\treflex assign_points_to_centroid when: even(cycle)\t{\t// The \"assignment\" step is also referred to as expectation step,\t\task centroids\t\t{\t\t\tmypoints &lt;- list&lt;datapoints&gt; ([]);\t\t}\t\tloop pt over: datapoints\t\t{\t\t\task pt\t\t\t{\t\t\t\tmycenter &lt;- (centroids) closest_to self;\t\t\t\tcolor_kmeans &lt;- mycenter.color_kmeans;\t\t\t\tadd self to: mycenter.mypoints;\t\t\t}\t\t}\t}\treflex update_centroids when: not even(cycle)\t{\t// the \"update step\" as maximization step,\t// making this algorithm a variant of the generalized expectation-maximization algorithm.\t//We give a random color to each group (i.e. to each datapoints agents of the group)\t\tloop center over: centroids\t\t{\t\t//old code... center.location &lt;- geometry(center.mypoints).location;\t\t\tcenter.location &lt;- mean(center.mypoints collect each.location);\t\t}\t}}species datapoints{\trgb color_kmeans &lt;- # grey;\tcentroids mycenter;\taspect kmeans_aspect2D\t{\t\tdraw circle(2) color: color_kmeans;\t}\taspect kmeans_aspect3D\t{\t\tdraw sphere(2) color: color_kmeans;\t}}species centroids{\trgb color_kmeans &lt;- # grey;\tlist&lt;datapoints&gt; mypoints;\taspect kmeans_aspect2D\t{\t\tdraw cross(3, 0.5) color: color_kmeans border: # black;\t\tloop pt over: mypoints\t\t{\t\t\tdraw line([location, pt]) + 0.1 color: color_kmeans;\t\t}\t}\taspect kmeans_aspect3D\t{\t\tdraw cube(5) color: color_kmeans border: # black;\t\tloop pt over: mypoints\t\t{\t\t\tdraw line([location, pt], 0.2) color: color_kmeans;\t\t}\t}}experiment clustering2D type: gui{\tparameter \"Number of clusters to split the data into\" var: k category: \"KMEANS\";\tparameter \"Number of points to be clustered\" var: N init: 100;\tparameter \"Number of dimensions\" var: dimensions init: 2 min: 2 max: 2;\tfont regular &lt;- font(\"Helvetica\", 14, # bold);\t\t\tpoint target &lt;- { 20, 95 };\toutput\t{\t\tdisplay map_kmeans\t\t{\t\t\tspecies datapoints aspect: kmeans_aspect2D;\t\t\tspecies centroids aspect: kmeans_aspect2D;\t\t\tgraphics \"Full target\"\t\t\t{\t\t\t\tdraw rectangle(100, 4) color: # yellow at: target + { 30, 0 };\t\t\t\tif (not even(cycle))\t\t\t\t{\t\t\t\t// the \"update step\" as maximization step, (a mean is done to recenter)\t\t\t\t\tdraw \"Next step is maximisation step the centroid will move to the means of its points\" at: target + { 0, 0 } font: regular color: # red;\t\t\t\t} else\t\t\t\t{\t\t\t\t\tdraw \"Next step is estimation Step (each point is assigned the color of his nearest centroid\" at: target + { 0, 0 } font: regular color: # green;\t\t\t\t}\t\t\t}\t\t}\t}}experiment clustering3D type: gui{\tparameter \"Number of clusters to split the data into\" var: k category: \"KMEANS\";\tparameter \"Number of points to be clustered\" var: N init: 100;\tfont regular &lt;- font(\"Helvetica\", 14, # bold);\tpoint target &lt;- { 20, 95 };\tparameter \"Number of dimensions\" var: dimensions init: 3 min: 3 max: 3;\taction _init_ {\t\tcreate MASKMEANS_model with: [dimensions::3];\t}\toutput\t{\t\tdisplay map_kmeans type: opengl\t\t{\t\t\tspecies datapoints aspect: kmeans_aspect3D;\t\t\tspecies centroids aspect: kmeans_aspect3D;\t\t}\t}}",
        "url":"/wiki/Learning-MAS_KMEANS.html"
      }
      ,
    
      "wiki-learning-html": {
        "title": "Learning",
        "content": "LearningThis sub-section is composed of the following models :  Agent Based Clustering",
        "url":"/wiki/Learning.html"
      }
      ,
    
      "wiki-life-life-html": {
        "title": "Life",
        "content": "Life_Author : _A model using a cellular automata to represent the Game of Life, the most famous example of cellular automata. Each cell will see if the number of living neighbours meets the condition to emerge or to live.Code of the model :model life//Declare the world as a torus or not torus environmentglobal torus: torus_environment {\t//Size of the environment\tint environment_width &lt;- 200 min: 10 max: 1000;\tint environment_height &lt;- 200 min: 10 max: 1000;\t\t//Declare as torus or not\tbool torus_environment &lt;- true;\t//Density \tint density &lt;- 25 min: 1 max: 99;\t//Conditions to live\tlist&lt;int&gt; living_conditions &lt;- [2, 3];\t//Conditions to birth\tlist&lt;int&gt; birth_conditions &lt;- [3];\t//Color for living cells\trgb livingcolor &lt;- °white;\t//Color for dying cells\trgb dyingcolor &lt;- °red;\t//Color for emerging cells\trgb emergingcolor &lt;- °orange;\t//Color for dead cells\trgb deadcolor &lt;- °black;\t//Shape of the environment\tgeometry shape &lt;- rectangle(environment_width, environment_height);\t\t//Initialization of the model by writing the description of the model in the console\tinit {\t\tdo description;\t}\t\t//Ask at each life_cell to evolve and update\treflex generation {\t\task life_cell {\t\t\tdo evolve;\t\t}\t\task life_cell {\t\t\tdo update;\t\t}\t}\t//Write the description of the model in the console\taction description {\t\twrite\t\t'Description. The Game of Life is a cellular automaton devised by the British mathematician John Horton Conway in 1970. It is the best-known example of a cellular automaton. The game is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input from humans. One interacts with the Game of Life by creating an initial configuration and observing how it evolves.  The universe of the Game of Life is an infinite two-dimensional orthogonal grid of square cells, each of which is in one of two possible states, live or dead. Every cell interacts with its eight neighbors, which are the cells that are directly horizontally, vertically, or diagonally adjacent. At each step in time, the following transitions occur: \\\\n\\\\t 1.Any live cell with fewer than two live neighbours dies, as if caused by underpopulation. \\\\n\\\\t 2.Any live cell with more than three live neighbours dies, as if by overcrowding. \\\\n\\\\t 3.Any live cell with two or three live neighbours lives on to the next generation. \\\\n\\\\t 4.Any dead cell with exactly three live neighbours becomes a live cell. The initial pattern constitutes the seed of the system. The first(generation) is created by applying the above rules simultaneously to every cell in the seed�births and deaths happen simultaneously, and the discrete moment at which this happens is sometimes called a tick (in other words, each generation is a pure function of the one before). The rules continue to be applied repeatedly to create further generations.';\t}}//Grid species representing a cellular automatagrid life_cell width: environment_width height: environment_height neighbors: 8  use_individual_shapes: false use_regular_agents: false frequency: 0use_neighbors_cache: false {\t//Boolean to know if it is the new state of the cell\tbool new_state;\t//List of all the neighbours\tlist&lt;life_cell&gt; neighbours &lt;- self neighbors_at 1;\t//Boolean  to know if it is a living or dead cell\tbool alive &lt;- (rnd(100)) &lt; density;\t\trgb color &lt;- alive ? livingcolor : deadcolor;\t\t//Action to evolve the cell considering its neighbours\taction evolve {\t\t//Count the number of living neighbours of the cells\t\tint living &lt;- neighbours count each.alive;\t\tif alive {\t\t\t//If the number of living respect the conditions, the cell is still alive\t\t\tnew_state &lt;- living in living_conditions;\t\t\tcolor &lt;- new_state ? livingcolor : dyingcolor;\t\t} else {\t\t\t//If the number of living meets the conditions, the cell go to born\t\t\tnew_state &lt;- living in birth_conditions;\t\t\tcolor &lt;- new_state ? emergingcolor : deadcolor;\t\t}\t}\t//Action to update the new state of the cell\taction update {\t\talive &lt;- new_state;\t}}experiment \"Game of Life\" type: gui {\tparameter 'Width:' var: environment_width category: 'Board';\tparameter 'Height:' var: environment_height category: 'Board';\tparameter 'Torus?:' var: torus_environment category: 'Board';\tparameter 'Initial density of live cells:' var: density category: 'Cells';\tparameter 'Numbers of live neighbours required to stay alive:' var: living_conditions category: 'Cells';\tparameter 'Numbers of live neighbours required to become alive:' var: birth_conditions category: 'Cells';\tparameter 'Color of live cells:' var: livingcolor category: 'Colors';\tparameter 'Color of dying cells:' var: dyingcolor category: 'Colors';\tparameter 'Color of emerging cells:' var: emergingcolor category: 'Colors';\tparameter 'Color of dead cells:' var: deadcolor category: 'Colors';\toutput {\t\tdisplay Life type: opengl{\t\t\tgrid life_cell;\t\t}\t}}",
        "url":"/wiki/Life-Life.html"
      }
      ,
    
      "wiki-life-html": {
        "title": "Life",
        "content": "LifeThis sub-section is composed of the following models :  Life",
        "url":"/wiki/Life.html"
      }
      ,
    
      "wiki-literals-html": {
        "title": "Literals",
        "content": "Literals(some literal expressions are also described in data types)A literal is a way to specify an unnamed constant value corresponding to a given data type. GAML supports various types of literals for often — or less often — used data types.Table of contents  Literals          Simple Types      Literal Constructors      Universal Literal      Simple TypesValues of simple (i.e. not composed) types can all be expressed using literal expressions. Namely:  bool: true and false.  int: decimal value, such as 100, or hexadecimal value if preceded by '#' (e.g. #AAAAAA, which returns the int 11184810)  float: the value in plain digits, using '.' for the decimal point (e.g. 123.297)  string: a sequence of characters enclosed between quotes ('my string') or double quotes (\"my string\")Literal ConstructorsAlthough they are not strictly literals in the sense given above, some special constructs (called literal constructors) allow the modeler to declare constants of other data types. They are actually operators but can be thought of literals when used with constant operands.  pair: the key and the value separated by :: (e.g. 12::'abc')  list: the elements, separated by commas, enclosed inside square brackets (e.g. [12,15,15])  map: a list of pairs (e.g. [12::'abc', 13::'def'])  point: 2 or 3 int or float ordinates enclosed inside curly brackets (e.g. {10.0,10.0,10.0})Universal LiteralFinally, a special literal, of type unknown, is shared between the data types and all the agent types (aka species). Only bool, int and float, which do not derive from unknown, do not accept this literal. All the others will accept it (e.g. string s &lt;- nil; is ok).  unknown: nil, which represents the non-initialized (or, literally, unknown) value.",
        "url":"/wiki/Literals.html"
      }
      ,
    
      "wiki-luneraysflu-html": {
        "title": "Luneray's flu",
        "content": "Luneray’s fluThis tutorial has for goal to introduce how to build a model with GAMA and to use GIS data and graphs. In particular, this tutorial shows how to write a simple GAMA model (the structure of a model, the notion of species…) load gis data, to agentify them and to use a network of polylines to constraint the movement of agents. The pdf of the presentation corresponding to this tutorial is available here. All the files related to this tutorial (shapefiles and models) are available here.The importation of models is described [here] (https://github.com/gama-platform/gama/wiki/G__ImportingModels)Model OverviewThe model built in this tutorial concerns the spreading of a flu in the city of Luneray (Normandie, France).Two layers of GIS data are used: a road layer (polylines) and a building layer (polygons). In this model, people agents are moving from building to building using the road network. Each infected people can infect the neighbor people.Some data collected concerning Luneray and the disease:  Number of inhabitants: 2147 (source : wikipedia)  Mean speed of the inhabitants (while moving on the road) : 2-5 km/h  The disease - non lethal - is spreading (by air) from people to people  Time to cure the disease: more than 100 days  Infection distance: 10 meters  Infection probability (when two people are at infection distance) : 0.05/minuteFrom the data collected, we made some modeling choice:  Simulation step: 1 minute  People are moving on the roads from building to building  Most of time people are moving to meet their friend then go back home  People use the shortest path to move between buildings  All people move at constant speed  Each time, people arrived at a building they are staying a certain time : they are staying longer in their home than in their friend houses  Infected people are never curedStep ListThis tutorial is composed of 5 steps corresponding to 5 models. For each step we present its purpose, an explicit formulation and the corresponding GAML code.  Creation of a first basic disease spreading model  Definition of monitors and chart outputs  Importation of GIS data  Use of a graph to constraint the movements of people  Definition of 3D displays",
        "url":"/wiki/LuneraysFlu.html"
      }
      ,
    
      "wiki-luneraysflu-step1-html": {
        "title": "1. Creation of a first basic disease spreading model",
        "content": "1. Creation of a first basic disease spreading modelThis first step illustrates how to create simple agents and make them move in their environment.Formulation  Set the time duration of a time step to 1 minutes  Define the people species with a moving skill  Define the move reflex that allow the people agent to move randomly and the infect reflex that allows them to infect other people agents.  Define the aspect of the people species  Add the people species to a displayModel DefinitionProject and modelThe first step of this tutorial consists in launching GAMA and choosing a workspace, then to define a new project or to import the existing one. For people that do not want to re-write all the models but just to follow the model construction, they can just download the model project here and the follow this procedure to import it into GAMA. For the other, the project and model creation procedures are detailed here.Note that the concepts of workspace and projects are explained here.model structureA GAMA model is composed of three type of sections:  global : this section, that is unique, defines the “world” agent, a special agent of a GAMA model. It represents all that is global to the model: dynamics, variables, actions. In addition, it allows to initialize the simulation (init block).  species and grid: these sections define the species of agents composing the model. Grid are defined in the following model step “vegetation dynamic”;  experiment : these sections define a context of execution of the simulations. In particular, it defines the input (parameters) and output (displays, files…) of a model.More details about the different sections of a GAMA model can be found here.speciesA species represents a «prototype» of agents: it defines their common properties.Three different elements can be defined in a species:  the internal state of its agents (attributes)  their behavior  how they are displayed (aspects)In our model, we define a people species:species people {\t\t }In addition, we want add a new capability to our agent: the possibility to move randomly. for that, we add a specific skill to our people agents. A skill is a built-in module that provide the modeler a self-contain and relevant set of actions and variables. The moving provides the agents with several attributes and actions related to movement.   species people skills: [moving]{       ...   }Internal stateAn attribute is defined as follows: type of the attribute  and name. Numerous types of attributes are available: int (integer), float (floating point number), string, bool (boolean, true or false), point (coordinates), list, pair, map, file, matrix, espèce d’agents, rgb (color), graph, path…  Optional facets: &lt;- (initial value), update (value recomputed at each step of the simulation), function:{..} (value computed each time the variable is used), min, maxIn addition to the attributes the modeler explicitly defines, species “inherits” other attributes called “built-in” variables:  A name (name): the identifier of the species  A shape (shape): the default shape of the agents to be construct after the species. It can be a point, a polygon, etc.  A location (location) : the centroid of its shape.In our model, we define 2 new attribute to our people agents:  speed of type float, with for initial value: a random value between 2 and 5 km/h  is_infected of type bool, with for initial value: falsespecies people skills:[moving]{\t\t\tfloat speed &lt;- (2 + rnd(3)) #km/#h;\tbool is_infected &lt;- false;}Note we use the rnd operator to define a random value between 2 and 5 for the speed. In addition, we precise a unit for the speed value by using the # symbol. For more details about units, see here.BehaviorGAMA proposes several ways to define the behavior of a species: dynamic variables (update facet), reflexes….A reflex is a block of statements (that can be defined in global or any species) that will be automatically executed at each simulation step if its condition is true, it is defined as follows:   reflex reflex_name when: condition {...}The when facet is optional: when it is omitted, the reflex is activated at each time step. Note that if several reflexes are defined for a species, the reflexes will be activated following their definition order.We define a first reflex called move that is activated at each simulation step (no condition) and that makes the people move randomly using the wander action from the moving skill.species people skills:[moving]{\t\t\t//variable definition\treflex move{\t\tdo wander;\t}}We define a second reflex called infect that is activated only when the agent is infected (is_infected = true) and that ask all the people at a distance of 10m to test a probability to be infected.species people skills:[moving]{\t\t\t//variable definition and move reflex\t\treflex infect when: is_infected{\t\task people at_distance 10 #m {\t\t\tif flip(0.05) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}}The ask allows an agent to ask another agents to do something (i.e. to execute a sequence of statements). The at_distance operator allows to get the list of agents (here of people agents) that are located at a distance lower or equal to the given distance (here 10m). The flip operator allows to test a probability.DisplayAn agent aspects have to be defined. An aspect is a way to display the agents of a species : aspect aspect_name {…}In the block of an aspect, it is possible to draw :  A geometry :  for instance, the shape of the agent (but it may be a different one, for instance a disk instead of a complex polygon)  An image : to draw icons  A text : to draw a textIn our model, we define an aspect for the people agent called circle that draw the agents as a circle of 10m radius with a color that depends on their is_infected attribute. If the people agent is infected, it will be draw in red, in green otherwise.species people {\t...//variable and reflex definition\taspect circle {\t\t\tdraw circle(10) color:is_infected ? #red : #green;\t\t}\t} }The ? structure allows to return a different value (here red or green) according to a condition (here is_infected = true).global sectionThe global section represents a specific agent, called world. Defining this agent follows the same principle as any agent and is, thus, defined after a species.The world agent represents everything that is global to the model : dynamics, variables…It allows to initialize simulations (init block): the world is always created and initialized first when a simulation is launched (before any other agents). The geometry (shape) of the world agent is by default a square with 100m for side size, but can be redefined if necessary. The step attribute of the world agent allows to specify the duration of one simulation step (by default, 1 step = 1 seconde).global variableIn the current model, we define 4 global attributes:  nb_people: the number of people that we want to create (init value: 2147)  nb_infected_init: the number of people infected at the initialization of the simulation (init value: 5)  step: redefine in order to set the duration of a simulation step to 1 minute.  shape: redefine in order to set the geometry of the world to a square of 1500 meters side size.    global {    int nb_people &lt;- 2147;    int nb_infected_init &lt;- 5;    float step &lt;- 1 #mn;    geometry shape&lt;-square(1500 #m);}      Model initializationThe init section of the global block allows to initialize the define what will happen at the initialization of a simulation, for instance to create agents. We use the statement create  to create agents of a specific species: create species_name + :  number : number of agents to create (int, 1 by default)  from : GIS file to use to create the agents (optional, string or file)  returns: list of created agents (list)For our model, we define the init block in order to create nb_people people agents and ask nb_infected_init of them to be infected:global {\t// world variable definition\tinit{\t\tcreate people number:nb_people;\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t}}experimentAn experiment block defines how a model can be simulated (executed). Several experiments can be defined for a given model. They are defined using : experiment exp_name type: gui/batch {[input] [output]}  gui : experiment with a graphical interface, which displays its input parameters and outputs.  batch : Allows to setup a series of simulations (w/o graphical interface).In our model, we define a gui experiment called main_experiment  :experiment main_experiment type: gui {}inputExperiments can define (input) parameters. A parameter definition allows to make the value of a global variable definable by the user through the graphic interface.A parameter is defined as follows:parameter title var: global_var category: cat;  title : string to display  var : reference to a global variable (defined in the global section)  category : string used to «store» the operators on the UI - optional  &lt;- : init value - optional  min : min value - optional  max : min value - optionalNote that the init, min and max values can be defined in the global variable definition.In our model, we define one parameter:  “Nb people infected at init” that will define the value of the global variable nb_infected_init with a min value of 1 and a max value of 2147 (the number of people living in Luneray).experiment main_experiment type:gui{\tparameter \"Nb people infected at init\" var: nb_infected_init min: 1 max: 2147;\t\toutput {\t}}outputOutput blocks are defined in an experiment and define how to visualize a simulation (with one or more display blocks that define separate windows). Each display can be refreshed independently by defining the facet refresh_every: nb (int) (the display will be refreshed every nb steps of the simulation).Each display can include different layers (like in a GIS) :  Agents lists : agents layer_name value: agents_list aspect: my_aspect;  Agents species : species  my_species aspect: my_aspect  Images: image layer_name file: image_file;  Texts : texte layer_name value: my_text;  Charts : see later.Note that it is possible to define a opengl display (for 3D display or just to optimize the display) by using the facet type: opengl.In our model, we define an OpenGL display to draw the people agents.output {\tdisplay map type: opengl{\t\tspecies people aspect:circle;\t\t}}Complete Modelmodel SI_city1global{ \tint nb_people &lt;- 2147;\tint nb_infected_init &lt;- 5;\tfloat step &lt;- 1 #mn;\tgeometry shape&lt;-square(1500 #m);\t\tinit{\t\tcreate people number:nb_people;\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t}\t}species people skills:[moving]{\t\t\tfloat speed &lt;- (2 + rnd(3)) #km/#h;\tbool is_infected &lt;- false;\treflex move{\t\tdo wander;\t}\treflex infect when: is_infected{\t\task people at_distance 10 #m {\t\t\tif flip(0.05) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(10) color:is_infected ? #red : #green;\t}}experiment main_experiment type:gui{\tparameter \"Nb people infected at init\" var: nb_infected_init min: 1 max: 2147;\toutput {\t\tdisplay map type: opengl{\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t}}Next step: Definition of monitors and chart outputs",
        "url":"/wiki/LuneraysFlu_step1.html"
      }
      ,
    
      "wiki-luneraysflu-step2-html": {
        "title": "2. Definition of monitors and chart outputs",
        "content": "2. Definition of monitors and chart outputsThis second step illustrates how to create monitors and charts to follows the evolution of variables and to add an ending condition to the simulation.Formulation  Add three new global dynamic variables to follow the evolution of the number of infected people agents, of not infected people agents and of the rate of infected people.  Define an ending condition for the simulation  Define a monitor to follow the rate of infected people agents  Define a chart to follow the rate of infected people agentsModel Definitionglobal sectionglobal variablesGAMA offers the possibility to define dynamic variable that will be recomputed at each simulation step by using the update facet when defining a variable. When an agent is activated, first, it recomputes each of its variables with a update facet (in their definition order), then it activates each of its reflexes (in their definition order).To better follow the evolution of sick people, we add three new global variables to the model:  nb_people_infected of type int with nb_infected_init as init value and updated at each simulation step by the number of infected people  nb_people_not_infected of type int with (nb_people - nb_infected_init) as init value and updated at each simulation step by the number of not infected people  infected_rate of type float updated at each simulation step by the number of infected people divided by the number of people.global{\t//... other attributes\tint nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected);\tint nb_people_not_infected &lt;- nb_people - nb_infected_init update: nb_people - nb_people_infected;\tfloat infected_rate update: nb_people_infected/nb_people;\t//... init}We used the count operator that allows to count the number of elements of a list for which the left condition is true. The keyword each represents each element of the list.ending conditionThe simplest way to add an ending condition to a model is to add a global reflex that is activated at the end of the simulation that will pause the simulation (use of the pause global action).In our model, we add a new reflex called end_simulation that will be activated when the infected rate is 1.0 (i.e. all the people agents are infected) and that will apply the pause action.global {\t//.. variable and init definition\t\treflex end_simulation when: infected_rate = 1.0 {\t\tdo pause;\t}} experimentmonitorGAMA provides modelers with the possibility to define monitors. A monitor allows to follow the value of an arbitrary expression in GAML. It will appear, in the User Interface, in a small window on its own and be recomputed every time step (or according to its ‘refresh’ facet).Definition of a monitor:  value: mandatory, the expression whose value will be displayed by the monitor.  refresh: bool, optional : if the expression is true, compute (default is true).For our model, we define a monitor to follow the value of the infected_rate variable:experiment main_experiment type:gui{\t//...parameters\toutput {\t\tmonitor \"Infected people rate\" value: infected_rate;\t\t               //...display\t}}ChartIn GAMA, charts are considered as a display layer. GAMA can display 3 main types of charts using the type facet:  histogram  pie  series/xy/scatter: both display series with lines or dots, with 3 subtypes :          series: to display the evolution of one/several variable (vs time or not).      xy: to specify both x and y value. To allow stacked plots, only one y value for each x value.      scatter: free x and y values for each serie.      In our model, we define a new display called _ chart_display_ that will be refresh every 10 simulation steps. In this display, we add a series charts with 2 layers of data:  susceptible: the number of people that are not infected (in green)  infected: the number of people that are infected (in red)    experiment main_experiment type:gui{    //...parameters    output {   //...display and monitors\t\t   display chart_display refresh:every(10) {       chart \"Disease spreading\" type: series {           data \"susceptible\" value: nb_people_not_infected color: #green;           data \"infected\" value: nb_people_infected color: #red;       }   }    }}        Complete Model  model SI_city2global{ \tint nb_people &lt;- 2147;\tint nb_infected_init &lt;- 5;\tfloat step &lt;- 1 #mn;\tgeometry shape&lt;-square(1500 #m);\tint nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected);\tint nb_people_not_infected &lt;- nb_people - nb_infected_init update: nb_people - nb_people_infected;\tfloat infected_rate update: nb_people_infected/nb_people;\t\t\tinit{\t\tcreate people number:nb_people;\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t}\t\treflex end_simulation when: infected_rate = 1.0 {\t\tdo pause;\t}}species people skills:[moving]{\t\t\tfloat speed &lt;- (2 + rnd(3)) #km/#h;\tbool is_infected &lt;- false;\treflex move{\t\tdo wander;\t}\treflex infect when: is_infected{\t\task people at_distance 10 #m {\t\t\tif flip(0.05) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(10) color:is_infected ? #red : #green;\t}}experiment main_experiment type:gui{\tparameter \"Nb people infected at init\" var: nb_infected_init min: 1 max: 2147;\toutput {\t\tmonitor \"Infected people rate\" value: infected_rate;\t\t\t\tdisplay map type: opengl{\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t\t\t\tdisplay chart refresh:every(10) {\t\t\tchart \"Disease spreading\" type: series {\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\t\t\t}\t\t}\t}}Next step: Importation of GIS data",
        "url":"/wiki/LuneraysFlu_step2.html"
      }
      ,
    
      "wiki-luneraysflu-step3-html": {
        "title": "3. Importation of GIS data",
        "content": "3. Importation of GIS dataThis third step illustrates how load GIS data and to agentify them.Formulation  Define 2 new species that will just be displayed: road and building.  Add a new my_building attribute to the people agents.  Define new global attributes to load GIS data (shape file).  Use the GIS data to create the road and building agents.  Add the road and building agents to the display.Model DefinitionFor this step, you will need to add the shapefiles of the roads and buildings inside the includes folder of the project. The shapefiles (and all the other files) can be found here.speciesIn this model, we have to define two species of agents: the road agents and the building ones. These agents will not have a particular behavior, they will just be displayed.For each of this species we define an aspect called geom. As we want to represent the geometry of the agent, we then use the keyword draw that allow to draw a given geometry. In order to draw the geometry of the agent we use the attribute shape (which is a built-in attribute of all agents). The road will be displayed in black and the building in gray.species road {\taspect geom {\t\tdraw shape color: #black;\t}}species building {\taspect geom {\t\tdraw shape color: #gray;\t}}In addition, we add an attribute to the people species called my_builing of type building. Note that agent species can be use as variable type.species people skills:[moving]{\t\t\t//other attributes\tbuilding my_house;         //reflexes and aspect }global sectionglobal variablesGAMA allows to automatically read GIS data that are formatted as shape files (or as OSM file). In our model, we define 2 shapefiles: one corresponding to the roads and the other ones to the buildings. Note that GAMA is able to manage the projection of the GIS data. In order to set the right size (and position) of the world geometry, we define its value as the envelope of the road shapefile (and no more a square of 1500 meters).global{\t//... other attributes\tfile roads_shapefile &lt;- file(\"../includes/routes.shp\");\tfile buildings_shapefile &lt;- file(\"../includes/batiments.shp\");\tgeometry shape &lt;- envelope(roads_shapefile);\t\t//... init}agentification of GIS dataIn GAMA, the agentification of GIS data is very straightforward: it only requires to use the create command with the from facet to pass the shapefile. Each object of the shapefile will be directly used to instantiate an agent of the specified species. The reading of an attribute in a shapefile is also very simple. It only requires to use the with facet: the argument of this facet is a dictionary of which the keys are the names of the agent attributes and the value the read command followed by the name of the shapefile attribute.In our model, we modify the init section in order to first create the road agents from the road shapefile, and the building agents from the building shapefile. Then, when creating people agents, we choose for them one random building and a random location inside this building.Note that it is possible to execute a sequence of statements at the creation of agents by using a block ({…}) rather than a simple line (;) when using the create statement.global {\t// world variable definition\tinit{\t\tcreate road from: roads_shapefile;\t\tcreate building from: buildings_shapefile;\t\tcreate people number:nb_people {\t\t\tmy_house &lt;- one_of(building);\t\t\tlocation &lt;- any_location_in(my_house);\t\t}\t\t\t\t}\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t}}We used here the one_of operator that returns a random element from a list and the any_location_in operator that returns a random location inside a geometry.experimentOutputIn the map display, we add the road and building species with their geom aspect just before the people species (in order to draw the people agents on the top of the roads and buildings).experiment main_experiment type: gui {\t... //parameter definition\toutput {\t... //monitor definition\t\tdisplay map type: opengl{\t\t\tspecies road aspect:geom;\t\t\tspecies building aspect:geom;\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t\t... //chart display definition\t}}Complete Modelmodel SI_city3 global{ \tint nb_people &lt;- 2147;\tint nb_infected_init &lt;- 5;\tfloat step &lt;- 1 #mn;\tfile roads_shapefile &lt;- file(\"../includes/roads.shp\");\tfile buildings_shapefile &lt;- file(\"../includes/buildings.shp\");\tgeometry shape &lt;- envelope(roads_shapefile);\tint current_hour update: (time /#h) mod 24;\tint nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected);\tint nb_people_not_infected &lt;- nb_people - nb_infected_init update: nb_people - nb_people_infected;\tfloat infected_rate update: nb_people_infected/nb_people;\t\t\tinit{\t\tcreate road from: roads_shapefile;\t\tcreate building from: buildings_shapefile;\t\tcreate people number:nb_people {\t\t\tmy_house &lt;- one_of(building);\t\t\tlocation &lt;- any_location_in(my_house);\t\t}\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t}\t\treflex end_simulation when: infected_rate = 1.0 {\t\tdo pause;\t}}species people skills:[moving]{\t\t\tfloat speed &lt;- (2 + rnd(3)) #km/#h;\tbool is_infected &lt;- false;\tbuilding my_house;\t\treflex move{\t\tdo wander;\t}\treflex infect when: is_infected{\t\task people at_distance 10 #m {\t\t\tif flip(0.05) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(10) color:is_infected ? #red : #green;\t}}species road {\taspect geom {\t\tdraw shape color: #black;\t}}species building {\taspect geom {\t\tdraw shape color: #gray;\t}}experiment main_experiment type:gui{\tparameter \"Nb people infected at init\" var: nb_infected_init min: 1 max: 2147;\toutput {\t\tmonitor \"Infected people rate\" value: infected_rate;\t\t\t\tdisplay map type: opengl {\t\t\tspecies road aspect:geom;\t\t\tspecies building aspect:geom;\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t\t\t\tdisplay chart refresh:every(10) {\t\t\tchart \"Disease spreading\" type: series {\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\t\t\t}\t\t}\t}}Next step: Use of a graph to constraint the movements of people",
        "url":"/wiki/LuneraysFlu_step3.html"
      }
      ,
    
      "wiki-luneraysflu-step4-html": {
        "title": "4. Use of a graph to constraint the movements of people]",
        "content": "4. Use of a graph to constraint the movements of people]This fourth step illustrates how to use a graph to constraint the movements of agentsFormulation  Define a new global variable: the road network (graph).  Build the road network graph from the road agents  Add new attribute to the people agents (target and in_my_house)  Define a new reflex for people agents: stay.  Modify the move reflex of the people agents.Model Definitionglobal sectionglobal variablesIn this model, we want that people agents move from buildings to buildings by using the shortest path in the road network. In order to compute this shortest path, we need to use a graph structure.We thus define a new global variable called road_network of type graph that will represent the road network.global{\t//... other attributes\tgraph road_network;\t\t//... init}In order to compute the graph from the road network, we use, just after having creating the road agents, the as_edge_graph operator. This operator automatically built a graph from a set of polylines. Each extremity point of the lines will become a node in the graph, and each polyline an edge. By default, the graph is not oriented and the weights of the edges are the perimeters of the polylines. It is of course possible to change through the use of some operators.global {\t// world variable definition\tinit{\t\tcreate road from: roads_shapefile;\t\troad_network &lt;- as_edge_graph(road);\t\tcreate building from: buildings_shapefile;\t\tcreate people number:nb_people {\t\t\tmy_home &lt;- one_of(building);\t\t\tlocation &lt;- any_location_in(my_home);\t\t}\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t\t}}people speciesWe want to modify the behavior of the people agents in order to make them move from buildings to buildings by using the shortest path in the road network. In addition, we want to integrate the fact that people will stay in the building a certain time before moving to another building. This staying time will depend if the agent is in its house or in another house (different probabilities of moving).variablesIn order to implement this behavior, we will add two variables to our people species:  target of type point that will be the location where the agent wants to go  in_my_house of type bool that will just say if the agent is in its house or not. At the beginning the agent will be in its house, so we initialize this variable by true.species people skills:[moving]{\t//...the other attributes\tpoint target;\tbool in_my_house &lt;- true;\t//....}behaviorFirst, we add a new reflex called stay that will be activated when the agent is in a house (i.e. its target is null) and that will define if the agent has to go or not. If the agent has to go, it will randomly choose a new target (a random location inside one of the building). We define two probabilities of moving: 0.01 if the agent is in its house, 0.1 otherwise (more chance to move if the agent is not in its house).reflex stay when: target = nil {\tif flip(in_my_house ? 0.01 : 0.1) {\t\tbuilding bd_target &lt;- in_my_house ? one_of(building) : my_house;\t\ttarget &lt;- any_location_in (bd_target);\t\tin_my_house &lt;- not in_my_house;\t}}Then, we modify the move reflex. This one will be only activated when the agent will have to move (target not null). Instead of using the wander action of the moving skill, we use the goto one that allows to make an agent moves toward a given target. In addition, it is possible to add a facet on to precise on which topology the agent will have to move on. In our case, the topology is the road network.When the agent reach its destination (location = target), it sets its target to null.reflex move when: target != nil{\tdo goto target:target on: road_network;\tif (location = target) {\t\ttarget &lt;- nil;\t} }Complete Modelmodel SI_city4 global{ \tint nb_people &lt;- 2147;\tint nb_infected_init &lt;- 5;\tfloat step &lt;- 1 #mn;\tfile roads_shapefile &lt;- file(\"../includes/roads.shp\");\tfile buildings_shapefile &lt;- file(\"../includes/buildings.shp\");\tgeometry shape &lt;- envelope(roads_shapefile);\tint nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected);\tint nb_people_not_infected &lt;- nb_people - nb_infected_init update: nb_people - nb_people_infected;\tfloat infected_rate update: nb_people_infected/nb_people;\t\tgraph road_network;\t\tinit{\t\tcreate road from: roads_shapefile;\t\troad_network &lt;- as_edge_graph(road);\t\tcreate building from: buildings_shapefile;\t\tcreate people number:nb_people {\t\t\tmy_house &lt;- one_of(building);\t\t\tlocation &lt;- any_location_in(my_house);\t\t}\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t}\t\treflex end_simulation when: infected_rate = 1.0 {\t\tdo pause;\t}}species people skills:[moving]{\t\t\tfloat speed &lt;- (2 + rnd(3)) #km/#h;\tbool is_infected &lt;- false;\tbuilding my_house;\tpoint target;\tbool in_my_house &lt;- true;\t\treflex stay when: target = nil {\t\tif flip(in_my_house ? 0.01 : 0.1) {\t\t\tbuilding bd_target &lt;- in_my_house ? one_of(building) : my_house;\t\t\ttarget &lt;- any_location_in (bd_target);\t\t\tin_my_house &lt;- not in_my_house;\t\t}\t}\t\t\treflex move when: target != nil{\t\tdo goto target:target on: road_network;\t\tif (location = target) {\t\t\ttarget &lt;- nil;\t\t} \t}\treflex infect when: is_infected{\t\task people at_distance 10 #m {\t\t\tif flip(0.05) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(10) color:is_infected ? #red : #green;\t}}species road {\taspect geom {\t\tdraw shape color: #black;\t}}species building {\taspect geom {\t\tdraw shape color: #gray;\t}}experiment main_experiment type:gui{\tparameter \"Nb people infected at init\" var: nb_infected_init min: 1 max: 2147;\toutput {\t\tmonitor \"Infected people rate\" value: infected_rate;\t\t\t\tdisplay map type: opengl{\t\t\tspecies road aspect:geom;\t\t\tspecies building aspect:geom;\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t\t\t\tdisplay chart refresh:every(10) {\t\t\tchart \"Disease spreading\" type: series {\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\t\t\t}\t\t}\t}}Next step: Definition of 3D displays",
        "url":"/wiki/LuneraysFlu_step4.html"
      }
      ,
    
      "wiki-luneraysflu-step5-html": {
        "title": "5. Definition of 3D displays",
        "content": "5. Definition of 3D displaysThis fifth step illustrates how to define 3D displaysFormulation  Define a new 3D aspect for roads.  Define a new 3D aspect for buildings  Define a new 3D aspect for people  Define a new 3D displayModel DefinitionspeciesFirst, we add a new variable called display_shape of type geometry for road agent that is a tube of 2m radius built from its geometry. Note that it is possible to get the list of points composing a geometry by using the points variable of the geometry. We define then an aspect called geom3D that draws the previous geometry in black.species road {\tgeometry display_shape &lt;- line(shape.points, 2.0);\t\t//....\taspect geom3D {\t\tdraw display_shape color: #black;\t}}Concerning the building species, we add a new variable called height of type float that is initialized by a random value between 20 and 40 meters.We define then an aspect called geom3D that draws the shape of the building with a depth of height and with using a texture (“texture.jpg” that is located inside the includes folder).species building {\tfloat height &lt;- 20#m + rnd(20) #m;\t//....\taspect geom3D {\t\tdraw shape depth: height texture:[\"../includes/texture.jpg\"];\t}}At last, we define a new aspect called geom3D for the people species that draws first a pyramid of 5 meters size, then a sphere of radius 2 meters at a height of 5m (z = 5). Note that it is possible to access the coordinates of a point by using the x, y and z variables. In GAMA, a point can be defined by using the format {x_value,y_value,z_value}.species people skills:[moving]{\t\t\t//....\taspect geom3D{\t\tdraw pyramid(5) color: is_infected ? #red : #green;\t\tdraw sphere(2) at: {location.x,location.y,5} color: is_infected ? #red : #green;\t\t}}outputWe define a new display called map_3D of type opengl with an ambient_light of 120 that displays first a image (“soil.jpg”), then the road with the geom3D aspect, then the building with the geom3D aspect, and finally the people with the geom3D aspect. All layers except the people’s one will not be refreshed (refresh set to false).experiment main_experiment type: gui {\toutput {\t// monitor and other displays\t\t\tdisplay map_3D type: opengl ambient_light: 120 {\t\t\timage \"../includes/soil.jpg\" refresh: false;\t\t\tspecies road aspect:geom3D refresh: false;\t\t\tspecies building aspect:geom3D refresh: false;\t\t\tspecies people aspect:geom3D;\t\t\t\t\t}\t}}Complete Modelmodel SI_city5global{ \tint nb_people &lt;- 2147;\tint nb_infected_init &lt;- 5;\tfloat step &lt;- 1 #mn;\tfile roads_shapefile &lt;- file(\"../includes/roads.shp\");\tfile buildings_shapefile &lt;- file(\"../includes/buildings.shp\");\tgeometry shape &lt;- envelope(roads_shapefile);\tint nb_people_infected &lt;- nb_infected_init update: people count (each.is_infected);\tint nb_people_not_infected &lt;- nb_people - nb_infected_init update: nb_people - nb_people_infected;\tfloat infected_rate update: nb_people_infected/nb_people;\t\tgraph road_network;\t\tinit{\t\tcreate road from: roads_shapefile;\t\troad_network &lt;- as_edge_graph(road);\t\tcreate building from: buildings_shapefile;\t\tcreate people number:nb_people {\t\t\tmy_house &lt;- one_of(building);\t\t\tlocation &lt;- any_location_in(my_house);\t\t}\t\task nb_infected_init among people {\t\t\tis_infected &lt;- true;\t\t}\t}\t\treflex end_simulation when: infected_rate = 1.0 {\t\tdo pause;\t}}species people skills:[moving]{\t\t\tfloat speed &lt;- (2 + rnd(3)) #km/#h;\tbool is_infected &lt;- false;\tbuilding my_house;\tpoint target;\tbool in_my_house &lt;- true;\t\treflex stay when: target = nil {\t\tif flip(in_my_house ? 0.01 : 0.1) {\t\t\tbuilding bd_target &lt;- in_my_house ? one_of(building) : my_house;\t\t\ttarget &lt;- any_location_in (bd_target);\t\t\tin_my_house &lt;- not in_my_house;\t\t}\t}\t\t\treflex move when: target != nil{\t\tdo goto target:target on: road_network;\t\tif (location = target) {\t\t\ttarget &lt;- nil;\t\t} \t}\treflex infect when: is_infected{\t\task people at_distance 10 #m {\t\t\tif flip(0.05) {\t\t\t\tis_infected &lt;- true;\t\t\t}\t\t}\t}\taspect circle{\t\tdraw circle(10) color:is_infected ? #red : #green;\t}\taspect geom3D{\t\tdraw pyramid(5) color: is_infected ? #red : #green;\t\tdraw sphere(2) at: {location.x,location.y,5} color: is_infected ? #red : #green;\t\t}\t}species road {\tgeometry display_shape &lt;- line(shape.points, 2.0);\t\taspect geom {\t\tdraw shape color: #black;\t}\taspect geom3D {\t\tdraw display_shape color: #black;\t}}species building {\tfloat height &lt;- 20#m + rnd(20) #m;\t\taspect geom {\t\tdraw shape color: #gray;\t}\taspect geom3D {\t\tdraw shape depth: height texture:[\"../includes/texture.jpg\"];\t}\t}experiment main_experiment type:gui{\tparameter \"Nb people infected at init\" var: nb_infected_init min: 1 max: 2147;\toutput {\t\tmonitor \"Infected people rate\" value: infected_rate;\t\t\t\tdisplay map type: opengl{\t\t\tspecies road aspect:geom;\t\t\tspecies building aspect:geom;\t\t\tspecies people aspect:circle;\t\t\t\t\t}\t\t\t\tdisplay map_3D type: opengl ambient_light: 120 {\t\t\timage \"../includes/soil.jpg\" refresh: false;\t\t\tspecies road aspect:geom3D refresh: false;\t\t\tspecies building aspect:geom3D refresh: false;\t\t\tspecies people aspect:geom3D;\t\t\t\t\t}\t\t\tdisplay chart refresh:every(10) {\t\t\tchart \"Disease spreading\" type: series {\t\t\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\t\t\t\tdata \"infected\" value: nb_people_infected color: #red;\t\t\t}\t\t}\t}}",
        "url":"/wiki/LuneraysFlu_step5.html"
      }
      ,
    
      "wiki-manipulatebasicspecies-html": {
        "title": "Manipulate basic species",
        "content": "Manipulate basic speciesIn this chapter, we will learn how to manipulate some basic species. As you already know, a species can be seen as the definition of a type of agent (we call agent the instance of a species). In OOP (Object-Oriented Programming), a species can be seen as the class. Each species is then defined by some attributes (“member” in OOP), actions (“method” in OOP) and behavior (“method” in OOP).In this section, we will first learn how to declare the world agent, using the global species. We will then learn how to declare regular species which will populate our world. The following lesson will be dedicated to learn how to define actions and behaviors for all those species. We will then learn how agents can interact between each other, especially with the statement ask. In the next chapter then, we will see how to attach skills to our species, giving them new attributes and actions. This section will be closed with a last lesson dealing with how inheritence works in GAML.",
        "url":"/wiki/ManipulateBasicSpecies.html"
      }
      ,
    
      "wiki-manipulatedates-html": {
        "title": "Manipulate Dates",
        "content": "Manipulate DatesManaging Time in ModelsIf some models are based on a abstract time - only the number of cycles is important - others are based on a real time. In order to manage the time, GAMA provides some tools to manage time.First, GAMA allows to define the duration of a simulation step. It provides access to different time variables. At last, since GAMA 1.7, it provides a date variable type and some global variables allowing to use a real calendar to manage time.Definition of the step and use of temporal unity valuesGAMA provides three important global variables to manage time:  cycle (int - not modifiable): the current simulation step - this variable is incremented by 1 at each simulation step  step (float - can be modified): the duration of a simulation step (in seconds). By default the duration is one second.  time (float - not modifiable): the current time spent since the beginning of the simulation - this variable is computed at each simulation step by: time = cycle * step.The value of the cycle and time variables are shown in the top left (green rectangle) of the simulation interface. Clicking on the green rectangle allows to display either the number cycles or the time variable. Concerning this variable, it is presented following a years - month - days - hours - minutes - seconds format. In this presentation, every months are considered as being composed of 30 days (the different number of days of months are not taken into account).Concerning the step facet, the variable can be modified by the modeler. A classic way of doing it consists in reediting the variable in the global section:global {       float step &lt;- 1 #hour;}In this example, each simulation step will represent 1 hour. This time will be taken into account for all actions based on time (e.g. moving actions).Note that the value of the step variable should be given in seconds. To facilitate the definition of the step value and of all expressions based on time, GAMA provides different built-in constant variables accessible with the “#” symbol:  #s : second - 1 second  #mn : minute - 60 seconds  #hour : hour - 60 minutes - 3600 seconds  #day : day - 24 hours - 86400 seconds  #month : month - 30 days - 2592000 seconds  #year : year - 12 month - 3.1104E7The date variable type and the use of a real calendarSince GAMA 1.7, it is possible to use a real calendar to manage the time. For that, the modeler have just to define the starting date of the simulation. This variable is of type date which allow to represent a date and time. A date variable has several attributes:  year (int): the year component of the date  month (int): the month component of the date  day (int): the day component of the date  hour (int): the hour component of the date  minute (int): the minute component of the date  second (int): the second component of the date  day_of_week (int): the day of the week  week_of_year (int): the week of the yearSeveral ways can be used to define a date. The simplest consists in using a list of int values: [year,month of the year,day of the month, hour of the day, minute of the hour, second of the minute]date my_date &lt;- date([2010,3,23,17,30,10]); // the 23th of March 2010, at 17:30:10Another way consists in using a string with the good format:date my_date &lt;- date(\"2010-3-23T17:30:10+07:00\"); Note that the current date can be access through the #now built-in variable (variable of type date).In addition, GAMA provides different useful operators working on dates. For instance, it is possible to compute the duration in seconds between 2 dates using the “-” operator. The result is given in seconds:float d &lt;- starting_date - my_date;It is also possible to add or subtract a duration (in seconds) to a date:write \"my_date + 10: \" + (my_date + 10);write \"my_date - 10: \" + (my_date - 10);At last, it is possible to add or subtract a duration (in years, months, weeks, days, hours, minutes,  seconds) to a date:write \"my_date add_years 1: \" + (my_date add_years 1);write \"my_date add_months 1: \" + (my_date add_months 1);write \"my_date add_weeks 1: \" + (my_date add_weeks 1);write \"my_date add_days 1: \" + (my_date add_days 1);write \"my_date add_hours 1: \" + (my_date add_hours 1);write \"my_date add_minutes 1: \" + (my_date add_minutes 1);write \"my_date add_seconds 1: \" + (my_date add_seconds 1);\t\t  write \"my_date subtract_years 1: \" + (my_date subtract_years 1);write \"my_date subtract_months 1: \" + (my_date subtract_months 1);write \"my_date subtract_weeks 1: \" + (my_date subtract_weeks 1);write \"my_date subtract_days 1: \" + (my_date subtract_days 1);write \"my_date subtract_hours 1: \" + (my_date subtract_hours 1);write \"my_date subtract_minutes 1: \" + (my_date subtract_minutes 1);write \"my_date subtract_seconds 1: \" + (my_date subtract_seconds 1);For the modelers, two global date variable are available:  starting_date: date considered as the beginning of the simulation  current_date: current date of the simulationBy default, these variables are nil. Defining a value of the starting_date allows to change the normal time management of the simulation by a more realistic one (using calendar):global {     date starting_date &lt;- date([1979,12,17,19,45,10]);}When a variable is set to this variable, the current_date variable is automatically initialized with the same value. However, at each simulation step, the current_date variable is incremented by the step variable. The value of the current_date will replace the value of the time variable in the top left green panel.Note that you have to be careful, when a real calendar is used, the built-in constants #month and #year should not be used as there are not consistent with the calendar (where month can be composed of 28, 29, 30 or 31 days).",
        "url":"/wiki/ManipulateDates.html"
      }
      ,
    
      "wiki-manipulatelight-html": {
        "title": "Implementing light",
        "content": "Implementing lightWhen using opengl display, GAMA provides you the possibility to manipulate one or several lights, making your display more realistic.Most of the following screenshots will be taken with the following short example gaml :model test_lightgrid cells {\taspect base {\t\tdraw square(1) at:{grid_x,grid_y} color:#white;\t}}experiment my_experiment type:gui{\toutput {\t\tdisplay my_display type:opengl background:#darkblue {\t\t\tspecies cells aspect:base;\t\t\tgraphics \"my_layer\" {\t\t\t\tdraw square(100) color:#white at:{50,50};\t\t\t\tdraw cube(5) color:#lightgrey at:{50,30};\t\t\t\tdraw cube(5) color:#lightgrey at:{30,35};\t\t\t\tdraw cube(5) color:#lightgrey at:{60,35};\t\t\t\tdraw sphere(5) color:#lightgrey at:{10,10,2.5};\t\t\t\tdraw sphere(5) color:#lightgrey at:{20,30,2.5};\t\t\t\tdraw sphere(5) color:#lightgrey at:{40,30,2.5};\t\t\t\tdraw sphere(5) color:#lightgrey at:{40,60,2.5};\t\t\t\tdraw cone3D(5,5) color:#lightgrey at:{55,10,0};\t\t\t\tdraw cylinder(5,5) color:#lightgrey at:{10,60,0};\t\t\t}\t\t}\t}}Index  Light generalities  Default light  Custom lightsLight generalitiesBefore going deep into the code, here is a quick explanation about how light works in opengl.First of all, you need to know that there are 3 types of lights you can manipulate : the ambient light, the diffuse light and the specular light. Each “light” in opengl is in fact composed of those 3 types of lights.Ambient lightThe ambient light is the light of your world without any lighting. If a face of a cube is not stricken by the light rays for instance, this face will appear totally black if there is no ambient light. To make your world more realistic, it is better to have an ambient light.An ambient light has then no position or direction. It is equally distributed to all the objects of your scene.Here is an example of our GAML scene using only ambient light (color red) :Diffuse lightThe diffuse light can be seen as the light rays : if a face of a cube is stricken by the diffuse light, it will take the color of this diffuse light. You have to know that the more perpendicular the face of your object will be to the light ray, the more lightened the face will be.A diffuse light has then a direction. It can have also a position.Your have 2 categories of diffuse light : the positional lights, and the directional lights.Positional lightsThose lights have a position in your world. It is the case of point lights and spot lights.  Point lightsPoints lights can be seen as a candle in your world, diffusing the light equally in all the direction.Here is an example of our GAML scene using only diffuse light, with a point light (color red, the light source is displayed as a red sphere) :  Spot lightsSpot lights can be seen as a torch light in your world. It needs a position, and also a direction and an angle.Here is an example of our GAML scene using only diffusion light, with a spot light (color red, the light source is displayed as a red cone) :Positional lights, as they have a position, can also have an attenuation according to the distance between the light source and the object. The value of positional lights are computed with the following formula :diffuse_light = diffuse_light * ( 1 / (1 + constante_attenuation + linear_attenuation * d + quadratic_attenuation * d))By changing those 3 values (constante_attenuation, linear_attenuation and quadratic_attenuation), you can control the way light is diffused over your world (if your world is “foggy” for instance, you may turn your linear and quadratic attenuation on). Note that by default, all those attenuation are equal to 0.Here is an example of our GAML scene using only diffusion light, with a point light with linear attenuation (color red, the light source is displayed as a red sphere) :Directional lightsDirectional lights have no real “position” : they only have a direction. A directional light will strike all the objects of your world with the same direction. An example of directional light you have in the real world would be the light of the sun : the sun is so far away from us that you can consider that the rays have the same direction and the same intensity wherever they strike.Since there is no position for directional lights, there is no attenuation either.Here is an example of our GAML scene using only diffusion light, with a directional light (color red) :Specular lightThis is a more advanced concept, giving an aspect a little bit “shinny” to the objects stricken by the specular light. It is used to simulate the interaction between the light and a special material (ex : wood, steel, rubber…).This specular light is not implemented yet in gama, only the two others are.Default lightIn your opengl display, without specifying any light, you will have only one light, with those following properties :Those values have been chosen in order to have the same visual effect in both opengl and java2D displays, when you display 2D objects, and also to have a nice “3D effect” when using the opengl displays. We chose the following setting by default :  The ambient light value : rgb(127,127,127,255)  diffuse light value : rgb(127,127,127,255)  type of light : direction  direction of the light : (0.5,0.5,-1);Here is an example of our GAML scene using the default light :Custom lightsIn your opengl display, you can create up to 8 lights, giving them the properties you want.Ambient lightIn order to keep it simple, the ambient light can be set directly when you are declaring your display, through the facet ambient_light. You will have one only ambient light.experiment my_experiment type:gui {\toutput {\t\tdisplay \"my_display\" type:opengl ambient_light:100 {\t\t}\t}}Note for developers : Note that this ambient light is set to the GL_LIGHT0. This GL_LIGHT0 only contains an ambient light, and no either diffuse nor specular light.Diffuse lightIn order to add lights, or modifying the existing lights, you can use the statement light, inside your display scope :experiment my_experiment type:gui {\toutput {\t\tdisplay \"my_display\" type:opengl {\t\t\tlight id:0;\t\t}\t}}This statement has just one non-optional facet : the facet “id”. Through this facet, you can specify which light you want. You can control 7 lights, through an integer value between 1 and 7.Once you are manipulating a light through the light statement, the light is turned on. To switch off the light, you have to add the facet active, and turn it to false.The light you are declaring through the light statement is in fact a “diffuse” light. You can specify the color of the diffuse light through the facet color (by default, the color will be turn to white).An other very important facet is the type facet. This facet accepts a value among direction, point and spot.Declaring direction lightA direction light, as explained in the first part, is a light without any position. Instead of the facet position, you will use the facet direction, giving a 3D vector.Example of implementation :light id:1 type:direction direction:{1,1,1} color:rgb(255,0,0);Declaring point lightA point light will need a facet position, in order to give the position of the light source.Example of implementation of a basic point light :light id:1 type:point position:{10,20,10} color:rgb(255,0,0);You can add, if you want, a custom attenuation of the light, through the facets linear_attenuation or quadratic_attenuation.Example of implementation of a point light with attenuation :light id:1 type:point position:{10,20,10} color:rgb(255,0,0) linear_attenuation:0.1;Declaring spot lightA spot light will need the facet position (a spot light is a positionnal light) and the facet direction. A spot light will also need a special facet spot_angle to determine the angle of the spot (by default, this value is set to 45 degree).Example of implementation of a basic spot light :light id:1 type:spot position:{0,0,10} direction:{1,1,1} color:rgb(255,0,0) spot_angle:20;Same as for point light, you can specify an attenuation for a spot light.Example of implementation of a spot light with attenuation :light id:1 type:spot position:{0,0,10} direction:{1,1,1} color:rgb(255,0,0) spot_angle:20;Note that when you are working with lights, you can display your lights through the facet draw light to help you implementing your model. The three types of lights are displayed differently :  The point light is represented by a sphere with the color of the diffuse light you specified, in the position of your light source.  The spot light is represented by a cone with the color of the diffuse light you specified, in the position of your light source, the orientation of your light source. The size of the base of the cone will depend of the angle you specified.  The direction light, as it has no real position, is represented with arrows a bit above the world, with the direction of your direction light, and the color of the diffuse light you specified.Note for developers : Note that, since the GL_LIGHT0 is already reserved for the ambient light (only !), all the other lights (from 1 to 7) are the lights from GL_LIGHT1 to GL_LIGHT7.            //: # (endConcept      light)      ",
        "url":"/wiki/ManipulateLight.html"
      }
      ,
    
      "wiki-manipulateosmdatas-html": {
        "title": "Manipulate OSM Datas",
        "content": "Manipulate OSM DatasThis section will be presented as a quick tutorial, showing how to proceed to manipulate OSM (Open street map) datas, and load them into GAMA. We will use the software QGIS to change the attributes of the OSM file.From the website openstreetmap.org, we will chose a place (in this example, we will take a neighborhood in New York City). Directly from the website, you can export the chosen area in the osm format.We have now to manipulate the attributes for the exported osm file.Several software are possible to use, but we will focus on QGIS, which is totally free and provides a lot of possibilities in term of manipulation of data.Once you have installed correctly QGIS, launch QGIS Desktop, and start to import the topology from the osm file.A message indicates that the import was successful. An output file .osm.db is created. You have now to export the topology to SpatiaLite.Specify the path for your DataBase file, then choose the export type (in your case, we will choose the type “Polygons (closed ways)”), choose an output layer name. If you want to use the open street maps attributes values, click on “Load from DB”, and select the attributes you want to keep. Click OK then.A message indicates that the export was successful, and you have now a new layer created.We will now manipulate the attributes of your datafile. Right click on the layer, and select “Open Attribute Table”.The table of attribute appears. Select the little pencil on the top-left corner of the window to modify the table.We will add an attribute manually. Click on the button “new column”, choose a name and a type (we will choose the type “text”).A new column appears at the end of the table. Let’s fill some values (for instance blue / red). Once you finishes, click on the “save edit” button.Our file is now ready to be exported. Right click on the layer, and click on “Save As”.Choose “shapefile” as format, choose a save path and click ok.Copy passed all the .shp created in the include folder of your GAMA project. You are now ready to write the model.model HowToUseOpenStreetMapglobal {\t// Global variables related to the Management units\t\tfile shapeFile &lt;- file('../includes/new_york.shp'); \t\t//definition of the environment size from the shapefile. \t//Note that is possible to define it from several files by using: geometry shape &lt;- envelope(envelope(file1) + envelope(file2) + ...);\tgeometry shape &lt;- envelope(shapeFile);\t\tinit {\t\t//Creation of elementOfNewYork agents from the shapefile (and reading some of the shapefile attributes)\t\tcreate elementOfNewYork from: shapeFile \t\t\twith: [elementId::int(read('id')), elementHeight::int(read('height')), elementColor::string(read('attrForGama'))] ;    }}\tspecies elementOfNewYork{\tint elementId;\tint elementHeight;\tstring elementColor;\t\taspect basic{\t\tdraw shape color: (elementColor = \"blue\") ? #blue : ( (elementColor = \"red\") ? #red : #yellow ) depth: elementHeight;\t}}\texperiment main type: gui {\t\t\toutput {\t\tdisplay HowToUseOpenStreetMap type:opengl {\t   \t\tspecies elementOfNewYork aspect: basic; \t\t}\t}}Here is the result, with a special colorization of the different elements regarding to the value of the attribute “attrForGama”, and an elevation regarding to the value of the attribute “height”.//: # (endConcept|use_osm_datas)",
        "url":"/wiki/ManipulateOSMDatas.html"
      }
      ,
    
      "wiki-map-comparison-raster-map-comparison-html": {
        "title": "Raster Map Comparison",
        "content": "Raster Map ComparisonAuthor : Patrick TaillandierThis model shows how to use different comparators to know the accuracy of a prediction model. Four comparators are used :  kappa, comparing the map observed and the map simulation ; kappa simulation comparing the initial map, the map observed and the map simulation;  fuzzy kappa, comparing the map observed and the map simulation but being more permissive by using fuzzy logic;  fuzzy kappa simulation, comparing the map observed, the map simulation and the map initial but being more permissive by using fuzzy logicCode of the model :model mapcomparisonglobal {\tlist&lt;string&gt; categories &lt;- [\"type 1\", \"type 2\", \"type 3\", \"type 4\"];\tmap&lt;string,rgb&gt; color_cat &lt;- [\"type 1\"::#blue, \"type 2\"::#green, \"type 3\"::#yellow, \"type 4\"::#red];\tmatrix&lt;float&gt; fuzzy_categories;\tmatrix&lt;float&gt; fuzzy_transitions;\tlist&lt;float&gt; nb_per_cat_obs;\tlist&lt;float&gt; nb_per_cat_sim;\t \tinit {\t\t//Initialize randomly the category of each cell\t\task shuffle(cell) {\t\t\tstring neigh_cat &lt;-one_of(neighbours).cat_observed;\t\t\tcat_init &lt;- neigh_cat in categories ? neigh_cat : one_of(categories);\t\t\tcolor_init &lt;- color_cat[cat_init];\t\t}\t\t\t\t//Initialize the category observed and the cat attributes of the cells according to probability : \t\t// 60% of cases, the category observed will be the same than the category initialized\t\t//60% of cases, the category will be the same than the category observed\t\task cell {\t\t\tcat_observed &lt;- flip(0.6) ?  cat_init : one_of(categories);\t\t\tcat &lt;- flip(0.6) ?  cat_observed : one_of(categories);\t\t\tcolor &lt;- color_cat[cat];\t\t\tcolor_obs &lt;- color_cat[cat_observed];\t\t}\t\tfuzzy_categories &lt;- 0.0 as_matrix {length(categories),length(categories)};\t\tloop i from: 0 to: length(categories) - 1 {\t\t\tfuzzy_categories[i,i] &lt;- 1.0;\t\t}\t\tfuzzy_transitions &lt;- 0.0 as_matrix {length(categories)*length(categories),length(categories)*length(categories)};\t\tloop i from: 0 to: (length(categories) * length(categories)) - 1 {\t\t\tfuzzy_transitions[i,i] &lt;- 1.0;\t\t\t}\t\tlist&lt;float&gt; similarity_per_agents ;\t\twrite \"kappa(map observed, map simulation, categories): \" + kappa( cell collect (each.cat_observed),cell collect (each.cat),categories);\t\twrite \"kappa simulation(map init, map observed, map simulation,categories): \" + kappa_sim( cell collect (each.cat_init), cell collect (each.cat_observed),cell collect (each.cat),categories);\t\tusing topology(cell) {\t\t\twrite \"fuzzy kappa(map observed, map simulation,categories): \" + fuzzy_kappa(list(cell), cell collect (each.cat_observed),cell collect (each.cat), similarity_per_agents,categories,fuzzy_categories, 10);\t\t\twrite \"fuzzy kappa sim(map init, map observed, map simulation,categories): \" + fuzzy_kappa_sim(list(cell), cell collect (each.cat_init), cell collect (each.cat_observed),cell collect (each.cat), similarity_per_agents,categories,fuzzy_transitions, 10);\t\t}\t\tloop i from: 0 to: length(cell) - 1 {\t\t\tint val &lt;- int(255 * similarity_per_agents[i]);\t\t\task cell[i] {color_fuzzy &lt;- rgb(val, val, val);}\t\t\t\t\t}\t\tloop c over: categories {\t\t\tnb_per_cat_obs &lt;&lt; cell count (each.cat_observed = c);\t\t\tnb_per_cat_sim &lt;&lt; cell count (each.cat = c); \t\t}\t\twrite \"percent_absolute_deviation : \" + percent_absolute_deviation(nb_per_cat_obs,nb_per_cat_sim) + \"%\";\t\t\t}\t}grid cell width: 50 height: 50 {\tstring cat_init;\tstring cat_observed;\tstring cat ;\trgb color;\trgb color_init;\trgb color_obs;\trgb color_fuzzy &lt;- #white;\tlist&lt;cell&gt; neighbours &lt;- self neighbors_at 1;\t\taspect fuzzy_sim {\t\tdraw shape color:color_fuzzy border: color_fuzzy;\t}\taspect init {\t\tdraw shape color:color_init border: color_init;\t}\taspect observed {\t\tdraw shape color:color_obs border: color_obs;\t}}experiment mapcomparison type: gui {\toutput {\t\tdisplay map_sim type: opengl{\t\t\tgrid cell;\t\t}\t\tdisplay map_observed type: opengl{\t\t\tspecies cell aspect: observed refresh: false;\t\t}\t\tdisplay map_init type: opengl{\t\t\tspecies cell aspect: init refresh: false;\t\t}\t\tdisplay map_fuzzy type: opengl{\t\t\tspecies cell aspect: fuzzy_sim ;\t\t}\t}}",
        "url":"/wiki/Map-comparison-Raster-Map-Comparison.html"
      }
      ,
    
      "wiki-map-comparison-vector-map-comparison-html": {
        "title": "Vector Map Comparison",
        "content": "Vector Map ComparisonAuthor : Patrick TaillandierThis model shows how to use different comparators to know the accuracy of a prediction model. Four comparators are used :  kappa, comparing the map observed and the map simulation ; kappa simulation comparing the initial map, the map observed and the map simulation;  fuzzy kappa, comparing the map observed and the map simulation but being more permissive by using fuzzy logic;  fuzzy kappa simulation, comparing the map observed, the map simulation and the map initial but being more permissive by using fuzzy logicFor each comparator, two comparisons are made : one without taking into account the weights of an area, just computing with each area having the same importance, and an other using weights related to the area of the regionCode of the model :model mapcomparisonglobal {\tlist&lt;string&gt; categories ;\tmap&lt;string,rgb&gt; color_cat ;\tmatrix&lt;float&gt; fuzzy_categories;\tmatrix&lt;float&gt; fuzzy_transitions;\tlist&lt;float&gt; nb_per_cat_obs;\tlist&lt;float&gt; nb_per_cat_sim;\tfile data &lt;- file(\"../includes/CLC00_06.shp\");\t\tgeometry shape &lt;- envelope(data);\t \tinit {\t\tcreate areaclc from: data with: [init_cover::string(read(\"CODE_00\")),obs_cover::string(read(\"CODE_06\"))] ;\t\task areaclc {\t\t\tif (not (init_cover in categories)) {categories &lt;&lt; init_cover; }\t\t\tif (not (obs_cover in categories)) {categories &lt;&lt; obs_cover;}\t\t\t\t\t}\t\tloop cat over: categories {\t\t\tcolor_cat[cat] &lt;- rgb(rnd(255),rnd(255),rnd(255));\t\t}\t\task areaclc {\t\t\tsim_cover &lt;- flip(0.7) ? obs_cover : one_of (categories);\t\t}\t\t\t\tfuzzy_categories &lt;- 0.0 as_matrix {length(categories),length(categories)};\t\tloop i from: 0 to: length(categories) - 1 {\t\t\tfuzzy_categories[i,i] &lt;- 1.0;\t\t}\t\tfuzzy_transitions &lt;- 0.0 as_matrix {length(categories)*length(categories),length(categories)*length(categories)};\t\tloop i from: 0 to: (length(categories) * length(categories)) - 1 {\t\t\tfuzzy_transitions[i,i] &lt;- 1.0;\t\t\t}\t\tlist&lt;float&gt; similarity_per_agents ;\t\twrite \"kappa(map observed, map simulation, categories): \" + kappa( areaclc collect (each.obs_cover),areaclc collect (each.sim_cover),categories);\t\twrite \"kappa(map observed, map simulation,categories, weights): \" + kappa( areaclc collect (each.obs_cover),areaclc collect (each.sim_cover),categories,areaclc collect (each.shape.area));\t\t\t\twrite \"kappa simulation(map init, map observed, map simulation, categories): \" + kappa_sim( areaclc collect (each.init_cover), areaclc collect (each.obs_cover),areaclc collect (each.sim_cover),categories);\t\twrite \"kappa simulation(map init, map observed, map simulation, categories, weights): \" + kappa_sim( areaclc collect (each.init_cover), areaclc collect (each.obs_cover),areaclc collect (each.sim_cover),categories,areaclc collect (each.shape.area));\t\t\t\twrite \"fuzzy kappa(map observed, map simulation,categories): \" + fuzzy_kappa(areaclc, areaclc collect (each.obs_cover),areaclc collect (each.sim_cover), similarity_per_agents,categories,fuzzy_categories, 3000);\t\twrite \"fuzzy kappa(map observed, map simulation,categories,weights): \" + fuzzy_kappa(areaclc, areaclc collect (each.obs_cover),areaclc collect (each.sim_cover), similarity_per_agents,categories,fuzzy_categories, 3000,areaclc collect (each.shape.area));\t\t\t\twrite \"fuzzy kappa sim(map init, map observed, map simulation,categories): \" + fuzzy_kappa_sim(areaclc, areaclc collect (each.init_cover), areaclc collect (each.obs_cover),areaclc collect (each.sim_cover), similarity_per_agents,categories,fuzzy_transitions, 3000);\t\twrite \"fuzzy kappa sim(map init, map observed, map simulation,categories,weights): \" + fuzzy_kappa_sim(areaclc, areaclc collect (each.init_cover), areaclc collect (each.obs_cover),areaclc collect (each.sim_cover), similarity_per_agents,categories,fuzzy_transitions, 3000,areaclc collect (each.shape.area));\t\t\t\tloop i from: 0 to: length(areaclc) - 1 {\t\t\tint val &lt;- int(255 * similarity_per_agents[i]);\t\t\task areaclc[i] {color_fuzzy &lt;- rgb(val, val, val);}\t\t\t\t\t}\t\tloop c over: categories {\t\t\tlist&lt;areaclc&gt; area_c &lt;- areaclc where (each.obs_cover = c);\t\t\tlist&lt;float&gt; area_shape_c &lt;- area_c collect (each.shape.area);\t\t\tnb_per_cat_obs &lt;&lt; sum(area_shape_c );\t\t\tnb_per_cat_sim &lt;&lt; sum((areaclc where (each.sim_cover = c)) collect (each.shape.area)); \t\t}\t\twrite \"percent_absolute_deviation : \" + percent_absolute_deviation(nb_per_cat_obs,nb_per_cat_sim) + \"%\";\t\t\t}\t} species areaclc {\tstring init_cover;\tstring obs_cover;\tstring sim_cover;\trgb color_fuzzy;\t\taspect init {\t\tdraw shape color: color_cat[init_cover];\t}\taspect simulation {\t\tdraw shape color: color_cat[sim_cover];\t}\taspect observed {\t\tdraw shape color: color_cat[obs_cover];\t}\taspect fuzzy_sim {\t\tdraw shape color: color_fuzzy;\t}}experiment mapcomparison type: gui {\toutput {\t\tdisplay map_sim type: opengl{\t\t\tspecies areaclc aspect: simulation;\t\t}\t\tdisplay map_observed type: opengl{\t\t\tspecies areaclc aspect: observed refresh: false;\t\t}\t\tdisplay map_init type: opengl{\t\t\tspecies areaclc aspect: init refresh: false;\t\t}\t\tdisplay map_fuzzy type: opengl background: #pink{\t\t\tspecies areaclc aspect: fuzzy_sim ;\t\t}\t}}",
        "url":"/wiki/Map-comparison-Vector-Map-Comparison.html"
      }
      ,
    
      "wiki-map-comparison-html": {
        "title": "Map comparison",
        "content": "Map comparisonThis sub-section is composed of the following models :      Raster Map Comparison        Vector Map Comparison  ",
        "url":"/wiki/Map-comparison.html"
      }
      ,
    
      "wiki-menusandcommands-html": {
        "title": "Menus and Commands",
        "content": "Menus and CommandsThe simulation perspective adds on the user interface a number of new menus and commands (i.e. buttons) that are specific to experiment-related tasks.Table of contents  Menus and Commands          Experiment Menu      Agents Menu      General Toolbar      Experiment MenuA menu, called “Experiment”, allows to control the current experiment. It shares some of its commands with the general toolbar (see below).  Run/Pause: allows to run or pause the experiment depending on its current state.  Step by Step: runs the experiment for one cycle and pauses it after.  Reload: stops the current experiment, deletes its contents, and reloads it, taking into account the parameters values that might have been changed by the user.  Stop at first error: if checked, the current experiment will stop running when an error is issued. The default value can be configured in the preferences.  Treat warnings as errors: if checked, a warning will be considered as an error (and if the previous item is checked, will stop the experiment). The default value can be configured in the preferences.  Display warnings and errors: if checked, displays the errors and warnings issued by the experiment. If not, do not display them. The default value can be configured in the preferences.  Force interrupt: forces the experiment to stop, whatever it is currently doing, purges the memory from it, and switches to the modeling perspective. Use this command with caution, as it can have undesirable effects depending on the state of the experiment (for example, if it is reading files, or outputting data, etc.).Agents MenuA second menu is added in the simulation perspective: “Agents”. This menu allows for an easy access to the different agents that populate an experiment.This hierarchical menu is always organized in the same way, whatever the experiment being run. A first level is dedicated to the current simulation agent: it allows to browse its population or to inspect the simulation agent itself. Browsing the population will give access to the current experiment agent (the “host” of this population). A second level lists the “micro-populations” present in the simulation agent. And the third level will give access to each individual agent in these populations. This organization is of course recursive: if these agents are themselves hosts of micro-populations, they will be displayed in their individual menu.Each agent, when selected, will reveal a similar individual menu. This menu will contain a set of predefined actions, the commands defined by the user for this species, if any, and then the micro-populations hosted by this agent, if any. Agents (like the instances of “ant” below) that do not host other agents and whose species has no user commands will have a “simple” individual menu.These are the 4 actions that will be there most of the time:  Inspect: open an inspector on this agent.  Highlight: makes this agent the current “highlighted” agent, forcing it to appear “highlighted” in all the displays that might have been defined.  Focus: this option is not accessible if no displays are defined. Makes the current display zoom on the selected agent (if it is displayed) so that it occupies the whole view.  Kill: destroys the selected agent and disposes of it. Use this command with caution, as it can have undesirable effects if the agent is currently executing its behavior.If an agent hosts other agents (it is the case in multi-level architecture), you can access to the micro-population quite easily:If user commands are defined for a species (for example in the existing model Features/Driving Skill/Road Traffic simple (City)), their individual menu will look like the following:General ToolbarThe last piece of user interface specific to the Simulation Perspective is a toolbar, which contains controls and information displays related to the current experiment.This toolbar is voluntarily minimalist, with three buttons already present in the experiment menu (namely, “Play/Pause”, “Step by Step” and “Reload”), which don’t need to be detailed here, and two new controls (“Experiment status” and “Cycle Delay”), which are explained below.While opening an experiment, the status will display some information about what’s going on. For instance, that GAMA is busy instantiating the agents, or opening the displays.The orange color usually means that, although the experiment is not ready, things are progressing without problems (a red color message is an indication that something went wrong). When the loading of the experiment is finished, GAMA displays the message “Simulation ready” on a green background. If the user runs the simulation, the status changes and displays the number of cycles already elapsed in the simulation currently managed by the experiment.Hovering over the status produces a more accurate information about the internal clock of the simulation.From top to bottom of this hover, we find the number of cycles elapsed, the simulated time already elapsed (in the example above, one cycle lasts one second of simulated time), the duration of cycle in milliseconds, the average duration of one cycle (computed over the number of cycles elapsed), and the total duration, so far, of the simulation (still in milliseconds).Although these durations are entirely dependent on the speed of the simulation engine (and, of course, the number of agents, their behaviors, etc.), there is a way to control it partially with the second control, which allows the user to force a minimal duration (in milliseconds) for a cycle, from 0 (its initial position) to 1000. Note that this minimal duration (or delay) will remain the same for the subsequent reloads of the experiment.In case it is necessary to have more than 1s of delay, it has to be defined, instead, as an attribute of the experiment.",
        "url":"/wiki/MenusAndCommands.html"
      }
      ,
    
      "wiki-mirrorspecies-html": {
        "title": "Mirror species",
        "content": "Mirror speciesA mirror species is a species whose population is automatically managed with respect to another species. Whenever an agent is created or destroyed from the other species, an instance of the mirror species is created or destroyed. Each of these ‘mirror agents’ has access to its reference agent (called its target).Mirror species can be used in different situations but the one we describe here is more oriented towards visualization purposes.Index  Declaration  ExampleDeclarationA mirror species can be defined using the mirrors keyword as following:species B mirrors: A{}In this case the species B mirrors the species A.By default the location of the species B will be random but in many cases, once want to place the mirror agent at the same location of the reference species. This can be achieve by simply adding the following lines in the mirror species :species B mirrors: A{    point location &lt;- target.location update: target.location;}target is a built-in attribute of a mirror species. It refers to the instance of the species tracked.In the same spirit any attribute of a reference species can be reach using the same syntax. For instance if the species A has an attribute called attribute1 of type int is is possible to get this attribute from the mirror species B using the following syntax:int value &lt;- target.attribute1;ExampleTo practice a bit with the mirror notion, we will now build a simple model displaying a species A (aspect: white circle) moving randomly, and another species B (aspect: blue sphere) with the species A location on x and y, with an upper value for the z axis.Here is an example of implementation for this model:model Mirrorglobal {  init{    create A number:100;      }}species A skills:[moving]{    reflex update{        do wander;    }    aspect base{        draw circle(1) color: #white;    }}species B mirrors: A{    point location &lt;- target.location update: point(target.location.x,target.location.y,target.location.z+5);    aspect base {        draw sphere(2) color: #blue;    }}experiment mirroExp type: gui {    output {        display superposedView type: opengl{           species A aspect: base;          species B aspect: base transparency:0.5;        }    }}",
        "url":"/wiki/MirrorSpecies.html"
      }
      ,
    
      "wiki-modelbuiltin-html": {
        "title": "The 'model' built-in species (Under Construction)",
        "content": "The ‘model’ built-in species (Under Construction)As described in the presentation of GAML, any model in GAMA is a species (introduced by the keyword global) which directly inherits from an abstract species called model. This abstract species (sub-species of agent) defines several attributes and actions that can then be used in any global section of any model.model attributesmodel defines several attributes, which, in addition to the attributes inherited from agent, form the minimal set of knowledge a model can manipulate.  model actions",
        "url":"/wiki/ModelBuiltIn.html"
      }
      ,
    
      "wiki-modellibrary-html": {
        "title": "Models Library",
        "content": "Models LibraryHere is the list of models accessible when you download GAMA. Do not hesitate to consult those models to have an idea of the possibilities of the platform.Models are divided within 5 categories :  Features : very short models designed to present the differents features of the platform.  Syntax : some gaml files in order to show you the syntax to use for basic things (casting, containers manipulation…).  Toy Models : some pre-made models designed to answer to concrete problematics.  Tutorials : models build in the tutorial section.  Additionnal Plugins : models using particular additionnal plugins.",
        "url":"/wiki/ModelLibrary.html"
      }
      ,
    
      "wiki-modelorganization-html": {
        "title": "Organization of a model",
        "content": "Organization of a modelAs already extensively detailed in the introduction page, defining a model in GAML amounts to defining a model species, which later allows to instantiate a model agent (aka a simulation), which may or may not contain micro-species, and which can be flanked by experiment plans in order to be simulated.This conceptual structure is respected in the definition of model files, which follows a similar pattern:  Definition of the global species, preceded by a header, in order to represent the model species  Definition of the different micro-species (either nested inside the global species or at the same level)  Definition of the different experiment plans that target this modelTable of contents  Model Header (model species)  Species declarations  Experiment declarations  Basic skeleton of a modelModel Header (model species)The header of a model file begins with the declaration of the name of the model. Contrarily to other statements, this declaration does not end with a semi-colon.model name_of_the_modelThe name of the model is not necessarily the same as the name of the file. It must conform to the general rule for naming species, i.e. be a valid identifier (beginning with a letter, containing only letters, digits and dashes). This name will be used for building the name of the model species, from which simulations will be instantiated. For instance, the following declaration:model dummywill internally create a species called dummy_model, child of the abstract species model, from which simulations (called dummy_model0, dummy_model1, etc.) will be instantiated.This declaration is followed by optional import statements that indicate which other models this model is importing. Import statements do not end with a semi-colon.Importing a model can take two forms. The first one, called inheritance import, is declared as follows:import \"relative_path_to_a_model_file\"import \"relative_path_to_another_model_file\"The second one, called usage import, is declared as follows:import \"relative_path_to_a_model_file\" as model_identifierWhen importing models using the first form, all the declarations of the model(s) imported will be merged with those of the current model (in the order with which the import statements are declared, i.e. the latest definitions of global attributes or behaviors superseding the previous ones).The second form is reserved for using models as micro-models of the current model. This possibility is still experimental in the current version of GAMA.The last part of the header is the definition of the global species, which is the actual definition of the model species itself.global {    // Definition of [global attributes](GlobalSpecies#declaration), [actions and behaviors](DefiningActionsAndBehaviors)}Note that neither the imports nor the definition of global are mandatory. Only the model statement is.Species declarationsThe header is followed by the declaration of the different species of agents that populate the model.The special species global is the world species. You will declare here all the global attributes/actions/behaviors. The global species does not have name, and is unique in your model.global {    // definition of global attributes, actions, behaviors}Regular species can be declared with the keyword species. You can declare several regular species, and they all have to be named.species nameOfSpecies {\t// definition of your [species attributes](RegularSpecies#declaration), [actions and behaviors](DefiningActionsAndBehaviors)}Note that the possibility to define the species after the global definition is actually a convenience: these species are micro-species of the model species and, hence, could be perfectly defined as nested species of global. For instance:global {    // definition of global attributes, actions, behaviors}species A {...}species B {...}is completely equivalent to:global {    // definition of [global attributes](GlobalSpecies#declaration), actions, behaviors    species A {...}    species B {...}}Experiment declarationsExperiments are usually declared at the end of the file. They start with the keyword experiment. They contains the simulation parameters, and the definition of the output (such as displays, monitors or inspectors). You can declare as much experiments as you want.experiment first_experiment {    // definition of parameters (intputs)    // definition of output    output {...}}experiment second_experiment {    // definition of parameters (inputs)    // definition of output}Note that you have two types of experiments:A GUI experiment allows to display a graphical interface with input parameters and outputs. It is declared with the following structure :experiment gui_experiment type:gui {\t[...]}A Batch experiment allows to execute numerous successive simulation runs (often used for model exploration). It is declared with the following structure :experiment batch_experiment type:batch {\t[...]}Basic skeleton of a modelHere is the basic skeleton of a model :model name_of_the_modelglobal {\t// definition of [global attributes](GlobalSpecies#declaration), actions, behaviours}species my_specie {\t// definition of attributes, actions, behaviours}experiment my_experiment /* + specify the type : \"type:gui\" or \"type:batch\" */{\t// here the definition of your experiment, with...\t// ... your inputs\toutput {\t\t// ... and your outputs\t}}Don’t forget this structure ! This will be the basis for all the models you will create from now.            //: # (endConcept      model_structure)      ",
        "url":"/wiki/ModelOrganization.html"
      }
      ,
    
      "wiki-multi-level-usage-balls-groups-and-clouds-html": {
        "title": "Balls, Groups and Clouds Multilevel Architecture",
        "content": "Balls, Groups and Clouds Multilevel Architecture_Author : _This model shows how to use multi-level architecture to group agents, and regroup groups. The operators capture is used to capture an agent by a group and change its species as a species contained by the group and defined in the group species section. The operator release is used to release contained agents and change them into an other species. The experiment shows ball moving randomly, and following other balls. When they are close to each other, they generate a group of balls with its own behavior. A group of group agents generate a cloud in the same way. When the number of balls contained inside the group is too high, the group disappears and releases all its balls repulsively.Code of the model :model balls_groups_cloudsglobal { \t// Parameters\tbool create_group &lt;- true; \tbool create_cloud &lt;- false; \t\t// Environment\tpoint environment_bounds &lt;- {500, 500}; \tgeometry shape &lt;- rectangle(environment_bounds) ;\t\t\t\t//Define a inner environment smaller inside the environment\tint inner_bounds_x &lt;- (int((environment_bounds.x) / 20))  ;\tint inner_bounds_y &lt;- (int((environment_bounds.y) / 20))  ;\tint xmin &lt;- inner_bounds_x ;\tint ymin &lt;- inner_bounds_y ;       \tint xmax &lt;- int((environment_bounds.x) - inner_bounds_x) ;\tint ymax &lt;- int((environment_bounds.y) - inner_bounds_y) ;\t\tfloat MAX_DISTANCE &lt;- environment_bounds.x + environment_bounds.y  ;\t\t//Global variables for ball agents\trgb ball_color &lt;- #green; \trgb chaos_ball_color &lt;- #red;\tfloat ball_size &lt;- float(3);  \tfloat ball_speed &lt;- float(1);\tfloat chaos_ball_speed &lt;- 8 * ball_speed;  \tint ball_number &lt;- 200 min: 2 max: 1000;  \tgeometry ball_shape &lt;- circle (ball_size) ;\tfloat ball_separation &lt;- 6 * ball_size; \t\t//Global variables for group agents\tint group_creation_distance &lt;- int(ball_separation + 1);\tint min_group_member &lt;- 3;\tint group_base_speed &lt;- (int(ball_speed * 1.5));\tint base_perception_range &lt;- int (environment_bounds.x / 100) min: 1 ;  \tint creation_frequency &lt;- 3;\tint update_frequency &lt;- 3;\tint merge_frequency &lt;- 3;\tfloat merge_possibility &lt;- 0.3;\t\t//Global variables for Clouds Agents\tint cloud_creation_distance &lt;- 30 const: true;\tint min_cloud_member &lt;- 3 const: true;\tint cloud_speed &lt;- 3 const: true;\tint cloud_perception_range &lt;- base_perception_range const: true ; \t\tinit {\t\tcreate ball number: ball_number ;\t\tcreate group_agents_viewer;\t\tcreate cloud_agents_viewer;\t}\t\t//The simulation will try to create group at each frequence cycle\treflex create_groups when: ( create_group and ((cycle mod creation_frequency) = 0) ) {\t\t//create a list from all balls following the nearest ball\t\tlist&lt;ball&gt; free_balls &lt;- ball where ((each.state) = 'follow_nearest_ball') ;\t\tif (length (free_balls) &gt; 1) {\t\t\t//Clustering of the balls according to their distance with at least a minimal number of balls in a group\t\t\tlist&lt;list&lt;ball&gt;&gt; satisfying_ball_groups &lt;- (free_balls simple_clustering_by_distance group_creation_distance) where ( (length (each)) &gt; min_group_member ) ;\t\t\t\t\t\t\t\t\tloop one_group over: satisfying_ball_groups {\t\t\t\tcreate group returns: new_groups;\t\t\t\t\t\t\t\t//Capture by the new groups created of the different balls present in the list one_group\t\t\t\task (new_groups at 0) as: group {\t\t\t\t\tcapture one_group as: ball_in_group; \t\t\t\t}\t\t\t}\t\t}\t}\t\t//The simulation will try to create clouds at each frequence cycle\treflex create_clouds when: (create_cloud and ((cycle mod creation_frequency) = 0) ) {\t\t//A cloud can be created only using group with a number of balls inside greater than 5% of the total ball number\t\tlist&lt;group&gt; candidate_groups &lt;- group where (length(each.members) &gt; (0.05 * ball_number) );\t\t\t\t//A cloud can be created also only using group which aren't too far away \t\tlist&lt;list&lt;group&gt;&gt; satisfying_groups &lt;- (candidate_groups simple_clustering_by_distance cloud_creation_distance) where (length(each) &gt;= min_cloud_member);\t\t\t\t//Creation of the different clouds using the groups satisfying both conditions\t\tloop one_group over: satisfying_groups {\t\t\tcreate cloud returns: rets;\t\t\t\t\t\tcloud newCloud &lt;- rets at 0; \t\t\task newCloud as: cloud {\t\t\t\tcapture one_group as: group_delegation;\t\t\t}\t\t\tloop gd over: (newCloud.members) {\t\t\t\task gd as group_delegation {\t\t\t\t\tmigrate ball_in_group target: ball_in_cloud;\t\t\t\t}\t\t\t} \t\t\t\t\t\tnewCloud.color &lt;- ((group_delegation(one_of(newCloud.members))).color).darker;\t\t}\t}}\t//Base species with just the skills moving and all built-in variables and operators derivated from it\tspecies base skills: [moving] ;\t\t//Species with a specified type of control architecture, here the final state machine FSM\tspecies ball parent: base control: fsm  { \t\t\t\tfloat speed &lt;- ball_speed; \t\trgb color &lt;- ball_color;\t\tint beginning_chaos_time; \t\tint time_in_chaos_state;\t\t\t\t//create the ball in a certain way to not make balls intersect each other\t\tinit {\t\t\tbool continue_loop &lt;- true ; \t\t\tloop while: continue_loop {\t\t\t\tpoint tmp_location &lt;- {(rnd (xmax - xmin)) + xmin, (rnd (ymax - ymin)) + ymin} ;\t\t\t\tgeometry potential_geom &lt;- ball_shape at_location tmp_location ; \t\t\t\t\t\t\t\tif ( empty ( ball where  ( each intersects potential_geom ) ) )  {\t\t\t\t\tlocation &lt;- tmp_location ;\t\t\t\t\tcontinue_loop &lt;- false ;\t\t\t\t}\t\t\t}\t\t}\t\t\t\t//Action used to separate the balls and make them repulsive for the other balls of the group\t\taction separation (list&lt;ball&gt; nearby_balls) {\t\t\tfloat repulsive_dx &lt;- 0.0 ;\t\t\tfloat repulsive_dy &lt;- 0.0 ;\t\t\tloop nb over: nearby_balls { \t\t\t\tfloat repulsive_distance &lt;- ball_separation - ( location distance_to ( nb).location ) ;\t\t\t\tint repulsive_direction &lt;- ((nb).location) towards (location) ;\t\t\t\trepulsive_dx &lt;- repulsive_dx + (repulsive_distance * (cos (repulsive_direction))) ;\t\t\t\trepulsive_dy &lt;- repulsive_dy + (repulsive_distance * (sin (repulsive_direction))) ;\t\t\t}\t\t\tlocation &lt;- location + {repulsive_dx, repulsive_dy} ;\t\t}\t\t\t\tbool in_bounds (point a_point) {\t\t\treturn ( !(a_point.x &lt; xmin) and !(a_point.x &gt; xmax) and !(a_point.y &lt; ymin) and !(a_point.y &gt; ymax) ) ;\t\t}\t\t \t\t//State that will make the agent follows the closest ball if it is not in the chaos state anymore\t\tstate follow_nearest_ball initial: true {\t\t\tenter {   \t\t\t\tcolor &lt;- ball_color ;\t\t\t\tspeed &lt;- ball_speed ;\t\t\t}\t\t\tlist&lt;ball&gt; free_balls &lt;- (list (ball) - self) where ((each.state) = 'follow_nearest_ball') ;\t\t\tball nearest_free_ball &lt;- free_balls closest_to self;\t\t\tif nearest_free_ball != nil {\t\t\t\theading &lt;- self towards (nearest_free_ball) ; \t\t\t\tfloat step_distance &lt;- speed * step ;\t\t\t\tfloat step_x &lt;- step_distance * (cos (heading)) ;\t\t\t\tfloat step_y &lt;- step_distance * (sin (heading)) ; \t\t\t\tpoint tmp_location &lt;- location + {step_x, step_y} ;\t\t\t\tif (self in_bounds (tmp_location) ) {\t\t\t\t\tlocation &lt;- tmp_location ;\t\t\t\t\tdo separation (((ball overlapping (shape + ball_separation)) - self));\t\t\t\t}\t\t\t}\t\t}\t\t\t\t//Make the ball move randomly during a certain time\t\tstate chaos {\t\t\tenter {\t\t\t\tbeginning_chaos_time &lt;- int(time) ;\t\t\t\ttime_in_chaos_state &lt;- 10 + (rnd(10)) ;\t\t\t\tcolor &lt;- chaos_ball_color ;\t\t\t\tspeed &lt;- chaos_ball_speed ;\t\t\t\theading &lt;- rnd(359) ;\t\t\t}\t\t\t\t\t\tfloat step_distance &lt;- speed * step ;\t\t\tfloat step_x &lt;- step_distance * (cos (heading)) ;\t\t\tfloat step_y &lt;- step_distance * (sin (heading)) ;\t\t\tpoint tmp_location &lt;- location + {step_x, step_y} ;\t\t\tif (self in_bounds (tmp_location)) {\t\t\t\tlocation &lt;- tmp_location ;\t\t\t\tdo separation (nearby_balls: (ball overlapping (shape + ball_separation)) - self);\t\t\t}\t\t\t\t\t\ttransition to: follow_nearest_ball when: time &gt; (beginning_chaos_time + time_in_chaos_state) ;\t\t}\t\t\t\taspect default {\t\t\tdraw ball_shape color: color size: ball_size at:self.location;\t\t}\t}\t\t//Species representing the group of balls\tspecies group parent: base { \t\t\t\trgb color &lt;- rgb ([ rnd(255), rnd(255), rnd(255) ]) ;\t\tgeometry shape &lt;- polygon (ball_in_group) buffer  10 ;\t\tfloat speed update: float(group_base_speed) ;\t\t\t\t//Parameter to capture the balls contains in the perception range\t\tfloat perception_range update: float(base_perception_range + (rnd(5))) ;\t\t\t\tball nearest_free_ball update: ( ball where ( (each.state = 'follow_nearest_ball') ) ) closest_to self ;\t\tgroup nearest_smaller_group update: ( ( (group as list) - self ) where ( (length (each.members)) &lt; (length (members)) ) ) closest_to self ;\t\tbase target update: (self get_nearer_target []) depends_on: [nearest_free_ball, nearest_smaller_group] ;\t\t \t\t//Function to return the closest ball or small group of balls that the agent could capture\t\tbase get_nearer_target {\t\t\tif  (nearest_free_ball = nil) and (nearest_smaller_group = nil) {\t\t\t\treturn nil ;\t\t\t}\t\t\t\t\t\tfloat distance_to_ball &lt;- (nearest_free_ball != nil) ? (self distance_to nearest_free_ball) : MAX_DISTANCE ;\t\t\tfloat distance_to_group &lt;- (nearest_smaller_group != nil) ? (self distance_to nearest_smaller_group) : MAX_DISTANCE ;\t\t\tif (distance_to_ball &lt; distance_to_group) {\t\t\t\treturn nearest_free_ball ;\t\t\t}\t\t\t \t\t\treturn nearest_smaller_group ;\t\t}\t\t\t\t//Action to use when the group of balls explode\t\taction separate_components {\t\t\tloop com over: (list (ball_in_group)) {\t\t\t\tlist&lt;ball_in_group&gt; nearby_balls &lt;-  ((ball_in_group overlapping (com.shape + ball_separation)) - com) where (each in members) ;\t\t\t\tfloat repulsive_dx &lt;- 0.0 ;\t\t\t\tfloat repulsive_dy &lt;- 0.0 ;\t\t\t\tloop nb over: nearby_balls { \t\t\t\t\tfloat repulsive_distance &lt;- ball_separation - ( (ball_in_group (com)).location distance_to nb.location ) ;\t\t\t\t\tint repulsive_direction &lt;- (nb.location) direction_to ((ball_in_group (com)).location) ;\t\t\t\t\trepulsive_dx &lt;- repulsive_dx + (repulsive_distance * (cos (repulsive_direction))) ;\t\t\t\t\trepulsive_dy &lt;- repulsive_dy + (repulsive_distance * (sin (repulsive_direction))) ;\t\t\t\t}\t\t\t\t\t\t\t\t(ball_in_group (com)).location &lt;- (ball_in_group (com)).location + {repulsive_dx, repulsive_dy} ;\t\t\t}\t\t}\t\t\t\t//Species that will represent the balls captured by the group agent\t\tspecies ball_in_group parent: ball topology: topology((world).shape)  {\t\t\t\t\t\tfloat my_age &lt;- 1.0 update: my_age + 0.01;\t\t\t \t\t\tstate follow_nearest_ball initial: true { }\t\t\t\t\t\tstate chaos { }\t\t\t\t\t\taspect default {\t\t\t\tdraw circle(my_age) color: ((host as group).color).darker ;\t\t\t}\t\t}\t\t\t\t//Reflex to capture all the balls close to the group agent\t\treflex capture_nearby_free_balls when: (cycle mod update_frequency) = 0 {\t\t\tlist&lt;ball&gt; nearby_free_balls &lt;- (ball overlapping (shape + perception_range)) where (each.state = 'follow_nearest_ball');\t\t\tif !(empty (nearby_free_balls)) {\t\t\t\tcapture nearby_free_balls as: ball_in_group;\t\t\t}\t\t}\t\t\t\t//Action to do when the group is disaggregated\t\taction disaggregate {\t\t\trelease members as: ball in: world {\t\t\t\t state &lt;- 'chaos' ;\t\t\t}\t\t\t\t\t\tdo die ;\t\t}\t\t\t\t//Reflex to merge the group close to the agent when the cycle is in the frequency of merging\t\treflex merge_nearby_groups when: (cycle mod merge_frequency) = 0 {\t\t\tif ( (target != nil) and ((species_of (target)) = group) ) {\t\t\t\tlist&lt;group&gt; nearby_groups &lt;- (group overlapping (shape + perception_range)) - self ;\t\t\t\t\t\t\t\tif target in nearby_groups {\t\t\t\t\tif (rnd(10)) &lt; (merge_possibility * 10) {\t\t\t\t\t\tlist&lt;ball_in_group&gt; target_coms &lt;- list&lt;ball_in_group&gt;(target.members) ;\t\t\t\t\t\tlist&lt;ball&gt; released_balls ;\t\t\t\t\t\task target {\t\t\t\t\t\t\trelease target_coms as: ball in: world returns: released_coms;\t\t\t\t\t\t\treleased_balls &lt;- list(released_coms);\t\t\t\t\t\t\tdo die ;\t\t\t\t\t\t}\t\t\t\t\t\tcapture released_balls as: ball_in_group; \t\t\t\t\t}\t\t\t\telse { ask target as group {do disaggregate ;} }\t\t\t\t}\t\t\t}\t\t}\t\t\t\t//Reflex to chase a target agent \t\treflex chase_target when: (target != nil) {\t\t\tint direction_to_nearest_ball &lt;- (self towards (target)) ;\t\t\tfloat step_distance &lt;- speed * step ;\t\t\tfloat dx &lt;- step_distance * (cos (direction_to_nearest_ball)) ;\t\t\tfloat dy &lt;- step_distance * (sin (direction_to_nearest_ball)) ;\t\t\tgeometry envelope &lt;- shape.envelope ;\t\t\tpoint topleft_point &lt;- (envelope.points) at 0 ;\t\t\tpoint bottomright_point &lt;- (envelope.points) at 0 ;\t\t\t\t\t\tloop p over: envelope.points {\t\t\t\tif ( (p.x &lt;= topleft_point.x) and (p.y &lt;= topleft_point.y) ) {\t\t\t\t\ttopleft_point &lt;- p ;\t\t\t\t}\t\t\t\t\t\t\t\tif ( (p.x &gt;= bottomright_point.x) and (p.y &gt;= bottomright_point.y) ) {\t\t\t\t\tbottomright_point &lt;- p ;\t\t\t\t}\t\t\t}\t\t\t\t\t\tif ( (dx + topleft_point.x) &lt; 0 ) {\t\t\t\tfloat tmp_dx &lt;- dx + topleft_point.x ;\t\t\t\tdx &lt;- dx - tmp_dx ;\t\t\t} else {\t\t\t\tif (dx + bottomright_point.x) &gt; (environment_bounds.x) {\t\t\t\t\tfloat tmp_dx &lt;- (dx + bottomright_point.x) - environment_bounds.x ;\t\t\t\t\tdx &lt;- dx - tmp_dx ;\t\t\t\t}\t\t\t}\t\t\t\t\t\tif (dy + topleft_point.y) &lt; 0 {\t\t\t\tfloat tmp_dy &lt;- dy + topleft_point.y ;\t\t\t\tdy &lt;- dy - tmp_dy ;\t\t\t} else {\t\t\t\tif (dy + topleft_point.y) &gt; (environment_bounds.y) {\t\t\t\t\tfloat tmp_dy &lt;- (dy + bottomright_point.y) - (environment_bounds.y) ;\t\t\t\t\tdy &lt;- dy - tmp_dy ;\t\t\t\t}\t\t\t}\t\t\t\t\t\tloop com over: (list (ball_in_group)) {\t\t\t\t(ball_in_group (com)).location &lt;- (ball_in_group (com)).location + {dx, dy} ;\t\t\t}\t\t\t\t\t\tshape &lt;- convex_hull((polygon ((list (ball_in_group)) collect (ball_in_group (each)).location)) + 2.0) ;\t\t}\t\t//Reflex to disaggregate the group if it is too important ie the number of balls is greater than 80% of the total ball number\t\treflex self_disaggregate {\t\t\tif ( ( length (members) ) &gt; ( 0.8 * (ball_number) ) ) {\t\t\t\tdo disaggregate ;\t\t\t}\t\t}\t\t\t\taspect default {\t\t\tdraw shape color: color;\t\t}\t}\t\t//Species cloud that will be created by an agglomeration of groups.\tspecies cloud parent: base {\t\tgeometry shape &lt;- convex_hull(polygon(members collect (((group_delegation(each)).shape).location))) update: convex_hull(polygon(members collect (((group_delegation(each)).shape).location)));\t\trgb color;\t\t\t\t//Species contained in the cloud to represent the groups captured by the cloud agent\t\tspecies group_delegation parent: group topology: (topology(world.shape)) {\t\t\tgeometry shape &lt;- convex_hull( (polygon ( (list (ball_in_cloud)) collect (each.location) )) ) buffer 10 update: convex_hull( (polygon ( (list (ball_in_cloud)) collect (each.location) )) ) buffer  10 ;\t\t\treflex capture_nearby_free_balls when: false {\t\t\t}\t\t\t\t\t\treflex merge_nearby_groups when: false {\t\t\t}\t\t\t\t\t\treflex chase_target when: false {\t\t\t}\t\t\t\t\t\treflex self_disaggregate {\t\t\t}\t\t\t\t\t\taction move2 (float with_heading, float with_speed) {\t\t\t\tloop m over: members {\t\t\t\t\task m as ball_in_cloud {\t\t\t\t\t\tdo move2 (with_heading,with_speed);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\t \t\t\tspecies ball_in_cloud parent: ball_in_group topology: (world.shape) as topology control: fsm {\t\t\t\t\t\t\t\taction move2 (float with_heading, float with_speed) {\t\t\t\t\tfloat dx &lt;- cos(with_heading) * with_speed;\t\t\t\t\tfloat dy &lt;- sin(with_heading) * with_speed;\t\t\t\t\tlocation &lt;- { ( (location.x) + dx ), ( (location.y) + dy )};\t\t\t\t}\t\t\t\t\t\t\t\taspect default {}\t\t\t\t\t\t\t}\t\t}\t\t\t\tgroup target_group;\t\t\t//The cloud try to look for small groups to capture them\t\treflex chase_group {\t\t\tif ( (target_group = nil) or (dead(target_group)) ) {\t\t\t\ttarget_group &lt;- one_of(group);\t\t\t}\t\t\t\t\t\tif (target_group != nil) {\t\t\t\tint direction_target &lt;- self towards(target_group);\t\t\t\t\t\t\t\tloop m over: members {\t\t\t\t\task m as group_delegation {\t\t\t\t\t\tdo move2 with: [ with_heading :: float(direction_target), with_speed :: float(cloud_speed) ];\t\t\t\t\t}\t\t\t\t\t\t\t\t}\t\t\t}\t\t}\t\t\t\t//Operator to know if a cloud can capture a group overlapping the cloud agent. \t\tbool can_capture (group a_group) {\t\t\t\t\t\tif (shape overlaps a_group.shape) { return true; }\t\t\t\t\t\tloop gd over: members {\t\t\t\tif ( (a_group.shape) overlaps ( ( group_delegation(gd)).shape ) ) { return true; }\t\t\t}\t\t\t\t\t\treturn false;\t\t}\t\t\t\t//Reflex to capture group\t\treflex capture_group {\t\t\tif ( (target_group != nil) and !(dead(target_group)) ) {\t\t\t\tif (self can_capture [ a_group :: target_group]) {\t\t\t\t\tcapture target_group as: group_delegation returns: gds;\t\t\t\t\t\task (gds at 0) as: group_delegation {\t\t\t\t\t\tmigrate ball_in_group target: ball_in_cloud;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t\t\t\t//Reflex to disaggregate the clouds when they are no more group to capture\t\treflex disaggregate when: (empty(list(group))) {\t\t\tloop m over: members {\t\t\t\task group_delegation(m) as: group_delegation {\t\t\t\t\tmigrate ball_in_cloud target: ball_in_group;\t\t\t\t}\t\t\t}\t\t\t\t\t\trelease members as: group in: world returns: r_groups;\t\t\t\t\t\tloop rg over: r_groups {\t\t\t\task rg as: group { do disaggregate; }\t\t\t}\t\t\t\t\t\tdo die; \t\t}\t \t \t\taspect default {\t\t\tdraw shape color: color empty: true;\t\t\tdraw (name + ' with ' + (string(length(members))) + ' groups.') size: 15 color: color  at: {location.x - 65, location.y};\t\t}\t}\t\tspecies group_agents_viewer  { \t\taspect default {\t\t\tdraw ('Number of groups: ' + (string (length (world.agents of_generic_species group)))) at: {(environment_bounds.x)/2 - 210, (environment_bounds.y)/2} color: #blue size: 40  ;\t\t}\t}\tspecies cloud_agents_viewer  { \t\taspect default {\t\t\tdraw ('Number of clouds: ' + (string (length (list(cloud))))) at: {(environment_bounds.x)/2 - 210, (environment_bounds.y)/2} color: #green size: 40 ;\t\t}\t} experiment group_experiment type: gui {\tparameter 'Create groups?' var: create_group &lt;- true;\tparameter 'Create clouds?' var: create_cloud &lt;- false;\t\t\toutput {\t\tdisplay 'Standard display' {\t\t\tspecies ball aspect: default transparency: 0.5 ;\t\t\t\t\t\tspecies group aspect: default transparency: 0.5 {\t\t\t\tspecies ball_in_group;\t\t\t}\t\t}\t\t\t\tdisplay 'Ball display' {\t\t\tspecies ball;\t\t}\t\t\t\tdisplay 'Group display' {\t\t\tspecies group;\t\t\tspecies group_agents_viewer;\t\t}\t}}experiment cloud_experiment type: gui {\tparameter 'Create groups?' var: create_group &lt;- true;\tparameter 'Create clouds?' var: create_cloud &lt;- true;\t\t\toutput {\t\tdisplay 'Standard display' {\t\t\tspecies ball aspect: default transparency: 0.5 ;\t\t\t\t\t\tspecies group aspect: default transparency: 0.5 {\t\t\t\tspecies ball_in_group;\t\t\t}\t\t\t\t\t\tspecies cloud aspect: default {\t\t\t\tspecies group_delegation transparency: 0.9 {\t\t\t\t\tspecies ball_in_cloud;\t\t\t\t\tspecies ball_in_group;\t\t\t\t}\t\t\t}\t\t}\t\t\t\tdisplay 'Ball display' {\t\t\tspecies ball;\t\t}\t\t\t\tdisplay 'Group display' {\t\t\tspecies group;\t\t\tspecies group_agents_viewer;\t\t}\t\tdisplay 'Cloud display' {\t\t\tspecies cloud;\t\t}\t\t\t\tmonitor \"Balls\" value: length(ball);\t\tmonitor \"Groups\" value: length(group);\t\tmonitor \"Clouds\" value: length(cloud);\t}}",
        "url":"/wiki/Multi-Level-Usage-Balls,-Groups-and-Clouds.html"
      }
      ,
    
      "wiki-multi-level-usage-corridor-hybrid-vs-abm-html": {
        "title": "Corridor Multi-Level Architecture with Mathematics Model and Agent Based Model",
        "content": "Corridor Multi-Level Architecture with Mathematics Model and Agent Based Model_Author : _This model shows how to use multi-level architecture. Two corridors are presented : one which can capture the pedestrians going through it and computing for them the time before releasing them at the end of the corridor, and an other doing nothing, letting the pedestrians moving by themselves in the corridor.Code of the model :model pedestrian_corridor_Hybrid_vs_ABMglobal {\t\t//Parameters of the environment\tint environment_width &lt;- 200 const: true;\tint environment_height &lt;- 200 const: true;\tgeometry shape &lt;- rectangle(environment_width, environment_height);\t\t\t\t//Parameters of the pedestrian agents\trgb pedestrian_green &lt;- #green;\t\tfloat pedestrian_size &lt;- 1.0;\tgeometry pedestrian_shape &lt;- circle (pedestrian_size) ;\tfloat pedestrian_speed &lt;- 2.0;  \t//Parameters of the corridors\trgb corridor_color &lt;- rgb ('blue');\tint corridor_width &lt;- 160 depends_on: [environment_width];\tint corridor_height &lt;- (int(environment_height * 0.05));\tpoint corridor_location_0 &lt;- {environment_width / 2, environment_height / 4};\tgeometry corridor_shape_0 &lt;- ( (rectangle ({corridor_width, corridor_height})) at_location corridor_location_0) ;\tpoint corridor_location_1 &lt;- {environment_width / 2, environment_height * 0.75};\tgeometry corridor_shape_1 &lt;- ( (rectangle ({corridor_width, corridor_height})) at_location corridor_location_1) ;\t//Parameters of pedestrian generation\tint new_pedestian_generate_frequency &lt;- 8;\tpoint pedestrian_source_0 &lt;- {0, corridor_location_0.y} ;\tpoint pedestrian_source_1 &lt;- {0, corridor_location_1.y} ;\t \t \t \tinit \t{\t\tcreate corridor number: 2 returns: new_corridors;\t\t\t\task (new_corridors at 0) \t\t{\t\t\tdo init_corridor corridor_shape: corridor_shape_0 is_hybrid: false;\t\t}\t\task (new_corridors at 1) \t\t{\t\t\tdo init_corridor corridor_shape: corridor_shape_1 is_hybrid: true; \t\t}\t}\t//Generation of pedestrians according to the frequency of generation : one for each corridor\treflex generate_pedestrians when: ( (cycle mod new_pedestian_generate_frequency) = 0 ) \t{ \t\tcreate pedestrian number: 2 returns: new_pedestrians;\t\t\t\task (new_pedestrians at 0) \t\t{\t\t\tdo init_location loc: pedestrian_source_0;\t\t}\t\t\t\task (new_pedestrians at 1) \t\t{\t\t\tdo init_location loc: pedestrian_source_1;\t\t}\t}\t}//Species for the pedestrians which can movespecies pedestrian skills: [moving] {\tgeometry shape &lt;- circle(pedestrian_size);\trgb color;\tcorridor last_corridor;\tpoint target_location;\tfloat speed &lt;- pedestrian_speed;\t\t//Initialisation of the target location according to its generation location\taction init_location (point loc) {\t\tlocation &lt;- loc;\t\ttarget_location &lt;- {environment_width, location.y};\t\theading &lt;- self towards (target_location);\t}\t//Reflex to move the agent to its target location and make it die once it reached its target\treflex move_left \t{\t\tdo move heading: (self) towards (target_location); \t\t\t\tif ( (target_location.x - location.x) &lt;= speed ) \t\t{\t\t\tdo die;\t\t}\t}\t \taspect default \t{\t\tdraw shape color: color;\t}}//Species for the corridor which can capture pedestriansspecies corridor  {\tbool capture_pedestrians;\t\t\taction init_corridor (geometry corridor_shape, bool is_hybrid) \t{\t\tshape &lt;- corridor_shape;\t\tcapture_pedestrians &lt;- is_hybrid;\t}\tfloat max_speed &lt;- pedestrian_speed;\tfloat macro_length min: 0.0 &lt;- float(corridor_width); // the length of macro_patch\t\t//Species to model the pedestrian captured by the corridor\tspecies captured_pedestrian parent: pedestrian schedules: [] \t{\t\tfloat released_time;  \t\t\t\taspect default { }\t}\t\tinit \t{ \t\tcreate corridor_info_drawer number: 1 with: [target :: self];\t}\t//Reflex to capture the pedestrians overlapping the corridor ie entering the corridor \treflex aggregate when: capture_pedestrians \t{\t\tlist&lt;pedestrian&gt; tobe_captured_pedestrians &lt;- (pedestrian overlapping shape) where ( (each.last_corridor != self) and ((each.location).x &lt; (self.location).x) ) ; \t\t\t\tif !(empty (tobe_captured_pedestrians)) \t\t{\t\t\tcapture tobe_captured_pedestrians as: captured_pedestrian returns: cps { \t\t\t\tlast_corridor &lt;- myself;\t\t\t}\t\t\tif !(empty (cps)) \t\t\t{\t\t\t\t\t//Computation of the time when the pedestrians captured will be released according to the speed\t\t\t\t\t// and the time they should make to pass the corridor if they move by themselves\t\t\t\t\tfloat group_outgoing_time &lt;- time + (corridor_width / (pedestrian_speed) ); \t\t\t\t\tloop cp over: cps \t\t\t\t\t{\t\t\t\t\t\t\tcp.released_time &lt;- group_outgoing_time;\t \t\t\t\t}\t\t\t}\t\t\t\t}\t}\t\t//Reflex to release the pedestrians when we consider they were enough time inside the corridor \treflex disaggregate  \t{\t\tlist tobe_released_pedestrians &lt;- members where (time &gt;= (captured_pedestrian (each)).released_time);\t\t\t\tif !(empty (tobe_released_pedestrians)) \t\t{\t\t\t\t\t\trelease tobe_released_pedestrians as: pedestrian in: world returns: released_pedestrians;\t\t\t\t\t\tloop rp over: released_pedestrians \t\t\t{\t\t\t\trp.speed &lt;- pedestrian_speed;\t\t\t\trp.location &lt;- {((environment_width / 2) + (corridor_width / 2)), ((corridor_shape_1).location).y};\t\t\t}\t\t}\t}\t\t\taspect default \t{\t\tdraw shape color: corridor_color;\t}} species corridor_info_drawer {\tcorridor target;\t\taspect base \t{\t\tif target.capture_pedestrians \t\t{\t\t\tdraw 'Hybrid model (coupling: ABM and Mathematical Model)' color: #blue size: 7 at: {(target.location).x - 90, (target.location).y - 10};\t\t\tdraw  'Aggregated agents: ' + string(length(target.members)) color: #black size: 7 at: {(target.location).x - 30, (target.location).y + 2};\t\t} \t\telse \t\t{\t\t\tdraw 'Agent-Based Model (ABM)' color: #blue size: 7 at: {(target.location).x - 40, (target.location).y - 10};\t\t}\t}}experiment default_experiment type: gui {\toutput \t{\t\tdisplay default_display \t\t{\t\t\tspecies pedestrian;\t\t\tspecies corridor transparency: 0.8;\t\t\tspecies corridor_info_drawer aspect: base;\t\t}\t}}",
        "url":"/wiki/Multi-Level-Usage-Corridor-(Hybrid-vs-ABM).html"
      }
      ,
    
      "wiki-multi-level-usage-corridor-html": {
        "title": "Corridor Multi-Level Architecture",
        "content": "Corridor Multi-Level Architecture_Author : _This model shows how to use multi-level architecture. A corridor can capture pedestrians going from left to right side if they are inside the corridor. This will result in changing their species from pedestrian to captured_pedestrian which will not be displayed. Once they pass enought time to consider they reach the exit of the corridor, they will be released by the corridor agent as pedestrians, letting them been displayed and going to their target.Code of the model :model corridorglobal {\t\t//Capture pedestrians parameter to define if wall will capture pedestrians\tbool capture_pedestrians &lt;- false parameter: 'Capture pedestrians?';\t\tint environment_size init: 2000;\tpoint environment_bounds init: {environment_size, environment_size} ;\tgeometry shape &lt;- rectangle(environment_bounds) ;\t\t\t\t//Pedestrians parameters\tfloat pedestrian_size init: 1.0;\tgeometry pedestrian_shape &lt;- circle (pedestrian_size);\trgb pedestrian_color &lt;- #green; \tfloat pedestrian_speed &lt;- 2.0;\t\t\t//Wall parameters\trgb corridor_wall_color &lt;- #black;\tint corridor_wall_width &lt;- int(environment_size / 2);\tint corridor_wall_height &lt;- 200;\tgeometry corridor_wall_0_shape &lt;- rectangle ( {corridor_wall_width, corridor_wall_height} ) at_location {environment_size / 2, corridor_wall_height / 2};\tgeometry corridor_wall_1_shape &lt;- rectangle ( {corridor_wall_width, corridor_wall_height} ) at_location {environment_size / 2, environment_size - (corridor_wall_height / 2)};\t\t//Corridor parameters\trgb corridor_color &lt;- #blue;\tint corridor_width &lt;- int(environment_size / 2) ;\tint corridor_height &lt;- environment_size ;\tpoint corridor_location &lt;- {environment_size / 2, environment_size / 2} ;\tgeometry corridor_shape &lt;- ( (rectangle ({corridor_width, corridor_height})) at_location corridor_location) - (corridor_wall_0_shape + corridor_wall_1_shape);\tint corridor_left_bounds &lt;- (int(corridor_location.x - (corridor_width / 2))) ;\tint corridor_right_bounds &lt;- (int(corridor_location.x + (corridor_width / 2))) ;\t\t//Generation of new pedestrians parameters\tint new_pedestrian_rate &lt;- 10;\tint new_pedestian_generate_frequency &lt;- 1;\tint new_pedestrian_y_distance &lt;- int(environment_size / new_pedestrian_rate);\t\tlist&lt;pedestrian&gt; pedestrians  update: list(pedestrian); \tfloat start_time &lt;- machine_time;\t\tinit {\t\tcreate corridor;\t\t \t\tcreate corridor_wall number: 2 returns: corridor_walls; \t\t(corridor_walls at 0).shape &lt;- corridor_wall_0_shape;\t\t(corridor_walls at 1).shape &lt;- corridor_wall_1_shape;\t\t\t}\t\t//Reflex to generate new pedestrians according to the frequency generation parameter\treflex generate_pedestrians when: ((cycle mod new_pedestian_generate_frequency) = 0) {\t\tcreate pedestrian number: new_pedestrian_rate returns: new_pedestrians; \t\t\t\tint loop_times &lt;- 0;\t\tloop p over: new_pedestrians {\t\t\tint y_coor &lt;- rnd (new_pedestrian_y_distance);\t\t\task p as: pedestrian {\t\t\t\tdo init_location loc: { 0, (loop_times * new_pedestrian_y_distance) + y_coor };\t\t\t}\t\t\tloop_times &lt;- loop_times + 1;\t\t}\t}} //Species pedestrian which will move from one side of the experiments to another and destroy itself once the other side is reachedspecies pedestrian skills: [moving] topology: ( topology (shape - (corridor_wall_0_shape + corridor_wall_1_shape)) ){\tgeometry shape &lt;-  circle (pedestrian_size);\tpoint initial_location;\tpoint target_location;\tint heading;\tfloat speed &lt;- 2.0;\t\taction init_location (point loc) {\t\tlocation &lt;- loc;\t\tinitial_location &lt;- loc;\t\ttarget_location &lt;- {environment_size, loc.y};\t\theading &lt;- (self) towards (target_location);\t}\t\t//Reflex to make the agent move to its target_location\treflex move_left {\t\tint update_heading &lt;- (self) towards (target_location);\t\t\t\tpoint current_location &lt;- location;\t\t\t\tdo move heading: update_heading ;\t\t\t\t//Conditions to know if the agent doesn't move, in this case we take care if it is bcause of the walls \t\tif (current_location = location) {\t\t\tif ( (location.y &lt;= corridor_wall_height) or (location.y &gt;= environment_size - corridor_wall_height) ) {\t\t\t\tdo move heading: self towards {(environment_size / 2) - (corridor_width / 2), environment_size / 2}; \t\t\t} else {\t\t\t\tdo move heading: self towards {environment_size / 2, environment_size / 2}; \t\t\t}\t\t}\t\t\t\tif( (target_location.x - location.x) &lt;= speed ) { \t\t\tdo die;\t\t}\t}\t \taspect my_aspect {\t\tdraw shape color: pedestrian_color;\t}}//Species which represents the corridorspecies corridor  {\tgeometry shape &lt;- corridor_shape;\t\t//Subspecies for the multi-level architectures : captured pedestrians in this case\tspecies captured_pedestrian parent: pedestrian schedules: [] {\t\tfloat released_time;\t\t\t\taspect my_aspect { }\t}\t\tinit {\t\tcreate corridor_info_drawer number: 1 with: [target :: self];\t}\t\t//Reflex to capture pedestrians if the parameter is checked\treflex aggregate when: capture_pedestrians {\t\t//List to get all the pedestrians inside the corridor\t\tlist&lt;pedestrian&gt; tobe_captured_pedestrians &lt;- (pedestrian overlapping shape);\t\t\t\t//If we have pedestrians inside the corridor, we capture them\t\tif !(empty (tobe_captured_pedestrians)) {\t\t\tcapture tobe_captured_pedestrians as: captured_pedestrian returns: cps;\t\t\t\t\t\t//We update the time during which a pedestrian is captured according to the time the pedestrian\t\t\t// should need to pass through the corridor if it wasn't captured\t\t\tloop cp over: cps {\t\t\t\tcp.released_time &lt;- time + ( ( corridor_width - ( (((cp).location).x) - ((environment_size / 2) - (corridor_width / 2)) ) ) / pedestrian_speed) ;\t\t\t}\t\t}\t}\t\t//Reflex to release pedestrians which have already passed enough time in the corridor\t// which means if they weren't captured by the corridor, they would have finish passing through it\treflex disaggregate  {\t\tlist tobe_released_pedestrians &lt;- members where (time &gt;= (captured_pedestrian (each)).released_time);\t\tif !(empty (tobe_released_pedestrians)) {\t\t\trelease tobe_released_pedestrians as: pedestrian in: world {\t\t\t\tlocation &lt;- {((environment_size / 2) + (corridor_width / 2)) + (2 * pedestrian_size), (location).y};\t\t\t}\t\t}\t}\t\taspect my_aspect {\t\tdraw shape color: corridor_color;\t}}species corridor_wall {\tinit {\t\tcreate corridor_wall_info_drawer number: 1 with: [target :: self];\t}\t\taspect  my_aspect {\t\tdraw shape color: corridor_wall_color;\t}}species corridor_info_drawer {\tcorridor target;\t\taspect my_aspect {\t\tdraw  'Captured pedestrians: ' + (string (length (target.members))) color: rgb ('blue') size: 12°px at: {(target.location).x - 480, (target.location).y};\t\tdraw  'Pedestrians: ' + (string (length (list (pedestrian)))) color: rgb ('blue') size: 12°px at: {(target.location).x - 135, (target.location).y + 100};\t}}species corridor_wall_info_drawer {\tcorridor_wall target;\t\tinit {\t\tlocation &lt;- target.location;\t}\t\taspect my_aspect { \t\tdraw 'WALL' color: rgb ('green') size: 15°px at: {(location).x - 40, (location).y};\t}}experiment corridor_expr type: gui{\toutput {\t\tdisplay defaut_display {\t\t\tspecies pedestrian;\t\t\t\t\t\tspecies corridor aspect: my_aspect transparency: 0.8 {\t\t\t\tspecies captured_pedestrian;\t\t\t}\t\t\t\t\t\tspecies corridor_wall aspect: my_aspect transparency: 0.7;\t\t\tspecies corridor_info_drawer aspect: my_aspect;\t\t\tspecies corridor_wall_info_drawer aspect: my_aspect;\t\t}\t\tdisplay Execution_Time refresh: every(25) {\t\t\tchart 'Simulation step length' type: series background: #white {\t\t\t\tdata 'simulation_step_length_in_mili_second' value: machine_time - start_time color: (rgb ('green'));\t\t\t}\t\t}\t \t\t\tdisplay Captured_Pedestrians refresh: every(25){\t\t\tchart 'Captured Pedestrian' type: series background: #white {\t\t\t\tdata 'captured_pedestrians' value: length ( ((list (corridor)) at 0).members ) color: rgb ('blue');\t\t\t\tdata 'pedestrians' value: length (list (pedestrian)) color: rgb ('white');  \t\t\t}\t\t}\t}}",
        "url":"/wiki/Multi-Level-Usage-Corridor.html"
      }
      ,
    
      "wiki-multi-level-usage-predators-preys-and-shelters-html": {
        "title": "Multi-Level Architecture with Preys and Predators",
        "content": "Multi-Level Architecture with Preys and Predators_Author : _This model shows how to use multi-level architecture. In this model, prey and predators agents move randomly in the environment. When a prey agent perceive a predator, it flees trying to go to the closest shelters while the predator agent chases it. The shelters capture the prey agents fleeing, changing them into prey_in_shelter species, that predator can’t chase during a certain time. They are released after that time in an invisible state so that they can wander in the  environment without being chase by the predator, but also, for a certain time.Code of the model :model preys_predators_sheltersglobal { \t//Parameters for the prey species\trgb prey_color &lt;- #green const: true;\tfloat prey_perception &lt;- 20.0;\tfloat prey_size &lt;- 2.0 const: true;\tfloat prey_speed &lt;- 1.0;\trgb prey_flee_color &lt;- #orange;\tfloat prey_invisible_speed &lt;- 3 * prey_speed;\trgb prey_invisible_color &lt;- #black;  \tint prey_in_shelter_max_time min: 1 init: 200;\tint prey_invisible_max_time min: 1 max: 100 init: 70; \tint number_of_preys min: 1 max: 1000 init: 100;\t\t//Parameters for the predator species\trgb predator_color &lt;- #red const: true;\tfloat predator_perception &lt;- 3.0;\tfloat predator_size &lt;- 4.0;\tfloat predator_speed &lt;- 1.0;\tint number_of_predators min: 1 max: 100 init: 30; \tgeometry shape &lt;- square(400);\t\trgb predator_in_shelter_color &lt;- #yellow const: true;\t \t//Parameters for the shelter species\trgb shelter_color &lt;- #blue const: true; \tfloat shelter_speed &lt;- 1.5 const: true;\tgeometry shelter_shape &lt;- square (50.0);\tint number_of_shelter &lt;- 2 const: true;\t\t\tinit {\t\tcreate prey number: number_of_preys;\t\tcreate predator number: number_of_predators; \t\tcreate shelter number: number_of_shelter returns: shelters;\t\t(shelters at 0).shape &lt;- shelter_shape at_location {150, 250};\t\t(shelters at 1).shape &lt;- shelter_shape at_location {350, 250};\t}}//Species prey which can move using the skill moving and its operatorsspecies prey skills: [moving] control: fsm {\tgeometry shape &lt;- square (prey_size);\trgb color &lt;- prey_color;\t\t//List of all predators inside the perception of the prey\tlist nearby_predators update: (agents_overlapping (shape + prey_perception)) of_species predator depends_on: shape;\tint invisible_time min: 1 &lt;- int(time);\tshelter nearest_shelter;\t\t\t//State to make the prey move randomly when there isn't any predator, if so, change the state to flee\tstate move_around initial: true {\t\tenter {\t\t\tspeed &lt;- prey_speed;\t\t\tcolor &lt;- prey_color;\t\t}\t\tdo wander; \t\t\t\ttransition to: flee_predator when: !(empty (nearby_predators)); \t}\t\t//State to make the prey move to the closest shelter to flee from the predator, if no predator are perceived, change the state to move aroung\tstate flee_predator {\t\tenter {\t\t\tcolor &lt;- prey_flee_color;\t\t\tnearest_shelter &lt;- first ( (list (shelter)) sort_by ( each distance_to (self)) );\t\t}\t\tif !(empty (nearby_predators)) { do move heading: (self) towards (nearest_shelter) speed: prey_speed;}\t\t\t\ttransition to: move_around when: (empty (nearby_predators));\t}\t//State to make the prey invisible during a certain time when it is released by the shelters\tstate invisible {\t\tenter {\t\t\tspeed &lt;- prey_invisible_speed;\t\t\tcolor &lt;- prey_invisible_color;\t\t\tinvisible_time &lt;- int(time);\t\t\theading &lt;- rnd (359) ;\t\t}\t\tdo move; \t\ttransition to: move_around when: ( (time - invisible_time) &gt; prey_invisible_max_time );\t}\t\taspect default {\t\tdraw  shape color: color;\t}}//Species predator which can move using the skill movingspecies predator skills: [moving] schedules: shuffle (list (predator)) {\tgeometry shape &lt;- square (predator_size);\tprey target_prey update: self choose_target_prey [];\t\t//Change the target prey according to the prey who aren't fleeing if it doesn't have any yet\taction choose_target_prey type: prey {\t\tif ( (target_prey = nil) or (dead (target_prey) ) ) {\t\t\treturn one_of ( (list (prey)) where (each.state = 'move_around') );\t\t}\t\t\t\treturn target_prey;\t}\t//Reflex to move randomly when no prey are perceived\treflex move_around when: (target_prey = nil) { do wander speed: predator_speed; }\t\t//Reflex to make the predator chase a prey\treflex chase_prey when: (target_prey != nil) { do move heading: self towards target_prey speed: predator_speed;}\t\taspect default {\t\tdraw shape color: predator_color;\t} } //Species shelter that will capture prey agentsspecies shelter skills: [moving]  frequency: 2 {\tgeometry shape &lt;- (square (50.0)) at_location {250, 250};\t\t//List of all preys which are being chased and inside the shelter but not captured yet\tlist&lt;prey&gt; chased_preys update: (prey) where ( (each.shape intersects shape) and (each.state = 'flee_predator') );\t\treflex move_around {\t\t//do wander speed: shelter_speed; \t}\t \t//Capture all the chased preys inside the shelter and change their species to prey_in_shelter\treflex capture_chased_preys when: !(empty (chased_preys)) { \t\tcapture chased_preys as: prey_in_shelter {\t\t\tstate &lt;- 'in_shelter'; \t\t\tshape &lt;- ( triangle (4.0) ) at_location location;\t\t}\t}\t\t//Release all the prey_in_shelter after a certain time and change their state to invisible after making their species returned to prey\treflex release_member_preys {\t\tlist&lt;prey_in_shelter&gt; to_be_released &lt;- (prey_in_shelter) where ( (time - each.in_shelter_time) &gt; prey_in_shelter_max_time );\t\t \t\trelease to_be_released in: world as: prey { \t\t\tstate &lt;- 'invisible';\t\t\tshape &lt;-  at_location (square (prey_size), self.location);   \t\t}\t} \t\t//Subspecies prey_in_shelter that will represent the prey agents captured by the shelter\tspecies prey_in_shelter parent: prey frequency: 2 schedules: ( ( int ( (length (prey_in_shelter)) / 2 ) ) among (list (prey_in_shelter)) ) {\t\tint in_shelter_time &lt;- int(time);\t\t\t\tstate in_shelter {\t\t\tdo wander speed: shelter_speed;\t\t}\t\t\t\taspect default {\t\t\tdraw  shape color: predator_in_shelter_color;\t\t} \t}\t\taspect default {\t\tdraw shape color: shelter_color;\t\tdraw 'Members: ' + (string (length ((members)))) color: rgb ('white') size: 6 at: {(location).x - 20, (location).y};\t}}experiment default_experiment type: gui {\toutput {\t\tdisplay default_display type: opengl{\t\t\tspecies prey aspect: default;\t\t\tspecies predator transparency: 0.5 aspect: default;\t\t\tspecies shelter transparency: 0.5 aspect: default { \t\t\t\tspecies prey_in_shelter aspect: default;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Multi-Level-Usage-Predators,-Preys-and-Shelters.html"
      }
      ,
    
      "wiki-multi-level-usage-html": {
        "title": "Multi-Level Usage",
        "content": "Multi-Level UsageThis sub-section is composed of the following models :      Balls, Groups and Clouds Multilevel Architecture        Corridor Multi-Level Architecture with Mathematics Model and Agent Based Model        Corridor Multi-Level Architecture        Multi-Level Architecture with Preys and Predators  ",
        "url":"/wiki/Multi-Level-Usage.html"
      }
      ,
    
      "wiki-multi-level-data-analysis-graph-from-bug-distance-graph-html": {
        "title": "SpatialGraph",
        "content": "SpatialGraphAuthor : Arnaud GrignardFrom the reference model “bug.gaml” a spatial graph is created. We create a species node that mirrors the species bug and then a spatial graph is creating using as_distance_graph operator.Code of the model :model SpatialGraph//Import the model Common Bug Species modelimport '../includes/Common Bug Species.gaml'global { \t//Graph that will be computed at each step linking the bug agents according to their distance\tgraph myGraph;\t//Minimal distance to consider two nodes agents (ie the bug) as connected\tfloat distance parameter: 'Distance' min: 1.0 &lt;- 10.0 category: 'Model';\t\t//Reflex to update the graph when cycle is greater than 0. Important because the mirroring has one step late from\t//the original species, and at step 0, the mirroring species aren't created\treflex updateGraph when:(cycle&gt;0){\t\t//Kill all the edge agent to create a new graph\t\task edge_agent {\t\t\tdo die;\t\t}\t\t//Create a new graph using the distance to compute the edges\t\tmyGraph &lt;- as_distance_graph(node_agent, [\"distance\"::distance, \"species\"::edge_agent]);\t}}//Species node_agent mirroring the bug speciesspecies node_agent mirrors: list(bug) {\t//Each location will be the one of the bug at the previous step\tpoint location &lt;- target.location update: target.location;\taspect base {\t\tdraw sphere(1.1) color: #green; \t}}//Species to represent the edge of the graphspecies edge_agent {\taspect base {\t\tdraw shape color: #green;\t}}experiment spatialGraph type: gui {\toutput {\t\t display graph_view type: opengl {\t \t    species bug aspect:base;\t\t\tspecies node_agent aspect: base position:{0,0,0.1};\t\t\tspecies edge_agent aspect: base position:{0,0,0.1};\t\t}\t}}",
        "url":"/wiki/Multi-level-data-analysis-Graph-From-Bug-(Distance-Graph).html"
      }
      ,
    
      "wiki-multi-level-data-analysis-graph-from-bug-mirror-graph-html": {
        "title": "SpatialGraph3d",
        "content": "SpatialGraph3dAuthor : Arnaud GrignardFrom the reference model “bug.gaml” a spatial graph is created. We create a species node that mirrors the species bug and then a spatial graph is creating using as_distance_graph operator. The species node should then define its own related_to method to decide wether or not a node is related to another one.Code of the model :model Graph//Import the model Common Bug Species modelimport '../includes/Common Bug Species.gaml'global {\t//Distance to link two bugs\tint distance parameter: 'Distance' min: 1 &lt;- 25 category: 'Model';\t//variable to start the animation of the model\tint startAnimation parameter: 'Start Animation ' min: 1 &lt;- 25 category: 'Animation View';\t//Variable to save the time animation\tint timeAnim &lt;- 0;\t//Reflex to update the time of animation\treflex updateAnimation \t{\t\tif (time &gt; startAnimation) \t\t{\t\t\ttimeAnim &lt;- int(time - startAnimation);\t\t}\t}}//Species node_agent mirroring the bug species, represented as graph nodespecies node_agent mirrors: list(bug) parent: graph_node edge_species: edge_agent {\t//Their location is the one of the target location\tpoint location &lt;- target.location update: target.location;\t\t//Action to know if an agent is related to another agent considering their distance\tbool related_to (node_agent other) {\t\tusing topology(target) {\t\t\treturn (target.location distance_to other.target.location) &lt; distance;\t\t}\t}\taspect base {\t\tdraw sphere(2) color: #green;\t}\taspect dynamic {\t\tint degree &lt;- (my_graph) degree_of (self);\t\tdraw sphere(1 + (degree / 5.0)) color: #blue;\t}}//Species edge to represent the edges of the graphspecies edge_agent parent: base_edge {\trgb color;\taspect base {\t\tdraw shape color: #green;\t}\t\taspect dynamic {\t\tshape &lt;- line([{ self.source.location.x, self.source.location.y, self.source.location.z }, { self.target.location.x, self.target.location.y, self.target.location.z }]);\t\tfloat val &lt;- 255.0 * (shape.perimeter / distance);\t\tcolor &lt;- hsb(val, 1.0, 1.0);\t\tdraw shape + 0.1 color: color border: color;\t}}experiment AdvancedView type: gui {\toutput {\t\tdisplay graph_plus_bug_layered type: opengl { \t\t  species bug aspect: base;\t\t  species node_agent aspect: base position: { 0, 0, 0.2 };\t\t  species edge_agent aspect: base position: { 0, 0, 0.2 };\t\t  species node_agent aspect: dynamic position: { 0, 0, 0.4 };\t\t  species edge_agent aspect: dynamic position: { 0, 0, 0.4 };\t\t}\t}}",
        "url":"/wiki/Multi-level-data-analysis-Graph-From-Bug-(Mirror-Graph).html"
      }
      ,
    
      "wiki-multi-level-data-analysis-modavi-html": {
        "title": "Modavi",
        "content": "ModaviAuthor : Arnaud GrignardFrom a reference model with node of a given class, a spatial graph is created (or a barabasi graph if spatialGraph is set to false) in the advanced view to represent the interaction in the reference model.An abstract view/controller is created to summarize the interaction in the advanced viewin a macro graph and control the reference model by defining an action (user_command) for each macroNode and macroEdge.Code of the model :model modavi global {\t//Graph of the agents\tgraph&lt;node_agent,edge_agent&gt; my_graph ;\t\t//Number of agents to create\tint nbAgent parameter: 'Number of Agents' min: 1 &lt;- 500 category: 'Model';\t//Number of value per class\tint nbValuePerClass parameter: 'Number of value per class' min: 1 max:100 &lt;- 15 category: 'Model';\t//Boolean to know if we display a spatial graph or not\tbool spatialGraph parameter: 'Spatial Graph' &lt;- true category: 'Model';\t//Distance to link two node agents\tfloat distance parameter: 'Distance' min: 1.0&lt;- 10.0 category: 'Model';\t//Threshold\tint threshold parameter: 'Threshold' min: 0 &lt;- 0 category: 'Model';\t//Size of a node agent\tint nodeSize parameter: 'Node size' min: 1 &lt;- 1 category: 'Aspect';\t//Size of a macro node agent\tint macroNodeSize parameter: 'Macro Node size' min: 1 &lt;- 2 category: 'Aspect';\t\t//Number of type of class\tint nbTypeOfClass &lt;-1;\t\t//Zoom factor\tint zoomFactor &lt;- nbTypeOfClass;\t//List of the different interaction matrices\tlist&lt;matrix&lt;int&gt;&gt; interactionMatrix &lt;-list_with(nbTypeOfClass,matrix([0]));\t//Number maximum of edges    int nbEdgeMax;        //Reflex to update the interaction matrix list    reflex updateInteractionMatrix{    \t//Ask for each edge agent to update it sources and destination to create the matrix    \task edge_agent{\t\t\tloop i from:0 to: nbTypeOfClass-1{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsrc &lt;- my_graph source_of(self);\t\t\t\tdest &lt;- my_graph target_of(self);\t\t\t\tint tmp &lt;- (interactionMatrix[i]  at {(src.classVector[i]-1),(dest.classVector[i]-1)});\t\t\t\tinteractionMatrix[i][src.classVector[i]-1,dest.classVector[i]-1] &lt;- (tmp+1);\t\t\t}\t\t}\t}\t\t//Reflex to compute te maximum number of edges\treflex computeNbEdgeMax{\t\t//Number maximum of edges\t\tnbEdgeMax &lt;-1;\t\t//Ask for each macro edge its aggregated link list number\t\task macroEdge{\t\t\tif(nbAggregatedLinkList[0] &gt; nbEdgeMax){\t\t\t\tnbEdgeMax &lt;-nbAggregatedLinkList[0];\t\t\t}\t\t\t}\t}\t//Initialization of the model\tinit {\t\t//Initialization of the matrix\t\tdo InitInteractionMatrix;\t\t//If we want a spatial graph in that case we create a graph according to their distance, else we create a barabasi albert graph\t\tif(spatialGraph){\t\t\tcreate node_agent number:nbAgent;\t\t\tmy_graph &lt;- graph&lt;node_agent, edge_agent&gt;(as_distance_graph(node_agent, ([\"distance\"::distance, \"species\"::edge_agent])));\t\t\t\t\t}        else{          my_graph &lt;- graph&lt;node_agent, edge_agent&gt;(generate_barabasi_albert(node_agent,edge_agent,nbAgent,2,true));\t        }        \t\t//For each node agent, we compute its class value\t\task node_agent as list{\t\t\tloop i from:0 to:nbTypeOfClass-1{\t\t\t\tclassVector[i] &lt;- rnd(nbValuePerClass-1)+1; \t\t\t}\t\t\t\t}\t\tint i&lt;-1;\t\t//Creation of the macronode according to the number of value per class\t\tcreate macroNode number: nbValuePerClass{\t \t\t\tclass &lt;-i;\t\t\tlocation &lt;- {(cos (((class-1)/nbValuePerClass)*360)*50 +50),(sin (((class-1)/nbValuePerClass)*360)*50+50),0};\t\t\tcolor &lt;- hsb (i/nbValuePerClass,1.0,1.0);\t\t\tdo updatemyNodes;\t\t\ti&lt;-i+1;\t\t\t}\t\t//We finally create the macroGraph\t\tcreate macroGraph;\t }\t //Action to initialize the interaction Matrix according to the number of type of classes\t action InitInteractionMatrix{\t\t loop i from:0 to:nbTypeOfClass-1{\t\t\t\tinteractionMatrix[i] &lt;- 0 as_matrix({nbValuePerClass,nbValuePerClass}); \t\t  }\t\t}}\t//Species to represent the node_agent\tspecies node_agent  {\t\t//Color of the node agent\t\trgb color;\t\t//List of the class\t\tlist&lt;int&gt; classVector &lt;- list_with (nbTypeOfClass,0);\t\t//List of the position\t\tlist&lt;point&gt; posVector &lt;- list_with (nbTypeOfClass,{0,0});\t\t//List of the color\t\tlist&lt;rgb&gt; colorList &lt;- list_with (nbTypeOfClass, rgb(0,0,0));\t\t\t\t\t\t\t\t\t\t//Shuffle the classes of the node_agent\t\treflex shuffleClass{\t\t\tloop i from:0 to: nbTypeOfClass-1{\t\t\t\tclassVector[i] &lt;- rnd(nbValuePerClass-1)+1;\t\t\t}\t\t\t} \t\t\t\taspect real {\t\t\t \t\t\tdraw sphere(nodeSize) color: colorList[0];\t\t} \t\t\t\t\t\t\t\t\t\taspect coloredByClass{\t\t\tloop i from:0 to: nbTypeOfClass-1{\t\t\t    colorList[i]&lt;- hsb (classVector[i]/nbValuePerClass,1.0,1.0);\t\t\t\t\t\t\t\t    posVector[i] &lt;- {(location.x+i*110)*(1/zoomFactor),(location.y)*(1/zoomFactor),0};  \t\t\t    draw sphere(nodeSize/zoomFactor) color: colorList[i] at: posVector[i] ;   \t\t\t}\t\t}\t\t}\t\t//Species edge_agent to represent the edge of the graph\tspecies edge_agent { \t\trgb color;\t\t//Source of the edge\t\tnode_agent src;\t\t//Target of the edge\t\tnode_agent dest;\t\t\t \t\taspect base {\t\t\tdraw shape color: rgb(125,125,125);\t\t}\t\t\t\t\taspect edgeGenericSpatialized{\t\t\tloop i from:0 to: nbTypeOfClass-1{\t\t\t  if ((src != nil) and (dest !=nil) ){\t\t\t\tdraw line( [ (src.posVector[i]) , (dest.posVector[i])] ) color:rgb(125,125,125);\t\t\t  }\t\t\t}\t\t}\t}\t//Species representing the macro node agents\tspecies macroNode{\t\trgb color;\t\tint class;\t\t//List of all the aggregated nodes\t\tlist&lt;int&gt; nbAggregatedNodes &lt;- list_with(nbTypeOfClass,0);\t\t//List of all the position\t\tlist&lt;point&gt; posVector &lt;-list_with(nbTypeOfClass,{0,0});\t\t \t\t//Update the nodes of the agents\t\treflex update{\t\t\tdo updatemyNodes;\t\t}\t\t//For each classes, find all the nodes with the same classes\t\taction updatemyNodes{\t\t\tloop i from:0 to: nbTypeOfClass-1{\t\t\t\t\t\t\tnbAggregatedNodes[i]&lt;-0;\t\t\t\task node_agent as list{\t\t\t\t  if\t(classVector[i] = myself.class) {\t\t\t\t\tmyself.nbAggregatedNodes[i] &lt;- myself.nbAggregatedNodes[i]+1;\t\t\t\t  }\t \t\t\t    }\t\t    }\t    \t\t} \t\t\t\taspect sphere{\t\t\tdraw sphere((nbAggregatedNodes[0]/10)*macroNodeSize) color: color at: point([location.x,location.y]) ;\t\t}\t\t\t\taspect Generic{\t\t\tloop i from:0 to: nbTypeOfClass-1\t\t\t{\t\t\tposVector[i] &lt;- {(location.x+i*150)*(1/zoomFactor),(location.y)*(1/zoomFactor),0};\t\t\t\tdraw sphere((nbAggregatedNodes[i]/10)*macroNodeSize*(1/zoomFactor)) color: color at: posVector[i] ;\t\t\t}\t\t}\t\t\t\t//This action only works when having nbTypeOfClass=1\t\taction removeMicroNode{\t\t\task node_agent as list{\t\t\t\t  if\t(classVector[0] = myself.class) {\t\t\t\t      do die;\t\t\t\t  }\t \t         }\t\t}\t\t\t\tuser_command \"Remove all micro node\" action: removeMicroNode;\t}\t\t//Species macroEdge representing the macro edges agents\tspecies macroEdge  { \t\trgb color &lt;- #black;\t\t//Source of the macroedge\t\tmacroNode src;\t\t//Destination of the macroedge\t\tmacroNode dest;\t\t//List of all the aggregated links\t\tlist&lt;int&gt; nbAggregatedLinkList &lt;- list_with(nbTypeOfClass,0);\t\t\t\taspect base {\t\t\tloop i from:0 to: nbTypeOfClass-1{\t\t\t\tif(nbAggregatedLinkList[i]&gt;threshold){\t\t\t\tdraw (line([src.posVector[i],dest.posVector[i]]) buffer ((nbAggregatedLinkList[i])/((length(edge_agent)))*nbEdgeMax)) color: rgb(125,125,125) border:rgb(125,125,125); \t\t\t\t\t}\t\t\t}\t\t}\t\t\t\t//Action to remove a micro edge\t\taction removeMicroEdge{\t\t\task edge_agent as list{\t\t\t\t  if\t((self.src.classVector[0] =  myself.src.class) and (self.dest.classVector[0] =  myself.dest.class)) {\t\t\t\t      do die;\t\t\t\t  }\t \t         }\t\t}\t\t\t\tuser_command \"Remove all micro edge\" action: removeMicroEdge;\t\t}\t\t//Species macroGraph representing the macro graph composed of macroNode and macroEdge\tspecies macroGraph {\t\t  \t//Reflex to update the graph by killing all the previous edges first    reflex updateAllMacroEdge {\t\t \task macroEdge as list{\t \t\tdo die;\t \t}\t \t\t \tloop h from:0 to: nbTypeOfClass-1{\t\t \tloop i from: 0 to: nbValuePerClass-1{\t\t      loop j from: 0 to: nbValuePerClass-1{\t\t        int tmp &lt;- interactionMatrix[h] at {i,j}; \t\t        if(i!=j){\t\t            create macroEdge{\t\t              nbAggregatedLinkList[h] &lt;- tmp;\t\t              src &lt;- macroNode[i];\t\t\t\t      dest &lt;- macroNode[j];\t\t            }\t  \t\t        }      \t\t      }\t\t    }\t    }  \t}  \t//Reflex to initialize the matrix  \treflex initMatrix{  \t\tloop i from:0 to:nbTypeOfClass-1{  \t\t  interactionMatrix[i] &lt;- 0 as_matrix({nbValuePerClass,nbValuePerClass});\t  \t\t}\t\t  }\t\t}experiment MODAVI type: gui {\toutput {\t\t\t\t\tdisplay MODAVI type:opengl draw_env:false {\t\t\tgraphics 'ReferenceModel'{\t\t\t\tdraw \"Reference model\" at:{200,50,0} size:5 color: #black perspective:false;\t\t\t}\t\t\tspecies node_agent aspect: real position:{100,0,0.01} ;\t\t\t\t\t\tgraphics 'View1'{\t\t\t\tdraw \"Advanced view\" at:{50,210,0} size:5 color: #black perspective:false;\t\t\t}\t\t\tspecies node_agent aspect: coloredByClass position: {0,100,0.02};\t\t\tspecies edge_agent aspect: edgeGenericSpatialized position: {0,100,0.02};\t\t\t\t\t\tgraphics 'AbstractView'{\t\t\t\tdraw \"Abstract view/controller\" at:{250,210,0} size:5 color: #black perspective:false;\t\t\t}\t\t\tspecies macroNode aspect:Generic position: {200,100,0.01};\t\t\tspecies macroEdge aspect:base position: {200,100,0.01};\t\t\t}\t}\t\t}",
        "url":"/wiki/Multi-level-data-analysis-MODAVI.html"
      }
      ,
    
      "wiki-multi-level-data-analysis-html": {
        "title": "Multi-level data analysis",
        "content": "Multi-level data analysisThis sub-section is composed of the following models :      SpatialGraph        SpatialGraph3d        Modavi  ",
        "url":"/wiki/Multi-level-data-analysis.html"
      }
      ,
    
      "wiki-multi-simulation-multi-simulation-html": {
        "title": "Multi Simulation",
        "content": "Multi SimulationAuthor : Patrick TaillandierModel to show how to use multi-simulation, i.e. to run several times the same GUI experiment with potentially different parameter setsCode of the model :model multi_simulationglobal {\t//definition of three global variables of which the initial values will be used by the first simulation \tint nb_agents &lt;- 10;\tfloat agent_speed &lt;- 1.0;\trgb agent_color &lt;- #green;\t\t\tinit {\t\tcreate dummy number: nb_agents;\t}}//definition a simple species that just move randomly at a given speedspecies dummy skills: [moving]{\trgb color &lt;- #green;\treflex move {\t\tdo wander speed: agent_speed;\t}\taspect default {\t\tdraw circle(2) color: agent_color border: #black;\t}}experiment main type: gui {\t//definition of a minimal duration for each cycle. As the model is very simple, it can run too fast to observe the results, so we slow it down.\tfloat minimum_cycle_duration &lt;- 0.1;\t\t//we define a init block to create new simulations\tinit {\t\t//we create a second simulation (the first simulation is always created by default) with the given parameters\t\tcreate simulation with: [nb_agents:: 5, agent_speed:: 3.0, agent_color:: #red];\t\t\t}\toutput {\t\tdisplay map {\t\t\t//we use an overlay to display the speed of the agents in the simulation\t\t\toverlay \"Overlay\" position: { 5, 5 } size: { 180 #px, 30 #px } background: # black transparency: 0.5 border: #black rounded: true            {               draw \"agent_speed: \" + agent_speed color: # white font: font(\"SansSerif\", 20, #bold) at: { 10°px, 20°px };            }\t\t\tspecies dummy;\t\t}\t}}",
        "url":"/wiki/Multi-simulation-Multi-simulation.html"
      }
      ,
    
      "wiki-multi-simulation-html": {
        "title": "Multi-simulation",
        "content": "Multi-simulationThis sub-section is composed of the following models :  Multi Simulation",
        "url":"/wiki/Multi-simulation.html"
      }
      ,
    
      "wiki-multilevelarchitecture-html": {
        "title": "Multi-level architecture",
        "content": "Multi-level architectureThe multi-level architecture offers the modeler the following possibilities: the declaration of a species as a micro-species of another species, the representation of an entity as different types of agent (i.e., GAML species), the dynamic migration of agents between populations.Index  Declaration of micro-species  Access to micro-agents / host agent  Representation of an entity as different types of agent  Dynamic migration of agents  ExampleDeclaration of micro-speciesA species can have other species as micro-species. The micro-species of a species is declared inside the species’ declaration.species macro_species {      species micro_species_in_group {      }}In the above example, “micro_species_in_group” is a micro-species of “macro_species”. An agent of “macro_species” can have agents “micro_species_in_group” as micro-agents. Agents of “micro_species_in_group” have an agent of “macro_species” as “host” agent.As the species “micro_species_in_group” is declared inside the species “macro_species”, “micro_species_in_group” will return a list of “micro_species_in_group” agent inside the given “macro_species” agent.global{\tinit {\t\tcreate macro_species number:5;\t}}species macro_species {\t\tinit {\t\tcreate micro_species_in_group number:rnd(10);\t\twrite \"the macro species named \"+name+\" contains \"+length(micro_species_in_group)+\" micro-species.\";\t}\t    species micro_species_in_group {    }}experiment my_experiment type: gui {}In this above example, we create 5 macro-species, and each one of these macro-species create a random number of inner micro-species. We can see that “micro_species_in_group” refers to the list of micro-species inside the given macro-species.Access to micro-agents, host agentTo access to micro-agents (from a macro-agent), and to host agent (from a micro-agents), you have to use two built-in attributes.The members built-in attribute is used inside the macro-agent, to get the list of all its micro-agents.species macro_species {\tinit {\t\tcreate first_micro_species number:3;\t\tcreate second_micro_species number:6;\t\twrite \"the macro species named \"+name+\" contains \"+length(members)+\" micro-species.\";\t}\t    species first_micro_species {    }        species second_micro_species {    }}The host built-in attribute is used inside the micro-agent to get the host macro-agent.species macro_species {\t\tmicro_species_in_group micro_agent;\t\tinit {\t\tcreate micro_species_in_group number:rnd(10);\t\twrite \"the macro species named \"+name+\" contains \"+length(members)+\" micro-species.\";\t}\t    species micro_species_in_group {    \tinit {    \t\twrite \"the micro species named \"+name+\" is hosted by \"+host;    \t}    }}NB: We already said that the world agent is a particular agent, instantiated just once. In fact, the world agent is the host of all the agents. You can try to get the host for a regular species, you will get the world agent itself (named as you named your model). You can also try to get the members of your world (from the global scope for example), and you will get the list of the agents presents in the world.global{\tinit {\t\tcreate macro_species number:5;\t\twrite \"the world has \"+length(members)+\" members.\";\t}}species macro_species {\t\tinit {\t\twrite \"the macro species named \"+name+\" is hosted by \"+host;\t}}Representation of an entity as different types of agentThe multi-level architecture is often used in order to represent an entity through different types of agent. For example, an agent “bee” can have a behavior when it is alone, but when the agent is near from a lot of agents, he can changes his type to “bee_in_swarm”, defined as a micro-species of a macro-species “swarm”. Other example: an agent “pedestrian” can have a certain behavior when walking on the street, and then change his type to “pedestrian_in_building” when he is in a macro-species “building”.You have then to distinguish two different species to define your micro-species:  The first can be seen as a regular species (it is the “bee” or the “pedestrian” for instance). We will name this species as “micro_species”.  The second is the real micro-species, defined inside the macro-species (it is the “bee_in_swarm” or the “pedestrian_in_building” for instance). We will name this species as “micro_species_in_group”. This species has to inherit from the “micro_species”.species micro_species {}species macro_species {\t\tspecies micro_species_in_group parent: micro_species {\t}}Dynamic migration of agentsIn our example about bees, a “swarm” entity is composed of nearby flying “bee” entities. When a “bee” entity approaches a “swarm” entity, this “bee” entity will become a member of the group. To represent this, the modeler lets the “bee” agent change its species to “bee_in_swarm” species. The “bee” agent hence becomes a “bee_in_swarm” agent. To change species of agent, we can use one of the following statements: capture, release, migrate.The statement capture is used by the “macro_species” to capture one (or several) “micro_species” agent(s), and turn it (them) to a “micro_species_in_group”. You can specify which agent (or list of agents) you want to capture by using the facet target. The facet as is used to cast the agent from “micro_species” to “micro_species_in_group”. You can use the facet return to get the newly captured agent(s).capture target:micro_species as:micro_species_in_group;The statement release is used by the “macro_species” to release one (or several) “micro_species_in_group” agent(s), and turn it (them) to a “micro_species”. You can specify which agent (or list of agents) you want to release by using the facet target. The facet as is used to cast the agent from “micro_species_in_group” to “micro_species”. The facet in is used to specify the new host (by default, it is the host of the “macro_species”). You can use the facet return to get the newly released agent(s).release target:list(micro_species_in_group) as:micro_species in:world;The statement migrate, less used, permits agents to migrate from one population/species to another population/species and stay in the same host after the migration. Read the GAML Reference to learn more about this statement.//: # (endConcept|multi_level)Example:Here is an example of micro_species that gather together in macro_species when they are close enough.model multilevelglobal {\tint release_time &lt;- 20;\tint capture_time &lt;- 100;\tint remaining_release_time &lt;- 0;\tint remaining_capture_time &lt;- capture_time;\tinit {\t\tcreate micro_species number:200;\t}\treflex reflex_timer {\t\tif (remaining_release_time=1)\t\t{\t\t\tremaining_release_time &lt;- 0;\t\t\tremaining_capture_time &lt;- capture_time;\t\t}\t\telse if (remaining_capture_time=1)\t\t{\t\t\tremaining_capture_time &lt;- 0;\t\t\tremaining_release_time &lt;- release_time;\t\t}\t\tremaining_release_time &lt;- remaining_release_time - 1;\t\tremaining_capture_time &lt;- remaining_capture_time - 1;\t}\treflex capture_micro_species when:(remaining_capture_time&gt;0 and flip(0.1)) {\t\task macro_species {\t\t\tlist&lt;micro_species&gt; micro_species_in_range &lt;- micro_species at_distance 1;\t\t\tif (micro_species_in_range != []) {\t\t\t\tdo capture_micro_species(micro_species_in_range);\t\t\t}\t\t}\t\task micro_species {\t\t\tlist&lt;micro_species&gt; micro_species_list_to_be_captured &lt;- micro_species at_distance 1;\t\t\tif(micro_species_list_to_be_captured != []) {\t\t\t\tcreate macro_species {\t\t\t\t\tlocation &lt;- myself.location;\t\t\t\t\tadd item:myself to:micro_species_list_to_be_captured;\t\t\t\t\tdo capture_micro_species(micro_species_list_to_be_captured);\t\t\t\t}\t\t\t}\t\t}\t}}species micro_species skills:[moving] {\tgeometry shape &lt;- circle(1);\taspect base {\t\tdraw shape;\t}\treflex move{\t\tdo wander;\t}}species macro_species {\tgeometry shape &lt;- circle(1) update:circle(length(members));\t\tspecies micro_species_in_group parent:micro_species {\t}\t\taction capture_micro_species(list&lt;micro_species&gt; micro_list) {\t\tloop mic_sp over:micro_list {\t\t\tcapture mic_sp as:micro_species_in_group;\t\t}\t}\t\treflex release_reflex when:(remaining_release_time&gt;0 and flip(0.1)) {\t\trelease members as:micro_species /*in:world*/;\t\tdo die;\t}\t\taspect base {\t\tdraw shape;\t\tdraw text:string(length(members)) color:#black size:4;\t}}experiment MyExperiment type: gui {\toutput {\t\tdisplay MyDisplay type: java2D {\t\t\tspecies macro_species aspect: base;\t\t\tspecies micro_species aspect: base;\t\t}\t}}",
        "url":"/wiki/MultiLevelArchitecture.html"
      }
      ,
    
      "wiki-multiparadigmmodeling-html": {
        "title": "Multi-Paradigm Modeling",
        "content": "Multi-Paradigm ModelingMulti-paradigm modeling is a research field focused on how to define a model semantically. From the beginning of this step by step tutorial, our approach is based on behavior (or reflex), for each agents. In this part, we will see that GAMA provides other ways to implement your model, using several control architectures. Sometime, it will be easier to implement your models choosing other paradigms.In a first part, we will see how to use some control architectures which already exist in GAML, such as finite state machine architecture, task based architecture or user control architecture. In a second part, we will see an other approach, a math approach, through equations.",
        "url":"/wiki/MultiParadigmModeling.html"
      }
      ,
    
      "wiki-multicriteria-decision-multicriteria-html": {
        "title": "Multicriteria",
        "content": "MulticriteriaAuthor : Patrick TaillandierThis model show how to use different methods of multicriteria analysis to look for the best house. Four methods are used : the Weighted_Means method , the Electre method , the Promethee method  an the Evidence Theory method. Each method uses different criteria with different weights according to the methods used.Code of the model :model multicriteriaglobal {\tfloat weight_standing &lt;- 1.0;\tfloat weight_price &lt;- 1.0;\tfloat weight_distance &lt;- 1.0;\tfloat weight_area &lt;- 1.0;\tfloat p_standing &lt;- 0.5;\tfloat p_price &lt;- 0.5;\tfloat p_distance &lt;- 0.5;\tfloat p_area &lt;- 0.5;\tfloat q_standing &lt;- 0.0;\tfloat q_price &lt;- 0.0;\tfloat q_distance &lt;- 0.0;\tfloat q_area &lt;- 0.0;\tfloat v_standing &lt;- 1.0;\tfloat v_price &lt;- 1.0;\tfloat v_distance &lt;- 1.0;\tfloat v_area &lt;- 1.0;\tfloat s_standing &lt;- 1.0;\tfloat s_price &lt;- 1.0;\tfloat s_distance &lt;- 1.0;\tfloat s_area &lt;- 1.0;\tfloat s1_standing &lt;- 0.0;\tfloat s1_price &lt;- 0.0;\tfloat s1_distance &lt;- 0.0;\tfloat s1_area &lt;- 0.0;\tfloat s2_standing &lt;- 1.0;\tfloat s2_price &lt;- 1.0;\tfloat s2_distance &lt;- 1.0;\tfloat s2_area &lt;- 1.0;\tfloat v1p_standing &lt;- 0.0;\tfloat v1p_price &lt;- 0.0;\tfloat v1p_distance &lt;- 0.0;\tfloat v1p_area &lt;- 0.0;\tfloat v2p_standing &lt;- 1.0;\tfloat v2p_price &lt;- 1.0;\tfloat v2p_distance &lt;- 1.0;\tfloat v2p_area &lt;- 1.0;\tfloat v1c_standing &lt;- 0.0;\tfloat v1c_price &lt;- 0.0;\tfloat v1c_distance &lt;- 0.0;\tfloat v1c_area &lt;- 0.0;\tfloat v2c_standing &lt;- 0.0;\tfloat v2c_price &lt;- 0.0;\tfloat v2c_distance &lt;- 0.0;\tfloat v2c_area &lt;- 0.0;\t\t//Lists that will store the different criteria to use for each method linked with their weights\tlist criteria_WM &lt;- [[\"name\"::\"standing\", \"weight\" :: weight_standing],[\"name\"::\"price\", \"weight\" :: weight_price],[\"name\"::\"distance\", \"weight\" ::weight_distance],[\"name\"::\"area\", \"weight\" :: weight_area]]; \tlist criteria_Electre &lt;- [[\"name\"::\"standing\", \"weight\" :: weight_standing, \"p\"::p_standing, \"q\"::q_standing, \"v\"::v_standing, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: weight_price, \"p\"::p_price, \"q\"::q_price, \"v\"::v_price,  \"maximize\" :: true],[\"name\"::\"distance\", \"weight\" ::weight_distance, \"p\"::p_distance, \"q\"::q_distance, \"v\"::v_distance,  \"maximize\" :: true],[\"name\"::\"area\", \"weight\" :: weight_area,  \"p\"::p_area, \"q\"::q_area, \"v\"::v_area,  \"maximize\" :: true]]; \tlist criteria_Promethee &lt;- [[\"name\"::\"standing\", \"weight\" :: weight_standing, \"p\"::p_standing, \"q\"::q_standing, \"s\"::s_standing, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: weight_price, \"p\"::p_price, \"q\"::q_price, \"s\"::s_price,  \"maximize\" :: true],[\"name\"::\"distance\", \"weight\" ::weight_distance, \"p\"::p_distance, \"q\"::q_distance, \"s\"::s_distance,  \"maximize\" :: true],[\"name\"::\"area\", \"weight\" :: weight_area,  \"p\"::p_area, \"q\"::q_area, \"s\"::s_area,  \"maximize\" :: true]];  \tlist criteria_ET &lt;- [[\"name\"::\"standing\", \"s1\"::s1_standing, \"s2\"::s2_standing, \"v1p\"::v1p_standing, \"v2p\"::v2p_standing, \"v1c\"::v1c_standing, \"v2c\"::v2c_standing,\"maximize\" :: true],[\"name\"::\"price\", \"s1\"::s1_price, \"s2\"::s2_price, \"v1p\"::v1p_price, \"v2p\"::v2p_price, \"v1c\"::v1c_price, \"v2c\"::v2c_price,  \"maximize\" :: true],[\"name\"::\"distance\", \"s1\"::s1_distance, \"s2\"::s2_distance, \"v1p\"::v1p_distance, \"v2p\"::v2p_distance, \"v1c\"::v1c_distance, \"v2c\"::v2c_distance,  \"maximize\" :: true],[\"name\"::\"area\", \"s1\"::s1_area, \"s2\"::s2_area, \"v1p\"::v1p_area, \"v2p\"::v2p_area, \"v1c\"::v1c_area, \"v2c\"::v2c_area, \"maximize\" :: true]];\t\t\tinit {\t\tcreate people;\t\tgeometry free_space &lt;- copy(shape);\t\tfree_space &lt;- free_space - 10;\t\tcreate house number: 15 {\t\t\tlocation &lt;- any_location_in (free_space);\t\t\tfree_space &lt;- free_space - (shape + 10);\t\t}\t}\t\treflex reset_selected {\t\task house {\t\t\tis_selected_WM &lt;- false;\t\t\tis_selected_electre &lt;- false;\t\t\tis_selected_promethee &lt;- false;\t\t\tis_selected_ET &lt;- false;\t\t}\t\tcriteria_WM &lt;- [[\"name\"::\"standing\", \"weight\" :: weight_standing],[\"name\"::\"price\", \"weight\" :: weight_price],[\"name\"::\"distance\", \"weight\" ::weight_distance],[\"name\"::\"area\", \"weight\" :: weight_area]]; \t\tcriteria_Electre &lt;- [[\"name\"::\"standing\", \"weight\" :: weight_standing, \"p\"::p_standing, \"q\"::q_standing, \"v\"::v_standing, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: weight_price, \"p\"::p_price, \"q\"::q_price, \"v\"::v_price,  \"maximize\" :: true],[\"name\"::\"distance\", \"weight\" ::weight_distance, \"p\"::p_distance, \"q\"::q_distance, \"v\"::v_distance,  \"maximize\" :: true],[\"name\"::\"area\", \"weight\" :: weight_area,  \"p\"::p_area, \"q\"::q_area, \"v\"::v_area,  \"maximize\" :: true]]; \t\tcriteria_Promethee &lt;- [[\"name\"::\"standing\", \"weight\" :: weight_standing, \"p\"::p_standing, \"q\"::q_standing, \"s\"::s_standing, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: weight_price, \"p\"::p_price, \"q\"::q_price, \"s\"::s_price,  \"maximize\" :: true],[\"name\"::\"distance\", \"weight\" ::weight_distance, \"p\"::p_distance, \"q\"::q_distance, \"s\"::s_distance,  \"maximize\" :: true],[\"name\"::\"area\", \"weight\" :: weight_area,  \"p\"::p_area, \"q\"::q_area, \"s\"::s_area,  \"maximize\" :: true]]; \t\tcriteria_ET &lt;- [[\"name\"::\"standing\", \"s1\"::s1_standing, \"s2\"::s2_standing, \"v1p\"::v1p_standing, \"v2p\"::v2p_standing, \"v1c\"::v1c_standing, \"v2c\"::v2c_standing,\"maximize\" :: true],[\"name\"::\"price\", \"s1\"::s1_price, \"s2\"::s2_price, \"v1p\"::v1p_price, \"v2p\"::v2p_price, \"v1c\"::v1c_price, \"v2c\"::v2c_price,  \"maximize\" :: true],[\"name\"::\"distance\", \"s1\"::s1_distance, \"s2\"::s2_distance, \"v1p\"::v1p_distance, \"v2p\"::v2p_distance, \"v1c\"::v1c_distance, \"v2c\"::v2c_distance,  \"maximize\" :: true],[\"name\"::\"area\", \"s1\"::s1_area, \"s2\"::s2_area, \"v1p\"::v1p_area, \"v2p\"::v2p_area, \"v1c\"::v1c_area, \"v2c\"::v2c_area, \"maximize\" :: true]];\t}\t}\tspecies people  {\taspect default {\t\tdraw sphere(2) color: °red;\t}\t\treflex choose_house_weighted_means {\t\tlist&lt;list&gt; cands &lt;- houses_eval();\t\tint choice &lt;- weighted_means_DM(cands, criteria_WM);\t\tif (choice &gt;= 0) {\t\t\task (house at choice) {is_selected_WM &lt;- true;}\t\t}\t}\t\treflex choose_house_promethee {\t\tlist&lt;list&gt; cands &lt;- houses_eval();\t\tint choice &lt;- promethee_DM(cands, criteria_Promethee);\t\tif (choice &gt;= 0) {\t\t\task (house at choice) {is_selected_promethee &lt;- true;}\t\t}\t}\treflex choose_house_electre {\t\tlist&lt;list&gt; cands &lt;- houses_eval();\t\tint choice &lt;- electre_DM(cands, criteria_Electre, 0.7);\t\tif (choice &gt;= 0) {\t\t\task (house at choice) {is_selected_electre &lt;- true;}\t\t}\t}\treflex choose_house_evidence_theory {\t\tlist&lt;list&gt; cands &lt;- houses_eval();\t\tint choice &lt;- evidence_theory_DM(cands, criteria_ET, true);\t\tif (choice &gt;= 0) {\t\t\task (house at choice) {is_selected_ET &lt;- true;}\t\t}\t}\t\tlist&lt;list&gt; houses_eval {\t\tlist&lt;list&gt; candidates;\t\tloop bat over: house {\t\t\tlist&lt;float&gt; cand;\t\t\tadd bat.standing / 5 to: cand;\t\t\tadd ((500000 - bat.price) / 500000) to: cand;\t\t\tadd ((100 - (self distance_to bat)) / 100) to: cand;\t\t\tadd (bat.shape.area / 15^2) to: cand;\t\t\tadd cand to: candidates;\t\t}\t\treturn candidates;\t}\t}species house {\tbool is_selected_WM &lt;- false;\tbool is_selected_electre &lt;- false;\tbool is_selected_promethee &lt;- false;\tbool is_selected_ET &lt;- false;\tgeometry shape &lt;- square(5 + rnd(10));\tfloat price &lt;- 100000.0 + rnd (400000);\tint standing &lt;- rnd(5);\trgb color &lt;- rgb(255 * (1 - standing/5.0),255 * (1 - standing/5.0),255);\tfloat height &lt;- price / 50000;\taspect weighted_means {\t\tif (is_selected_WM) {\t\t\tdraw shape + 2.0 color: °red;\t\t}\t\tdraw shape color: color depth: height;\t}\taspect electre_means {\t\tif (is_selected_electre) {\t\t\tdraw shape + 2.0 color: °red;\t\t}\t\tdraw shape color: color depth: height;\t}\taspect promethee_means {\t\tif (is_selected_promethee) {\t\t\tdraw shape + 2.0 color: °red;\t\t}\t\tdraw shape color: color depth: height;\t}\taspect evidence_theory_means {\t\tif (is_selected_ET) {\t\t\tdraw shape + 2.0 color: °red;\t\t}\t\tdraw shape color: color depth: height;\t}}experiment multicriteria type: gui {\tparameter \"weight of the standing criterion\" var:weight_standing category: \"Weight\";\tparameter \"weight of the price criterion\" var:weight_price category: \"Weight\";\tparameter \"weight of the distance criterion\" var:weight_distance category: \"Weight\";\tparameter \"weight of the area criterion\" var:weight_area category: \"Weight\";\tparameter \"preference threshold of the standing criterion\" var:p_standing category: \"Preference\";\tparameter \"preference threshold of the price criterion\" var:p_price category: \"Preference\";\tparameter \"preference threshold of the distance criterion\" var:p_distance category: \"Preference\";\tparameter \"preference threshold of the area criterion\" var:p_area category: \"Preference\";\tparameter \"indifference threshold of the standing criterion\" var:q_standing category: \"Indifference\";\tparameter \"indifference threshold of the price criterion\" var:q_price category: \"Indifference\";\tparameter \"indifference threshold of the distance criterion\" var:q_distance category: \"Indifference\";\tparameter \"indifference threshold of the area criterion\" var:q_area category: \"Indifference\";\tparameter \"veto threshold of the standing criterion\" var:v_standing category: \"Veto\";\tparameter \"veto threshold of the price criterion\" var:v_price category: \"Veto\";\tparameter \"veto threshold of the distance criterion\" var:v_distance category: \"Veto\";\tparameter \"veto threshold of the area criterion\" var:v_area category: \"Veto\";\tparameter \"max prefence value of the standing criterion\" var:v_standing category: \"Max preference value\";\tparameter \"max prefence value of the price criterion\" var:v_price category: \"Max preference value\";\tparameter \"max prefence value of the distance criterion\" var:v_distance category: \"Max preference value\";\tparameter \"max prefence value of the area criterion\" var:v_area category: \"Max preference value\";\tparameter \"min criterion threshold of the standing criterion\" var:s1_standing category: \"Evidence Theory\";\tparameter \"min criterion threshold of the price criterion\" var:s1_price category: \"Evidence Theory\";\tparameter \"min criterion threshold of the distance criterion\" var:s1_distance category: \"Evidence Theory\";\tparameter \"min criterion threshold of the area criterion\" var:s1_area category: \"Evidence Theory\";\tparameter \"max criterion threshold of the standing criterion\" var:s2_standing category: \"Evidence Theory\";\tparameter \"max criterion threshold of the price criterion\" var:s2_price category: \"Evidence Theory\";\tparameter \"max criterion threshold of the distance criterion\" var:s2_distance category: \"Evidence Theory\";\tparameter \"max criterion threshold of the area criterion\" var:s2_area category:\"Evidence Theory\";\tparameter \"min preference of the standing criterion\" var:v1p_standing category: \"Evidence Theory\";\tparameter \"min preference of the price criterion\" var:v1p_price category: \"Evidence Theory\";\tparameter \"min preference of the distance criterion\" var:v1p_distance category: \"Evidence Theory\";\tparameter \"min preference of the area criterion\" var:v1p_area category: \"Evidence Theory\";\tparameter \"max preference of the standing criterion\" var:v2p_standing category: \"Evidence Theory\";\tparameter \"max preference of the price criterion\" var:v2p_price category: \"Evidence Theory\";\tparameter \"max preference of the distance criterion\" var:v2p_distance category: \"Evidence Theory\";\tparameter \"max preference of the area criterion\" var:v2p_area category: \"Evidence Theory\";\tparameter \"min rejection of the standing criterion\" var:v1c_standing category: \"Evidence Theory\";\tparameter \"min rejection of the price criterion\" var:v1c_price category: \"Evidence Theory\";\tparameter \"min rejection of the distance criterion\" var:v1c_distance category: \"Evidence Theory\";\tparameter \"min rejection of the area criterion\" var:v1c_area category: \"Evidence Theory\";\tparameter \"max rejection of the standing criterion\" var:v2c_standing category: \"Evidence Theory\";\tparameter \"max rejection of the price criterion\" var:v2c_price category: \"Evidence Theory\";\tparameter \"max rejection of the distance criterion\" var:v2c_distance category: \"Evidence Theory\";\tparameter \"max rejection of the area criterion\" var:v2c_area category: \"Evidence Theory\";\toutput {\t\tdisplay Map_Weighted_Means type: opengl{\t\t\tspecies house aspect: weighted_means;\t\t\tspecies people;\t\t}\t\tdisplay Map_Electre type: opengl{\t\t\tspecies house aspect: electre_means;\t\t\tspecies people;\t\t}\t\tdisplay Map_Promethee type: opengl{\t\t\tspecies house aspect: promethee_means;\t\t\tspecies people;\t\t}\t\tdisplay Map_Evidence_theory type: opengl{\t\t\tspecies house aspect: evidence_theory_means;\t\t\tspecies people;\t\t}\t}}",
        "url":"/wiki/Multicriteria-decision-Multicriteria.html"
      }
      ,
    
      "wiki-multicriteria-decision-html": {
        "title": "Multicriteria decision",
        "content": "Multicriteria decisionThis sub-section is composed of the following models :  Multicriteria",
        "url":"/wiki/Multicriteria-decision.html"
      }
      ,
    
      "wiki-navigatingworkspace-html": {
        "title": "Navigating in the Workspace",
        "content": "Navigating in the WorkspaceAll the models that you edit or run using GAMA are accessible from a central location: the Navigator, which is always on the left-hand side of the main window and cannot be closed. This view presents the models currently present in (or linked from) your workspace.Table of contents  Navigating in the Workspace          The Different Categories of Models                  Models library          Plugin models          User models                    Inspect Models      Moving Models Around      Closing and Deleting Projects      The Different Categories of ModelsIn the Navigator, models are organized in three different categories: Models library, Plugin models, and User models. This organization is purely logical and does not reflect where the models are actually stored in the workspace (or elsewhere). Whatever their actual location, model files need to be stored in projects, which may contain also other files (called resources) necessary for the models to function. A project may of course contain several model files, especially if they are importing each other, if they represent different models on the same topic, or if they share the same resources.Models libraryThis category represents the models that are shipped with each version of GAMA. They do not reside in the workspace, but are considered as linked from it. This link is established every time a new workspace is created. Their actual location is within a plugin (msi.gama.models) of the GAMA application. This category contains four main projects in GAMA 1.6.1, which are further refined in folders and sub-folders that contain model files and resources.It may happen, in some occasions, that the library of models is not synchronized with the version of GAMA that uses your workspace. This is the case if you use different versions of GAMA to work with the same workspace. In that case, it is required that the library be manually updated. This can be done using the “Update library” item in the contextual menu.To look up for a particular model in the library, users can use the “Search for file” menu item. A search dialog is then displayed, which allows to look for models by their title (for example, models containing “GIS” in the example below).Plugin modelsThis category represents the models that are related to a specific plugin (additional or integrated by default). The corresponding plugin is shown between parenthesis.For each projects, you can see the list of plugins needed, and a caption to show you if the plugin is actually installed in your GAMA version or not : green if the plugin is installed, red otherwise.User modelsThis category regroups all the projects that have been created or imported in the workspace by the user. Each project is actually a folder that resides in the folder of the workspace (so they can be easily located from within the filesystem). Any modification (addition, removal of files…) made to them in the file system (or using another application) is immediately reflected in the Navigator and vice-versa.Model files, although it is by no means mandatory, usually reside in a sub-folder of the project called “models”.Inspect ModelsEach models is presented as a node in the navigation workspace, including Experiment buttons and/or Requires node and/or Uses node.      Experiment button : Experiment button are present if your model contains experiments (it is usually the case !). To run the corresponding experiment, just click on it. To learn more about running experiments, jump into this section.        Require node : The node Require is present if your model uses some plugins (additional or integrated by default). Each plugin is listed in this node, with a green icon if the plugin is already installed in your GAMA, and a red one if it is not the case. If the plugin you want in not installed, an error will be raised in your model. Please read about how to install plugins to learn some more about it.    Uses node : The node Uses is present if your model uses some external resources, and if the path to the resource is correct (if the path to the resource is not correct, the resource will not be displayed under Uses)Moving Models AroundModel files, as well as resources, or even complete projects, can be moved around between the “Models Library”/”Plugin Models” and “Users Models” categories, or within them, directly in the Navigator. Drag’n drop operations are supported, as well as copy and paste. For example, the model “Life.gaml”, present in the “Models Library”, can perfectly be copied and then pasted in a project in the “Users Model”. This local copy in the workspace can then be further edited by the user without altering the original one.Closing and Deleting ProjectsUsers can choose to get rid of old projects by either closing or deleting them. Closing a project means that it will still reside in the workspace (and be still visible, although a bit differently, in the Navigator) but its model(s) won’t participate to the build process and won’t be displayable until the project is opened again.Deleting a project must be invoked when the user wants this project to not appear in the workspace anymore (unless, that is, it is imported again). Invoking this command will effectively make the workspace “forget” about this project, and this can be further doubled with a deletion of the projects resources and models from the filesystem.",
        "url":"/wiki/NavigatingWorkspace.html"
      }
      ,
    
      "wiki-newversionchanges-html": {
        "title": "Java version",
        "content": "Java versionDue to changes in the libraries used by GAMA 1.7, this version now requires JDK/JVM 1.8 to run.Changes between 1.6.1 and 1.7 that can influence the dynamics of models  Initialization order between the initialization of variables and the execution of the init block in gridsinit -&gt; vars in 1.6.1 / vars -&gt; init in 1.7  Initialization order of agents -&gt; now, the init block of the agents are not executed at the end of the global init, but during it.put a sample model to explain the order of creation and its differences  Initialization of vars to their default valuemap ? list ?  Systematic casting and verification of typesgive examples  header of CSV files: be careful, in GAMA 1.7, if the first line is detected as a header, it is not read when the file is casted as a matrix (so the first row of the matrix is not the header, but the first line of data)gives examples  the step of batch experiments is now executed after all repetitions of simulations are done (not after each one). They can however be still accessed using the attributes simulations (see Batch.gaml in Models Library)  signal and diffuse have been merged into a single statement  facets do not accept a space between their identifier and the : anymore.  simplification of equation/solve statements and deprecation of old facets  in FIPA skill, contentis replaced everywhere with contents  in FIPA skill, receivers is replaced everywhere with to  in FIPA skill, messages is replaced by mailbox  The pseudo-attribute user_location has been removed (not deprecated, unfortunately) and replaced by the “unit” #user_location.  The actions called by an event layer do not need anymore to define point and list&lt;agent&gt; arguments to receive the mouse location and the list of agents selected. Instead, they can now use #user_location and they have to compute the selected agents by themselves (using an arbitrary function).  The random number generators now better handle seeding (larger range), but it can change the series of values previously obtained from a given seed in 1.6.1  all models now have a starting_date and a current_date. They then dont begin at an hypothetical “zero” date, but at the epoch date defined by ISO 8601 (1970/1/1). It should not change models that dont rely on dates, except that:  #year (and its nicknames #y, #years) and #month (and its nickname #month) do not longer have a default value (of resp. 30 days and 360 days). Instead, they are always evaluated against the current_date of the model. If no starting_date is defined, the values of #month and #year will then depend on the sequence of months and year since epoch day.  as_time, as_system_time, as_date and as_system_date have been removedEnhancements in 1.7  Simulations  simulations can now be run in parallel withing an experiment (with their outputs, displays, etc.)  batch experiments inherit from this possibility and can now run their repetitions in parallel too.      concurrency between agents is now possible and can be controlled on a species/grid/ask basis (from multi-threaded concurrency to complete parallelism within a species/grid or between the targets of an ask statement)    Language  gama : a new immutable agent that can be invoked to change preferences or access to platform-only properties (like machine-time)  date : new data type that offers the possibility to use a real calendar, to define a starting_date and to query a current_date from a simulation, to parse dates from date files or to output them in custom formats. Dates can be added, subtracted, compared. Various new operators (minus_months, etc.) allow for a fine manipulation of their data. Time units (#sec, #s, #mn, #minute, #h, #hour, #day, etc.) can be used in conjunction with them. Interval of dates (date1 to date2) can be created and used as a basis for loops, etc. Various simple operators allow for defining conditions based on the current_date (after(date1), before(date2), since(date1), etc.).  font in draw  BDI control architecture for agents  file management, new operators, new statements, new skills(?), new built-in variables, files can now download their contents from the web by using standard http: https: addresses instead of file paths.  The save can now directly manipulate files and … save them. So something like save shape_file(\"bb.shp\", my_agents collect each.shape); is possible.  status statement (to manipulate the status line from GAML)  new operators (sum_of, product_of, etc.)  casting of files works  co-modeling (importation of micro-models that can be managed within a macro-model)  populations of agents can now be easily exported to CSV files using the save statement  Simple messaging skill between agents  Terminal commands can now be issued from within GAMA using the console operator  New status statement allows to change the text of the status.  light statement in 3D display provides the possibility to custom your lights (point lights, direction lights, spot lights)      on_change: facet for attributes/parameters allows to define a sequence of statements to run whenever the value changes.    Data importation  draw of complex shapes through obj file  new types fo files are taken into account: geotiff and dxf  viewers for common files      navigator: better overview of model files and their support files, addition of plugin models    Editor  doc on built-in elements, templates, shortcuts to common tasks, hyperlinks to files used  improvement in time, gathering of infos/todos      warnings can be removed from model files    Models library:      New models (make a list)    Preferences  For performances and bug fixes in displays      OpenGL displays should be up to 3 times faster in rendering    Simulation displays  fullscreen mode for displays (ESC key)  CTRL+O for overlay and CTRL+L for layers side controls  cleaner OpenGL displays (less garbage, better drawing of lines, rotation helper, sticky ROI, etc.)  possibility to use a new OpenGl pipeline and to define keystoning parameters (for projections)  faster java2D displays (esp. on zoom)  better user interaction (mouse move, hover, key listener)  a whole new set of charts  getting values when moving the mouse on charts  possibility to declare permanent layout:  + #splitted, #horizontal, #vertical, #stacked in the output section to automatically layout the display view.  Changing simulation names is reflected in their display titles (and it can be dynamic)      OpenGL displays now handle rotations of 2D and 3D shapes, combinations of textures and colours, and keystoning    Error view  Much faster (up to 100x !) display of errors      Contextual menu to copy the text of errors to clipboard or open the editor on it    Validation  Faster validation of multi-file models (x2 approx.)  Much less memory used compared to 1.6.1 (/10 approx.)      No more “false positive” errors    Console  Interactive console allows to directly interact with agents (experiments, simulations and any agent) and get a direct feedback on the impact of code execution using a new interpreter integrated with the console. Available in the modeling perspective (to interact with the new gama agent) as well as the simulation perspective (to interact with the current experiment agent).      Console now accepts colored text output    Monitor view      monitors can have colors    GAMA-wide online help on the language      A global search engine is now available in the top-right corner of the GAMA window to look for GAML idioms    Serialization  Serialize simulations and replay them (to come)      Serialization and deserialization of agents between simulations (to come)    Allow TCP, UDP and MQQT communications between agents in different simulations (to come)",
        "url":"/wiki/NewVersionChanges.html"
      }
      ,
    
      "wiki-olderversions-html": {
        "title": "Versions of GAMA",
        "content": "Versions of GAMAGAMA exists since 2007 and has undergone a number of changes since its first release, materialized by different versions of the platform. Although we do not maintain these versions anymore, some are still used in lectures or specific projects. This page provides a list of these versions and, for each of them, a summary of its features and a link to its documentation in PDF format.GAMA 1.6.1 (June 2014)Version 1.6.1 is the current version of GAMA. It improves many features over version 1.6 :  OpenGL displays improvements  Various enhancements for displays (overlay, focus, light, trace, DEM, colors with alpha, addition of CSS colors..)  Compilation of models (errors tracked, memory, report of errors, etc.)  Validation of stochastic models (random now extended to every areas of a model, incl. the operations on HashSets)  GIS file handling (esp. with the possibility to pass a custom CRS)  Handling of OSM data  Comparison of raster and vectorial maps  Traffic moving skill improvement  Handling of various other file types (uniform constructors, …)  Documentation itself (both online and on the website)  Testing framework and debugging tools (trace, sample)  Speed of computation of several spatial operators  Experiments (permanent output, access to the duration of cycles)  Type system (complete parametric definitions of types)  Addition of several 3D operations  Auto-update mechanism of plugins  Automatic importation of files/projects when double-clicked in the OS (or transmitted by command line arguments)  Definition of charts (dynamic data lists, marker type, range, etc.)Documentation:  Available onlineGAMA 1.6 (July 2013)This version introduced many features over 1.5.1 :  correction of bugs (in particular, freeze, memory consumption)  performance improvement (in particular for “big” models)  further simplification of the GAML language (assignments, manipulation of containers)  integration of an agent browser  improvement of the 3D integration (new operators, new display facet bug corrections…)  removing of the environment block  more user/simulation interaction (event statement)Documentation:  Documentation in PDFGAMA 1.5 / 1.5.1 (July &amp; November 2012)Key points :  Improvement of the performance and stability  Simplification of the modeling language (omissible facets, types as declarations, etc.)  Integration of non-spatial graphs  Introduction of OpenGL displays  Improvement of the user interaction in the simulation perspective  Generalization of the notion of experimentVersion 1.5.1 improved some features of 1.5 :  correction of bugs (in particular, no more freezes when reloading an experiment)  performance improvement (in particular for “big” models)  improvement of the 3D integration (new operators to add a “z” to geometries, bug corrections…)  new models (driving_traffic, Vote, 3D models)Documentation:  Documentation in PDFGAMA 1.4 (December 2011)This versions introduced the new integrated development environment based on XText, as well as a completely revamped modeling language, not based on XML anymore, and much easier to read and write. It also introduced new important types such as geometry, graph, path and topology in order to ease the spatial manipulation of agents.Key points :  Deep refactoring of the source code  New programming language (based on XText)  Integration of a true IDE based on Eclipse/Xtext  Deep refactoring of the meta-model  Better integration of multi-level species  New important notion: topology  New variable types: geometry, graph, path, topology  Many more novelties/improvements/enrichments…Documentation:  Documentation in PDFGAMA 1.3 (August 2010)Version 1.3 added numerous operators to manipulate GIS data. Moreover, it integrated new features like the possibility to define custom displays and to define multi-level models. It allowed to use clustering and decision-making methods. And it greatly improved the performances of the platform.Key points :  Important improvement of the performance of the platform  Improvement of the simulation display  Enrichment of the spatial operators/actions  Integration of multi-level models  Integration of clustering algorithms  Integration of decision-making algorithmsDocumentation:  Documentation in PDFGAMA 1.1 (October 2009)The first “real” release of GAMA, which incorporated several changes, including an XML editor coupled with the simulator, the possibility to take snapshots of every graphical window, save parameters and monitors for future reuse, save charts as CSV files, and definitely fixed the memory leaks observed in previous internal versions.Key points :  Transformation into a more complete and versatile platform  Addition of batch controllers  Integration of a true modeling language (based on XML)  First release as an open-source projectDocumentation:  Guidebook of GAMA 1.1  Training session on GAMA 1.1 (Hanoi)",
        "url":"/wiki/OlderVersions.html"
      }
      ,
    
      "wiki-operators-html": {
        "title": "Operators",
        "content": "OperatorsThis file is automatically generated from java files. Do Not Edit It.DefinitionOperators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function.Most of them use a classical prefixed functional syntax (i.e. operator_name(operand1, operand2, operand3), see below), with the exception of arithmetic (e.g. +, /), logical (and, or), comparison (e.g. &gt;, &lt;), access (., [..]) and pair (::) operators, which require an infixed notation (i.e. operand1 operator_symbol operand1).The ternary functional if-else operator, ? :, uses a special infixed syntax composed with two symbols (e.g. operand1 ? operand2 : operand3). Two unary operators (- and !) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g. ` - 10, ! (operand1 or operand2)`).Finally, special constructor operators ({...} for constructing points, [...] for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. {1,2,3}, [operand1, operand2, ..., operandn] or [key1::value1, key2::value2... keyn::valuen]).With the exception of these special cases above, the following rules apply to the syntax of operators:  if they only have one operand, the functional prefixed syntax is mandatory (e.g. operator_name(operand1))  if they have two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2)) or the infixed syntax (e.g. operand1 operator_name operand2) can be used.  if they have more than two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2, ..., operand)) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. operand1 operator_name(operand2, ..., operand)) can be used.All of these alternative syntaxes are completely equivalent.Operators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.Priority between operatorsThe priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.GAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely:  the constructor operators, like ::, used to compose pairs of operands, have the lowest priority of all operators (e.g. a &gt; b :: b &gt; c will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, [a &gt; 10, b &gt; 5] will return a list of boolean values.  it is followed by the ?: operator, the functional if-else (e.g. ` a &gt; b ? a + 10 : a - 10` will return the result of the if-else).  next are the logical operators, and and or (e.g. a &gt; b or b &gt; c will return the value of the test)  next are the comparison operators (i.e. &gt;, &lt;, &lt;=, &gt;=, =, !=)  next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)  next the unary operators - and !  next the access operators . and [] (e.g. {1,2,3}.x &gt; 20 + {4,5,6}.y will return the result of the comparison between the x and y ordinates of the two points)  and finally the functional operators, which have the highest priority of all.Using actions as operatorsActions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.For instance, if the following species is defined:species spec1 {        int min(int x, int y) {                return x &gt; y ? x : y;        }}Any agent instance of spec1 can use min as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:global {        init {                create spec1;                spec1 my_agent &lt;- spec1[0];                int the_min &lt;- my_agent min(10,20); // or min(my_agent, 10, 20);        }}If the action doesn’t have any operands, the syntax to use is my_agent the_action(). Finally, if it does not return a value, it might still be used but is considering as returning a value of type unknown (e.g. unknown result &lt;- my_agent the_action(op1, op2);).Note that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).Table of ContentsOperators by categories3Dbox, cone3D, cube, cylinder, dem, hexagon, pyramid, rgb_to_xyz, set_z, sphere, teapot,Arithmetic operators-, /, [^](#^), [](#), +, abs, acos, asin, atan, atan2, ceil, cos, cos_rad, div, even, exp, fact, floor, hypot, is_finite, is_number, ln, log, mod, round, signum, sin, sin_rad, sqrt, tan, tan_rad, tanh, with_precision,BDIand, eval_when, get_about, get_agent, get_agent_cause, get_decay, get_dominance, get_familiarity, get_intensity, get_lifetime, get_liking, get_praiseworthiness, get_priority, get_solidarity, get_super_intention, new_emotion, new_predicate, new_social_link, or, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_liking, set_solidarity, set_truth, with_lifetime, with_praiseworthiness, with_priority, with_values,Casting operatorsas, as_int, as_matrix, font, is, is_skill, list_with, matrix_with, species, to_gaml, topology,Color-related operators-, /, [](#), +, blend, brewer_colors, brewer_palettes, grayscale, hsb, mean, median, rgb, rnd_color, sum,Comparison operators!=, &lt;, &lt;=, =, &gt;, &gt;=, between,Containers-related operators-, ::, +, accumulate, among, at, collect, contains, contains_all, contains_any, count, distinct, empty, every, first, first_with, get, group_by, in, index_by, inter, interleave, internal_at, internal_integrated_value, last, last_with, length, max, max_of, mean, mean_of, median, min, min_of, mul, one_of, product_of, range, reverse, shuffle, sort_by, sum, sum_of, union, variance_of, where, with_max_of, with_min_of,Date-related operators-, !=, +, &lt;, &lt;=, =, &gt;, &gt;=, after, before, between, every, milliseconds_between, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_weeks, minus_years, months_between, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_weeks, plus_years, since, to, until, years_between,DatesDriving operatorsas_driving_graph,edgeedge_between,EDP-related operatorsdiff, diff2, internal_zero_order_equation,Files-related operatorscrs, file, file_exists, folder, get, new_folder, osm_file, read, writable,FIPA-related operatorsconversation, message,Graphs-related operatorsadd_edge, add_node, adjacency, agent_from_geometry, all_pairs_shortest_path, alpha_index, as_distance_graph, as_edge_graph, as_intersection_graph, as_path, beta_index, betweenness_centrality, biggest_cliques_of, connected_components_of, connectivity_index, contains_edge, contains_vertex, degree_of, directed, edge, edge_between, edge_betweenness, edges, gamma_index, generate_barabasi_albert, generate_complete_graph, generate_watts_strogatz, grid_cells_to_graph, in_degree_of, in_edges_of, layout, load_graph_from_file, load_shortest_paths, maximal_cliques_of, nb_cycles, neighbors_of, node, nodes, out_degree_of, out_edges_of, path_between, paths_between, predecessors_of, remove_node_from, rewire_n, source_of, spatial_graph, successors_of, sum, target_of, undirected, use_cache, weight_of, with_optimizer_type, with_weights,Grid-related operatorsas_4_grid, as_grid, as_hexagonal_grid, grid_at, path_between,Iterator operatorsaccumulate, as_map, collect, count, distribution_of, distribution_of, distribution_of, distribution2d_of, distribution2d_of, distribution2d_of, first_with, frequency_of, group_by, index_by, last_with, max_of, mean_of, min_of, product_of, sort_by, sum_of, variance_of, where, with_max_of, with_min_of,List-related operatorscopy_between, index_of, last_index_of,Logical operators:, !, ?, and, or,Map comparaison operatorsfuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,Map-related operatorsas_map, index_of, last_index_of,Materialmaterial,Matrix-related operators-, /, ., [](#), +, append_horizontally, append_vertically, column_at, columns_list, determinant, eigenvalues, index_of, inverse, last_index_of, row_at, rows_list, shuffle, trace, transpose,multicriteria operatorselectre_DM, evidence_theory_DM, promethee_DM, weighted_means_DM,Path-related operatorsagent_from_geometry, all_pairs_shortest_path, as_path, load_shortest_paths, path_between, path_to, paths_between, use_cache,Points-related operators-, /, [](#), +, &lt;, &lt;=, &gt;, &gt;=, add_point, angle_between, any_location_in, centroid, closest_points_with, farthest_point_to, grid_at, norm, point, points_along, points_at, points_on,Random operatorsbinomial, flip, gauss, poisson, rnd, rnd_choice, sample, shuffle, skew_gauss, truncated_gauss,ReverseOperatorsShapearc, box, circle, cone, cone3D, cross, cube, curve, cylinder, ellipse, envelope, geometry_collection, hexagon, line, link, plan, polygon, polyhedron, pyramid, rectangle, sphere, square, squircle, teapot, triangle,Spatial operators-, [](#), +, add_point, agent_closest_to, agent_farthest_to, agents_at_distance, agents_inside, agents_overlapping, angle_between, any_location_in, arc, around, as_4_grid, as_grid, as_hexagonal_grid, at_distance, at_location, box, centroid, circle, clean, closest_points_with, closest_to, cone, cone3D, convex_hull, covers, cross, crosses, crs, CRS_transform, cube, curve, cylinder, dem, direction_between, disjoint_from, distance_between, distance_to, ellipse, envelope, farthest_point_to, farthest_to, geometry_collection, gini, hexagon, hierarchical_clustering, IDW, inside, inter, intersects, line, link, masked_by, moran, neighbors_at, neighbors_of, overlapping, overlaps, partially_overlaps, path_between, path_to, plan, points_along, points_at, points_on, polygon, polyhedron, pyramid, rectangle, rgb_to_xyz, rotated_by, round, scaled_to, set_z, simple_clustering_by_distance, simplification, skeletonize, smooth, sphere, split_at, split_geometry, split_lines, square, squircle, teapot, to_GAMA_CRS, to_rectangles, to_squares, touches, towards, transformed_by, translated_by, triangle, triangulate, union, using, voronoi, with_precision, without_holes,Spatial properties operatorscovers, crosses, intersects, partially_overlaps, touches,Spatial queries operatorsagent_closest_to, agent_farthest_to, agents_at_distance, agents_inside, agents_overlapping, at_distance, closest_to, farthest_to, inside, neighbors_at, neighbors_of, overlapping,Spatial relations operatorsdirection_between, distance_between, distance_to, path_between, path_to, towards,Spatial statistical operatorshierarchical_clustering, simple_clustering_by_distance,Spatial transformations operators-, [](#), +, as_4_grid, as_grid, as_hexagonal_grid, at_location, clean, convex_hull, CRS_transform, rotated_by, scaled_to, simplification, skeletonize, smooth, split_geometry, split_lines, to_GAMA_CRS, to_rectangles, to_squares, transformed_by, translated_by, triangulate, voronoi, without_holes,Species-related operatorsindex_of, last_index_of, of_generic_species, of_species,Statistical operatorsbuild, corR, dbscan, distribution_of, distribution2d_of, frequency_of, gamma_rnd, geometric_mean, gini, harmonic_mean, hierarchical_clustering, kmeans, kurtosis, max, mean, mean_deviation, meanR, median, min, moran, mul, predict, simple_clustering_by_distance, skewness, standard_deviation, sum, variance,Strings-related operators+, &lt;, &lt;=, &gt;, &gt;=, at, char, contains, contains_all, contains_any, copy_between, date, empty, first, in, indented_by, index_of, is_number, last, last_index_of, length, lower_case, replace, replace_regex, reverse, sample, shuffle, split_with, string, upper_case,System., command, copy, dead, eval_gaml, every, user_input,Time-related operatorsdate, string,Types-related operatorsUser control operatorsuser_input,Operators-Possible use:  - (int) —&gt;  int  - (point) —&gt;  point  - (float) —&gt;  float  int - float —&gt;  float  - (int , float) —&gt;  float  int - int —&gt;  int  - (int , int) —&gt;  int  matrix - float —&gt;  matrix  - (matrix , float) —&gt;  matrix  float - matrix —&gt;  matrix  - (float , matrix) —&gt;  matrix  date - float —&gt;  date  - (date , float) —&gt;  date  species - agent —&gt;  container  - (species , agent) —&gt;  container  date - date —&gt;  float  - (date , date) —&gt;  float  matrix - matrix —&gt;  matrix  - (matrix , matrix) —&gt;  matrix  point - int —&gt;  point  - (point , int) —&gt;  point  date - int —&gt;  date  - (date , int) —&gt;  date  point - float —&gt;  point  - (point , float) —&gt;  point  float - float —&gt;  float  - (float , float) —&gt;  float  rgb - rgb —&gt;  rgb  - (rgb , rgb) —&gt;  rgb  int - matrix —&gt;  matrix  - (int , matrix) —&gt;  matrix  container - container —&gt;  container  - (container , container) —&gt;  container  rgb - int —&gt;  rgb  - (rgb , int) —&gt;  rgb  container - unknown —&gt;  container  - (container , unknown) —&gt;  container  point - point —&gt;  point  - (point , point) —&gt;  point  float - int —&gt;  float  - (float , int) —&gt;  float  geometry - geometry —&gt;  geometry  - (geometry , geometry) —&gt;  geometry  matrix - int —&gt;  matrix  - (matrix , int) —&gt;  matrix  geometry - float —&gt;  geometry  - (geometry , float) —&gt;  geometry  map - map —&gt;  map  - (map , map) —&gt;  map  map - pair —&gt;  map  - (map , pair) —&gt;  map  geometry - container&lt;geometry&gt; —&gt;  geometry  - (geometry , container&lt;geometry&gt;) —&gt;  geometryResult:Returns the difference of the two operands.If it is used as an unary operator, it returns the opposite of the operand.Comment:The behavior of the operator depends on the type of the operands.Special cases:  if the left operand is a species and the right operand is an agent of the species, - returns a list containing all the agents of the species minus this agent  if both operands are containers and the right operand is empty, - returns the left operand  if both operands are numbers, performs a normal arithmetic difference and returns a float if one of them is a float.int var7 &lt;- 1 - 1; \t// var7 equals 0int var8 &lt;- 1.0 - 1; \t// var8 equals 0.0int var9 &lt;- 3.7 - 1.2; \t// var9 equals 2.5int var10 &lt;- 3 - 1.2; \t// var10 equals 1.8  if both operands are dates, returns the duration in seconds between  date2 and date1. To obtain a more precise duration, in milliseconds, use milliseconds_between(date1, date2)float var11 &lt;- date1 - date2; \t// var11 equals 598  if one of the operands is a date and the other a number, returns a date corresponding to the date minus the given number as duration (in seconds)date1 - 200  if left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the difference of the operand coordinate with this number.point var13 &lt;- {1, 2} - 4.5; \t// var13 equals {-3.5, -2.5, -4.5}point var14 &lt;- {1, 2} - 4; \t// var14 equals {-3.0,-2.0,-4.0}  if both operands are colors, returns a new color resulting from the subtraction of the two operands, component by componentrgb var15 &lt;- rgb([255, 128, 32]) - rgb('red'); \t// var15 equals rgb([0,128,32])  if one operand is a matrix and the other a number (float or int), performs a normal arithmetic difference of the number with each element of the matrix (results are float if the number is a float.matrix var16 &lt;- 3.5 - matrix([[2,5],[3,4]]); \t// var16 equals matrix([[1.5,-1.5],[0.5,-0.5]])  if both operands are containers, returns a new list in which all the elements of the right operand have been removed from the left onelist&lt;int&gt; var17 &lt;- [1,2,3,4,5,6] - [2,4,9]; \t// var17 equals [1,3,5,6]list&lt;int&gt; var18 &lt;- [1,2,3,4,5,6] - [0,8]; \t// var18 equals [1,2,3,4,5,6]  if one operand is a color and the other an integer, returns a new color resulting from the subtraction of each component of the color with the right operandrgb var19 &lt;- rgb([255, 128, 32]) - 3; \t// var19 equals rgb([252,125,29])  if the left operand is a list and the right operand is an object of any type (except list), - returns a list containing the elements of the left operand minus all the occurrences of this objectlist&lt;int&gt; var20 &lt;- [1,2,3,4,5,6] - 2; \t// var20 equals [1,3,4,5,6]list&lt;int&gt; var21 &lt;- [1,2,3,4,5,6] - 0; \t// var21 equals [1,2,3,4,5,6]  if both operands are points, returns their difference (coordinates per coordinates).point var22 &lt;- {1, 2} - {4, 5}; \t// var22 equals {-3.0, -3.0}  if both operands are a point, a geometry or an agent, returns the geometry resulting from the difference between both geometriesgeometry var23 &lt;- geom1 - geom2; \t// var23 equals a geometry corresponding to difference between geom1 and geom2  if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) reduced by the right-hand operand distancegeometry var24 &lt;- shape - 5; \t// var24 equals a geometry corresponding to the geometry of the agent applying the operator reduced by a distance of 5  if the right-operand is a list of points, geometries or agents, returns the geometry resulting from the difference between the left-geometry and all of the right-geometriesgeometry var25 &lt;- rectangle(10,10) - [circle(2), square(2)]; \t// var25 equals rectangle(10,10) - (circle(2) + square(2))Examples:int var0 &lt;- - (-56); \t// var0 equals 56point var1 &lt;- -{3.0,5.0}; \t// var1 equals {-3.0,-5.0}point var2 &lt;- -{1.0,6.0,7.0}; \t// var2 equals {-1.0,-6.0,-7.0}map var3 &lt;- ['a'::1,'b'::2] - ['b'::2]; \t// var3 equals ['a'::1]map var4 &lt;- ['a'::1,'b'::2] - ['b'::2,'c'::3]; \t// var4 equals ['a'::1]map var5 &lt;- ['a'::1,'b'::2] - ('b'::2); \t// var5 equals ['a'::1]map var6 &lt;- ['a'::1,'b'::2] - ('c'::3); \t// var6 equals ['a'::1,'b'::2]See also:+, [](#), /, milliseconds_between, -,:Possible use:  unknown : unknown —&gt;  unknown  : (unknown , unknown) —&gt;  unknownSee also:?,::Possible use:  any expression :: any expression —&gt;  pair  :: (any expression , any expression) —&gt;  pairResult:produces a new pair combining the left and the right operandsSpecial cases:  nil is not acceptable as a key (although it is as a value). If such a case happens, :: will throw an appropriate error!Possible use:  ! (bool) —&gt;  boolResult:opposite boolean value.Special cases:  if the parameter is not boolean, it is casted to a boolean value.Examples:bool var0 &lt;- ! (true); \t// var0 equals falseSee also:bool, and, or,!=Possible use:  float != float —&gt;  bool  != (float , float) —&gt;  bool  unknown != unknown —&gt;  bool  != (unknown , unknown) —&gt;  bool  date != date —&gt;  bool  != (date , date) —&gt;  bool  float != int —&gt;  bool  != (float , int) —&gt;  bool  int != float —&gt;  bool  != (int , float) —&gt;  boolResult:true if both operands are different, false otherwiseExamples:bool var0 &lt;- 3.0 != 3.0; \t// var0 equals falsebool var1 &lt;- 4.0 != 4.7; \t// var1 equals truebool var2 &lt;- [2,3] != [2,3]; \t// var2 equals falsebool var3 &lt;- [2,4] != [2,3]; \t// var3 equals true#now != #now minus_hours 1 :- truebool var5 &lt;- 3.0 != 3; \t// var5 equals falsebool var6 &lt;- 4.7 != 4; \t// var6 equals truebool var7 &lt;- 3 != 3.0; \t// var7 equals falsebool var8 &lt;- 4 != 4.7; \t// var8 equals trueSee also:=, &gt;, &lt;, &gt;=, &lt;=,?Possible use:  bool ? any expression —&gt;  unknown  ? (bool , any expression) —&gt;  unknownResult:It is used in combination with the : operator: if the left-hand operand evaluates to true, returns the value of the left-hand operand of the :, otherwise that of the right-hand operand of the :Comment:These functional tests can be combined together.Examples:list&lt;string&gt; var0 &lt;- [10, 19, 43, 12, 7, 22] collect ((each &gt; 20) ? 'above' : 'below'); \t// var0 equals ['below', 'below', 'above', 'below', 'below', 'above']rgb color &lt;- (flip(0.3) ? #red : (flip(0.9) ? #blue : #green));See also::,/Possible use:  rgb / float —&gt;  rgb  / (rgb , float) —&gt;  rgb  float / int —&gt;  float  / (float , int) —&gt;  float  point / float —&gt;  point  / (point , float) —&gt;  point  int / int —&gt;  float  / (int , int) —&gt;  float  int / float —&gt;  float  / (int , float) —&gt;  float  matrix / float —&gt;  matrix  / (matrix , float) —&gt;  matrix  point / int —&gt;  point  / (point , int) —&gt;  point  matrix / matrix —&gt;  matrix  / (matrix , matrix) —&gt;  matrix  matrix / int —&gt;  matrix  / (matrix , int) —&gt;  matrix  float / float —&gt;  float  / (float , float) —&gt;  float  rgb / int —&gt;  rgb  / (rgb , int) —&gt;  rgbResult:Returns the division of the two operands.Special cases:  if the right-hand operand is equal to zero, raises a “Division by zero” exception  if one operand is a color and the other a double, returns a new color resulting from the division of each component of the color by the right operand. The result on each component is then truncated.rgb var0 &lt;- rgb([255, 128, 32]) / 2.5; \t// var0 equals rgb([102,51,13])  if the left operand is a point, returns a new point with coordinates divided by the right operandpoint var1 &lt;- {5, 7.5} / 2.5; \t// var1 equals {2, 3}point var2 &lt;- {2,5} / 4; \t// var2 equals {0.5,1.25}  if both operands are numbers (float or int), performs a normal arithmetic division and returns a float.float var3 &lt;- 3 / 5.0; \t// var3 equals 0.6  if one operand is a color and the other an integer, returns a new color resulting from the division of each component of the color by the right operandrgb var4 &lt;- rgb([255, 128, 32]) / 2; \t// var4 equals rgb([127,64,16])See also:[](#), +, -,.Possible use:  matrix . matrix —&gt;  matrix  . (matrix , matrix) —&gt;  matrix  agent . any expression —&gt;  unknown  . (agent , any expression) —&gt;  unknownResult:It has two different uses: it can be the dot product between 2 matrices or return an evaluation of the expression (right-hand operand) in the scope the given agent.Special cases:  if the agent is nil or dead, throws an exception  if both operands are matrix, returns the dot product of themmatrix var0 &lt;- matrix([[1,1],[1,2]]) . matrix([[1,1],[1,2]]); \t// var0 equals matrix([[2,3],[3,5]])  if the left operand is an agent, it evaluates of the expression (right-hand operand) in the scope the given agentunknown var1 &lt;- agent1.location; \t// var1 equals the location of the agent agent1map(nil).keys^Possible use:  int ^ float —&gt;  float  ^ (int , float) —&gt;  float  float ^ float —&gt;  float  ^ (float , float) —&gt;  float  int ^ int —&gt;  float  ^ (int , int) —&gt;  float  float ^ int —&gt;  float  ^ (float , int) —&gt;  floatResult:Returns the value (always a float) of the left operand raised to the power of the right operand.Special cases:  if the right-hand operand is equal to 0, returns 1  if it is equal to 1, returns the left-hand operand.  Various examples of powerfloat var1 &lt;- 2 ^ 3; \t// var1 equals 8.0Examples:float var0 &lt;- 4.84 ^ 0.5; \t// var0 equals 2.2See also:[](#), sqrt,@Same signification as at*Possible use:  int * int —&gt;  int  * (int , int) —&gt;  int  matrix * int —&gt;  matrix  * (matrix , int) —&gt;  matrix  point * point —&gt;  float  * (point , point) —&gt;  float  int * float —&gt;  float  * (int , float) —&gt;  float  float * float —&gt;  float  * (float , float) —&gt;  float  matrix * matrix —&gt;  matrix  * (matrix , matrix) —&gt;  matrix  point * int —&gt;  point  * (point , int) —&gt;  point  float * matrix —&gt;  matrix  * (float , matrix) —&gt;  matrix  geometry * point —&gt;  geometry  * (geometry , point) —&gt;  geometry  point * float —&gt;  point  * (point , float) —&gt;  point  int * matrix —&gt;  matrix  * (int , matrix) —&gt;  matrix  float * int —&gt;  float  * (float , int) —&gt;  float  rgb * int —&gt;  rgb  * (rgb , int) —&gt;  rgb  matrix * float —&gt;  matrix  * (matrix , float) —&gt;  matrix  geometry * float —&gt;  geometry  * (geometry , float) —&gt;  geometryResult:Returns the product of the two operands.Special cases:  if both operands are numbers (float or int), performs a normal arithmetic product and returns a float if one of them is a float.int var1 &lt;- 1 * 1; \t// var1 equals 1  if both operands are points, returns their scalar productfloat var2 &lt;- {2,5} * {4.5, 5}; \t// var2 equals 34.0  if the left-hand operator is a point and the right-hand a number, returns a point with coordinates multiplied by the numberpoint var3 &lt;- {2,5} * 4; \t// var3 equals {8.0, 20.0}point var4 &lt;- {2, 4} * 2.5; \t// var4 equals {5.0, 10.0}  if the left-hand operand is a geometry and the right-hand operand a point, returns a geometry corresponding to the left-hand operand (geometry, agent, point) scaled by the right-hand operand coefficients in the 3 dimensionsgeometry var5 &lt;- shape * {0.5,0.5,2}; \t// var5 equals a geometry corresponding to the geometry of the agent applying the operator scaled by a coefficient of 0.5 in x, 0.5 in y and 2 in z  if one operand is a matrix and the other a number (float or int), performs a normal arithmetic product of the number with each element of the matrix (results are float if the number is a float.matrix&lt;float&gt; m &lt;- (3.5 * matrix([[2,5],[3,4]]));\t//m equals matrix([[7.0,17.5],[10.5,14]])  if one operand is a color and the other an integer, returns a new color resulting from the product of each component of the color with the right operand (with a maximum value at 255)rgb var7 &lt;- rgb([255, 128, 32]) * 2; \t// var7 equals rgb([255,255,64])  if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) scaled by the right-hand operand coefficientgeometry var8 &lt;- circle(10) * 2; \t// var8 equals circle(20)Examples:float var0 &lt;- 2.5 * 2; \t// var0 equals 5.0See also:+, -, /,+Possible use:  string + string —&gt;  string  + (string , string) —&gt;  string  date + float —&gt;  date  + (date , float) —&gt;  date  map + pair —&gt;  map  + (map , pair) —&gt;  map  int + matrix —&gt;  matrix  + (int , matrix) —&gt;  matrix  point + int —&gt;  point  + (point , int) —&gt;  point  rgb + rgb —&gt;  rgb  + (rgb , rgb) —&gt;  rgb  geometry + float —&gt;  geometry  + (geometry , float) —&gt;  geometry  matrix + float —&gt;  matrix  + (matrix , float) —&gt;  matrix  geometry + geometry —&gt;  geometry  + (geometry , geometry) —&gt;  geometry  map + map —&gt;  map  + (map , map) —&gt;  map  float + float —&gt;  float  + (float , float) —&gt;  float  float + int —&gt;  float  + (float , int) —&gt;  float  matrix + matrix —&gt;  matrix  + (matrix , matrix) —&gt;  matrix  date + string —&gt;  string  + (date , string) —&gt;  string  matrix + int —&gt;  matrix  + (matrix , int) —&gt;  matrix  int + int —&gt;  int  + (int , int) —&gt;  int  string + unknown —&gt;  string  + (string , unknown) —&gt;  string  point + point —&gt;  point  + (point , point) —&gt;  point  float + matrix —&gt;  matrix  + (float , matrix) —&gt;  matrix  int + float —&gt;  float  + (int , float) —&gt;  float  point + float —&gt;  point  + (point , float) —&gt;  point  rgb + int —&gt;  rgb  + (rgb , int) —&gt;  rgb  date + int —&gt;  date  + (date , int) —&gt;  date  container + container —&gt;  container  + (container , container) —&gt;  container  container + unknown —&gt;  container  + (container , unknown) —&gt;  container  + (geometry, float, int) —&gt;  geometry  + (geometry, float, int, int) —&gt;  geometryResult:Returns the sum, union or concatenation of the two operands.Special cases:  if one of the operands is nil, + throws an error  if both operands are species, returns a special type of list called meta-population  if the left-hand operand is a geometry and the right-hand operands a float and an integer, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the first right-hand operand (distance), using a number of segments equal to the second right-hand operandgeometry var4 &lt;- circle(5) + (5,32); \t// var4 equals circle(10)  if one operand is a matrix and the other a number (float or int), performs a normal arithmetic sum of the number with each element of the matrix (results are float if the number is a float.matrix var5 &lt;- 3.5 + matrix([[2,5],[3,4]]); \t// var5 equals matrix([[5.5,8.5],[6.5,7.5]])  if both operands are colors, returns a new color resulting from the sum of the two operands, component by componentrgb var6 &lt;- rgb([255, 128, 32]) + rgb('red'); \t// var6 equals rgb([255,128,32])  if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the right-hand operand distance. The number of segments used by default is 8 and the end cap style is #roundgeometry var7 &lt;- circle(5) + 5; \t// var7 equals circle(10)  if the right-operand is a point, a geometry or an agent, returns the geometry resulting from the union between both geometriesgeometry var8 &lt;- geom1 + geom2; \t// var8 equals a geometry corresponding to union between geom1 and geom2  if both operands are numbers (float or int), performs a normal arithmetic sum and returns a float if one of them is a float.int var9 &lt;- 1 + 1; \t// var9 equals 2int var10 &lt;- 1.0 + 1; \t// var10 equals 2.0int var11 &lt;- 1.0 + 2.5; \t// var11 equals 3.5  if the left-hand operand is a string, returns the concatenation of the two operands (the left-hand one beind casted into a string)string var12 &lt;- \"hello \" + 12; \t// var12 equals \"hello 12\"  if both operands are points, returns their sum.point var13 &lt;- {1, 2} + {4, 5}; \t// var13 equals {5.0, 7.0}  if the left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the sum of the operand coordinate with this number.point var14 &lt;- {1, 2} + 4; \t// var14 equals {5.0, 6.0,4.0}point var15 &lt;- {1, 2} + 4.5; \t// var15 equals {5.5, 6.5,4.5}  if one operand is a color and the other an integer, returns a new color resulting from the sum of each component of the color with the right operandrgb var16 &lt;- rgb([255, 128, 32]) + 3; \t// var16 equals rgb([255,131,35])  if the left-hand operand is a geometry and the right-hand operands a float, an integer and one of #round, #square or #flat, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the first right-hand operand (distance), using a number of segments equal to the second right-hand operand and a flat, square or round end cap stylegeometry var17 &lt;- circle(5) + (5,32,#round); \t// var17 equals circle(10)  if one of the operands is a date and the other a number, returns a date corresponding to the date plus the given number as duration (in seconds)date1 + 200  if both operands are list, +returns the concatenation of both lists.list&lt;int&gt; var19 &lt;- [1,2,3,4,5,6] + [2,4,9]; \t// var19 equals [1,2,3,4,5,6,2,4,9]list&lt;int&gt; var20 &lt;- [1,2,3,4,5,6] + [0,8]; \t// var20 equals [1,2,3,4,5,6,0,8]  if the right operand is an object of any type (except a container), + returns a list of the elements of the left operand, to which this object has been addedlist&lt;int&gt; var21 &lt;- [1,2,3,4,5,6] + 2; \t// var21 equals [1,2,3,4,5,6,2]list&lt;int&gt; var22 &lt;- [1,2,3,4,5,6] + 0; \t// var22 equals [1,2,3,4,5,6,0]Examples:map var0 &lt;- ['a'::1,'b'::2] + ('c'::3); \t// var0 equals ['a'::1,'b'::2,'c'::3]map var1 &lt;- ['a'::1,'b'::2] + ('c'::3); \t// var1 equals ['a'::1,'b'::2,'c'::3]map var2 &lt;- ['a'::1,'b'::2] + ['c'::3]; \t// var2 equals ['a'::1,'b'::2,'c'::3]map var3 &lt;- ['a'::1,'b'::2] + [5::3.0]; \t// var3 equals ['a'::1.0,'b'::2.0,5::3.0]See also:-, [](#), /,&lt;Possible use:  float &lt; int —&gt;  bool  &lt; (float , int) —&gt;  bool  int &lt; int —&gt;  bool  &lt; (int , int) —&gt;  bool  point &lt; point —&gt;  bool  &lt; (point , point) —&gt;  bool  int &lt; float —&gt;  bool  &lt; (int , float) —&gt;  bool  date &lt; date —&gt;  bool  &lt; (date , date) —&gt;  bool  float &lt; float —&gt;  bool  &lt; (float , float) —&gt;  bool  string &lt; string —&gt;  bool  &lt; (string , string) —&gt;  boolResult:true if the left-hand operand is less than the right-hand operand, false otherwise.Special cases:  if one of the operands is nil, returns false  if both operands are points, returns true if and only if the left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.bool var5 &lt;- {5,7} &lt; {4,6}; \t// var5 equals falsebool var6 &lt;- {5,7} &lt; {4,8}; \t// var6 equals false  if both operands are String, uses a lexicographic comparison of two stringsbool var7 &lt;- 'abc' &lt; 'aeb'; \t// var7 equals trueExamples:bool var0 &lt;- 3.5 &lt; 7; \t// var0 equals truebool var1 &lt;- 3 &lt; 7; \t// var1 equals truebool var2 &lt;- 3 &lt; 2.5; \t// var2 equals false#now &lt; #now minus_hours 1 :- falsebool var4 &lt;- 3.5 &lt; 7.6; \t// var4 equals trueSee also:&gt;, &gt;=, &lt;=, =, !=,&lt;=Possible use:  string &lt;= string —&gt;  bool  &lt;= (string , string) —&gt;  bool  date &lt;= date —&gt;  bool  &lt;= (date , date) —&gt;  bool  float &lt;= float —&gt;  bool  &lt;= (float , float) —&gt;  bool  int &lt;= int —&gt;  bool  &lt;= (int , int) —&gt;  bool  int &lt;= float —&gt;  bool  &lt;= (int , float) —&gt;  bool  float &lt;= int —&gt;  bool  &lt;= (float , int) —&gt;  bool  point &lt;= point —&gt;  bool  &lt;= (point , point) —&gt;  boolResult:true if the left-hand operand is less or equal than the right-hand operand, false otherwise.Special cases:  if one of the operands is nil, returns false  if both operands are String, uses a lexicographic comparison of two stringsbool var5 &lt;- 'abc' &lt;= 'aeb'; \t// var5 equals true  if both operands are points, returns true if and only if the left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.bool var6 &lt;- {5,7} &lt;= {4,6}; \t// var6 equals falsebool var7 &lt;- {5,7} &lt;= {4,8}; \t// var7 equals falseExamples:#now &lt;= #now minus_hours 1 :- falsebool var1 &lt;- 3.5 &lt;= 3.5; \t// var1 equals truebool var2 &lt;- 3 &lt;= 7; \t// var2 equals truebool var3 &lt;- 3 &lt;= 2.5; \t// var3 equals falsebool var4 &lt;- 7.0 &lt;= 7; \t// var4 equals trueSee also:&gt;, &lt;, &gt;=, =, !=,&lt;&gt;Same signification as !==Possible use:  date = date —&gt;  bool  = (date , date) —&gt;  bool  int = float —&gt;  bool  = (int , float) —&gt;  bool  unknown = unknown —&gt;  bool  = (unknown , unknown) —&gt;  bool  float = float —&gt;  bool  = (float , float) —&gt;  bool  float = int —&gt;  bool  = (float , int) —&gt;  bool  int = int —&gt;  bool  = (int , int) —&gt;  boolResult:returns true if both operands are equal, false otherwisereturns true if both operands are equal, false otherwiseSpecial cases:  if both operands are any kind of objects, returns true if they are identical (i.e., the same object) or equal (comparisons between nil values are permitted)bool var0 &lt;- [2,3] = [2,3]; \t// var0 equals trueExamples:#now = #now minus_hours 1 :- falsebool var2 &lt;- 3 = 3.0; \t// var2 equals truebool var3 &lt;- 4 = 4.7; \t// var3 equals falsebool var4 &lt;- 4.5 = 4.7; \t// var4 equals falsebool var5 &lt;- 4.7 = 4; \t// var5 equals falsebool var6 &lt;- 4 = 5; \t// var6 equals falseSee also:!=, &gt;, &lt;, &gt;=, &lt;=,&gt;Possible use:  int &gt; float —&gt;  bool  &gt; (int , float) —&gt;  bool  float &gt; float —&gt;  bool  &gt; (float , float) —&gt;  bool  string &gt; string —&gt;  bool  &gt; (string , string) —&gt;  bool  int &gt; int —&gt;  bool  &gt; (int , int) —&gt;  bool  date &gt; date —&gt;  bool  &gt; (date , date) —&gt;  bool  point &gt; point —&gt;  bool  &gt; (point , point) —&gt;  bool  float &gt; int —&gt;  bool  &gt; (float , int) —&gt;  boolResult:true if the left-hand operand is greater than the right-hand operand, false otherwise.Special cases:  if one of the operands is nil, returns false  if both operands are String, uses a lexicographic comparison of two stringsbool var0 &lt;- 'abc' &gt; 'aeb'; \t// var0 equals false  if both operands are points, returns true if and only if the left component (x) of the left operand if greater than x of the right one and if the right component (y) of the left operand is greater than y of the right one.bool var1 &lt;- {5,7} &gt; {4,6}; \t// var1 equals truebool var2 &lt;- {5,7} &gt; {4,8}; \t// var2 equals falseExamples:bool var3 &lt;- 3 &gt; 2.5; \t// var3 equals truebool var4 &lt;- 3.5 &gt; 7.6; \t// var4 equals falsebool var5 &lt;- 3 &gt; 7; \t// var5 equals false#now &gt; #now minus_hours 1 :- truebool var7 &lt;- 3.5 &gt; 7; \t// var7 equals falseSee also:&lt;, &gt;=, &lt;=, =, !=,&gt;=Possible use:  float &gt;= int —&gt;  bool  &gt;= (float , int) —&gt;  bool  int &gt;= int —&gt;  bool  &gt;= (int , int) —&gt;  bool  int &gt;= float —&gt;  bool  &gt;= (int , float) —&gt;  bool  string &gt;= string —&gt;  bool  &gt;= (string , string) —&gt;  bool  date &gt;= date —&gt;  bool  &gt;= (date , date) —&gt;  bool  float &gt;= float —&gt;  bool  &gt;= (float , float) —&gt;  bool  point &gt;= point —&gt;  bool  &gt;= (point , point) —&gt;  boolResult:true if the left-hand operand is greater or equal than the right-hand operand, false otherwise.Special cases:  if one of the operands is nil, returns false  if both operands are string, uses a lexicographic comparison of the two stringsbool var5 &lt;- 'abc' &gt;= 'aeb'; \t// var5 equals falsebool var6 &lt;- 'abc' &gt;= 'abc'; \t// var6 equals true  if both operands are points, returns true if and only if the left component (x) of the left operand if greater or equal than x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.bool var7 &lt;- {5,7} &gt;= {4,6}; \t// var7 equals truebool var8 &lt;- {5,7} &gt;= {4,8}; \t// var8 equals falseExamples:bool var0 &lt;- 3.5 &gt;= 7; \t// var0 equals falsebool var1 &lt;- 3 &gt;= 7; \t// var1 equals falsebool var2 &lt;- 3 &gt;= 2.5; \t// var2 equals true#now &gt;= #now minus_hours 1 :- truebool var4 &lt;- 3.5 &gt;= 3.5; \t// var4 equals trueSee also:&gt;, &lt;, &lt;=, =, !=,absPossible use:  abs (int) —&gt;  int  abs (float) —&gt;  floatResult:Returns the absolute value of the operand (so a positive int or float depending on the type of the operand).Examples:int var0 &lt;- abs (-10); \t// var0 equals 10int var1 &lt;- abs (10); \t// var1 equals 10float var3 &lt;- abs (200 * -1 + 0.5); \t// var3 equals 199.5accumulatePossible use:  container accumulate any expression —&gt;  container  accumulate (container , any expression) —&gt;  containerResult:returns a new flat list, in which each element is the evaluation of the right-hand operand. If this evaluation returns a list, the elements of this result are added directly to the list returnedComment:accumulate is dedicated to the application of a same computation on each element of a container (and returns a list). In the right-hand operand, the keyword each can be used to represent, in turn, each of the left-hand operand elements.Examples:container var0 &lt;- [a1,a2,a3] accumulate (each neighbors_at 10); \t// var0 equals a flat list of all the neighbors of these three agentslist&lt;int&gt; var1 &lt;- [1,2,4] accumulate ([2,4]); \t// var1 equals [2,4,2,4,2,4]list&lt;int&gt; var2 &lt;- [1,2,4] accumulate (each * 2); \t// var2 equals [2,4,8]See also:collect,acosPossible use:  acos (float) —&gt;  float  acos (int) —&gt;  floatResult:Returns the value (in the interval [0,180], in decimal degrees) of the arccos of the operand (which should be in [-1,1]).Special cases:  if the right-hand operand is outside of the [-1,1] interval, returns NaNExamples:float var0 &lt;- acos (0); \t// var0 equals 90.0See also:asin, atan, cos,actionPossible use:  action (any) —&gt;  actionResult:Casts the operand into the type actionadd_daysSame signification as plus_daysadd_edgePossible use:  graph add_edge pair —&gt;  graph  add_edge (graph , pair) —&gt;  graphResult:add an edge between a source vertex and a target vertex (resp. the left and the right element of the pair operand)Comment:if the edge already exists, the graph is unchangedExamples:graph &lt;- graph add_edge (source::target);See also:add_node, graph,add_hoursSame signification as plus_hoursadd_minutesSame signification as plus_minutesadd_monthsSame signification as plus_monthsadd_msSame signification as plus_msadd_nodePossible use:  graph add_node geometry —&gt;  graph  add_node (graph , geometry) —&gt;  graphResult:adds a node in a graph.Examples:graph var0 &lt;- graph add_node node(0) ; \t// var0 equals the graph with node(0)See also:add_edge, graph,add_pointPossible use:  geometry add_point point —&gt;  geometry  add_point (geometry , point) —&gt;  geometryResult:A new geometry resulting from the addition of the right point (coordinate) to the left-hand geometry. Note that adding a point to a line or polyline will always return a closed contour. Also note that the position at which the added point will appear in the geometry is not necessarily the last one, as points are always ordered in a clockwise fashion in geometriesExamples:geometry var0 &lt;- polygon([{10,10},{10,20},{20,20}]) add_point {20,10}; \t// var0 equals polygon([{10,10},{10,20},{20,20},{20,10}])add_secondsSame signification as +add_weeksSame signification as plus_weeksadd_yearsSame signification as plus_yearsadjacencyPossible use:  adjacency (graph) —&gt;  matrix&lt;float&gt;Result:adjacency matrix of the given graph.afterPossible use:  after (date) —&gt;  bool  any expression after date —&gt;  bool  after (any expression , date) —&gt;  boolResult:Returns true if the current_date of the model is strictly after the date passed in argument. Synonym of ‘current_date &gt; argument’. Can be used in its composed form with 2 arguments to express the lower boundary for the computation of a frequency. Note that only dates strictly after this one will be tested against the frequencyExamples:reflex when: after(starting_date) {} -: will always be run after the first stepreflex when: false after(starting date + #10days) {} -: will not be run after this date. Better to use 'until' or 'before' in that caseevery(2#days) after (starting_date + 1#day) // the computation will return true every two days (using the starting_date of the model as the starting point) only for the dates strictly after this starting_date + 1#dayagentPossible use:  agent (any) —&gt;  agentResult:Casts the operand into the type agentagent_closest_toPossible use:  agent_closest_to (unknown) —&gt;  agentResult:An agent, the closest to the operand (casted as a geometry).Comment:the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.Examples:agent var0 &lt;- agent_closest_to(self); \t// var0 equals the closest agent to the agent applying the operator.See also:neighbors_at, neighbors_of, agents_inside, agents_overlapping, closest_to, inside, overlapping,agent_farthest_toPossible use:  agent_farthest_to (unknown) —&gt;  agentResult:An agent, the farthest to the operand (casted as a geometry).Comment:the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.Examples:agent var0 &lt;- agent_farthest_to(self); \t// var0 equals the farthest agent to the agent applying the operator.See also:neighbors_at, neighbors_of, agents_inside, agents_overlapping, closest_to, inside, overlapping, agent_closest_to, farthest_to,agent_from_geometryPossible use:  path agent_from_geometry geometry —&gt;  agent  agent_from_geometry (path , geometry) —&gt;  agentResult:returns the agent corresponding to given geometry (right-hand operand) in the given path (left-hand operand).Special cases:  if the left-hand operand is nil, returns nilExamples:geometry line &lt;- one_of(path_followed.segments);road ag &lt;- road(path_followed agent_from_geometry line);See also:path,agents_at_distancePossible use:  agents_at_distance (float) —&gt;  containerResult:A list of agents situated at a distance lower than the right argument.Examples:container var0 &lt;- agents_at_distance(20); \t// var0 equals all the agents (excluding the caller) which distance to the caller is lower than 20See also:neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, overlapping, at_distance,agents_insidePossible use:  agents_inside (unknown) —&gt;  list&lt;agent&gt;Result:A list of agents covered by the operand (casted as a geometry).Examples:list&lt;agent&gt; var0 &lt;- agents_inside(self); \t// var0 equals the agents that are covered by the shape of the agent applying the operator.See also:agent_closest_to, agents_overlapping, closest_to, inside, overlapping,agents_overlappingPossible use:  agents_overlapping (unknown) —&gt;  list&lt;agent&gt;Result:A list of agents overlapping the operand (casted as a geometry).Examples:list&lt;agent&gt; var0 &lt;- agents_overlapping(self); \t// var0 equals the agents that overlap the shape of the agent applying the operator.See also:neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, overlapping, at_distance,all_pairs_shortest_pathPossible use:  all_pairs_shortest_path (graph) —&gt;  matrix&lt;int&gt;Result:returns the successor matrix of shortest paths between all node pairs (rows: source, columns: target): a cell (i,j) will thus contains the next node in the shortest path between i and j.Examples:matrix&lt;int&gt; var0 &lt;- all_pairs_shortest_paths(my_graph); \t// var0 equals shortest_paths_matrix will contain all pairs of shortest pathsalpha_indexPossible use:  alpha_index (graph) —&gt;  floatResult:returns the alpha index of the graph (measure of connectivity which evaluates the number of cycles in a graph in comparison with the maximum number of cycles. The higher the alpha index, the more a network is connected: alpha = nb_cycles / (2*S-5) - planar graph)Examples:float var1 &lt;- alpha_index(graphEpidemio); \t// var1 equals the alpha index of the graphSee also:beta_index, gamma_index, nb_cycles, connectivity_index,amongPossible use:  int among container —&gt;  container  among (int , container) —&gt;  containerResult:Returns a list of length the value of the left-hand operand, containing random elements from the right-hand operand. As of GAMA 1.6, the order in which the elements are returned can be different than the order in which they appear in the right-hand containerSpecial cases:  if the right-hand operand is empty, among returns a new empty list. If it is nil, it throws an error.  if the left-hand operand is greater than the length of the right-hand operand, among returns the right-hand operand (converted as a list). If it is smaller or equal to zero, it returns an empty listExamples:list&lt;int&gt; var0 &lt;- 3 among [1,2,4,3,5,7,6,8]; \t// var0 equals [1,2,8] (for example)container var1 &lt;- 3 among g2; \t// var1 equals [node6,node11,node7]container var2 &lt;- 3 among list(node); \t// var2 equals [node1,node11,node4]list&lt;int&gt; var3 &lt;- 1 among [1::2,3::4]; \t// var3 equals 2 or 4andPossible use:  bool and any expression —&gt;  bool  and (bool , any expression) —&gt;  boolResult:a bool value, equal to the logical and between the left-hand operand and the right-hand operand.Comment:both operands are always casted to bool before applying the operator. Thus, an expression like (1 and 0) is accepted and returns false.See also:bool, or, !,andPossible use:  predicate and predicate —&gt;  predicate  and (predicate , predicate) —&gt;  predicateResult:create a new predicate from two others by including them as subintentionsExamples:predicate1 and predicate2angle_betweenPossible use:  angle_between (point, point, point) —&gt;  intResult:the angle between vectors P0P1 and P0P2 (P0, P1, P2 being the three point operands)Examples:int var0 &lt;- angle_between({5,5},{10,5},{5,10}); \t// var0 equals 90anySame signification as one_ofany_location_inPossible use:  any_location_in (geometry) —&gt;  pointResult:A point inside (or touching) the operand-geometry.Examples:point var0 &lt;- any_location_in(square(5)); \t// var0 equals a point in the square, for example : {3,4.6}.See also:closest_points_with, farthest_point_to, points_at,any_point_inSame signification as any_location_inappend_horizontallyPossible use:  matrix append_horizontally matrix —&gt;  matrix  append_horizontally (matrix , matrix) —&gt;  matrix  matrix append_horizontally matrix —&gt;  matrix  append_horizontally (matrix , matrix) —&gt;  matrixResult:A matrix resulting from the concatenation of the rows of the two given matrices. If not both numerical or both object matrices, returns the first matrix.Examples:matrix var0 &lt;- matrix([[1.0,2.0],[3.0,4.0]]) append_horizontally matrix([[1,2],[3,4]]); \t// var0 equals matrix([[1.0,2.0],[3.0,4.0],[1.0,2.0],[3.0,4.0]])append_verticallyPossible use:  matrix append_vertically matrix —&gt;  matrix  append_vertically (matrix , matrix) —&gt;  matrix  matrix append_vertically matrix —&gt;  matrix  append_vertically (matrix , matrix) —&gt;  matrixResult:A matrix resulting from the concatenation of the columns  of the two given matrices. If not both numerical or both object matrices, returns the first matrix.Examples:matrix var0 &lt;- matrix([[1,2],[3,4]]) append_vertically matrix([[1,2],[3,4]]); \t// var0 equals matrix([[1,2,1,2],[3,4,3,4]])arcPossible use:  arc (float, float, float) —&gt;  geometry  arc (float, float, float, bool) —&gt;  geometryResult:An arc, which radius is equal to the first operand, heading to the second and amplitude the thirdAn arc, which radius is equal to the first operand, heading to the second, amplitude to the third and a boolean indicating whether to return a linestring or a polygon to the fourthComment:the center of the arc is by default the location of the current agent in which has been called this operator. This operator returns a polygon by default.the center of the arc is by default the location of the current agent in which has been called this operator.Special cases:  returns a point if the radius operand is lower or equal to 0.  returns a point if the radius operand is lower or equal to 0.Examples:geometry var0 &lt;- arc(4,45,90); \t// var0 equals a geometry as an arc of radius 4, in a direction of 45Â° and an amplitude of 90Â°geometry var1 &lt;- arc(4,45,90, false); \t// var1 equals a geometry as an arc of radius 4, in a direction of 45Â° and an amplitude of 90Â°, which only contains the points on the arcSee also:around, cone, line, link, norm, point, polygon, polyline, super_ellipse, rectangle, square, circle, ellipse, triangle,aroundPossible use:  float around unknown —&gt;  geometry  around (float , unknown) —&gt;  geometryResult:A geometry resulting from the difference between a buffer around the right-operand casted in geometry at a distance left-operand (right-operand buffer left-operand) and the right-operand casted as geometry.Special cases:  returns a circle geometry of radius right-operand if the left-operand is nilExamples:geometry var0 &lt;- 10 around circle(5); \t// var0 equals the ring geometry between 5 and 10.See also:circle, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,asPossible use:  unknown as any expression —&gt;  unknown  as (unknown , any expression) —&gt;  unknownResult:casting of the first argument into a given typeComment:It is equivalent to the application of the type operator on the left operand.Examples:int var0 &lt;- 3.5 as int; \t// var0 equals int(3.5)as_4_gridPossible use:  geometry as_4_grid point —&gt;  matrix  as_4_grid (geometry , point) —&gt;  matrixResult:A matrix of square geometries (grid with 4-neighborhood) with dimension given by the right-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)Examples:matrix var0 &lt;- self as_4_grid {10, 5}; \t// var0 equals the matrix of square geometries (grid with 4-neighborhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.See also:as_grid, as_hexagonal_grid,as_distance_graphPossible use:  container as_distance_graph map —&gt;  graph  as_distance_graph (container , map) —&gt;  graph  container as_distance_graph float —&gt;  graph  as_distance_graph (container , float) —&gt;  graph  as_distance_graph (container, float, species) —&gt;  graphResult:creates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices close enough (less than a distance, right-hand operand).Comment:as_distance_graph is more efficient for a list of points than as_intersection_graph.Examples:list(ant) as_distance_graph 3.0See also:as_intersection_graph, as_edge_graph,as_driving_graphPossible use:  container as_driving_graph container —&gt;  graph  as_driving_graph (container , container) —&gt;  graphResult:creates a graph from the list/map of edges given as operand and connect the node to the edgeExamples:as_driving_graph(road,node)  --:  build a graph while using the road agents as edges and the node agents as nodesSee also:as_intersection_graph, as_distance_graph, as_edge_graph,as_edge_graphPossible use:  as_edge_graph (map) —&gt;  graph  as_edge_graph (container) —&gt;  graph  container as_edge_graph float —&gt;  graph  as_edge_graph (container , float) —&gt;  graphResult:creates a graph from the list/map of edges given as operandSpecial cases:  if the operand is a map, the graph will be built by creating edges from pairs of the mapgraph var0 &lt;- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); \t// var0 equals a graph with these three vertices and two edges  if the operand is a list and a tolerance (max distance in meters to consider that 2 points are the same node) is given, the graph will be built with elements of the list as edges and two edges will be connected by a node if the distance between their extremity (first or last points) are at distance lower or equal to the tolerancegraph var1 &lt;- as_edge_graph([line([{1,5},{12,45}]),line([{13,45},{34,56}])],1);; \t// var1 equals a graph with two edges and three vertices  if the operand is a list, the graph will be built with elements of the list as edgesgraph var2 &lt;- as_edge_graph([line([{1,5},{12,45}]),line([{12,45},{34,56}])]); \t// var2 equals a graph with two edges and three verticesSee also:as_intersection_graph, as_distance_graph,as_gridPossible use:  geometry as_grid point —&gt;  matrix  as_grid (geometry , point) —&gt;  matrixResult:A matrix of square geometries (grid with 8-neighborhood) with dimension given by the right-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)Examples:matrix var0 &lt;- self as_grid {10, 5}; \t// var0 equals a matrix of square geometries (grid with 8-neighborhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.See also:as_4_grid, as_hexagonal_grid,as_hexagonal_gridPossible use:  geometry as_hexagonal_grid point —&gt;  list&lt;geometry&gt;  as_hexagonal_grid (geometry , point) —&gt;  list&lt;geometry&gt;Result:A list of geometries (hexagonal) corresponding to the hexagonal tesselation of the first operand geometryExamples:list&lt;geometry&gt; var0 &lt;- self as_hexagonal_grid {10, 5}; \t// var0 equals list of geometries (hexagonal) corresponding to the hexagonal tesselation of the first operand geometrySee also:as_4_grid, as_grid,as_intPossible use:  string as_int int —&gt;  int  as_int (string , int) —&gt;  intResult:parses the string argument as a signed integer in the radix specified by the second argument.Special cases:  if the left operand is nil or empty, as_int returns 0  if the left operand does not represent an integer in the specified radix, as_int throws an exceptionExamples:int var0 &lt;- '20' as_int 10; \t// var0 equals 20int var1 &lt;- '20' as_int 8; \t// var1 equals 16int var2 &lt;- '20' as_int 16; \t// var2 equals 32int var3 &lt;- '1F' as_int 16; \t// var3 equals 31int var4 &lt;- 'hello' as_int 32; \t// var4 equals 18306744See also:int,as_intersection_graphPossible use:  container as_intersection_graph float —&gt;  graph  as_intersection_graph (container , float) —&gt;  graphResult:creates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices with an intersection (with a given tolerance).Comment:as_intersection_graph is more efficient for a list of geometries (but less accurate) than as_distance_graph.Examples:list(ant) as_intersection_graph 0.5See also:as_distance_graph, as_edge_graph,as_mapPossible use:  container as_map any expression —&gt;  map  as_map (container , any expression) —&gt;  mapResult:produces a new map from the evaluation of the right-hand operand for each element of the left-hand operandComment:the right-hand operand should be a pairSpecial cases:  if the left-hand operand is nil, as_map throws an error.Examples:map&lt;int,int&gt; var0 &lt;- [1,2,3,4,5,6,7,8] as_map (each::(each * 2)); \t// var0 equals [1::2, 2::4, 3::6, 4::8, 5::10, 6::12, 7::14, 8::16]map&lt;int,int&gt; var1 &lt;- [1::2,3::4,5::6] as_map (each::(each * 2)); \t// var1 equals [2::4, 4::8, 6::12] as_matrixPossible use:  unknown as_matrix point —&gt;  matrix  as_matrix (unknown , point) —&gt;  matrixResult:casts the left operand into a matrix with right operand as preferred sizeComment:This operator is very useful to cast a file containing raster data into a matrix.Note that both components of the right operand point should be positive, otherwise an exception is raised.The operator as_matrix creates a matrix of preferred size. It fills in it with elements of the left operand until the matrix is full If the size is to short, some elements will be omitted. Matrix remaining elements will be filled in by nil.Special cases:  if the right operand is nil, as_matrix is equivalent to the matrix operatorSee also:matrix,as_pathPossible use:  list&lt;geometry&gt; as_path graph —&gt;  path  as_path (list&lt;geometry&gt; , graph) —&gt;  pathResult:create a graph path from the list of shapeExamples:path var0 &lt;- [road1,road2,road3] as_path my_graph; \t// var0 equals a path road1-&gt;road2-&gt;road3 of my_graphasinPossible use:  asin (float) —&gt;  float  asin (int) —&gt;  floatResult:the arcsin of the operandSpecial cases:  if the right-hand operand is outside of the [-1,1] interval, returns NaNExamples:float var0 &lt;- asin (0); \t// var0 equals 0.0float var1 &lt;- asin (90); \t// var1 equals #nanSee also:acos, atan, sin,atPossible use:  string at int —&gt;  string  at (string , int) —&gt;  string  container&lt;KeyType,ValueType&gt; at KeyType —&gt;  ValueType  at (container&lt;KeyType,ValueType&gt; , KeyType) —&gt;  ValueTypeResult:the element at the right operand index of the containerComment:The first element of the container is located at the index 0. In addition, if the user tries to get the element at an index higher or equals than the length of the container, he will get an IndexOutOfBoundException.The at operator behavior depends on the nature of the operandSpecial cases:  if it is a file, at returns the element of the file content at the index specified by the right operand  if it is a population, at returns the agent at the index specified by the right operand  if it is a graph and if the right operand is a node, at returns the in and out edges corresponding to that node  if it is a graph and if the right operand is an edge, at returns the pair node_out::node_in of the edge  if it is a graph and if the right operand is a pair node1::node2, at returns the edge from node1 to node2 in the graph  if it is a list or a matrix, at returns the element at the index specified by the right operandint var1 &lt;- [1, 2, 3] at 2; \t// var1 equals 3point var2 &lt;- [{1,2}, {3,4}, {5,6}] at 0; \t// var2 equals {1.0,2.0}Examples:string var0 &lt;- 'abcdef' at 0; \t// var0 equals 'a'See also:contains_all, contains_any,at_distancePossible use:  container&lt;agent&gt; at_distance float —&gt;  list&lt;geometry&gt;  at_distance (container&lt;agent&gt; , float) —&gt;  list&lt;geometry&gt;Result:A list of agents or geometries among the left-operand list that are located at a distance &lt;= the right operand from the caller agent (in its topology)Examples:list&lt;geometry&gt; var0 &lt;- [ag1, ag2, ag3] at_distance 20; \t// var0 equals the agents of the list located at a distance &lt;= 20 from the caller agent (in the same order).See also:neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, overlapping,at_locationPossible use:  geometry at_location point —&gt;  geometry  at_location (geometry , point) —&gt;  geometryResult:A geometry resulting from the tran of a translation to the right-hand operand point of the left-hand operand (geometry, agent, point)Examples:geometry var0 &lt;- self at_location {10, 20}; \t// var0 equals the geometry resulting from a translation to the location {10, 20} of the left-hand geometry (or agent).atanPossible use:  atan (float) —&gt;  float  atan (int) —&gt;  floatResult:Returns the value (in the interval [-90,90], in decimal degrees) of the arctan of the operand (which can be any real number).Examples:float var0 &lt;- atan (1); \t// var0 equals 45.0See also:acos, asin, tan,atan2Possible use:  float atan2 float —&gt;  float  atan2 (float , float) —&gt;  floatResult:the atan2 value of the two operands.Comment:The function atan2 is the arctangent function with two arguments. The purpose of using two arguments instead of one is to gather information on the signs of the inputs in order to return the appropriate quadrant of the computed angle, which is not possible for the single-argument arctangent function.Examples:float var0 &lt;- atan2 (0,0); \t// var0 equals 0.0See also:atan, acos, asin,attributesPossible use:  attributes (any) —&gt;  attributesResult:Casts the operand into the type attributesBDIPlanPossible use:  BDIPlan (any) —&gt;  BDIPlanResult:Casts the operand into the type BDIPlanbeforePossible use:  before (date) —&gt;  bool  any expression before date —&gt;  bool  before (any expression , date) —&gt;  boolResult:Returns true if the current_date of the model is strictly before the date passed in argument. Synonym of ‘current_date &lt; argument’Examples:reflex when: before(starting_date) {} -: will never be runbeta_indexPossible use:  beta_index (graph) —&gt;  floatResult:returns the beta index of the graph (Measures the level of connectivity in a graph and is expressed by the relationship between the number of links (e) over the number of nodes (v) : beta = e/v.Examples:graph graphEpidemio &lt;- graph([]);float var1 &lt;- beta_index(graphEpidemio); \t// var1 equals the beta index of the graphSee also:alpha_index, gamma_index, nb_cycles, connectivity_index,betweenPossible use:  date between date —&gt;  bool  between (date , date) —&gt;  bool  between (int, int, int) —&gt;  bool  between (any expression, date, date) —&gt;  bool  between (float, float, float) —&gt;  bool  between (date, date, date) —&gt;  boolResult:returns true the first integer operand is bigger than the second integer operand and smaller than the third integer operandreturns true if the first float operand is bigger than the second float operand and smaller than the third float operandSpecial cases:  returns true if the first operand is between the two dates passed in arguments (both exclusive). Can be combined with ‘every’ to express a frequency between two dates(date('2016-01-01') between(date('2000-01-01'), date('2020-02-02') -: trueevery #day between(date('2000-01-01'), date('2020-02-02') // will return true every new day between these two dates, taking the first one as the starting point  returns true if the first operand is between the two dates passed in arguments (both exclusive). The version with 2 arguments compares the current_date with the 2 others(date('2016-01-01') between(date('2000-01-01'), date('2020-02-02') -: truebetween(date('2000-01-01'), date('2020-02-02') // will return true if the current_date of the model is in_between the 2Examples:bool var0 &lt;- between(5, 1, 10); \t// var0 equals truebool var1 &lt;- between(5.0, 1.0, 10.0); \t// var1 equals truebetweenness_centralityPossible use:  betweenness_centrality (graph) —&gt;  mapResult:returns a map containing for each vertex (key), its betweenness centrality (value): number of shortest paths passing through each vertexExamples:graph graphEpidemio &lt;- graph([]);map var1 &lt;- betweenness_centrality(graphEpidemio); \t// var1 equals the betweenness centrality index of the graphbiggest_cliques_ofPossible use:  biggest_cliques_of (graph) —&gt;  list&lt;list&gt;Result:returns the biggest cliques of a graph using the Bron-Kerbosch clique detection algorithmExamples:graph my_graph &lt;- graph([]);list&lt;list&gt; var1 &lt;- biggest_cliques_of (my_graph); \t// var1 equals the list of the biggest cliques as listSee also:maximal_cliques_of,binomialPossible use:  int binomial float —&gt;  int  binomial (int , float) —&gt;  intResult:A value from a random variable following a binomial distribution. The operands represent the number of experiments n and the success probability p.Comment:The binomial distribution is the discrete probability distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields success with probability p, cf. Binomial distribution on Wikipedia.Examples:int var0 &lt;- binomial(15,0.6); \t// var0 equals a random positive integerSee also:poisson, gauss,blendPossible use:  rgb blend rgb —&gt;  rgb  blend (rgb , rgb) —&gt;  rgb  blend (rgb, rgb, float) —&gt;  rgbResult:Blend two colors with an optional ratio (c1 * r + c2 * (1 - r)) between 0 and 1Special cases:  If the ratio is omitted, an even blend is donergb var3 &lt;- blend(#red, #blue); \t// var3 equals to a color very close to the purpleExamples:rgb var1 &lt;- blend(#red, #blue, 0.3); \t// var1 equals to a color between the purple and the blueSee also:rgb, hsb,boolPossible use:  bool (any) —&gt;  boolResult:Casts the operand into the type boolboxPossible use:  box (point) —&gt;  geometry  box (float, float, float) —&gt;  geometryResult:A box geometry which side sizes are given by the operands.Comment:the center of the box is by default the location of the current agent in which has been called this operator.the center of the box is by default the location of the current agent in which has been called this operator.Special cases:  returns nil if the operand is nil.  returns nil if the operand is nil.Examples:geometry var0 &lt;- box(10, 5 , 5); \t// var0 equals a geometry as a rectangle with width = 10, height = 5 depth= 5.geometry var1 &lt;- box({10, 5 , 5}); \t// var1 equals a geometry as a rectangle with width = 10, height = 5 depth= 5.See also:around, circle, sphere, cone, line, link, norm, point, polygon, polyline, square, cube, triangle,brewer_colorsPossible use:  brewer_colors (string) —&gt;  list&lt;rgb&gt;  string brewer_colors int —&gt;  list&lt;rgb&gt;  brewer_colors (string , int) —&gt;  list&lt;rgb&gt;Result:Build a list of colors of a given type (see website http://colorbrewer2.org/)Build a list of colors of a given type (see website http://colorbrewer2.org/) with a given number of classesExamples:list&lt;rgb&gt; var0 &lt;- list&lt;rgb&gt; colors &lt;- brewer_colors(\"OrRd\");; \t// var0 equals a list of 6 blue colorslist&lt;rgb&gt; var1 &lt;- list&lt;rgb&gt; colors &lt;- brewer_colors(\"Pastel1\", 10);; \t// var1 equals a list of 10 sequential colorsSee also:brewer_palettes,brewer_palettesPossible use:  brewer_palettes (int) —&gt;  list&lt;string&gt;  int brewer_palettes int —&gt;  list&lt;string&gt;  brewer_palettes (int , int) —&gt;  list&lt;string&gt;Result:returns the list a palette with a given min number of classes and max number of classes)returns the list a palette with a given min number of classes and max number of classes)Examples:list&lt;string&gt; var0 &lt;- list&lt;rgb&gt; colors &lt;- brewer_palettes(5,10);; \t// var0 equals a list of palettes that are composed of a min of 5 colors and a max of 10 colorslist&lt;string&gt; var1 &lt;- list&lt;rgb&gt; colors &lt;- brewer_palettes();; \t// var1 equals a list of palettes that are composed of a min of 5 colorsSee also:brewer_colors,bufferSame signification as +buildPossible use:  build (matrix&lt;float&gt;) —&gt;  regression  matrix&lt;float&gt; build string —&gt;  regression  build (matrix&lt;float&gt; , string) —&gt;  regressionResult:returns the regression build from the matrix data (a row = an instance, the last value of each line is the y value) while using the given ordinary least squares method. Usage: build(data)returns the regression build from the matrix data (a row = an instance, the last value of each line is the y value) while using the given method (“GLS” or “OLS”). Usage: build(data,method)Examples:matrix([[1,2,3,4],[2,3,4,2]])build(matrix([[1,2,3,4],[2,3,4,2]]),\"GLS\")ceilPossible use:  ceil (float) —&gt;  floatResult:Maps the operand to the smallest following integer, i.e. the smallest integer not less than x.Examples:float var0 &lt;- ceil(3); \t// var0 equals 3.0float var1 &lt;- ceil(3.5); \t// var1 equals 4.0float var2 &lt;- ceil(-4.7); \t// var2 equals -4.0See also:floor, round,centroidPossible use:  centroid (geometry) —&gt;  pointResult:Centroid (weighted sum of the centroids of a decomposition of the area into triangles) of the operand-geometry. Can be different to the location of the geometryExamples:point var0 &lt;- centroid(world); \t// var0 equals the centroid of the square, for example : {50.0,50.0}.See also:any_location_in, closest_points_with, farthest_point_to, points_at,charPossible use:  char (int) —&gt;  stringSpecial cases:  converts ACSII integer value to characterstring var0 &lt;- char (34); \t// var0 equals '\"'circlePossible use:  circle (float) —&gt;  geometry  float circle point —&gt;  geometry  circle (float , point) —&gt;  geometryResult:A circle geometry which radius is equal to the first operand, and the center has the location equal to the second operand.A circle geometry which radius is equal to the operand.Comment:the center of the circle is by default the location of the current agent in which has been called this operator.Special cases:  returns a point if the operand is lower or equal to 0.  returns a point if the operand is lower or equal to 0.Examples:geometry var0 &lt;- circle(10,{80,30}); \t// var0 equals a geometry as a circle of radius 10, the center will be in the location {80,30}.geometry var1 &lt;- circle(10); \t// var1 equals a geometry as a circle of radius 10.See also:around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,cleanPossible use:  clean (geometry) —&gt;  geometryResult:A geometry corresponding to the cleaning of the operand (geometry, agent, point)Comment:The cleaning corresponds to a buffer with a distance of 0.0Examples:geometry var0 &lt;- clean(self); \t// var0 equals returns the geometry resulting from the cleaning of the geometry of the agent applying the operator.closest_points_withPossible use:  geometry closest_points_with geometry —&gt;  list&lt;point&gt;  closest_points_with (geometry , geometry) —&gt;  list&lt;point&gt;Result:A list of two closest points between the two geometries.Examples:list&lt;point&gt; var0 &lt;- geom1 closest_points_with(geom2); \t// var0 equals [pt1, pt2] with pt1 the closest point of geom1 to geom2 and pt1 the closest point of geom2 to geom1See also:any_location_in, any_point_in, farthest_point_to, points_at,closest_toPossible use:  container&lt;agent&gt; closest_to geometry —&gt;  geometry  closest_to (container&lt;agent&gt; , geometry) —&gt;  geometryResult:An agent or a geometry among the left-operand list of agents, species or meta-population (addition of species), the closest to the operand (casted as a geometry).Comment:the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.Examples:geometry var0 &lt;- [ag1, ag2, ag3] closest_to(self); \t// var0 equals return the closest agent among ag1, ag2 and ag3 to the agent applying the operator.(species1 + species2) closest_to selfSee also:neighbors_at, neighbors_of, inside, overlapping, agents_overlapping, agents_inside, agent_closest_to,collectPossible use:  container collect any expression —&gt;  container  collect (container , any expression) —&gt;  containerResult:returns a new list, in which each element is the evaluation of the right-hand operand.Comment:collect is similar to accumulate except that accumulate always produces flat lists if the right-hand operand returns a list.In addition, collect can be applied to any container.Special cases:  if the left-hand operand is nil, collect throws an errorExamples:container var0 &lt;- [1,2,4] collect (each *2); \t// var0 equals [2,4,8]container var1 &lt;- [1,2,4] collect ([2,4]); \t// var1 equals [[2,4],[2,4],[2,4]]container var2 &lt;- [1::2, 3::4, 5::6] collect (each + 2); \t// var2 equals [4,6,8]container var3 &lt;- (list(node) collect (node(each).location.x * 2); \t// var3 equals the list of nodes with their x multiplied by 2See also:accumulate,column_atPossible use:  matrix column_at int —&gt;  list  column_at (matrix , int) —&gt;  listResult:returns the column at a num_col (right-hand operand)Examples:list var0 &lt;- matrix([[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]]) column_at 2; \t// var0 equals [\"el31\",\"el32\",\"el33\"]See also:row_at, rows_list,columns_listPossible use:  columns_list (matrix) —&gt;  list&lt;list&gt;Result:returns a list of the columns of the matrix, with each column as a list of elementsExamples:list&lt;list&gt; var0 &lt;- columns_list(matrix([[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]])); \t// var0 equals [[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]]See also:rows_list,commandPossible use:  command (string) —&gt;  stringResult:command allows GAMA to issue a system command using the system terminal or shell and to receive a string containing the outcome of the command or script executed. By default, commands are blocking the agent calling them, unless the sequence ‘ &amp;’ is used at the end. In this case, the result of the operator is an empty stringconePossible use:  cone (point) —&gt;  geometry  int cone int —&gt;  geometry  cone (int , int) —&gt;  geometryResult:A cone geometry which min and max angles are given by the operands.A cone geometry which min and max angles are given by the operands.Comment:the center of the cone is by default the location of the current agent in which has been called this operator.the center of the cone is by default the location of the current agent in which has been called this operator.Special cases:  returns nil if the operand is nil.  returns nil if the operand is nil.Examples:geometry var0 &lt;- cone({0, 45}); \t// var0 equals a geometry as a cone with min angle is 0 and max angle is 45.geometry var1 &lt;- cone(0, 45); \t// var1 equals a geometry as a cone with min angle is 0 and max angle is 45.See also:around, circle, line, link, norm, point, polygon, polyline, rectangle, square, triangle,cone3DPossible use:  float cone3D float —&gt;  geometry  cone3D (float , float) —&gt;  geometryResult:A cone geometry which base radius size is equal to the first operand, and which the height is equal to the second operand.Comment:the center of the cone is by default the location of the current agent in which has been called this operator.Special cases:  returns a point if the operand is lower or equal to 0.Examples:geometry var0 &lt;- cone3D(10.0,5.0); \t// var0 equals a geometry as a cone with a base circle of radius 10 and a height of 5.See also:around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,connected_components_ofPossible use:  connected_components_of (graph) —&gt;  list&lt;list&gt;Result:returns the connected components of of a graph, i.e. the list of all vertices that are in the maximally connected component together with the specified vertex.Examples:graph my_graph &lt;- graph([]);list&lt;list&gt; var1 &lt;- connected_components_of (my_graph); \t// var1 equals the list of all the components as listSee also:alpha_index, connectivity_index, nb_cycles,connectivity_indexPossible use:  connectivity_index (graph) —&gt;  floatResult:returns a simple connectivity index. This number is estimated through the number of nodes (v) and of sub-graphs (p) : IC = (v - p) /(v - 1).Examples:graph graphEpidemio &lt;- graph([]);float var1 &lt;- connectivity_index(graphEpidemio); \t// var1 equals the connectivity index of the graphSee also:alpha_index, beta_index, gamma_index, nb_cycles,containerPossible use:  container (any) —&gt;  containerResult:Casts the operand into the type containercontainsPossible use:  container&lt;KeyType,ValueType&gt; contains unknown —&gt;  bool  contains (container&lt;KeyType,ValueType&gt; , unknown) —&gt;  bool  string contains string —&gt;  bool  contains (string , string) —&gt;  boolResult:true, if the container contains the right operand, false otherwiseComment:the contains operator behavior depends on the nature of the operandSpecial cases:  if it is a map, contains returns true if the operand is a key of the map  if it is a file, contains returns true it the operand is contained in the file content  if it is a population, contains returns true if the operand is an agent of the population, false otherwise  if it is a graph, contains returns true if the operand is a node or an edge of the graph, false otherwise  if both operands are strings, returns true if the right-hand operand contains the right-hand pattern;  if it is a list or a matrix, contains returns true if the list or matrix contains the right operandbool var0 &lt;- [1, 2, 3] contains 2; \t// var0 equals truebool var1 &lt;- [{1,2}, {3,4}, {5,6}] contains {3,4}; \t// var1 equals trueExamples:bool var2 &lt;- 'abcded' contains 'bc'; \t// var2 equals trueSee also:contains_all, contains_any,contains_allPossible use:  container contains_all container —&gt;  bool  contains_all (container , container) —&gt;  bool  string contains_all list —&gt;  bool  contains_all (string , list) —&gt;  boolResult:true if the left operand contains all the elements of the right operand, false otherwiseComment:the definition of contains depends on the containerSpecial cases:  if the right operand is nil or empty, contains_all returns true  if the left-operand is a string, test whether the string contains all the element of the list;bool var4 &lt;- \"abcabcabc\" contains_all [\"ca\",\"xy\"]; \t// var4 equals falseExamples:bool var0 &lt;- [1,2,3,4,5,6] contains_all [2,4]; \t// var0 equals true bool var1 &lt;- [1,2,3,4,5,6] contains_all [2,8]; \t// var1 equals falsebool var2 &lt;- [1::2, 3::4, 5::6] contains_all [1,3]; \t// var2 equals false bool var3 &lt;- [1::2, 3::4, 5::6] contains_all [2,4]; \t// var3 equals trueSee also:contains, contains_any,contains_anyPossible use:  container contains_any container —&gt;  bool  contains_any (container , container) —&gt;  bool  string contains_any list —&gt;  bool  contains_any (string , list) —&gt;  boolResult:true if the left operand contains one of the elements of the right operand, false otherwiseComment:the definition of contains depends on the containerSpecial cases:  if the right operand is nil or empty, contains_any returns falseExamples:bool var0 &lt;- [1,2,3,4,5,6] contains_any [2,4]; \t// var0 equals true bool var1 &lt;- [1,2,3,4,5,6] contains_any [2,8]; \t// var1 equals truebool var2 &lt;- [1::2, 3::4, 5::6] contains_any [1,3]; \t// var2 equals falsebool var3 &lt;- [1::2, 3::4, 5::6] contains_any [2,4]; \t// var3 equals truebool var4 &lt;- \"abcabcabc\" contains_any [\"ca\",\"xy\"]; \t// var4 equals trueSee also:contains, contains_all,contains_edgePossible use:  graph contains_edge unknown —&gt;  bool  contains_edge (graph , unknown) —&gt;  bool  graph contains_edge pair —&gt;  bool  contains_edge (graph , pair) —&gt;  boolResult:returns true if the graph(left-hand operand) contains the given edge (righ-hand operand), false otherwiseSpecial cases:  if the left-hand operand is nil, returns false  if the right-hand operand is a pair, returns true if it exists an edge between the two elements of the pair in the graphbool var2 &lt;- graphEpidemio contains_edge (node(0)::node(3)); \t// var2 equals trueExamples:graph graphFromMap &lt;-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);bool var1 &lt;- graphFromMap contains_edge link({1,5}::{12,45}); \t// var1 equals trueSee also:contains_vertex,contains_vertexPossible use:  graph contains_vertex unknown —&gt;  bool  contains_vertex (graph , unknown) —&gt;  boolResult:returns true if the graph(left-hand operand) contains the given vertex (righ-hand operand), false otherwiseSpecial cases:  if the left-hand operand is nil, returns falseExamples:graph graphFromMap&lt;-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);bool var1 &lt;- graphFromMap contains_vertex {1,5}; \t// var1 equals trueSee also:contains_edge,conversationPossible use:  conversation (unknown) —&gt;  conversationconvex_hullPossible use:  convex_hull (geometry) —&gt;  geometryResult:A geometry corresponding to the convex hull of the operand.Examples:geometry var0 &lt;- convex_hull(self); \t// var0 equals the convex hull of the geometry of the agent applying the operatorcopyPossible use:  copy (unknown) —&gt;  unknownResult:returns a copy of the operand.copy_betweenPossible use:  copy_between (string, int, int) —&gt;  string  copy_between (container, int, int) —&gt;  containerResult:Returns a copy of the first operand between the indexes determined by the second (inclusive) and third operands (exclusive)Special cases:  If the first operand is empty, returns an empty object of the same type  If the second operand is greater than or equal to the third operand, return an empty object of the same type  If the first operand is nil, raises an errorExamples:string var0 &lt;- copy_between(\"abcabcabc\", 2,6); \t// var0 equals \"cabc\"container var1 &lt;-  copy_between ([4, 1, 6, 9 ,7], 1, 3); \t// var1 equals [1, 6]corRPossible use:  container corR container —&gt;  unknown  corR (container , container) —&gt;  unknownResult:returns the Pearson correlation coefficient of two given vectors (right-hand operands) in given variable  (left-hand operand).Special cases:  if the lengths of two vectors in the right-hand aren’t equal, returns 0Examples:list X &lt;- [1, 2, 3];list Y &lt;- [1, 2, 4];unknown var2 &lt;- corR(X, Y); \t// var2 equals 0.981980506061966cosPossible use:  cos (int) —&gt;  float  cos (float) —&gt;  floatResult:Returns the value (in [-1,1]) of the cosinus of the operand (in decimal degrees).  The argument is casted to an int before being evaluated.Special cases:  Operand values out of the range [0-359] are normalized.Examples:float var0 &lt;- cos (0); \t// var0 equals 1.0float var1 &lt;- cos(360); \t// var1 equals 1.0float var2 &lt;- cos(-720); \t// var2 equals 1.0See also:sin, tan,cos_radPossible use:  cos_rad (float) —&gt;  floatResult:Returns the value (in [-1,1]) of the cosinus of the operand (in decimal degrees).  The argument is casted to an int before being evaluated.Special cases:  Operand values out of the range [0-359] are normalized.See also:sin, tan,countPossible use:  container count any expression —&gt;  int  count (container , any expression) —&gt;  intResult:returns an int, equal to the number of elements of the left-hand operand that make the right-hand operand evaluate to true.Comment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.Special cases:  if the left-hand operand is nil, count throws an errorExamples:int var0 &lt;- [1,2,3,4,5,6,7,8] count (each &gt; 3); \t// var0 equals 5// Number of nodes of graph g2 without any out edgegraph g2 &lt;- graph([]);int var3 &lt;- g2 count (length(g2 out_edges_of each) = 0  ) ; \t// var3 equals the total number of out edges// Number of agents node with x &gt; 32int n &lt;- (list(node) count (round(node(each).location.x) &gt; 32);int var6 &lt;- [1::2, 3::4, 5::6] count (each &gt; 4); \t// var6 equals 1See also:group_by,coversPossible use:  geometry covers geometry —&gt;  bool  covers (geometry , geometry) —&gt;  boolResult:A boolean, equal to true if the left-geometry (or agent/point) covers the right-geometry (or agent/point).Special cases:  if one of the operand is null, returns false.Examples:bool var0 &lt;- square(5) covers square(2); \t// var0 equals trueSee also:disjoint_from, crosses, overlaps, partially_overlaps, touches,crossPossible use:  cross (float) —&gt;  geometry  float cross float —&gt;  geometry  cross (float , float) —&gt;  geometryResult:A cross, which radius is equal to the first operandA cross, which radius is equal to the first operand and the width of the lines for the secondExamples:geometry var0 &lt;- cross(10); \t// var0 equals a geometry as a cross of radius 10geometry var1 &lt;- cross(10,2); \t// var1 equals a geometry as a cross of radius 10, and with a width of 2 for the lines See also:around, cone, line, link, norm, point, polygon, polyline, super_ellipse, rectangle, square, circle, ellipse, triangle,crossesPossible use:  geometry crosses geometry —&gt;  bool  crosses (geometry , geometry) —&gt;  boolResult:A boolean, equal to true if the left-geometry (or agent/point) crosses the right-geometry (or agent/point).Special cases:  if one of the operand is null, returns false.  if one operand is a point, returns false.Examples:bool var0 &lt;- polyline([{10,10},{20,20}]) crosses polyline([{10,20},{20,10}]); \t// var0 equals truebool var1 &lt;- polyline([{10,10},{20,20}]) crosses {15,15}; \t// var1 equals truebool var2 &lt;- polyline([{0,0},{25,25}]) crosses polygon([{10,10},{10,20},{20,20},{20,10}]); \t// var2 equals trueSee also:disjoint_from, intersects, overlaps, partially_overlaps, touches,crsPossible use:  crs (file) —&gt;  stringResult:the Coordinate Reference System (CRS) of the GIS fileExamples:string var0 &lt;- crs(my_shapefile); \t// var0 equals the crs of the shapefileCRS_transformPossible use:  CRS_transform (geometry) —&gt;  geometry  geometry CRS_transform string —&gt;  geometry  CRS_transform (geometry , string) —&gt;  geometrySpecial cases:  returns the geometry corresponding to the transformation of the given geometry by the left operand CRS (Coordinate Reference System)geometry var0 &lt;- shape CRS_transform(\"EPSG:4326\"); \t// var0 equals a geometry corresponding to the agent geometry transformed into the EPSG:4326 CRS  returns the geometry corresponding to the transformation of the given geometry by the current CRS (Coordinate Reference System), the one corresponding to the world’s agent onegeometry var1 &lt;- CRS_transform(shape); \t// var1 equals a geometry corresponding to the agent geometry transformed into the current CRScsv_filePossible use:  csv_file (string) —&gt;  fileResult:Constructs a file of type csv. Allowed extensions are limited to csv, tsvcubePossible use:  cube (float) —&gt;  geometryResult:A cube geometry which side size is equal to the operand.Comment:the center of the cube is by default the location of the current agent in which has been called this operator.Special cases:  returns nil if the operand is nil.Examples:geometry var0 &lt;- cube(10); \t// var0 equals a geometry as a square of side size 10.See also:around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, triangle,curvePossible use:  curve (point, point, point) —&gt;  geometry  curve (point, point, point, int) —&gt;  geometry  curve (point, point, point, point) —&gt;  geometry  curve (point, point, point, point, int) —&gt;  geometryResult:A quadratic Bezier curve geometry built from the three given points composed of a given numnber of points.A quadratic Bezier curve geometry built from the three given points composed of 10 points.A cubic Bezier curve geometry built from the four given points composed of a given number of points.A cubic Bezier curve geometry built from the four given points composed of 10 points.Special cases:  if the operand is nil, returns nil  if the last operand (number of points) is inferior to 2, returns nil  if the operand is nil, returns nil  if the operand is nil, returns nil  if the last operand (number of points) is inferior to 2, returns nil  if the operand is nil, returns nilExamples:geometry var0 &lt;- curve({0,0}, {0,10}, {10,10}, 20); \t// var0 equals a quadratic Bezier curve geometry composed of 20 points from p0 to p2.geometry var1 &lt;- curve({0,0}, {0,10}, {10,10}); \t// var1 equals a quadratic Bezier curve geometry composed of 10 points from p0 to p2.geometry var2 &lt;- curve({0,0}, {0,10}, {10,10}); \t// var2 equals a cubic Bezier curve geometry composed of 10 points from p0 to p3.geometry var3 &lt;- curve({0,0}, {0,10}, {10,10}); \t// var3 equals a cubic Bezier curve geometry composed of 10 points from p0 to p3.See also:around, circle, cone, link, norm, point, polygone, rectangle, square, triangle, line,cylinderPossible use:  float cylinder float —&gt;  geometry  cylinder (float , float) —&gt;  geometryResult:A cylinder geometry which radius is equal to the operand.Comment:the center of the cylinder is by default the location of the current agent in which has been called this operator.Special cases:  returns a point if the operand is lower or equal to 0.Examples:geometry var0 &lt;- cylinder(10,10); \t// var0 equals a geometry as a circle of radius 10.See also:around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,datePossible use:  string date string —&gt;  date  date (string , string) —&gt;  dateResult:converts a string to a date following a custom pattern. The pattern can use “%Y %M %N %D %E %h %m %s %z” for outputting years, months, name of month, days, name of days, hours, minutes, seconds and the time-zone. A null or empty pattern will parse the date using one of the ISO date &amp; time formats (similar to date(‘…’) in that case). The pattern can also follow the pattern definition found here, which gives much more control over what will be parsed: https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns. Different patterns are available by default as constant: #iso_local, #iso_simple, #iso_offset, #iso_zoned and #custom, which can be changed in the preferencesExamples:date(\"1999-12-30\", 'yyyy-MM-dd')dbscanPossible use:  dbscan (list, float, int) —&gt;  list&lt;list&gt;Result:returns the list of clusters (list of instance indices) computed with the dbscan (density-based spatial clustering of applications with noise) algorithm from the first operand data according to the maximum radius of the neighborhood to be considered (eps) and the minimum number of points needed for a cluster (minPts). Usage: dbscan(data,eps,minPoints)Special cases:  if the lengths of two vectors in the right-hand aren’t equal, returns 0Examples:dbscan ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],10,2)deadPossible use:  dead (agent) —&gt;  boolResult:true if the agent is dead (or null), false otherwise.Examples:bool var0 &lt;- dead(agent_A); \t// var0 equals true or falsedegree_ofPossible use:  graph degree_of unknown —&gt;  int  degree_of (graph , unknown) —&gt;  intResult:returns the degree (in+out) of a vertex (right-hand operand) in the graph given as left-hand operand.Examples:int var1 &lt;- graphFromMap degree_of (node(3)); \t// var1 equals 3See also:in_degree_of, out_degree_of,demPossible use:  dem (file) —&gt;  geometry  file dem file —&gt;  geometry  dem (file , file) —&gt;  geometry  file dem float —&gt;  geometry  dem (file , float) —&gt;  geometry  dem (file, file, float) —&gt;  geometryResult:A polygon that is equivalent to the surface of the textureExamples:geometry var0 &lt;- dem(dem,texture,z_factor); \t// var0 equals a geometry as a rectangle of width and height equal to the texture.geometry var1 &lt;- dem(dem,texture); \t// var1 equals a geometry as a rectangle of weight and height equal to the texture.geometry var2 &lt;- dem(dem,z_factor); \t// var2 equals a geometry as a rectangle of weight and height equal to the texture.geometry var3 &lt;- dem(dem); \t// var3 equals returns a geometry as a rectangle of width and height equal to the texture.detSame signification as determinantdeterminantPossible use:  determinant (matrix) —&gt;  floatResult:The determinant of the given matrixExamples:float var0 &lt;- determinant(matrix([[1,2],[3,4]])); \t// var0 equals -2diffPossible use:  float diff float —&gt;  float  diff (float , float) —&gt;  floatdiff2Possible use:  float diff2 float —&gt;  float  diff2 (float , float) —&gt;  floatdirectedPossible use:  directed (graph) —&gt;  graphResult:the operand graph becomes a directed graph.Comment:the operator alters the operand graph, it does not create a new one.See also:undirected,direction_betweenPossible use:  topology direction_between container&lt;geometry&gt; —&gt;  int  direction_between (topology , container&lt;geometry&gt;) —&gt;  intResult:A direction (in degree) between a list of two geometries (geometries, agents, points) considering a topology.Examples:int var0 &lt;- my_topology direction_between [ag1, ag2]; \t// var0 equals the direction between ag1 and ag2 considering the topology my_topologySee also:towards, direction_to, distance_to, distance_between, path_between, path_to,direction_toSame signification as towardsdisjoint_fromPossible use:  geometry disjoint_from geometry —&gt;  bool  disjoint_from (geometry , geometry) —&gt;  boolResult:A boolean, equal to true if the left-geometry (or agent/point) is disjoints from the right-geometry (or agent/point).Special cases:  if one of the operand is null, returns true.  if one operand is a point, returns false if the point is included in the geometry.Examples:bool var0 &lt;- polyline([{10,10},{20,20}]) disjoint_from polyline([{15,15},{25,25}]); \t// var0 equals falsebool var1 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var1 equals falsebool var2 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from {15,15}; \t// var2 equals falsebool var3 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from {25,25}; \t// var3 equals truebool var4 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{35,35},{35,45},{45,45},{45,35}]); \t// var4 equals trueSee also:intersects, crosses, overlaps, partially_overlaps, touches,distance_betweenPossible use:  topology distance_between container&lt;geometry&gt; —&gt;  float  distance_between (topology , container&lt;geometry&gt;) —&gt;  floatResult:A distance between a list of geometries (geometries, agents, points) considering a topology.Examples:float var0 &lt;- my_topology distance_between [ag1, ag2, ag3]; \t// var0 equals the distance between ag1, ag2 and ag3 considering the topology my_topologySee also:towards, direction_to, distance_to, direction_between, path_between, path_to,distance_toPossible use:  geometry distance_to geometry —&gt;  float  distance_to (geometry , geometry) —&gt;  float  point distance_to point —&gt;  float  distance_to (point , point) —&gt;  floatResult:A distance between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.Examples:float var0 &lt;- ag1 distance_to ag2; \t// var0 equals the distance between ag1 and ag2 considering the topology of the agent applying the operatorSee also:towards, direction_to, distance_between, direction_between, path_between, path_to,distinctPossible use:  distinct (container) —&gt;  containerResult:produces a set from the elements of the operand (i.e. a list without duplicated elements)Special cases:  if the operand is nil, remove_duplicates returns nil  if the operand is a graph, remove_duplicates returns the set of nodes  if the operand is a matrix, remove_duplicates returns a matrix without duplicated row  if the operand is a map, remove_duplicates returns the set of values without duplicatecontainer var1 &lt;- remove_duplicates([1::3,2::4,3::3,5::7]); \t// var1 equals [3,4,7]Examples:container var0 &lt;- remove_duplicates([3,2,5,1,2,3,5,5,5]); \t// var0 equals [3,2,5,1]distribution_ofPossible use:  distribution_of (container) —&gt;  map  container distribution_of int —&gt;  map  distribution_of (container , int) —&gt;  map  distribution_of (container, int, float, float) —&gt;  mapResult:Discretize a list of values into n bins (computes the bins from a numerical variable into n (default 10) bins. Returns a distribution map with the values (values key), the interval legends (legend key), the distribution parameters (params keys, for cumulative charts). Parameters can be (list), (list, nbbins) or (list,nbbins,valmin,valmax)Examples:map var0 &lt;- distribution_of([1,1,2,12.5]); \t// var0 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])map var1 &lt;- distribution_of([1,1,2,12.5],10); \t// var1 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])map var2 &lt;- distribution_of([1,1,2,12.5]); \t// var2 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])See also:as_map,distribution2d_ofPossible use:  container distribution2d_of container —&gt;  map  distribution2d_of (container , container) —&gt;  map  distribution2d_of (container, container, int, int) —&gt;  map  distribution2d_of (container, container, int, float, float, int, float, float) —&gt;  mapResult:Discretize two lists of values into n bins (computes the bins from a numerical variable into n (default 10) bins. Returns a distribution map with the values (values key), the interval legends (legend key), the distribution parameters (params keys, for cumulative charts). Parameters can be (list), (list, nbbins) or (list,nbbins,valmin,valmax)Examples:map var0 &lt;- distribution_of([1,1,2,12.5],10); \t// var0 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])map var1 &lt;- distribution2d_of([1,1,2,12.5]); \t// var1 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])map var2 &lt;- distribution_of([1,1,2,12.5],10); \t// var2 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])See also:as_map,divPossible use:  float div float —&gt;  int  div (float , float) —&gt;  int  int div int —&gt;  int  div (int , int) —&gt;  int  float div int —&gt;  int  div (float , int) —&gt;  int  int div float —&gt;  int  div (int , float) —&gt;  intResult:Returns the truncation of the division of the left-hand operand by the right-hand operand.Special cases:  if the right-hand operand is equal to zero, raises an exception.  if the right-hand operand is equal to zero, raises an exception.  if the right-hand operand is equal to zero, raises an exception.Examples:int var0 &lt;- 40.1 div 4.5; \t// var0 equals 8int var1 &lt;- 40 div 3; \t// var1 equals 13int var2 &lt;- 40.5 div 3; \t// var2 equals 13int var3 &lt;- 40 div 4.1; \t// var3 equals 9See also:mod,dxf_filePossible use:  dxf_file (string) —&gt;  fileResult:Constructs a file of type dxf. Allowed extensions are limited to dxfedgePossible use:  edge (pair) —&gt;  unknown  edge (unknown) —&gt;  unknown  unknown edge unknown —&gt;  unknown  edge (unknown , unknown) —&gt;  unknown  pair edge float —&gt;  unknown  edge (pair , float) —&gt;  unknown  unknown edge float —&gt;  unknown  edge (unknown , float) —&gt;  unknown  edge (unknown, unknown, unknown) —&gt;  unknown  edge (unknown, unknown, float) —&gt;  unknown  edge (pair, unknown, float) —&gt;  unknown  edge (unknown, unknown, unknown, float) —&gt;  unknownedge_betweenPossible use:  graph edge_between pair —&gt;  unknown  edge_between (graph , pair) —&gt;  unknownResult:returns the edge linking two nodesExamples:unknown var0 &lt;- graphFromMap edge_between node1::node2; \t// var0 equals edge1See also:out_edges_of, in_edges_of,edge_betweennessPossible use:  edge_betweenness (graph) —&gt;  mapResult:returns a map containing for each edge (key), its betweenness centrality (value): number of shortest paths passing through each edgeExamples:graph graphEpidemio &lt;- graph([]);map var1 &lt;- edge_betweenness(graphEpidemio); \t// var1 equals the edge betweenness index of the graphedgesPossible use:  edges (container) —&gt;  containereigenvaluesPossible use:  eigenvalues (matrix) —&gt;  list&lt;float&gt;Result:The eigen values (matrix) of the given matrixExamples:list&lt;float&gt; var0 &lt;- eigenvalues(matrix([[5,-3],[6,-4]])); \t// var0 equals [2.0000000000000004,-0.9999999999999998]electre_DMPossible use:  electre_DM (list&lt;list&gt;, list&lt;map&lt;string,object&gt;&gt;, float) —&gt;  intResult:The index of the best candidate according to a method based on the ELECTRE methods. The principle of the ELECTRE methods is to compare the possible candidates by pair. These methods analyses the possible outranking relation existing between two candidates. An candidate outranks another if this one is at least as good as the other one. The ELECTRE methods are based on two concepts: the concordance and the discordance. The concordance characterizes the fact that, for an outranking relation to be validated, a sufficient majority of criteria should be in favor of this assertion. The discordance characterizes the fact that, for an outranking relation to be validated, none of the criteria in the minority should oppose too strongly this assertion. These two conditions must be true for validating the outranking assertion. More information about the ELECTRE methods can be found in [http://www.springerlink.com/content/g367r44322876223/\tFigueira,  J., Mousseau, V., Roy, B.: ELECTRE Methods. In: Figueira, J., Greco, S., and Ehrgott, M., (Eds.), Multiple Criteria Decision Analysis: State of the Art Surveys, Springer, New York, 133–162 (2005)]. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains fives elements: a name, a weight, a preference value (p), an indifference value (q) and a veto value (v). The preference value represents the threshold from which the difference between two criterion values allows to prefer one vector of values over another. The indifference value represents the threshold from which the difference between two criterion values is considered significant. The veto value represents the threshold from which the difference between two criterion values disqualifies the candidate that obtained the smaller value; the last operand is the fuzzy cut.Special cases:  returns -1 is the list of candidates is nil or emptyExamples:int var0 &lt;- electre_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"weight\" :: 2.0,\"p\"::0.5, \"q\"::0.0, \"s\"::1.0, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: 1.0,\"p\"::0.5, \"q\"::0.0, \"s\"::1.0, \"maximize\" :: false]]); \t// var0 equals 0See also:weighted_means_DM, promethee_DM, evidence_theory_DM,ellipsePossible use:  float ellipse float —&gt;  geometry  ellipse (float , float) —&gt;  geometryResult:An ellipse geometry which x-radius is equal to the first operand and y-radius is equal to the second operandComment:the center of the ellipse is by default the location of the current agent in which has been called this operator.Special cases:  returns a point if both operands are lower or equal to 0, a line if only one is.Examples:geometry var0 &lt;- ellipse(10, 10); \t// var0 equals a geometry as an ellipse of width 10 and height 10.See also:around, cone, line, link, norm, point, polygon, polyline, rectangle, square, circle, squircle, triangle,emotionPossible use:  emotion (any) —&gt;  emotionResult:Casts the operand into the type emotionemptyPossible use:  empty (container&lt;KeyType,ValueType&gt;) —&gt;  bool  empty (string) —&gt;  boolResult:true if the operand is empty, false otherwise.Comment:the empty operator behavior depends on the nature of the operandSpecial cases:  if it is a map, empty returns true if the map contains no key-value mappings, and false otherwise  if it is a file, empty returns true if the content of the file (that is also a container) is empty, and false otherwise  if it is a population, empty returns true if there is no agent in the population, and false otherwise  if it is a graph, empty returns true if it contains no vertex and no edge, and false otherwise  if it is a matrix of int, float or object, it will return true if all elements are respectively 0, 0.0 or null, and false otherwise  if it is a matrix of geometry, it will return true if the matrix contains no cell, and false otherwise  if it is a list, empty returns true if there is no element in the list, and false otherwisebool var0 &lt;- empty([]); \t// var0 equals true  if it is a string, empty returns true if the string does not contain any character, and false otherwisebool var1 &lt;- empty ('abced'); \t// var1 equals falseenlarged_bySame signification as +envelopePossible use:  envelope (unknown) —&gt;  geometryResult:A 3D geometry that represents the box that surrounds the geometries or the surface described by the arguments. More general than geometry(arguments).envelope, as it allows to pass int, double, point, image files, shape files, asc files, or any list combining these arguments, in which case the envelope will be correctly expanded. If an envelope cannot be determined from the arguments, a default one of dimensions (0,100, 0, 100, 0, 100) is returnedeval_gamlPossible use:  eval_gaml (string) —&gt;  unknownResult:evaluates the given GAML string.Examples:unknown var0 &lt;- eval_gaml(\"2+3\"); \t// var0 equals 5eval_whenPossible use:  eval_when (BDIPlan) —&gt;  boolResult:evaluate the facet when of a given planExamples:eval_when(plan1)evenPossible use:  even (int) —&gt;  boolResult:Returns true if the operand is even and false if it is odd.Special cases:  if the operand is equal to 0, it returns true.  if the operand is a float, it is truncated beforeExamples:bool var0 &lt;- even (3); \t// var0 equals falsebool var1 &lt;- even(-12); \t// var1 equals trueeveryPossible use:  every (int) —&gt;  bool  every (any expression) —&gt;  bool  msi.gama.util.GamaDateInterval every any expression —&gt;  msi.gama.util.IList&lt;msi.gama.util.GamaDate&gt;  every (msi.gama.util.GamaDateInterval , any expression) —&gt;  msi.gama.util.IList&lt;msi.gama.util.GamaDate&gt;  container every int —&gt;  container  every (container , int) —&gt;  containerResult:true every operand * cycle, false otherwiseapplies a step to an interval of dates defined by ‘date1 to date2’expects a frequency (expressed in seconds of simulated time) as argument. Will return true every time the current_date matches with this frequencyRetrieves elements from the first argument every step (second argument) elements. Raises an error if the step is negative or equal to zeroComment:the value of the every operator depends on the cycle. It can be used to do something every x cycle.Used to do something at regular intervals of time. Can be used in conjunction with ‘since’, ‘after’, ‘before’, ‘until’ or ‘between’, so that this computation only takes place in the temporal segment defined by these operators. In all cases, the starting_date of the model is used as a reference starting pointExamples:if every(2) {write \"the cycle number is even\";}\t     else {write \"the cycle number is odd\";}(date('2000-01-01') to date('2010-01-01')) every (#month) // builds an interval between these two dates which contains all the monthly dates starting from the beginning of the intervalreflex when: every(2#days) since date('2000-01-01') { .. }state a { transition to: b when: every(2#mn);} state b { transition to: a when: every(30#s);} // This oscillatory behavior will use the starting_date of the model as its starting point in timeSee also:to, since, after,every_cycleSame signification as everyevidence_theory_DMPossible use:  list&lt;list&gt; evidence_theory_DM list&lt;map&lt;string,object&gt;&gt; —&gt;  int  evidence_theory_DM (list&lt;list&gt; , list&lt;map&lt;string,object&gt;&gt;) —&gt;  int  evidence_theory_DM (list&lt;list&gt;, list&lt;map&lt;string,object&gt;&gt;, bool) —&gt;  intResult:The index of the best candidate according to a method based on the Evidence theory. This theory, which was proposed by Shafer ([http://www.glennshafer.com/books/amte.html Shafer G (1976) A mathematical theory of evidence, Princeton University Press]), is based on the work of Dempster ([http://projecteuclid.org/DPubS?service=UI&amp;version=1.0&amp;verb=Display&amp;handle=euclid.aoms/1177698950 Dempster A (1967) Upper and lower probabilities induced by multivalued mapping. Annals of Mathematical Statistics, vol.  38, pp. 325–339]) on lower and upper probability distributions. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains seven elements: a name, a first threshold s1, a second threshold s2, a value for the assertion “this candidate is the best” at threshold s1 (v1p), a value for the assertion “this candidate is the best” at threshold s2 (v2p), a value for the assertion “this candidate is not the best” at threshold s1 (v1c), a value for the assertion “this candidate is not the best” at threshold s2 (v2c). v1p, v2p, v1c and v2c have to been defined in order that: v1p + v1c &lt;= 1.0; v2p + v2c &lt;= 1.0.; the last operand allows to use a simple version of this multi-criteria decision making method (simple if true)Special cases:  if the operator is used with only 2 operands (the candidates and the criteria), the last parameter (use simple method) is set to true  returns -1 is the list of candidates is nil or emptyExamples:int var0 &lt;- evidence_theory_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"s1\" :: 0.0,\"s2\"::1.0, \"v1p\"::0.0, \"v2p\"::1.0, \"v1c\"::0.0, \"v2c\"::0.0, \"maximize\" :: true],[\"name\"::\"price\",  \"s1\" :: 0.0,\"s2\"::1.0, \"v1p\"::0.0, \"v2p\"::1.0, \"v1c\"::0.0, \"v2c\"::0.0, \"maximize\" :: true]], true); \t// var0 equals 0See also:weighted_means_DM, electre_DM,expPossible use:  exp (float) —&gt;  float  exp (int) —&gt;  floatResult:Returns Euler’s number e raised to the power of the operand.Special cases:  the operand is casted to a float before being evaluated.  the operand is casted to a float before being evaluated.Examples:float var0 &lt;- exp (0); \t// var0 equals 1.0See also:ln,factPossible use:  fact (int) —&gt;  floatResult:Returns the factorial of the operand.Special cases:  if the operand is less than 0, fact returns 0.Examples:float var0 &lt;- fact(4); \t// var0 equals 24farthest_point_toPossible use:  geometry farthest_point_to point —&gt;  point  farthest_point_to (geometry , point) —&gt;  pointResult:the farthest point of the left-operand to the left-point.Examples:point var0 &lt;- geom farthest_point_to(pt); \t// var0 equals the farthest point of geom to ptSee also:any_location_in, any_point_in, closest_points_with, points_at,farthest_toPossible use:  container&lt;agent&gt; farthest_to geometry —&gt;  geometry  farthest_to (container&lt;agent&gt; , geometry) —&gt;  geometryResult:An agent or a geometry among the left-operand list of agents, species or meta-population (addition of species), the farthest to the operand (casted as a geometry).Comment:the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.Examples:geometry var0 &lt;- [ag1, ag2, ag3] closest_to(self); \t// var0 equals return the farthest agent among ag1, ag2 and ag3 to the agent applying the operator.(species1 + species2) closest_to selfSee also:neighbors_at, neighbors_of, inside, overlapping, agents_overlapping, agents_inside, agent_closest_to, closest_to, agent_farthest_to,filePossible use:  file (string) —&gt;  file  string file container —&gt;  file  file (string , container) —&gt;  fileResult:opens a file in read only mode, creates a GAML file object, and tries to determine and store the file content in the contents attribute.Creates a file in read/write mode, setting its contents to the container passed in parameterComment:The file should have a supported extension, see file type definition for supported file extensions.The type of container to pass will depend on the type of file (see the management of files in the documentation). Can be used to copy files since files are considered as containers. For example: save file(‘image_copy.png’, file(‘image.png’)); will copy image.png to image_copy.pngSpecial cases:  If the specified string does not refer to an existing file, an exception is risen when the variable is used.Examples:let fileT type: file value: file(\"../includes/Stupid_Cell.Data\"); \t\t\t// fileT represents the file \"../includes/Stupid_Cell.Data\"\t\t\t// fileT.contents here contains a matrix storing all the data of the text fileSee also:folder, new_folder,file_existsPossible use:  file_exists (string) —&gt;  boolResult:Test whether the parameter is the path to an existing file.firstPossible use:  first (string) —&gt;  string  first (container&lt;KeyType,ValueType&gt;) —&gt;  ValueType  int first container —&gt;  container  first (int , container) —&gt;  containerResult:the first value of the operandComment:the first operator behavior depends on the nature of the operandSpecial cases:  if it is a map, first returns the first value of the first pair (in insertion order)  if it is a file, first returns the first element of the content of the file (that is also a container)  if it is a population, first returns the first agent of the population  if it is a graph, first returns the first edge (in creation order)  if it is a matrix, first returns the element at {0,0} in the matrix  for a matrix of int or float, it will return 0 if the matrix is empty  for a matrix of object or geometry, it will return nil if the matrix is empty  if it is a string, first returns a string composed of its first characterstring var0 &lt;- first ('abce'); \t// var0 equals 'a'  if it is a list, first returns the first element of the list, or nil if the list is emptyint var1 &lt;- first ([1, 2, 3]); \t// var1 equals 1See also:last,first_ofSame signification as firstfirst_withPossible use:  container first_with any expression —&gt;  unknown  first_with (container , any expression) —&gt;  unknownResult:the first element of the left-hand operand that makes the right-hand operand evaluate to true.Comment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  if the left-hand operand is nil, first_with throws an error. If there is no element that satisfies the condition, it returns nil  if the left-operand is a map, the keyword each will contain each valueunknown var4 &lt;- [1::2, 3::4, 5::6] first_with (each &gt;= 4); \t// var4 equals 4unknown var5 &lt;- [1::2, 3::4, 5::6].pairs first_with (each.value &gt;= 4); \t// var5 equals 3::4Examples:unknown var0 &lt;- [1,2,3,4,5,6,7,8] first_with (each &gt; 3); \t// var0 equals 4unknown var2 &lt;- g2 first_with (length(g2 out_edges_of each) = 0); \t// var2 equals node9unknown var3 &lt;- (list(node) first_with (round(node(each).location.x) &gt; 32); \t// var3 equals node2See also:group_by, last_with, where,flipPossible use:  flip (float) —&gt;  boolResult:true or false given the probability represented by the operandSpecial cases:  flip 0 always returns false, flip 1 trueExamples:bool var0 &lt;- flip (0.66666); \t// var0 equals 2/3 chances to return true.See also:rnd,floatPossible use:  float (any) —&gt;  floatResult:Casts the operand into the type floatfloorPossible use:  floor (float) —&gt;  floatResult:Maps the operand to the largest previous following integer, i.e. the largest integer not greater than x.Examples:float var0 &lt;- floor(3); \t// var0 equals 3.0float var1 &lt;- floor(3.5); \t// var1 equals 3.0float var2 &lt;- floor(-4.7); \t// var2 equals -5.0See also:ceil, round,folderPossible use:  folder (string) —&gt;  fileResult:opens an existing repositorySpecial cases:  If the specified string does not refer to an existing repository, an exception is risen.Examples:folder(\"../includes/\")file dirT &lt;- folder(\"../includes/\");\t\t\t\t// dirT represents the repository \"../includes/\"\t\t\t\t// dirT.contents here contains the list of the names of included filesSee also:file, new_folder,fontPossible use:  font (string, int, int) —&gt;  fontResult:Creates a new font, by specifying its name (either a font face name like ‘Lucida Grande Bold’ or ‘Helvetica’, or a logical name like ‘Dialog’, ‘SansSerif’, ‘Serif’, etc.), a size in points and a style, either #bold, #italic or #plain or a combination (addition) of them.Examples:font var0 &lt;- font ('Helvetica Neue',12, #bold + #italic); \t// var0 equals a bold and italic face of the Helvetica Neue familyfrequency_ofPossible use:  container frequency_of any expression —&gt;  map  frequency_of (container , any expression) —&gt;  mapResult:Returns a map with keys equal to the application of the right-hand argument (like collect) and values equal to the frequency of this key (i.e. how many times it has been obtained)Examples:map var0 &lt;- [ag1, ag2, ag3, ag4] frequency_of each.size; \t// var0 equals the different sizes as keys and the number of agents of this size as valuesSee also:as_map,fromSame signification as sincefuzzy_kappaPossible use:  fuzzy_kappa (list&lt;agent&gt;, list, list, list&lt;float&gt;, list, matrix&lt;float&gt;, float) —&gt;  float  fuzzy_kappa (list&lt;agent&gt;, list, list, list&lt;float&gt;, list, matrix&lt;float&gt;, float, list) —&gt;  floatResult:fuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance, weights). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling &amp; Software, 21fuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling &amp; Software, 21Examples:fuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2, [1.0,3.0,2.0,2.0,4.0])fuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2)fuzzy_kappa_simPossible use:  fuzzy_kappa_sim (list&lt;agent&gt;, list, list, list, list&lt;float&gt;, list, matrix&lt;float&gt;, float) —&gt;  float  fuzzy_kappa_sim (list&lt;agent&gt;, list, list, list, list&lt;float&gt;, list, matrix&lt;float&gt;, float, list) —&gt;  floatResult:fuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800, fuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance, weights). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800,Examples:fuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2)fuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2,[1.0,3.0,2.0,2.0,4.0])gaml_filePossible use:  gaml_file (string) —&gt;  fileResult:Constructs a file of type gaml. Allowed extensions are limited to gaml, experimentgamma_indexPossible use:  gamma_index (graph) —&gt;  floatResult:returns the gamma index of the graph (A measure of connectivity that considers the relationship between the number of observed links and the number of possible links: gamma = e/(3 * (v - 2)) - for planar graph.Examples:graph graphEpidemio &lt;- graph([]);float var1 &lt;- gamma_index(graphEpidemio); \t// var1 equals the gamma index of the graphSee also:alpha_index, beta_index, nb_cycles, connectivity_index,gamma_rndPossible use:  float gamma_rnd float —&gt;  float  gamma_rnd (float , float) —&gt;  floatResult:returns a random value from a gamma distribution with specified values of the shape and scale parametersExamples:gamma_rnd(10.0,5.0)gaussPossible use:  gauss (point) —&gt;  float  float gauss float —&gt;  float  gauss (float , float) —&gt;  floatResult:A value from a normally distributed random variable with expected value (mean) and variance (standardDeviation). The probability density function of such a variable is a Gaussian.A value from a normally distributed random variable with expected value (mean) and variance (standardDeviation). The probability density function of such a variable is a Gaussian.Special cases:  when the operand is a point, it is read as {mean, standardDeviation}  when standardDeviation value is 0.0, it always returns the mean value  when the operand is a point, it is read as {mean, standardDeviation}  when standardDeviation value is 0.0, it always returns the mean valueExamples:float var0 &lt;- gauss(0,0.3); \t// var0 equals 0.22354float var1 &lt;- gauss(0,0.3); \t// var1 equals -0.1357float var2 &lt;- gauss({0,0.3}); \t// var2 equals 0.22354float var3 &lt;- gauss({0,0.3}); \t// var3 equals -0.1357See also:skew_gauss, truncated_gauss, poisson,generate_barabasi_albertPossible use:  generate_barabasi_albert (container&lt;agent&gt;, species, int, bool) —&gt;  graph  generate_barabasi_albert (species, species, int, int, bool) —&gt;  graphResult:returns a random scale-free network (following Barabasi-Albert (BA) model).returns a random scale-free network (following Barabasi-Albert (BA) model).Comment:The Barabasi-Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:The Barabasi-Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:Special cases:  “vertices_specy”: the species of vertices  “edges_species”: the species of edges  “size”: the graph will contain (size + 1) nodes  “m”: the number of edges added per novel node  “synchronized”: is the graph and the species of vertices and edges synchronized?  “agents”: list of existing node agents  “edges_species”: the species of edges  “size”: the graph will contain (size + 1) nodes  “m”: the number of edges added per novel node  “synchronized”: is the graph and the species of vertices and edges synchronized?Examples:graph&lt;yourNodeSpecy,yourEdgeSpecy&gt; graphEpidemio &lt;- generate_barabasi_albert(\t\tyourNodeSpecy,\t\tyourEdgeSpecy,\t\t3,\t\t5,\t\ttrue);graph&lt;yourNodeSpecy,yourEdgeSpecy&gt; graphEpidemio &lt;- generate_barabasi_albert(\t\tyourListOfNodes,\t\tyourEdgeSpecy,\t\t3,\t\t5,\t\ttrue);See also:generate_watts_strogatz,generate_complete_graphPossible use:  generate_complete_graph (container&lt;agent&gt;, species, bool) —&gt;  graph  generate_complete_graph (container&lt;agent&gt;, species, float, bool) —&gt;  graph  generate_complete_graph (species, species, int, bool) —&gt;  graph  generate_complete_graph (species, species, int, float, bool) —&gt;  graphResult:returns a fully connected graph.returns a fully connected graph.returns a fully connected graph.returns a fully connected graph.Comment:Arguments should include following elements:Arguments should include following elements:Arguments should include following elements:Arguments should include following elements:Special cases:  “agents”: list of existing node agents  “edges_species”: the species of edges  “layoutRadius”: nodes of the graph will be located on a circle with radius layoutRadius and centered in the environment.  “synchronized”: is the graph and the species of vertices and edges synchronized?  “vertices_specy”: the species of vertices  “edges_species”: the species of edges  “size”: the graph will contain size nodes.  “layoutRadius”: nodes of the graph will be located on a circle with radius layoutRadius and centered in the environment.  “synchronized”: is the graph and the species of vertices and edges synchronized?  “vertices_specy”: the species of vertices  “edges_species”: the species of edges  “size”: the graph will contain size nodes.  “synchronized”: is the graph and the species of vertices and edges synchronized?  “agents”: list of existing node agents  “edges_species”: the species of edges  “synchronized”: is the graph and the species of vertices and edges synchronized?Examples:graph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_complete_graph(\t\t\tmyListOfNodes,\t\t\tmyEdgeSpecy,\t\t\t25,\t\ttrue);graph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_complete_graph(\t\t\tmyVertexSpecy,\t\t\tmyEdgeSpecy,\t\t\t10, 25,\t\ttrue);graph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_complete_graph(\t\t\tmyVertexSpecy,\t\t\tmyEdgeSpecy,\t\t\t10,\t\ttrue);graph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_complete_graph(\t\t\tmyListOfNodes,\t\t\tmyEdgeSpecy,\t\ttrue);See also:generate_barabasi_albert, generate_watts_strogatz,generate_watts_strogatzPossible use:  generate_watts_strogatz (container&lt;agent&gt;, species, float, int, bool) —&gt;  graph  generate_watts_strogatz (species, species, int, float, int, bool) —&gt;  graphResult:returns a random small-world network (following Watts-Strogatz model).returns a random small-world network (following Watts-Strogatz model).Comment:The Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:The Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:Special cases:  “vertices_specy”: the species of vertices  “edges_species”: the species of edges  “size”: the graph will contain (size + 1) nodes. Size must be greater than k.  “p”: probability to “rewire” an edge. So it must be between 0 and 1. The parameter is often called beta in the literature.  “k”: the base degree of each node. k must be greater than 2 and even.  “synchronized”: is the graph and the species of vertices and edges synchronized?  “agents”: list of existing node agents  “edges_species”: the species of edges  “p”: probability to “rewire” an edge. So it must be between 0 and 1. The parameter is often called beta in the literature.  “k”: the base degree of each node. k must be greater than 2 and even.  “synchronized”: is the graph and the species of vertices and edges synchronized?Examples:graph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_watts_strogatz(\t\t\tmyVertexSpecy,\t\t\tmyEdgeSpecy,\t\t\t2,\t\t\t0.3,\t\t\t2,\t\ttrue);graph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_watts_strogatz(\t\t\tmyListOfNodes,\t\t\tmyEdgeSpecy,\t\t\t0.3,\t\t\t2,\t\ttrue);See also:generate_barabasi_albert,geojson_filePossible use:  geojson_file (string) —&gt;  fileResult:Constructs a file of type geojson. Allowed extensions are limited to json, geojson, geo.jsongeometric_meanPossible use:  geometric_mean (container) —&gt;  floatResult:the geometric mean of the elements of the operand. See Geometric_mean for more details.Comment:The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.Examples:float var0 &lt;- geometric_mean ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 4.962326343467649See also:mean, median, harmonic_mean,geometryPossible use:  geometry (any) —&gt;  geometryResult:Casts the operand into the type geometrygeometry_collectionPossible use:  geometry_collection (container&lt;geometry&gt;) —&gt;  geometryResult:A geometry collection (multi-geometry) composed of the given list of geometries.Special cases:  if the operand is nil, returns the point geometry {0,0}  if the operand is composed of a single geometry, returns a copy of the geometry.Examples:geometry var0 &lt;- geometry_collection([{0,0}, {0,10}, {10,10}, {10,0}]); \t// var0 equals a geometry composed of the 4 points (multi-point).See also:around, circle, cone, link, norm, point, polygone, rectangle, square, triangle, line,getPossible use:  geometry get string —&gt;  unknown  get (geometry , string) —&gt;  unknown  agent get string —&gt;  unknown  get (agent , string) —&gt;  unknownResult:Reads an attribute of the specified geometry (left operand). The attribute name is specified by the right operand.Reads an attribute of the specified agent (left operand). The attribute name is specified by the right operand.Special cases:  Reading the attribute of a geometrystring geom_area &lt;- a_geometry get('area');     // reads then 'area' attribute of 'a_geometry' variable then assigns the returned value to the geom_area variable  Reading the attribute of another agentstring agent_name &lt;- an_agent get('name');     // reads then 'name' attribute of an_agent then assigns the returned value to the agent_name variableget_aboutPossible use:  get_about (emotion) —&gt;  predicateResult:get the about value of the given emotionExamples:get_about(emotion)get_agentPossible use:  get_agent (msi.gaml.architecture.simplebdi.SocialLink) —&gt;  agentResult:get the agent value of the given social linkExamples:get_agent(social_link1)get_agent_causePossible use:  get_agent_cause (emotion) —&gt;  agent  get_agent_cause (predicate) —&gt;  agentResult:get the agent cause value of the given emotionExamples:get_agent_cause(emotion)get_decayPossible use:  get_decay (emotion) —&gt;  floatResult:get the decay value of the given emotionExamples:get_decay(emotion)get_dominancePossible use:  get_dominance (msi.gaml.architecture.simplebdi.SocialLink) —&gt;  floatResult:get the dominance value of the given social linkExamples:get_dominance(social_link1)get_familiarityPossible use:  get_familiarity (msi.gaml.architecture.simplebdi.SocialLink) —&gt;  floatResult:get the familiarity value of the given social linkExamples:get_familiarity(social_link1)get_intensityPossible use:  get_intensity (emotion) —&gt;  floatResult:get the intensity value of the given emotionExamples:emotion set_intensity 12get_lifetimePossible use:  get_lifetime (predicate) —&gt;  intget_likingPossible use:  get_liking (msi.gaml.architecture.simplebdi.SocialLink) —&gt;  floatResult:get the liking value of the given social linkExamples:get_liking(social_link1)get_praiseworthinessPossible use:  get_praiseworthiness (predicate) —&gt;  floatget_priorityPossible use:  get_priority (predicate) —&gt;  floatget_solidarityPossible use:  get_solidarity (msi.gaml.architecture.simplebdi.SocialLink) —&gt;  floatResult:get the solidarity value of the given social linkExamples:get_solidarity(social_link1)get_super_intentionPossible use:  get_super_intention (predicate) —&gt;  predicategif_filePossible use:  gif_file (string) —&gt;  fileResult:Constructs a file of type gif. Allowed extensions are limited to gifginiPossible use:  gini (list&lt;float&gt;) —&gt;  floatSpecial cases:  return the Gini Index of the given list of values (list of floats)float var0 &lt;- gini([1.0, 0.5, 2.0]); \t// var0 equals the gini index computedgraphPossible use:  graph (any) —&gt;  graphResult:Casts the operand into the type graphgrayscalePossible use:  grayscale (rgb) —&gt;  rgbResult:Converts rgb color to grayscale valueComment:r=red, g=green, b=blue. Between 0 and 255 and gray = 0.299 * red + 0.587 * green + 0.114 * blue (Photoshop value)Examples:rgb var0 &lt;- grayscale (rgb(255,0,0)); \t// var0 equals to a dark greySee also:rgb, hsb,grid_atPossible use:  species grid_at point —&gt;  agent  grid_at (species , point) —&gt;  agentResult:returns the cell of the grid (right-hand operand) at the position given by the right-hand operandComment:If the left-hand operand is a point of floats, it is used as a point of ints.Special cases:  if the left-hand operand is not a grid cell species, returns nilExamples:agent var0 &lt;- grid_cell grid_at {1,2}; \t// var0 equals the agent grid_cell with grid_x=1 and grid_y = 2grid_cells_to_graphPossible use:  grid_cells_to_graph (container) —&gt;  graphResult:creates a graph from a list of cells (operand). An edge is created between neighbors.Examples:my_cell_graph&lt;-grid_cells_to_graph(cells_list)grid_filePossible use:  grid_file (string) —&gt;  fileResult:Constructs a file of type grid. Allowed extensions are limited to asc, tifgroup_byPossible use:  container group_by any expression —&gt;  map  group_by (container , any expression) —&gt;  mapResult:Returns a map, where the keys take the possible values of the right-hand operand and the map values are the list of elements of the left-hand operand associated to the key valueComment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  if the left-hand operand is nil, group_by throws an errorExamples:map var0 &lt;- [1,2,3,4,5,6,7,8] group_by (each &gt; 3); \t// var0 equals [false::[1, 2, 3], true::[4, 5, 6, 7, 8]]map var1 &lt;- g2 group_by (length(g2 out_edges_of each) ); \t// var1 equals [ 0::[node9, node7, node10, node8, node11], 1::[node6], 2::[node5], 3::[node4]]map var2 &lt;- (list(node) group_by (round(node(each).location.x)); \t// var2 equals [32::[node5], 21::[node1], 4::[node0], 66::[node2], 96::[node3]]map var3 &lt;- [1::2, 3::4, 5::6] group_by (each &gt; 4); \t// var3 equals [false::[2, 4], true::[6]]See also:first_with, last_with, where,harmonic_meanPossible use:  harmonic_mean (container) —&gt;  floatResult:the harmonic mean of the elements of the operand. See Harmonic_mean for more details.Comment:The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.Examples:float var0 &lt;- harmonic_mean ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 4.804159445407279See also:mean, median, geometric_mean,hexagonPossible use:  hexagon (point) —&gt;  geometry  hexagon (float) —&gt;  geometryResult:A hexagon geometry which the given with and heightComment:the center of the hexagon is by default the location of the current agent in which has been called this operator.the center of the hexagon is by default the location of the current agent in which has been called this operator.Special cases:  returns nil if the operand is nil.  returns nil if the operand is nil.Examples:geometry var0 &lt;- hexagon({10,5}); \t// var0 equals a geometry as a hexagon of width of 10 and height of 5.geometry var1 &lt;- hexagon(10); \t// var1 equals a geometry as a hexagon of width of 10 and height of 10.See also:around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, triangle,hierarchical_clusteringPossible use:  container&lt;agent&gt; hierarchical_clustering float —&gt;  container  hierarchical_clustering (container&lt;agent&gt; , float) —&gt;  containerResult:A tree (list of list) contained groups of agents clustered by distance considering a distance min between two groups.Comment:use of hierarchical clustering with Minimum for linkage criterion between two groups of agents.Examples:container var0 &lt;- [ag1, ag2, ag3, ag4, ag5] hierarchical_clustering 20.0; \t// var0 equals for example, can return [[[ag1],[ag3]], [ag2], [[[ag4],[ag5]],[ag6]]See also:simple_clustering_by_distance,hsbPossible use:  hsb (float, float, float) —&gt;  rgb  hsb (float, float, float, int) —&gt;  rgb  hsb (float, float, float, float) —&gt;  rgbResult:Converts hsb (h=hue, s=saturation, b=brightness) value to Gama colorComment:h,s and b components should be floating-point values between 0.0 and 1.0 and when used alpha should be an integer (between 0 and 255) or a float (between 0 and 1) . Examples: Red=(0.0,1.0,1.0), Yellow=(0.16,1.0,1.0), Green=(0.33,1.0,1.0), Cyan=(0.5,1.0,1.0), Blue=(0.66,1.0,1.0), Magenta=(0.83,1.0,1.0)Examples:rgb var0 &lt;- hsb (0.5,1.0,1.0,0.0); \t// var0 equals rgb(\"cyan\",0)rgb var1 &lt;- hsb (0.0,1.0,1.0); \t// var1 equals rgb(\"red\")See also:rgb,hypotPossible use:  hypot (float, float, float, float) —&gt;  floatResult:Returns sqrt(x2 +y2) without intermediate overflow or underflow.Special cases:  If either argument is infinite, then the result is positive infinity. If either argument is NaN and neither argument is infinite, then the result is NaN.Examples:float var0 &lt;- hypot(0,1,0,1); \t// var0 equals sqrt(2)IDWPossible use:  IDW (container&lt;agent&gt;, map&lt;point,float&gt;, int) —&gt;  map&lt;agent,float&gt;Result:Inverse Distance Weighting (IDW) is a type of deterministic method for multivariate interpolation with a known scattered set of points. The assigned values to each geometry are calculated with a weighted average of the values available at the known points. See: http://en.wikipedia.org/wiki/Inverse_distance_weighting Usage: IDW (list of geometries, map of points (key: point, value: value), power parameter)Examples:map&lt;agent,float&gt; var0 &lt;- IDW([ag1, ag2, ag3, ag4, ag5],[{10,10}::25.0, {10,80}::10.0, {100,10}::15.0], 2); \t// var0 equals for example, can return [ag1::12.0, ag2::23.0,ag3::12.0,ag4::14.0,ag5::17.0]image_filePossible use:  image_file (string) —&gt;  fileResult:Constructs a file of type image. Allowed extensions are limited to tiff, jpg, jpeg, png, pict, bmpinPossible use:  unknown in container —&gt;  bool  in (unknown , container) —&gt;  bool  string in string —&gt;  bool  in (string , string) —&gt;  boolResult:true if the right operand contains the left operand, false otherwiseComment:the definition of in depends on the containerSpecial cases:  if the right operand is nil or empty, in returns false  if both operands are strings, returns true if the left-hand operand patterns is included in to the right-hand string;Examples:bool var0 &lt;- 2 in [1,2,3,4,5,6]; \t// var0 equals truebool var1 &lt;- 7 in [1,2,3,4,5,6]; \t// var1 equals falsebool var2 &lt;- 3 in [1::2, 3::4, 5::6]; \t// var2 equals falsebool var3 &lt;- 6 in [1::2, 3::4, 5::6]; \t// var3 equals truebool var4 &lt;-  'bc' in 'abcded'; \t// var4 equals trueSee also:contains,in_degree_ofPossible use:  graph in_degree_of unknown —&gt;  int  in_degree_of (graph , unknown) —&gt;  intResult:returns the in degree of a vertex (right-hand operand) in the graph given as left-hand operand.Examples:int var1 &lt;- graphFromMap in_degree_of (node(3)); \t// var1 equals 2See also:out_degree_of, degree_of,in_edges_ofPossible use:  graph in_edges_of unknown —&gt;  container  in_edges_of (graph , unknown) —&gt;  containerResult:returns the list of the in-edges of a vertex (right-hand operand) in the graph given as left-hand operand.Examples:container var1 &lt;- graphFromMap in_edges_of node({12,45}); \t// var1 equals [LineString]See also:out_edges_of,indented_byPossible use:  string indented_by int —&gt;  string  indented_by (string , int) —&gt;  stringResult:Converts a (possibly multiline) string by indenting it by a number – specified by the second operand – of tabulations to the rightindex_byPossible use:  container index_by any expression —&gt;  map  index_by (container , any expression) —&gt;  mapResult:produces a new map from the evaluation of the right-hand operand for each element of the left-hand operandSpecial cases:  if the left-hand operand is nil, index_by throws an error. If the operation results in duplicate keys, only the first value corresponding to the key is keptExamples:map var0 &lt;- [1,2,3,4,5,6,7,8] index_by (each - 1); \t// var0 equals [0::1, 1::2, 2::3, 3::4, 4::5, 5::6, 6::7, 7::8]index_ofPossible use:  container index_of unknown —&gt;  int  index_of (container , unknown) —&gt;  int  map index_of unknown —&gt;  unknown  index_of (map , unknown) —&gt;  unknown  matrix index_of unknown —&gt;  point  index_of (matrix , unknown) —&gt;  point  string index_of string —&gt;  int  index_of (string , string) —&gt;  int  species index_of unknown —&gt;  int  index_of (species , unknown) —&gt;  intResult:the index of the first occurence of the right operand in the left operand containerthe index of the first occurence of the right operand in the left operand containerComment:The definition of index_of and the type of the index depend on the containerSpecial cases:  if the left operand is a map, index_of returns the index of a value or nil if the value is not mapped  if the left operator is a species, returns the index of an agent in a species. If the argument is not an agent of this species, returns -1. Use int(agent) instead  if the left operand is a list, index_of returns the index as an integerint var1 &lt;- [1,2,3,4,5,6] index_of 4; \t// var1 equals 3int var2 &lt;- [4,2,3,4,5,4] index_of 4; \t// var2 equals 0  if the left operand is a matrix, index_of returns the index as a pointpoint var3 &lt;- matrix([[1,2,3],[4,5,6]]) index_of 4; \t// var3 equals {1.0,0.0}  if both operands are strings, returns the index within the left-hand string of the first occurrence of the given right-hand stringint var4 &lt;-  \"abcabcabc\" index_of \"ca\"; \t// var4 equals 2Examples:unknown var0 &lt;- [1::2, 3::4, 5::6] index_of 4; \t// var0 equals 3See also:at, last_index_of,insidePossible use:  container&lt;agent&gt; inside geometry —&gt;  list&lt;geometry&gt;  inside (container&lt;agent&gt; , geometry) —&gt;  list&lt;geometry&gt;Result:A list of agents or geometries among the left-operand list, species or meta-population (addition of species), covered by the operand (casted as a geometry).Examples:list&lt;geometry&gt; var0 &lt;- [ag1, ag2, ag3] inside(self); \t// var0 equals the agents among ag1, ag2 and ag3 that are covered by the shape of the right-hand argument.list&lt;geometry&gt; var1 &lt;- (species1 + species2) inside (self); \t// var1 equals the agents among species species1 and species2 that are covered by the shape of the right-hand argument.See also:neighbors_at, neighbors_of, closest_to, overlapping, agents_overlapping, agents_inside, agent_closest_to,intPossible use:  int (any) —&gt;  intResult:Casts the operand into the type intinterPossible use:  container inter container —&gt;  container  inter (container , container) —&gt;  container  geometry inter geometry —&gt;  geometry  inter (geometry , geometry) —&gt;  geometryResult:the intersection of the two operandsA geometry resulting from the intersection between the two geometriesComment:both containers are transformed into sets (so without duplicated element, cf. remove_deplicates operator) before the set intersection is computed.Special cases:  if an operand is a graph, it will be transformed into the set of its nodes  returns nil if one of the operands is nil  if an operand is a map, it will be transformed into the set of its valuescontainer var0 &lt;- [1::2, 3::4, 5::6] inter [2,4]; \t// var0 equals [2,4]container var1 &lt;- [1::2, 3::4, 5::6] inter [1,3]; \t// var1 equals []  if an operand is a matrix, it will be transformed into the set of the linescontainer var2 &lt;- matrix([[1,2,3],[4,5,4]]) inter [3,4]; \t// var2 equals [3,4]Examples:container var3 &lt;- [1,2,3,4,5,6] inter [2,4]; \t// var3 equals [2,4]container var4 &lt;- [1,2,3,4,5,6] inter [0,8]; \t// var4 equals []geometry var5 &lt;- square(10) inter circle(5); \t// var5 equals circle(5)See also:remove_duplicates, union, +, -,interleavePossible use:  interleave (container) —&gt;  containerResult:a new list containing the interleaved elements of the containers contained in the operandComment:the operand should be a list of lists of elements. The result is a list of elements.Examples:container var0 &lt;- interleave([1,2,4,3,5,7,6,8]); \t// var0 equals [1,2,4,3,5,7,6,8]container var1 &lt;- interleave([['e11','e12','e13'],['e21','e22','e23'],['e31','e32','e33']]); \t// var1 equals ['e11','e21','e31','e12','e22','e32','e13','e23','e33']internal_atPossible use:  agent internal_at container —&gt;  unknown  internal_at (agent , container) —&gt;  unknown  geometry internal_at container —&gt;  unknown  internal_at (geometry , container) —&gt;  unknown  container&lt;KeyType,ValueType&gt; internal_at list&lt;KeyType&gt; —&gt;  ValueType  internal_at (container&lt;KeyType,ValueType&gt; , list&lt;KeyType&gt;) —&gt;  ValueTypeResult:For internal use only. Corresponds to the implementation, for agents, of the access to containers with [index]For internal use only. Corresponds to the implementation, for geometries, of the access to containers with [index]For internal use only. Corresponds to the implementation of the access to containers with [index]See also:at,internal_integrated_valuePossible use:  any expression internal_integrated_value any expression —&gt;  container  internal_integrated_value (any expression , any expression) —&gt;  containerResult:For internal use only. Corresponds to the implementation, for agents, of the access to containers with [index]internal_zero_order_equationPossible use:  internal_zero_order_equation (any expression) —&gt;  floatintersectionSame signification as interintersectsPossible use:  geometry intersects geometry —&gt;  bool  intersects (geometry , geometry) —&gt;  boolResult:A boolean, equal to true if the left-geometry (or agent/point) intersects the right-geometry (or agent/point).Special cases:  if one of the operand is null, returns false.Examples:bool var0 &lt;- square(5) intersects {10,10}; \t// var0 equals falseSee also:disjoint_from, crosses, overlaps, partially_overlaps, touches,inversePossible use:  inverse (matrix) —&gt;  matrix&lt;float&gt;Result:The inverse matrix of the given matrix. If no inverse exists, returns a matrix that has properties that resemble that of an inverse.Examples:matrix&lt;float&gt; var0 &lt;- inverse(matrix([[5,-3],[6,-4]])); \t// var0 equals [2.0000000000000004,-0.9999999999999998]inverse_distance_weightingSame signification as IDWisPossible use:  unknown is any expression —&gt;  bool  is (unknown , any expression) —&gt;  boolResult:returns true if the left operand is of the right operand type, false otherwiseExamples:bool var0 &lt;- 0 is int; \t// var0 equals truebool var1 &lt;- an_agent is node; \t// var1 equals truebool var2 &lt;- 1 is float; \t// var2 equals falseis_csvPossible use:  is_csv (any) —&gt;  boolResult:Tests whether the operand is a csv file.is_dxfPossible use:  is_dxf (any) —&gt;  boolResult:Tests whether the operand is a dxf file.is_finitePossible use:  is_finite (float) —&gt;  boolResult:Returns whether the argument is a finite number or notExamples:bool var0 &lt;- is_finite(4.66); \t// var0 equals truebool var1 &lt;- is_finite(#infinity); \t// var1 equals falseis_gamlPossible use:  is_gaml (any) —&gt;  boolResult:Tests whether the operand is a gaml file.is_geojsonPossible use:  is_geojson (any) —&gt;  boolResult:Tests whether the operand is a geojson file.is_gifPossible use:  is_gif (any) —&gt;  boolResult:Tests whether the operand is a gif file.is_gridPossible use:  is_grid (any) —&gt;  boolResult:Tests whether the operand is a grid file.is_imagePossible use:  is_image (any) —&gt;  boolResult:Tests whether the operand is a image file.is_jsonPossible use:  is_json (any) —&gt;  boolResult:Tests whether the operand is a json file.is_numberPossible use:  is_number (string) —&gt;  bool  is_number (float) —&gt;  boolResult:tests whether the operand represents a numerical valueReturns whether the argument is a real number or notComment:Note that the symbol . should be used for a float value (a string with , will not be considered as a numeric value). Symbols e and E are also accepted. A hexadecimal value should begin with #.Examples:bool var0 &lt;- is_number(\"test\"); \t// var0 equals falsebool var1 &lt;- is_number(\"123.56\"); \t// var1 equals truebool var2 &lt;- is_number(\"-1.2e5\"); \t// var2 equals truebool var3 &lt;- is_number(\"1,2\"); \t// var3 equals falsebool var4 &lt;- is_number(\"#12FA\"); \t// var4 equals truebool var5 &lt;- is_number(4.66); \t// var5 equals truebool var6 &lt;- is_number(#infinity); \t// var6 equals truebool var7 &lt;- is_number(#nan); \t// var7 equals falseis_objPossible use:  is_obj (any) —&gt;  boolResult:Tests whether the operand is a obj file.is_osmPossible use:  is_osm (any) —&gt;  boolResult:Tests whether the operand is a osm file.is_pgmPossible use:  is_pgm (any) —&gt;  boolResult:Tests whether the operand is a pgm file.is_propertyPossible use:  is_property (any) —&gt;  boolResult:Tests whether the operand is a property file.is_RPossible use:  is_R (any) —&gt;  boolResult:Tests whether the operand is a R file.is_shapePossible use:  is_shape (any) —&gt;  boolResult:Tests whether the operand is a shape file.is_skillPossible use:  unknown is_skill string —&gt;  bool  is_skill (unknown , string) —&gt;  boolResult:returns true if the left operand is an agent whose species implements the right-hand skill nameExamples:bool var0 &lt;- agentA is_skill 'moving'; \t// var0 equals trueis_svgPossible use:  is_svg (any) —&gt;  boolResult:Tests whether the operand is a svg file.is_textPossible use:  is_text (any) —&gt;  boolResult:Tests whether the operand is a text file.is_threedsPossible use:  is_threeds (any) —&gt;  boolResult:Tests whether the operand is a threeds file.is_URLPossible use:  is_URL (any) —&gt;  boolResult:Tests whether the operand is a URL file.is_xmlPossible use:  is_xml (any) —&gt;  boolResult:Tests whether the operand is a xml file.json_filePossible use:  json_file (string) —&gt;  fileResult:Constructs a file of type json. Allowed extensions are limited to jsonkappaPossible use:  kappa (list, list, list) —&gt;  float  kappa (list, list, list, list) —&gt;  floatResult:kappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20.kappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories, weights). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20.Examples:kappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3])float var1 &lt;- kappa([1,3,5,1,5],[1,1,1,1,5],[1,3,5]); \t// var1 equals the similarity between 0 and 1float var2 &lt;- kappa([1,1,1,1,5],[1,1,1,1,5],[1,3,5]); \t// var2 equals 1.0kappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3], [1.0, 2.0, 3.0, 1.0, 5.0])kappa_simPossible use:  kappa_sim (list, list, list, list) —&gt;  float  kappa_sim (list, list, list, list, list) —&gt;  floatResult:kappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories). Reference: van Vliet, J., Bregt, A.K. &amp; Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8).kappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories, weights). Reference: van Vliet, J., Bregt, A.K. &amp; Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8)Examples:kappa([cat1,cat1,cat2,cat2,cat2],[cat2,cat1,cat2,cat1,cat3],[cat2,cat1,cat2,cat3,cat3], [cat1,cat2,cat3])kappa([cat1,cat1,cat2,cat2,cat2],[cat2,cat1,cat2,cat1,cat3],[cat2,cat1,cat2,cat3,cat3], [cat1,cat2,cat3],[1.0, 2.0, 3.0, 1.0, 5.0])kmeansPossible use:  list kmeans int —&gt;  list&lt;list&gt;  kmeans (list , int) —&gt;  list&lt;list&gt;  kmeans (list, int, int) —&gt;  list&lt;list&gt;Result:returns the list of clusters (list of instance indices) computed with the kmeans++ algorithm from the first operand data according to the number of clusters to split the data into (k) and the maximum number of iterations to run the algorithm for (If negative, no maximum will be used) (maxIt). Usage: kmeans(data,k,maxit)returns the list of clusters (list of instance indices) computed with the kmeans++ algorithm from the first operand data according to the number of clusters to split the data into (k). Usage: kmeans(data,k)Special cases:  if the lengths of two vectors in the right-hand aren’t equal, returns 0  if the lengths of two vectors in the right-hand aren’t equal, returns 0Examples:kmeans ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],2,10)kmeans ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],2)kurtosisPossible use:  kurtosis (list) —&gt;  floatResult:returns kurtosis value computed from the operand list of valuesSpecial cases:  if the length of the list is lower than 3, returns NaNExamples:kurtosis ([1,2,3,4,5])lastPossible use:  last (string) —&gt;  string  last (container&lt;KeyType,ValueType&gt;) —&gt;  ValueType  int last container —&gt;  container  last (int , container) —&gt;  containerResult:the last element of the operandComment:the last operator behavior depends on the nature of the operandSpecial cases:  if it is a map, last returns the value of the last pair (in insertion order)  if it is a file, last returns the last element of the content of the file (that is also a container)  if it is a population, last returns the last agent of the population  if it is a graph, last returns a list containing the last edge created  if it is a matrix, last returns the element at {length-1,length-1} in the matrix  for a matrix of int or float, it will return 0 if the matrix is empty  for a matrix of object or geometry, it will return nil if the matrix is empty  if it is a string, last returns a string composed of its last character, or an empty string if the operand is emptystring var0 &lt;- last ('abce'); \t// var0 equals 'e'  if it is a list, last returns the last element of the list, or nil if the list is emptyint var1 &lt;- last ([1, 2, 3]); \t// var1 equals 3See also:first,last_index_ofPossible use:  map last_index_of unknown —&gt;  unknown  last_index_of (map , unknown) —&gt;  unknown  string last_index_of string —&gt;  int  last_index_of (string , string) —&gt;  int  species last_index_of unknown —&gt;  int  last_index_of (species , unknown) —&gt;  int  container last_index_of unknown —&gt;  int  last_index_of (container , unknown) —&gt;  int  matrix last_index_of unknown —&gt;  point  last_index_of (matrix , unknown) —&gt;  pointResult:the index of the last occurence of the right operand in the left operand containerComment:The definition of last_index_of and the type of the index depend on the containerSpecial cases:  if the left operand is a species, the last index of an agent is the same as its index  if the left operand is a map, last_index_of returns the index as an int (the key of the pair)unknown var0 &lt;- [1::2, 3::4, 5::4] last_index_of 4; \t// var0 equals 5  if both operands are strings, returns the index within the left-hand string of the rightmost occurrence of the given right-hand stringint var1 &lt;- \"abcabcabc\" last_index_of \"ca\"; \t// var1 equals 5  if the left operand is a list, last_index_of returns the index as an integerint var2 &lt;- [1,2,3,4,5,6] last_index_of 4; \t// var2 equals 3int var3 &lt;- [4,2,3,4,5,4] last_index_of 4; \t// var3 equals 5  if the left operand is a matrix, last_index_of returns the index as a pointpoint var4 &lt;- matrix([[1,2,3],[4,5,4]]) last_index_of 4; \t// var4 equals {1.0,2.0}See also:at, index_of, last_index_of,last_ofSame signification as lastlast_withPossible use:  container last_with any expression —&gt;  unknown  last_with (container , any expression) —&gt;  unknownResult:the last element of the left-hand operand that makes the right-hand operand evaluate to true.Comment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  if the left-hand operand is nil, last_with throws an error.  If there is no element that satisfies the condition, it returns nil  if the left-operand is a map, the keyword each will contain each valueunknown var4 &lt;- [1::2, 3::4, 5::6] last_with (each &gt;= 4); \t// var4 equals 6unknown var5 &lt;- [1::2, 3::4, 5::6].pairs last_with (each.value &gt;= 4); \t// var5 equals 5::6Examples:unknown var0 &lt;- [1,2,3,4,5,6,7,8] last_with (each &gt; 3); \t// var0 equals 8unknown var2 &lt;- g2 last_with (length(g2 out_edges_of each) = 0 ); \t// var2 equals node11unknown var3 &lt;- (list(node) last_with (round(node(each).location.x) &gt; 32); \t// var3 equals node3See also:group_by, first_with, where,layoutPossible use:  graph layout string —&gt;  graph  layout (graph , string) —&gt;  graph  layout (graph, string, int) —&gt;  graph  layout (graph, string, int, map&lt;string,unknown&gt;) —&gt;  graphResult:layouts a GAMA graph.lengthPossible use:  length (string) —&gt;  int  length (container&lt;KeyType,ValueType&gt;) —&gt;  intResult:the number of elements contained in the operandComment:the length operator behavior depends on the nature of the operandSpecial cases:  if it is a population, length returns number of agents of the population  if it is a graph, length returns the number of vertexes or of edges (depending on the way it was created)  if it is a string, length returns the number of charactersint var0 &lt;- length ('I am an agent'); \t// var0 equals 13  if it is a list or a map, length returns the number of elements in the list or mapint var1 &lt;- length([12,13]); \t// var1 equals 2int var2 &lt;- length([]); \t// var2 equals 0  if it is a matrix, length returns the number of cellsint var3 &lt;- length(matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]])); \t// var3 equals 6linePossible use:  line (container&lt;geometry&gt;) —&gt;  geometry  container&lt;geometry&gt; line float —&gt;  geometry  line (container&lt;geometry&gt; , float) —&gt;  geometryResult:A polyline geometry from the given list of points represented as a cylinder of radius r.A polyline geometry from the given list of points.Special cases:  if the operand is nil, returns the point geometry {0,0}  if the operand is composed of a single point, returns a point geometry.  if the operand is nil, returns the point geometry {0,0}  if the operand is composed of a single point, returns a point geometry.  if a radius is added, the given list of points represented as a cylinder of radius rgeometry var0 &lt;- polyline([{0,0}, {0,10}, {10,10}, {10,0}],0.2); \t// var0 equals a polyline geometry composed of the 4 points.Examples:geometry var1 &lt;- polyline([{0,0}, {0,10}, {10,10}, {10,0}]); \t// var1 equals a polyline geometry composed of the 4 points.See also:around, circle, cone, link, norm, point, polygone, rectangle, square, triangle,linkPossible use:  geometry link geometry —&gt;  geometry  link (geometry , geometry) —&gt;  geometryResult:A dynamic line geometry between the location of the two operandsComment:The geometry of the link is a line between the locations of the two operands, which is built and maintained dynamicallySpecial cases:  if one of the operands is nil, link returns a point geometry at the location of the other. If both are null, it returns a point geometry at {0,0}Examples:geometry var0 &lt;- link (geom1,geom2); \t// var0 equals a link geometry between geom1 and geom2.See also:around, circle, cone, line, norm, point, polygon, polyline, rectangle, square, triangle,listPossible use:  list (any) —&gt;  listResult:Casts the operand into the type listlist_withPossible use:  int list_with any expression —&gt;  container  list_with (int , any expression) —&gt;  containerResult:creates a list with a size provided by the first operand, and filled with the second operandComment:Note that the right operand  should be positive, and that the second one is evaluated for each position  in the list.See also:list,lnPossible use:  ln (int) —&gt;  float  ln (float) —&gt;  floatResult:Returns the natural logarithm (base e) of the operand.Special cases:  an exception is raised if the operand is less than zero.Examples:float var0 &lt;- ln(1); \t// var0 equals 0.0float var1 &lt;- ln(exp(1)); \t// var1 equals 1.0See also:exp,load_graph_from_filePossible use:  load_graph_from_file (string) —&gt;  graph  string load_graph_from_file file —&gt;  graph  load_graph_from_file (string , file) —&gt;  graph  string load_graph_from_file string —&gt;  graph  load_graph_from_file (string , string) —&gt;  graph  load_graph_from_file (string, species, species) —&gt;  graph  load_graph_from_file (string, file, species, species) —&gt;  graph  load_graph_from_file (string, string, species, species) —&gt;  graph  load_graph_from_file (string, string, species, species, bool) —&gt;  graphResult:loads a graph from a filereturns a graph loaded from a given file encoded into a given format. The last boolean parameter indicates whether the resulting graph will be considered as spatial or not by GAMAComment:Available formats: “pajek”: Pajek (Slovene word for Spider) is a program, for Windows, for analysis and visualization of large networks. See: http://pajek.imfm.si/doku.php?id=pajek for more details.”lgl”: LGL is a compendium of applications for making the visualization of large networks and trees tractable. See: http://lgl.sourceforge.net/ for more details.”dot”: DOT is a plain text graph description language. It is a simple way of describing graphs that both humans and computer programs can use. See: http://en.wikipedia.org/wiki/DOT_language for more details.”edge”: This format is a simple text file with numeric vertex ids defining the edges.”gexf”: GEXF (Graph Exchange XML Format) is a language for describing complex networks structures, their associated data and dynamics. Started in 2007 at Gephi project by different actors, deeply involved in graph exchange issues, the gexf specifications are mature enough to claim being both extensible and open, and suitable for real specific applications. See: http://gexf.net/format/ for more details.”graphml”: GraphML is a comprehensive and easy-to-use file format for graphs based on XML. See: http://graphml.graphdrawing.org/ for more details.”tlp” or “tulip”: TLP is the Tulip software graph format. See: http://tulip.labri.fr/TulipDrupal/?q=tlp-file-format for more details. “ncol”: This format is used by the Large Graph Layout progra. It is simply a symbolic weighted edge list. It is a simple text file with one edge per line. An edge is defined by two symbolic vertex names separated by whitespace. (The symbolic vertex names themselves cannot contain whitespace.) They might followed by an optional number, this will be the weight of the edge. See: http://bioinformatics.icmb.utexas.edu/lgl for more details.The map operand should includes following elements:Available formats: “pajek”: Pajek (Slovene word for Spider) is a program, for Windows, for analysis and visualization of large networks. See: http://pajek.imfm.si/doku.php?id=pajek for more details.”lgl”: LGL is a compendium of applications for making the visualization of large networks and trees tractable. See: http://lgl.sourceforge.net/ for more details.”dot”: DOT is a plain text graph description language. It is a simple way of describing graphs that both humans and computer programs can use. See: http://en.wikipedia.org/wiki/DOT_language for more details.”edge”: This format is a simple text file with numeric vertex ids defining the edges.”gexf”: GEXF (Graph Exchange XML Format) is a language for describing complex networks structures, their associated data and dynamics. Started in 2007 at Gephi project by different actors, deeply involved in graph exchange issues, the gexf specifications are mature enough to claim being both extensible and open, and suitable for real specific applications. See: http://gexf.net/format/ for more details.”graphml”: GraphML is a comprehensive and easy-to-use file format for graphs based on XML. See: http://graphml.graphdrawing.org/ for more details.”tlp” or “tulip”: TLP is the Tulip software graph format. See: http://tulip.labri.fr/TulipDrupal/?q=tlp-file-format for more details. “ncol”: This format is used by the Large Graph Layout progra. It is simply a symbolic weighted edge list. It is a simple text file with one edge per line. An edge is defined by two symbolic vertex names separated by whitespace. (The symbolic vertex names themselves cannot contain whitespace.) They might followed by an optional number, this will be the weight of the edge. See: http://bioinformatics.icmb.utexas.edu/lgl for more details.The map operand should includes following elements:Special cases:  “format”: the format of the file  “filename”: the filename of the file containing the network  “edges_species”: the species of edges  “vertices_specy”: the species of vertices  “format”: the format of the file  “filename”: the filename of the file containing the network  “edges_species”: the species of edges  “vertices_specy”: the species of vertices  “format”: the format of the file, “file”: the file containing the network, “edges_species”: the species of edges, “vertices_specy”: the species of verticesgraph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- load_graph_from_file(\t\t\t\"pajek\",\t\t\t\"example_of_Pajek_file\",\t\t\tmyVertexSpecy,\t\t\tmyEdgeSpecy );  “filename”: the filename of the file containing the network, “edges_species”: the species of edges, “vertices_specy”: the species of verticesgraph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- load_graph_from_file(\t\t\t\"pajek\",\t\t\t\"./example_of_Pajek_file\",\t\t\tmyVertexSpecy,\t\t\tmyEdgeSpecy );  “file”: the file containing the networkgraph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- load_graph_from_file(\t\t\t\"pajek\",\t\t\t\"example_of_Pajek_file\");  “format”: the format of the file, “file”: the file containing the networkgraph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- load_graph_from_file(\t\t\t\"pajek\",\t\t\t\"example_of_Pajek_file\");  “format”: the format of the file, “filename”: the filename of the file containing the networkgraph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- load_graph_from_file(\t\t\t\"pajek\",\t\t\t\"example_of_Pajek_file\");Examples:graph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- load_graph_from_file(\t\t\t\"pajek\",\t\t\t\"./example_of_Pajek_file\",\t\t\tmyVertexSpecy,\t\t\tmyEdgeSpecy);graph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- load_graph_from_file(\t\t\t\"pajek\",\t\t\t\"./example_of_Pajek_file\",\t\t\tmyVertexSpecy,\t\t\tmyEdgeSpecy , true);load_shortest_pathsPossible use:  graph load_shortest_paths matrix —&gt;  graph  load_shortest_paths (graph , matrix) —&gt;  graphResult:put in the graph cache the computed shortest paths contained in the matrix (rows: source, columns: target)Examples:graph var0 &lt;- load_shortest_paths(shortest_paths_matrix); \t// var0 equals return my_graph with all the shortest paths computedlogPossible use:  log (float) —&gt;  float  log (int) —&gt;  floatResult:Returns the logarithm (base 10) of the operand.Special cases:  an exception is raised if the operand is equals or less than zero.Examples:float var0 &lt;- log(10); \t// var0 equals 1.0float var1 &lt;- log(1); \t// var1 equals 0.0See also:ln,lower_casePossible use:  lower_case (string) —&gt;  stringResult:Converts all of the characters in the string operand to lower caseExamples:string var0 &lt;- lower_case(\"Abc\"); \t// var0 equals 'abc'See also:upper_case,mapPossible use:  map (any) —&gt;  mapResult:Casts the operand into the type mapmasked_byPossible use:  geometry masked_by container&lt;geometry&gt; —&gt;  geometry  masked_by (geometry , container&lt;geometry&gt;) —&gt;  geometry  masked_by (geometry, container&lt;geometry&gt;, int) —&gt;  geometryExamples:geometry var0 &lt;- perception_geom masked_by obstacle_list; \t// var0 equals the geometry representing the part of perception_geom visible from the agent position considering the list of obstacles obstacle_list.geometry var1 &lt;- perception_geom masked_by obstacle_list; \t// var1 equals the geometry representing the part of perception_geom visible from the agent position considering the list of obstacles obstacle_list.materialPossible use:  float material float —&gt;  msi.gama.util.GamaMaterial  material (float , float) —&gt;  msi.gama.util.GamaMaterialResult:ReturnsExamples:See also:,matrixPossible use:  matrix (any) —&gt;  matrixResult:Casts the operand into the type matrixmatrix_withPossible use:  point matrix_with any expression —&gt;  matrix  matrix_with (point , any expression) —&gt;  matrixResult:creates a matrix with a size provided by the first operand, and filled with the second operandComment:Note that both components of the right operand point should be positive, otherwise an exception is raised.See also:matrix, as_matrix,maxPossible use:  max (container) —&gt;  unknownResult:the maximum element found in the operandComment:the max operator behavior depends on the nature of the operandSpecial cases:  if it is a population of a list of other type: max transforms all elements into integer and returns the maximum of them  if it is a map, max returns the maximum among the list of all elements value  if it is a file, max returns the maximum of the content of the file (that is also a container)  if it is a graph, max returns the maximum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)  if it is a matrix of int, float or object, max returns the maximum of all the numerical elements (thus all elements for integer and float matrices)  if it is a matrix of geometry, max returns the maximum of the list of the geometries  if it is a matrix of another type, max returns the maximum of the elements transformed into float  if it is a list of int of float, max returns the maximum of all the elementsunknown var0 &lt;- max ([100, 23.2, 34.5]); \t// var0 equals 100.0  if it is a list of points: max returns the maximum of all points as a point (i.e. the point with the greatest coordinate on the x-axis, in case of equality the point with the greatest coordinate on the y-axis is chosen. If all the points are equal, the first one is returned. )unknown var1 &lt;- max([{1.0,3.0},{3.0,5.0},{9.0,1.0},{7.0,8.0}]); \t// var1 equals {9.0,1.0}See also:min,max_ofPossible use:  container max_of any expression —&gt;  unknown  max_of (container , any expression) —&gt;  unknownResult:the maximum value of the right-hand expression evaluated on each of the elements of the left-hand operandComment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  As of GAMA 1.6, if the left-hand operand is nil or empty, max_of throws an error  if the left-operand is a map, the keyword each will contain each valueunknown var5 &lt;- [1::2, 3::4, 5::6] max_of (each + 3); \t// var5 equals 6Examples:unknown var1 &lt;- [1,2,4,3,5,7,6,8] max_of (each * 100 ); \t// var1 equals 800graph g2 &lt;- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);unknown var3 &lt;- g2.vertices max_of (g2 degree_of( each )); \t// var3 equals 2unknown var4 &lt;- (list(node) max_of (round(node(each).location.x)); \t// var4 equals 96See also:min_of,maximal_cliques_ofPossible use:  maximal_cliques_of (graph) —&gt;  list&lt;list&gt;Result:returns the maximal cliques of a graph using the Bron-Kerbosch clique detection algorithm: A clique is maximal if it is impossible to enlarge it by adding another vertex from the graph. Note that a maximal clique is not necessarily the biggest clique in the graph.Examples:graph my_graph &lt;- graph([]);list&lt;list&gt; var1 &lt;- maximal_cliques_of (my_graph); \t// var1 equals the list of all the maximal cliques as listSee also:biggest_cliques_of,meanPossible use:  mean (container) —&gt;  unknownResult:the mean of all the elements of the operandComment:the elements of the operand are summed (see sum for more details about the sum of container elements ) and then the sum value is divided by the number of elements.Special cases:  if the container contains points, the result will be a point. If the container contains rgb values, the result will be a rgb colorExamples:unknown var0 &lt;- mean ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 5.125 See also:sum,mean_deviationPossible use:  mean_deviation (container) —&gt;  floatResult:the deviation from the mean of all the elements of the operand. See Mean_deviation for more details.Comment:The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.Examples:float var0 &lt;- mean_deviation ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 1.125See also:mean, standard_deviation,mean_ofPossible use:  container mean_of any expression —&gt;  unknown  mean_of (container , any expression) —&gt;  unknownResult:the mean of the right-hand expression evaluated on each of the elements of the left-hand operandComment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  if the left-operand is a map, the keyword each will contain each valueunknown var2 &lt;- [1::2, 3::4, 5::6] mean_of (each); \t// var2 equals 4Examples:unknown var1 &lt;- [1,2] mean_of (each * 10 ); \t// var1 equals 15See also:min_of, max_of, sum_of, product_of,meanRPossible use:  meanR (container) —&gt;  unknownResult:returns the mean value of given vector (right-hand operand) in given variable  (left-hand operand).Examples:list&lt;int&gt; X &lt;- [2, 3, 1];int var1 &lt;- meanR(X); \t// var1 equals 2medianPossible use:  median (container) —&gt;  unknownResult:the median of all the elements of the operand.Special cases:  if the container contains points, the result will be a point. If the container contains rgb values, the result will be a rgb colorExamples:unknown var0 &lt;- median ([4.5, 3.5, 5.5, 3.4, 7.0]); \t// var0 equals 5.0See also:mean,messagePossible use:  message (unknown) —&gt;  msi.gama.extensions.messaging.GamaMessageResult:to be addedmilliseconds_betweenPossible use:  date milliseconds_between date —&gt;  float  milliseconds_between (date , date) —&gt;  floatResult:Provide the exact number of milliseconds between two dates. This number can be positive or negative (if the second operand is smaller than the first one)Examples:milliseconds_between(d1, d2) -: 10 minPossible use:  min (container) —&gt;  unknownResult:the minimum element found in the operand.Comment:the min operator behavior depends on the nature of the operandSpecial cases:  if it is a list of points: min returns the minimum of all points as a point (i.e. the point with the smallest coordinate on the x-axis, in case of equality the point with the smallest coordinate on the y-axis is chosen. If all the points are equal, the first one is returned. )  if it is a population of a list of other types: min transforms all elements into integer and returns the minimum of them  if it is a map, min returns the minimum among the list of all elements value  if it is a file, min returns the minimum of the content of the file (that is also a container)  if it is a graph, min returns the minimum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)  if it is a matrix of int, float or object, min returns the minimum of all the numerical elements (thus all elements for integer and float matrices)  if it is a matrix of geometry, min returns the minimum of the list of the geometries  if it is a matrix of another type, min returns the minimum of the elements transformed into float  if it is a list of int or float: min returns the minimum of all the elementsunknown var0 &lt;- min ([100, 23.2, 34.5]); \t// var0 equals 23.2See also:max,min_ofPossible use:  container min_of any expression —&gt;  unknown  min_of (container , any expression) —&gt;  unknownResult:the minimum value of the right-hand expression evaluated on each of the elements of the left-hand operandComment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  if the left-hand operand is nil or empty, min_of throws an error  if the left-operand is a map, the keyword each will contain each valueunknown var5 &lt;- [1::2, 3::4, 5::6] min_of (each + 3); \t// var5 equals 5Examples:unknown var1 &lt;- [1,2,4,3,5,7,6,8] min_of (each * 100 ); \t// var1 equals 100graph g2 &lt;- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);unknown var3 &lt;- g2 min_of (length(g2 out_edges_of each) ); \t// var3 equals 0unknown var4 &lt;- (list(node) min_of (round(node(each).location.x)); \t// var4 equals 4See also:max_of,minus_daysPossible use:  date minus_days int —&gt;  date  minus_days (date , int) —&gt;  dateResult:Subtract a given number of days from a dateExamples:date1 minus_days 20minus_hoursPossible use:  date minus_hours int —&gt;  date  minus_hours (date , int) —&gt;  dateResult:Remove a given number of hours from a dateExamples:date1 minus_hours 15 // equivalent to date1 - 15 #hminus_minutesPossible use:  date minus_minutes int —&gt;  date  minus_minutes (date , int) —&gt;  dateResult:Subtract a given number of minutes from a dateExamples:date1 minus_minutes 5 // equivalent to date1 - 5#mnminus_monthsPossible use:  date minus_months int —&gt;  date  minus_months (date , int) —&gt;  dateResult:Subtract a given number of months from a dateExamples:date1 minus_months 5minus_msPossible use:  date minus_ms int —&gt;  date  minus_ms (date , int) —&gt;  dateResult:Remove a given number of milliseconds from a dateExamples:date1 minus_ms 15 // equivalent to date1 - 15 #msminus_secondsSame signification as -minus_weeksPossible use:  date minus_weeks int —&gt;  date  minus_weeks (date , int) —&gt;  dateResult:Subtract a given number of weeks from a dateExamples:date1 minus_weeks 15minus_yearsPossible use:  date minus_years int —&gt;  date  minus_years (date , int) —&gt;  dateResult:Subtract a given number of year from a dateExamples:date1 minus_years 3modPossible use:  int mod int —&gt;  int  mod (int , int) —&gt;  intResult:Returns the remainder of the integer division of the left-hand operand by the right-hand operand.Special cases:  if operands are float, they are truncated  if the right-hand operand is equal to zero, raises an exception.Examples:int var0 &lt;- 40 mod 3; \t// var0 equals 1See also:div,months_betweenPossible use:  date months_between date —&gt;  int  months_between (date , date) —&gt;  intResult:Provide the exact number of months between two dates. This number can be positive or negative (if the second operand is smaller than the first one)Examples:months_between(d1, d2) -: 10 moranPossible use:  list&lt;float&gt; moran matrix&lt;float&gt; —&gt;  float  moran (list&lt;float&gt; , matrix&lt;float&gt;) —&gt;  floatSpecial cases:  return the Moran Index of the given list of interest points (list of floats) and the weight matrix (matrix of float)float var0 &lt;- moran([1.0, 0.5, 2.0], weight_matrix); \t// var0 equals the Moran index computedmulPossible use:  mul (container) —&gt;  unknownResult:the product of all the elements of the operandComment:the mul operator behavior depends on the nature of the operandSpecial cases:  if it is a list of points: mul returns the product of all points as a point (each coordinate is the product of the corresponding coordinate of each element)  if it is a list of other types: mul transforms all elements into integer and multiplies them  if it is a map, mul returns the product of the value of all elements  if it is a file, mul returns the product of the content of the file (that is also a container)  if it is a graph, mul returns the product of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)  if it is a matrix of int, float or object, mul returns the product of all the numerical elements (thus all elements for integer and float matrices)  if it is a matrix of geometry, mul returns the product of the list of the geometries  if it is a matrix of other types: mul transforms all elements into float and multiplies them  if it is a list of int or float: mul returns the product of all the elementsunknown var0 &lt;- mul ([100, 23.2, 34.5]); \t// var0 equals 80040.0See also:sum,nb_cyclesPossible use:  nb_cycles (graph) —&gt;  intResult:returns the maximum number of independent cycles in a graph. This number (u) is estimated through the number of nodes (v), links (e) and of sub-graphs (p): u = e - v + p.Examples:graph graphEpidemio &lt;- graph([]);int var1 &lt;- nb_cycles(graphEpidemio); \t// var1 equals the number of cycles in the graphSee also:alpha_index, beta_index, gamma_index, connectivity_index,neighbors_atPossible use:  geometry neighbors_at float —&gt;  container  neighbors_at (geometry , float) —&gt;  containerResult:a list, containing all the agents of the same species than the left argument (if it is an agent) located at a distance inferior or equal to the right-hand operand to the left-hand operand (geometry, agent, point).Comment:The topology used to compute the neighborhood  is the one of the left-operand if this one is an agent; otherwise the one of the agent applying the operator.Examples:container var0 &lt;- (self neighbors_at (10)); \t// var0 equals all the agents located at a distance lower or equal to 10 to the agent applying the operator.See also:neighbors_of, closest_to, overlapping, agents_overlapping, agents_inside, agent_closest_to, at_distance,neighbors_ofPossible use:  graph neighbors_of unknown —&gt;  container  neighbors_of (graph , unknown) —&gt;  container  topology neighbors_of agent —&gt;  container  neighbors_of (topology , agent) —&gt;  container  neighbors_of (topology, geometry, float) —&gt;  containerResult:a list, containing all the agents of the same species than the argument (if it is an agent) located at a distance inferior or equal to 1 to the right-hand operand agent considering the left-hand operand topology.Special cases:  a list, containing all the agents of the same species than the left argument (if it is an agent) located at a distance inferior or equal to the third argument to the second argument (agent, geometry or point) considering the first operand topology.container var3 &lt;- neighbors_of (topology(self), self,10); \t// var3 equals all the agents located at a distance lower or equal to 10 to the agent applying the operator considering its topology.Examples:container var0 &lt;- graphEpidemio neighbors_of (node(3)); \t// var0 equals [node0,node2]container var1 &lt;- graphFromMap neighbors_of node({12,45}); \t// var1 equals [{1.0,5.0},{34.0,56.0}]container var2 &lt;- topology(self) neighbors_of self; \t// var2 equals returns all the agents located at a distance lower or equal to 1 to the agent applying the operator considering its topology.See also:predecessors_of, successors_of, neighbors_at, closest_to, overlapping, agents_overlapping, agents_inside, agent_closest_to,new_emotionPossible use:  new_emotion (string) —&gt;  emotion  string new_emotion agent —&gt;  emotion  new_emotion (string , agent) —&gt;  emotion  string new_emotion float —&gt;  emotion  new_emotion (string , float) —&gt;  emotion  string new_emotion predicate —&gt;  emotion  new_emotion (string , predicate) —&gt;  emotion  new_emotion (string, float, predicate) —&gt;  emotion  new_emotion (string, float, float) —&gt;  emotion  new_emotion (string, predicate, agent) —&gt;  emotion  new_emotion (string, float, agent) —&gt;  emotion  new_emotion (string, float, float, agent) —&gt;  emotion  new_emotion (string, float, predicate, float) —&gt;  emotion  new_emotion (string, float, predicate, agent) —&gt;  emotion  new_emotion (string, float, predicate, float, agent) —&gt;  emotionResult:a new emotion with the given properties (name)a new emotion with the given properties (name)a new emotion with the given properties (name,intensity,about)a new emotion with the given properties (name,intensity,decay)a new emotion with the given properties (name)a new emotion with the given properties (name, intensity)a new emotion with the given properties (name,about)a new emotion with the given properties (name)a new emotion with the given properties (name)a new emotion with the given properties (name)a new emotion with the given properties (name)a new emotion with the given properties (name)Examples:emotion(\"joy\",12.3,eatFood,4)emotion(\"joy\",12.3,eatFood,4)emotion(\"joy\",12.3,eatFood)emotion(\"joy\",12.3,4)emotion(\"joy\",12.3,eatFood,4)emotion(\"joy\",12.3)emotion(\"joy\",eatFood)emotion(\"joy\")emotion(\"joy\",12.3,eatFood,4)emotion(\"joy\",12.3,eatFood,4)emotion(\"joy\",12.3,eatFood,4)emotion(\"joy\",12.3,eatFood,4)new_folderPossible use:  new_folder (string) —&gt;  fileResult:opens an existing repository or create a new folder if it does not exist.Special cases:  If the specified string does not refer to an existing repository, the repository is created.  If the string refers to an existing file, an exception is risen.Examples:file dirNewT &lt;- new_folder(\"incl/\");   \t// dirNewT represents the repository \"../incl/\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// eventually creates the directory ../inclSee also:folder, file,new_predicatePossible use:  new_predicate (string) —&gt;  predicate  string new_predicate agent —&gt;  predicate  new_predicate (string , agent) —&gt;  predicate  string new_predicate float —&gt;  predicate  new_predicate (string , float) —&gt;  predicate  string new_predicate int —&gt;  predicate  new_predicate (string , int) —&gt;  predicate  string new_predicate map —&gt;  predicate  new_predicate (string , map) —&gt;  predicate  string new_predicate bool —&gt;  predicate  new_predicate (string , bool) —&gt;  predicate  new_predicate (string, map, float) —&gt;  predicate  new_predicate (string, map, int) —&gt;  predicate  new_predicate (string, map, agent) —&gt;  predicate  new_predicate (string, map, bool) —&gt;  predicate  new_predicate (string, map, int, bool) —&gt;  predicate  new_predicate (string, map, bool, agent) —&gt;  predicate  new_predicate (string, map, float, int) —&gt;  predicate  new_predicate (string, map, int, agent) —&gt;  predicate  new_predicate (string, map, float, agent) —&gt;  predicate  new_predicate (string, map, float, bool) —&gt;  predicate  new_predicate (string, map, float, int, bool) —&gt;  predicate  new_predicate (string, map, int, bool, agent) —&gt;  predicate  new_predicate (string, map, float, bool, agent) —&gt;  predicate  new_predicate (string, map, float, int, agent) —&gt;  predicate  new_predicate (string, map, float, int, bool, agent) —&gt;  predicateResult:a new predicate with the given properties (name, values, lifetime, is_true)a new predicate with the given properties (name, values, priority)a new predicate with the given properties (name, values, priority, lifetime, is_true, agentCause)a new predicate with the given properties (name, values, is_true, agentCause)a new predicate with the given properties (name, values, lifetime)a new predicate with the given properties (name, values, priority, lifetime, is_true)a new predicate with the given properties (name, values, lifetime, is_true, agentCause)a new predicate with the given is_true (name, priority)a new predicate with the given is_true (name, lifetime)a new predicate with the given properties (name, values)a new predicate with the given properties (name, values, lifetime)a new predicate with the given is_true (name, is_true)a new predicate with the given properties (name, values, priority,lifetime)a new predicate with the given properties (name, values, priority, is_true, agentCause)a new predicate with the given properties (name, values, \tagentCause)a new predicate with the given properties (name, values, lifetime, agentCause)a new predicate with the given properties (name)a new predicate with the given properties (name, values, priority, agentCause)a new predicate with the given properties (name, values, priority, is_true)a new predicate with the given properties (name, values, priority, lifetime, agentCause)a new predicate with the given properties (name, values, is_true)Examples:predicate(\"people to meet\", [\"time\"::10], 10,true)predicate(\"people to meet\", people1, [\"time\"::10])predicate(\"people to meet\", [\"time\"::10],2.0,10, true, agentA)predicate(\"people to meet\", [\"time\"::10], true, agentA)predicate(\"people to meet\", [\"time\"::10], true)predicate(\"people to meet\", [\"time\"::10],2.0,10, true)predicate(\"people to meet\", [\"time\"::10], 10, true, agentA)predicate(\"hasWater\", 2.0 )predicate(\"hasWater\", 10 predicate(\"people to meet\", people1 )predicate(\"people to meet\", [\"time\"::10], true)predicate(\"hasWater\", true)predicate(\"people to meet\", [\"time\"::10], 2.0,10)predicate(\"people to meet\", [\"time\"::10], 2.0, true, agentA)predicate(\"people to meet\", [\"time\"::10], agentA)predicate(\"people to meet\", [\"time\"::10], 10, agentA)predicate(\"people to meet\")predicate(\"people to meet\", [\"time\"::10], 2.0,agentA)predicate(\"people to meet\", [\"time\"::10],2.0, true)predicate(\"people to meet\", [\"time\"::10], 2.0,10,agentA)predicate(\"people to meet\", [\"time\"::10], true)new_social_linkPossible use:  new_social_link (agent) —&gt;  msi.gaml.architecture.simplebdi.SocialLink  new_social_link (agent, float, float, float, float) —&gt;  msi.gaml.architecture.simplebdi.SocialLinkResult:a new social linka new social linkExamples:new_social_link(agentA)new_social_link(agentA,0.0,-0.1,0.2,0.1)nodePossible use:  node (unknown) —&gt;  unknown  unknown node float —&gt;  unknown  node (unknown , float) —&gt;  unknownnodesPossible use:  nodes (container) —&gt;  containernormPossible use:  norm (point) —&gt;  floatResult:the norm of the vector with the coordinates of the point operand.Examples:float var0 &lt;- norm({3,4}); \t// var0 equals 5.0notSame signification as !obj_filePossible use:  obj_file (string) —&gt;  fileResult:Constructs a file of type obj. Allowed extensions are limited to obj, OBJofSame signification as .of_generic_speciesPossible use:  container of_generic_species species —&gt;  container  of_generic_species (container , species) —&gt;  containerResult:a list, containing the agents of the left-hand operand whose species is that denoted by the right-hand operand and whose species extends the right-hand operand speciesExamples:// species test {}// species sous_test parent: test {}container var2 &lt;- [sous_test(0),sous_test(1),test(2),test(3)] of_generic_species test; \t// var2 equals [sous_test0,sous_test1,test2,test3]container var3 &lt;- [sous_test(0),sous_test(1),test(2),test(3)] of_generic_species sous_test; \t// var3 equals [sous_test0,sous_test1]container var4 &lt;- [sous_test(0),sous_test(1),test(2),test(3)] of_species test; \t// var4 equals [test2,test3]container var5 &lt;- [sous_test(0),sous_test(1),test(2),test(3)] of_species sous_test; \t// var5 equals [sous_test0,sous_test1]See also:of_species,of_speciesPossible use:  container of_species species —&gt;  container  of_species (container , species) —&gt;  containerResult:a list, containing the agents of the left-hand operand whose species is the one denoted by the right-hand operand.The expression agents of_species (species self) is equivalent to agents where (species each = species self); however, the advantage of using the first syntax is that the resulting list is correctly typed with the right species, whereas, in the second syntax, the parser cannot determine the species of the agents within the list (resulting in the need to cast it explicitly if it is to be used in an ask statement, for instance).Special cases:  if the right operand is nil, of_species returns the right operandExamples:container var0 &lt;- (self neighbors_at 10) of_species (species (self)); \t// var0 equals all the neighboring agents of the same species.container var1 &lt;- [test(0),test(1),node(1),node(2)] of_species test; \t// var1 equals [test0,test1]See also:of_generic_species,one_ofPossible use:  one_of (container&lt;KeyType,ValueType&gt;) —&gt;  ValueTypeResult:one of the values stored in this container  at a random keyComment:the one_of operator behavior depends on the nature of the operandSpecial cases:  if it is a graph, one_of returns one of the lists of edges  if it is a file, one_of returns one of the elements of the content of the file (that is also a container)  if the operand is empty, one_of returns nil  if it is a list or a matrix, one_of returns one of the values of the list or of the matrixint i &lt;- any ([1,2,3]); \t// i equals 1, 2 or 3string sMat &lt;- one_of(matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]])); \t// sMat equals \"c11\",\"c12\",\"c13\", \"c21\",\"c22\" or \"c23\"  if it is a map, one_of returns one the value of a random pair of the mapint im &lt;- one_of ([2::3, 4::5, 6::7]);\t// im equals 3, 5 or 7bool var6 &lt;- [2::3, 4::5, 6::7].values contains im; \t// var6 equals true  if it is a population, one_of returns one of the agents of the populationbug b &lt;- one_of(bug);  \t// Given a previously defined species bug, b is one of the created bugs, e.g. bug3See also:contains,orPossible use:  bool or any expression —&gt;  bool  or (bool , any expression) —&gt;  boolResult:a bool value, equal to the logical or between the left-hand operand and the right-hand operand.Comment:both operands are always casted to bool before applying the operator. Thus, an expression like 1 or 0 is accepted and returns true.See also:bool, and, !,orPossible use:  predicate or predicate —&gt;  predicate  or (predicate , predicate) —&gt;  predicateResult:create a new predicate from two others by including them as subintentions. It’s an exclusive “or”Examples:predicate1 or predicate2osm_filePossible use:  string osm_file map&lt;string,list&gt; —&gt;  file  osm_file (string , map&lt;string,list&gt;) —&gt;  file  osm_file (string, map&lt;string,list&gt;, int) —&gt;  fileResult:opens a file that a is a kind of OSM file with some filtering.opens a file that a is a kind of OSM file with some filtering, forcing the initial CRS to be the one indicated by the second int parameter (see http://spatialreference.org/ref/epsg/). If this int parameter is equal to 0, the data is considered as already projected.Comment:The file should have a OSM file extension, cf. file type definition for supported file extensions.The file should have a OSM file extension, cf. file type definition for supported file extensions.Special cases:  If the specified string does not refer to an existing OSM file, an exception is risen.  If the specified string does not refer to an existing OSM file, an exception is risen.Examples:file myOSMfile &lt;- osm_file(\"../includes/rouen.osm\", [\"highway\"::[\"primary\",\"motorway\"]]);file myOSMfile2 &lt;- osm_file(\"../includes/rouen.osm\",[\"highway\"::[\"primary\",\"motorway\"]], 0);See also:file,out_degree_ofPossible use:  graph out_degree_of unknown —&gt;  int  out_degree_of (graph , unknown) —&gt;  intResult:returns the out degree of a vertex (right-hand operand) in the graph given as left-hand operand.Examples:int var1 &lt;- graphFromMap out_degree_of (node(3)); \t// var1 equals 4See also:in_degree_of, degree_of,out_edges_ofPossible use:  graph out_edges_of unknown —&gt;  container  out_edges_of (graph , unknown) —&gt;  containerResult:returns the list of the out-edges of a vertex (right-hand operand) in the graph given as left-hand operand.Examples:container var1 &lt;- graphFromMap out_edges_of (node(3)); \t// var1 equals 3See also:in_edges_of,overlappingPossible use:  container&lt;agent&gt; overlapping geometry —&gt;  list&lt;geometry&gt;  overlapping (container&lt;agent&gt; , geometry) —&gt;  list&lt;geometry&gt;Result:A list of agents or geometries among the left-operand list, species or meta-population (addition of species), overlapping the operand (casted as a geometry).Examples:list&lt;geometry&gt; var0 &lt;- [ag1, ag2, ag3] overlapping(self); \t// var0 equals return the agents among ag1, ag2 and ag3 that overlap the shape of the agent applying the operator.(species1 + species2) overlapping selfSee also:neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, agents_overlapping,overlapsPossible use:  geometry overlaps geometry —&gt;  bool  overlaps (geometry , geometry) —&gt;  boolResult:A boolean, equal to true if the left-geometry (or agent/point) overlaps the right-geometry (or agent/point).Special cases:  if one of the operand is null, returns false.  if one operand is a point, returns true if the point is included in the geometryExamples:bool var0 &lt;- polyline([{10,10},{20,20}]) overlaps polyline([{15,15},{25,25}]); \t// var0 equals truebool var1 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var1 equals truebool var2 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps {25,25}; \t// var2 equals falsebool var3 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{35,35},{35,45},{45,45},{45,35}]); \t// var3 equals falsebool var4 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polyline([{10,10},{20,20}]); \t// var4 equals truebool var5 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps {15,15}; \t// var5 equals truebool var6 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{0,0},{0,30},{30,30}, {30,0}]); \t// var6 equals truebool var7 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var7 equals truebool var8 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{10,20},{20,20},{20,30},{10,30}]); \t// var8 equals trueSee also:disjoint_from, crosses, intersects, partially_overlaps, touches,pairPossible use:  pair (any) —&gt;  pairResult:Casts the operand into the type pairpartially_overlapsPossible use:  geometry partially_overlaps geometry —&gt;  bool  partially_overlaps (geometry , geometry) —&gt;  boolResult:A boolean, equal to true if the left-geometry (or agent/point) partially overlaps the right-geometry (or agent/point).Comment:if one geometry operand fully covers the other geometry operand, returns false (contrarily to the overlaps operator).Special cases:  if one of the operand is null, returns false.Examples:bool var0 &lt;- polyline([{10,10},{20,20}]) partially_overlaps polyline([{15,15},{25,25}]); \t// var0 equals truebool var1 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var1 equals truebool var2 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps {25,25}; \t// var2 equals falsebool var3 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{35,35},{35,45},{45,45},{45,35}]); \t// var3 equals falsebool var4 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polyline([{10,10},{20,20}]); \t// var4 equals falsebool var5 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps {15,15}; \t// var5 equals falsebool var6 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{0,0},{0,30},{30,30}, {30,0}]); \t// var6 equals falsebool var7 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var7 equals truebool var8 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{10,20},{20,20},{20,30},{10,30}]); \t// var8 equals falseSee also:disjoint_from, crosses, overlaps, intersects, touches,pathPossible use:  path (any) —&gt;  pathResult:Casts the operand into the type pathpath_betweenPossible use:  topology path_between container&lt;geometry&gt; —&gt;  path  path_between (topology , container&lt;geometry&gt;) —&gt;  path  list&lt;agent&gt; path_between container&lt;geometry&gt; —&gt;  path  path_between (list&lt;agent&gt; , container&lt;geometry&gt;) —&gt;  path  path_between (graph, geometry, geometry) —&gt;  path  path_between (list&lt;agent&gt;, geometry, geometry) —&gt;  path  path_between (topology, geometry, geometry) —&gt;  pathResult:The shortest path between a list of two objects in a graphThe shortest path between two objects according to set of cellsThe shortest path between several objects according to set of cellsExamples:path var0 &lt;- path_between (my_graph, ag1, ag2); \t// var0 equals A path between ag1 and ag2path var1 &lt;- my_topology path_between [ag1, ag2]; \t// var1 equals A path between ag1 and ag2path var2 &lt;- path_between (cell_grid where each.is_free, ag1, ag2); \t// var2 equals A path between ag1 and ag2 passing through the given cell_grid agentspath var3 &lt;- my_topology path_between (ag1, ag2); \t// var3 equals A path between ag1 and ag2path var4 &lt;- path_between (cell_grid where each.is_free, [ag1, ag2, ag3]); \t// var4 equals A path between ag1 and ag2 and ag3 passing through the given cell_grid agentsSee also:towards, direction_to, distance_between, direction_between, path_to, distance_to,path_toPossible use:  geometry path_to geometry —&gt;  path  path_to (geometry , geometry) —&gt;  path  point path_to point —&gt;  path  path_to (point , point) —&gt;  pathResult:A path between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.Examples:path var0 &lt;- ag1 path_to ag2; \t// var0 equals the path between ag1 and ag2 considering the topology of the agent applying the operatorSee also:towards, direction_to, distance_between, direction_between, path_between, distance_to,paths_betweenPossible use:  paths_between (graph, pair, int) —&gt;  list&lt;path&gt;Result:The K shortest paths between a list of two objects in a graphExamples:list&lt;path&gt; var0 &lt;- paths_between(my_graph, ag1:: ag2, 2); \t// var0 equals the 2 shortest paths (ordered by length) between ag1 and ag2percent_absolute_deviationPossible use:  list&lt;float&gt; percent_absolute_deviation list&lt;float&gt; —&gt;  float  percent_absolute_deviation (list&lt;float&gt; , list&lt;float&gt;) —&gt;  floatResult:percent absolute deviation indicator for 2 series of values: percent_absolute_deviation(list_vals_observe,list_vals_sim)Examples:percent_absolute_deviation([200,300,150,150,200],[250,250,100,200,200])pgm_filePossible use:  pgm_file (string) —&gt;  fileResult:Constructs a file of type pgm. Allowed extensions are limited to pgmplanPossible use:  container&lt;geometry&gt; plan float —&gt;  geometry  plan (container&lt;geometry&gt; , float) —&gt;  geometryResult:A polyline geometry from the given list of points.Special cases:  if the operand is nil, returns the point geometry {0,0}  if the operand is composed of a single point, returns a point geometry.Examples:geometry var0 &lt;- polyplan([{0,0}, {0,10}, {10,10}, {10,0}],10); \t// var0 equals a polyline geometry composed of the 4 points with a depth of 10.See also:around, circle, cone, link, norm, point, polygone, rectangle, square, triangle,plus_daysPossible use:  date plus_days int —&gt;  date  plus_days (date , int) —&gt;  dateResult:Add a given number of days to a dateExamples:date1 plus_days 20plus_hoursPossible use:  date plus_hours int —&gt;  date  plus_hours (date , int) —&gt;  dateResult:Add a given number of hours to a dateExamples:date1 plus_hours 15 // equivalent to date1 + 15 #hplus_minutesPossible use:  date plus_minutes int —&gt;  date  plus_minutes (date , int) —&gt;  dateResult:Add a given number of minutes to a dateExamples:date1 plus_minutes 5 // equivalent to date1 + 5 #mnplus_monthsPossible use:  date plus_months int —&gt;  date  plus_months (date , int) —&gt;  dateResult:Add a given number of months to a dateExamples:date1 plus_months 5plus_msPossible use:  date plus_ms int —&gt;  date  plus_ms (date , int) —&gt;  dateResult:Add a given number of milliseconds to a dateExamples:date1 plus_ms 15 // equivalent to date1 + 15 #msplus_secondsSame signification as +plus_weeksPossible use:  date plus_weeks int —&gt;  date  plus_weeks (date , int) —&gt;  dateResult:Add a given number of weeks to a dateExamples:date1 plus_weeks 15plus_yearsPossible use:  date plus_years int —&gt;  date  plus_years (date , int) —&gt;  dateResult:Add a given number of years to a dateExamples:date1 plus_years 3pointPossible use:  float point int —&gt;  point  point (float , int) —&gt;  point  int point float —&gt;  point  point (int , float) —&gt;  point  int point int —&gt;  point  point (int , int) —&gt;  point  float point float —&gt;  point  point (float , float) —&gt;  point  point (float, int, int) —&gt;  point  point (int, int, int) —&gt;  point  point (float, int, float) —&gt;  point  point (int, int, float) —&gt;  point  point (int, float, float) —&gt;  point  point (float, float, float) —&gt;  point  point (float, float, int) —&gt;  pointResult:internal use only. Use the standard construction {x,y} instead.internal use only. Use the standard construction {x,y} instead.internal use only. Use the standard construction {x,y, z} instead.internal use only. Use the standard construction {x,y, z} instead.internal use only. Use the standard construction {x,y, z} instead.internal use only. Use the standard construction {x,y, z} instead.internal use only. Use the standard construction {x,y, z} instead.internal use only. Use the standard construction {x,y} instead.internal use only. Use the standard construction {x,y} instead.internal use only. Use the standard construction {x,y, z} instead.internal use only. Use the standard construction {x,y, z} instead.points_alongPossible use:  geometry points_along list&lt;float&gt; —&gt;  container  points_along (geometry , list&lt;float&gt;) —&gt;  containerResult:A list of points along the operand-geometry given its location in terms of rate of distance from the starting points of the geometry.Examples:container var0 &lt;-  line([{10,10},{80,80}]) points_along ([0.3, 0.5, 0.9]); \t// var0 equals the list of following points: [{31.0,31.0,0.0},{45.0,45.0,0.0},{73.0,73.0,0.0}]See also:closest_points_with, farthest_point_to, points_at, points_on,points_atPossible use:  int points_at float —&gt;  list&lt;point&gt;  points_at (int , float) —&gt;  list&lt;point&gt;Result:A list of left-operand number of points located at a the right-operand distance to the agent location.Examples:list&lt;point&gt; var0 &lt;- 3 points_at(20.0); \t// var0 equals returns [pt1, pt2, pt3] with pt1, pt2 and pt3 located at a distance of 20.0 to the agent locationSee also:any_location_in, any_point_in, closest_points_with, farthest_point_to,points_onPossible use:  geometry points_on float —&gt;  container  points_on (geometry , float) —&gt;  containerResult:A list of points of the operand-geometry distant from each other to the float right-operand .Examples:container var0 &lt;-  square(5) points_on(2); \t// var0 equals a list of points belonging to the exterior ring of the square distant from each other of 2.See also:closest_points_with, farthest_point_to, points_at,poissonPossible use:  poisson (float) —&gt;  intResult:A value from a random variable following a Poisson distribution (with the positive expected number of occurence lambda as operand).Comment:The Poisson distribution is a discrete probability distribution that expresses the probability of a given number of events occurring in a fixed interval of time and/or space if these events occur with a known average rate and independently of the time since the last event, cf. Poisson distribution on Wikipedia.Examples:int var0 &lt;- poisson(3.5); \t// var0 equals a random positive integerSee also:binomial, gauss,polygonPossible use:  polygon (container&lt;agent&gt;) —&gt;  geometryResult:A polygon geometry from the given list of points.Special cases:  if the operand is nil, returns the point geometry {0,0}  if the operand is composed of a single point, returns a point geometry  if the operand is composed of 2 points, returns a polyline geometry.Examples:geometry var0 &lt;- polygon([{0,0}, {0,10}, {10,10}, {10,0}]); \t// var0 equals a polygon geometry composed of the 4 points.See also:around, circle, cone, line, link, norm, point, polyline, rectangle, square, triangle,polyhedronPossible use:  container&lt;geometry&gt; polyhedron float —&gt;  geometry  polyhedron (container&lt;geometry&gt; , float) —&gt;  geometryResult:A polyhedron geometry from the given list of points.Special cases:  if the operand is nil, returns the point geometry {0,0}  if the operand is composed of a single point, returns a point geometry  if the operand is composed of 2 points, returns a polyline geometry.Examples:geometry var0 &lt;- polyhedron([{0,0}, {0,10}, {10,10}, {10,0}],10); \t// var0 equals a polygon geometry composed of the 4 points and of depth 10.See also:around, circle, cone, line, link, norm, point, polyline, rectangle, square, triangle,polylineSame signification as linepolyplanSame signification as planpredecessors_ofPossible use:  graph predecessors_of unknown —&gt;  container  predecessors_of (graph , unknown) —&gt;  containerResult:returns the list of predecessors (i.e. sources of in edges) of the given vertex (right-hand operand) in the given graph (left-hand operand)Examples:container var1 &lt;- graphEpidemio predecessors_of ({1,5}); \t// var1 equals []container var2 &lt;- graphEpidemio predecessors_of node({34,56}); \t// var2 equals [{12;45}]See also:neighbors_of, successors_of,predicatePossible use:  predicate (any) —&gt;  predicateResult:Casts the operand into the type predicatepredictPossible use:  regression predict list&lt;float&gt; —&gt;  float  predict (regression , list&lt;float&gt;) —&gt;  floatResult:returns the value predict by the regression parameters for a given instance. Usage: predict(regression, instance)Examples:predict(my_regression, [1,2,3]productSame signification as mulproduct_ofPossible use:  container product_of any expression —&gt;  unknown  product_of (container , any expression) —&gt;  unknownResult:the product of the right-hand expression evaluated on each of the elements of the left-hand operandComment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  if the left-operand is a map, the keyword each will contain each valueunknown var2 &lt;- [1::2, 3::4, 5::6] product_of (each); \t// var2 equals 48Examples:unknown var1 &lt;- [1,2] product_of (each * 10 ); \t// var1 equals 200See also:min_of, max_of, sum_of, mean_of,promethee_DMPossible use:  list&lt;list&gt; promethee_DM list&lt;map&lt;string,object&gt;&gt; —&gt;  int  promethee_DM (list&lt;list&gt; , list&lt;map&lt;string,object&gt;&gt;) —&gt;  intResult:The index of the best candidate according to the Promethee II method. This method is based on a comparison per pair of possible candidates along each criterion: all candidates are compared to each other by pair and ranked. More information about this method can be found in [http://www.sciencedirect.com/science?_ob=ArticleURL&amp;_udi=B6VCT-4VF56TV-1&amp;_user=10&amp;_coverDate=01%2F01%2F2010&amp;_rdoc=1&amp;_fmt=high&amp;_orig=search&amp;_sort=d&amp;_docanchor=&amp;view=c&amp;_searchStrId=1389284642&amp;_rerunOrigin=google&amp;_acct=C000050221&amp;_version=1&amp;_urlVersion=0&amp;_userid=10&amp;md5=d334de2a4e0d6281199a39857648cd36 Behzadian, M., Kazemzadeh, R., Albadvi, A., M., A.: PROMETHEE: A comprehensive literature review on methodologies and applications. European Journal of Operational Research(2009)]. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains fours elements: a name, a weight, a preference value (p) and an indifference value (q). The preference value represents the threshold from which the difference between two criterion values allows to prefer one vector of values over another. The indifference value represents the threshold from which the difference between two criterion values is considered significant.Special cases:  returns -1 is the list of candidates is nil or emptyExamples:int var0 &lt;- promethee_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"weight\" :: 2.0,\"p\"::0.5, \"q\"::0.0, \"s\"::1.0, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: 1.0,\"p\"::0.5, \"q\"::0.0, \"s\"::1.0, \"maximize\" :: false]]); \t// var0 equals 1See also:weighted_means_DM, electre_DM, evidence_theory_DM,property_filePossible use:  property_file (string) —&gt;  fileResult:Constructs a file of type property. Allowed extensions are limited to propertiespyramidPossible use:  pyramid (float) —&gt;  geometryResult:A square geometry which side size is given by the operand.Comment:the center of the pyramid is by default the location of the current agent in which has been called this operator.Special cases:  returns nil if the operand is nil.Examples:geometry var0 &lt;- pyramid(5); \t// var0 equals a geometry as a square with side_size = 5.See also:around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, square,R_correlationSame signification as corRR_filePossible use:  R_file (string) —&gt;  fileResult:Constructs a file of type R. Allowed extensions are limited to rR_meanSame signification as meanRrangePossible use:  range (int) —&gt;  container  int range int —&gt;  container  range (int , int) —&gt;  container  range (int, int, int) —&gt;  containerResult:Allows to build a list of int representing all contiguous values from zero to the argument. The range can be increasing or decreasing. Passing 0 will return a singleton list with 0Allows to build a list of int representing all contiguous values from the first to the second argument, using the step represented by the third argument. The range can be increasing or decreasing. Passing the same value for both will return a singleton list with this value. Passing a step of 0 will result in an exception. Attempting to build infinite ranges (e.g. end &gt; start with a negative step) will similarly not be accepted and yield an exceptionAllows to build a list of int representing all contiguous values from the first to the second argument. The range can be increasing or decreasing. Passing the same value for both will return a singleton list with this valuereadPossible use:  read (string) —&gt;  unknownResult:Reads an attribute of the agent. The attribute’s name is specified by the operand.Examples:unknown agent_name &lt;- read ('name'); \t// agent_name equals reads the 'name' variable of agent then assigns the returned value to the 'agent_name' variable. rectanglePossible use:  rectangle (point) —&gt;  geometry  float rectangle float —&gt;  geometry  rectangle (float , float) —&gt;  geometry  point rectangle point —&gt;  geometry  rectangle (point , point) —&gt;  geometryResult:A rectangle geometry which side sizes are given by the operands.Comment:the center of the rectangle is by default the location of the current agent in which has been called this operator.the center of the rectangle is by default the location of the current agent in which has been called this operator.Special cases:  returns nil if the operand is nil.  returns nil if the operand is nil.  returns nil if the operand is nil.Examples:geometry var0 &lt;- rectangle(10, 5); \t// var0 equals a geometry as a rectangle with width = 10 and height = 5.geometry var1 &lt;- rectangle({2.0,6.0}, {6.0,20.0}); \t// var1 equals a geometry as a rectangle with {2.0,6.0} as the upper-left corner, {6.0,20.0} as the lower-right corner.geometry var2 &lt;- rectangle({10, 5}); \t// var2 equals a geometry as a rectangle with width = 10 and height = 5.See also:around, circle, cone, line, link, norm, point, polygon, polyline, square, triangle,reduced_bySame signification as -regressionPossible use:  regression (any) —&gt;  regressionResult:Casts the operand into the type regressionremove_duplicatesSame signification as distinctremove_node_fromPossible use:  geometry remove_node_from graph —&gt;  graph  remove_node_from (geometry , graph) —&gt;  graphResult:removes a node from a graph.Comment:all the edges containing this node are also removed.Examples:graph var0 &lt;- node(0) remove_node_from graphEpidemio; \t// var0 equals the graph without node(0)replacePossible use:  replace (string, string, string) —&gt;  stringResult:Returns the String resulting by replacing for the first operand all the sub-strings corresponding the second operand by the third operandExamples:string var0 &lt;- replace('to be or not to be,that is the question','to', 'do'); \t// var0 equals 'do be or not do be,that is the question'See also:replace_regex,replace_regexPossible use:  replace_regex (string, string, string) —&gt;  stringResult:Returns the String resulting by replacing for the first operand all the sub-strings corresponding to the regular expression given in the second operand by the third operandExamples:string var0 &lt;- replace_regex(\"colour, color\", \"colou?r\", \"col\"); \t// var0 equals 'col, col'See also:replace,reversePossible use:  reverse (string) —&gt;  string  reverse (container&lt;KeyType,ValueType&gt;) —&gt;  msi.gama.util.IContainer&lt;?,?&gt;Result:the operand elements in the reversed order in a copy of the operand.Comment:the reverse operator behavior depends on the nature of the operandSpecial cases:  if it is a file, reverse returns a copy of the file with a reversed content  if it is a population, reverse returns a copy of the population with elements in the reversed order  if it is a graph, reverse returns a copy of the graph (with all edges and vertexes), with all of the edges reversed  if it is a string, reverse returns a new string with characters in the reversed orderstring var0 &lt;- reverse ('abcd'); \t// var0 equals 'dcba'  if it is a list, reverse returns a copy of the operand list with elements in the reversed ordermsi.gama.util.IContainer&lt;?,?&gt; var1 &lt;- reverse ([10,12,14]); \t// var1 equals [14, 12, 10]  if it is a map, reverse returns a copy of the operand map with each pair in the reversed order (i.e. all keys become values and values become keys)msi.gama.util.IContainer&lt;?,?&gt; var2 &lt;- reverse (['k1'::44, 'k2'::32, 'k3'::12]); \t// var2 equals [12::'k3',  32::'k2', 44::'k1']  if it is a matrix, reverse returns a new matrix containing the transpose of the operand.msi.gama.util.IContainer&lt;?,?&gt; var3 &lt;- reverse(matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]])); \t// var3 equals matrix([[\"c11\",\"c21\"],[\"c12\",\"c22\"],[\"c13\",\"c23\"]])rewire_nPossible use:  graph rewire_n int —&gt;  graph  rewire_n (graph , int) —&gt;  graphResult:rewires the given count of edges.Comment:If there are too many edges, all the edges will be rewired.Examples:graph var1 &lt;- graphEpidemio rewire_n 10; \t// var1 equals the graph with 3 edges rewiredrgbPossible use:  rgb rgb float —&gt;  rgb  rgb (rgb , float) —&gt;  rgb  rgb rgb int —&gt;  rgb  rgb (rgb , int) —&gt;  rgb  string rgb int —&gt;  rgb  rgb (string , int) —&gt;  rgb  rgb (int, int, int) —&gt;  rgb  rgb (int, int, int, float) —&gt;  rgb  rgb (int, int, int, int) —&gt;  rgbResult:Returns a color defined by red, green, blue components and an alpha blending value.Special cases:  It can be used with r=red, g=green, b=blue (each between 0 and 255), a=alpha (between 0.0 and 1.0)  It can be used with a color and an alpha between 0 and 1  It can be used with a color and an alpha between 0 and 255  It can be used with r=red, g=green, b=blue, each between 0 and 255  It can be used with a name of color and alpha (between 0 and 255)  It can be used with r=red, g=green, b=blue (each between 0 and 255), a=alpha (between 0 and 255)Examples:rgb var0 &lt;- rgb (255,0,0,0.5); \t// var0 equals a light red colorrgb var1 &lt;- rgb(rgb(255,0,0),0.5); \t// var1 equals a light red colorrgb var2 &lt;- rgb(rgb(255,0,0),125); \t// var2 equals a light red colorrgb var3 &lt;- rgb (255,0,0); \t// var3 equals #redrgb var4 &lt;- rgb (\"red\"); \t// var4 equals rgb(255,0,0)rgb var5 &lt;- rgb (255,0,0,125); \t// var5 equals a light red colorSee also:hsb,rgb_to_xyzPossible use:  rgb_to_xyz (file) —&gt;  list&lt;point&gt;Result:A list of point corresponding to RGB value of an image (r:x , g:y, b:z)Examples:list&lt;point&gt; var0 &lt;- rgb_to_xyz(texture); \t// var0 equals a list of pointsrndPossible use:  rnd (float) —&gt;  float  rnd (int) —&gt;  int  rnd (point) —&gt;  point  point rnd point —&gt;  point  rnd (point , point) —&gt;  point  int rnd int —&gt;  int  rnd (int , int) —&gt;  int  float rnd float —&gt;  float  rnd (float , float) —&gt;  float  rnd (point, point, float) —&gt;  point  rnd (float, float, float) —&gt;  float  rnd (int, int, int) —&gt;  intResult:a random integer in the interval [0, operand]Comment:to obtain a probability between 0 and 1, use the expression (rnd n) / n, where n is used to indicate the precisionSpecial cases:  if the operand is a float, returns an uniformly distributed float random number in [0.0, to]  if the operand is a point, returns a point with three random float ordinates, each in the interval [0, ordinate of argument]Examples:float var0 &lt;- rnd(3.4); \t// var0 equals a random float between 0.0 and 3.4point var1 &lt;- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}, 1); \t// var1 equals a point with x = 2.0, y equal to 2.0, 3.0 or 4.0 and z between 0.0 and 10.0 every 1.0point var2 &lt;- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}); \t// var2 equals a point with x = 2.0, y between 2.0 and 4.0 and z between 0.0 and 10.0int var3 &lt;- rnd (2, 4); \t// var3 equals 2, 3 or 4float var4 &lt;- rnd (2.0, 4.0); \t// var4 equals a float number between 2.0 and 4.0float var5 &lt;- rnd (2.0, 4.0, 0.5); \t// var5 equals a float number between 2.0 and 4.0 every 0.5int var6 &lt;- rnd (2); \t// var6 equals 0, 1 or 2float var7 &lt;- rnd (1000) / 1000; \t// var7 equals a float between 0 and 1 with a precision of 0.001point var8 &lt;- rnd ({2.5,3, 0.0}); \t// var8 equals {x,y} with x in [0.0,2.0], y in [0.0,3.0], z = 0.0int var9 &lt;- rnd (2, 12, 4); \t// var9 equals 2, 6 or 10See also:flip,rnd_choicePossible use:  rnd_choice (container) —&gt;  intResult:returns an index of the given list with a probability following the (normalized) distribution described in the list (a form of lottery)Examples:int var0 &lt;- rnd_choice([0.2,0.5,0.3]); \t// var0 equals 2/10 chances to return 0, 5/10 chances to return 1, 3/10 chances to return 2See also:rnd,rnd_colorPossible use:  rnd_color (int) —&gt;  rgbResult:rgb colorComment:Return a random color equivalent to rgb(rnd(operand),rnd(operand),rnd(operand))Examples:rgb var0 &lt;- rnd_color(255); \t// var0 equals a random color, equivalent to rgb(rnd(255),rnd(255),rnd(255))See also:rgb, hsb,rotated_byPossible use:  geometry rotated_by float —&gt;  geometry  rotated_by (geometry , float) —&gt;  geometry  geometry rotated_by int —&gt;  geometry  rotated_by (geometry , int) —&gt;  geometry  rotated_by (geometry, float, point) —&gt;  geometryResult:A geometry resulting from the application of a rotation by the right-hand operand angle (degree) to the left-hand operand (geometry, agent, point)A geometry resulting from the application of a rotation by the right-hand operand angles (degree) along the three axis (x,y,z) to the left-hand operand (geometry, agent, point)Comment:the right-hand operand can be a float or a intExamples:geometry var0 &lt;- self rotated_by 45; \t// var0 equals the geometry resulting from a 45 degrees rotation to the geometry of the agent applying the operator.geometry var1 &lt;- rotated_by(pyramid(10),45, {1,0,0}); \t// var1 equals the geometry resulting from a 45 degrees rotation along the {1,0,0} vector to the geometry of the agent applying the operator.See also:transformed_by, translated_by,roundPossible use:  round (int) —&gt;  int  round (point) —&gt;  point  round (float) —&gt;  intResult:Returns the rounded value of the operand.Special cases:  if the operand is an int, round returns itExamples:point var0 &lt;- {12345.78943,  12345.78943, 12345.78943} with_precision 2; \t// var0 equals {12345.79,12345.79,12345.79}int var1 &lt;- round (0.51); \t// var1 equals 1int var2 &lt;- round (100.2); \t// var2 equals 100int var3 &lt;- round(-0.51); \t// var3 equals -1See also:round, int, with_precision,row_atPossible use:  matrix row_at int —&gt;  list  row_at (matrix , int) —&gt;  listResult:returns the row at a num_line (right-hand operand)Examples:list var0 &lt;- matrix([[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]]) row_at 2; \t// var0 equals [\"el13\",\"el23\",\"el33\"]See also:column_at, columns_list,rows_listPossible use:  rows_list (matrix) —&gt;  list&lt;list&gt;Result:returns a list of the rows of the matrix, with each row as a list of elementsExamples:list&lt;list&gt; var0 &lt;- rows_list(matrix([[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]])); \t// var0 equals [[\"el11\",\"el21\",\"el31\"],[\"el12\",\"el22\",\"el32\"],[\"el13\",\"el23\",\"el33\"]]See also:columns_list,samplePossible use:  sample (any expression) —&gt;  string  string sample any expression —&gt;  string  sample (string , any expression) —&gt;  string  sample (container, int, bool) —&gt;  container  sample (container, int, bool, container) —&gt;  containerResult:takes a sample of the specified size from the elements of x using either with or without replacementtakes a sample of the specified size from the elements of x using either with or without replacement with given weightsExamples:container var0 &lt;- sample([2,10,1],2,false); \t// var0 equals [1,2]container var1 &lt;- sample([2,10,1],2,false,[0.1,0.7,0.2]); \t// var1 equals [10,2]scaled_bySame signification as [](#)scaled_toPossible use:  geometry scaled_to point —&gt;  geometry  scaled_to (geometry , point) —&gt;  geometryResult:allows to restrict the size of a geometry so that it fits in the envelope {width, height, depth} defined by the second operandExamples:geometry var0 &lt;- shape scaled_to {10,10}; \t// var0 equals a geometry corresponding to the geometry of the agent applying the operator scaled so that it fits a square of 10x10selectSame signification as whereset_aboutPossible use:  emotion set_about predicate —&gt;  emotion  set_about (emotion , predicate) —&gt;  emotionResult:change the about value of the given emotionExamples:emotion set_about predicate1set_agentPossible use:  msi.gaml.architecture.simplebdi.SocialLink set_agent agent —&gt;  msi.gaml.architecture.simplebdi.SocialLink  set_agent (msi.gaml.architecture.simplebdi.SocialLink , agent) —&gt;  msi.gaml.architecture.simplebdi.SocialLinkResult:change the agent value of the given social linkExamples:social_link set_agent agentAset_agent_causePossible use:  emotion set_agent_cause agent —&gt;  emotion  set_agent_cause (emotion , agent) —&gt;  emotion  predicate set_agent_cause agent —&gt;  predicate  set_agent_cause (predicate , agent) —&gt;  predicateResult:change the agentCause value of the given emotionchange the agentCause value of the given predicateExamples:emotion set_agent_cause agentApredicate set_agent_cause agentAset_decayPossible use:  emotion set_decay float —&gt;  emotion  set_decay (emotion , float) —&gt;  emotionResult:change the decay value of the given emotionExamples:emotion set_decay 12set_dominancePossible use:  msi.gaml.architecture.simplebdi.SocialLink set_dominance float —&gt;  msi.gaml.architecture.simplebdi.SocialLink  set_dominance (msi.gaml.architecture.simplebdi.SocialLink , float) —&gt;  msi.gaml.architecture.simplebdi.SocialLinkResult:change the dominance value of the given social linkExamples:social_link set_dominance 0.4set_familiarityPossible use:  msi.gaml.architecture.simplebdi.SocialLink set_familiarity float —&gt;  msi.gaml.architecture.simplebdi.SocialLink  set_familiarity (msi.gaml.architecture.simplebdi.SocialLink , float) —&gt;  msi.gaml.architecture.simplebdi.SocialLinkResult:change the familiarity value of the given social linkExamples:social_link set_familiarity 0.4set_intensityPossible use:  emotion set_intensity float —&gt;  emotion  set_intensity (emotion , float) —&gt;  emotionResult:change the intensity value of the given emotionExamples:emotion set_intensity 12set_likingPossible use:  msi.gaml.architecture.simplebdi.SocialLink set_liking float —&gt;  msi.gaml.architecture.simplebdi.SocialLink  set_liking (msi.gaml.architecture.simplebdi.SocialLink , float) —&gt;  msi.gaml.architecture.simplebdi.SocialLinkResult:change the liking value of the given social linkExamples:social_link set_liking 0.4set_solidarityPossible use:  msi.gaml.architecture.simplebdi.SocialLink set_solidarity float —&gt;  msi.gaml.architecture.simplebdi.SocialLink  set_solidarity (msi.gaml.architecture.simplebdi.SocialLink , float) —&gt;  msi.gaml.architecture.simplebdi.SocialLinkResult:change the solidarity value of the given social linkExamples:social_link set_solidarity 0.4set_truthPossible use:  predicate set_truth bool —&gt;  predicate  set_truth (predicate , bool) —&gt;  predicateResult:change the is_true value of the given predicateExamples:predicate set_truth falseset_zPossible use:  geometry set_z container&lt;float&gt; —&gt;  geometry  set_z (geometry , container&lt;float&gt;) —&gt;  geometry  set_z (geometry, int, float) —&gt;  geometryResult:Sets the z ordinate of the n-th point of a geometry to the value provided by the third argumentExamples:loop i from: 0 to: length(shape.points) - 1{set shape &lt;-  set_z (shape, i, 3.0);}shape &lt;- triangle(3) set_z [5,10,14];shape_filePossible use:  shape_file (string) —&gt;  fileResult:Constructs a file of type shape. Allowed extensions are limited to shpshufflePossible use:  shuffle (matrix) —&gt;  matrix  shuffle (string) —&gt;  string  shuffle (container) —&gt;  containerResult:The elements of the operand in random order.Special cases:  if the operand is empty, returns an empty list (or string, matrix)Examples:matrix var0 &lt;- shuffle (matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]])); \t// var0 equals matrix([[\"c12\",\"c21\",\"c11\"],[\"c13\",\"c22\",\"c23\"]]) (for example)string var1 &lt;- shuffle ('abc'); \t// var1 equals 'bac' (for example)container var2 &lt;- shuffle ([12, 13, 14]); \t// var2 equals [14,12,13] (for example)See also:reverse,signumPossible use:  signum (float) —&gt;  intResult:Returns -1 if the argument is negative, +1 if it is positive, 0 if it is equal to zero or not a numberExamples:int var0 &lt;- signum(-12); \t// var0 equals -1int var1 &lt;- signum(14); \t// var1 equals 1int var2 &lt;- signum(0); \t// var2 equals 0simple_clustering_by_distancePossible use:  container&lt;agent&gt; simple_clustering_by_distance float —&gt;  list&lt;list&lt;agent&gt;&gt;  simple_clustering_by_distance (container&lt;agent&gt; , float) —&gt;  list&lt;list&lt;agent&gt;&gt;Result:A list of agent groups clustered by distance considering a distance min between two groups.Examples:list&lt;list&lt;agent&gt;&gt; var0 &lt;- [ag1, ag2, ag3, ag4, ag5] simpleClusteringByDistance 20.0; \t// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]See also:hierarchical_clustering,simple_clustering_by_envelope_distanceSame signification as simple_clustering_by_distancesimplificationPossible use:  geometry simplification float —&gt;  geometry  simplification (geometry , float) —&gt;  geometryResult:A geometry corresponding to the simplification of the operand (geometry, agent, point) considering a tolerance distance.Comment:The algorithm used for the simplification is Douglas-PeuckerExamples:geometry var0 &lt;- self simplification 0.1; \t// var0 equals the geometry resulting from the application of the Douglas-Peuker algorithm on the geometry of the agent applying the operator with a tolerance distance of 0.1.sinPossible use:  sin (float) —&gt;  float  sin (int) —&gt;  floatResult:Returns the value (in [-1,1]) of the sinus of the operand (in decimal degrees). The argument is casted to an int before being evaluated.Special cases:  Operand values out of the range [0-359] are normalized.Examples:float var0 &lt;- sin(360); \t// var0 equals 0.0float var1 &lt;- sin (0); \t// var1 equals 0.0See also:cos, tan,sin_radPossible use:  sin_rad (float) —&gt;  floatResult:Returns the value (in [-1,1]) of the sinus of the operand (in decimal degrees). The argument is casted to an int before being evaluated.Special cases:  Operand values out of the range [0-359] are normalized.Examples:float var0 &lt;- sin(360); \t// var0 equals 0.0See also:cos, tan,sincePossible use:  since (date) —&gt;  bool  any expression since date —&gt;  bool  since (any expression , date) —&gt;  boolResult:Returns true if the current_date of the model is after (or equal to) the date passed in argument. Synonym of ‘current_date &gt;= argument’. Can be used, like ‘after’, in its composed form with 2 arguments to express the lowest boundary of the computation of a frequency. However, contrary to ‘after’, there is a subtle difference: the lowest boundary will be tested against the frequency as wellExamples:reflex when: since(starting_date) {} -: will always be runevery(2#days) since (starting_date + 1#day) // the computation will return true 1 day after the starting date and every two days after this reference dateskeletonizePossible use:  skeletonize (geometry) —&gt;  list&lt;geometry&gt;Result:A list of geometries (polylines) corresponding to the skeleton of the operand geometry (geometry, agent)Examples:list&lt;geometry&gt; var0 &lt;- skeletonize(self); \t// var0 equals the list of geometries corresponding to the skeleton of the geometry of the agent applying the operator.skew_gaussPossible use:  skew_gauss (float, float, float, float) —&gt;  floatResult:A value from a skew normally distributed random variable with min value (the minimum skewed value possible), max value (the maximum skewed value possible), skew (the degree to which the values cluster around the mode of the distribution; higher values mean tighter clustering) and bias (the tendency of the mode to approach the min, max or midpoint value; positive values bias toward max, negative values toward min).The algorithm was taken from http://stackoverflow.com/questions/5853187/skewing-java-random-number-generation-toward-a-certain-numberExamples:float var0 &lt;- skew_gauss(0.0, 1.0, 0.7,0.1); \t// var0 equals 0.1729218460343077See also:gauss, truncated_gauss, poisson,skewnessPossible use:  skewness (list) —&gt;  floatResult:returns skewness value computed from the operand list of valuesSpecial cases:  if the length of the list is lower than 3, returns NaNExamples:skewness ([1,2,3,4,5])skillPossible use:  skill (any) —&gt;  skillResult:Casts the operand into the type skillsmoothPossible use:  geometry smooth float —&gt;  geometry  smooth (geometry , float) —&gt;  geometryResult:Returns a ‘smoothed’ geometry, where straight lines are replaces by polynomial (bicubic) curves. The first parameter is the original geometry, the second is the ‘fit’ parameter which can be in the range 0 (loose fit) to 1 (tightest fit).Examples:geometry var0 &lt;- smooth(square(10), 0.0); \t// var0 equals a 'rounded' squaresocial_linkPossible use:  social_link (any) —&gt;  social_linkResult:Casts the operand into the type social_linksolidSame signification as without_holessortSame signification as sort_bysort_byPossible use:  container sort_by any expression —&gt;  container  sort_by (container , any expression) —&gt;  containerResult:Returns a list, containing the elements of the left-hand operand sorted in ascending order by the value of the right-hand operand when it is evaluated on them.Comment:the left-hand operand is casted to a list before applying the operator. In the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.Special cases:  if the left-hand operand is nil, sort_by throws an errorExamples:container var0 &lt;- [1,2,4,3,5,7,6,8] sort_by (each); \t// var0 equals [1,2,3,4,5,6,7,8]container var2 &lt;- g2 sort_by (length(g2 out_edges_of each) ); \t// var2 equals [node9, node7, node10, node8, node11, node6, node5, node4]container var3 &lt;- (list(node) sort_by (round(node(each).location.x)); \t// var3 equals [node5, node1, node0, node2, node3]container var4 &lt;- [1::2, 5::6, 3::4] sort_by (each); \t// var4 equals [2, 4, 6]See also:group_by,source_ofPossible use:  graph source_of unknown —&gt;  unknown  source_of (graph , unknown) —&gt;  unknownResult:returns the source of the edge (right-hand operand) contained in the graph given in left-hand operand.Special cases:  if the lef-hand operand (the graph) is nil, throws an ExceptionExamples:graph graphEpidemio &lt;- generate_barabasi_albert( [\"edges_species\"::edge,\"vertices_specy\"::node,\"size\"::3,\"m\"::5] );unknown var1 &lt;- graphEpidemio source_of(edge(3)); \t// var1 equals node1graph graphFromMap &lt;-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);point var3 &lt;- graphFromMap source_of(link({1,5}::{12,45})); \t// var3 equals {1,5}See also:target_of,spatial_graphPossible use:  spatial_graph (container) —&gt;  graphResult:allows to create a spatial graph from a container of vertices, without trying to wire them. The container can be empty. Emits an error if the contents of the container are not geometries, points or agentsSee also:graph,speciesPossible use:  species (unknown) —&gt;  speciesResult:casting of the operand to a species.Special cases:  if the operand is nil, returns nil;  if the operand is an agent, returns its species;  if the operand is a string, returns the species with this name (nil if not found);  otherwise, returns nilExamples:species var0 &lt;- species(self); \t// var0 equals the species of the current agentspecies var1 &lt;- species('node'); \t// var1 equals nodespecies var2 &lt;- species([1,5,9,3]); \t// var2 equals nilspecies var3 &lt;- species(node1); \t// var3 equals nodespecies_ofSame signification as speciesspherePossible use:  sphere (float) —&gt;  geometryResult:A sphere geometry which radius is equal to the operand.Comment:the centre of the sphere is by default the location of the current agent in which has been called this operator.Special cases:  returns a point if the operand is lower or equal to 0.Examples:geometry var0 &lt;- sphere(10); \t// var0 equals a geometry as a circle of radius 10 but displays a sphere.See also:around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,split_atPossible use:  geometry split_at point —&gt;  list&lt;geometry&gt;  split_at (geometry , point) —&gt;  list&lt;geometry&gt;Result:The two part of the left-operand lines split at the given right-operand pointSpecial cases:  if the left-operand is a point or a polygon, returns an empty listExamples:list&lt;geometry&gt; var0 &lt;- polyline([{1,2},{4,6}]) split_at {7,6}; \t// var0 equals [polyline([{1.0,2.0},{7.0,6.0}]), polyline([{7.0,6.0},{4.0,6.0}])]split_geometryPossible use:  geometry split_geometry float —&gt;  list&lt;geometry&gt;  split_geometry (geometry , float) —&gt;  list&lt;geometry&gt;  geometry split_geometry point —&gt;  list&lt;geometry&gt;  split_geometry (geometry , point) —&gt;  list&lt;geometry&gt;  split_geometry (geometry, int, int) —&gt;  list&lt;geometry&gt;Result:A list of geometries that result from the decomposition of the geometry by square cells of the given side size (geometry, size)A list of geometries that result from the decomposition of the geometry by rectangle cells of the given dimension (geometry, {size_x, size_y})A list of geometries that result from the decomposition of the geometry according to a grid with the given number of rows and columns (geometry, nb_cols, nb_rows)Examples:list&lt;geometry&gt; var0 &lt;- to_squares(self, 10.0); \t// var0 equals the list of the geometries corresponding to the decomposition of the geometry by squares of side size 10.0list&lt;geometry&gt; var1 &lt;- to_rectangles(self, {10.0, 15.0}); \t// var1 equals the list of the geometries corresponding to the decomposition of the geometry by rectangles of size 10.0, 15.0list&lt;geometry&gt; var2 &lt;- to_rectangles(self, 10,20); \t// var2 equals the list of the geometries corresponding to the decomposition of the geometry of the agent applying the operatorsplit_linesPossible use:  split_lines (container&lt;geometry&gt;) —&gt;  list&lt;geometry&gt;Result:A list of geometries resulting after cutting the lines at their intersections.Examples:list&lt;geometry&gt; var0 &lt;- split_lines([line([{0,10}, {20,10}]), line([{0,10}, {20,10}])]); \t// var0 equals a list of four polylines: line([{0,10}, {10,10}]), line([{10,10}, {20,10}]), line([{10,0}, {10,10}]) and line([{10,10}, {10,20}])split_withPossible use:  string split_with string —&gt;  container  split_with (string , string) —&gt;  containerResult:Returns a list containing the sub-strings (tokens) of the left-hand operand delimited by each of the characters of the right-hand operand.Comment:Delimiters themselves are excluded from the resulting list.Examples:container var0 &lt;- 'to be or not to be,that is the question' split_with ' ,'; \t// var0 equals ['to','be','or','not','to','be','that','is','the','question']sqrtPossible use:  sqrt (int) —&gt;  float  sqrt (float) —&gt;  floatResult:Returns the square root of the operand.Special cases:  if the operand is negative, an exception is raisedExamples:float var0 &lt;- sqrt(4); \t// var0 equals 2.0float var1 &lt;- sqrt(4); \t// var1 equals 2.0squarePossible use:  square (float) —&gt;  geometryResult:A square geometry which side size is equal to the operand.Comment:the centre of the square is by default the location of the current agent in which has been called this operator.Special cases:  returns nil if the operand is nil.Examples:geometry var0 &lt;- square(10); \t// var0 equals a geometry as a square of side size 10.See also:around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, triangle,squirclePossible use:  float squircle float —&gt;  geometry  squircle (float , float) —&gt;  geometryResult:A mix of square and circle geometry (see : http://en.wikipedia.org/wiki/Squircle), which side size is equal to the first operand and power is equal to the second operandComment:the center of the ellipse is by default the location of the current agent in which has been called this operator.Special cases:  returns a point if the side operand is lower or equal to 0.Examples:geometry var0 &lt;- squircle(4,4); \t// var0 equals a geometry as a squircle of side 4 with a power of 4.See also:around, cone, line, link, norm, point, polygon, polyline, super_ellipse, rectangle, square, circle, ellipse, triangle,standard_deviationPossible use:  standard_deviation (container) —&gt;  floatResult:the standard deviation on the elements of the operand. See Standard_deviation for more details.Comment:The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.Examples:float var0 &lt;- standard_deviation ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 1.2930100540985752See also:mean, mean_deviation,stringPossible use:  date string string —&gt;  string  string (date , string) —&gt;  stringResult:converts a date to astring following a custom pattern. The pattern can use “%Y %M %N %D %E %h %m %s %z” for outputting years, months, name of month, days, name of days, hours, minutes, seconds and the time-zone. A null or empty pattern will return the complete date as defined by the ISO date &amp; time format. The pattern can also follow the pattern definition found here, which gives much more control over the format of the date: https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns. Different patterns are available by default as constants: #iso_local, #iso_simple, #iso_offset, #iso_zoned and #custom, which can be changed in the preferencesExamples:format(#now, 'yyyy-MM-dd')subtract_daysSame signification as minus_dayssubtract_hoursSame signification as minus_hourssubtract_minutesSame signification as minus_minutessubtract_monthsSame signification as minus_monthssubtract_msSame signification as minus_mssubtract_secondsSame signification as -subtract_weeksSame signification as minus_weekssubtract_yearsSame signification as minus_yearssuccessors_ofPossible use:  graph successors_of unknown —&gt;  container  successors_of (graph , unknown) —&gt;  containerResult:returns the list of successors (i.e. targets of out edges) of the given vertex (right-hand operand) in the given graph (left-hand operand)Examples:container var1 &lt;- graphEpidemio successors_of ({1,5}); \t// var1 equals [{12,45}]container var2 &lt;- graphEpidemio successors_of node({34,56}); \t// var2 equals []See also:predecessors_of, neighbors_of,sumPossible use:  sum (graph) —&gt;  float  sum (container) —&gt;  unknownResult:the sum of all the elements of the operandComment:the behavior depends on the nature of the operandSpecial cases:  if it is a population or a list of other types: sum transforms all elements into float and sums them  if it is a map, sum returns the sum of the value of all elements  if it is a file, sum returns the sum of the content of the file (that is also a container)  if it is a graph, sum returns the total weight of the graph  if it is a matrix of int, float or object, sum returns the sum of all the numerical elements (i.e. all elements for integer and float matrices)  if it is a matrix of other types: sum transforms all elements into float and sums them  if it is a list of colors: sum will sum them and return the blended resulting color  if it is a list of int or float: sum returns the sum of all the elementsint var0 &lt;- sum ([12,10,3]); \t// var0 equals 25  if it is a list of points: sum returns the sum of all points as a point (each coordinate is the sum of the corresponding coordinate of each element)unknown var1 &lt;- sum([{1.0,3.0},{3.0,5.0},{9.0,1.0},{7.0,8.0}]); \t// var1 equals {20.0,17.0}See also:mul,sum_ofPossible use:  container sum_of any expression —&gt;  unknown  sum_of (container , any expression) —&gt;  unknownResult:the sum of the right-hand expression evaluated on each of the elements of the left-hand operandComment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  if the left-operand is a map, the keyword each will contain each valueunknown var2 &lt;- [1::2, 3::4, 5::6] sum_of (each + 3); \t// var2 equals 21Examples:unknown var1 &lt;- [1,2] sum_of (each * 100 ); \t// var1 equals 300See also:min_of, max_of, product_of, mean_of,svg_filePossible use:  svg_file (string) —&gt;  fileResult:Constructs a file of type svg. Allowed extensions are limited to svgtanPossible use:  tan (int) —&gt;  float  tan (float) —&gt;  floatResult:Returns the value (in [-1,1]) of the trigonometric tangent of the operand (in decimal degrees). The argument is casted to an int before being evaluated.Special cases:  Operand values out of the range [0-359] are normalized. Notice that tan(360) does not return 0.0 but -2.4492935982947064E-16  The tangent is only defined for any real number except 90 + k * 180 (k an positive or negative integer). Nevertheless notice that tan(90) returns 1.633123935319537E16 (whereas we could except infinity).Examples:float var0 &lt;- tan (0); \t// var0 equals 0.0float var1 &lt;- tan(90); \t// var1 equals 1.633123935319537E16See also:cos, sin,tan_radPossible use:  tan_rad (float) —&gt;  floatResult:Returns the value (in [-1,1]) of the trigonometric tangent of the operand (in decimal degrees). The argument is casted to an int before being evaluated.Special cases:  Operand values out of the range [0-359] are normalized. Notice that tan(360) does not return 0.0 but -2.4492935982947064E-16  The tangent is only defined for any real number except 90 + k * 180 (k an positive or negative integer). Nevertheless notice that tan(90) returns 1.633123935319537E16 (whereas we could except infinity).See also:cos, sin,tanhPossible use:  tanh (float) —&gt;  float  tanh (int) —&gt;  floatResult:Returns the value (in the interval [-1,1]) of the hyperbolic tangent of the operand (which can be any real number, expressed in decimal degrees).Examples:float var0 &lt;- tanh(0); \t// var0 equals 0.0float var1 &lt;- tanh(100); \t// var1 equals 1.0target_ofPossible use:  graph target_of unknown —&gt;  unknown  target_of (graph , unknown) —&gt;  unknownResult:returns the target of the edge (right-hand operand) contained in the graph given in left-hand operand.Special cases:  if the lef-hand operand (the graph) is nil, returns nilExamples:graph graphEpidemio &lt;- generate_barabasi_albert( [\"edges_species\"::edge,\"vertices_specy\"::node,\"size\"::3,\"m\"::5] );unknown var1 &lt;- graphEpidemio source_of(edge(3)); \t// var1 equals node1graph graphFromMap &lt;-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);unknown var3 &lt;- graphFromMap target_of(link({1,5}::{12,45})); \t// var3 equals {12,45}See also:source_of,teapotPossible use:  teapot (float) —&gt;  geometryResult:A teapot geometry which radius is equal to the operand.Comment:the centre of the teapot is by default the location of the current agent in which has been called this operator.Special cases:  returns a point if the operand is lower or equal to 0.Examples:geometry var0 &lt;- teapot(10); \t// var0 equals a geometry as a circle of radius 10 but displays a teapot.See also:around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,text_filePossible use:  text_file (string) —&gt;  fileResult:Constructs a file of type text. Allowed extensions are limited to txt, data, textTGaussSame signification as truncated_gaussthreeds_filePossible use:  threeds_file (string) —&gt;  fileResult:Constructs a file of type threeds. Allowed extensions are limited to 3ds, maxtoPossible use:  date to date —&gt;  msi.gama.util.IList&lt;msi.gama.util.GamaDate&gt;  to (date , date) —&gt;  msi.gama.util.IList&lt;msi.gama.util.GamaDate&gt;Result:builds an interval between two dates (the first inclusive and the second exclusive, which behaves like a read-only list of dates. The default step between two dates is the step of the modelComment:The default step can be overruled by using the every operator applied to this intervalExamples:date('2000-01-01') to date('2010-01-01') // builds an interval between these two dates(date('2000-01-01') to date('2010-01-01')) every (#month) // builds an interval between these two dates which contains all the monthly dates starting from the beginning of the intervalSee also:every,to_GAMA_CRSPossible use:  to_GAMA_CRS (geometry) —&gt;  geometry  geometry to_GAMA_CRS string —&gt;  geometry  to_GAMA_CRS (geometry , string) —&gt;  geometrySpecial cases:  returns the geometry corresponding to the transformation of the given geometry to the GAMA CRS (Coordinate Reference System) assuming the given geometry is referenced by given CRSgeometry var0 &lt;- to_GAMA_CRS({121,14}, \"EPSG:4326\"); \t// var0 equals a geometry corresponding to the agent geometry transformed into the GAMA CRS  returns the geometry corresponding to the transformation of the given geometry to the GAMA CRS (Coordinate Reference System) assuming the given geometry is referenced by the current CRS, the one corresponding to the world’s agent onegeometry var1 &lt;- to_GAMA_CRS({121,14}); \t// var1 equals a geometry corresponding to the agent geometry transformed into the GAMA CRSto_gamlPossible use:  to_gaml (unknown) —&gt;  stringResult:returns the literal description of an expression or description – action, behavior, species, aspect, even model – in gamlExamples:string var0 &lt;- to_gaml(0); \t// var0 equals '0'string var1 &lt;- to_gaml(3.78); \t// var1 equals '3.78'string var2 &lt;- to_gaml(true); \t// var2 equals 'true'string var3 &lt;- to_gaml({23, 4.0}); \t// var3 equals '{23.0,4.0,0.0}'string var4 &lt;- to_gaml(5::34); \t// var4 equals '5::34'string var5 &lt;- to_gaml(rgb(255,0,125)); \t// var5 equals 'rgb (255, 0, 125,255)'string var6 &lt;- to_gaml('hello'); \t// var6 equals \"'hello'\"string var7 &lt;- to_gaml([1,5,9,3]); \t// var7 equals '[1,5,9,3]'string var8 &lt;- to_gaml(['a'::345, 'b'::13, 'c'::12]); \t// var8 equals \"(['a'::345,'b'::13,'c'::12] as map )\"string var9 &lt;- to_gaml([[3,5,7,9],[2,4,6,8]]); \t// var9 equals '[[3,5,7,9],[2,4,6,8]]'string var10 &lt;- to_gaml(a_graph); \t// var10 equals ([((1 as node)::(3 as node))::(5 as edge),((0 as node)::(3 as node))::(3 as edge),((1 as node)::(2 as node))::(1 as edge),((0 as node)::(2 as node))::(2 as edge),((0 as node)::(1 as node))::(0 as edge),((2 as node)::(3 as node))::(4 as edge)] as map ) as graphstring var11 &lt;- to_gaml(node1); \t// var11 equals  1 as nodeto_rectanglesPossible use:  to_rectangles (geometry, point, bool) —&gt;  list&lt;geometry&gt;  to_rectangles (geometry, int, int, bool) —&gt;  list&lt;geometry&gt;Result:A list of rectangles of the size corresponding to the given dimension that result from the decomposition of the geometry into rectangles (geometry, dimension, overlaps), if overlaps = true, add the rectangles that overlap the border of the geometryA list of rectangles corresponding to the given dimension that result from the decomposition of the geometry into rectangles (geometry, nb_cols, nb_rows, overlaps) by a grid composed of the given number of columns and rows, if overlaps = true, add the rectangles that overlap the border of the geometryExamples:list&lt;geometry&gt; var0 &lt;- to_rectangles(self, {10.0, 15.0}, true); \t// var0 equals the list of rectangles of size {10.0, 15.0} corresponding to the discretization into rectangles of the geometry of the agent applying the operator. The rectangles overlapping the border of the geometry are keptlist&lt;geometry&gt; var1 &lt;- to_rectangles(self, 5, 20, true); \t// var1 equals the list of rectangles corresponding to the discretization by a grid of 5 columns and 20 rows into rectangles of the geometry of the agent applying the operator. The rectangles overlapping the border of the geometry are keptto_squaresSame signification as split_geometryPossible use:  to_squares (geometry, int, bool) —&gt;  list&lt;geometry&gt;  to_squares (geometry, float, bool) —&gt;  list&lt;geometry&gt;  to_squares (geometry, int, bool, float) —&gt;  list&lt;geometry&gt;Result:A list of a given number of squares from the decomposition of the geometry into squares (geometry, nb_square, overlaps), if overlaps = true, add the squares that overlap the border of the geometryA list of squares of the size corresponding to the given size that result from the decomposition of the geometry into squares (geometry, size, overlaps), if overlaps = true, add the squares that overlap the border of the geometryA list of a given number of squares from the decomposition of the geometry into squares (geometry, nb_square, overlaps, precision_coefficient), if overlaps = true, add the squares that overlap the border of the geometry, coefficient_precision should be close to 1.0Examples:list&lt;geometry&gt; var0 &lt;- to_squares(self, 10, true); \t// var0 equals the list of 10 squares corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are keptlist&lt;geometry&gt; var1 &lt;- to_squares(self, 10.0, true); \t// var1 equals the list of squares of side size 10.0 corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are keptlist&lt;geometry&gt; var2 &lt;- to_squares(self, 10, true, 0.99); \t// var2 equals the list of 10 squares corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are keptto_trianglesSame signification as triangulatetokenizeSame signification as split_withtopologyPossible use:  topology (unknown) —&gt;  topologyResult:casting of the operand to a topology.Special cases:  if the operand is a topology, returns the topology itself;  if the operand is a spatial graph, returns the graph topology associated;  if the operand is a population, returns the topology of the population;  if the operand is a shape or a geometry, returns the continuous topology bounded by the geometry;  if the operand is a matrix, returns the grid topology associated  if the operand is another kind of container, returns the multiple topology associated to the container  otherwise, casts the operand to a geometry and build a topology from it.Examples:topology var0 &lt;- topology(0); \t// var0 equals niltopology(a_graph)\t--: Multiple topology in POLYGON ((24.712119771887785 7.867357373616512, 24.712119771887785 61.283226839310565, 82.4013676510046  7.867357373616512)) at location[53.556743711446195;34.57529210646354]See also:geometry,touchesPossible use:  geometry touches geometry —&gt;  bool  touches (geometry , geometry) —&gt;  boolResult:A boolean, equal to true if the left-geometry (or agent/point) touches the right-geometry (or agent/point).Comment:returns true when the left-operand only touches the right-operand. When one geometry covers partially (or fully) the other one, it returns false.Special cases:  if one of the operand is null, returns false.Examples:bool var0 &lt;- polyline([{10,10},{20,20}]) touches {15,15}; \t// var0 equals falsebool var1 &lt;- polyline([{10,10},{20,20}]) touches {10,10}; \t// var1 equals truebool var2 &lt;- {15,15} touches {15,15}; \t// var2 equals falsebool var3 &lt;- polyline([{10,10},{20,20}]) touches polyline([{10,10},{5,5}]); \t// var3 equals truebool var4 &lt;- polyline([{10,10},{20,20}]) touches polyline([{5,5},{15,15}]); \t// var4 equals falsebool var5 &lt;- polyline([{10,10},{20,20}]) touches polyline([{15,15},{25,25}]); \t// var5 equals falsebool var6 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var6 equals falsebool var7 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{10,20},{20,20},{20,30},{10,30}]); \t// var7 equals truebool var8 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{10,10},{0,10},{0,0},{10,0}]); \t// var8 equals truebool var9 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) touches {15,15}; \t// var9 equals falsebool var10 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) touches {10,15}; \t// var10 equals trueSee also:disjoint_from, crosses, overlaps, partially_overlaps, intersects,towardsPossible use:  geometry towards geometry —&gt;  int  towards (geometry , geometry) —&gt;  intResult:The direction (in degree) between the two geometries (geometries, agents, points) considering the topology of the agent applying the operator.Examples:int var0 &lt;- ag1 towards ag2; \t// var0 equals the direction between ag1 and ag2 and ag3 considering the topology of the agent applying the operatorSee also:distance_between, distance_to, direction_between, path_between, path_to,tracePossible use:  trace (matrix) —&gt;  floatResult:The trace of the given matrix (the sum of the elements on the main diagonal).Examples:float var0 &lt;- trace(matrix([[1,2],[3,4]])); \t// var0 equals 5transformed_byPossible use:  geometry transformed_by point —&gt;  geometry  transformed_by (geometry , point) —&gt;  geometryResult:A geometry resulting from the application of a rotation and a scaling (right-operand : point {angle(degree), scale factor} of the left-hand operand (geometry, agent, point)Examples:geometry var0 &lt;- self transformed_by {45, 0.5}; \t// var0 equals the geometry resulting from 45 degrees rotation and 50% scaling of the geometry of the agent applying the operator.See also:rotated_by, translated_by,translated_byPossible use:  geometry translated_by point —&gt;  geometry  translated_by (geometry , point) —&gt;  geometryResult:A geometry resulting from the application of a translation by the right-hand operand distance to the left-hand operand (geometry, agent, point)Examples:geometry var0 &lt;- self translated_by {10,10,10}; \t// var0 equals the geometry resulting from applying the translation to the left-hand geometry (or agent).See also:rotated_by, transformed_by,translated_toSame signification as at_locationtransposePossible use:  transpose (matrix) —&gt;  matrixResult:The transposition of the given matrixExamples:matrix var0 &lt;- transpose(matrix([[5,-3],[6,-4]])); \t// var0 equals [[5,6],[-3,-4]]trianglePossible use:  triangle (float) —&gt;  geometryResult:A triangle geometry which side size is given by the operand.Comment:the center of the triangle is by default the location of the current agent in which has been called this operator.Special cases:  returns nil if the operand is nil.Examples:geometry var0 &lt;- triangle(5); \t// var0 equals a geometry as a triangle with side_size = 5.See also:around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, square,triangulatePossible use:  triangulate (list&lt;geometry&gt;) —&gt;  list&lt;geometry&gt;  triangulate (geometry) —&gt;  list&lt;geometry&gt;Result:A list of geometries (triangles) corresponding to the Delaunay triangulation of the operand geometry (geometry, agent, point)Examples:list&lt;geometry&gt; var0 &lt;- triangulate(self); \t// var0 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator.list&lt;geometry&gt; var1 &lt;- triangulate(self); \t// var1 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator.truncated_gaussPossible use:  truncated_gauss (container) —&gt;  float  truncated_gauss (point) —&gt;  floatResult:A random value from a normally distributed random variable in the interval ]mean - standardDeviation; mean + standardDeviation[.Special cases:  if the operand is a list, only the two first elements are taken into account as [mean, standardDeviation]  when truncated_gauss is called with a list of only one element mean, it will always return 0.0  when the operand is a point, it is read as {mean, standardDeviation}Examples:float var0 &lt;- truncated_gauss ([0.5, 0.0]); \t// var0 equals 0.5float var1 &lt;- truncated_gauss ({0, 0.3}); \t// var1 equals a float between -0.3 and 0.3See also:gauss,undirectedPossible use:  undirected (graph) —&gt;  graphResult:the operand graph becomes an undirected graph.Comment:the operator alters the operand graph, it does not create a new one.See also:directed,unionPossible use:  union (container&lt;geometry&gt;) —&gt;  geometry  container union container —&gt;  container  union (container , container) —&gt;  containerResult:returns a new list containing all the elements of both containers without duplicated elements.Special cases:  if the left or right operand is nil, union throws an error  if the right-operand is a container of points, geometries or agents, returns the geometry resulting from the union all the geometriesExamples:container var0 &lt;- [1,2,3,4,5,6] union [2,4,9]; \t// var0 equals [1,2,3,4,5,6,9]container var1 &lt;- [1,2,3,4,5,6] union [0,8]; \t// var1 equals [1,2,3,4,5,6,0,8]container var2 &lt;- [1,3,2,4,5,6,8,5,6] union [0,8]; \t// var2 equals [1,3,2,4,5,6,8,0]geometry var3 &lt;- union([geom1, geom2, geom3]); \t// var3 equals a geometry corresponding to union between geom1, geom2 and geom3See also:inter, +,unknownPossible use:  unknown (any) —&gt;  unknownResult:Casts the operand into the type unknownuntilPossible use:  until (date) —&gt;  bool  any expression until date —&gt;  bool  until (any expression , date) —&gt;  boolResult:Returns true if the current_date of the model is before (or equel to) the date passed in argument. Synonym of ‘current_date &lt;= argument’Examples:reflex when: until(starting_date) {} -: will be run only once at the beginning of the simulationupper_casePossible use:  upper_case (string) —&gt;  stringResult:Converts all of the characters in the string operand to upper caseExamples:string var0 &lt;- upper_case(\"Abc\"); \t// var0 equals 'ABC'See also:lower_case,URL_filePossible use:  URL_file (string) —&gt;  fileResult:Constructs a file of type URL. Allowed extensions are limited to urluse_cachePossible use:  graph use_cache bool —&gt;  graph  use_cache (graph , bool) —&gt;  graphResult:if the second operand is true, the operand graph will store in a cache all the previously computed shortest path (the cache be cleared if the graph is modified).Comment:the operator alters the operand graph, it does not create a new one.See also:path_between,user_inputPossible use:  user_input (any expression) —&gt;  map&lt;string,unknown&gt;  string user_input any expression —&gt;  map&lt;string,unknown&gt;  user_input (string , any expression) —&gt;  map&lt;string,unknown&gt;Result:asks the user for some values (not defined as parameters). Takes a string (optional) and a map as arguments. The string is used to specify the message of the dialog box. The map is to specify the parameters you want the user to change before the simulation starts, with the name of the parameter in string key, and the default value as value.Comment:This operator takes a map [string::value] as argument, displays a dialog asking the user for these values, and returns the same map with the modified values (if any). The dialog is modal and will interrupt the execution of the simulation until the user has either dismissed or accepted it. It can be used, for instance, in an init section to force the user to input new values instead of relying on the initial values of parameters :Examples:map&lt;string,unknown&gt; values2 &lt;- user_input(\"Enter numer of agents and locations\",[\"Number\" :: 100, \"Location\" :: {10, 10}]);create bug number: int(values2 at \"Number\") with: [location:: (point(values2 at \"Location\"))];map&lt;string,unknown&gt; values &lt;- user_input([\"Number\" :: 100, \"Location\" :: {10, 10}]);create bug number: int(values at \"Number\") with: [location:: (point(values at \"Location\"))];usingPossible use:  any expression using topology —&gt;  unknown  using (any expression , topology) —&gt;  unknownResult:Allows to specify in which topology a spatial computation should take place.Special cases:  has no effect if the topology passed as a parameter is nilExamples:unknown var0 &lt;- (agents closest_to self) using topology(world); \t// var0 equals the closest agent to self (the caller) in the continuous topology of the worldvariancePossible use:  variance (container) —&gt;  floatResult:the variance of the elements of the operand. See Variance for more details.Comment:The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.Examples:float var0 &lt;- variance ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 1.671875See also:mean, median,variance_ofPossible use:  container variance_of any expression —&gt;  unknown  variance_of (container , any expression) —&gt;  unknownResult:the variance of the right-hand expression evaluated on each of the elements of the left-hand operandComment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.See also:min_of, max_of, sum_of, product_of,voronoiPossible use:  voronoi (list&lt;point&gt;) —&gt;  list&lt;geometry&gt;  list&lt;point&gt; voronoi geometry —&gt;  list&lt;geometry&gt;  voronoi (list&lt;point&gt; , geometry) —&gt;  list&lt;geometry&gt;Result:A list of geometries corresponding to the Voronoi diagram built from the list of points according to the given clipA list of geometries corresponding to the Voronoi diagram built from the list of pointsExamples:list&lt;geometry&gt; var0 &lt;- voronoi([{10,10},{50,50},{90,90},{10,90},{90,10}], square(300)); \t// var0 equals the list of geometries corresponding to the Voronoi Diagram built from the list of points with a square of 300m side size as clip.list&lt;geometry&gt; var1 &lt;- voronoi([{10,10},{50,50},{90,90},{10,90},{90,10}]); \t// var1 equals the list of geometries corresponding to the Voronoi Diagram built from the list of points.weight_ofPossible use:  graph weight_of unknown —&gt;  float  weight_of (graph , unknown) —&gt;  floatResult:returns the weight of the given edge (right-hand operand) contained in the graph given in right-hand operand.Comment:In a localized graph, an edge has a weight by default (the distance between both vertices).Special cases:  if the left-operand (the graph) is nil, returns nil  if the right-hand operand is not an edge of the given graph, weight_of checks whether it is a node of the graph and tries to return its weight  if the right-hand operand is neither a node, nor an edge, returns 1.Examples:graph graphFromMap &lt;-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);float var1 &lt;- graphFromMap weight_of(link({1,5}::{12,45})); \t// var1 equals 1.0weighted_means_DMPossible use:  list&lt;list&gt; weighted_means_DM list&lt;map&lt;string,object&gt;&gt; —&gt;  int  weighted_means_DM (list&lt;list&gt; , list&lt;map&lt;string,object&gt;&gt;) —&gt;  intResult:The index of the candidate that maximizes the weighted mean of its criterion values. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion (list of map)Special cases:  returns -1 is the list of candidates is nil or emptyExamples:int var0 &lt;- weighted_means_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"weight\" :: 2.0],[\"name\"::\"price\", \"weight\" :: 1.0]]); \t// var0 equals 1See also:promethee_DM, electre_DM, evidence_theory_DM,wherePossible use:  container where any expression —&gt;  container  where (container , any expression) —&gt;  containerResult:a list containing all the elements of the left-hand operand that make the right-hand operand evaluate to true.Comment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  if the left-hand operand is a list nil, where returns a new empty list  if the left-operand is a map, the keyword each will contain each valuecontainer var4 &lt;- [1::2, 3::4, 5::6] where (each &gt;= 4); \t// var4 equals [4, 6]Examples:container var0 &lt;- [1,2,3,4,5,6,7,8] where (each &gt; 3); \t// var0 equals [4, 5, 6, 7, 8] container var2 &lt;- g2 where (length(g2 out_edges_of each) = 0 ); \t// var2 equals [node9, node7, node10, node8, node11]container var3 &lt;- (list(node) where (round(node(each).location.x) &gt; 32); \t// var3 equals [node2, node3]See also:first_with, last_with, where,with_lifetimePossible use:  predicate with_lifetime int —&gt;  predicate  with_lifetime (predicate , int) —&gt;  predicateResult:change the parameters of the given predicateExamples:predicate with_lifetime 10with_max_ofPossible use:  container with_max_of any expression —&gt;  unknown  with_max_of (container , any expression) —&gt;  unknownResult:one of elements of the left-hand operand that maximizes the value of the right-hand operandComment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  if the left-hand operand is nil, with_max_of returns the default value of the right-hand operandExamples:unknown var0 &lt;- [1,2,3,4,5,6,7,8] with_max_of (each ); \t// var0 equals 8unknown var2 &lt;- g2 with_max_of (length(g2 out_edges_of each)  ) ; \t// var2 equals node4unknown var3 &lt;- (list(node) with_max_of (round(node(each).location.x)); \t// var3 equals node3unknown var4 &lt;- [1::2, 3::4, 5::6] with_max_of (each); \t// var4 equals 6See also:where, with_min_of,with_min_ofPossible use:  container with_min_of any expression —&gt;  unknown  with_min_of (container , any expression) —&gt;  unknownResult:one of elements of the left-hand operand that minimizes the value of the right-hand operandComment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  if the left-hand operand is nil, with_max_of returns the default value of the right-hand operandExamples:unknown var0 &lt;- [1,2,3,4,5,6,7,8] with_min_of (each ); \t// var0 equals 1unknown var2 &lt;- g2 with_min_of (length(g2 out_edges_of each)  ); \t// var2 equals node11unknown var3 &lt;- (list(node) with_min_of (round(node(each).location.x)); \t// var3 equals node0unknown var4 &lt;- [1::2, 3::4, 5::6] with_min_of (each); \t// var4 equals 2See also:where, with_max_of,with_optimizer_typePossible use:  graph with_optimizer_type string —&gt;  graph  with_optimizer_type (graph , string) —&gt;  graphResult:changes the shortest path computation method of the given graphComment:the right-hand operand can be “Djikstra”, “Bellmann”, “Astar” to use the associated algorithm. Note that these methods are dynamic: the path is computed when needed. In contrarily, if the operand is another string, a static method will be used, i.e. all the shortest are previously computed.Examples:graphEpidemio &lt;- graphEpidemio with_optimizer_type \"static\";See also:set_verbose,with_praiseworthinessPossible use:  predicate with_praiseworthiness float —&gt;  predicate  with_praiseworthiness (predicate , float) —&gt;  predicateResult:change the praiseworthiness value of the given predicateExamples:predicate set_truth falsewith_precisionPossible use:  float with_precision int —&gt;  float  with_precision (float , int) —&gt;  float  point with_precision int —&gt;  point  with_precision (point , int) —&gt;  pointResult:Rounds off the value of left-hand operand to the precision given by the value of right-hand operandRounds off the ordinates of the left-hand point to the precision given by the value of right-hand operandExamples:float var0 &lt;- 12345.78943 with_precision 2; \t// var0 equals 12345.79float var1 &lt;- 123 with_precision 2; \t// var1 equals 123.00point var2 &lt;- {12345.78943, 12345.78943, 12345.78943} with_precision 2 ; \t// var2 equals {12345.79, 12345.79, 12345.79}See also:round,with_priorityPossible use:  predicate with_priority float —&gt;  predicate  with_priority (predicate , float) —&gt;  predicateResult:change the priority of the given predicateExamples:predicate with_priority 2with_valuesPossible use:  predicate with_values map —&gt;  predicate  with_values (predicate , map) —&gt;  predicateResult:change the parameters of the given predicateExamples:predicate with_values [\"time\"::10]with_weightsPossible use:  graph with_weights map —&gt;  graph  with_weights (graph , map) —&gt;  graph  graph with_weights container —&gt;  graph  with_weights (graph , container) —&gt;  graphResult:returns the graph (left-hand operand) with weight given in the map (right-hand operand).Comment:this operand re-initializes the path finderSpecial cases:  if the right-hand operand is a list, affects the n elements of the list to the n first edges. Note that the ordering of edges may change overtime, which can create some problems…  if the left-hand operand is a map, the map should contains pairs such as: vertex/edge::doublegraph_from_edges (list(ant) as_map each::one_of (list(ant))) with_weights (list(ant) as_map each::each.food)without_holesPossible use:  without_holes (geometry) —&gt;  geometryResult:A geometry corresponding to the operand geometry (geometry, agent, point) without its holesExamples:geometry var0 &lt;- solid(self); \t// var0 equals the geometry corresponding to the geometry of the agent applying the operator without its holes.writablePossible use:  file writable bool —&gt;  file  writable (file , bool) —&gt;  fileResult:Marks the file as read-only or not, depending on the second boolean argument, and returns the first argumentComment:A file is created using its native flags. This operator can change them. Beware that this change is system-wide (and not only restrained to GAMA): changing a file to read-only mode (e.g. “writable(f, false)”)Examples:file var0 &lt;- shape_file(\"../images/point_eau.shp\") writable false; \t// var0 equals returns a file in read-only modeSee also:file,xml_filePossible use:  xml_file (string) —&gt;  fileResult:Constructs a file of type xml. Allowed extensions are limited to xmlyears_betweenPossible use:  date years_between date —&gt;  int  years_between (date , date) —&gt;  intResult:Provide the exact number of years between two dates. This number can be positive or negative (if the second operand is smaller than the first one)Examples:years_between(d1, d2) -: 10 ",
        "url":"/wiki/Operators.html"
      }
      ,
    
      "wiki-operatorsac-html": {
        "title": "Operators (A to C)",
        "content": "#Operators (A to C)This file is automatically generated from java files. Do Not Edit It.DefinitionOperators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function.Most of them use a classical prefixed functional syntax (i.e. operator_name(operand1, operand2, operand3), see below), with the exception of arithmetic (e.g. +, /), logical (and, or), comparison (e.g. &gt;, &lt;), access (., [..]) and pair (::) operators, which require an infixed notation (i.e. operand1 operator_symbol operand1).The ternary functional if-else operator, ? :, uses a special infixed syntax composed with two symbols (e.g. operand1 ? operand2 : operand3). Two unary operators (- and !) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g. ` - 10, ! (operand1 or operand2)`).Finally, special constructor operators ({...} for constructing points, [...] for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. {1,2,3}, [operand1, operand2, ..., operandn] or [key1::value1, key2::value2... keyn::valuen]).With the exception of these special cases above, the following rules apply to the syntax of operators:  if they only have one operand, the functional prefixed syntax is mandatory (e.g. operator_name(operand1))  if they have two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2)) or the infixed syntax (e.g. operand1 operator_name operand2) can be used.  if they have more than two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2, ..., operand)) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. operand1 operator_name(operand2, ..., operand)) can be used.All of these alternative syntaxes are completely equivalent.Operators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.Priority between operatorsThe priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.GAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely:  the constructor operators, like ::, used to compose pairs of operands, have the lowest priority of all operators (e.g. a &gt; b :: b &gt; c will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, [a &gt; 10, b &gt; 5] will return a list of boolean values.  it is followed by the ?: operator, the functional if-else (e.g. ` a &gt; b ? a + 10 : a - 10` will return the result of the if-else).  next are the logical operators, and and or (e.g. a &gt; b or b &gt; c will return the value of the test)  next are the comparison operators (i.e. &gt;, &lt;, &lt;=, &gt;=, =, !=)  next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)  next the unary operators - and !  next the access operators . and [] (e.g. {1,2,3}.x &gt; 20 + {4,5,6}.y will return the result of the comparison between the x and y ordinates of the two points)  and finally the functional operators, which have the highest priority of all.Using actions as operatorsActions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.For instance, if the following species is defined:species spec1 {        int min(int x, int y) {                return x &gt; y ? x : y;        }}Any agent instance of spec1 can use min as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:global {        init {                create spec1;                spec1 my_agent &lt;- spec1[0];                int the_min &lt;- my_agent min(10,20); // or min(my_agent, 10, 20);        }}If the action doesn’t have any operands, the syntax to use is my_agent the_action(). Finally, if it does not return a value, it might still be used but is considering as returning a value of type unknown (e.g. unknown result &lt;- my_agent the_action(op1, op2);).Note that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).Table of ContentsOperators by categories3Dbox, cone3D, cube, cylinder, dem, hexagon, pyramid, rgb_to_xyz, set_z, sphere, teapot,Arithmetic operators-, /, [^](OperatorsAC#^), [](OperatorsAC#), +, abs, acos, asin, atan, atan2, ceil, cos, cos_rad, div, even, exp, fact, floor, hypot, is_finite, is_number, ln, log, mod, round, signum, sin, sin_rad, sqrt, tan, tan_rad, tanh, with_precision,BDIand, eval_when, get_about, get_agent, get_agent_cause, get_decay, get_dominance, get_familiarity, get_intensity, get_lifetime, get_liking, get_praiseworthiness, get_priority, get_solidarity, get_super_intention, new_emotion, new_predicate, new_social_link, or, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_liking, set_solidarity, set_truth, with_lifetime, with_praiseworthiness, with_priority, with_values,Casting operatorsas, as_int, as_matrix, font, is, is_skill, list_with, matrix_with, species, to_gaml, topology,Color-related operators-, /, [](OperatorsAC#), +, blend, brewer_colors, brewer_palettes, grayscale, hsb, mean, median, rgb, rnd_color, sum,Comparison operators!=, &lt;, &lt;=, =, &gt;, &gt;=, between,Containers-related operators-, ::, +, accumulate, among, at, collect, contains, contains_all, contains_any, count, distinct, empty, every, first, first_with, get, group_by, in, index_by, inter, interleave, internal_at, internal_integrated_value, last, last_with, length, max, max_of, mean, mean_of, median, min, min_of, mul, one_of, product_of, range, reverse, shuffle, sort_by, sum, sum_of, union, variance_of, where, with_max_of, with_min_of,Date-related operators-, !=, +, &lt;, &lt;=, =, &gt;, &gt;=, after, before, between, every, milliseconds_between, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_weeks, minus_years, months_between, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_weeks, plus_years, since, to, until, years_between,DatesDriving operatorsas_driving_graph,edgeedge_between,EDP-related operatorsdiff, diff2, internal_zero_order_equation,Files-related operatorscrs, file, file_exists, folder, get, new_folder, osm_file, read, writable,FIPA-related operatorsconversation, message,Graphs-related operatorsadd_edge, add_node, adjacency, agent_from_geometry, all_pairs_shortest_path, alpha_index, as_distance_graph, as_edge_graph, as_intersection_graph, as_path, beta_index, betweenness_centrality, biggest_cliques_of, connected_components_of, connectivity_index, contains_edge, contains_vertex, degree_of, directed, edge, edge_between, edge_betweenness, edges, gamma_index, generate_barabasi_albert, generate_complete_graph, generate_watts_strogatz, grid_cells_to_graph, in_degree_of, in_edges_of, layout, load_graph_from_file, load_shortest_paths, maximal_cliques_of, nb_cycles, neighbors_of, node, nodes, out_degree_of, out_edges_of, path_between, paths_between, predecessors_of, remove_node_from, rewire_n, source_of, spatial_graph, successors_of, sum, target_of, undirected, use_cache, weight_of, with_optimizer_type, with_weights,Grid-related operatorsas_4_grid, as_grid, as_hexagonal_grid, grid_at, path_between,Iterator operatorsaccumulate, as_map, collect, count, distribution_of, distribution_of, distribution_of, distribution2d_of, distribution2d_of, distribution2d_of, first_with, frequency_of, group_by, index_by, last_with, max_of, mean_of, min_of, product_of, sort_by, sum_of, variance_of, where, with_max_of, with_min_of,List-related operatorscopy_between, index_of, last_index_of,Logical operators:, !, ?, and, or,Map comparaison operatorsfuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,Map-related operatorsas_map, index_of, last_index_of,Materialmaterial,Matrix-related operators-, /, ., [](OperatorsAC#), +, append_horizontally, append_vertically, column_at, columns_list, determinant, eigenvalues, index_of, inverse, last_index_of, row_at, rows_list, shuffle, trace, transpose,multicriteria operatorselectre_DM, evidence_theory_DM, promethee_DM, weighted_means_DM,Path-related operatorsagent_from_geometry, all_pairs_shortest_path, as_path, load_shortest_paths, path_between, path_to, paths_between, use_cache,Points-related operators-, /, [](OperatorsAC#), +, &lt;, &lt;=, &gt;, &gt;=, add_point, angle_between, any_location_in, centroid, closest_points_with, farthest_point_to, grid_at, norm, point, points_along, points_at, points_on,Random operatorsbinomial, flip, gauss, poisson, rnd, rnd_choice, sample, shuffle, skew_gauss, truncated_gauss,ReverseOperatorsShapearc, box, circle, cone, cone3D, cross, cube, curve, cylinder, ellipse, envelope, geometry_collection, hexagon, line, link, plan, polygon, polyhedron, pyramid, rectangle, sphere, square, squircle, teapot, triangle,Spatial operators-, [](OperatorsAC#), +, add_point, agent_closest_to, agent_farthest_to, agents_at_distance, agents_inside, agents_overlapping, angle_between, any_location_in, arc, around, as_4_grid, as_grid, as_hexagonal_grid, at_distance, at_location, box, centroid, circle, clean, closest_points_with, closest_to, cone, cone3D, convex_hull, covers, cross, crosses, crs, CRS_transform, cube, curve, cylinder, dem, direction_between, disjoint_from, distance_between, distance_to, ellipse, envelope, farthest_point_to, farthest_to, geometry_collection, gini, hexagon, hierarchical_clustering, IDW, inside, inter, intersects, line, link, masked_by, moran, neighbors_at, neighbors_of, overlapping, overlaps, partially_overlaps, path_between, path_to, plan, points_along, points_at, points_on, polygon, polyhedron, pyramid, rectangle, rgb_to_xyz, rotated_by, round, scaled_to, set_z, simple_clustering_by_distance, simplification, skeletonize, smooth, sphere, split_at, split_geometry, split_lines, square, squircle, teapot, to_GAMA_CRS, to_rectangles, to_squares, touches, towards, transformed_by, translated_by, triangle, triangulate, union, using, voronoi, with_precision, without_holes,Spatial properties operatorscovers, crosses, intersects, partially_overlaps, touches,Spatial queries operatorsagent_closest_to, agent_farthest_to, agents_at_distance, agents_inside, agents_overlapping, at_distance, closest_to, farthest_to, inside, neighbors_at, neighbors_of, overlapping,Spatial relations operatorsdirection_between, distance_between, distance_to, path_between, path_to, towards,Spatial statistical operatorshierarchical_clustering, simple_clustering_by_distance,Spatial transformations operators-, [](OperatorsAC#), +, as_4_grid, as_grid, as_hexagonal_grid, at_location, clean, convex_hull, CRS_transform, rotated_by, scaled_to, simplification, skeletonize, smooth, split_geometry, split_lines, to_GAMA_CRS, to_rectangles, to_squares, transformed_by, translated_by, triangulate, voronoi, without_holes,Species-related operatorsindex_of, last_index_of, of_generic_species, of_species,Statistical operatorsbuild, corR, dbscan, distribution_of, distribution2d_of, frequency_of, gamma_rnd, geometric_mean, gini, harmonic_mean, hierarchical_clustering, kmeans, kurtosis, max, mean, mean_deviation, meanR, median, min, moran, mul, predict, simple_clustering_by_distance, skewness, standard_deviation, sum, variance,Strings-related operators+, &lt;, &lt;=, &gt;, &gt;=, at, char, contains, contains_all, contains_any, copy_between, date, empty, first, in, indented_by, index_of, is_number, last, last_index_of, length, lower_case, replace, replace_regex, reverse, sample, shuffle, split_with, string, upper_case,System., command, copy, dead, eval_gaml, every, user_input,Time-related operatorsdate, string,Types-related operatorsUser control operatorsuser_input,Operators-Possible use:  - (int) —&gt;  int  - (point) —&gt;  point  - (float) —&gt;  float  int - float —&gt;  float  - (int , float) —&gt;  float  int - int —&gt;  int  - (int , int) —&gt;  int  matrix - float —&gt;  matrix  - (matrix , float) —&gt;  matrix  float - matrix —&gt;  matrix  - (float , matrix) —&gt;  matrix  date - float —&gt;  date  - (date , float) —&gt;  date  species - agent —&gt;  container  - (species , agent) —&gt;  container  date - date —&gt;  float  - (date , date) —&gt;  float  matrix - matrix —&gt;  matrix  - (matrix , matrix) —&gt;  matrix  point - int —&gt;  point  - (point , int) —&gt;  point  date - int —&gt;  date  - (date , int) —&gt;  date  point - float —&gt;  point  - (point , float) —&gt;  point  float - float —&gt;  float  - (float , float) —&gt;  float  rgb - rgb —&gt;  rgb  - (rgb , rgb) —&gt;  rgb  int - matrix —&gt;  matrix  - (int , matrix) —&gt;  matrix  container - container —&gt;  container  - (container , container) —&gt;  container  rgb - int —&gt;  rgb  - (rgb , int) —&gt;  rgb  container - unknown —&gt;  container  - (container , unknown) —&gt;  container  point - point —&gt;  point  - (point , point) —&gt;  point  float - int —&gt;  float  - (float , int) —&gt;  float  geometry - geometry —&gt;  geometry  - (geometry , geometry) —&gt;  geometry  matrix - int —&gt;  matrix  - (matrix , int) —&gt;  matrix  geometry - float —&gt;  geometry  - (geometry , float) —&gt;  geometry  map - map —&gt;  map  - (map , map) —&gt;  map  map - pair —&gt;  map  - (map , pair) —&gt;  map  geometry - container&lt;geometry&gt; —&gt;  geometry  - (geometry , container&lt;geometry&gt;) —&gt;  geometryResult:Returns the difference of the two operands.If it is used as an unary operator, it returns the opposite of the operand.Comment:The behavior of the operator depends on the type of the operands.Special cases:  if the left operand is a species and the right operand is an agent of the species, - returns a list containing all the agents of the species minus this agent  if both operands are containers and the right operand is empty, - returns the left operand  if both operands are numbers, performs a normal arithmetic difference and returns a float if one of them is a float.int var7 &lt;- 1 - 1; \t// var7 equals 0int var8 &lt;- 1.0 - 1; \t// var8 equals 0.0int var9 &lt;- 3.7 - 1.2; \t// var9 equals 2.5int var10 &lt;- 3 - 1.2; \t// var10 equals 1.8  if both operands are dates, returns the duration in seconds between  date2 and date1. To obtain a more precise duration, in milliseconds, use milliseconds_between(date1, date2)float var11 &lt;- date1 - date2; \t// var11 equals 598  if one of the operands is a date and the other a number, returns a date corresponding to the date minus the given number as duration (in seconds)date1 - 200  if left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the difference of the operand coordinate with this number.point var13 &lt;- {1, 2} - 4.5; \t// var13 equals {-3.5, -2.5, -4.5}point var14 &lt;- {1, 2} - 4; \t// var14 equals {-3.0,-2.0,-4.0}  if both operands are colors, returns a new color resulting from the subtraction of the two operands, component by componentrgb var15 &lt;- rgb([255, 128, 32]) - rgb('red'); \t// var15 equals rgb([0,128,32])  if one operand is a matrix and the other a number (float or int), performs a normal arithmetic difference of the number with each element of the matrix (results are float if the number is a float.matrix var16 &lt;- 3.5 - matrix([[2,5],[3,4]]); \t// var16 equals matrix([[1.5,-1.5],[0.5,-0.5]])  if both operands are containers, returns a new list in which all the elements of the right operand have been removed from the left onelist&lt;int&gt; var17 &lt;- [1,2,3,4,5,6] - [2,4,9]; \t// var17 equals [1,3,5,6]list&lt;int&gt; var18 &lt;- [1,2,3,4,5,6] - [0,8]; \t// var18 equals [1,2,3,4,5,6]  if one operand is a color and the other an integer, returns a new color resulting from the subtraction of each component of the color with the right operandrgb var19 &lt;- rgb([255, 128, 32]) - 3; \t// var19 equals rgb([252,125,29])  if the left operand is a list and the right operand is an object of any type (except list), - returns a list containing the elements of the left operand minus all the occurrences of this objectlist&lt;int&gt; var20 &lt;- [1,2,3,4,5,6] - 2; \t// var20 equals [1,3,4,5,6]list&lt;int&gt; var21 &lt;- [1,2,3,4,5,6] - 0; \t// var21 equals [1,2,3,4,5,6]  if both operands are points, returns their difference (coordinates per coordinates).point var22 &lt;- {1, 2} - {4, 5}; \t// var22 equals {-3.0, -3.0}  if both operands are a point, a geometry or an agent, returns the geometry resulting from the difference between both geometriesgeometry var23 &lt;- geom1 - geom2; \t// var23 equals a geometry corresponding to difference between geom1 and geom2  if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) reduced by the right-hand operand distancegeometry var24 &lt;- shape - 5; \t// var24 equals a geometry corresponding to the geometry of the agent applying the operator reduced by a distance of 5  if the right-operand is a list of points, geometries or agents, returns the geometry resulting from the difference between the left-geometry and all of the right-geometriesgeometry var25 &lt;- rectangle(10,10) - [circle(2), square(2)]; \t// var25 equals rectangle(10,10) - (circle(2) + square(2))Examples:int var0 &lt;- - (-56); \t// var0 equals 56point var1 &lt;- -{3.0,5.0}; \t// var1 equals {-3.0,-5.0}point var2 &lt;- -{1.0,6.0,7.0}; \t// var2 equals {-1.0,-6.0,-7.0}map var3 &lt;- ['a'::1,'b'::2] - ['b'::2]; \t// var3 equals ['a'::1]map var4 &lt;- ['a'::1,'b'::2] - ['b'::2,'c'::3]; \t// var4 equals ['a'::1]map var5 &lt;- ['a'::1,'b'::2] - ('b'::2); \t// var5 equals ['a'::1]map var6 &lt;- ['a'::1,'b'::2] - ('c'::3); \t// var6 equals ['a'::1,'b'::2]See also:+, [](OperatorsAC#), /, milliseconds_between, -,:Possible use:  unknown : unknown —&gt;  unknown  : (unknown , unknown) —&gt;  unknownSee also:?,::Possible use:  any expression :: any expression —&gt;  pair  :: (any expression , any expression) —&gt;  pairResult:produces a new pair combining the left and the right operandsSpecial cases:  nil is not acceptable as a key (although it is as a value). If such a case happens, :: will throw an appropriate error!Possible use:  ! (bool) —&gt;  boolResult:opposite boolean value.Special cases:  if the parameter is not boolean, it is casted to a boolean value.Examples:bool var0 &lt;- ! (true); \t// var0 equals falseSee also:bool, and, or,!=Possible use:  float != float —&gt;  bool  != (float , float) —&gt;  bool  unknown != unknown —&gt;  bool  != (unknown , unknown) —&gt;  bool  date != date —&gt;  bool  != (date , date) —&gt;  bool  float != int —&gt;  bool  != (float , int) —&gt;  bool  int != float —&gt;  bool  != (int , float) —&gt;  boolResult:true if both operands are different, false otherwiseExamples:bool var0 &lt;- 3.0 != 3.0; \t// var0 equals falsebool var1 &lt;- 4.0 != 4.7; \t// var1 equals truebool var2 &lt;- [2,3] != [2,3]; \t// var2 equals falsebool var3 &lt;- [2,4] != [2,3]; \t// var3 equals true#now != #now minus_hours 1 :- truebool var5 &lt;- 3.0 != 3; \t// var5 equals falsebool var6 &lt;- 4.7 != 4; \t// var6 equals truebool var7 &lt;- 3 != 3.0; \t// var7 equals falsebool var8 &lt;- 4 != 4.7; \t// var8 equals trueSee also:=, &gt;, &lt;, &gt;=, &lt;=,?Possible use:  bool ? any expression —&gt;  unknown  ? (bool , any expression) —&gt;  unknownResult:It is used in combination with the : operator: if the left-hand operand evaluates to true, returns the value of the left-hand operand of the :, otherwise that of the right-hand operand of the :Comment:These functional tests can be combined together.Examples:list&lt;string&gt; var0 &lt;- [10, 19, 43, 12, 7, 22] collect ((each &gt; 20) ? 'above' : 'below'); \t// var0 equals ['below', 'below', 'above', 'below', 'below', 'above']rgb color &lt;- (flip(0.3) ? #red : (flip(0.9) ? #blue : #green));See also::,/Possible use:  rgb / float —&gt;  rgb  / (rgb , float) —&gt;  rgb  float / int —&gt;  float  / (float , int) —&gt;  float  point / float —&gt;  point  / (point , float) —&gt;  point  int / int —&gt;  float  / (int , int) —&gt;  float  int / float —&gt;  float  / (int , float) —&gt;  float  matrix / float —&gt;  matrix  / (matrix , float) —&gt;  matrix  point / int —&gt;  point  / (point , int) —&gt;  point  matrix / matrix —&gt;  matrix  / (matrix , matrix) —&gt;  matrix  matrix / int —&gt;  matrix  / (matrix , int) —&gt;  matrix  float / float —&gt;  float  / (float , float) —&gt;  float  rgb / int —&gt;  rgb  / (rgb , int) —&gt;  rgbResult:Returns the division of the two operands.Special cases:  if the right-hand operand is equal to zero, raises a “Division by zero” exception  if one operand is a color and the other a double, returns a new color resulting from the division of each component of the color by the right operand. The result on each component is then truncated.rgb var0 &lt;- rgb([255, 128, 32]) / 2.5; \t// var0 equals rgb([102,51,13])  if the left operand is a point, returns a new point with coordinates divided by the right operandpoint var1 &lt;- {5, 7.5} / 2.5; \t// var1 equals {2, 3}point var2 &lt;- {2,5} / 4; \t// var2 equals {0.5,1.25}  if both operands are numbers (float or int), performs a normal arithmetic division and returns a float.float var3 &lt;- 3 / 5.0; \t// var3 equals 0.6  if one operand is a color and the other an integer, returns a new color resulting from the division of each component of the color by the right operandrgb var4 &lt;- rgb([255, 128, 32]) / 2; \t// var4 equals rgb([127,64,16])See also:[](OperatorsAC#), +, -,.Possible use:  matrix . matrix —&gt;  matrix  . (matrix , matrix) —&gt;  matrix  agent . any expression —&gt;  unknown  . (agent , any expression) —&gt;  unknownResult:It has two different uses: it can be the dot product between 2 matrices or return an evaluation of the expression (right-hand operand) in the scope the given agent.Special cases:  if the agent is nil or dead, throws an exception  if both operands are matrix, returns the dot product of themmatrix var0 &lt;- matrix([[1,1],[1,2]]) . matrix([[1,1],[1,2]]); \t// var0 equals matrix([[2,3],[3,5]])  if the left operand is an agent, it evaluates of the expression (right-hand operand) in the scope the given agentunknown var1 &lt;- agent1.location; \t// var1 equals the location of the agent agent1map(nil).keys^Possible use:  int ^ float —&gt;  float  ^ (int , float) —&gt;  float  float ^ float —&gt;  float  ^ (float , float) —&gt;  float  int ^ int —&gt;  float  ^ (int , int) —&gt;  float  float ^ int —&gt;  float  ^ (float , int) —&gt;  floatResult:Returns the value (always a float) of the left operand raised to the power of the right operand.Special cases:  if the right-hand operand is equal to 0, returns 1  if it is equal to 1, returns the left-hand operand.  Various examples of powerfloat var1 &lt;- 2 ^ 3; \t// var1 equals 8.0Examples:float var0 &lt;- 4.84 ^ 0.5; \t// var0 equals 2.2See also:[](OperatorsAC#), sqrt,@Same signification as at*Possible use:  int * int —&gt;  int  * (int , int) —&gt;  int  matrix * int —&gt;  matrix  * (matrix , int) —&gt;  matrix  point * point —&gt;  float  * (point , point) —&gt;  float  int * float —&gt;  float  * (int , float) —&gt;  float  float * float —&gt;  float  * (float , float) —&gt;  float  matrix * matrix —&gt;  matrix  * (matrix , matrix) —&gt;  matrix  point * int —&gt;  point  * (point , int) —&gt;  point  float * matrix —&gt;  matrix  * (float , matrix) —&gt;  matrix  geometry * point —&gt;  geometry  * (geometry , point) —&gt;  geometry  point * float —&gt;  point  * (point , float) —&gt;  point  int * matrix —&gt;  matrix  * (int , matrix) —&gt;  matrix  float * int —&gt;  float  * (float , int) —&gt;  float  rgb * int —&gt;  rgb  * (rgb , int) —&gt;  rgb  matrix * float —&gt;  matrix  * (matrix , float) —&gt;  matrix  geometry * float —&gt;  geometry  * (geometry , float) —&gt;  geometryResult:Returns the product of the two operands.Special cases:  if both operands are numbers (float or int), performs a normal arithmetic product and returns a float if one of them is a float.int var1 &lt;- 1 * 1; \t// var1 equals 1  if both operands are points, returns their scalar productfloat var2 &lt;- {2,5} * {4.5, 5}; \t// var2 equals 34.0  if the left-hand operator is a point and the right-hand a number, returns a point with coordinates multiplied by the numberpoint var3 &lt;- {2,5} * 4; \t// var3 equals {8.0, 20.0}point var4 &lt;- {2, 4} * 2.5; \t// var4 equals {5.0, 10.0}  if the left-hand operand is a geometry and the right-hand operand a point, returns a geometry corresponding to the left-hand operand (geometry, agent, point) scaled by the right-hand operand coefficients in the 3 dimensionsgeometry var5 &lt;- shape * {0.5,0.5,2}; \t// var5 equals a geometry corresponding to the geometry of the agent applying the operator scaled by a coefficient of 0.5 in x, 0.5 in y and 2 in z  if one operand is a matrix and the other a number (float or int), performs a normal arithmetic product of the number with each element of the matrix (results are float if the number is a float.matrix&lt;float&gt; m &lt;- (3.5 * matrix([[2,5],[3,4]]));\t//m equals matrix([[7.0,17.5],[10.5,14]])  if one operand is a color and the other an integer, returns a new color resulting from the product of each component of the color with the right operand (with a maximum value at 255)rgb var7 &lt;- rgb([255, 128, 32]) * 2; \t// var7 equals rgb([255,255,64])  if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) scaled by the right-hand operand coefficientgeometry var8 &lt;- circle(10) * 2; \t// var8 equals circle(20)Examples:float var0 &lt;- 2.5 * 2; \t// var0 equals 5.0See also:+, -, /,+Possible use:  string + string —&gt;  string  + (string , string) —&gt;  string  date + float —&gt;  date  + (date , float) —&gt;  date  map + pair —&gt;  map  + (map , pair) —&gt;  map  int + matrix —&gt;  matrix  + (int , matrix) —&gt;  matrix  point + int —&gt;  point  + (point , int) —&gt;  point  rgb + rgb —&gt;  rgb  + (rgb , rgb) —&gt;  rgb  geometry + float —&gt;  geometry  + (geometry , float) —&gt;  geometry  matrix + float —&gt;  matrix  + (matrix , float) —&gt;  matrix  geometry + geometry —&gt;  geometry  + (geometry , geometry) —&gt;  geometry  map + map —&gt;  map  + (map , map) —&gt;  map  float + float —&gt;  float  + (float , float) —&gt;  float  float + int —&gt;  float  + (float , int) —&gt;  float  matrix + matrix —&gt;  matrix  + (matrix , matrix) —&gt;  matrix  date + string —&gt;  string  + (date , string) —&gt;  string  matrix + int —&gt;  matrix  + (matrix , int) —&gt;  matrix  int + int —&gt;  int  + (int , int) —&gt;  int  string + unknown —&gt;  string  + (string , unknown) —&gt;  string  point + point —&gt;  point  + (point , point) —&gt;  point  float + matrix —&gt;  matrix  + (float , matrix) —&gt;  matrix  int + float —&gt;  float  + (int , float) —&gt;  float  point + float —&gt;  point  + (point , float) —&gt;  point  rgb + int —&gt;  rgb  + (rgb , int) —&gt;  rgb  date + int —&gt;  date  + (date , int) —&gt;  date  container + container —&gt;  container  + (container , container) —&gt;  container  container + unknown —&gt;  container  + (container , unknown) —&gt;  container  + (geometry, float, int) —&gt;  geometry  + (geometry, float, int, int) —&gt;  geometryResult:Returns the sum, union or concatenation of the two operands.Special cases:  if one of the operands is nil, + throws an error  if both operands are species, returns a special type of list called meta-population  if the left-hand operand is a geometry and the right-hand operands a float and an integer, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the first right-hand operand (distance), using a number of segments equal to the second right-hand operandgeometry var4 &lt;- circle(5) + (5,32); \t// var4 equals circle(10)  if one operand is a matrix and the other a number (float or int), performs a normal arithmetic sum of the number with each element of the matrix (results are float if the number is a float.matrix var5 &lt;- 3.5 + matrix([[2,5],[3,4]]); \t// var5 equals matrix([[5.5,8.5],[6.5,7.5]])  if both operands are colors, returns a new color resulting from the sum of the two operands, component by componentrgb var6 &lt;- rgb([255, 128, 32]) + rgb('red'); \t// var6 equals rgb([255,128,32])  if the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the right-hand operand distance. The number of segments used by default is 8 and the end cap style is #roundgeometry var7 &lt;- circle(5) + 5; \t// var7 equals circle(10)  if the right-operand is a point, a geometry or an agent, returns the geometry resulting from the union between both geometriesgeometry var8 &lt;- geom1 + geom2; \t// var8 equals a geometry corresponding to union between geom1 and geom2  if both operands are numbers (float or int), performs a normal arithmetic sum and returns a float if one of them is a float.int var9 &lt;- 1 + 1; \t// var9 equals 2int var10 &lt;- 1.0 + 1; \t// var10 equals 2.0int var11 &lt;- 1.0 + 2.5; \t// var11 equals 3.5  if the left-hand operand is a string, returns the concatenation of the two operands (the left-hand one beind casted into a string)string var12 &lt;- \"hello \" + 12; \t// var12 equals \"hello 12\"  if both operands are points, returns their sum.point var13 &lt;- {1, 2} + {4, 5}; \t// var13 equals {5.0, 7.0}  if the left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the sum of the operand coordinate with this number.point var14 &lt;- {1, 2} + 4; \t// var14 equals {5.0, 6.0,4.0}point var15 &lt;- {1, 2} + 4.5; \t// var15 equals {5.5, 6.5,4.5}  if one operand is a color and the other an integer, returns a new color resulting from the sum of each component of the color with the right operandrgb var16 &lt;- rgb([255, 128, 32]) + 3; \t// var16 equals rgb([255,131,35])  if the left-hand operand is a geometry and the right-hand operands a float, an integer and one of #round, #square or #flat, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the first right-hand operand (distance), using a number of segments equal to the second right-hand operand and a flat, square or round end cap stylegeometry var17 &lt;- circle(5) + (5,32,#round); \t// var17 equals circle(10)  if one of the operands is a date and the other a number, returns a date corresponding to the date plus the given number as duration (in seconds)date1 + 200  if both operands are list, +returns the concatenation of both lists.list&lt;int&gt; var19 &lt;- [1,2,3,4,5,6] + [2,4,9]; \t// var19 equals [1,2,3,4,5,6,2,4,9]list&lt;int&gt; var20 &lt;- [1,2,3,4,5,6] + [0,8]; \t// var20 equals [1,2,3,4,5,6,0,8]  if the right operand is an object of any type (except a container), + returns a list of the elements of the left operand, to which this object has been addedlist&lt;int&gt; var21 &lt;- [1,2,3,4,5,6] + 2; \t// var21 equals [1,2,3,4,5,6,2]list&lt;int&gt; var22 &lt;- [1,2,3,4,5,6] + 0; \t// var22 equals [1,2,3,4,5,6,0]Examples:map var0 &lt;- ['a'::1,'b'::2] + ('c'::3); \t// var0 equals ['a'::1,'b'::2,'c'::3]map var1 &lt;- ['a'::1,'b'::2] + ('c'::3); \t// var1 equals ['a'::1,'b'::2,'c'::3]map var2 &lt;- ['a'::1,'b'::2] + ['c'::3]; \t// var2 equals ['a'::1,'b'::2,'c'::3]map var3 &lt;- ['a'::1,'b'::2] + [5::3.0]; \t// var3 equals ['a'::1.0,'b'::2.0,5::3.0]See also:-, [](OperatorsAC#), /,&lt;Possible use:  float &lt; int —&gt;  bool  &lt; (float , int) —&gt;  bool  int &lt; int —&gt;  bool  &lt; (int , int) —&gt;  bool  point &lt; point —&gt;  bool  &lt; (point , point) —&gt;  bool  int &lt; float —&gt;  bool  &lt; (int , float) —&gt;  bool  date &lt; date —&gt;  bool  &lt; (date , date) —&gt;  bool  float &lt; float —&gt;  bool  &lt; (float , float) —&gt;  bool  string &lt; string —&gt;  bool  &lt; (string , string) —&gt;  boolResult:true if the left-hand operand is less than the right-hand operand, false otherwise.Special cases:  if one of the operands is nil, returns false  if both operands are points, returns true if and only if the left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.bool var5 &lt;- {5,7} &lt; {4,6}; \t// var5 equals falsebool var6 &lt;- {5,7} &lt; {4,8}; \t// var6 equals false  if both operands are String, uses a lexicographic comparison of two stringsbool var7 &lt;- 'abc' &lt; 'aeb'; \t// var7 equals trueExamples:bool var0 &lt;- 3.5 &lt; 7; \t// var0 equals truebool var1 &lt;- 3 &lt; 7; \t// var1 equals truebool var2 &lt;- 3 &lt; 2.5; \t// var2 equals false#now &lt; #now minus_hours 1 :- falsebool var4 &lt;- 3.5 &lt; 7.6; \t// var4 equals trueSee also:&gt;, &gt;=, &lt;=, =, !=,&lt;=Possible use:  string &lt;= string —&gt;  bool  &lt;= (string , string) —&gt;  bool  date &lt;= date —&gt;  bool  &lt;= (date , date) —&gt;  bool  float &lt;= float —&gt;  bool  &lt;= (float , float) —&gt;  bool  int &lt;= int —&gt;  bool  &lt;= (int , int) —&gt;  bool  int &lt;= float —&gt;  bool  &lt;= (int , float) —&gt;  bool  float &lt;= int —&gt;  bool  &lt;= (float , int) —&gt;  bool  point &lt;= point —&gt;  bool  &lt;= (point , point) —&gt;  boolResult:true if the left-hand operand is less or equal than the right-hand operand, false otherwise.Special cases:  if one of the operands is nil, returns false  if both operands are String, uses a lexicographic comparison of two stringsbool var5 &lt;- 'abc' &lt;= 'aeb'; \t// var5 equals true  if both operands are points, returns true if and only if the left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.bool var6 &lt;- {5,7} &lt;= {4,6}; \t// var6 equals falsebool var7 &lt;- {5,7} &lt;= {4,8}; \t// var7 equals falseExamples:#now &lt;= #now minus_hours 1 :- falsebool var1 &lt;- 3.5 &lt;= 3.5; \t// var1 equals truebool var2 &lt;- 3 &lt;= 7; \t// var2 equals truebool var3 &lt;- 3 &lt;= 2.5; \t// var3 equals falsebool var4 &lt;- 7.0 &lt;= 7; \t// var4 equals trueSee also:&gt;, &lt;, &gt;=, =, !=,&lt;&gt;Same signification as !==Possible use:  date = date —&gt;  bool  = (date , date) —&gt;  bool  int = float —&gt;  bool  = (int , float) —&gt;  bool  unknown = unknown —&gt;  bool  = (unknown , unknown) —&gt;  bool  float = float —&gt;  bool  = (float , float) —&gt;  bool  float = int —&gt;  bool  = (float , int) —&gt;  bool  int = int —&gt;  bool  = (int , int) —&gt;  boolResult:returns true if both operands are equal, false otherwisereturns true if both operands are equal, false otherwiseSpecial cases:  if both operands are any kind of objects, returns true if they are identical (i.e., the same object) or equal (comparisons between nil values are permitted)bool var0 &lt;- [2,3] = [2,3]; \t// var0 equals trueExamples:#now = #now minus_hours 1 :- falsebool var2 &lt;- 3 = 3.0; \t// var2 equals truebool var3 &lt;- 4 = 4.7; \t// var3 equals falsebool var4 &lt;- 4.5 = 4.7; \t// var4 equals falsebool var5 &lt;- 4.7 = 4; \t// var5 equals falsebool var6 &lt;- 4 = 5; \t// var6 equals falseSee also:!=, &gt;, &lt;, &gt;=, &lt;=,&gt;Possible use:  int &gt; float —&gt;  bool  &gt; (int , float) —&gt;  bool  float &gt; float —&gt;  bool  &gt; (float , float) —&gt;  bool  string &gt; string —&gt;  bool  &gt; (string , string) —&gt;  bool  int &gt; int —&gt;  bool  &gt; (int , int) —&gt;  bool  date &gt; date —&gt;  bool  &gt; (date , date) —&gt;  bool  point &gt; point —&gt;  bool  &gt; (point , point) —&gt;  bool  float &gt; int —&gt;  bool  &gt; (float , int) —&gt;  boolResult:true if the left-hand operand is greater than the right-hand operand, false otherwise.Special cases:  if one of the operands is nil, returns false  if both operands are String, uses a lexicographic comparison of two stringsbool var0 &lt;- 'abc' &gt; 'aeb'; \t// var0 equals false  if both operands are points, returns true if and only if the left component (x) of the left operand if greater than x of the right one and if the right component (y) of the left operand is greater than y of the right one.bool var1 &lt;- {5,7} &gt; {4,6}; \t// var1 equals truebool var2 &lt;- {5,7} &gt; {4,8}; \t// var2 equals falseExamples:bool var3 &lt;- 3 &gt; 2.5; \t// var3 equals truebool var4 &lt;- 3.5 &gt; 7.6; \t// var4 equals falsebool var5 &lt;- 3 &gt; 7; \t// var5 equals false#now &gt; #now minus_hours 1 :- truebool var7 &lt;- 3.5 &gt; 7; \t// var7 equals falseSee also:&lt;, &gt;=, &lt;=, =, !=,&gt;=Possible use:  float &gt;= int —&gt;  bool  &gt;= (float , int) —&gt;  bool  int &gt;= int —&gt;  bool  &gt;= (int , int) —&gt;  bool  int &gt;= float —&gt;  bool  &gt;= (int , float) —&gt;  bool  string &gt;= string —&gt;  bool  &gt;= (string , string) —&gt;  bool  date &gt;= date —&gt;  bool  &gt;= (date , date) —&gt;  bool  float &gt;= float —&gt;  bool  &gt;= (float , float) —&gt;  bool  point &gt;= point —&gt;  bool  &gt;= (point , point) —&gt;  boolResult:true if the left-hand operand is greater or equal than the right-hand operand, false otherwise.Special cases:  if one of the operands is nil, returns false  if both operands are string, uses a lexicographic comparison of the two stringsbool var5 &lt;- 'abc' &gt;= 'aeb'; \t// var5 equals falsebool var6 &lt;- 'abc' &gt;= 'abc'; \t// var6 equals true  if both operands are points, returns true if and only if the left component (x) of the left operand if greater or equal than x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.bool var7 &lt;- {5,7} &gt;= {4,6}; \t// var7 equals truebool var8 &lt;- {5,7} &gt;= {4,8}; \t// var8 equals falseExamples:bool var0 &lt;- 3.5 &gt;= 7; \t// var0 equals falsebool var1 &lt;- 3 &gt;= 7; \t// var1 equals falsebool var2 &lt;- 3 &gt;= 2.5; \t// var2 equals true#now &gt;= #now minus_hours 1 :- truebool var4 &lt;- 3.5 &gt;= 3.5; \t// var4 equals trueSee also:&gt;, &lt;, &lt;=, =, !=,absPossible use:  abs (int) —&gt;  int  abs (float) —&gt;  floatResult:Returns the absolute value of the operand (so a positive int or float depending on the type of the operand).Examples:int var0 &lt;- abs (-10); \t// var0 equals 10int var1 &lt;- abs (10); \t// var1 equals 10float var3 &lt;- abs (200 * -1 + 0.5); \t// var3 equals 199.5accumulatePossible use:  container accumulate any expression —&gt;  container  accumulate (container , any expression) —&gt;  containerResult:returns a new flat list, in which each element is the evaluation of the right-hand operand. If this evaluation returns a list, the elements of this result are added directly to the list returnedComment:accumulate is dedicated to the application of a same computation on each element of a container (and returns a list). In the right-hand operand, the keyword each can be used to represent, in turn, each of the left-hand operand elements.Examples:container var0 &lt;- [a1,a2,a3] accumulate (each neighbors_at 10); \t// var0 equals a flat list of all the neighbors of these three agentslist&lt;int&gt; var1 &lt;- [1,2,4] accumulate ([2,4]); \t// var1 equals [2,4,2,4,2,4]list&lt;int&gt; var2 &lt;- [1,2,4] accumulate (each * 2); \t// var2 equals [2,4,8]See also:collect,acosPossible use:  acos (float) —&gt;  float  acos (int) —&gt;  floatResult:Returns the value (in the interval [0,180], in decimal degrees) of the arccos of the operand (which should be in [-1,1]).Special cases:  if the right-hand operand is outside of the [-1,1] interval, returns NaNExamples:float var0 &lt;- acos (0); \t// var0 equals 90.0See also:asin, atan, cos,actionPossible use:  action (any) —&gt;  actionResult:Casts the operand into the type actionadd_daysSame signification as plus_daysadd_edgePossible use:  graph add_edge pair —&gt;  graph  add_edge (graph , pair) —&gt;  graphResult:add an edge between a source vertex and a target vertex (resp. the left and the right element of the pair operand)Comment:if the edge already exists, the graph is unchangedExamples:graph &lt;- graph add_edge (source::target);See also:add_node, graph,add_hoursSame signification as plus_hoursadd_minutesSame signification as plus_minutesadd_monthsSame signification as plus_monthsadd_msSame signification as plus_msadd_nodePossible use:  graph add_node geometry —&gt;  graph  add_node (graph , geometry) —&gt;  graphResult:adds a node in a graph.Examples:graph var0 &lt;- graph add_node node(0) ; \t// var0 equals the graph with node(0)See also:add_edge, graph,add_pointPossible use:  geometry add_point point —&gt;  geometry  add_point (geometry , point) —&gt;  geometryResult:A new geometry resulting from the addition of the right point (coordinate) to the left-hand geometry. Note that adding a point to a line or polyline will always return a closed contour. Also note that the position at which the added point will appear in the geometry is not necessarily the last one, as points are always ordered in a clockwise fashion in geometriesExamples:geometry var0 &lt;- polygon([{10,10},{10,20},{20,20}]) add_point {20,10}; \t// var0 equals polygon([{10,10},{10,20},{20,20},{20,10}])add_secondsSame signification as +add_weeksSame signification as plus_weeksadd_yearsSame signification as plus_yearsadjacencyPossible use:  adjacency (graph) —&gt;  matrix&lt;float&gt;Result:adjacency matrix of the given graph.afterPossible use:  after (date) —&gt;  bool  any expression after date —&gt;  bool  after (any expression , date) —&gt;  boolResult:Returns true if the current_date of the model is strictly after the date passed in argument. Synonym of ‘current_date &gt; argument’. Can be used in its composed form with 2 arguments to express the lower boundary for the computation of a frequency. Note that only dates strictly after this one will be tested against the frequencyExamples:reflex when: after(starting_date) {} -: will always be run after the first stepreflex when: false after(starting date + #10days) {} -: will not be run after this date. Better to use 'until' or 'before' in that caseevery(2#days) after (starting_date + 1#day) // the computation will return true every two days (using the starting_date of the model as the starting point) only for the dates strictly after this starting_date + 1#dayagentPossible use:  agent (any) —&gt;  agentResult:Casts the operand into the type agentagent_closest_toPossible use:  agent_closest_to (unknown) —&gt;  agentResult:An agent, the closest to the operand (casted as a geometry).Comment:the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.Examples:agent var0 &lt;- agent_closest_to(self); \t// var0 equals the closest agent to the agent applying the operator.See also:neighbors_at, neighbors_of, agents_inside, agents_overlapping, closest_to, inside, overlapping,agent_farthest_toPossible use:  agent_farthest_to (unknown) —&gt;  agentResult:An agent, the farthest to the operand (casted as a geometry).Comment:the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.Examples:agent var0 &lt;- agent_farthest_to(self); \t// var0 equals the farthest agent to the agent applying the operator.See also:neighbors_at, neighbors_of, agents_inside, agents_overlapping, closest_to, inside, overlapping, agent_closest_to, farthest_to,agent_from_geometryPossible use:  path agent_from_geometry geometry —&gt;  agent  agent_from_geometry (path , geometry) —&gt;  agentResult:returns the agent corresponding to given geometry (right-hand operand) in the given path (left-hand operand).Special cases:  if the left-hand operand is nil, returns nilExamples:geometry line &lt;- one_of(path_followed.segments);road ag &lt;- road(path_followed agent_from_geometry line);See also:path,agents_at_distancePossible use:  agents_at_distance (float) —&gt;  containerResult:A list of agents situated at a distance lower than the right argument.Examples:container var0 &lt;- agents_at_distance(20); \t// var0 equals all the agents (excluding the caller) which distance to the caller is lower than 20See also:neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, overlapping, at_distance,agents_insidePossible use:  agents_inside (unknown) —&gt;  list&lt;agent&gt;Result:A list of agents covered by the operand (casted as a geometry).Examples:list&lt;agent&gt; var0 &lt;- agents_inside(self); \t// var0 equals the agents that are covered by the shape of the agent applying the operator.See also:agent_closest_to, agents_overlapping, closest_to, inside, overlapping,agents_overlappingPossible use:  agents_overlapping (unknown) —&gt;  list&lt;agent&gt;Result:A list of agents overlapping the operand (casted as a geometry).Examples:list&lt;agent&gt; var0 &lt;- agents_overlapping(self); \t// var0 equals the agents that overlap the shape of the agent applying the operator.See also:neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, overlapping, at_distance,all_pairs_shortest_pathPossible use:  all_pairs_shortest_path (graph) —&gt;  matrix&lt;int&gt;Result:returns the successor matrix of shortest paths between all node pairs (rows: source, columns: target): a cell (i,j) will thus contains the next node in the shortest path between i and j.Examples:matrix&lt;int&gt; var0 &lt;- all_pairs_shortest_paths(my_graph); \t// var0 equals shortest_paths_matrix will contain all pairs of shortest pathsalpha_indexPossible use:  alpha_index (graph) —&gt;  floatResult:returns the alpha index of the graph (measure of connectivity which evaluates the number of cycles in a graph in comparison with the maximum number of cycles. The higher the alpha index, the more a network is connected: alpha = nb_cycles / (2*S-5) - planar graph)Examples:float var1 &lt;- alpha_index(graphEpidemio); \t// var1 equals the alpha index of the graphSee also:beta_index, gamma_index, nb_cycles, connectivity_index,amongPossible use:  int among container —&gt;  container  among (int , container) —&gt;  containerResult:Returns a list of length the value of the left-hand operand, containing random elements from the right-hand operand. As of GAMA 1.6, the order in which the elements are returned can be different than the order in which they appear in the right-hand containerSpecial cases:  if the right-hand operand is empty, among returns a new empty list. If it is nil, it throws an error.  if the left-hand operand is greater than the length of the right-hand operand, among returns the right-hand operand (converted as a list). If it is smaller or equal to zero, it returns an empty listExamples:list&lt;int&gt; var0 &lt;- 3 among [1,2,4,3,5,7,6,8]; \t// var0 equals [1,2,8] (for example)container var1 &lt;- 3 among g2; \t// var1 equals [node6,node11,node7]container var2 &lt;- 3 among list(node); \t// var2 equals [node1,node11,node4]list&lt;int&gt; var3 &lt;- 1 among [1::2,3::4]; \t// var3 equals 2 or 4andPossible use:  bool and any expression —&gt;  bool  and (bool , any expression) —&gt;  boolResult:a bool value, equal to the logical and between the left-hand operand and the right-hand operand.Comment:both operands are always casted to bool before applying the operator. Thus, an expression like (1 and 0) is accepted and returns false.See also:bool, or, !,andPossible use:  predicate and predicate —&gt;  predicate  and (predicate , predicate) —&gt;  predicateResult:create a new predicate from two others by including them as subintentionsExamples:predicate1 and predicate2angle_betweenPossible use:  angle_between (point, point, point) —&gt;  intResult:the angle between vectors P0P1 and P0P2 (P0, P1, P2 being the three point operands)Examples:int var0 &lt;- angle_between({5,5},{10,5},{5,10}); \t// var0 equals 90anySame signification as one_ofany_location_inPossible use:  any_location_in (geometry) —&gt;  pointResult:A point inside (or touching) the operand-geometry.Examples:point var0 &lt;- any_location_in(square(5)); \t// var0 equals a point in the square, for example : {3,4.6}.See also:closest_points_with, farthest_point_to, points_at,any_point_inSame signification as any_location_inappend_horizontallyPossible use:  matrix append_horizontally matrix —&gt;  matrix  append_horizontally (matrix , matrix) —&gt;  matrix  matrix append_horizontally matrix —&gt;  matrix  append_horizontally (matrix , matrix) —&gt;  matrixResult:A matrix resulting from the concatenation of the rows of the two given matrices. If not both numerical or both object matrices, returns the first matrix.Examples:matrix var0 &lt;- matrix([[1.0,2.0],[3.0,4.0]]) append_horizontally matrix([[1,2],[3,4]]); \t// var0 equals matrix([[1.0,2.0],[3.0,4.0],[1.0,2.0],[3.0,4.0]])append_verticallyPossible use:  matrix append_vertically matrix —&gt;  matrix  append_vertically (matrix , matrix) —&gt;  matrix  matrix append_vertically matrix —&gt;  matrix  append_vertically (matrix , matrix) —&gt;  matrixResult:A matrix resulting from the concatenation of the columns  of the two given matrices. If not both numerical or both object matrices, returns the first matrix.Examples:matrix var0 &lt;- matrix([[1,2],[3,4]]) append_vertically matrix([[1,2],[3,4]]); \t// var0 equals matrix([[1,2,1,2],[3,4,3,4]])arcPossible use:  arc (float, float, float) —&gt;  geometry  arc (float, float, float, bool) —&gt;  geometryResult:An arc, which radius is equal to the first operand, heading to the second and amplitude the thirdAn arc, which radius is equal to the first operand, heading to the second, amplitude to the third and a boolean indicating whether to return a linestring or a polygon to the fourthComment:the center of the arc is by default the location of the current agent in which has been called this operator. This operator returns a polygon by default.the center of the arc is by default the location of the current agent in which has been called this operator.Special cases:  returns a point if the radius operand is lower or equal to 0.  returns a point if the radius operand is lower or equal to 0.Examples:geometry var0 &lt;- arc(4,45,90); \t// var0 equals a geometry as an arc of radius 4, in a direction of 45Â° and an amplitude of 90Â°geometry var1 &lt;- arc(4,45,90, false); \t// var1 equals a geometry as an arc of radius 4, in a direction of 45Â° and an amplitude of 90Â°, which only contains the points on the arcSee also:around, cone, line, link, norm, point, polygon, polyline, super_ellipse, rectangle, square, circle, ellipse, triangle,aroundPossible use:  float around unknown —&gt;  geometry  around (float , unknown) —&gt;  geometryResult:A geometry resulting from the difference between a buffer around the right-operand casted in geometry at a distance left-operand (right-operand buffer left-operand) and the right-operand casted as geometry.Special cases:  returns a circle geometry of radius right-operand if the left-operand is nilExamples:geometry var0 &lt;- 10 around circle(5); \t// var0 equals the ring geometry between 5 and 10.See also:circle, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,asPossible use:  unknown as any expression —&gt;  unknown  as (unknown , any expression) —&gt;  unknownResult:casting of the first argument into a given typeComment:It is equivalent to the application of the type operator on the left operand.Examples:int var0 &lt;- 3.5 as int; \t// var0 equals int(3.5)as_4_gridPossible use:  geometry as_4_grid point —&gt;  matrix  as_4_grid (geometry , point) —&gt;  matrixResult:A matrix of square geometries (grid with 4-neighborhood) with dimension given by the right-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)Examples:matrix var0 &lt;- self as_4_grid {10, 5}; \t// var0 equals the matrix of square geometries (grid with 4-neighborhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.See also:as_grid, as_hexagonal_grid,as_distance_graphPossible use:  container as_distance_graph map —&gt;  graph  as_distance_graph (container , map) —&gt;  graph  container as_distance_graph float —&gt;  graph  as_distance_graph (container , float) —&gt;  graph  as_distance_graph (container, float, species) —&gt;  graphResult:creates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices close enough (less than a distance, right-hand operand).Comment:as_distance_graph is more efficient for a list of points than as_intersection_graph.Examples:list(ant) as_distance_graph 3.0See also:as_intersection_graph, as_edge_graph,as_driving_graphPossible use:  container as_driving_graph container —&gt;  graph  as_driving_graph (container , container) —&gt;  graphResult:creates a graph from the list/map of edges given as operand and connect the node to the edgeExamples:as_driving_graph(road,node)  --:  build a graph while using the road agents as edges and the node agents as nodesSee also:as_intersection_graph, as_distance_graph, as_edge_graph,as_edge_graphPossible use:  as_edge_graph (map) —&gt;  graph  as_edge_graph (container) —&gt;  graph  container as_edge_graph float —&gt;  graph  as_edge_graph (container , float) —&gt;  graphResult:creates a graph from the list/map of edges given as operandSpecial cases:  if the operand is a map, the graph will be built by creating edges from pairs of the mapgraph var0 &lt;- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); \t// var0 equals a graph with these three vertices and two edges  if the operand is a list and a tolerance (max distance in meters to consider that 2 points are the same node) is given, the graph will be built with elements of the list as edges and two edges will be connected by a node if the distance between their extremity (first or last points) are at distance lower or equal to the tolerancegraph var1 &lt;- as_edge_graph([line([{1,5},{12,45}]),line([{13,45},{34,56}])],1);; \t// var1 equals a graph with two edges and three vertices  if the operand is a list, the graph will be built with elements of the list as edgesgraph var2 &lt;- as_edge_graph([line([{1,5},{12,45}]),line([{12,45},{34,56}])]); \t// var2 equals a graph with two edges and three verticesSee also:as_intersection_graph, as_distance_graph,as_gridPossible use:  geometry as_grid point —&gt;  matrix  as_grid (geometry , point) —&gt;  matrixResult:A matrix of square geometries (grid with 8-neighborhood) with dimension given by the right-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)Examples:matrix var0 &lt;- self as_grid {10, 5}; \t// var0 equals a matrix of square geometries (grid with 8-neighborhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.See also:as_4_grid, as_hexagonal_grid,as_hexagonal_gridPossible use:  geometry as_hexagonal_grid point —&gt;  list&lt;geometry&gt;  as_hexagonal_grid (geometry , point) —&gt;  list&lt;geometry&gt;Result:A list of geometries (hexagonal) corresponding to the hexagonal tesselation of the first operand geometryExamples:list&lt;geometry&gt; var0 &lt;- self as_hexagonal_grid {10, 5}; \t// var0 equals list of geometries (hexagonal) corresponding to the hexagonal tesselation of the first operand geometrySee also:as_4_grid, as_grid,as_intPossible use:  string as_int int —&gt;  int  as_int (string , int) —&gt;  intResult:parses the string argument as a signed integer in the radix specified by the second argument.Special cases:  if the left operand is nil or empty, as_int returns 0  if the left operand does not represent an integer in the specified radix, as_int throws an exceptionExamples:int var0 &lt;- '20' as_int 10; \t// var0 equals 20int var1 &lt;- '20' as_int 8; \t// var1 equals 16int var2 &lt;- '20' as_int 16; \t// var2 equals 32int var3 &lt;- '1F' as_int 16; \t// var3 equals 31int var4 &lt;- 'hello' as_int 32; \t// var4 equals 18306744See also:int,as_intersection_graphPossible use:  container as_intersection_graph float —&gt;  graph  as_intersection_graph (container , float) —&gt;  graphResult:creates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices with an intersection (with a given tolerance).Comment:as_intersection_graph is more efficient for a list of geometries (but less accurate) than as_distance_graph.Examples:list(ant) as_intersection_graph 0.5See also:as_distance_graph, as_edge_graph,as_mapPossible use:  container as_map any expression —&gt;  map  as_map (container , any expression) —&gt;  mapResult:produces a new map from the evaluation of the right-hand operand for each element of the left-hand operandComment:the right-hand operand should be a pairSpecial cases:  if the left-hand operand is nil, as_map throws an error.Examples:map&lt;int,int&gt; var0 &lt;- [1,2,3,4,5,6,7,8] as_map (each::(each * 2)); \t// var0 equals [1::2, 2::4, 3::6, 4::8, 5::10, 6::12, 7::14, 8::16]map&lt;int,int&gt; var1 &lt;- [1::2,3::4,5::6] as_map (each::(each * 2)); \t// var1 equals [2::4, 4::8, 6::12] as_matrixPossible use:  unknown as_matrix point —&gt;  matrix  as_matrix (unknown , point) —&gt;  matrixResult:casts the left operand into a matrix with right operand as preferred sizeComment:This operator is very useful to cast a file containing raster data into a matrix.Note that both components of the right operand point should be positive, otherwise an exception is raised.The operator as_matrix creates a matrix of preferred size. It fills in it with elements of the left operand until the matrix is full If the size is to short, some elements will be omitted. Matrix remaining elements will be filled in by nil.Special cases:  if the right operand is nil, as_matrix is equivalent to the matrix operatorSee also:matrix,as_pathPossible use:  list&lt;geometry&gt; as_path graph —&gt;  path  as_path (list&lt;geometry&gt; , graph) —&gt;  pathResult:create a graph path from the list of shapeExamples:path var0 &lt;- [road1,road2,road3] as_path my_graph; \t// var0 equals a path road1-&gt;road2-&gt;road3 of my_graphasinPossible use:  asin (float) —&gt;  float  asin (int) —&gt;  floatResult:the arcsin of the operandSpecial cases:  if the right-hand operand is outside of the [-1,1] interval, returns NaNExamples:float var0 &lt;- asin (0); \t// var0 equals 0.0float var1 &lt;- asin (90); \t// var1 equals #nanSee also:acos, atan, sin,atPossible use:  string at int —&gt;  string  at (string , int) —&gt;  string  container&lt;KeyType,ValueType&gt; at KeyType —&gt;  ValueType  at (container&lt;KeyType,ValueType&gt; , KeyType) —&gt;  ValueTypeResult:the element at the right operand index of the containerComment:The first element of the container is located at the index 0. In addition, if the user tries to get the element at an index higher or equals than the length of the container, he will get an IndexOutOfBoundException.The at operator behavior depends on the nature of the operandSpecial cases:  if it is a file, at returns the element of the file content at the index specified by the right operand  if it is a population, at returns the agent at the index specified by the right operand  if it is a graph and if the right operand is a node, at returns the in and out edges corresponding to that node  if it is a graph and if the right operand is an edge, at returns the pair node_out::node_in of the edge  if it is a graph and if the right operand is a pair node1::node2, at returns the edge from node1 to node2 in the graph  if it is a list or a matrix, at returns the element at the index specified by the right operandint var1 &lt;- [1, 2, 3] at 2; \t// var1 equals 3point var2 &lt;- [{1,2}, {3,4}, {5,6}] at 0; \t// var2 equals {1.0,2.0}Examples:string var0 &lt;- 'abcdef' at 0; \t// var0 equals 'a'See also:contains_all, contains_any,at_distancePossible use:  container&lt;agent&gt; at_distance float —&gt;  list&lt;geometry&gt;  at_distance (container&lt;agent&gt; , float) —&gt;  list&lt;geometry&gt;Result:A list of agents or geometries among the left-operand list that are located at a distance &lt;= the right operand from the caller agent (in its topology)Examples:list&lt;geometry&gt; var0 &lt;- [ag1, ag2, ag3] at_distance 20; \t// var0 equals the agents of the list located at a distance &lt;= 20 from the caller agent (in the same order).See also:neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, overlapping,at_locationPossible use:  geometry at_location point —&gt;  geometry  at_location (geometry , point) —&gt;  geometryResult:A geometry resulting from the tran of a translation to the right-hand operand point of the left-hand operand (geometry, agent, point)Examples:geometry var0 &lt;- self at_location {10, 20}; \t// var0 equals the geometry resulting from a translation to the location {10, 20} of the left-hand geometry (or agent).atanPossible use:  atan (float) —&gt;  float  atan (int) —&gt;  floatResult:Returns the value (in the interval [-90,90], in decimal degrees) of the arctan of the operand (which can be any real number).Examples:float var0 &lt;- atan (1); \t// var0 equals 45.0See also:acos, asin, tan,atan2Possible use:  float atan2 float —&gt;  float  atan2 (float , float) —&gt;  floatResult:the atan2 value of the two operands.Comment:The function atan2 is the arctangent function with two arguments. The purpose of using two arguments instead of one is to gather information on the signs of the inputs in order to return the appropriate quadrant of the computed angle, which is not possible for the single-argument arctangent function.Examples:float var0 &lt;- atan2 (0,0); \t// var0 equals 0.0See also:atan, acos, asin,attributesPossible use:  attributes (any) —&gt;  attributesResult:Casts the operand into the type attributesBDIPlanPossible use:  BDIPlan (any) —&gt;  BDIPlanResult:Casts the operand into the type BDIPlanbeforePossible use:  before (date) —&gt;  bool  any expression before date —&gt;  bool  before (any expression , date) —&gt;  boolResult:Returns true if the current_date of the model is strictly before the date passed in argument. Synonym of ‘current_date &lt; argument’Examples:reflex when: before(starting_date) {} -: will never be runbeta_indexPossible use:  beta_index (graph) —&gt;  floatResult:returns the beta index of the graph (Measures the level of connectivity in a graph and is expressed by the relationship between the number of links (e) over the number of nodes (v) : beta = e/v.Examples:graph graphEpidemio &lt;- graph([]);float var1 &lt;- beta_index(graphEpidemio); \t// var1 equals the beta index of the graphSee also:alpha_index, gamma_index, nb_cycles, connectivity_index,betweenPossible use:  date between date —&gt;  bool  between (date , date) —&gt;  bool  between (int, int, int) —&gt;  bool  between (any expression, date, date) —&gt;  bool  between (float, float, float) —&gt;  bool  between (date, date, date) —&gt;  boolResult:returns true the first integer operand is bigger than the second integer operand and smaller than the third integer operandreturns true if the first float operand is bigger than the second float operand and smaller than the third float operandSpecial cases:  returns true if the first operand is between the two dates passed in arguments (both exclusive). Can be combined with ‘every’ to express a frequency between two dates(date('2016-01-01') between(date('2000-01-01'), date('2020-02-02') -: trueevery #day between(date('2000-01-01'), date('2020-02-02') // will return true every new day between these two dates, taking the first one as the starting point  returns true if the first operand is between the two dates passed in arguments (both exclusive). The version with 2 arguments compares the current_date with the 2 others(date('2016-01-01') between(date('2000-01-01'), date('2020-02-02') -: truebetween(date('2000-01-01'), date('2020-02-02') // will return true if the current_date of the model is in_between the 2Examples:bool var0 &lt;- between(5, 1, 10); \t// var0 equals truebool var1 &lt;- between(5.0, 1.0, 10.0); \t// var1 equals truebetweenness_centralityPossible use:  betweenness_centrality (graph) —&gt;  mapResult:returns a map containing for each vertex (key), its betweenness centrality (value): number of shortest paths passing through each vertexExamples:graph graphEpidemio &lt;- graph([]);map var1 &lt;- betweenness_centrality(graphEpidemio); \t// var1 equals the betweenness centrality index of the graphbiggest_cliques_ofPossible use:  biggest_cliques_of (graph) —&gt;  list&lt;list&gt;Result:returns the biggest cliques of a graph using the Bron-Kerbosch clique detection algorithmExamples:graph my_graph &lt;- graph([]);list&lt;list&gt; var1 &lt;- biggest_cliques_of (my_graph); \t// var1 equals the list of the biggest cliques as listSee also:maximal_cliques_of,binomialPossible use:  int binomial float —&gt;  int  binomial (int , float) —&gt;  intResult:A value from a random variable following a binomial distribution. The operands represent the number of experiments n and the success probability p.Comment:The binomial distribution is the discrete probability distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields success with probability p, cf. Binomial distribution on Wikipedia.Examples:int var0 &lt;- binomial(15,0.6); \t// var0 equals a random positive integerSee also:poisson, gauss,blendPossible use:  rgb blend rgb —&gt;  rgb  blend (rgb , rgb) —&gt;  rgb  blend (rgb, rgb, float) —&gt;  rgbResult:Blend two colors with an optional ratio (c1 * r + c2 * (1 - r)) between 0 and 1Special cases:  If the ratio is omitted, an even blend is donergb var3 &lt;- blend(#red, #blue); \t// var3 equals to a color very close to the purpleExamples:rgb var1 &lt;- blend(#red, #blue, 0.3); \t// var1 equals to a color between the purple and the blueSee also:rgb, hsb,boolPossible use:  bool (any) —&gt;  boolResult:Casts the operand into the type boolboxPossible use:  box (point) —&gt;  geometry  box (float, float, float) —&gt;  geometryResult:A box geometry which side sizes are given by the operands.Comment:the center of the box is by default the location of the current agent in which has been called this operator.the center of the box is by default the location of the current agent in which has been called this operator.Special cases:  returns nil if the operand is nil.  returns nil if the operand is nil.Examples:geometry var0 &lt;- box(10, 5 , 5); \t// var0 equals a geometry as a rectangle with width = 10, height = 5 depth= 5.geometry var1 &lt;- box({10, 5 , 5}); \t// var1 equals a geometry as a rectangle with width = 10, height = 5 depth= 5.See also:around, circle, sphere, cone, line, link, norm, point, polygon, polyline, square, cube, triangle,brewer_colorsPossible use:  brewer_colors (string) —&gt;  list&lt;rgb&gt;  string brewer_colors int —&gt;  list&lt;rgb&gt;  brewer_colors (string , int) —&gt;  list&lt;rgb&gt;Result:Build a list of colors of a given type (see website http://colorbrewer2.org/)Build a list of colors of a given type (see website http://colorbrewer2.org/) with a given number of classesExamples:list&lt;rgb&gt; var0 &lt;- list&lt;rgb&gt; colors &lt;- brewer_colors(\"OrRd\");; \t// var0 equals a list of 6 blue colorslist&lt;rgb&gt; var1 &lt;- list&lt;rgb&gt; colors &lt;- brewer_colors(\"Pastel1\", 10);; \t// var1 equals a list of 10 sequential colorsSee also:brewer_palettes,brewer_palettesPossible use:  brewer_palettes (int) —&gt;  list&lt;string&gt;  int brewer_palettes int —&gt;  list&lt;string&gt;  brewer_palettes (int , int) —&gt;  list&lt;string&gt;Result:returns the list a palette with a given min number of classes and max number of classes)returns the list a palette with a given min number of classes and max number of classes)Examples:list&lt;string&gt; var0 &lt;- list&lt;rgb&gt; colors &lt;- brewer_palettes(5,10);; \t// var0 equals a list of palettes that are composed of a min of 5 colors and a max of 10 colorslist&lt;string&gt; var1 &lt;- list&lt;rgb&gt; colors &lt;- brewer_palettes();; \t// var1 equals a list of palettes that are composed of a min of 5 colorsSee also:brewer_colors,bufferSame signification as +buildPossible use:  build (matrix&lt;float&gt;) —&gt;  regression  matrix&lt;float&gt; build string —&gt;  regression  build (matrix&lt;float&gt; , string) —&gt;  regressionResult:returns the regression build from the matrix data (a row = an instance, the last value of each line is the y value) while using the given ordinary least squares method. Usage: build(data)returns the regression build from the matrix data (a row = an instance, the last value of each line is the y value) while using the given method (“GLS” or “OLS”). Usage: build(data,method)Examples:matrix([[1,2,3,4],[2,3,4,2]])build(matrix([[1,2,3,4],[2,3,4,2]]),\"GLS\")ceilPossible use:  ceil (float) —&gt;  floatResult:Maps the operand to the smallest following integer, i.e. the smallest integer not less than x.Examples:float var0 &lt;- ceil(3); \t// var0 equals 3.0float var1 &lt;- ceil(3.5); \t// var1 equals 4.0float var2 &lt;- ceil(-4.7); \t// var2 equals -4.0See also:floor, round,centroidPossible use:  centroid (geometry) —&gt;  pointResult:Centroid (weighted sum of the centroids of a decomposition of the area into triangles) of the operand-geometry. Can be different to the location of the geometryExamples:point var0 &lt;- centroid(world); \t// var0 equals the centroid of the square, for example : {50.0,50.0}.See also:any_location_in, closest_points_with, farthest_point_to, points_at,charPossible use:  char (int) —&gt;  stringSpecial cases:  converts ACSII integer value to characterstring var0 &lt;- char (34); \t// var0 equals '\"'circlePossible use:  circle (float) —&gt;  geometry  float circle point —&gt;  geometry  circle (float , point) —&gt;  geometryResult:A circle geometry which radius is equal to the first operand, and the center has the location equal to the second operand.A circle geometry which radius is equal to the operand.Comment:the center of the circle is by default the location of the current agent in which has been called this operator.Special cases:  returns a point if the operand is lower or equal to 0.  returns a point if the operand is lower or equal to 0.Examples:geometry var0 &lt;- circle(10,{80,30}); \t// var0 equals a geometry as a circle of radius 10, the center will be in the location {80,30}.geometry var1 &lt;- circle(10); \t// var1 equals a geometry as a circle of radius 10.See also:around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,cleanPossible use:  clean (geometry) —&gt;  geometryResult:A geometry corresponding to the cleaning of the operand (geometry, agent, point)Comment:The cleaning corresponds to a buffer with a distance of 0.0Examples:geometry var0 &lt;- clean(self); \t// var0 equals returns the geometry resulting from the cleaning of the geometry of the agent applying the operator.closest_points_withPossible use:  geometry closest_points_with geometry —&gt;  list&lt;point&gt;  closest_points_with (geometry , geometry) —&gt;  list&lt;point&gt;Result:A list of two closest points between the two geometries.Examples:list&lt;point&gt; var0 &lt;- geom1 closest_points_with(geom2); \t// var0 equals [pt1, pt2] with pt1 the closest point of geom1 to geom2 and pt1 the closest point of geom2 to geom1See also:any_location_in, any_point_in, farthest_point_to, points_at,closest_toPossible use:  container&lt;agent&gt; closest_to geometry —&gt;  geometry  closest_to (container&lt;agent&gt; , geometry) —&gt;  geometryResult:An agent or a geometry among the left-operand list of agents, species or meta-population (addition of species), the closest to the operand (casted as a geometry).Comment:the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.Examples:geometry var0 &lt;- [ag1, ag2, ag3] closest_to(self); \t// var0 equals return the closest agent among ag1, ag2 and ag3 to the agent applying the operator.(species1 + species2) closest_to selfSee also:neighbors_at, neighbors_of, inside, overlapping, agents_overlapping, agents_inside, agent_closest_to,collectPossible use:  container collect any expression —&gt;  container  collect (container , any expression) —&gt;  containerResult:returns a new list, in which each element is the evaluation of the right-hand operand.Comment:collect is similar to accumulate except that accumulate always produces flat lists if the right-hand operand returns a list.In addition, collect can be applied to any container.Special cases:  if the left-hand operand is nil, collect throws an errorExamples:container var0 &lt;- [1,2,4] collect (each *2); \t// var0 equals [2,4,8]container var1 &lt;- [1,2,4] collect ([2,4]); \t// var1 equals [[2,4],[2,4],[2,4]]container var2 &lt;- [1::2, 3::4, 5::6] collect (each + 2); \t// var2 equals [4,6,8]container var3 &lt;- (list(node) collect (node(each).location.x * 2); \t// var3 equals the list of nodes with their x multiplied by 2See also:accumulate,column_atPossible use:  matrix column_at int —&gt;  list  column_at (matrix , int) —&gt;  listResult:returns the column at a num_col (right-hand operand)Examples:list var0 &lt;- matrix([[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]]) column_at 2; \t// var0 equals [\"el31\",\"el32\",\"el33\"]See also:row_at, rows_list,columns_listPossible use:  columns_list (matrix) —&gt;  list&lt;list&gt;Result:returns a list of the columns of the matrix, with each column as a list of elementsExamples:list&lt;list&gt; var0 &lt;- columns_list(matrix([[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]])); \t// var0 equals [[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]]See also:rows_list,commandPossible use:  command (string) —&gt;  stringResult:command allows GAMA to issue a system command using the system terminal or shell and to receive a string containing the outcome of the command or script executed. By default, commands are blocking the agent calling them, unless the sequence ‘ &amp;’ is used at the end. In this case, the result of the operator is an empty stringconePossible use:  cone (point) —&gt;  geometry  int cone int —&gt;  geometry  cone (int , int) —&gt;  geometryResult:A cone geometry which min and max angles are given by the operands.A cone geometry which min and max angles are given by the operands.Comment:the center of the cone is by default the location of the current agent in which has been called this operator.the center of the cone is by default the location of the current agent in which has been called this operator.Special cases:  returns nil if the operand is nil.  returns nil if the operand is nil.Examples:geometry var0 &lt;- cone({0, 45}); \t// var0 equals a geometry as a cone with min angle is 0 and max angle is 45.geometry var1 &lt;- cone(0, 45); \t// var1 equals a geometry as a cone with min angle is 0 and max angle is 45.See also:around, circle, line, link, norm, point, polygon, polyline, rectangle, square, triangle,cone3DPossible use:  float cone3D float —&gt;  geometry  cone3D (float , float) —&gt;  geometryResult:A cone geometry which base radius size is equal to the first operand, and which the height is equal to the second operand.Comment:the center of the cone is by default the location of the current agent in which has been called this operator.Special cases:  returns a point if the operand is lower or equal to 0.Examples:geometry var0 &lt;- cone3D(10.0,5.0); \t// var0 equals a geometry as a cone with a base circle of radius 10 and a height of 5.See also:around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,connected_components_ofPossible use:  connected_components_of (graph) —&gt;  list&lt;list&gt;Result:returns the connected components of of a graph, i.e. the list of all vertices that are in the maximally connected component together with the specified vertex.Examples:graph my_graph &lt;- graph([]);list&lt;list&gt; var1 &lt;- connected_components_of (my_graph); \t// var1 equals the list of all the components as listSee also:alpha_index, connectivity_index, nb_cycles,connectivity_indexPossible use:  connectivity_index (graph) —&gt;  floatResult:returns a simple connectivity index. This number is estimated through the number of nodes (v) and of sub-graphs (p) : IC = (v - p) /(v - 1).Examples:graph graphEpidemio &lt;- graph([]);float var1 &lt;- connectivity_index(graphEpidemio); \t// var1 equals the connectivity index of the graphSee also:alpha_index, beta_index, gamma_index, nb_cycles,containerPossible use:  container (any) —&gt;  containerResult:Casts the operand into the type containercontainsPossible use:  container&lt;KeyType,ValueType&gt; contains unknown —&gt;  bool  contains (container&lt;KeyType,ValueType&gt; , unknown) —&gt;  bool  string contains string —&gt;  bool  contains (string , string) —&gt;  boolResult:true, if the container contains the right operand, false otherwiseComment:the contains operator behavior depends on the nature of the operandSpecial cases:  if it is a map, contains returns true if the operand is a key of the map  if it is a file, contains returns true it the operand is contained in the file content  if it is a population, contains returns true if the operand is an agent of the population, false otherwise  if it is a graph, contains returns true if the operand is a node or an edge of the graph, false otherwise  if both operands are strings, returns true if the right-hand operand contains the right-hand pattern;  if it is a list or a matrix, contains returns true if the list or matrix contains the right operandbool var0 &lt;- [1, 2, 3] contains 2; \t// var0 equals truebool var1 &lt;- [{1,2}, {3,4}, {5,6}] contains {3,4}; \t// var1 equals trueExamples:bool var2 &lt;- 'abcded' contains 'bc'; \t// var2 equals trueSee also:contains_all, contains_any,contains_allPossible use:  container contains_all container —&gt;  bool  contains_all (container , container) —&gt;  bool  string contains_all list —&gt;  bool  contains_all (string , list) —&gt;  boolResult:true if the left operand contains all the elements of the right operand, false otherwiseComment:the definition of contains depends on the containerSpecial cases:  if the right operand is nil or empty, contains_all returns true  if the left-operand is a string, test whether the string contains all the element of the list;bool var4 &lt;- \"abcabcabc\" contains_all [\"ca\",\"xy\"]; \t// var4 equals falseExamples:bool var0 &lt;- [1,2,3,4,5,6] contains_all [2,4]; \t// var0 equals true bool var1 &lt;- [1,2,3,4,5,6] contains_all [2,8]; \t// var1 equals falsebool var2 &lt;- [1::2, 3::4, 5::6] contains_all [1,3]; \t// var2 equals false bool var3 &lt;- [1::2, 3::4, 5::6] contains_all [2,4]; \t// var3 equals trueSee also:contains, contains_any,contains_anyPossible use:  container contains_any container —&gt;  bool  contains_any (container , container) —&gt;  bool  string contains_any list —&gt;  bool  contains_any (string , list) —&gt;  boolResult:true if the left operand contains one of the elements of the right operand, false otherwiseComment:the definition of contains depends on the containerSpecial cases:  if the right operand is nil or empty, contains_any returns falseExamples:bool var0 &lt;- [1,2,3,4,5,6] contains_any [2,4]; \t// var0 equals true bool var1 &lt;- [1,2,3,4,5,6] contains_any [2,8]; \t// var1 equals truebool var2 &lt;- [1::2, 3::4, 5::6] contains_any [1,3]; \t// var2 equals falsebool var3 &lt;- [1::2, 3::4, 5::6] contains_any [2,4]; \t// var3 equals truebool var4 &lt;- \"abcabcabc\" contains_any [\"ca\",\"xy\"]; \t// var4 equals trueSee also:contains, contains_all,contains_edgePossible use:  graph contains_edge unknown —&gt;  bool  contains_edge (graph , unknown) —&gt;  bool  graph contains_edge pair —&gt;  bool  contains_edge (graph , pair) —&gt;  boolResult:returns true if the graph(left-hand operand) contains the given edge (righ-hand operand), false otherwiseSpecial cases:  if the left-hand operand is nil, returns false  if the right-hand operand is a pair, returns true if it exists an edge between the two elements of the pair in the graphbool var2 &lt;- graphEpidemio contains_edge (node(0)::node(3)); \t// var2 equals trueExamples:graph graphFromMap &lt;-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);bool var1 &lt;- graphFromMap contains_edge link({1,5}::{12,45}); \t// var1 equals trueSee also:contains_vertex,contains_vertexPossible use:  graph contains_vertex unknown —&gt;  bool  contains_vertex (graph , unknown) —&gt;  boolResult:returns true if the graph(left-hand operand) contains the given vertex (righ-hand operand), false otherwiseSpecial cases:  if the left-hand operand is nil, returns falseExamples:graph graphFromMap&lt;-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);bool var1 &lt;- graphFromMap contains_vertex {1,5}; \t// var1 equals trueSee also:contains_edge,conversationPossible use:  conversation (unknown) —&gt;  conversationconvex_hullPossible use:  convex_hull (geometry) —&gt;  geometryResult:A geometry corresponding to the convex hull of the operand.Examples:geometry var0 &lt;- convex_hull(self); \t// var0 equals the convex hull of the geometry of the agent applying the operatorcopyPossible use:  copy (unknown) —&gt;  unknownResult:returns a copy of the operand.copy_betweenPossible use:  copy_between (string, int, int) —&gt;  string  copy_between (container, int, int) —&gt;  containerResult:Returns a copy of the first operand between the indexes determined by the second (inclusive) and third operands (exclusive)Special cases:  If the first operand is empty, returns an empty object of the same type  If the second operand is greater than or equal to the third operand, return an empty object of the same type  If the first operand is nil, raises an errorExamples:string var0 &lt;- copy_between(\"abcabcabc\", 2,6); \t// var0 equals \"cabc\"container var1 &lt;-  copy_between ([4, 1, 6, 9 ,7], 1, 3); \t// var1 equals [1, 6]corRPossible use:  container corR container —&gt;  unknown  corR (container , container) —&gt;  unknownResult:returns the Pearson correlation coefficient of two given vectors (right-hand operands) in given variable  (left-hand operand).Special cases:  if the lengths of two vectors in the right-hand aren’t equal, returns 0Examples:list X &lt;- [1, 2, 3];list Y &lt;- [1, 2, 4];unknown var2 &lt;- corR(X, Y); \t// var2 equals 0.981980506061966cosPossible use:  cos (int) —&gt;  float  cos (float) —&gt;  floatResult:Returns the value (in [-1,1]) of the cosinus of the operand (in decimal degrees).  The argument is casted to an int before being evaluated.Special cases:  Operand values out of the range [0-359] are normalized.Examples:float var0 &lt;- cos (0); \t// var0 equals 1.0float var1 &lt;- cos(360); \t// var1 equals 1.0float var2 &lt;- cos(-720); \t// var2 equals 1.0See also:sin, tan,cos_radPossible use:  cos_rad (float) —&gt;  floatResult:Returns the value (in [-1,1]) of the cosinus of the operand (in decimal degrees).  The argument is casted to an int before being evaluated.Special cases:  Operand values out of the range [0-359] are normalized.See also:sin, tan,countPossible use:  container count any expression —&gt;  int  count (container , any expression) —&gt;  intResult:returns an int, equal to the number of elements of the left-hand operand that make the right-hand operand evaluate to true.Comment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.Special cases:  if the left-hand operand is nil, count throws an errorExamples:int var0 &lt;- [1,2,3,4,5,6,7,8] count (each &gt; 3); \t// var0 equals 5// Number of nodes of graph g2 without any out edgegraph g2 &lt;- graph([]);int var3 &lt;- g2 count (length(g2 out_edges_of each) = 0  ) ; \t// var3 equals the total number of out edges// Number of agents node with x &gt; 32int n &lt;- (list(node) count (round(node(each).location.x) &gt; 32);int var6 &lt;- [1::2, 3::4, 5::6] count (each &gt; 4); \t// var6 equals 1See also:group_by,coversPossible use:  geometry covers geometry —&gt;  bool  covers (geometry , geometry) —&gt;  boolResult:A boolean, equal to true if the left-geometry (or agent/point) covers the right-geometry (or agent/point).Special cases:  if one of the operand is null, returns false.Examples:bool var0 &lt;- square(5) covers square(2); \t// var0 equals trueSee also:disjoint_from, crosses, overlaps, partially_overlaps, touches,crossPossible use:  cross (float) —&gt;  geometry  float cross float —&gt;  geometry  cross (float , float) —&gt;  geometryResult:A cross, which radius is equal to the first operandA cross, which radius is equal to the first operand and the width of the lines for the secondExamples:geometry var0 &lt;- cross(10); \t// var0 equals a geometry as a cross of radius 10geometry var1 &lt;- cross(10,2); \t// var1 equals a geometry as a cross of radius 10, and with a width of 2 for the lines See also:around, cone, line, link, norm, point, polygon, polyline, super_ellipse, rectangle, square, circle, ellipse, triangle,crossesPossible use:  geometry crosses geometry —&gt;  bool  crosses (geometry , geometry) —&gt;  boolResult:A boolean, equal to true if the left-geometry (or agent/point) crosses the right-geometry (or agent/point).Special cases:  if one of the operand is null, returns false.  if one operand is a point, returns false.Examples:bool var0 &lt;- polyline([{10,10},{20,20}]) crosses polyline([{10,20},{20,10}]); \t// var0 equals truebool var1 &lt;- polyline([{10,10},{20,20}]) crosses {15,15}; \t// var1 equals truebool var2 &lt;- polyline([{0,0},{25,25}]) crosses polygon([{10,10},{10,20},{20,20},{20,10}]); \t// var2 equals trueSee also:disjoint_from, intersects, overlaps, partially_overlaps, touches,crsPossible use:  crs (file) —&gt;  stringResult:the Coordinate Reference System (CRS) of the GIS fileExamples:string var0 &lt;- crs(my_shapefile); \t// var0 equals the crs of the shapefileCRS_transformPossible use:  CRS_transform (geometry) —&gt;  geometry  geometry CRS_transform string —&gt;  geometry  CRS_transform (geometry , string) —&gt;  geometrySpecial cases:  returns the geometry corresponding to the transformation of the given geometry by the left operand CRS (Coordinate Reference System)geometry var0 &lt;- shape CRS_transform(\"EPSG:4326\"); \t// var0 equals a geometry corresponding to the agent geometry transformed into the EPSG:4326 CRS  returns the geometry corresponding to the transformation of the given geometry by the current CRS (Coordinate Reference System), the one corresponding to the world’s agent onegeometry var1 &lt;- CRS_transform(shape); \t// var1 equals a geometry corresponding to the agent geometry transformed into the current CRScsv_filePossible use:  csv_file (string) —&gt;  fileResult:Constructs a file of type csv. Allowed extensions are limited to csv, tsvcubePossible use:  cube (float) —&gt;  geometryResult:A cube geometry which side size is equal to the operand.Comment:the center of the cube is by default the location of the current agent in which has been called this operator.Special cases:  returns nil if the operand is nil.Examples:geometry var0 &lt;- cube(10); \t// var0 equals a geometry as a square of side size 10.See also:around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, triangle,curvePossible use:  curve (point, point, point) —&gt;  geometry  curve (point, point, point, int) —&gt;  geometry  curve (point, point, point, point) —&gt;  geometry  curve (point, point, point, point, int) —&gt;  geometryResult:A quadratic Bezier curve geometry built from the three given points composed of a given numnber of points.A quadratic Bezier curve geometry built from the three given points composed of 10 points.A cubic Bezier curve geometry built from the four given points composed of a given number of points.A cubic Bezier curve geometry built from the four given points composed of 10 points.Special cases:  if the operand is nil, returns nil  if the last operand (number of points) is inferior to 2, returns nil  if the operand is nil, returns nil  if the operand is nil, returns nil  if the last operand (number of points) is inferior to 2, returns nil  if the operand is nil, returns nilExamples:geometry var0 &lt;- curve({0,0}, {0,10}, {10,10}, 20); \t// var0 equals a quadratic Bezier curve geometry composed of 20 points from p0 to p2.geometry var1 &lt;- curve({0,0}, {0,10}, {10,10}); \t// var1 equals a quadratic Bezier curve geometry composed of 10 points from p0 to p2.geometry var2 &lt;- curve({0,0}, {0,10}, {10,10}); \t// var2 equals a cubic Bezier curve geometry composed of 10 points from p0 to p3.geometry var3 &lt;- curve({0,0}, {0,10}, {10,10}); \t// var3 equals a cubic Bezier curve geometry composed of 10 points from p0 to p3.See also:around, circle, cone, link, norm, point, polygone, rectangle, square, triangle, line,cylinderPossible use:  float cylinder float —&gt;  geometry  cylinder (float , float) —&gt;  geometryResult:A cylinder geometry which radius is equal to the operand.Comment:the center of the cylinder is by default the location of the current agent in which has been called this operator.Special cases:  returns a point if the operand is lower or equal to 0.Examples:geometry var0 &lt;- cylinder(10,10); \t// var0 equals a geometry as a circle of radius 10.See also:around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,IDWPossible use:  IDW (container&lt;agent&gt;, map&lt;point,float&gt;, int) —&gt;  map&lt;agent,float&gt;Result:Inverse Distance Weighting (IDW) is a type of deterministic method for multivariate interpolation with a known scattered set of points. The assigned values to each geometry are calculated with a weighted average of the values available at the known points. See: http://en.wikipedia.org/wiki/Inverse_distance_weighting Usage: IDW (list of geometries, map of points (key: point, value: value), power parameter)Examples:map&lt;agent,float&gt; var0 &lt;- IDW([ag1, ag2, ag3, ag4, ag5],[{10,10}::25.0, {10,80}::10.0, {100,10}::15.0], 2); \t// var0 equals for example, can return [ag1::12.0, ag2::23.0,ag3::12.0,ag4::14.0,ag5::17.0]R_correlationSame signification as corRR_filePossible use:  R_file (string) —&gt;  fileResult:Constructs a file of type R. Allowed extensions are limited to rR_meanSame signification as meanRTGaussSame signification as truncated_gaussURL_filePossible use:  URL_file (string) —&gt;  fileResult:Constructs a file of type URL. Allowed extensions are limited to url",
        "url":"/wiki/OperatorsAC.html"
      }
      ,
    
      "wiki-operatorsdm-html": {
        "title": "Operators (D to M)",
        "content": "#Operators (D to M)This file is automatically generated from java files. Do Not Edit It.DefinitionOperators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function.Most of them use a classical prefixed functional syntax (i.e. operator_name(operand1, operand2, operand3), see below), with the exception of arithmetic (e.g. +, /), logical (and, or), comparison (e.g. &gt;, &lt;), access (., [..]) and pair (::) operators, which require an infixed notation (i.e. operand1 operator_symbol operand1).The ternary functional if-else operator, ? :, uses a special infixed syntax composed with two symbols (e.g. operand1 ? operand2 : operand3). Two unary operators (- and !) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g. ` - 10, ! (operand1 or operand2)`).Finally, special constructor operators ({...} for constructing points, [...] for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. {1,2,3}, [operand1, operand2, ..., operandn] or [key1::value1, key2::value2... keyn::valuen]).With the exception of these special cases above, the following rules apply to the syntax of operators:  if they only have one operand, the functional prefixed syntax is mandatory (e.g. operator_name(operand1))  if they have two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2)) or the infixed syntax (e.g. operand1 operator_name operand2) can be used.  if they have more than two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2, ..., operand)) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. operand1 operator_name(operand2, ..., operand)) can be used.All of these alternative syntaxes are completely equivalent.Operators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.Priority between operatorsThe priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.GAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely:  the constructor operators, like ::, used to compose pairs of operands, have the lowest priority of all operators (e.g. a &gt; b :: b &gt; c will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, [a &gt; 10, b &gt; 5] will return a list of boolean values.  it is followed by the ?: operator, the functional if-else (e.g. ` a &gt; b ? a + 10 : a - 10` will return the result of the if-else).  next are the logical operators, and and or (e.g. a &gt; b or b &gt; c will return the value of the test)  next are the comparison operators (i.e. &gt;, &lt;, &lt;=, &gt;=, =, !=)  next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)  next the unary operators - and !  next the access operators . and [] (e.g. {1,2,3}.x &gt; 20 + {4,5,6}.y will return the result of the comparison between the x and y ordinates of the two points)  and finally the functional operators, which have the highest priority of all.Using actions as operatorsActions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.For instance, if the following species is defined:species spec1 {        int min(int x, int y) {                return x &gt; y ? x : y;        }}Any agent instance of spec1 can use min as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:global {        init {                create spec1;                spec1 my_agent &lt;- spec1[0];                int the_min &lt;- my_agent min(10,20); // or min(my_agent, 10, 20);        }}If the action doesn’t have any operands, the syntax to use is my_agent the_action(). Finally, if it does not return a value, it might still be used but is considering as returning a value of type unknown (e.g. unknown result &lt;- my_agent the_action(op1, op2);).Note that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).Table of ContentsOperators by categories3Dbox, cone3D, cube, cylinder, dem, hexagon, pyramid, rgb_to_xyz, set_z, sphere, teapot,Arithmetic operators-, /, [^](OperatorsAC#^), [](OperatorsAC#), +, abs, acos, asin, atan, atan2, ceil, cos, cos_rad, div, even, exp, fact, floor, hypot, is_finite, is_number, ln, log, mod, round, signum, sin, sin_rad, sqrt, tan, tan_rad, tanh, with_precision,BDIand, eval_when, get_about, get_agent, get_agent_cause, get_decay, get_dominance, get_familiarity, get_intensity, get_lifetime, get_liking, get_praiseworthiness, get_priority, get_solidarity, get_super_intention, new_emotion, new_predicate, new_social_link, or, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_liking, set_solidarity, set_truth, with_lifetime, with_praiseworthiness, with_priority, with_values,Casting operatorsas, as_int, as_matrix, font, is, is_skill, list_with, matrix_with, species, to_gaml, topology,Color-related operators-, /, [](OperatorsAC#), +, blend, brewer_colors, brewer_palettes, grayscale, hsb, mean, median, rgb, rnd_color, sum,Comparison operators!=, &lt;, &lt;=, =, &gt;, &gt;=, between,Containers-related operators-, ::, +, accumulate, among, at, collect, contains, contains_all, contains_any, count, distinct, empty, every, first, first_with, get, group_by, in, index_by, inter, interleave, internal_at, internal_integrated_value, last, last_with, length, max, max_of, mean, mean_of, median, min, min_of, mul, one_of, product_of, range, reverse, shuffle, sort_by, sum, sum_of, union, variance_of, where, with_max_of, with_min_of,Date-related operators-, !=, +, &lt;, &lt;=, =, &gt;, &gt;=, after, before, between, every, milliseconds_between, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_weeks, minus_years, months_between, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_weeks, plus_years, since, to, until, years_between,DatesDriving operatorsas_driving_graph,edgeedge_between,EDP-related operatorsdiff, diff2, internal_zero_order_equation,Files-related operatorscrs, file, file_exists, folder, get, new_folder, osm_file, read, writable,FIPA-related operatorsconversation, message,Graphs-related operatorsadd_edge, add_node, adjacency, agent_from_geometry, all_pairs_shortest_path, alpha_index, as_distance_graph, as_edge_graph, as_intersection_graph, as_path, beta_index, betweenness_centrality, biggest_cliques_of, connected_components_of, connectivity_index, contains_edge, contains_vertex, degree_of, directed, edge, edge_between, edge_betweenness, edges, gamma_index, generate_barabasi_albert, generate_complete_graph, generate_watts_strogatz, grid_cells_to_graph, in_degree_of, in_edges_of, layout, load_graph_from_file, load_shortest_paths, maximal_cliques_of, nb_cycles, neighbors_of, node, nodes, out_degree_of, out_edges_of, path_between, paths_between, predecessors_of, remove_node_from, rewire_n, source_of, spatial_graph, successors_of, sum, target_of, undirected, use_cache, weight_of, with_optimizer_type, with_weights,Grid-related operatorsas_4_grid, as_grid, as_hexagonal_grid, grid_at, path_between,Iterator operatorsaccumulate, as_map, collect, count, distribution_of, distribution_of, distribution_of, distribution2d_of, distribution2d_of, distribution2d_of, first_with, frequency_of, group_by, index_by, last_with, max_of, mean_of, min_of, product_of, sort_by, sum_of, variance_of, where, with_max_of, with_min_of,List-related operatorscopy_between, index_of, last_index_of,Logical operators:, !, ?, and, or,Map comparaison operatorsfuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,Map-related operatorsas_map, index_of, last_index_of,Materialmaterial,Matrix-related operators-, /, ., [](OperatorsAC#), +, append_horizontally, append_vertically, column_at, columns_list, determinant, eigenvalues, index_of, inverse, last_index_of, row_at, rows_list, shuffle, trace, transpose,multicriteria operatorselectre_DM, evidence_theory_DM, promethee_DM, weighted_means_DM,Path-related operatorsagent_from_geometry, all_pairs_shortest_path, as_path, load_shortest_paths, path_between, path_to, paths_between, use_cache,Points-related operators-, /, [](OperatorsAC#), +, &lt;, &lt;=, &gt;, &gt;=, add_point, angle_between, any_location_in, centroid, closest_points_with, farthest_point_to, grid_at, norm, point, points_along, points_at, points_on,Random operatorsbinomial, flip, gauss, poisson, rnd, rnd_choice, sample, shuffle, skew_gauss, truncated_gauss,ReverseOperatorsShapearc, box, circle, cone, cone3D, cross, cube, curve, cylinder, ellipse, envelope, geometry_collection, hexagon, line, link, plan, polygon, polyhedron, pyramid, rectangle, sphere, square, squircle, teapot, triangle,Spatial operators-, [](OperatorsAC#), +, add_point, agent_closest_to, agent_farthest_to, agents_at_distance, agents_inside, agents_overlapping, angle_between, any_location_in, arc, around, as_4_grid, as_grid, as_hexagonal_grid, at_distance, at_location, box, centroid, circle, clean, closest_points_with, closest_to, cone, cone3D, convex_hull, covers, cross, crosses, crs, CRS_transform, cube, curve, cylinder, dem, direction_between, disjoint_from, distance_between, distance_to, ellipse, envelope, farthest_point_to, farthest_to, geometry_collection, gini, hexagon, hierarchical_clustering, IDW, inside, inter, intersects, line, link, masked_by, moran, neighbors_at, neighbors_of, overlapping, overlaps, partially_overlaps, path_between, path_to, plan, points_along, points_at, points_on, polygon, polyhedron, pyramid, rectangle, rgb_to_xyz, rotated_by, round, scaled_to, set_z, simple_clustering_by_distance, simplification, skeletonize, smooth, sphere, split_at, split_geometry, split_lines, square, squircle, teapot, to_GAMA_CRS, to_rectangles, to_squares, touches, towards, transformed_by, translated_by, triangle, triangulate, union, using, voronoi, with_precision, without_holes,Spatial properties operatorscovers, crosses, intersects, partially_overlaps, touches,Spatial queries operatorsagent_closest_to, agent_farthest_to, agents_at_distance, agents_inside, agents_overlapping, at_distance, closest_to, farthest_to, inside, neighbors_at, neighbors_of, overlapping,Spatial relations operatorsdirection_between, distance_between, distance_to, path_between, path_to, towards,Spatial statistical operatorshierarchical_clustering, simple_clustering_by_distance,Spatial transformations operators-, [](OperatorsAC#), +, as_4_grid, as_grid, as_hexagonal_grid, at_location, clean, convex_hull, CRS_transform, rotated_by, scaled_to, simplification, skeletonize, smooth, split_geometry, split_lines, to_GAMA_CRS, to_rectangles, to_squares, transformed_by, translated_by, triangulate, voronoi, without_holes,Species-related operatorsindex_of, last_index_of, of_generic_species, of_species,Statistical operatorsbuild, corR, dbscan, distribution_of, distribution2d_of, frequency_of, gamma_rnd, geometric_mean, gini, harmonic_mean, hierarchical_clustering, kmeans, kurtosis, max, mean, mean_deviation, meanR, median, min, moran, mul, predict, simple_clustering_by_distance, skewness, standard_deviation, sum, variance,Strings-related operators+, &lt;, &lt;=, &gt;, &gt;=, at, char, contains, contains_all, contains_any, copy_between, date, empty, first, in, indented_by, index_of, is_number, last, last_index_of, length, lower_case, replace, replace_regex, reverse, sample, shuffle, split_with, string, upper_case,System., command, copy, dead, eval_gaml, every, user_input,Time-related operatorsdate, string,Types-related operatorsUser control operatorsuser_input,OperatorsdatePossible use:  string date string —&gt;  date  date (string , string) —&gt;  dateResult:converts a string to a date following a custom pattern. The pattern can use “%Y %M %N %D %E %h %m %s %z” for outputting years, months, name of month, days, name of days, hours, minutes, seconds and the time-zone. A null or empty pattern will parse the date using one of the ISO date &amp; time formats (similar to date(‘…’) in that case). The pattern can also follow the pattern definition found here, which gives much more control over what will be parsed: https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns. Different patterns are available by default as constant: #iso_local, #iso_simple, #iso_offset, #iso_zoned and #custom, which can be changed in the preferencesExamples:date(\"1999-12-30\", 'yyyy-MM-dd')dbscanPossible use:  dbscan (list, float, int) —&gt;  list&lt;list&gt;Result:returns the list of clusters (list of instance indices) computed with the dbscan (density-based spatial clustering of applications with noise) algorithm from the first operand data according to the maximum radius of the neighborhood to be considered (eps) and the minimum number of points needed for a cluster (minPts). Usage: dbscan(data,eps,minPoints)Special cases:  if the lengths of two vectors in the right-hand aren’t equal, returns 0Examples:dbscan ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],10,2)deadPossible use:  dead (agent) —&gt;  boolResult:true if the agent is dead (or null), false otherwise.Examples:bool var0 &lt;- dead(agent_A); \t// var0 equals true or falsedegree_ofPossible use:  graph degree_of unknown —&gt;  int  degree_of (graph , unknown) —&gt;  intResult:returns the degree (in+out) of a vertex (right-hand operand) in the graph given as left-hand operand.Examples:int var1 &lt;- graphFromMap degree_of (node(3)); \t// var1 equals 3See also:in_degree_of, out_degree_of,demPossible use:  dem (file) —&gt;  geometry  file dem file —&gt;  geometry  dem (file , file) —&gt;  geometry  file dem float —&gt;  geometry  dem (file , float) —&gt;  geometry  dem (file, file, float) —&gt;  geometryResult:A polygon that is equivalent to the surface of the textureExamples:geometry var0 &lt;- dem(dem,texture,z_factor); \t// var0 equals a geometry as a rectangle of width and height equal to the texture.geometry var1 &lt;- dem(dem,texture); \t// var1 equals a geometry as a rectangle of weight and height equal to the texture.geometry var2 &lt;- dem(dem,z_factor); \t// var2 equals a geometry as a rectangle of weight and height equal to the texture.geometry var3 &lt;- dem(dem); \t// var3 equals returns a geometry as a rectangle of width and height equal to the texture.detSame signification as determinantdeterminantPossible use:  determinant (matrix) —&gt;  floatResult:The determinant of the given matrixExamples:float var0 &lt;- determinant(matrix([[1,2],[3,4]])); \t// var0 equals -2diffPossible use:  float diff float —&gt;  float  diff (float , float) —&gt;  floatdiff2Possible use:  float diff2 float —&gt;  float  diff2 (float , float) —&gt;  floatdirectedPossible use:  directed (graph) —&gt;  graphResult:the operand graph becomes a directed graph.Comment:the operator alters the operand graph, it does not create a new one.See also:undirected,direction_betweenPossible use:  topology direction_between container&lt;geometry&gt; —&gt;  int  direction_between (topology , container&lt;geometry&gt;) —&gt;  intResult:A direction (in degree) between a list of two geometries (geometries, agents, points) considering a topology.Examples:int var0 &lt;- my_topology direction_between [ag1, ag2]; \t// var0 equals the direction between ag1 and ag2 considering the topology my_topologySee also:towards, direction_to, distance_to, distance_between, path_between, path_to,direction_toSame signification as towardsdisjoint_fromPossible use:  geometry disjoint_from geometry —&gt;  bool  disjoint_from (geometry , geometry) —&gt;  boolResult:A boolean, equal to true if the left-geometry (or agent/point) is disjoints from the right-geometry (or agent/point).Special cases:  if one of the operand is null, returns true.  if one operand is a point, returns false if the point is included in the geometry.Examples:bool var0 &lt;- polyline([{10,10},{20,20}]) disjoint_from polyline([{15,15},{25,25}]); \t// var0 equals falsebool var1 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var1 equals falsebool var2 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from {15,15}; \t// var2 equals falsebool var3 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from {25,25}; \t// var3 equals truebool var4 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{35,35},{35,45},{45,45},{45,35}]); \t// var4 equals trueSee also:intersects, crosses, overlaps, partially_overlaps, touches,distance_betweenPossible use:  topology distance_between container&lt;geometry&gt; —&gt;  float  distance_between (topology , container&lt;geometry&gt;) —&gt;  floatResult:A distance between a list of geometries (geometries, agents, points) considering a topology.Examples:float var0 &lt;- my_topology distance_between [ag1, ag2, ag3]; \t// var0 equals the distance between ag1, ag2 and ag3 considering the topology my_topologySee also:towards, direction_to, distance_to, direction_between, path_between, path_to,distance_toPossible use:  geometry distance_to geometry —&gt;  float  distance_to (geometry , geometry) —&gt;  float  point distance_to point —&gt;  float  distance_to (point , point) —&gt;  floatResult:A distance between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.Examples:float var0 &lt;- ag1 distance_to ag2; \t// var0 equals the distance between ag1 and ag2 considering the topology of the agent applying the operatorSee also:towards, direction_to, distance_between, direction_between, path_between, path_to,distinctPossible use:  distinct (container) —&gt;  containerResult:produces a set from the elements of the operand (i.e. a list without duplicated elements)Special cases:  if the operand is nil, remove_duplicates returns nil  if the operand is a graph, remove_duplicates returns the set of nodes  if the operand is a matrix, remove_duplicates returns a matrix without duplicated row  if the operand is a map, remove_duplicates returns the set of values without duplicatecontainer var1 &lt;- remove_duplicates([1::3,2::4,3::3,5::7]); \t// var1 equals [3,4,7]Examples:container var0 &lt;- remove_duplicates([3,2,5,1,2,3,5,5,5]); \t// var0 equals [3,2,5,1]distribution_ofPossible use:  distribution_of (container) —&gt;  map  container distribution_of int —&gt;  map  distribution_of (container , int) —&gt;  map  distribution_of (container, int, float, float) —&gt;  mapResult:Discretize a list of values into n bins (computes the bins from a numerical variable into n (default 10) bins. Returns a distribution map with the values (values key), the interval legends (legend key), the distribution parameters (params keys, for cumulative charts). Parameters can be (list), (list, nbbins) or (list,nbbins,valmin,valmax)Examples:map var0 &lt;- distribution_of([1,1,2,12.5]); \t// var0 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])map var1 &lt;- distribution_of([1,1,2,12.5],10); \t// var1 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])map var2 &lt;- distribution_of([1,1,2,12.5]); \t// var2 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])See also:as_map,distribution2d_ofPossible use:  container distribution2d_of container —&gt;  map  distribution2d_of (container , container) —&gt;  map  distribution2d_of (container, container, int, int) —&gt;  map  distribution2d_of (container, container, int, float, float, int, float, float) —&gt;  mapResult:Discretize two lists of values into n bins (computes the bins from a numerical variable into n (default 10) bins. Returns a distribution map with the values (values key), the interval legends (legend key), the distribution parameters (params keys, for cumulative charts). Parameters can be (list), (list, nbbins) or (list,nbbins,valmin,valmax)Examples:map var0 &lt;- distribution_of([1,1,2,12.5],10); \t// var0 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])map var1 &lt;- distribution2d_of([1,1,2,12.5]); \t// var1 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])map var2 &lt;- distribution_of([1,1,2,12.5],10); \t// var2 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])See also:as_map,divPossible use:  float div float —&gt;  int  div (float , float) —&gt;  int  int div int —&gt;  int  div (int , int) —&gt;  int  float div int —&gt;  int  div (float , int) —&gt;  int  int div float —&gt;  int  div (int , float) —&gt;  intResult:Returns the truncation of the division of the left-hand operand by the right-hand operand.Special cases:  if the right-hand operand is equal to zero, raises an exception.  if the right-hand operand is equal to zero, raises an exception.  if the right-hand operand is equal to zero, raises an exception.Examples:int var0 &lt;- 40.1 div 4.5; \t// var0 equals 8int var1 &lt;- 40 div 3; \t// var1 equals 13int var2 &lt;- 40.5 div 3; \t// var2 equals 13int var3 &lt;- 40 div 4.1; \t// var3 equals 9See also:mod,dxf_filePossible use:  dxf_file (string) —&gt;  fileResult:Constructs a file of type dxf. Allowed extensions are limited to dxfedgePossible use:  edge (pair) —&gt;  unknown  edge (unknown) —&gt;  unknown  unknown edge unknown —&gt;  unknown  edge (unknown , unknown) —&gt;  unknown  pair edge float —&gt;  unknown  edge (pair , float) —&gt;  unknown  unknown edge float —&gt;  unknown  edge (unknown , float) —&gt;  unknown  edge (unknown, unknown, unknown) —&gt;  unknown  edge (unknown, unknown, float) —&gt;  unknown  edge (pair, unknown, float) —&gt;  unknown  edge (unknown, unknown, unknown, float) —&gt;  unknownedge_betweenPossible use:  graph edge_between pair —&gt;  unknown  edge_between (graph , pair) —&gt;  unknownResult:returns the edge linking two nodesExamples:unknown var0 &lt;- graphFromMap edge_between node1::node2; \t// var0 equals edge1See also:out_edges_of, in_edges_of,edge_betweennessPossible use:  edge_betweenness (graph) —&gt;  mapResult:returns a map containing for each edge (key), its betweenness centrality (value): number of shortest paths passing through each edgeExamples:graph graphEpidemio &lt;- graph([]);map var1 &lt;- edge_betweenness(graphEpidemio); \t// var1 equals the edge betweenness index of the graphedgesPossible use:  edges (container) —&gt;  containereigenvaluesPossible use:  eigenvalues (matrix) —&gt;  list&lt;float&gt;Result:The eigen values (matrix) of the given matrixExamples:list&lt;float&gt; var0 &lt;- eigenvalues(matrix([[5,-3],[6,-4]])); \t// var0 equals [2.0000000000000004,-0.9999999999999998]electre_DMPossible use:  electre_DM (list&lt;list&gt;, list&lt;map&lt;string,object&gt;&gt;, float) —&gt;  intResult:The index of the best candidate according to a method based on the ELECTRE methods. The principle of the ELECTRE methods is to compare the possible candidates by pair. These methods analyses the possible outranking relation existing between two candidates. An candidate outranks another if this one is at least as good as the other one. The ELECTRE methods are based on two concepts: the concordance and the discordance. The concordance characterizes the fact that, for an outranking relation to be validated, a sufficient majority of criteria should be in favor of this assertion. The discordance characterizes the fact that, for an outranking relation to be validated, none of the criteria in the minority should oppose too strongly this assertion. These two conditions must be true for validating the outranking assertion. More information about the ELECTRE methods can be found in [http://www.springerlink.com/content/g367r44322876223/\tFigueira,  J., Mousseau, V., Roy, B.: ELECTRE Methods. In: Figueira, J., Greco, S., and Ehrgott, M., (Eds.), Multiple Criteria Decision Analysis: State of the Art Surveys, Springer, New York, 133–162 (2005)]. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains fives elements: a name, a weight, a preference value (p), an indifference value (q) and a veto value (v). The preference value represents the threshold from which the difference between two criterion values allows to prefer one vector of values over another. The indifference value represents the threshold from which the difference between two criterion values is considered significant. The veto value represents the threshold from which the difference between two criterion values disqualifies the candidate that obtained the smaller value; the last operand is the fuzzy cut.Special cases:  returns -1 is the list of candidates is nil or emptyExamples:int var0 &lt;- electre_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"weight\" :: 2.0,\"p\"::0.5, \"q\"::0.0, \"s\"::1.0, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: 1.0,\"p\"::0.5, \"q\"::0.0, \"s\"::1.0, \"maximize\" :: false]]); \t// var0 equals 0See also:weighted_means_DM, promethee_DM, evidence_theory_DM,ellipsePossible use:  float ellipse float —&gt;  geometry  ellipse (float , float) —&gt;  geometryResult:An ellipse geometry which x-radius is equal to the first operand and y-radius is equal to the second operandComment:the center of the ellipse is by default the location of the current agent in which has been called this operator.Special cases:  returns a point if both operands are lower or equal to 0, a line if only one is.Examples:geometry var0 &lt;- ellipse(10, 10); \t// var0 equals a geometry as an ellipse of width 10 and height 10.See also:around, cone, line, link, norm, point, polygon, polyline, rectangle, square, circle, squircle, triangle,emotionPossible use:  emotion (any) —&gt;  emotionResult:Casts the operand into the type emotionemptyPossible use:  empty (container&lt;KeyType,ValueType&gt;) —&gt;  bool  empty (string) —&gt;  boolResult:true if the operand is empty, false otherwise.Comment:the empty operator behavior depends on the nature of the operandSpecial cases:  if it is a map, empty returns true if the map contains no key-value mappings, and false otherwise  if it is a file, empty returns true if the content of the file (that is also a container) is empty, and false otherwise  if it is a population, empty returns true if there is no agent in the population, and false otherwise  if it is a graph, empty returns true if it contains no vertex and no edge, and false otherwise  if it is a matrix of int, float or object, it will return true if all elements are respectively 0, 0.0 or null, and false otherwise  if it is a matrix of geometry, it will return true if the matrix contains no cell, and false otherwise  if it is a list, empty returns true if there is no element in the list, and false otherwisebool var0 &lt;- empty([]); \t// var0 equals true  if it is a string, empty returns true if the string does not contain any character, and false otherwisebool var1 &lt;- empty ('abced'); \t// var1 equals falseenlarged_bySame signification as +envelopePossible use:  envelope (unknown) —&gt;  geometryResult:A 3D geometry that represents the box that surrounds the geometries or the surface described by the arguments. More general than geometry(arguments).envelope, as it allows to pass int, double, point, image files, shape files, asc files, or any list combining these arguments, in which case the envelope will be correctly expanded. If an envelope cannot be determined from the arguments, a default one of dimensions (0,100, 0, 100, 0, 100) is returnedeval_gamlPossible use:  eval_gaml (string) —&gt;  unknownResult:evaluates the given GAML string.Examples:unknown var0 &lt;- eval_gaml(\"2+3\"); \t// var0 equals 5eval_whenPossible use:  eval_when (BDIPlan) —&gt;  boolResult:evaluate the facet when of a given planExamples:eval_when(plan1)evenPossible use:  even (int) —&gt;  boolResult:Returns true if the operand is even and false if it is odd.Special cases:  if the operand is equal to 0, it returns true.  if the operand is a float, it is truncated beforeExamples:bool var0 &lt;- even (3); \t// var0 equals falsebool var1 &lt;- even(-12); \t// var1 equals trueeveryPossible use:  every (int) —&gt;  bool  every (any expression) —&gt;  bool  msi.gama.util.GamaDateInterval every any expression —&gt;  msi.gama.util.IList&lt;msi.gama.util.GamaDate&gt;  every (msi.gama.util.GamaDateInterval , any expression) —&gt;  msi.gama.util.IList&lt;msi.gama.util.GamaDate&gt;  container every int —&gt;  container  every (container , int) —&gt;  containerResult:true every operand * cycle, false otherwiseapplies a step to an interval of dates defined by ‘date1 to date2’expects a frequency (expressed in seconds of simulated time) as argument. Will return true every time the current_date matches with this frequencyRetrieves elements from the first argument every step (second argument) elements. Raises an error if the step is negative or equal to zeroComment:the value of the every operator depends on the cycle. It can be used to do something every x cycle.Used to do something at regular intervals of time. Can be used in conjunction with ‘since’, ‘after’, ‘before’, ‘until’ or ‘between’, so that this computation only takes place in the temporal segment defined by these operators. In all cases, the starting_date of the model is used as a reference starting pointExamples:if every(2) {write \"the cycle number is even\";}\t     else {write \"the cycle number is odd\";}(date('2000-01-01') to date('2010-01-01')) every (#month) // builds an interval between these two dates which contains all the monthly dates starting from the beginning of the intervalreflex when: every(2#days) since date('2000-01-01') { .. }state a { transition to: b when: every(2#mn);} state b { transition to: a when: every(30#s);} // This oscillatory behavior will use the starting_date of the model as its starting point in timeSee also:to, since, after,every_cycleSame signification as everyevidence_theory_DMPossible use:  list&lt;list&gt; evidence_theory_DM list&lt;map&lt;string,object&gt;&gt; —&gt;  int  evidence_theory_DM (list&lt;list&gt; , list&lt;map&lt;string,object&gt;&gt;) —&gt;  int  evidence_theory_DM (list&lt;list&gt;, list&lt;map&lt;string,object&gt;&gt;, bool) —&gt;  intResult:The index of the best candidate according to a method based on the Evidence theory. This theory, which was proposed by Shafer ([http://www.glennshafer.com/books/amte.html Shafer G (1976) A mathematical theory of evidence, Princeton University Press]), is based on the work of Dempster ([http://projecteuclid.org/DPubS?service=UI&amp;version=1.0&amp;verb=Display&amp;handle=euclid.aoms/1177698950 Dempster A (1967) Upper and lower probabilities induced by multivalued mapping. Annals of Mathematical Statistics, vol.  38, pp. 325–339]) on lower and upper probability distributions. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains seven elements: a name, a first threshold s1, a second threshold s2, a value for the assertion “this candidate is the best” at threshold s1 (v1p), a value for the assertion “this candidate is the best” at threshold s2 (v2p), a value for the assertion “this candidate is not the best” at threshold s1 (v1c), a value for the assertion “this candidate is not the best” at threshold s2 (v2c). v1p, v2p, v1c and v2c have to been defined in order that: v1p + v1c &lt;= 1.0; v2p + v2c &lt;= 1.0.; the last operand allows to use a simple version of this multi-criteria decision making method (simple if true)Special cases:  if the operator is used with only 2 operands (the candidates and the criteria), the last parameter (use simple method) is set to true  returns -1 is the list of candidates is nil or emptyExamples:int var0 &lt;- evidence_theory_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"s1\" :: 0.0,\"s2\"::1.0, \"v1p\"::0.0, \"v2p\"::1.0, \"v1c\"::0.0, \"v2c\"::0.0, \"maximize\" :: true],[\"name\"::\"price\",  \"s1\" :: 0.0,\"s2\"::1.0, \"v1p\"::0.0, \"v2p\"::1.0, \"v1c\"::0.0, \"v2c\"::0.0, \"maximize\" :: true]], true); \t// var0 equals 0See also:weighted_means_DM, electre_DM,expPossible use:  exp (float) —&gt;  float  exp (int) —&gt;  floatResult:Returns Euler’s number e raised to the power of the operand.Special cases:  the operand is casted to a float before being evaluated.  the operand is casted to a float before being evaluated.Examples:float var0 &lt;- exp (0); \t// var0 equals 1.0See also:ln,factPossible use:  fact (int) —&gt;  floatResult:Returns the factorial of the operand.Special cases:  if the operand is less than 0, fact returns 0.Examples:float var0 &lt;- fact(4); \t// var0 equals 24farthest_point_toPossible use:  geometry farthest_point_to point —&gt;  point  farthest_point_to (geometry , point) —&gt;  pointResult:the farthest point of the left-operand to the left-point.Examples:point var0 &lt;- geom farthest_point_to(pt); \t// var0 equals the farthest point of geom to ptSee also:any_location_in, any_point_in, closest_points_with, points_at,farthest_toPossible use:  container&lt;agent&gt; farthest_to geometry —&gt;  geometry  farthest_to (container&lt;agent&gt; , geometry) —&gt;  geometryResult:An agent or a geometry among the left-operand list of agents, species or meta-population (addition of species), the farthest to the operand (casted as a geometry).Comment:the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.Examples:geometry var0 &lt;- [ag1, ag2, ag3] closest_to(self); \t// var0 equals return the farthest agent among ag1, ag2 and ag3 to the agent applying the operator.(species1 + species2) closest_to selfSee also:neighbors_at, neighbors_of, inside, overlapping, agents_overlapping, agents_inside, agent_closest_to, closest_to, agent_farthest_to,filePossible use:  file (string) —&gt;  file  string file container —&gt;  file  file (string , container) —&gt;  fileResult:opens a file in read only mode, creates a GAML file object, and tries to determine and store the file content in the contents attribute.Creates a file in read/write mode, setting its contents to the container passed in parameterComment:The file should have a supported extension, see file type definition for supported file extensions.The type of container to pass will depend on the type of file (see the management of files in the documentation). Can be used to copy files since files are considered as containers. For example: save file(‘image_copy.png’, file(‘image.png’)); will copy image.png to image_copy.pngSpecial cases:  If the specified string does not refer to an existing file, an exception is risen when the variable is used.Examples:let fileT type: file value: file(\"../includes/Stupid_Cell.Data\"); \t\t\t// fileT represents the file \"../includes/Stupid_Cell.Data\"\t\t\t// fileT.contents here contains a matrix storing all the data of the text fileSee also:folder, new_folder,file_existsPossible use:  file_exists (string) —&gt;  boolResult:Test whether the parameter is the path to an existing file.firstPossible use:  first (string) —&gt;  string  first (container&lt;KeyType,ValueType&gt;) —&gt;  ValueType  int first container —&gt;  container  first (int , container) —&gt;  containerResult:the first value of the operandComment:the first operator behavior depends on the nature of the operandSpecial cases:  if it is a map, first returns the first value of the first pair (in insertion order)  if it is a file, first returns the first element of the content of the file (that is also a container)  if it is a population, first returns the first agent of the population  if it is a graph, first returns the first edge (in creation order)  if it is a matrix, first returns the element at {0,0} in the matrix  for a matrix of int or float, it will return 0 if the matrix is empty  for a matrix of object or geometry, it will return nil if the matrix is empty  if it is a string, first returns a string composed of its first characterstring var0 &lt;- first ('abce'); \t// var0 equals 'a'  if it is a list, first returns the first element of the list, or nil if the list is emptyint var1 &lt;- first ([1, 2, 3]); \t// var1 equals 1See also:last,first_ofSame signification as firstfirst_withPossible use:  container first_with any expression —&gt;  unknown  first_with (container , any expression) —&gt;  unknownResult:the first element of the left-hand operand that makes the right-hand operand evaluate to true.Comment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  if the left-hand operand is nil, first_with throws an error. If there is no element that satisfies the condition, it returns nil  if the left-operand is a map, the keyword each will contain each valueunknown var4 &lt;- [1::2, 3::4, 5::6] first_with (each &gt;= 4); \t// var4 equals 4unknown var5 &lt;- [1::2, 3::4, 5::6].pairs first_with (each.value &gt;= 4); \t// var5 equals 3::4Examples:unknown var0 &lt;- [1,2,3,4,5,6,7,8] first_with (each &gt; 3); \t// var0 equals 4unknown var2 &lt;- g2 first_with (length(g2 out_edges_of each) = 0); \t// var2 equals node9unknown var3 &lt;- (list(node) first_with (round(node(each).location.x) &gt; 32); \t// var3 equals node2See also:group_by, last_with, where,flipPossible use:  flip (float) —&gt;  boolResult:true or false given the probability represented by the operandSpecial cases:  flip 0 always returns false, flip 1 trueExamples:bool var0 &lt;- flip (0.66666); \t// var0 equals 2/3 chances to return true.See also:rnd,floatPossible use:  float (any) —&gt;  floatResult:Casts the operand into the type floatfloorPossible use:  floor (float) —&gt;  floatResult:Maps the operand to the largest previous following integer, i.e. the largest integer not greater than x.Examples:float var0 &lt;- floor(3); \t// var0 equals 3.0float var1 &lt;- floor(3.5); \t// var1 equals 3.0float var2 &lt;- floor(-4.7); \t// var2 equals -5.0See also:ceil, round,folderPossible use:  folder (string) —&gt;  fileResult:opens an existing repositorySpecial cases:  If the specified string does not refer to an existing repository, an exception is risen.Examples:folder(\"../includes/\")file dirT &lt;- folder(\"../includes/\");\t\t\t\t// dirT represents the repository \"../includes/\"\t\t\t\t// dirT.contents here contains the list of the names of included filesSee also:file, new_folder,fontPossible use:  font (string, int, int) —&gt;  fontResult:Creates a new font, by specifying its name (either a font face name like ‘Lucida Grande Bold’ or ‘Helvetica’, or a logical name like ‘Dialog’, ‘SansSerif’, ‘Serif’, etc.), a size in points and a style, either #bold, #italic or #plain or a combination (addition) of them.Examples:font var0 &lt;- font ('Helvetica Neue',12, #bold + #italic); \t// var0 equals a bold and italic face of the Helvetica Neue familyfrequency_ofPossible use:  container frequency_of any expression —&gt;  map  frequency_of (container , any expression) —&gt;  mapResult:Returns a map with keys equal to the application of the right-hand argument (like collect) and values equal to the frequency of this key (i.e. how many times it has been obtained)Examples:map var0 &lt;- [ag1, ag2, ag3, ag4] frequency_of each.size; \t// var0 equals the different sizes as keys and the number of agents of this size as valuesSee also:as_map,fromSame signification as sincefuzzy_kappaPossible use:  fuzzy_kappa (list&lt;agent&gt;, list, list, list&lt;float&gt;, list, matrix&lt;float&gt;, float) —&gt;  float  fuzzy_kappa (list&lt;agent&gt;, list, list, list&lt;float&gt;, list, matrix&lt;float&gt;, float, list) —&gt;  floatResult:fuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance, weights). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling &amp; Software, 21fuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling &amp; Software, 21Examples:fuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2, [1.0,3.0,2.0,2.0,4.0])fuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2)fuzzy_kappa_simPossible use:  fuzzy_kappa_sim (list&lt;agent&gt;, list, list, list, list&lt;float&gt;, list, matrix&lt;float&gt;, float) —&gt;  float  fuzzy_kappa_sim (list&lt;agent&gt;, list, list, list, list&lt;float&gt;, list, matrix&lt;float&gt;, float, list) —&gt;  floatResult:fuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800, fuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance, weights). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800,Examples:fuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2)fuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2,[1.0,3.0,2.0,2.0,4.0])gaml_filePossible use:  gaml_file (string) —&gt;  fileResult:Constructs a file of type gaml. Allowed extensions are limited to gaml, experimentgamma_indexPossible use:  gamma_index (graph) —&gt;  floatResult:returns the gamma index of the graph (A measure of connectivity that considers the relationship between the number of observed links and the number of possible links: gamma = e/(3 * (v - 2)) - for planar graph.Examples:graph graphEpidemio &lt;- graph([]);float var1 &lt;- gamma_index(graphEpidemio); \t// var1 equals the gamma index of the graphSee also:alpha_index, beta_index, nb_cycles, connectivity_index,gamma_rndPossible use:  float gamma_rnd float —&gt;  float  gamma_rnd (float , float) —&gt;  floatResult:returns a random value from a gamma distribution with specified values of the shape and scale parametersExamples:gamma_rnd(10.0,5.0)gaussPossible use:  gauss (point) —&gt;  float  float gauss float —&gt;  float  gauss (float , float) —&gt;  floatResult:A value from a normally distributed random variable with expected value (mean) and variance (standardDeviation). The probability density function of such a variable is a Gaussian.A value from a normally distributed random variable with expected value (mean) and variance (standardDeviation). The probability density function of such a variable is a Gaussian.Special cases:  when the operand is a point, it is read as {mean, standardDeviation}  when standardDeviation value is 0.0, it always returns the mean value  when the operand is a point, it is read as {mean, standardDeviation}  when standardDeviation value is 0.0, it always returns the mean valueExamples:float var0 &lt;- gauss(0,0.3); \t// var0 equals 0.22354float var1 &lt;- gauss(0,0.3); \t// var1 equals -0.1357float var2 &lt;- gauss({0,0.3}); \t// var2 equals 0.22354float var3 &lt;- gauss({0,0.3}); \t// var3 equals -0.1357See also:skew_gauss, truncated_gauss, poisson,generate_barabasi_albertPossible use:  generate_barabasi_albert (container&lt;agent&gt;, species, int, bool) —&gt;  graph  generate_barabasi_albert (species, species, int, int, bool) —&gt;  graphResult:returns a random scale-free network (following Barabasi-Albert (BA) model).returns a random scale-free network (following Barabasi-Albert (BA) model).Comment:The Barabasi-Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:The Barabasi-Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:Special cases:  “vertices_specy”: the species of vertices  “edges_species”: the species of edges  “size”: the graph will contain (size + 1) nodes  “m”: the number of edges added per novel node  “synchronized”: is the graph and the species of vertices and edges synchronized?  “agents”: list of existing node agents  “edges_species”: the species of edges  “size”: the graph will contain (size + 1) nodes  “m”: the number of edges added per novel node  “synchronized”: is the graph and the species of vertices and edges synchronized?Examples:graph&lt;yourNodeSpecy,yourEdgeSpecy&gt; graphEpidemio &lt;- generate_barabasi_albert(\t\tyourNodeSpecy,\t\tyourEdgeSpecy,\t\t3,\t\t5,\t\ttrue);graph&lt;yourNodeSpecy,yourEdgeSpecy&gt; graphEpidemio &lt;- generate_barabasi_albert(\t\tyourListOfNodes,\t\tyourEdgeSpecy,\t\t3,\t\t5,\t\ttrue);See also:generate_watts_strogatz,generate_complete_graphPossible use:  generate_complete_graph (container&lt;agent&gt;, species, bool) —&gt;  graph  generate_complete_graph (container&lt;agent&gt;, species, float, bool) —&gt;  graph  generate_complete_graph (species, species, int, bool) —&gt;  graph  generate_complete_graph (species, species, int, float, bool) —&gt;  graphResult:returns a fully connected graph.returns a fully connected graph.returns a fully connected graph.returns a fully connected graph.Comment:Arguments should include following elements:Arguments should include following elements:Arguments should include following elements:Arguments should include following elements:Special cases:  “agents”: list of existing node agents  “edges_species”: the species of edges  “layoutRadius”: nodes of the graph will be located on a circle with radius layoutRadius and centered in the environment.  “synchronized”: is the graph and the species of vertices and edges synchronized?  “vertices_specy”: the species of vertices  “edges_species”: the species of edges  “size”: the graph will contain size nodes.  “layoutRadius”: nodes of the graph will be located on a circle with radius layoutRadius and centered in the environment.  “synchronized”: is the graph and the species of vertices and edges synchronized?  “vertices_specy”: the species of vertices  “edges_species”: the species of edges  “size”: the graph will contain size nodes.  “synchronized”: is the graph and the species of vertices and edges synchronized?  “agents”: list of existing node agents  “edges_species”: the species of edges  “synchronized”: is the graph and the species of vertices and edges synchronized?Examples:graph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_complete_graph(\t\t\tmyListOfNodes,\t\t\tmyEdgeSpecy,\t\t\t25,\t\ttrue);graph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_complete_graph(\t\t\tmyVertexSpecy,\t\t\tmyEdgeSpecy,\t\t\t10, 25,\t\ttrue);graph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_complete_graph(\t\t\tmyVertexSpecy,\t\t\tmyEdgeSpecy,\t\t\t10,\t\ttrue);graph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_complete_graph(\t\t\tmyListOfNodes,\t\t\tmyEdgeSpecy,\t\ttrue);See also:generate_barabasi_albert, generate_watts_strogatz,generate_watts_strogatzPossible use:  generate_watts_strogatz (container&lt;agent&gt;, species, float, int, bool) —&gt;  graph  generate_watts_strogatz (species, species, int, float, int, bool) —&gt;  graphResult:returns a random small-world network (following Watts-Strogatz model).returns a random small-world network (following Watts-Strogatz model).Comment:The Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:The Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:Special cases:  “vertices_specy”: the species of vertices  “edges_species”: the species of edges  “size”: the graph will contain (size + 1) nodes. Size must be greater than k.  “p”: probability to “rewire” an edge. So it must be between 0 and 1. The parameter is often called beta in the literature.  “k”: the base degree of each node. k must be greater than 2 and even.  “synchronized”: is the graph and the species of vertices and edges synchronized?  “agents”: list of existing node agents  “edges_species”: the species of edges  “p”: probability to “rewire” an edge. So it must be between 0 and 1. The parameter is often called beta in the literature.  “k”: the base degree of each node. k must be greater than 2 and even.  “synchronized”: is the graph and the species of vertices and edges synchronized?Examples:graph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_watts_strogatz(\t\t\tmyVertexSpecy,\t\t\tmyEdgeSpecy,\t\t\t2,\t\t\t0.3,\t\t\t2,\t\ttrue);graph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- generate_watts_strogatz(\t\t\tmyListOfNodes,\t\t\tmyEdgeSpecy,\t\t\t0.3,\t\t\t2,\t\ttrue);See also:generate_barabasi_albert,geojson_filePossible use:  geojson_file (string) —&gt;  fileResult:Constructs a file of type geojson. Allowed extensions are limited to json, geojson, geo.jsongeometric_meanPossible use:  geometric_mean (container) —&gt;  floatResult:the geometric mean of the elements of the operand. See Geometric_mean for more details.Comment:The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.Examples:float var0 &lt;- geometric_mean ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 4.962326343467649See also:mean, median, harmonic_mean,geometryPossible use:  geometry (any) —&gt;  geometryResult:Casts the operand into the type geometrygeometry_collectionPossible use:  geometry_collection (container&lt;geometry&gt;) —&gt;  geometryResult:A geometry collection (multi-geometry) composed of the given list of geometries.Special cases:  if the operand is nil, returns the point geometry {0,0}  if the operand is composed of a single geometry, returns a copy of the geometry.Examples:geometry var0 &lt;- geometry_collection([{0,0}, {0,10}, {10,10}, {10,0}]); \t// var0 equals a geometry composed of the 4 points (multi-point).See also:around, circle, cone, link, norm, point, polygone, rectangle, square, triangle, line,getPossible use:  geometry get string —&gt;  unknown  get (geometry , string) —&gt;  unknown  agent get string —&gt;  unknown  get (agent , string) —&gt;  unknownResult:Reads an attribute of the specified geometry (left operand). The attribute name is specified by the right operand.Reads an attribute of the specified agent (left operand). The attribute name is specified by the right operand.Special cases:  Reading the attribute of a geometrystring geom_area &lt;- a_geometry get('area');     // reads then 'area' attribute of 'a_geometry' variable then assigns the returned value to the geom_area variable  Reading the attribute of another agentstring agent_name &lt;- an_agent get('name');     // reads then 'name' attribute of an_agent then assigns the returned value to the agent_name variableget_aboutPossible use:  get_about (emotion) —&gt;  predicateResult:get the about value of the given emotionExamples:get_about(emotion)get_agentPossible use:  get_agent (msi.gaml.architecture.simplebdi.SocialLink) —&gt;  agentResult:get the agent value of the given social linkExamples:get_agent(social_link1)get_agent_causePossible use:  get_agent_cause (emotion) —&gt;  agent  get_agent_cause (predicate) —&gt;  agentResult:get the agent cause value of the given emotionExamples:get_agent_cause(emotion)get_decayPossible use:  get_decay (emotion) —&gt;  floatResult:get the decay value of the given emotionExamples:get_decay(emotion)get_dominancePossible use:  get_dominance (msi.gaml.architecture.simplebdi.SocialLink) —&gt;  floatResult:get the dominance value of the given social linkExamples:get_dominance(social_link1)get_familiarityPossible use:  get_familiarity (msi.gaml.architecture.simplebdi.SocialLink) —&gt;  floatResult:get the familiarity value of the given social linkExamples:get_familiarity(social_link1)get_intensityPossible use:  get_intensity (emotion) —&gt;  floatResult:get the intensity value of the given emotionExamples:emotion set_intensity 12get_lifetimePossible use:  get_lifetime (predicate) —&gt;  intget_likingPossible use:  get_liking (msi.gaml.architecture.simplebdi.SocialLink) —&gt;  floatResult:get the liking value of the given social linkExamples:get_liking(social_link1)get_praiseworthinessPossible use:  get_praiseworthiness (predicate) —&gt;  floatget_priorityPossible use:  get_priority (predicate) —&gt;  floatget_solidarityPossible use:  get_solidarity (msi.gaml.architecture.simplebdi.SocialLink) —&gt;  floatResult:get the solidarity value of the given social linkExamples:get_solidarity(social_link1)get_super_intentionPossible use:  get_super_intention (predicate) —&gt;  predicategif_filePossible use:  gif_file (string) —&gt;  fileResult:Constructs a file of type gif. Allowed extensions are limited to gifginiPossible use:  gini (list&lt;float&gt;) —&gt;  floatSpecial cases:  return the Gini Index of the given list of values (list of floats)float var0 &lt;- gini([1.0, 0.5, 2.0]); \t// var0 equals the gini index computedgraphPossible use:  graph (any) —&gt;  graphResult:Casts the operand into the type graphgrayscalePossible use:  grayscale (rgb) —&gt;  rgbResult:Converts rgb color to grayscale valueComment:r=red, g=green, b=blue. Between 0 and 255 and gray = 0.299 * red + 0.587 * green + 0.114 * blue (Photoshop value)Examples:rgb var0 &lt;- grayscale (rgb(255,0,0)); \t// var0 equals to a dark greySee also:rgb, hsb,grid_atPossible use:  species grid_at point —&gt;  agent  grid_at (species , point) —&gt;  agentResult:returns the cell of the grid (right-hand operand) at the position given by the right-hand operandComment:If the left-hand operand is a point of floats, it is used as a point of ints.Special cases:  if the left-hand operand is not a grid cell species, returns nilExamples:agent var0 &lt;- grid_cell grid_at {1,2}; \t// var0 equals the agent grid_cell with grid_x=1 and grid_y = 2grid_cells_to_graphPossible use:  grid_cells_to_graph (container) —&gt;  graphResult:creates a graph from a list of cells (operand). An edge is created between neighbors.Examples:my_cell_graph&lt;-grid_cells_to_graph(cells_list)grid_filePossible use:  grid_file (string) —&gt;  fileResult:Constructs a file of type grid. Allowed extensions are limited to asc, tifgroup_byPossible use:  container group_by any expression —&gt;  map  group_by (container , any expression) —&gt;  mapResult:Returns a map, where the keys take the possible values of the right-hand operand and the map values are the list of elements of the left-hand operand associated to the key valueComment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  if the left-hand operand is nil, group_by throws an errorExamples:map var0 &lt;- [1,2,3,4,5,6,7,8] group_by (each &gt; 3); \t// var0 equals [false::[1, 2, 3], true::[4, 5, 6, 7, 8]]map var1 &lt;- g2 group_by (length(g2 out_edges_of each) ); \t// var1 equals [ 0::[node9, node7, node10, node8, node11], 1::[node6], 2::[node5], 3::[node4]]map var2 &lt;- (list(node) group_by (round(node(each).location.x)); \t// var2 equals [32::[node5], 21::[node1], 4::[node0], 66::[node2], 96::[node3]]map var3 &lt;- [1::2, 3::4, 5::6] group_by (each &gt; 4); \t// var3 equals [false::[2, 4], true::[6]]See also:first_with, last_with, where,harmonic_meanPossible use:  harmonic_mean (container) —&gt;  floatResult:the harmonic mean of the elements of the operand. See Harmonic_mean for more details.Comment:The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.Examples:float var0 &lt;- harmonic_mean ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 4.804159445407279See also:mean, median, geometric_mean,hexagonPossible use:  hexagon (point) —&gt;  geometry  hexagon (float) —&gt;  geometryResult:A hexagon geometry which the given with and heightComment:the center of the hexagon is by default the location of the current agent in which has been called this operator.the center of the hexagon is by default the location of the current agent in which has been called this operator.Special cases:  returns nil if the operand is nil.  returns nil if the operand is nil.Examples:geometry var0 &lt;- hexagon({10,5}); \t// var0 equals a geometry as a hexagon of width of 10 and height of 5.geometry var1 &lt;- hexagon(10); \t// var1 equals a geometry as a hexagon of width of 10 and height of 10.See also:around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, triangle,hierarchical_clusteringPossible use:  container&lt;agent&gt; hierarchical_clustering float —&gt;  container  hierarchical_clustering (container&lt;agent&gt; , float) —&gt;  containerResult:A tree (list of list) contained groups of agents clustered by distance considering a distance min between two groups.Comment:use of hierarchical clustering with Minimum for linkage criterion between two groups of agents.Examples:container var0 &lt;- [ag1, ag2, ag3, ag4, ag5] hierarchical_clustering 20.0; \t// var0 equals for example, can return [[[ag1],[ag3]], [ag2], [[[ag4],[ag5]],[ag6]]See also:simple_clustering_by_distance,hsbPossible use:  hsb (float, float, float) —&gt;  rgb  hsb (float, float, float, int) —&gt;  rgb  hsb (float, float, float, float) —&gt;  rgbResult:Converts hsb (h=hue, s=saturation, b=brightness) value to Gama colorComment:h,s and b components should be floating-point values between 0.0 and 1.0 and when used alpha should be an integer (between 0 and 255) or a float (between 0 and 1) . Examples: Red=(0.0,1.0,1.0), Yellow=(0.16,1.0,1.0), Green=(0.33,1.0,1.0), Cyan=(0.5,1.0,1.0), Blue=(0.66,1.0,1.0), Magenta=(0.83,1.0,1.0)Examples:rgb var0 &lt;- hsb (0.5,1.0,1.0,0.0); \t// var0 equals rgb(\"cyan\",0)rgb var1 &lt;- hsb (0.0,1.0,1.0); \t// var1 equals rgb(\"red\")See also:rgb,hypotPossible use:  hypot (float, float, float, float) —&gt;  floatResult:Returns sqrt(x2 +y2) without intermediate overflow or underflow.Special cases:  If either argument is infinite, then the result is positive infinity. If either argument is NaN and neither argument is infinite, then the result is NaN.Examples:float var0 &lt;- hypot(0,1,0,1); \t// var0 equals sqrt(2)image_filePossible use:  image_file (string) —&gt;  fileResult:Constructs a file of type image. Allowed extensions are limited to tiff, jpg, jpeg, png, pict, bmpinPossible use:  unknown in container —&gt;  bool  in (unknown , container) —&gt;  bool  string in string —&gt;  bool  in (string , string) —&gt;  boolResult:true if the right operand contains the left operand, false otherwiseComment:the definition of in depends on the containerSpecial cases:  if the right operand is nil or empty, in returns false  if both operands are strings, returns true if the left-hand operand patterns is included in to the right-hand string;Examples:bool var0 &lt;- 2 in [1,2,3,4,5,6]; \t// var0 equals truebool var1 &lt;- 7 in [1,2,3,4,5,6]; \t// var1 equals falsebool var2 &lt;- 3 in [1::2, 3::4, 5::6]; \t// var2 equals falsebool var3 &lt;- 6 in [1::2, 3::4, 5::6]; \t// var3 equals truebool var4 &lt;-  'bc' in 'abcded'; \t// var4 equals trueSee also:contains,in_degree_ofPossible use:  graph in_degree_of unknown —&gt;  int  in_degree_of (graph , unknown) —&gt;  intResult:returns the in degree of a vertex (right-hand operand) in the graph given as left-hand operand.Examples:int var1 &lt;- graphFromMap in_degree_of (node(3)); \t// var1 equals 2See also:out_degree_of, degree_of,in_edges_ofPossible use:  graph in_edges_of unknown —&gt;  container  in_edges_of (graph , unknown) —&gt;  containerResult:returns the list of the in-edges of a vertex (right-hand operand) in the graph given as left-hand operand.Examples:container var1 &lt;- graphFromMap in_edges_of node({12,45}); \t// var1 equals [LineString]See also:out_edges_of,indented_byPossible use:  string indented_by int —&gt;  string  indented_by (string , int) —&gt;  stringResult:Converts a (possibly multiline) string by indenting it by a number – specified by the second operand – of tabulations to the rightindex_byPossible use:  container index_by any expression —&gt;  map  index_by (container , any expression) —&gt;  mapResult:produces a new map from the evaluation of the right-hand operand for each element of the left-hand operandSpecial cases:  if the left-hand operand is nil, index_by throws an error. If the operation results in duplicate keys, only the first value corresponding to the key is keptExamples:map var0 &lt;- [1,2,3,4,5,6,7,8] index_by (each - 1); \t// var0 equals [0::1, 1::2, 2::3, 3::4, 4::5, 5::6, 6::7, 7::8]index_ofPossible use:  container index_of unknown —&gt;  int  index_of (container , unknown) —&gt;  int  map index_of unknown —&gt;  unknown  index_of (map , unknown) —&gt;  unknown  matrix index_of unknown —&gt;  point  index_of (matrix , unknown) —&gt;  point  string index_of string —&gt;  int  index_of (string , string) —&gt;  int  species index_of unknown —&gt;  int  index_of (species , unknown) —&gt;  intResult:the index of the first occurence of the right operand in the left operand containerthe index of the first occurence of the right operand in the left operand containerComment:The definition of index_of and the type of the index depend on the containerSpecial cases:  if the left operand is a map, index_of returns the index of a value or nil if the value is not mapped  if the left operator is a species, returns the index of an agent in a species. If the argument is not an agent of this species, returns -1. Use int(agent) instead  if the left operand is a list, index_of returns the index as an integerint var1 &lt;- [1,2,3,4,5,6] index_of 4; \t// var1 equals 3int var2 &lt;- [4,2,3,4,5,4] index_of 4; \t// var2 equals 0  if the left operand is a matrix, index_of returns the index as a pointpoint var3 &lt;- matrix([[1,2,3],[4,5,6]]) index_of 4; \t// var3 equals {1.0,0.0}  if both operands are strings, returns the index within the left-hand string of the first occurrence of the given right-hand stringint var4 &lt;-  \"abcabcabc\" index_of \"ca\"; \t// var4 equals 2Examples:unknown var0 &lt;- [1::2, 3::4, 5::6] index_of 4; \t// var0 equals 3See also:at, last_index_of,insidePossible use:  container&lt;agent&gt; inside geometry —&gt;  list&lt;geometry&gt;  inside (container&lt;agent&gt; , geometry) —&gt;  list&lt;geometry&gt;Result:A list of agents or geometries among the left-operand list, species or meta-population (addition of species), covered by the operand (casted as a geometry).Examples:list&lt;geometry&gt; var0 &lt;- [ag1, ag2, ag3] inside(self); \t// var0 equals the agents among ag1, ag2 and ag3 that are covered by the shape of the right-hand argument.list&lt;geometry&gt; var1 &lt;- (species1 + species2) inside (self); \t// var1 equals the agents among species species1 and species2 that are covered by the shape of the right-hand argument.See also:neighbors_at, neighbors_of, closest_to, overlapping, agents_overlapping, agents_inside, agent_closest_to,intPossible use:  int (any) —&gt;  intResult:Casts the operand into the type intinterPossible use:  container inter container —&gt;  container  inter (container , container) —&gt;  container  geometry inter geometry —&gt;  geometry  inter (geometry , geometry) —&gt;  geometryResult:the intersection of the two operandsA geometry resulting from the intersection between the two geometriesComment:both containers are transformed into sets (so without duplicated element, cf. remove_deplicates operator) before the set intersection is computed.Special cases:  if an operand is a graph, it will be transformed into the set of its nodes  returns nil if one of the operands is nil  if an operand is a map, it will be transformed into the set of its valuescontainer var0 &lt;- [1::2, 3::4, 5::6] inter [2,4]; \t// var0 equals [2,4]container var1 &lt;- [1::2, 3::4, 5::6] inter [1,3]; \t// var1 equals []  if an operand is a matrix, it will be transformed into the set of the linescontainer var2 &lt;- matrix([[1,2,3],[4,5,4]]) inter [3,4]; \t// var2 equals [3,4]Examples:container var3 &lt;- [1,2,3,4,5,6] inter [2,4]; \t// var3 equals [2,4]container var4 &lt;- [1,2,3,4,5,6] inter [0,8]; \t// var4 equals []geometry var5 &lt;- square(10) inter circle(5); \t// var5 equals circle(5)See also:remove_duplicates, union, +, -,interleavePossible use:  interleave (container) —&gt;  containerResult:a new list containing the interleaved elements of the containers contained in the operandComment:the operand should be a list of lists of elements. The result is a list of elements.Examples:container var0 &lt;- interleave([1,2,4,3,5,7,6,8]); \t// var0 equals [1,2,4,3,5,7,6,8]container var1 &lt;- interleave([['e11','e12','e13'],['e21','e22','e23'],['e31','e32','e33']]); \t// var1 equals ['e11','e21','e31','e12','e22','e32','e13','e23','e33']internal_atPossible use:  agent internal_at container —&gt;  unknown  internal_at (agent , container) —&gt;  unknown  geometry internal_at container —&gt;  unknown  internal_at (geometry , container) —&gt;  unknown  container&lt;KeyType,ValueType&gt; internal_at list&lt;KeyType&gt; —&gt;  ValueType  internal_at (container&lt;KeyType,ValueType&gt; , list&lt;KeyType&gt;) —&gt;  ValueTypeResult:For internal use only. Corresponds to the implementation, for agents, of the access to containers with [index]For internal use only. Corresponds to the implementation, for geometries, of the access to containers with [index]For internal use only. Corresponds to the implementation of the access to containers with [index]See also:at,internal_integrated_valuePossible use:  any expression internal_integrated_value any expression —&gt;  container  internal_integrated_value (any expression , any expression) —&gt;  containerResult:For internal use only. Corresponds to the implementation, for agents, of the access to containers with [index]internal_zero_order_equationPossible use:  internal_zero_order_equation (any expression) —&gt;  floatintersectionSame signification as interintersectsPossible use:  geometry intersects geometry —&gt;  bool  intersects (geometry , geometry) —&gt;  boolResult:A boolean, equal to true if the left-geometry (or agent/point) intersects the right-geometry (or agent/point).Special cases:  if one of the operand is null, returns false.Examples:bool var0 &lt;- square(5) intersects {10,10}; \t// var0 equals falseSee also:disjoint_from, crosses, overlaps, partially_overlaps, touches,inversePossible use:  inverse (matrix) —&gt;  matrix&lt;float&gt;Result:The inverse matrix of the given matrix. If no inverse exists, returns a matrix that has properties that resemble that of an inverse.Examples:matrix&lt;float&gt; var0 &lt;- inverse(matrix([[5,-3],[6,-4]])); \t// var0 equals [2.0000000000000004,-0.9999999999999998]inverse_distance_weightingSame signification as IDWisPossible use:  unknown is any expression —&gt;  bool  is (unknown , any expression) —&gt;  boolResult:returns true if the left operand is of the right operand type, false otherwiseExamples:bool var0 &lt;- 0 is int; \t// var0 equals truebool var1 &lt;- an_agent is node; \t// var1 equals truebool var2 &lt;- 1 is float; \t// var2 equals falseis_csvPossible use:  is_csv (any) —&gt;  boolResult:Tests whether the operand is a csv file.is_dxfPossible use:  is_dxf (any) —&gt;  boolResult:Tests whether the operand is a dxf file.is_finitePossible use:  is_finite (float) —&gt;  boolResult:Returns whether the argument is a finite number or notExamples:bool var0 &lt;- is_finite(4.66); \t// var0 equals truebool var1 &lt;- is_finite(#infinity); \t// var1 equals falseis_gamlPossible use:  is_gaml (any) —&gt;  boolResult:Tests whether the operand is a gaml file.is_geojsonPossible use:  is_geojson (any) —&gt;  boolResult:Tests whether the operand is a geojson file.is_gifPossible use:  is_gif (any) —&gt;  boolResult:Tests whether the operand is a gif file.is_gridPossible use:  is_grid (any) —&gt;  boolResult:Tests whether the operand is a grid file.is_imagePossible use:  is_image (any) —&gt;  boolResult:Tests whether the operand is a image file.is_jsonPossible use:  is_json (any) —&gt;  boolResult:Tests whether the operand is a json file.is_numberPossible use:  is_number (string) —&gt;  bool  is_number (float) —&gt;  boolResult:tests whether the operand represents a numerical valueReturns whether the argument is a real number or notComment:Note that the symbol . should be used for a float value (a string with , will not be considered as a numeric value). Symbols e and E are also accepted. A hexadecimal value should begin with #.Examples:bool var0 &lt;- is_number(\"test\"); \t// var0 equals falsebool var1 &lt;- is_number(\"123.56\"); \t// var1 equals truebool var2 &lt;- is_number(\"-1.2e5\"); \t// var2 equals truebool var3 &lt;- is_number(\"1,2\"); \t// var3 equals falsebool var4 &lt;- is_number(\"#12FA\"); \t// var4 equals truebool var5 &lt;- is_number(4.66); \t// var5 equals truebool var6 &lt;- is_number(#infinity); \t// var6 equals truebool var7 &lt;- is_number(#nan); \t// var7 equals falseis_objPossible use:  is_obj (any) —&gt;  boolResult:Tests whether the operand is a obj file.is_osmPossible use:  is_osm (any) —&gt;  boolResult:Tests whether the operand is a osm file.is_pgmPossible use:  is_pgm (any) —&gt;  boolResult:Tests whether the operand is a pgm file.is_propertyPossible use:  is_property (any) —&gt;  boolResult:Tests whether the operand is a property file.is_RPossible use:  is_R (any) —&gt;  boolResult:Tests whether the operand is a R file.is_shapePossible use:  is_shape (any) —&gt;  boolResult:Tests whether the operand is a shape file.is_skillPossible use:  unknown is_skill string —&gt;  bool  is_skill (unknown , string) —&gt;  boolResult:returns true if the left operand is an agent whose species implements the right-hand skill nameExamples:bool var0 &lt;- agentA is_skill 'moving'; \t// var0 equals trueis_svgPossible use:  is_svg (any) —&gt;  boolResult:Tests whether the operand is a svg file.is_textPossible use:  is_text (any) —&gt;  boolResult:Tests whether the operand is a text file.is_threedsPossible use:  is_threeds (any) —&gt;  boolResult:Tests whether the operand is a threeds file.is_URLPossible use:  is_URL (any) —&gt;  boolResult:Tests whether the operand is a URL file.is_xmlPossible use:  is_xml (any) —&gt;  boolResult:Tests whether the operand is a xml file.json_filePossible use:  json_file (string) —&gt;  fileResult:Constructs a file of type json. Allowed extensions are limited to jsonkappaPossible use:  kappa (list, list, list) —&gt;  float  kappa (list, list, list, list) —&gt;  floatResult:kappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20.kappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories, weights). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20.Examples:kappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3])float var1 &lt;- kappa([1,3,5,1,5],[1,1,1,1,5],[1,3,5]); \t// var1 equals the similarity between 0 and 1float var2 &lt;- kappa([1,1,1,1,5],[1,1,1,1,5],[1,3,5]); \t// var2 equals 1.0kappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3], [1.0, 2.0, 3.0, 1.0, 5.0])kappa_simPossible use:  kappa_sim (list, list, list, list) —&gt;  float  kappa_sim (list, list, list, list, list) —&gt;  floatResult:kappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories). Reference: van Vliet, J., Bregt, A.K. &amp; Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8).kappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories, weights). Reference: van Vliet, J., Bregt, A.K. &amp; Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8)Examples:kappa([cat1,cat1,cat2,cat2,cat2],[cat2,cat1,cat2,cat1,cat3],[cat2,cat1,cat2,cat3,cat3], [cat1,cat2,cat3])kappa([cat1,cat1,cat2,cat2,cat2],[cat2,cat1,cat2,cat1,cat3],[cat2,cat1,cat2,cat3,cat3], [cat1,cat2,cat3],[1.0, 2.0, 3.0, 1.0, 5.0])kmeansPossible use:  list kmeans int —&gt;  list&lt;list&gt;  kmeans (list , int) —&gt;  list&lt;list&gt;  kmeans (list, int, int) —&gt;  list&lt;list&gt;Result:returns the list of clusters (list of instance indices) computed with the kmeans++ algorithm from the first operand data according to the number of clusters to split the data into (k) and the maximum number of iterations to run the algorithm for (If negative, no maximum will be used) (maxIt). Usage: kmeans(data,k,maxit)returns the list of clusters (list of instance indices) computed with the kmeans++ algorithm from the first operand data according to the number of clusters to split the data into (k). Usage: kmeans(data,k)Special cases:  if the lengths of two vectors in the right-hand aren’t equal, returns 0  if the lengths of two vectors in the right-hand aren’t equal, returns 0Examples:kmeans ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],2,10)kmeans ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],2)kurtosisPossible use:  kurtosis (list) —&gt;  floatResult:returns kurtosis value computed from the operand list of valuesSpecial cases:  if the length of the list is lower than 3, returns NaNExamples:kurtosis ([1,2,3,4,5])lastPossible use:  last (string) —&gt;  string  last (container&lt;KeyType,ValueType&gt;) —&gt;  ValueType  int last container —&gt;  container  last (int , container) —&gt;  containerResult:the last element of the operandComment:the last operator behavior depends on the nature of the operandSpecial cases:  if it is a map, last returns the value of the last pair (in insertion order)  if it is a file, last returns the last element of the content of the file (that is also a container)  if it is a population, last returns the last agent of the population  if it is a graph, last returns a list containing the last edge created  if it is a matrix, last returns the element at {length-1,length-1} in the matrix  for a matrix of int or float, it will return 0 if the matrix is empty  for a matrix of object or geometry, it will return nil if the matrix is empty  if it is a string, last returns a string composed of its last character, or an empty string if the operand is emptystring var0 &lt;- last ('abce'); \t// var0 equals 'e'  if it is a list, last returns the last element of the list, or nil if the list is emptyint var1 &lt;- last ([1, 2, 3]); \t// var1 equals 3See also:first,last_index_ofPossible use:  map last_index_of unknown —&gt;  unknown  last_index_of (map , unknown) —&gt;  unknown  string last_index_of string —&gt;  int  last_index_of (string , string) —&gt;  int  species last_index_of unknown —&gt;  int  last_index_of (species , unknown) —&gt;  int  container last_index_of unknown —&gt;  int  last_index_of (container , unknown) —&gt;  int  matrix last_index_of unknown —&gt;  point  last_index_of (matrix , unknown) —&gt;  pointResult:the index of the last occurence of the right operand in the left operand containerComment:The definition of last_index_of and the type of the index depend on the containerSpecial cases:  if the left operand is a species, the last index of an agent is the same as its index  if the left operand is a map, last_index_of returns the index as an int (the key of the pair)unknown var0 &lt;- [1::2, 3::4, 5::4] last_index_of 4; \t// var0 equals 5  if both operands are strings, returns the index within the left-hand string of the rightmost occurrence of the given right-hand stringint var1 &lt;- \"abcabcabc\" last_index_of \"ca\"; \t// var1 equals 5  if the left operand is a list, last_index_of returns the index as an integerint var2 &lt;- [1,2,3,4,5,6] last_index_of 4; \t// var2 equals 3int var3 &lt;- [4,2,3,4,5,4] last_index_of 4; \t// var3 equals 5  if the left operand is a matrix, last_index_of returns the index as a pointpoint var4 &lt;- matrix([[1,2,3],[4,5,4]]) last_index_of 4; \t// var4 equals {1.0,2.0}See also:at, index_of, last_index_of,last_ofSame signification as lastlast_withPossible use:  container last_with any expression —&gt;  unknown  last_with (container , any expression) —&gt;  unknownResult:the last element of the left-hand operand that makes the right-hand operand evaluate to true.Comment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  if the left-hand operand is nil, last_with throws an error.  If there is no element that satisfies the condition, it returns nil  if the left-operand is a map, the keyword each will contain each valueunknown var4 &lt;- [1::2, 3::4, 5::6] last_with (each &gt;= 4); \t// var4 equals 6unknown var5 &lt;- [1::2, 3::4, 5::6].pairs last_with (each.value &gt;= 4); \t// var5 equals 5::6Examples:unknown var0 &lt;- [1,2,3,4,5,6,7,8] last_with (each &gt; 3); \t// var0 equals 8unknown var2 &lt;- g2 last_with (length(g2 out_edges_of each) = 0 ); \t// var2 equals node11unknown var3 &lt;- (list(node) last_with (round(node(each).location.x) &gt; 32); \t// var3 equals node3See also:group_by, first_with, where,layoutPossible use:  graph layout string —&gt;  graph  layout (graph , string) —&gt;  graph  layout (graph, string, int) —&gt;  graph  layout (graph, string, int, map&lt;string,unknown&gt;) —&gt;  graphResult:layouts a GAMA graph.lengthPossible use:  length (string) —&gt;  int  length (container&lt;KeyType,ValueType&gt;) —&gt;  intResult:the number of elements contained in the operandComment:the length operator behavior depends on the nature of the operandSpecial cases:  if it is a population, length returns number of agents of the population  if it is a graph, length returns the number of vertexes or of edges (depending on the way it was created)  if it is a string, length returns the number of charactersint var0 &lt;- length ('I am an agent'); \t// var0 equals 13  if it is a list or a map, length returns the number of elements in the list or mapint var1 &lt;- length([12,13]); \t// var1 equals 2int var2 &lt;- length([]); \t// var2 equals 0  if it is a matrix, length returns the number of cellsint var3 &lt;- length(matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]])); \t// var3 equals 6linePossible use:  line (container&lt;geometry&gt;) —&gt;  geometry  container&lt;geometry&gt; line float —&gt;  geometry  line (container&lt;geometry&gt; , float) —&gt;  geometryResult:A polyline geometry from the given list of points represented as a cylinder of radius r.A polyline geometry from the given list of points.Special cases:  if the operand is nil, returns the point geometry {0,0}  if the operand is composed of a single point, returns a point geometry.  if the operand is nil, returns the point geometry {0,0}  if the operand is composed of a single point, returns a point geometry.  if a radius is added, the given list of points represented as a cylinder of radius rgeometry var0 &lt;- polyline([{0,0}, {0,10}, {10,10}, {10,0}],0.2); \t// var0 equals a polyline geometry composed of the 4 points.Examples:geometry var1 &lt;- polyline([{0,0}, {0,10}, {10,10}, {10,0}]); \t// var1 equals a polyline geometry composed of the 4 points.See also:around, circle, cone, link, norm, point, polygone, rectangle, square, triangle,linkPossible use:  geometry link geometry —&gt;  geometry  link (geometry , geometry) —&gt;  geometryResult:A dynamic line geometry between the location of the two operandsComment:The geometry of the link is a line between the locations of the two operands, which is built and maintained dynamicallySpecial cases:  if one of the operands is nil, link returns a point geometry at the location of the other. If both are null, it returns a point geometry at {0,0}Examples:geometry var0 &lt;- link (geom1,geom2); \t// var0 equals a link geometry between geom1 and geom2.See also:around, circle, cone, line, norm, point, polygon, polyline, rectangle, square, triangle,listPossible use:  list (any) —&gt;  listResult:Casts the operand into the type listlist_withPossible use:  int list_with any expression —&gt;  container  list_with (int , any expression) —&gt;  containerResult:creates a list with a size provided by the first operand, and filled with the second operandComment:Note that the right operand  should be positive, and that the second one is evaluated for each position  in the list.See also:list,lnPossible use:  ln (int) —&gt;  float  ln (float) —&gt;  floatResult:Returns the natural logarithm (base e) of the operand.Special cases:  an exception is raised if the operand is less than zero.Examples:float var0 &lt;- ln(1); \t// var0 equals 0.0float var1 &lt;- ln(exp(1)); \t// var1 equals 1.0See also:exp,load_graph_from_filePossible use:  load_graph_from_file (string) —&gt;  graph  string load_graph_from_file file —&gt;  graph  load_graph_from_file (string , file) —&gt;  graph  string load_graph_from_file string —&gt;  graph  load_graph_from_file (string , string) —&gt;  graph  load_graph_from_file (string, species, species) —&gt;  graph  load_graph_from_file (string, file, species, species) —&gt;  graph  load_graph_from_file (string, string, species, species) —&gt;  graph  load_graph_from_file (string, string, species, species, bool) —&gt;  graphResult:loads a graph from a filereturns a graph loaded from a given file encoded into a given format. The last boolean parameter indicates whether the resulting graph will be considered as spatial or not by GAMAComment:Available formats: “pajek”: Pajek (Slovene word for Spider) is a program, for Windows, for analysis and visualization of large networks. See: http://pajek.imfm.si/doku.php?id=pajek for more details.”lgl”: LGL is a compendium of applications for making the visualization of large networks and trees tractable. See: http://lgl.sourceforge.net/ for more details.”dot”: DOT is a plain text graph description language. It is a simple way of describing graphs that both humans and computer programs can use. See: http://en.wikipedia.org/wiki/DOT_language for more details.”edge”: This format is a simple text file with numeric vertex ids defining the edges.”gexf”: GEXF (Graph Exchange XML Format) is a language for describing complex networks structures, their associated data and dynamics. Started in 2007 at Gephi project by different actors, deeply involved in graph exchange issues, the gexf specifications are mature enough to claim being both extensible and open, and suitable for real specific applications. See: http://gexf.net/format/ for more details.”graphml”: GraphML is a comprehensive and easy-to-use file format for graphs based on XML. See: http://graphml.graphdrawing.org/ for more details.”tlp” or “tulip”: TLP is the Tulip software graph format. See: http://tulip.labri.fr/TulipDrupal/?q=tlp-file-format for more details. “ncol”: This format is used by the Large Graph Layout progra. It is simply a symbolic weighted edge list. It is a simple text file with one edge per line. An edge is defined by two symbolic vertex names separated by whitespace. (The symbolic vertex names themselves cannot contain whitespace.) They might followed by an optional number, this will be the weight of the edge. See: http://bioinformatics.icmb.utexas.edu/lgl for more details.The map operand should includes following elements:Available formats: “pajek”: Pajek (Slovene word for Spider) is a program, for Windows, for analysis and visualization of large networks. See: http://pajek.imfm.si/doku.php?id=pajek for more details.”lgl”: LGL is a compendium of applications for making the visualization of large networks and trees tractable. See: http://lgl.sourceforge.net/ for more details.”dot”: DOT is a plain text graph description language. It is a simple way of describing graphs that both humans and computer programs can use. See: http://en.wikipedia.org/wiki/DOT_language for more details.”edge”: This format is a simple text file with numeric vertex ids defining the edges.”gexf”: GEXF (Graph Exchange XML Format) is a language for describing complex networks structures, their associated data and dynamics. Started in 2007 at Gephi project by different actors, deeply involved in graph exchange issues, the gexf specifications are mature enough to claim being both extensible and open, and suitable for real specific applications. See: http://gexf.net/format/ for more details.”graphml”: GraphML is a comprehensive and easy-to-use file format for graphs based on XML. See: http://graphml.graphdrawing.org/ for more details.”tlp” or “tulip”: TLP is the Tulip software graph format. See: http://tulip.labri.fr/TulipDrupal/?q=tlp-file-format for more details. “ncol”: This format is used by the Large Graph Layout progra. It is simply a symbolic weighted edge list. It is a simple text file with one edge per line. An edge is defined by two symbolic vertex names separated by whitespace. (The symbolic vertex names themselves cannot contain whitespace.) They might followed by an optional number, this will be the weight of the edge. See: http://bioinformatics.icmb.utexas.edu/lgl for more details.The map operand should includes following elements:Special cases:  “format”: the format of the file  “filename”: the filename of the file containing the network  “edges_species”: the species of edges  “vertices_specy”: the species of vertices  “format”: the format of the file  “filename”: the filename of the file containing the network  “edges_species”: the species of edges  “vertices_specy”: the species of vertices  “format”: the format of the file, “file”: the file containing the network, “edges_species”: the species of edges, “vertices_specy”: the species of verticesgraph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- load_graph_from_file(\t\t\t\"pajek\",\t\t\t\"example_of_Pajek_file\",\t\t\tmyVertexSpecy,\t\t\tmyEdgeSpecy );  “filename”: the filename of the file containing the network, “edges_species”: the species of edges, “vertices_specy”: the species of verticesgraph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- load_graph_from_file(\t\t\t\"pajek\",\t\t\t\"./example_of_Pajek_file\",\t\t\tmyVertexSpecy,\t\t\tmyEdgeSpecy );  “file”: the file containing the networkgraph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- load_graph_from_file(\t\t\t\"pajek\",\t\t\t\"example_of_Pajek_file\");  “format”: the format of the file, “file”: the file containing the networkgraph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- load_graph_from_file(\t\t\t\"pajek\",\t\t\t\"example_of_Pajek_file\");  “format”: the format of the file, “filename”: the filename of the file containing the networkgraph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- load_graph_from_file(\t\t\t\"pajek\",\t\t\t\"example_of_Pajek_file\");Examples:graph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- load_graph_from_file(\t\t\t\"pajek\",\t\t\t\"./example_of_Pajek_file\",\t\t\tmyVertexSpecy,\t\t\tmyEdgeSpecy);graph&lt;myVertexSpecy,myEdgeSpecy&gt; myGraph &lt;- load_graph_from_file(\t\t\t\"pajek\",\t\t\t\"./example_of_Pajek_file\",\t\t\tmyVertexSpecy,\t\t\tmyEdgeSpecy , true);load_shortest_pathsPossible use:  graph load_shortest_paths matrix —&gt;  graph  load_shortest_paths (graph , matrix) —&gt;  graphResult:put in the graph cache the computed shortest paths contained in the matrix (rows: source, columns: target)Examples:graph var0 &lt;- load_shortest_paths(shortest_paths_matrix); \t// var0 equals return my_graph with all the shortest paths computedlogPossible use:  log (float) —&gt;  float  log (int) —&gt;  floatResult:Returns the logarithm (base 10) of the operand.Special cases:  an exception is raised if the operand is equals or less than zero.Examples:float var0 &lt;- log(10); \t// var0 equals 1.0float var1 &lt;- log(1); \t// var1 equals 0.0See also:ln,lower_casePossible use:  lower_case (string) —&gt;  stringResult:Converts all of the characters in the string operand to lower caseExamples:string var0 &lt;- lower_case(\"Abc\"); \t// var0 equals 'abc'See also:upper_case,mapPossible use:  map (any) —&gt;  mapResult:Casts the operand into the type mapmasked_byPossible use:  geometry masked_by container&lt;geometry&gt; —&gt;  geometry  masked_by (geometry , container&lt;geometry&gt;) —&gt;  geometry  masked_by (geometry, container&lt;geometry&gt;, int) —&gt;  geometryExamples:geometry var0 &lt;- perception_geom masked_by obstacle_list; \t// var0 equals the geometry representing the part of perception_geom visible from the agent position considering the list of obstacles obstacle_list.geometry var1 &lt;- perception_geom masked_by obstacle_list; \t// var1 equals the geometry representing the part of perception_geom visible from the agent position considering the list of obstacles obstacle_list.materialPossible use:  float material float —&gt;  msi.gama.util.GamaMaterial  material (float , float) —&gt;  msi.gama.util.GamaMaterialResult:ReturnsExamples:See also:,matrixPossible use:  matrix (any) —&gt;  matrixResult:Casts the operand into the type matrixmatrix_withPossible use:  point matrix_with any expression —&gt;  matrix  matrix_with (point , any expression) —&gt;  matrixResult:creates a matrix with a size provided by the first operand, and filled with the second operandComment:Note that both components of the right operand point should be positive, otherwise an exception is raised.See also:matrix, as_matrix,maxPossible use:  max (container) —&gt;  unknownResult:the maximum element found in the operandComment:the max operator behavior depends on the nature of the operandSpecial cases:  if it is a population of a list of other type: max transforms all elements into integer and returns the maximum of them  if it is a map, max returns the maximum among the list of all elements value  if it is a file, max returns the maximum of the content of the file (that is also a container)  if it is a graph, max returns the maximum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)  if it is a matrix of int, float or object, max returns the maximum of all the numerical elements (thus all elements for integer and float matrices)  if it is a matrix of geometry, max returns the maximum of the list of the geometries  if it is a matrix of another type, max returns the maximum of the elements transformed into float  if it is a list of int of float, max returns the maximum of all the elementsunknown var0 &lt;- max ([100, 23.2, 34.5]); \t// var0 equals 100.0  if it is a list of points: max returns the maximum of all points as a point (i.e. the point with the greatest coordinate on the x-axis, in case of equality the point with the greatest coordinate on the y-axis is chosen. If all the points are equal, the first one is returned. )unknown var1 &lt;- max([{1.0,3.0},{3.0,5.0},{9.0,1.0},{7.0,8.0}]); \t// var1 equals {9.0,1.0}See also:min,max_ofPossible use:  container max_of any expression —&gt;  unknown  max_of (container , any expression) —&gt;  unknownResult:the maximum value of the right-hand expression evaluated on each of the elements of the left-hand operandComment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  As of GAMA 1.6, if the left-hand operand is nil or empty, max_of throws an error  if the left-operand is a map, the keyword each will contain each valueunknown var5 &lt;- [1::2, 3::4, 5::6] max_of (each + 3); \t// var5 equals 6Examples:unknown var1 &lt;- [1,2,4,3,5,7,6,8] max_of (each * 100 ); \t// var1 equals 800graph g2 &lt;- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);unknown var3 &lt;- g2.vertices max_of (g2 degree_of( each )); \t// var3 equals 2unknown var4 &lt;- (list(node) max_of (round(node(each).location.x)); \t// var4 equals 96See also:min_of,maximal_cliques_ofPossible use:  maximal_cliques_of (graph) —&gt;  list&lt;list&gt;Result:returns the maximal cliques of a graph using the Bron-Kerbosch clique detection algorithm: A clique is maximal if it is impossible to enlarge it by adding another vertex from the graph. Note that a maximal clique is not necessarily the biggest clique in the graph.Examples:graph my_graph &lt;- graph([]);list&lt;list&gt; var1 &lt;- maximal_cliques_of (my_graph); \t// var1 equals the list of all the maximal cliques as listSee also:biggest_cliques_of,meanPossible use:  mean (container) —&gt;  unknownResult:the mean of all the elements of the operandComment:the elements of the operand are summed (see sum for more details about the sum of container elements ) and then the sum value is divided by the number of elements.Special cases:  if the container contains points, the result will be a point. If the container contains rgb values, the result will be a rgb colorExamples:unknown var0 &lt;- mean ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 5.125 See also:sum,mean_deviationPossible use:  mean_deviation (container) —&gt;  floatResult:the deviation from the mean of all the elements of the operand. See Mean_deviation for more details.Comment:The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.Examples:float var0 &lt;- mean_deviation ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 1.125See also:mean, standard_deviation,mean_ofPossible use:  container mean_of any expression —&gt;  unknown  mean_of (container , any expression) —&gt;  unknownResult:the mean of the right-hand expression evaluated on each of the elements of the left-hand operandComment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  if the left-operand is a map, the keyword each will contain each valueunknown var2 &lt;- [1::2, 3::4, 5::6] mean_of (each); \t// var2 equals 4Examples:unknown var1 &lt;- [1,2] mean_of (each * 10 ); \t// var1 equals 15See also:min_of, max_of, sum_of, product_of,meanRPossible use:  meanR (container) —&gt;  unknownResult:returns the mean value of given vector (right-hand operand) in given variable  (left-hand operand).Examples:list&lt;int&gt; X &lt;- [2, 3, 1];int var1 &lt;- meanR(X); \t// var1 equals 2medianPossible use:  median (container) —&gt;  unknownResult:the median of all the elements of the operand.Special cases:  if the container contains points, the result will be a point. If the container contains rgb values, the result will be a rgb colorExamples:unknown var0 &lt;- median ([4.5, 3.5, 5.5, 3.4, 7.0]); \t// var0 equals 5.0See also:mean,messagePossible use:  message (unknown) —&gt;  msi.gama.extensions.messaging.GamaMessageResult:to be addedmilliseconds_betweenPossible use:  date milliseconds_between date —&gt;  float  milliseconds_between (date , date) —&gt;  floatResult:Provide the exact number of milliseconds between two dates. This number can be positive or negative (if the second operand is smaller than the first one)Examples:milliseconds_between(d1, d2) -: 10 minPossible use:  min (container) —&gt;  unknownResult:the minimum element found in the operand.Comment:the min operator behavior depends on the nature of the operandSpecial cases:  if it is a list of points: min returns the minimum of all points as a point (i.e. the point with the smallest coordinate on the x-axis, in case of equality the point with the smallest coordinate on the y-axis is chosen. If all the points are equal, the first one is returned. )  if it is a population of a list of other types: min transforms all elements into integer and returns the minimum of them  if it is a map, min returns the minimum among the list of all elements value  if it is a file, min returns the minimum of the content of the file (that is also a container)  if it is a graph, min returns the minimum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)  if it is a matrix of int, float or object, min returns the minimum of all the numerical elements (thus all elements for integer and float matrices)  if it is a matrix of geometry, min returns the minimum of the list of the geometries  if it is a matrix of another type, min returns the minimum of the elements transformed into float  if it is a list of int or float: min returns the minimum of all the elementsunknown var0 &lt;- min ([100, 23.2, 34.5]); \t// var0 equals 23.2See also:max,min_ofPossible use:  container min_of any expression —&gt;  unknown  min_of (container , any expression) —&gt;  unknownResult:the minimum value of the right-hand expression evaluated on each of the elements of the left-hand operandComment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  if the left-hand operand is nil or empty, min_of throws an error  if the left-operand is a map, the keyword each will contain each valueunknown var5 &lt;- [1::2, 3::4, 5::6] min_of (each + 3); \t// var5 equals 5Examples:unknown var1 &lt;- [1,2,4,3,5,7,6,8] min_of (each * 100 ); \t// var1 equals 100graph g2 &lt;- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);unknown var3 &lt;- g2 min_of (length(g2 out_edges_of each) ); \t// var3 equals 0unknown var4 &lt;- (list(node) min_of (round(node(each).location.x)); \t// var4 equals 4See also:max_of,minus_daysPossible use:  date minus_days int —&gt;  date  minus_days (date , int) —&gt;  dateResult:Subtract a given number of days from a dateExamples:date1 minus_days 20minus_hoursPossible use:  date minus_hours int —&gt;  date  minus_hours (date , int) —&gt;  dateResult:Remove a given number of hours from a dateExamples:date1 minus_hours 15 // equivalent to date1 - 15 #hminus_minutesPossible use:  date minus_minutes int —&gt;  date  minus_minutes (date , int) —&gt;  dateResult:Subtract a given number of minutes from a dateExamples:date1 minus_minutes 5 // equivalent to date1 - 5#mnminus_monthsPossible use:  date minus_months int —&gt;  date  minus_months (date , int) —&gt;  dateResult:Subtract a given number of months from a dateExamples:date1 minus_months 5minus_msPossible use:  date minus_ms int —&gt;  date  minus_ms (date , int) —&gt;  dateResult:Remove a given number of milliseconds from a dateExamples:date1 minus_ms 15 // equivalent to date1 - 15 #msminus_secondsSame signification as -minus_weeksPossible use:  date minus_weeks int —&gt;  date  minus_weeks (date , int) —&gt;  dateResult:Subtract a given number of weeks from a dateExamples:date1 minus_weeks 15minus_yearsPossible use:  date minus_years int —&gt;  date  minus_years (date , int) —&gt;  dateResult:Subtract a given number of year from a dateExamples:date1 minus_years 3modPossible use:  int mod int —&gt;  int  mod (int , int) —&gt;  intResult:Returns the remainder of the integer division of the left-hand operand by the right-hand operand.Special cases:  if operands are float, they are truncated  if the right-hand operand is equal to zero, raises an exception.Examples:int var0 &lt;- 40 mod 3; \t// var0 equals 1See also:div,months_betweenPossible use:  date months_between date —&gt;  int  months_between (date , date) —&gt;  intResult:Provide the exact number of months between two dates. This number can be positive or negative (if the second operand is smaller than the first one)Examples:months_between(d1, d2) -: 10 moranPossible use:  list&lt;float&gt; moran matrix&lt;float&gt; —&gt;  float  moran (list&lt;float&gt; , matrix&lt;float&gt;) —&gt;  floatSpecial cases:  return the Moran Index of the given list of interest points (list of floats) and the weight matrix (matrix of float)float var0 &lt;- moran([1.0, 0.5, 2.0], weight_matrix); \t// var0 equals the Moran index computedmulPossible use:  mul (container) —&gt;  unknownResult:the product of all the elements of the operandComment:the mul operator behavior depends on the nature of the operandSpecial cases:  if it is a list of points: mul returns the product of all points as a point (each coordinate is the product of the corresponding coordinate of each element)  if it is a list of other types: mul transforms all elements into integer and multiplies them  if it is a map, mul returns the product of the value of all elements  if it is a file, mul returns the product of the content of the file (that is also a container)  if it is a graph, mul returns the product of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)  if it is a matrix of int, float or object, mul returns the product of all the numerical elements (thus all elements for integer and float matrices)  if it is a matrix of geometry, mul returns the product of the list of the geometries  if it is a matrix of other types: mul transforms all elements into float and multiplies them  if it is a list of int or float: mul returns the product of all the elementsunknown var0 &lt;- mul ([100, 23.2, 34.5]); \t// var0 equals 80040.0See also:sum,",
        "url":"/wiki/OperatorsDM.html"
      }
      ,
    
      "wiki-operatorsnz-html": {
        "title": "Operators (N to Z)",
        "content": "#Operators (N to Z)This file is automatically generated from java files. Do Not Edit It.DefinitionOperators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function.Most of them use a classical prefixed functional syntax (i.e. operator_name(operand1, operand2, operand3), see below), with the exception of arithmetic (e.g. +, /), logical (and, or), comparison (e.g. &gt;, &lt;), access (., [..]) and pair (::) operators, which require an infixed notation (i.e. operand1 operator_symbol operand1).The ternary functional if-else operator, ? :, uses a special infixed syntax composed with two symbols (e.g. operand1 ? operand2 : operand3). Two unary operators (- and !) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g. ` - 10, ! (operand1 or operand2)`).Finally, special constructor operators ({...} for constructing points, [...] for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. {1,2,3}, [operand1, operand2, ..., operandn] or [key1::value1, key2::value2... keyn::valuen]).With the exception of these special cases above, the following rules apply to the syntax of operators:  if they only have one operand, the functional prefixed syntax is mandatory (e.g. operator_name(operand1))  if they have two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2)) or the infixed syntax (e.g. operand1 operator_name operand2) can be used.  if they have more than two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2, ..., operand)) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. operand1 operator_name(operand2, ..., operand)) can be used.All of these alternative syntaxes are completely equivalent.Operators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.Priority between operatorsThe priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.GAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely:  the constructor operators, like ::, used to compose pairs of operands, have the lowest priority of all operators (e.g. a &gt; b :: b &gt; c will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, [a &gt; 10, b &gt; 5] will return a list of boolean values.  it is followed by the ?: operator, the functional if-else (e.g. ` a &gt; b ? a + 10 : a - 10` will return the result of the if-else).  next are the logical operators, and and or (e.g. a &gt; b or b &gt; c will return the value of the test)  next are the comparison operators (i.e. &gt;, &lt;, &lt;=, &gt;=, =, !=)  next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)  next the unary operators - and !  next the access operators . and [] (e.g. {1,2,3}.x &gt; 20 + {4,5,6}.y will return the result of the comparison between the x and y ordinates of the two points)  and finally the functional operators, which have the highest priority of all.Using actions as operatorsActions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.For instance, if the following species is defined:species spec1 {        int min(int x, int y) {                return x &gt; y ? x : y;        }}Any agent instance of spec1 can use min as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:global {        init {                create spec1;                spec1 my_agent &lt;- spec1[0];                int the_min &lt;- my_agent min(10,20); // or min(my_agent, 10, 20);        }}If the action doesn’t have any operands, the syntax to use is my_agent the_action(). Finally, if it does not return a value, it might still be used but is considering as returning a value of type unknown (e.g. unknown result &lt;- my_agent the_action(op1, op2);).Note that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).Table of ContentsOperators by categories3Dbox, cone3D, cube, cylinder, dem, hexagon, pyramid, rgb_to_xyz, set_z, sphere, teapot,Arithmetic operators-, /, [^](OperatorsAC#^), [](OperatorsAC#), +, abs, acos, asin, atan, atan2, ceil, cos, cos_rad, div, even, exp, fact, floor, hypot, is_finite, is_number, ln, log, mod, round, signum, sin, sin_rad, sqrt, tan, tan_rad, tanh, with_precision,BDIand, eval_when, get_about, get_agent, get_agent_cause, get_decay, get_dominance, get_familiarity, get_intensity, get_lifetime, get_liking, get_praiseworthiness, get_priority, get_solidarity, get_super_intention, new_emotion, new_predicate, new_social_link, or, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_liking, set_solidarity, set_truth, with_lifetime, with_praiseworthiness, with_priority, with_values,Casting operatorsas, as_int, as_matrix, font, is, is_skill, list_with, matrix_with, species, to_gaml, topology,Color-related operators-, /, [](OperatorsAC#), +, blend, brewer_colors, brewer_palettes, grayscale, hsb, mean, median, rgb, rnd_color, sum,Comparison operators!=, &lt;, &lt;=, =, &gt;, &gt;=, between,Containers-related operators-, ::, +, accumulate, among, at, collect, contains, contains_all, contains_any, count, distinct, empty, every, first, first_with, get, group_by, in, index_by, inter, interleave, internal_at, internal_integrated_value, last, last_with, length, max, max_of, mean, mean_of, median, min, min_of, mul, one_of, product_of, range, reverse, shuffle, sort_by, sum, sum_of, union, variance_of, where, with_max_of, with_min_of,Date-related operators-, !=, +, &lt;, &lt;=, =, &gt;, &gt;=, after, before, between, every, milliseconds_between, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_weeks, minus_years, months_between, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_weeks, plus_years, since, to, until, years_between,DatesDriving operatorsas_driving_graph,edgeedge_between,EDP-related operatorsdiff, diff2, internal_zero_order_equation,Files-related operatorscrs, file, file_exists, folder, get, new_folder, osm_file, read, writable,FIPA-related operatorsconversation, message,Graphs-related operatorsadd_edge, add_node, adjacency, agent_from_geometry, all_pairs_shortest_path, alpha_index, as_distance_graph, as_edge_graph, as_intersection_graph, as_path, beta_index, betweenness_centrality, biggest_cliques_of, connected_components_of, connectivity_index, contains_edge, contains_vertex, degree_of, directed, edge, edge_between, edge_betweenness, edges, gamma_index, generate_barabasi_albert, generate_complete_graph, generate_watts_strogatz, grid_cells_to_graph, in_degree_of, in_edges_of, layout, load_graph_from_file, load_shortest_paths, maximal_cliques_of, nb_cycles, neighbors_of, node, nodes, out_degree_of, out_edges_of, path_between, paths_between, predecessors_of, remove_node_from, rewire_n, source_of, spatial_graph, successors_of, sum, target_of, undirected, use_cache, weight_of, with_optimizer_type, with_weights,Grid-related operatorsas_4_grid, as_grid, as_hexagonal_grid, grid_at, path_between,Iterator operatorsaccumulate, as_map, collect, count, distribution_of, distribution_of, distribution_of, distribution2d_of, distribution2d_of, distribution2d_of, first_with, frequency_of, group_by, index_by, last_with, max_of, mean_of, min_of, product_of, sort_by, sum_of, variance_of, where, with_max_of, with_min_of,List-related operatorscopy_between, index_of, last_index_of,Logical operators:, !, ?, and, or,Map comparaison operatorsfuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,Map-related operatorsas_map, index_of, last_index_of,Materialmaterial,Matrix-related operators-, /, ., [](OperatorsAC#), +, append_horizontally, append_vertically, column_at, columns_list, determinant, eigenvalues, index_of, inverse, last_index_of, row_at, rows_list, shuffle, trace, transpose,multicriteria operatorselectre_DM, evidence_theory_DM, promethee_DM, weighted_means_DM,Path-related operatorsagent_from_geometry, all_pairs_shortest_path, as_path, load_shortest_paths, path_between, path_to, paths_between, use_cache,Points-related operators-, /, [](OperatorsAC#), +, &lt;, &lt;=, &gt;, &gt;=, add_point, angle_between, any_location_in, centroid, closest_points_with, farthest_point_to, grid_at, norm, point, points_along, points_at, points_on,Random operatorsbinomial, flip, gauss, poisson, rnd, rnd_choice, sample, shuffle, skew_gauss, truncated_gauss,ReverseOperatorsShapearc, box, circle, cone, cone3D, cross, cube, curve, cylinder, ellipse, envelope, geometry_collection, hexagon, line, link, plan, polygon, polyhedron, pyramid, rectangle, sphere, square, squircle, teapot, triangle,Spatial operators-, [](OperatorsAC#), +, add_point, agent_closest_to, agent_farthest_to, agents_at_distance, agents_inside, agents_overlapping, angle_between, any_location_in, arc, around, as_4_grid, as_grid, as_hexagonal_grid, at_distance, at_location, box, centroid, circle, clean, closest_points_with, closest_to, cone, cone3D, convex_hull, covers, cross, crosses, crs, CRS_transform, cube, curve, cylinder, dem, direction_between, disjoint_from, distance_between, distance_to, ellipse, envelope, farthest_point_to, farthest_to, geometry_collection, gini, hexagon, hierarchical_clustering, IDW, inside, inter, intersects, line, link, masked_by, moran, neighbors_at, neighbors_of, overlapping, overlaps, partially_overlaps, path_between, path_to, plan, points_along, points_at, points_on, polygon, polyhedron, pyramid, rectangle, rgb_to_xyz, rotated_by, round, scaled_to, set_z, simple_clustering_by_distance, simplification, skeletonize, smooth, sphere, split_at, split_geometry, split_lines, square, squircle, teapot, to_GAMA_CRS, to_rectangles, to_squares, touches, towards, transformed_by, translated_by, triangle, triangulate, union, using, voronoi, with_precision, without_holes,Spatial properties operatorscovers, crosses, intersects, partially_overlaps, touches,Spatial queries operatorsagent_closest_to, agent_farthest_to, agents_at_distance, agents_inside, agents_overlapping, at_distance, closest_to, farthest_to, inside, neighbors_at, neighbors_of, overlapping,Spatial relations operatorsdirection_between, distance_between, distance_to, path_between, path_to, towards,Spatial statistical operatorshierarchical_clustering, simple_clustering_by_distance,Spatial transformations operators-, [](OperatorsAC#), +, as_4_grid, as_grid, as_hexagonal_grid, at_location, clean, convex_hull, CRS_transform, rotated_by, scaled_to, simplification, skeletonize, smooth, split_geometry, split_lines, to_GAMA_CRS, to_rectangles, to_squares, transformed_by, translated_by, triangulate, voronoi, without_holes,Species-related operatorsindex_of, last_index_of, of_generic_species, of_species,Statistical operatorsbuild, corR, dbscan, distribution_of, distribution2d_of, frequency_of, gamma_rnd, geometric_mean, gini, harmonic_mean, hierarchical_clustering, kmeans, kurtosis, max, mean, mean_deviation, meanR, median, min, moran, mul, predict, simple_clustering_by_distance, skewness, standard_deviation, sum, variance,Strings-related operators+, &lt;, &lt;=, &gt;, &gt;=, at, char, contains, contains_all, contains_any, copy_between, date, empty, first, in, indented_by, index_of, is_number, last, last_index_of, length, lower_case, replace, replace_regex, reverse, sample, shuffle, split_with, string, upper_case,System., command, copy, dead, eval_gaml, every, user_input,Time-related operatorsdate, string,Types-related operatorsUser control operatorsuser_input,Operatorsnb_cyclesPossible use:  nb_cycles (graph) —&gt;  intResult:returns the maximum number of independent cycles in a graph. This number (u) is estimated through the number of nodes (v), links (e) and of sub-graphs (p): u = e - v + p.Examples:graph graphEpidemio &lt;- graph([]);int var1 &lt;- nb_cycles(graphEpidemio); \t// var1 equals the number of cycles in the graphSee also:alpha_index, beta_index, gamma_index, connectivity_index,neighbors_atPossible use:  geometry neighbors_at float —&gt;  container  neighbors_at (geometry , float) —&gt;  containerResult:a list, containing all the agents of the same species than the left argument (if it is an agent) located at a distance inferior or equal to the right-hand operand to the left-hand operand (geometry, agent, point).Comment:The topology used to compute the neighborhood  is the one of the left-operand if this one is an agent; otherwise the one of the agent applying the operator.Examples:container var0 &lt;- (self neighbors_at (10)); \t// var0 equals all the agents located at a distance lower or equal to 10 to the agent applying the operator.See also:neighbors_of, closest_to, overlapping, agents_overlapping, agents_inside, agent_closest_to, at_distance,neighbors_ofPossible use:  graph neighbors_of unknown —&gt;  container  neighbors_of (graph , unknown) —&gt;  container  topology neighbors_of agent —&gt;  container  neighbors_of (topology , agent) —&gt;  container  neighbors_of (topology, geometry, float) —&gt;  containerResult:a list, containing all the agents of the same species than the argument (if it is an agent) located at a distance inferior or equal to 1 to the right-hand operand agent considering the left-hand operand topology.Special cases:  a list, containing all the agents of the same species than the left argument (if it is an agent) located at a distance inferior or equal to the third argument to the second argument (agent, geometry or point) considering the first operand topology.container var3 &lt;- neighbors_of (topology(self), self,10); \t// var3 equals all the agents located at a distance lower or equal to 10 to the agent applying the operator considering its topology.Examples:container var0 &lt;- graphEpidemio neighbors_of (node(3)); \t// var0 equals [node0,node2]container var1 &lt;- graphFromMap neighbors_of node({12,45}); \t// var1 equals [{1.0,5.0},{34.0,56.0}]container var2 &lt;- topology(self) neighbors_of self; \t// var2 equals returns all the agents located at a distance lower or equal to 1 to the agent applying the operator considering its topology.See also:predecessors_of, successors_of, neighbors_at, closest_to, overlapping, agents_overlapping, agents_inside, agent_closest_to,new_emotionPossible use:  new_emotion (string) —&gt;  emotion  string new_emotion agent —&gt;  emotion  new_emotion (string , agent) —&gt;  emotion  string new_emotion float —&gt;  emotion  new_emotion (string , float) —&gt;  emotion  string new_emotion predicate —&gt;  emotion  new_emotion (string , predicate) —&gt;  emotion  new_emotion (string, float, predicate) —&gt;  emotion  new_emotion (string, float, float) —&gt;  emotion  new_emotion (string, predicate, agent) —&gt;  emotion  new_emotion (string, float, agent) —&gt;  emotion  new_emotion (string, float, float, agent) —&gt;  emotion  new_emotion (string, float, predicate, float) —&gt;  emotion  new_emotion (string, float, predicate, agent) —&gt;  emotion  new_emotion (string, float, predicate, float, agent) —&gt;  emotionResult:a new emotion with the given properties (name)a new emotion with the given properties (name)a new emotion with the given properties (name,intensity,about)a new emotion with the given properties (name,intensity,decay)a new emotion with the given properties (name)a new emotion with the given properties (name, intensity)a new emotion with the given properties (name,about)a new emotion with the given properties (name)a new emotion with the given properties (name)a new emotion with the given properties (name)a new emotion with the given properties (name)a new emotion with the given properties (name)Examples:emotion(\"joy\",12.3,eatFood,4)emotion(\"joy\",12.3,eatFood,4)emotion(\"joy\",12.3,eatFood)emotion(\"joy\",12.3,4)emotion(\"joy\",12.3,eatFood,4)emotion(\"joy\",12.3)emotion(\"joy\",eatFood)emotion(\"joy\")emotion(\"joy\",12.3,eatFood,4)emotion(\"joy\",12.3,eatFood,4)emotion(\"joy\",12.3,eatFood,4)emotion(\"joy\",12.3,eatFood,4)new_folderPossible use:  new_folder (string) —&gt;  fileResult:opens an existing repository or create a new folder if it does not exist.Special cases:  If the specified string does not refer to an existing repository, the repository is created.  If the string refers to an existing file, an exception is risen.Examples:file dirNewT &lt;- new_folder(\"incl/\");   \t// dirNewT represents the repository \"../incl/\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// eventually creates the directory ../inclSee also:folder, file,new_predicatePossible use:  new_predicate (string) —&gt;  predicate  string new_predicate agent —&gt;  predicate  new_predicate (string , agent) —&gt;  predicate  string new_predicate float —&gt;  predicate  new_predicate (string , float) —&gt;  predicate  string new_predicate int —&gt;  predicate  new_predicate (string , int) —&gt;  predicate  string new_predicate map —&gt;  predicate  new_predicate (string , map) —&gt;  predicate  string new_predicate bool —&gt;  predicate  new_predicate (string , bool) —&gt;  predicate  new_predicate (string, map, float) —&gt;  predicate  new_predicate (string, map, int) —&gt;  predicate  new_predicate (string, map, agent) —&gt;  predicate  new_predicate (string, map, bool) —&gt;  predicate  new_predicate (string, map, int, bool) —&gt;  predicate  new_predicate (string, map, bool, agent) —&gt;  predicate  new_predicate (string, map, float, int) —&gt;  predicate  new_predicate (string, map, int, agent) —&gt;  predicate  new_predicate (string, map, float, agent) —&gt;  predicate  new_predicate (string, map, float, bool) —&gt;  predicate  new_predicate (string, map, float, int, bool) —&gt;  predicate  new_predicate (string, map, int, bool, agent) —&gt;  predicate  new_predicate (string, map, float, bool, agent) —&gt;  predicate  new_predicate (string, map, float, int, agent) —&gt;  predicate  new_predicate (string, map, float, int, bool, agent) —&gt;  predicateResult:a new predicate with the given properties (name, values, lifetime, is_true)a new predicate with the given properties (name, values, priority)a new predicate with the given properties (name, values, priority, lifetime, is_true, agentCause)a new predicate with the given properties (name, values, is_true, agentCause)a new predicate with the given properties (name, values, lifetime)a new predicate with the given properties (name, values, priority, lifetime, is_true)a new predicate with the given properties (name, values, lifetime, is_true, agentCause)a new predicate with the given is_true (name, priority)a new predicate with the given is_true (name, lifetime)a new predicate with the given properties (name, values)a new predicate with the given properties (name, values, lifetime)a new predicate with the given is_true (name, is_true)a new predicate with the given properties (name, values, priority,lifetime)a new predicate with the given properties (name, values, priority, is_true, agentCause)a new predicate with the given properties (name, values, \tagentCause)a new predicate with the given properties (name, values, lifetime, agentCause)a new predicate with the given properties (name)a new predicate with the given properties (name, values, priority, agentCause)a new predicate with the given properties (name, values, priority, is_true)a new predicate with the given properties (name, values, priority, lifetime, agentCause)a new predicate with the given properties (name, values, is_true)Examples:predicate(\"people to meet\", [\"time\"::10], 10,true)predicate(\"people to meet\", people1, [\"time\"::10])predicate(\"people to meet\", [\"time\"::10],2.0,10, true, agentA)predicate(\"people to meet\", [\"time\"::10], true, agentA)predicate(\"people to meet\", [\"time\"::10], true)predicate(\"people to meet\", [\"time\"::10],2.0,10, true)predicate(\"people to meet\", [\"time\"::10], 10, true, agentA)predicate(\"hasWater\", 2.0 )predicate(\"hasWater\", 10 predicate(\"people to meet\", people1 )predicate(\"people to meet\", [\"time\"::10], true)predicate(\"hasWater\", true)predicate(\"people to meet\", [\"time\"::10], 2.0,10)predicate(\"people to meet\", [\"time\"::10], 2.0, true, agentA)predicate(\"people to meet\", [\"time\"::10], agentA)predicate(\"people to meet\", [\"time\"::10], 10, agentA)predicate(\"people to meet\")predicate(\"people to meet\", [\"time\"::10], 2.0,agentA)predicate(\"people to meet\", [\"time\"::10],2.0, true)predicate(\"people to meet\", [\"time\"::10], 2.0,10,agentA)predicate(\"people to meet\", [\"time\"::10], true)new_social_linkPossible use:  new_social_link (agent) —&gt;  msi.gaml.architecture.simplebdi.SocialLink  new_social_link (agent, float, float, float, float) —&gt;  msi.gaml.architecture.simplebdi.SocialLinkResult:a new social linka new social linkExamples:new_social_link(agentA)new_social_link(agentA,0.0,-0.1,0.2,0.1)nodePossible use:  node (unknown) —&gt;  unknown  unknown node float —&gt;  unknown  node (unknown , float) —&gt;  unknownnodesPossible use:  nodes (container) —&gt;  containernormPossible use:  norm (point) —&gt;  floatResult:the norm of the vector with the coordinates of the point operand.Examples:float var0 &lt;- norm({3,4}); \t// var0 equals 5.0notSame signification as !obj_filePossible use:  obj_file (string) —&gt;  fileResult:Constructs a file of type obj. Allowed extensions are limited to obj, OBJofSame signification as .of_generic_speciesPossible use:  container of_generic_species species —&gt;  container  of_generic_species (container , species) —&gt;  containerResult:a list, containing the agents of the left-hand operand whose species is that denoted by the right-hand operand and whose species extends the right-hand operand speciesExamples:// species test {}// species sous_test parent: test {}container var2 &lt;- [sous_test(0),sous_test(1),test(2),test(3)] of_generic_species test; \t// var2 equals [sous_test0,sous_test1,test2,test3]container var3 &lt;- [sous_test(0),sous_test(1),test(2),test(3)] of_generic_species sous_test; \t// var3 equals [sous_test0,sous_test1]container var4 &lt;- [sous_test(0),sous_test(1),test(2),test(3)] of_species test; \t// var4 equals [test2,test3]container var5 &lt;- [sous_test(0),sous_test(1),test(2),test(3)] of_species sous_test; \t// var5 equals [sous_test0,sous_test1]See also:of_species,of_speciesPossible use:  container of_species species —&gt;  container  of_species (container , species) —&gt;  containerResult:a list, containing the agents of the left-hand operand whose species is the one denoted by the right-hand operand.The expression agents of_species (species self) is equivalent to agents where (species each = species self); however, the advantage of using the first syntax is that the resulting list is correctly typed with the right species, whereas, in the second syntax, the parser cannot determine the species of the agents within the list (resulting in the need to cast it explicitly if it is to be used in an ask statement, for instance).Special cases:  if the right operand is nil, of_species returns the right operandExamples:container var0 &lt;- (self neighbors_at 10) of_species (species (self)); \t// var0 equals all the neighboring agents of the same species.container var1 &lt;- [test(0),test(1),node(1),node(2)] of_species test; \t// var1 equals [test0,test1]See also:of_generic_species,one_ofPossible use:  one_of (container&lt;KeyType,ValueType&gt;) —&gt;  ValueTypeResult:one of the values stored in this container  at a random keyComment:the one_of operator behavior depends on the nature of the operandSpecial cases:  if it is a graph, one_of returns one of the lists of edges  if it is a file, one_of returns one of the elements of the content of the file (that is also a container)  if the operand is empty, one_of returns nil  if it is a list or a matrix, one_of returns one of the values of the list or of the matrixint i &lt;- any ([1,2,3]); \t// i equals 1, 2 or 3string sMat &lt;- one_of(matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]])); \t// sMat equals \"c11\",\"c12\",\"c13\", \"c21\",\"c22\" or \"c23\"  if it is a map, one_of returns one the value of a random pair of the mapint im &lt;- one_of ([2::3, 4::5, 6::7]);\t// im equals 3, 5 or 7bool var6 &lt;- [2::3, 4::5, 6::7].values contains im; \t// var6 equals true  if it is a population, one_of returns one of the agents of the populationbug b &lt;- one_of(bug);  \t// Given a previously defined species bug, b is one of the created bugs, e.g. bug3See also:contains,orPossible use:  bool or any expression —&gt;  bool  or (bool , any expression) —&gt;  boolResult:a bool value, equal to the logical or between the left-hand operand and the right-hand operand.Comment:both operands are always casted to bool before applying the operator. Thus, an expression like 1 or 0 is accepted and returns true.See also:bool, and, !,orPossible use:  predicate or predicate —&gt;  predicate  or (predicate , predicate) —&gt;  predicateResult:create a new predicate from two others by including them as subintentions. It’s an exclusive “or”Examples:predicate1 or predicate2osm_filePossible use:  string osm_file map&lt;string,list&gt; —&gt;  file  osm_file (string , map&lt;string,list&gt;) —&gt;  file  osm_file (string, map&lt;string,list&gt;, int) —&gt;  fileResult:opens a file that a is a kind of OSM file with some filtering.opens a file that a is a kind of OSM file with some filtering, forcing the initial CRS to be the one indicated by the second int parameter (see http://spatialreference.org/ref/epsg/). If this int parameter is equal to 0, the data is considered as already projected.Comment:The file should have a OSM file extension, cf. file type definition for supported file extensions.The file should have a OSM file extension, cf. file type definition for supported file extensions.Special cases:  If the specified string does not refer to an existing OSM file, an exception is risen.  If the specified string does not refer to an existing OSM file, an exception is risen.Examples:file myOSMfile &lt;- osm_file(\"../includes/rouen.osm\", [\"highway\"::[\"primary\",\"motorway\"]]);file myOSMfile2 &lt;- osm_file(\"../includes/rouen.osm\",[\"highway\"::[\"primary\",\"motorway\"]], 0);See also:file,out_degree_ofPossible use:  graph out_degree_of unknown —&gt;  int  out_degree_of (graph , unknown) —&gt;  intResult:returns the out degree of a vertex (right-hand operand) in the graph given as left-hand operand.Examples:int var1 &lt;- graphFromMap out_degree_of (node(3)); \t// var1 equals 4See also:in_degree_of, degree_of,out_edges_ofPossible use:  graph out_edges_of unknown —&gt;  container  out_edges_of (graph , unknown) —&gt;  containerResult:returns the list of the out-edges of a vertex (right-hand operand) in the graph given as left-hand operand.Examples:container var1 &lt;- graphFromMap out_edges_of (node(3)); \t// var1 equals 3See also:in_edges_of,overlappingPossible use:  container&lt;agent&gt; overlapping geometry —&gt;  list&lt;geometry&gt;  overlapping (container&lt;agent&gt; , geometry) —&gt;  list&lt;geometry&gt;Result:A list of agents or geometries among the left-operand list, species or meta-population (addition of species), overlapping the operand (casted as a geometry).Examples:list&lt;geometry&gt; var0 &lt;- [ag1, ag2, ag3] overlapping(self); \t// var0 equals return the agents among ag1, ag2 and ag3 that overlap the shape of the agent applying the operator.(species1 + species2) overlapping selfSee also:neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, agents_overlapping,overlapsPossible use:  geometry overlaps geometry —&gt;  bool  overlaps (geometry , geometry) —&gt;  boolResult:A boolean, equal to true if the left-geometry (or agent/point) overlaps the right-geometry (or agent/point).Special cases:  if one of the operand is null, returns false.  if one operand is a point, returns true if the point is included in the geometryExamples:bool var0 &lt;- polyline([{10,10},{20,20}]) overlaps polyline([{15,15},{25,25}]); \t// var0 equals truebool var1 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var1 equals truebool var2 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps {25,25}; \t// var2 equals falsebool var3 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{35,35},{35,45},{45,45},{45,35}]); \t// var3 equals falsebool var4 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polyline([{10,10},{20,20}]); \t// var4 equals truebool var5 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps {15,15}; \t// var5 equals truebool var6 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{0,0},{0,30},{30,30}, {30,0}]); \t// var6 equals truebool var7 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var7 equals truebool var8 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{10,20},{20,20},{20,30},{10,30}]); \t// var8 equals trueSee also:disjoint_from, crosses, intersects, partially_overlaps, touches,pairPossible use:  pair (any) —&gt;  pairResult:Casts the operand into the type pairpartially_overlapsPossible use:  geometry partially_overlaps geometry —&gt;  bool  partially_overlaps (geometry , geometry) —&gt;  boolResult:A boolean, equal to true if the left-geometry (or agent/point) partially overlaps the right-geometry (or agent/point).Comment:if one geometry operand fully covers the other geometry operand, returns false (contrarily to the overlaps operator).Special cases:  if one of the operand is null, returns false.Examples:bool var0 &lt;- polyline([{10,10},{20,20}]) partially_overlaps polyline([{15,15},{25,25}]); \t// var0 equals truebool var1 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var1 equals truebool var2 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps {25,25}; \t// var2 equals falsebool var3 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{35,35},{35,45},{45,45},{45,35}]); \t// var3 equals falsebool var4 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polyline([{10,10},{20,20}]); \t// var4 equals falsebool var5 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps {15,15}; \t// var5 equals falsebool var6 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{0,0},{0,30},{30,30}, {30,0}]); \t// var6 equals falsebool var7 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var7 equals truebool var8 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{10,20},{20,20},{20,30},{10,30}]); \t// var8 equals falseSee also:disjoint_from, crosses, overlaps, intersects, touches,pathPossible use:  path (any) —&gt;  pathResult:Casts the operand into the type pathpath_betweenPossible use:  topology path_between container&lt;geometry&gt; —&gt;  path  path_between (topology , container&lt;geometry&gt;) —&gt;  path  list&lt;agent&gt; path_between container&lt;geometry&gt; —&gt;  path  path_between (list&lt;agent&gt; , container&lt;geometry&gt;) —&gt;  path  path_between (graph, geometry, geometry) —&gt;  path  path_between (list&lt;agent&gt;, geometry, geometry) —&gt;  path  path_between (topology, geometry, geometry) —&gt;  pathResult:The shortest path between a list of two objects in a graphThe shortest path between two objects according to set of cellsThe shortest path between several objects according to set of cellsExamples:path var0 &lt;- path_between (my_graph, ag1, ag2); \t// var0 equals A path between ag1 and ag2path var1 &lt;- my_topology path_between [ag1, ag2]; \t// var1 equals A path between ag1 and ag2path var2 &lt;- path_between (cell_grid where each.is_free, ag1, ag2); \t// var2 equals A path between ag1 and ag2 passing through the given cell_grid agentspath var3 &lt;- my_topology path_between (ag1, ag2); \t// var3 equals A path between ag1 and ag2path var4 &lt;- path_between (cell_grid where each.is_free, [ag1, ag2, ag3]); \t// var4 equals A path between ag1 and ag2 and ag3 passing through the given cell_grid agentsSee also:towards, direction_to, distance_between, direction_between, path_to, distance_to,path_toPossible use:  geometry path_to geometry —&gt;  path  path_to (geometry , geometry) —&gt;  path  point path_to point —&gt;  path  path_to (point , point) —&gt;  pathResult:A path between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.Examples:path var0 &lt;- ag1 path_to ag2; \t// var0 equals the path between ag1 and ag2 considering the topology of the agent applying the operatorSee also:towards, direction_to, distance_between, direction_between, path_between, distance_to,paths_betweenPossible use:  paths_between (graph, pair, int) —&gt;  list&lt;path&gt;Result:The K shortest paths between a list of two objects in a graphExamples:list&lt;path&gt; var0 &lt;- paths_between(my_graph, ag1:: ag2, 2); \t// var0 equals the 2 shortest paths (ordered by length) between ag1 and ag2percent_absolute_deviationPossible use:  list&lt;float&gt; percent_absolute_deviation list&lt;float&gt; —&gt;  float  percent_absolute_deviation (list&lt;float&gt; , list&lt;float&gt;) —&gt;  floatResult:percent absolute deviation indicator for 2 series of values: percent_absolute_deviation(list_vals_observe,list_vals_sim)Examples:percent_absolute_deviation([200,300,150,150,200],[250,250,100,200,200])pgm_filePossible use:  pgm_file (string) —&gt;  fileResult:Constructs a file of type pgm. Allowed extensions are limited to pgmplanPossible use:  container&lt;geometry&gt; plan float —&gt;  geometry  plan (container&lt;geometry&gt; , float) —&gt;  geometryResult:A polyline geometry from the given list of points.Special cases:  if the operand is nil, returns the point geometry {0,0}  if the operand is composed of a single point, returns a point geometry.Examples:geometry var0 &lt;- polyplan([{0,0}, {0,10}, {10,10}, {10,0}],10); \t// var0 equals a polyline geometry composed of the 4 points with a depth of 10.See also:around, circle, cone, link, norm, point, polygone, rectangle, square, triangle,plus_daysPossible use:  date plus_days int —&gt;  date  plus_days (date , int) —&gt;  dateResult:Add a given number of days to a dateExamples:date1 plus_days 20plus_hoursPossible use:  date plus_hours int —&gt;  date  plus_hours (date , int) —&gt;  dateResult:Add a given number of hours to a dateExamples:date1 plus_hours 15 // equivalent to date1 + 15 #hplus_minutesPossible use:  date plus_minutes int —&gt;  date  plus_minutes (date , int) —&gt;  dateResult:Add a given number of minutes to a dateExamples:date1 plus_minutes 5 // equivalent to date1 + 5 #mnplus_monthsPossible use:  date plus_months int —&gt;  date  plus_months (date , int) —&gt;  dateResult:Add a given number of months to a dateExamples:date1 plus_months 5plus_msPossible use:  date plus_ms int —&gt;  date  plus_ms (date , int) —&gt;  dateResult:Add a given number of milliseconds to a dateExamples:date1 plus_ms 15 // equivalent to date1 + 15 #msplus_secondsSame signification as +plus_weeksPossible use:  date plus_weeks int —&gt;  date  plus_weeks (date , int) —&gt;  dateResult:Add a given number of weeks to a dateExamples:date1 plus_weeks 15plus_yearsPossible use:  date plus_years int —&gt;  date  plus_years (date , int) —&gt;  dateResult:Add a given number of years to a dateExamples:date1 plus_years 3pointPossible use:  float point int —&gt;  point  point (float , int) —&gt;  point  int point float —&gt;  point  point (int , float) —&gt;  point  int point int —&gt;  point  point (int , int) —&gt;  point  float point float —&gt;  point  point (float , float) —&gt;  point  point (float, int, int) —&gt;  point  point (int, int, int) —&gt;  point  point (float, int, float) —&gt;  point  point (int, int, float) —&gt;  point  point (int, float, float) —&gt;  point  point (float, float, float) —&gt;  point  point (float, float, int) —&gt;  pointResult:internal use only. Use the standard construction {x,y} instead.internal use only. Use the standard construction {x,y} instead.internal use only. Use the standard construction {x,y, z} instead.internal use only. Use the standard construction {x,y, z} instead.internal use only. Use the standard construction {x,y, z} instead.internal use only. Use the standard construction {x,y, z} instead.internal use only. Use the standard construction {x,y, z} instead.internal use only. Use the standard construction {x,y} instead.internal use only. Use the standard construction {x,y} instead.internal use only. Use the standard construction {x,y, z} instead.internal use only. Use the standard construction {x,y, z} instead.points_alongPossible use:  geometry points_along list&lt;float&gt; —&gt;  container  points_along (geometry , list&lt;float&gt;) —&gt;  containerResult:A list of points along the operand-geometry given its location in terms of rate of distance from the starting points of the geometry.Examples:container var0 &lt;-  line([{10,10},{80,80}]) points_along ([0.3, 0.5, 0.9]); \t// var0 equals the list of following points: [{31.0,31.0,0.0},{45.0,45.0,0.0},{73.0,73.0,0.0}]See also:closest_points_with, farthest_point_to, points_at, points_on,points_atPossible use:  int points_at float —&gt;  list&lt;point&gt;  points_at (int , float) —&gt;  list&lt;point&gt;Result:A list of left-operand number of points located at a the right-operand distance to the agent location.Examples:list&lt;point&gt; var0 &lt;- 3 points_at(20.0); \t// var0 equals returns [pt1, pt2, pt3] with pt1, pt2 and pt3 located at a distance of 20.0 to the agent locationSee also:any_location_in, any_point_in, closest_points_with, farthest_point_to,points_onPossible use:  geometry points_on float —&gt;  container  points_on (geometry , float) —&gt;  containerResult:A list of points of the operand-geometry distant from each other to the float right-operand .Examples:container var0 &lt;-  square(5) points_on(2); \t// var0 equals a list of points belonging to the exterior ring of the square distant from each other of 2.See also:closest_points_with, farthest_point_to, points_at,poissonPossible use:  poisson (float) —&gt;  intResult:A value from a random variable following a Poisson distribution (with the positive expected number of occurence lambda as operand).Comment:The Poisson distribution is a discrete probability distribution that expresses the probability of a given number of events occurring in a fixed interval of time and/or space if these events occur with a known average rate and independently of the time since the last event, cf. Poisson distribution on Wikipedia.Examples:int var0 &lt;- poisson(3.5); \t// var0 equals a random positive integerSee also:binomial, gauss,polygonPossible use:  polygon (container&lt;agent&gt;) —&gt;  geometryResult:A polygon geometry from the given list of points.Special cases:  if the operand is nil, returns the point geometry {0,0}  if the operand is composed of a single point, returns a point geometry  if the operand is composed of 2 points, returns a polyline geometry.Examples:geometry var0 &lt;- polygon([{0,0}, {0,10}, {10,10}, {10,0}]); \t// var0 equals a polygon geometry composed of the 4 points.See also:around, circle, cone, line, link, norm, point, polyline, rectangle, square, triangle,polyhedronPossible use:  container&lt;geometry&gt; polyhedron float —&gt;  geometry  polyhedron (container&lt;geometry&gt; , float) —&gt;  geometryResult:A polyhedron geometry from the given list of points.Special cases:  if the operand is nil, returns the point geometry {0,0}  if the operand is composed of a single point, returns a point geometry  if the operand is composed of 2 points, returns a polyline geometry.Examples:geometry var0 &lt;- polyhedron([{0,0}, {0,10}, {10,10}, {10,0}],10); \t// var0 equals a polygon geometry composed of the 4 points and of depth 10.See also:around, circle, cone, line, link, norm, point, polyline, rectangle, square, triangle,polylineSame signification as linepolyplanSame signification as planpredecessors_ofPossible use:  graph predecessors_of unknown —&gt;  container  predecessors_of (graph , unknown) —&gt;  containerResult:returns the list of predecessors (i.e. sources of in edges) of the given vertex (right-hand operand) in the given graph (left-hand operand)Examples:container var1 &lt;- graphEpidemio predecessors_of ({1,5}); \t// var1 equals []container var2 &lt;- graphEpidemio predecessors_of node({34,56}); \t// var2 equals [{12;45}]See also:neighbors_of, successors_of,predicatePossible use:  predicate (any) —&gt;  predicateResult:Casts the operand into the type predicatepredictPossible use:  regression predict list&lt;float&gt; —&gt;  float  predict (regression , list&lt;float&gt;) —&gt;  floatResult:returns the value predict by the regression parameters for a given instance. Usage: predict(regression, instance)Examples:predict(my_regression, [1,2,3]productSame signification as mulproduct_ofPossible use:  container product_of any expression —&gt;  unknown  product_of (container , any expression) —&gt;  unknownResult:the product of the right-hand expression evaluated on each of the elements of the left-hand operandComment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  if the left-operand is a map, the keyword each will contain each valueunknown var2 &lt;- [1::2, 3::4, 5::6] product_of (each); \t// var2 equals 48Examples:unknown var1 &lt;- [1,2] product_of (each * 10 ); \t// var1 equals 200See also:min_of, max_of, sum_of, mean_of,promethee_DMPossible use:  list&lt;list&gt; promethee_DM list&lt;map&lt;string,object&gt;&gt; —&gt;  int  promethee_DM (list&lt;list&gt; , list&lt;map&lt;string,object&gt;&gt;) —&gt;  intResult:The index of the best candidate according to the Promethee II method. This method is based on a comparison per pair of possible candidates along each criterion: all candidates are compared to each other by pair and ranked. More information about this method can be found in [http://www.sciencedirect.com/science?_ob=ArticleURL&amp;_udi=B6VCT-4VF56TV-1&amp;_user=10&amp;_coverDate=01%2F01%2F2010&amp;_rdoc=1&amp;_fmt=high&amp;_orig=search&amp;_sort=d&amp;_docanchor=&amp;view=c&amp;_searchStrId=1389284642&amp;_rerunOrigin=google&amp;_acct=C000050221&amp;_version=1&amp;_urlVersion=0&amp;_userid=10&amp;md5=d334de2a4e0d6281199a39857648cd36 Behzadian, M., Kazemzadeh, R., Albadvi, A., M., A.: PROMETHEE: A comprehensive literature review on methodologies and applications. European Journal of Operational Research(2009)]. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains fours elements: a name, a weight, a preference value (p) and an indifference value (q). The preference value represents the threshold from which the difference between two criterion values allows to prefer one vector of values over another. The indifference value represents the threshold from which the difference between two criterion values is considered significant.Special cases:  returns -1 is the list of candidates is nil or emptyExamples:int var0 &lt;- promethee_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"weight\" :: 2.0,\"p\"::0.5, \"q\"::0.0, \"s\"::1.0, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: 1.0,\"p\"::0.5, \"q\"::0.0, \"s\"::1.0, \"maximize\" :: false]]); \t// var0 equals 1See also:weighted_means_DM, electre_DM, evidence_theory_DM,property_filePossible use:  property_file (string) —&gt;  fileResult:Constructs a file of type property. Allowed extensions are limited to propertiespyramidPossible use:  pyramid (float) —&gt;  geometryResult:A square geometry which side size is given by the operand.Comment:the center of the pyramid is by default the location of the current agent in which has been called this operator.Special cases:  returns nil if the operand is nil.Examples:geometry var0 &lt;- pyramid(5); \t// var0 equals a geometry as a square with side_size = 5.See also:around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, square,rangePossible use:  range (int) —&gt;  container  int range int —&gt;  container  range (int , int) —&gt;  container  range (int, int, int) —&gt;  containerResult:Allows to build a list of int representing all contiguous values from zero to the argument. The range can be increasing or decreasing. Passing 0 will return a singleton list with 0Allows to build a list of int representing all contiguous values from the first to the second argument, using the step represented by the third argument. The range can be increasing or decreasing. Passing the same value for both will return a singleton list with this value. Passing a step of 0 will result in an exception. Attempting to build infinite ranges (e.g. end &gt; start with a negative step) will similarly not be accepted and yield an exceptionAllows to build a list of int representing all contiguous values from the first to the second argument. The range can be increasing or decreasing. Passing the same value for both will return a singleton list with this valuereadPossible use:  read (string) —&gt;  unknownResult:Reads an attribute of the agent. The attribute’s name is specified by the operand.Examples:unknown agent_name &lt;- read ('name'); \t// agent_name equals reads the 'name' variable of agent then assigns the returned value to the 'agent_name' variable. rectanglePossible use:  rectangle (point) —&gt;  geometry  float rectangle float —&gt;  geometry  rectangle (float , float) —&gt;  geometry  point rectangle point —&gt;  geometry  rectangle (point , point) —&gt;  geometryResult:A rectangle geometry which side sizes are given by the operands.Comment:the center of the rectangle is by default the location of the current agent in which has been called this operator.the center of the rectangle is by default the location of the current agent in which has been called this operator.Special cases:  returns nil if the operand is nil.  returns nil if the operand is nil.  returns nil if the operand is nil.Examples:geometry var0 &lt;- rectangle(10, 5); \t// var0 equals a geometry as a rectangle with width = 10 and height = 5.geometry var1 &lt;- rectangle({2.0,6.0}, {6.0,20.0}); \t// var1 equals a geometry as a rectangle with {2.0,6.0} as the upper-left corner, {6.0,20.0} as the lower-right corner.geometry var2 &lt;- rectangle({10, 5}); \t// var2 equals a geometry as a rectangle with width = 10 and height = 5.See also:around, circle, cone, line, link, norm, point, polygon, polyline, square, triangle,reduced_bySame signification as -regressionPossible use:  regression (any) —&gt;  regressionResult:Casts the operand into the type regressionremove_duplicatesSame signification as distinctremove_node_fromPossible use:  geometry remove_node_from graph —&gt;  graph  remove_node_from (geometry , graph) —&gt;  graphResult:removes a node from a graph.Comment:all the edges containing this node are also removed.Examples:graph var0 &lt;- node(0) remove_node_from graphEpidemio; \t// var0 equals the graph without node(0)replacePossible use:  replace (string, string, string) —&gt;  stringResult:Returns the String resulting by replacing for the first operand all the sub-strings corresponding the second operand by the third operandExamples:string var0 &lt;- replace('to be or not to be,that is the question','to', 'do'); \t// var0 equals 'do be or not do be,that is the question'See also:replace_regex,replace_regexPossible use:  replace_regex (string, string, string) —&gt;  stringResult:Returns the String resulting by replacing for the first operand all the sub-strings corresponding to the regular expression given in the second operand by the third operandExamples:string var0 &lt;- replace_regex(\"colour, color\", \"colou?r\", \"col\"); \t// var0 equals 'col, col'See also:replace,reversePossible use:  reverse (string) —&gt;  string  reverse (container&lt;KeyType,ValueType&gt;) —&gt;  msi.gama.util.IContainer&lt;?,?&gt;Result:the operand elements in the reversed order in a copy of the operand.Comment:the reverse operator behavior depends on the nature of the operandSpecial cases:  if it is a file, reverse returns a copy of the file with a reversed content  if it is a population, reverse returns a copy of the population with elements in the reversed order  if it is a graph, reverse returns a copy of the graph (with all edges and vertexes), with all of the edges reversed  if it is a string, reverse returns a new string with characters in the reversed orderstring var0 &lt;- reverse ('abcd'); \t// var0 equals 'dcba'  if it is a list, reverse returns a copy of the operand list with elements in the reversed ordermsi.gama.util.IContainer&lt;?,?&gt; var1 &lt;- reverse ([10,12,14]); \t// var1 equals [14, 12, 10]  if it is a map, reverse returns a copy of the operand map with each pair in the reversed order (i.e. all keys become values and values become keys)msi.gama.util.IContainer&lt;?,?&gt; var2 &lt;- reverse (['k1'::44, 'k2'::32, 'k3'::12]); \t// var2 equals [12::'k3',  32::'k2', 44::'k1']  if it is a matrix, reverse returns a new matrix containing the transpose of the operand.msi.gama.util.IContainer&lt;?,?&gt; var3 &lt;- reverse(matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]])); \t// var3 equals matrix([[\"c11\",\"c21\"],[\"c12\",\"c22\"],[\"c13\",\"c23\"]])rewire_nPossible use:  graph rewire_n int —&gt;  graph  rewire_n (graph , int) —&gt;  graphResult:rewires the given count of edges.Comment:If there are too many edges, all the edges will be rewired.Examples:graph var1 &lt;- graphEpidemio rewire_n 10; \t// var1 equals the graph with 3 edges rewiredrgbPossible use:  rgb rgb float —&gt;  rgb  rgb (rgb , float) —&gt;  rgb  rgb rgb int —&gt;  rgb  rgb (rgb , int) —&gt;  rgb  string rgb int —&gt;  rgb  rgb (string , int) —&gt;  rgb  rgb (int, int, int) —&gt;  rgb  rgb (int, int, int, float) —&gt;  rgb  rgb (int, int, int, int) —&gt;  rgbResult:Returns a color defined by red, green, blue components and an alpha blending value.Special cases:  It can be used with r=red, g=green, b=blue (each between 0 and 255), a=alpha (between 0.0 and 1.0)  It can be used with a color and an alpha between 0 and 1  It can be used with a color and an alpha between 0 and 255  It can be used with r=red, g=green, b=blue, each between 0 and 255  It can be used with a name of color and alpha (between 0 and 255)  It can be used with r=red, g=green, b=blue (each between 0 and 255), a=alpha (between 0 and 255)Examples:rgb var0 &lt;- rgb (255,0,0,0.5); \t// var0 equals a light red colorrgb var1 &lt;- rgb(rgb(255,0,0),0.5); \t// var1 equals a light red colorrgb var2 &lt;- rgb(rgb(255,0,0),125); \t// var2 equals a light red colorrgb var3 &lt;- rgb (255,0,0); \t// var3 equals #redrgb var4 &lt;- rgb (\"red\"); \t// var4 equals rgb(255,0,0)rgb var5 &lt;- rgb (255,0,0,125); \t// var5 equals a light red colorSee also:hsb,rgb_to_xyzPossible use:  rgb_to_xyz (file) —&gt;  list&lt;point&gt;Result:A list of point corresponding to RGB value of an image (r:x , g:y, b:z)Examples:list&lt;point&gt; var0 &lt;- rgb_to_xyz(texture); \t// var0 equals a list of pointsrndPossible use:  rnd (float) —&gt;  float  rnd (int) —&gt;  int  rnd (point) —&gt;  point  point rnd point —&gt;  point  rnd (point , point) —&gt;  point  int rnd int —&gt;  int  rnd (int , int) —&gt;  int  float rnd float —&gt;  float  rnd (float , float) —&gt;  float  rnd (point, point, float) —&gt;  point  rnd (float, float, float) —&gt;  float  rnd (int, int, int) —&gt;  intResult:a random integer in the interval [0, operand]Comment:to obtain a probability between 0 and 1, use the expression (rnd n) / n, where n is used to indicate the precisionSpecial cases:  if the operand is a float, returns an uniformly distributed float random number in [0.0, to]  if the operand is a point, returns a point with three random float ordinates, each in the interval [0, ordinate of argument]Examples:float var0 &lt;- rnd(3.4); \t// var0 equals a random float between 0.0 and 3.4point var1 &lt;- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}, 1); \t// var1 equals a point with x = 2.0, y equal to 2.0, 3.0 or 4.0 and z between 0.0 and 10.0 every 1.0point var2 &lt;- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}); \t// var2 equals a point with x = 2.0, y between 2.0 and 4.0 and z between 0.0 and 10.0int var3 &lt;- rnd (2, 4); \t// var3 equals 2, 3 or 4float var4 &lt;- rnd (2.0, 4.0); \t// var4 equals a float number between 2.0 and 4.0float var5 &lt;- rnd (2.0, 4.0, 0.5); \t// var5 equals a float number between 2.0 and 4.0 every 0.5int var6 &lt;- rnd (2); \t// var6 equals 0, 1 or 2float var7 &lt;- rnd (1000) / 1000; \t// var7 equals a float between 0 and 1 with a precision of 0.001point var8 &lt;- rnd ({2.5,3, 0.0}); \t// var8 equals {x,y} with x in [0.0,2.0], y in [0.0,3.0], z = 0.0int var9 &lt;- rnd (2, 12, 4); \t// var9 equals 2, 6 or 10See also:flip,rnd_choicePossible use:  rnd_choice (container) —&gt;  intResult:returns an index of the given list with a probability following the (normalized) distribution described in the list (a form of lottery)Examples:int var0 &lt;- rnd_choice([0.2,0.5,0.3]); \t// var0 equals 2/10 chances to return 0, 5/10 chances to return 1, 3/10 chances to return 2See also:rnd,rnd_colorPossible use:  rnd_color (int) —&gt;  rgbResult:rgb colorComment:Return a random color equivalent to rgb(rnd(operand),rnd(operand),rnd(operand))Examples:rgb var0 &lt;- rnd_color(255); \t// var0 equals a random color, equivalent to rgb(rnd(255),rnd(255),rnd(255))See also:rgb, hsb,rotated_byPossible use:  geometry rotated_by float —&gt;  geometry  rotated_by (geometry , float) —&gt;  geometry  geometry rotated_by int —&gt;  geometry  rotated_by (geometry , int) —&gt;  geometry  rotated_by (geometry, float, point) —&gt;  geometryResult:A geometry resulting from the application of a rotation by the right-hand operand angle (degree) to the left-hand operand (geometry, agent, point)A geometry resulting from the application of a rotation by the right-hand operand angles (degree) along the three axis (x,y,z) to the left-hand operand (geometry, agent, point)Comment:the right-hand operand can be a float or a intExamples:geometry var0 &lt;- self rotated_by 45; \t// var0 equals the geometry resulting from a 45 degrees rotation to the geometry of the agent applying the operator.geometry var1 &lt;- rotated_by(pyramid(10),45, {1,0,0}); \t// var1 equals the geometry resulting from a 45 degrees rotation along the {1,0,0} vector to the geometry of the agent applying the operator.See also:transformed_by, translated_by,roundPossible use:  round (int) —&gt;  int  round (point) —&gt;  point  round (float) —&gt;  intResult:Returns the rounded value of the operand.Special cases:  if the operand is an int, round returns itExamples:point var0 &lt;- {12345.78943,  12345.78943, 12345.78943} with_precision 2; \t// var0 equals {12345.79,12345.79,12345.79}int var1 &lt;- round (0.51); \t// var1 equals 1int var2 &lt;- round (100.2); \t// var2 equals 100int var3 &lt;- round(-0.51); \t// var3 equals -1See also:round, int, with_precision,row_atPossible use:  matrix row_at int —&gt;  list  row_at (matrix , int) —&gt;  listResult:returns the row at a num_line (right-hand operand)Examples:list var0 &lt;- matrix([[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]]) row_at 2; \t// var0 equals [\"el13\",\"el23\",\"el33\"]See also:column_at, columns_list,rows_listPossible use:  rows_list (matrix) —&gt;  list&lt;list&gt;Result:returns a list of the rows of the matrix, with each row as a list of elementsExamples:list&lt;list&gt; var0 &lt;- rows_list(matrix([[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]])); \t// var0 equals [[\"el11\",\"el21\",\"el31\"],[\"el12\",\"el22\",\"el32\"],[\"el13\",\"el23\",\"el33\"]]See also:columns_list,samplePossible use:  sample (any expression) —&gt;  string  string sample any expression —&gt;  string  sample (string , any expression) —&gt;  string  sample (container, int, bool) —&gt;  container  sample (container, int, bool, container) —&gt;  containerResult:takes a sample of the specified size from the elements of x using either with or without replacementtakes a sample of the specified size from the elements of x using either with or without replacement with given weightsExamples:container var0 &lt;- sample([2,10,1],2,false); \t// var0 equals [1,2]container var1 &lt;- sample([2,10,1],2,false,[0.1,0.7,0.2]); \t// var1 equals [10,2]scaled_bySame signification as [](OperatorsAC#)scaled_toPossible use:  geometry scaled_to point —&gt;  geometry  scaled_to (geometry , point) —&gt;  geometryResult:allows to restrict the size of a geometry so that it fits in the envelope {width, height, depth} defined by the second operandExamples:geometry var0 &lt;- shape scaled_to {10,10}; \t// var0 equals a geometry corresponding to the geometry of the agent applying the operator scaled so that it fits a square of 10x10selectSame signification as whereset_aboutPossible use:  emotion set_about predicate —&gt;  emotion  set_about (emotion , predicate) —&gt;  emotionResult:change the about value of the given emotionExamples:emotion set_about predicate1set_agentPossible use:  msi.gaml.architecture.simplebdi.SocialLink set_agent agent —&gt;  msi.gaml.architecture.simplebdi.SocialLink  set_agent (msi.gaml.architecture.simplebdi.SocialLink , agent) —&gt;  msi.gaml.architecture.simplebdi.SocialLinkResult:change the agent value of the given social linkExamples:social_link set_agent agentAset_agent_causePossible use:  emotion set_agent_cause agent —&gt;  emotion  set_agent_cause (emotion , agent) —&gt;  emotion  predicate set_agent_cause agent —&gt;  predicate  set_agent_cause (predicate , agent) —&gt;  predicateResult:change the agentCause value of the given emotionchange the agentCause value of the given predicateExamples:emotion set_agent_cause agentApredicate set_agent_cause agentAset_decayPossible use:  emotion set_decay float —&gt;  emotion  set_decay (emotion , float) —&gt;  emotionResult:change the decay value of the given emotionExamples:emotion set_decay 12set_dominancePossible use:  msi.gaml.architecture.simplebdi.SocialLink set_dominance float —&gt;  msi.gaml.architecture.simplebdi.SocialLink  set_dominance (msi.gaml.architecture.simplebdi.SocialLink , float) —&gt;  msi.gaml.architecture.simplebdi.SocialLinkResult:change the dominance value of the given social linkExamples:social_link set_dominance 0.4set_familiarityPossible use:  msi.gaml.architecture.simplebdi.SocialLink set_familiarity float —&gt;  msi.gaml.architecture.simplebdi.SocialLink  set_familiarity (msi.gaml.architecture.simplebdi.SocialLink , float) —&gt;  msi.gaml.architecture.simplebdi.SocialLinkResult:change the familiarity value of the given social linkExamples:social_link set_familiarity 0.4set_intensityPossible use:  emotion set_intensity float —&gt;  emotion  set_intensity (emotion , float) —&gt;  emotionResult:change the intensity value of the given emotionExamples:emotion set_intensity 12set_likingPossible use:  msi.gaml.architecture.simplebdi.SocialLink set_liking float —&gt;  msi.gaml.architecture.simplebdi.SocialLink  set_liking (msi.gaml.architecture.simplebdi.SocialLink , float) —&gt;  msi.gaml.architecture.simplebdi.SocialLinkResult:change the liking value of the given social linkExamples:social_link set_liking 0.4set_solidarityPossible use:  msi.gaml.architecture.simplebdi.SocialLink set_solidarity float —&gt;  msi.gaml.architecture.simplebdi.SocialLink  set_solidarity (msi.gaml.architecture.simplebdi.SocialLink , float) —&gt;  msi.gaml.architecture.simplebdi.SocialLinkResult:change the solidarity value of the given social linkExamples:social_link set_solidarity 0.4set_truthPossible use:  predicate set_truth bool —&gt;  predicate  set_truth (predicate , bool) —&gt;  predicateResult:change the is_true value of the given predicateExamples:predicate set_truth falseset_zPossible use:  geometry set_z container&lt;float&gt; —&gt;  geometry  set_z (geometry , container&lt;float&gt;) —&gt;  geometry  set_z (geometry, int, float) —&gt;  geometryResult:Sets the z ordinate of the n-th point of a geometry to the value provided by the third argumentExamples:loop i from: 0 to: length(shape.points) - 1{set shape &lt;-  set_z (shape, i, 3.0);}shape &lt;- triangle(3) set_z [5,10,14];shape_filePossible use:  shape_file (string) —&gt;  fileResult:Constructs a file of type shape. Allowed extensions are limited to shpshufflePossible use:  shuffle (matrix) —&gt;  matrix  shuffle (string) —&gt;  string  shuffle (container) —&gt;  containerResult:The elements of the operand in random order.Special cases:  if the operand is empty, returns an empty list (or string, matrix)Examples:matrix var0 &lt;- shuffle (matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]])); \t// var0 equals matrix([[\"c12\",\"c21\",\"c11\"],[\"c13\",\"c22\",\"c23\"]]) (for example)string var1 &lt;- shuffle ('abc'); \t// var1 equals 'bac' (for example)container var2 &lt;- shuffle ([12, 13, 14]); \t// var2 equals [14,12,13] (for example)See also:reverse,signumPossible use:  signum (float) —&gt;  intResult:Returns -1 if the argument is negative, +1 if it is positive, 0 if it is equal to zero or not a numberExamples:int var0 &lt;- signum(-12); \t// var0 equals -1int var1 &lt;- signum(14); \t// var1 equals 1int var2 &lt;- signum(0); \t// var2 equals 0simple_clustering_by_distancePossible use:  container&lt;agent&gt; simple_clustering_by_distance float —&gt;  list&lt;list&lt;agent&gt;&gt;  simple_clustering_by_distance (container&lt;agent&gt; , float) —&gt;  list&lt;list&lt;agent&gt;&gt;Result:A list of agent groups clustered by distance considering a distance min between two groups.Examples:list&lt;list&lt;agent&gt;&gt; var0 &lt;- [ag1, ag2, ag3, ag4, ag5] simpleClusteringByDistance 20.0; \t// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]See also:hierarchical_clustering,simple_clustering_by_envelope_distanceSame signification as simple_clustering_by_distancesimplificationPossible use:  geometry simplification float —&gt;  geometry  simplification (geometry , float) —&gt;  geometryResult:A geometry corresponding to the simplification of the operand (geometry, agent, point) considering a tolerance distance.Comment:The algorithm used for the simplification is Douglas-PeuckerExamples:geometry var0 &lt;- self simplification 0.1; \t// var0 equals the geometry resulting from the application of the Douglas-Peuker algorithm on the geometry of the agent applying the operator with a tolerance distance of 0.1.sinPossible use:  sin (float) —&gt;  float  sin (int) —&gt;  floatResult:Returns the value (in [-1,1]) of the sinus of the operand (in decimal degrees). The argument is casted to an int before being evaluated.Special cases:  Operand values out of the range [0-359] are normalized.Examples:float var0 &lt;- sin(360); \t// var0 equals 0.0float var1 &lt;- sin (0); \t// var1 equals 0.0See also:cos, tan,sin_radPossible use:  sin_rad (float) —&gt;  floatResult:Returns the value (in [-1,1]) of the sinus of the operand (in decimal degrees). The argument is casted to an int before being evaluated.Special cases:  Operand values out of the range [0-359] are normalized.Examples:float var0 &lt;- sin(360); \t// var0 equals 0.0See also:cos, tan,sincePossible use:  since (date) —&gt;  bool  any expression since date —&gt;  bool  since (any expression , date) —&gt;  boolResult:Returns true if the current_date of the model is after (or equal to) the date passed in argument. Synonym of ‘current_date &gt;= argument’. Can be used, like ‘after’, in its composed form with 2 arguments to express the lowest boundary of the computation of a frequency. However, contrary to ‘after’, there is a subtle difference: the lowest boundary will be tested against the frequency as wellExamples:reflex when: since(starting_date) {} -: will always be runevery(2#days) since (starting_date + 1#day) // the computation will return true 1 day after the starting date and every two days after this reference dateskeletonizePossible use:  skeletonize (geometry) —&gt;  list&lt;geometry&gt;Result:A list of geometries (polylines) corresponding to the skeleton of the operand geometry (geometry, agent)Examples:list&lt;geometry&gt; var0 &lt;- skeletonize(self); \t// var0 equals the list of geometries corresponding to the skeleton of the geometry of the agent applying the operator.skew_gaussPossible use:  skew_gauss (float, float, float, float) —&gt;  floatResult:A value from a skew normally distributed random variable with min value (the minimum skewed value possible), max value (the maximum skewed value possible), skew (the degree to which the values cluster around the mode of the distribution; higher values mean tighter clustering) and bias (the tendency of the mode to approach the min, max or midpoint value; positive values bias toward max, negative values toward min).The algorithm was taken from http://stackoverflow.com/questions/5853187/skewing-java-random-number-generation-toward-a-certain-numberExamples:float var0 &lt;- skew_gauss(0.0, 1.0, 0.7,0.1); \t// var0 equals 0.1729218460343077See also:gauss, truncated_gauss, poisson,skewnessPossible use:  skewness (list) —&gt;  floatResult:returns skewness value computed from the operand list of valuesSpecial cases:  if the length of the list is lower than 3, returns NaNExamples:skewness ([1,2,3,4,5])skillPossible use:  skill (any) —&gt;  skillResult:Casts the operand into the type skillsmoothPossible use:  geometry smooth float —&gt;  geometry  smooth (geometry , float) —&gt;  geometryResult:Returns a ‘smoothed’ geometry, where straight lines are replaces by polynomial (bicubic) curves. The first parameter is the original geometry, the second is the ‘fit’ parameter which can be in the range 0 (loose fit) to 1 (tightest fit).Examples:geometry var0 &lt;- smooth(square(10), 0.0); \t// var0 equals a 'rounded' squaresocial_linkPossible use:  social_link (any) —&gt;  social_linkResult:Casts the operand into the type social_linksolidSame signification as without_holessortSame signification as sort_bysort_byPossible use:  container sort_by any expression —&gt;  container  sort_by (container , any expression) —&gt;  containerResult:Returns a list, containing the elements of the left-hand operand sorted in ascending order by the value of the right-hand operand when it is evaluated on them.Comment:the left-hand operand is casted to a list before applying the operator. In the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.Special cases:  if the left-hand operand is nil, sort_by throws an errorExamples:container var0 &lt;- [1,2,4,3,5,7,6,8] sort_by (each); \t// var0 equals [1,2,3,4,5,6,7,8]container var2 &lt;- g2 sort_by (length(g2 out_edges_of each) ); \t// var2 equals [node9, node7, node10, node8, node11, node6, node5, node4]container var3 &lt;- (list(node) sort_by (round(node(each).location.x)); \t// var3 equals [node5, node1, node0, node2, node3]container var4 &lt;- [1::2, 5::6, 3::4] sort_by (each); \t// var4 equals [2, 4, 6]See also:group_by,source_ofPossible use:  graph source_of unknown —&gt;  unknown  source_of (graph , unknown) —&gt;  unknownResult:returns the source of the edge (right-hand operand) contained in the graph given in left-hand operand.Special cases:  if the lef-hand operand (the graph) is nil, throws an ExceptionExamples:graph graphEpidemio &lt;- generate_barabasi_albert( [\"edges_species\"::edge,\"vertices_specy\"::node,\"size\"::3,\"m\"::5] );unknown var1 &lt;- graphEpidemio source_of(edge(3)); \t// var1 equals node1graph graphFromMap &lt;-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);point var3 &lt;- graphFromMap source_of(link({1,5}::{12,45})); \t// var3 equals {1,5}See also:target_of,spatial_graphPossible use:  spatial_graph (container) —&gt;  graphResult:allows to create a spatial graph from a container of vertices, without trying to wire them. The container can be empty. Emits an error if the contents of the container are not geometries, points or agentsSee also:graph,speciesPossible use:  species (unknown) —&gt;  speciesResult:casting of the operand to a species.Special cases:  if the operand is nil, returns nil;  if the operand is an agent, returns its species;  if the operand is a string, returns the species with this name (nil if not found);  otherwise, returns nilExamples:species var0 &lt;- species(self); \t// var0 equals the species of the current agentspecies var1 &lt;- species('node'); \t// var1 equals nodespecies var2 &lt;- species([1,5,9,3]); \t// var2 equals nilspecies var3 &lt;- species(node1); \t// var3 equals nodespecies_ofSame signification as speciesspherePossible use:  sphere (float) —&gt;  geometryResult:A sphere geometry which radius is equal to the operand.Comment:the centre of the sphere is by default the location of the current agent in which has been called this operator.Special cases:  returns a point if the operand is lower or equal to 0.Examples:geometry var0 &lt;- sphere(10); \t// var0 equals a geometry as a circle of radius 10 but displays a sphere.See also:around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,split_atPossible use:  geometry split_at point —&gt;  list&lt;geometry&gt;  split_at (geometry , point) —&gt;  list&lt;geometry&gt;Result:The two part of the left-operand lines split at the given right-operand pointSpecial cases:  if the left-operand is a point or a polygon, returns an empty listExamples:list&lt;geometry&gt; var0 &lt;- polyline([{1,2},{4,6}]) split_at {7,6}; \t// var0 equals [polyline([{1.0,2.0},{7.0,6.0}]), polyline([{7.0,6.0},{4.0,6.0}])]split_geometryPossible use:  geometry split_geometry float —&gt;  list&lt;geometry&gt;  split_geometry (geometry , float) —&gt;  list&lt;geometry&gt;  geometry split_geometry point —&gt;  list&lt;geometry&gt;  split_geometry (geometry , point) —&gt;  list&lt;geometry&gt;  split_geometry (geometry, int, int) —&gt;  list&lt;geometry&gt;Result:A list of geometries that result from the decomposition of the geometry by square cells of the given side size (geometry, size)A list of geometries that result from the decomposition of the geometry by rectangle cells of the given dimension (geometry, {size_x, size_y})A list of geometries that result from the decomposition of the geometry according to a grid with the given number of rows and columns (geometry, nb_cols, nb_rows)Examples:list&lt;geometry&gt; var0 &lt;- to_squares(self, 10.0); \t// var0 equals the list of the geometries corresponding to the decomposition of the geometry by squares of side size 10.0list&lt;geometry&gt; var1 &lt;- to_rectangles(self, {10.0, 15.0}); \t// var1 equals the list of the geometries corresponding to the decomposition of the geometry by rectangles of size 10.0, 15.0list&lt;geometry&gt; var2 &lt;- to_rectangles(self, 10,20); \t// var2 equals the list of the geometries corresponding to the decomposition of the geometry of the agent applying the operatorsplit_linesPossible use:  split_lines (container&lt;geometry&gt;) —&gt;  list&lt;geometry&gt;Result:A list of geometries resulting after cutting the lines at their intersections.Examples:list&lt;geometry&gt; var0 &lt;- split_lines([line([{0,10}, {20,10}]), line([{0,10}, {20,10}])]); \t// var0 equals a list of four polylines: line([{0,10}, {10,10}]), line([{10,10}, {20,10}]), line([{10,0}, {10,10}]) and line([{10,10}, {10,20}])split_withPossible use:  string split_with string —&gt;  container  split_with (string , string) —&gt;  containerResult:Returns a list containing the sub-strings (tokens) of the left-hand operand delimited by each of the characters of the right-hand operand.Comment:Delimiters themselves are excluded from the resulting list.Examples:container var0 &lt;- 'to be or not to be,that is the question' split_with ' ,'; \t// var0 equals ['to','be','or','not','to','be','that','is','the','question']sqrtPossible use:  sqrt (int) —&gt;  float  sqrt (float) —&gt;  floatResult:Returns the square root of the operand.Special cases:  if the operand is negative, an exception is raisedExamples:float var0 &lt;- sqrt(4); \t// var0 equals 2.0float var1 &lt;- sqrt(4); \t// var1 equals 2.0squarePossible use:  square (float) —&gt;  geometryResult:A square geometry which side size is equal to the operand.Comment:the centre of the square is by default the location of the current agent in which has been called this operator.Special cases:  returns nil if the operand is nil.Examples:geometry var0 &lt;- square(10); \t// var0 equals a geometry as a square of side size 10.See also:around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, triangle,squirclePossible use:  float squircle float —&gt;  geometry  squircle (float , float) —&gt;  geometryResult:A mix of square and circle geometry (see : http://en.wikipedia.org/wiki/Squircle), which side size is equal to the first operand and power is equal to the second operandComment:the center of the ellipse is by default the location of the current agent in which has been called this operator.Special cases:  returns a point if the side operand is lower or equal to 0.Examples:geometry var0 &lt;- squircle(4,4); \t// var0 equals a geometry as a squircle of side 4 with a power of 4.See also:around, cone, line, link, norm, point, polygon, polyline, super_ellipse, rectangle, square, circle, ellipse, triangle,standard_deviationPossible use:  standard_deviation (container) —&gt;  floatResult:the standard deviation on the elements of the operand. See Standard_deviation for more details.Comment:The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.Examples:float var0 &lt;- standard_deviation ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 1.2930100540985752See also:mean, mean_deviation,stringPossible use:  date string string —&gt;  string  string (date , string) —&gt;  stringResult:converts a date to astring following a custom pattern. The pattern can use “%Y %M %N %D %E %h %m %s %z” for outputting years, months, name of month, days, name of days, hours, minutes, seconds and the time-zone. A null or empty pattern will return the complete date as defined by the ISO date &amp; time format. The pattern can also follow the pattern definition found here, which gives much more control over the format of the date: https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns. Different patterns are available by default as constants: #iso_local, #iso_simple, #iso_offset, #iso_zoned and #custom, which can be changed in the preferencesExamples:format(#now, 'yyyy-MM-dd')subtract_daysSame signification as minus_dayssubtract_hoursSame signification as minus_hourssubtract_minutesSame signification as minus_minutessubtract_monthsSame signification as minus_monthssubtract_msSame signification as minus_mssubtract_secondsSame signification as -subtract_weeksSame signification as minus_weekssubtract_yearsSame signification as minus_yearssuccessors_ofPossible use:  graph successors_of unknown —&gt;  container  successors_of (graph , unknown) —&gt;  containerResult:returns the list of successors (i.e. targets of out edges) of the given vertex (right-hand operand) in the given graph (left-hand operand)Examples:container var1 &lt;- graphEpidemio successors_of ({1,5}); \t// var1 equals [{12,45}]container var2 &lt;- graphEpidemio successors_of node({34,56}); \t// var2 equals []See also:predecessors_of, neighbors_of,sumPossible use:  sum (graph) —&gt;  float  sum (container) —&gt;  unknownResult:the sum of all the elements of the operandComment:the behavior depends on the nature of the operandSpecial cases:  if it is a population or a list of other types: sum transforms all elements into float and sums them  if it is a map, sum returns the sum of the value of all elements  if it is a file, sum returns the sum of the content of the file (that is also a container)  if it is a graph, sum returns the total weight of the graph  if it is a matrix of int, float or object, sum returns the sum of all the numerical elements (i.e. all elements for integer and float matrices)  if it is a matrix of other types: sum transforms all elements into float and sums them  if it is a list of colors: sum will sum them and return the blended resulting color  if it is a list of int or float: sum returns the sum of all the elementsint var0 &lt;- sum ([12,10,3]); \t// var0 equals 25  if it is a list of points: sum returns the sum of all points as a point (each coordinate is the sum of the corresponding coordinate of each element)unknown var1 &lt;- sum([{1.0,3.0},{3.0,5.0},{9.0,1.0},{7.0,8.0}]); \t// var1 equals {20.0,17.0}See also:mul,sum_ofPossible use:  container sum_of any expression —&gt;  unknown  sum_of (container , any expression) —&gt;  unknownResult:the sum of the right-hand expression evaluated on each of the elements of the left-hand operandComment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  if the left-operand is a map, the keyword each will contain each valueunknown var2 &lt;- [1::2, 3::4, 5::6] sum_of (each + 3); \t// var2 equals 21Examples:unknown var1 &lt;- [1,2] sum_of (each * 100 ); \t// var1 equals 300See also:min_of, max_of, product_of, mean_of,svg_filePossible use:  svg_file (string) —&gt;  fileResult:Constructs a file of type svg. Allowed extensions are limited to svgtanPossible use:  tan (int) —&gt;  float  tan (float) —&gt;  floatResult:Returns the value (in [-1,1]) of the trigonometric tangent of the operand (in decimal degrees). The argument is casted to an int before being evaluated.Special cases:  Operand values out of the range [0-359] are normalized. Notice that tan(360) does not return 0.0 but -2.4492935982947064E-16  The tangent is only defined for any real number except 90 + k * 180 (k an positive or negative integer). Nevertheless notice that tan(90) returns 1.633123935319537E16 (whereas we could except infinity).Examples:float var0 &lt;- tan (0); \t// var0 equals 0.0float var1 &lt;- tan(90); \t// var1 equals 1.633123935319537E16See also:cos, sin,tan_radPossible use:  tan_rad (float) —&gt;  floatResult:Returns the value (in [-1,1]) of the trigonometric tangent of the operand (in decimal degrees). The argument is casted to an int before being evaluated.Special cases:  Operand values out of the range [0-359] are normalized. Notice that tan(360) does not return 0.0 but -2.4492935982947064E-16  The tangent is only defined for any real number except 90 + k * 180 (k an positive or negative integer). Nevertheless notice that tan(90) returns 1.633123935319537E16 (whereas we could except infinity).See also:cos, sin,tanhPossible use:  tanh (float) —&gt;  float  tanh (int) —&gt;  floatResult:Returns the value (in the interval [-1,1]) of the hyperbolic tangent of the operand (which can be any real number, expressed in decimal degrees).Examples:float var0 &lt;- tanh(0); \t// var0 equals 0.0float var1 &lt;- tanh(100); \t// var1 equals 1.0target_ofPossible use:  graph target_of unknown —&gt;  unknown  target_of (graph , unknown) —&gt;  unknownResult:returns the target of the edge (right-hand operand) contained in the graph given in left-hand operand.Special cases:  if the lef-hand operand (the graph) is nil, returns nilExamples:graph graphEpidemio &lt;- generate_barabasi_albert( [\"edges_species\"::edge,\"vertices_specy\"::node,\"size\"::3,\"m\"::5] );unknown var1 &lt;- graphEpidemio source_of(edge(3)); \t// var1 equals node1graph graphFromMap &lt;-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);unknown var3 &lt;- graphFromMap target_of(link({1,5}::{12,45})); \t// var3 equals {12,45}See also:source_of,teapotPossible use:  teapot (float) —&gt;  geometryResult:A teapot geometry which radius is equal to the operand.Comment:the centre of the teapot is by default the location of the current agent in which has been called this operator.Special cases:  returns a point if the operand is lower or equal to 0.Examples:geometry var0 &lt;- teapot(10); \t// var0 equals a geometry as a circle of radius 10 but displays a teapot.See also:around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,text_filePossible use:  text_file (string) —&gt;  fileResult:Constructs a file of type text. Allowed extensions are limited to txt, data, textthreeds_filePossible use:  threeds_file (string) —&gt;  fileResult:Constructs a file of type threeds. Allowed extensions are limited to 3ds, maxtoPossible use:  date to date —&gt;  msi.gama.util.IList&lt;msi.gama.util.GamaDate&gt;  to (date , date) —&gt;  msi.gama.util.IList&lt;msi.gama.util.GamaDate&gt;Result:builds an interval between two dates (the first inclusive and the second exclusive, which behaves like a read-only list of dates. The default step between two dates is the step of the modelComment:The default step can be overruled by using the every operator applied to this intervalExamples:date('2000-01-01') to date('2010-01-01') // builds an interval between these two dates(date('2000-01-01') to date('2010-01-01')) every (#month) // builds an interval between these two dates which contains all the monthly dates starting from the beginning of the intervalSee also:every,to_GAMA_CRSPossible use:  to_GAMA_CRS (geometry) —&gt;  geometry  geometry to_GAMA_CRS string —&gt;  geometry  to_GAMA_CRS (geometry , string) —&gt;  geometrySpecial cases:  returns the geometry corresponding to the transformation of the given geometry to the GAMA CRS (Coordinate Reference System) assuming the given geometry is referenced by given CRSgeometry var0 &lt;- to_GAMA_CRS({121,14}, \"EPSG:4326\"); \t// var0 equals a geometry corresponding to the agent geometry transformed into the GAMA CRS  returns the geometry corresponding to the transformation of the given geometry to the GAMA CRS (Coordinate Reference System) assuming the given geometry is referenced by the current CRS, the one corresponding to the world’s agent onegeometry var1 &lt;- to_GAMA_CRS({121,14}); \t// var1 equals a geometry corresponding to the agent geometry transformed into the GAMA CRSto_gamlPossible use:  to_gaml (unknown) —&gt;  stringResult:returns the literal description of an expression or description – action, behavior, species, aspect, even model – in gamlExamples:string var0 &lt;- to_gaml(0); \t// var0 equals '0'string var1 &lt;- to_gaml(3.78); \t// var1 equals '3.78'string var2 &lt;- to_gaml(true); \t// var2 equals 'true'string var3 &lt;- to_gaml({23, 4.0}); \t// var3 equals '{23.0,4.0,0.0}'string var4 &lt;- to_gaml(5::34); \t// var4 equals '5::34'string var5 &lt;- to_gaml(rgb(255,0,125)); \t// var5 equals 'rgb (255, 0, 125,255)'string var6 &lt;- to_gaml('hello'); \t// var6 equals \"'hello'\"string var7 &lt;- to_gaml([1,5,9,3]); \t// var7 equals '[1,5,9,3]'string var8 &lt;- to_gaml(['a'::345, 'b'::13, 'c'::12]); \t// var8 equals \"(['a'::345,'b'::13,'c'::12] as map )\"string var9 &lt;- to_gaml([[3,5,7,9],[2,4,6,8]]); \t// var9 equals '[[3,5,7,9],[2,4,6,8]]'string var10 &lt;- to_gaml(a_graph); \t// var10 equals ([((1 as node)::(3 as node))::(5 as edge),((0 as node)::(3 as node))::(3 as edge),((1 as node)::(2 as node))::(1 as edge),((0 as node)::(2 as node))::(2 as edge),((0 as node)::(1 as node))::(0 as edge),((2 as node)::(3 as node))::(4 as edge)] as map ) as graphstring var11 &lt;- to_gaml(node1); \t// var11 equals  1 as nodeto_rectanglesPossible use:  to_rectangles (geometry, point, bool) —&gt;  list&lt;geometry&gt;  to_rectangles (geometry, int, int, bool) —&gt;  list&lt;geometry&gt;Result:A list of rectangles of the size corresponding to the given dimension that result from the decomposition of the geometry into rectangles (geometry, dimension, overlaps), if overlaps = true, add the rectangles that overlap the border of the geometryA list of rectangles corresponding to the given dimension that result from the decomposition of the geometry into rectangles (geometry, nb_cols, nb_rows, overlaps) by a grid composed of the given number of columns and rows, if overlaps = true, add the rectangles that overlap the border of the geometryExamples:list&lt;geometry&gt; var0 &lt;- to_rectangles(self, {10.0, 15.0}, true); \t// var0 equals the list of rectangles of size {10.0, 15.0} corresponding to the discretization into rectangles of the geometry of the agent applying the operator. The rectangles overlapping the border of the geometry are keptlist&lt;geometry&gt; var1 &lt;- to_rectangles(self, 5, 20, true); \t// var1 equals the list of rectangles corresponding to the discretization by a grid of 5 columns and 20 rows into rectangles of the geometry of the agent applying the operator. The rectangles overlapping the border of the geometry are keptto_squaresSame signification as split_geometryPossible use:  to_squares (geometry, int, bool) —&gt;  list&lt;geometry&gt;  to_squares (geometry, float, bool) —&gt;  list&lt;geometry&gt;  to_squares (geometry, int, bool, float) —&gt;  list&lt;geometry&gt;Result:A list of a given number of squares from the decomposition of the geometry into squares (geometry, nb_square, overlaps), if overlaps = true, add the squares that overlap the border of the geometryA list of squares of the size corresponding to the given size that result from the decomposition of the geometry into squares (geometry, size, overlaps), if overlaps = true, add the squares that overlap the border of the geometryA list of a given number of squares from the decomposition of the geometry into squares (geometry, nb_square, overlaps, precision_coefficient), if overlaps = true, add the squares that overlap the border of the geometry, coefficient_precision should be close to 1.0Examples:list&lt;geometry&gt; var0 &lt;- to_squares(self, 10, true); \t// var0 equals the list of 10 squares corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are keptlist&lt;geometry&gt; var1 &lt;- to_squares(self, 10.0, true); \t// var1 equals the list of squares of side size 10.0 corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are keptlist&lt;geometry&gt; var2 &lt;- to_squares(self, 10, true, 0.99); \t// var2 equals the list of 10 squares corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are keptto_trianglesSame signification as triangulatetokenizeSame signification as split_withtopologyPossible use:  topology (unknown) —&gt;  topologyResult:casting of the operand to a topology.Special cases:  if the operand is a topology, returns the topology itself;  if the operand is a spatial graph, returns the graph topology associated;  if the operand is a population, returns the topology of the population;  if the operand is a shape or a geometry, returns the continuous topology bounded by the geometry;  if the operand is a matrix, returns the grid topology associated  if the operand is another kind of container, returns the multiple topology associated to the container  otherwise, casts the operand to a geometry and build a topology from it.Examples:topology var0 &lt;- topology(0); \t// var0 equals niltopology(a_graph)\t--: Multiple topology in POLYGON ((24.712119771887785 7.867357373616512, 24.712119771887785 61.283226839310565, 82.4013676510046  7.867357373616512)) at location[53.556743711446195;34.57529210646354]See also:geometry,touchesPossible use:  geometry touches geometry —&gt;  bool  touches (geometry , geometry) —&gt;  boolResult:A boolean, equal to true if the left-geometry (or agent/point) touches the right-geometry (or agent/point).Comment:returns true when the left-operand only touches the right-operand. When one geometry covers partially (or fully) the other one, it returns false.Special cases:  if one of the operand is null, returns false.Examples:bool var0 &lt;- polyline([{10,10},{20,20}]) touches {15,15}; \t// var0 equals falsebool var1 &lt;- polyline([{10,10},{20,20}]) touches {10,10}; \t// var1 equals truebool var2 &lt;- {15,15} touches {15,15}; \t// var2 equals falsebool var3 &lt;- polyline([{10,10},{20,20}]) touches polyline([{10,10},{5,5}]); \t// var3 equals truebool var4 &lt;- polyline([{10,10},{20,20}]) touches polyline([{5,5},{15,15}]); \t// var4 equals falsebool var5 &lt;- polyline([{10,10},{20,20}]) touches polyline([{15,15},{25,25}]); \t// var5 equals falsebool var6 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{15,15},{15,25},{25,25},{25,15}]); \t// var6 equals falsebool var7 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{10,20},{20,20},{20,30},{10,30}]); \t// var7 equals truebool var8 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{10,10},{0,10},{0,0},{10,0}]); \t// var8 equals truebool var9 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) touches {15,15}; \t// var9 equals falsebool var10 &lt;- polygon([{10,10},{10,20},{20,20},{20,10}]) touches {10,15}; \t// var10 equals trueSee also:disjoint_from, crosses, overlaps, partially_overlaps, intersects,towardsPossible use:  geometry towards geometry —&gt;  int  towards (geometry , geometry) —&gt;  intResult:The direction (in degree) between the two geometries (geometries, agents, points) considering the topology of the agent applying the operator.Examples:int var0 &lt;- ag1 towards ag2; \t// var0 equals the direction between ag1 and ag2 and ag3 considering the topology of the agent applying the operatorSee also:distance_between, distance_to, direction_between, path_between, path_to,tracePossible use:  trace (matrix) —&gt;  floatResult:The trace of the given matrix (the sum of the elements on the main diagonal).Examples:float var0 &lt;- trace(matrix([[1,2],[3,4]])); \t// var0 equals 5transformed_byPossible use:  geometry transformed_by point —&gt;  geometry  transformed_by (geometry , point) —&gt;  geometryResult:A geometry resulting from the application of a rotation and a scaling (right-operand : point {angle(degree), scale factor} of the left-hand operand (geometry, agent, point)Examples:geometry var0 &lt;- self transformed_by {45, 0.5}; \t// var0 equals the geometry resulting from 45 degrees rotation and 50% scaling of the geometry of the agent applying the operator.See also:rotated_by, translated_by,translated_byPossible use:  geometry translated_by point —&gt;  geometry  translated_by (geometry , point) —&gt;  geometryResult:A geometry resulting from the application of a translation by the right-hand operand distance to the left-hand operand (geometry, agent, point)Examples:geometry var0 &lt;- self translated_by {10,10,10}; \t// var0 equals the geometry resulting from applying the translation to the left-hand geometry (or agent).See also:rotated_by, transformed_by,translated_toSame signification as at_locationtransposePossible use:  transpose (matrix) —&gt;  matrixResult:The transposition of the given matrixExamples:matrix var0 &lt;- transpose(matrix([[5,-3],[6,-4]])); \t// var0 equals [[5,6],[-3,-4]]trianglePossible use:  triangle (float) —&gt;  geometryResult:A triangle geometry which side size is given by the operand.Comment:the center of the triangle is by default the location of the current agent in which has been called this operator.Special cases:  returns nil if the operand is nil.Examples:geometry var0 &lt;- triangle(5); \t// var0 equals a geometry as a triangle with side_size = 5.See also:around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, square,triangulatePossible use:  triangulate (list&lt;geometry&gt;) —&gt;  list&lt;geometry&gt;  triangulate (geometry) —&gt;  list&lt;geometry&gt;Result:A list of geometries (triangles) corresponding to the Delaunay triangulation of the operand geometry (geometry, agent, point)Examples:list&lt;geometry&gt; var0 &lt;- triangulate(self); \t// var0 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator.list&lt;geometry&gt; var1 &lt;- triangulate(self); \t// var1 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator.truncated_gaussPossible use:  truncated_gauss (container) —&gt;  float  truncated_gauss (point) —&gt;  floatResult:A random value from a normally distributed random variable in the interval ]mean - standardDeviation; mean + standardDeviation[.Special cases:  if the operand is a list, only the two first elements are taken into account as [mean, standardDeviation]  when truncated_gauss is called with a list of only one element mean, it will always return 0.0  when the operand is a point, it is read as {mean, standardDeviation}Examples:float var0 &lt;- truncated_gauss ([0.5, 0.0]); \t// var0 equals 0.5float var1 &lt;- truncated_gauss ({0, 0.3}); \t// var1 equals a float between -0.3 and 0.3See also:gauss,undirectedPossible use:  undirected (graph) —&gt;  graphResult:the operand graph becomes an undirected graph.Comment:the operator alters the operand graph, it does not create a new one.See also:directed,unionPossible use:  union (container&lt;geometry&gt;) —&gt;  geometry  container union container —&gt;  container  union (container , container) —&gt;  containerResult:returns a new list containing all the elements of both containers without duplicated elements.Special cases:  if the left or right operand is nil, union throws an error  if the right-operand is a container of points, geometries or agents, returns the geometry resulting from the union all the geometriesExamples:container var0 &lt;- [1,2,3,4,5,6] union [2,4,9]; \t// var0 equals [1,2,3,4,5,6,9]container var1 &lt;- [1,2,3,4,5,6] union [0,8]; \t// var1 equals [1,2,3,4,5,6,0,8]container var2 &lt;- [1,3,2,4,5,6,8,5,6] union [0,8]; \t// var2 equals [1,3,2,4,5,6,8,0]geometry var3 &lt;- union([geom1, geom2, geom3]); \t// var3 equals a geometry corresponding to union between geom1, geom2 and geom3See also:inter, +,unknownPossible use:  unknown (any) —&gt;  unknownResult:Casts the operand into the type unknownuntilPossible use:  until (date) —&gt;  bool  any expression until date —&gt;  bool  until (any expression , date) —&gt;  boolResult:Returns true if the current_date of the model is before (or equel to) the date passed in argument. Synonym of ‘current_date &lt;= argument’Examples:reflex when: until(starting_date) {} -: will be run only once at the beginning of the simulationupper_casePossible use:  upper_case (string) —&gt;  stringResult:Converts all of the characters in the string operand to upper caseExamples:string var0 &lt;- upper_case(\"Abc\"); \t// var0 equals 'ABC'See also:lower_case,use_cachePossible use:  graph use_cache bool —&gt;  graph  use_cache (graph , bool) —&gt;  graphResult:if the second operand is true, the operand graph will store in a cache all the previously computed shortest path (the cache be cleared if the graph is modified).Comment:the operator alters the operand graph, it does not create a new one.See also:path_between,user_inputPossible use:  user_input (any expression) —&gt;  map&lt;string,unknown&gt;  string user_input any expression —&gt;  map&lt;string,unknown&gt;  user_input (string , any expression) —&gt;  map&lt;string,unknown&gt;Result:asks the user for some values (not defined as parameters). Takes a string (optional) and a map as arguments. The string is used to specify the message of the dialog box. The map is to specify the parameters you want the user to change before the simulation starts, with the name of the parameter in string key, and the default value as value.Comment:This operator takes a map [string::value] as argument, displays a dialog asking the user for these values, and returns the same map with the modified values (if any). The dialog is modal and will interrupt the execution of the simulation until the user has either dismissed or accepted it. It can be used, for instance, in an init section to force the user to input new values instead of relying on the initial values of parameters :Examples:map&lt;string,unknown&gt; values2 &lt;- user_input(\"Enter numer of agents and locations\",[\"Number\" :: 100, \"Location\" :: {10, 10}]);create bug number: int(values2 at \"Number\") with: [location:: (point(values2 at \"Location\"))];map&lt;string,unknown&gt; values &lt;- user_input([\"Number\" :: 100, \"Location\" :: {10, 10}]);create bug number: int(values at \"Number\") with: [location:: (point(values at \"Location\"))];usingPossible use:  any expression using topology —&gt;  unknown  using (any expression , topology) —&gt;  unknownResult:Allows to specify in which topology a spatial computation should take place.Special cases:  has no effect if the topology passed as a parameter is nilExamples:unknown var0 &lt;- (agents closest_to self) using topology(world); \t// var0 equals the closest agent to self (the caller) in the continuous topology of the worldvariancePossible use:  variance (container) —&gt;  floatResult:the variance of the elements of the operand. See Variance for more details.Comment:The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.Examples:float var0 &lt;- variance ([4.5, 3.5, 5.5, 7.0]); \t// var0 equals 1.671875See also:mean, median,variance_ofPossible use:  container variance_of any expression —&gt;  unknown  variance_of (container , any expression) —&gt;  unknownResult:the variance of the right-hand expression evaluated on each of the elements of the left-hand operandComment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.See also:min_of, max_of, sum_of, product_of,voronoiPossible use:  voronoi (list&lt;point&gt;) —&gt;  list&lt;geometry&gt;  list&lt;point&gt; voronoi geometry —&gt;  list&lt;geometry&gt;  voronoi (list&lt;point&gt; , geometry) —&gt;  list&lt;geometry&gt;Result:A list of geometries corresponding to the Voronoi diagram built from the list of points according to the given clipA list of geometries corresponding to the Voronoi diagram built from the list of pointsExamples:list&lt;geometry&gt; var0 &lt;- voronoi([{10,10},{50,50},{90,90},{10,90},{90,10}], square(300)); \t// var0 equals the list of geometries corresponding to the Voronoi Diagram built from the list of points with a square of 300m side size as clip.list&lt;geometry&gt; var1 &lt;- voronoi([{10,10},{50,50},{90,90},{10,90},{90,10}]); \t// var1 equals the list of geometries corresponding to the Voronoi Diagram built from the list of points.weight_ofPossible use:  graph weight_of unknown —&gt;  float  weight_of (graph , unknown) —&gt;  floatResult:returns the weight of the given edge (right-hand operand) contained in the graph given in right-hand operand.Comment:In a localized graph, an edge has a weight by default (the distance between both vertices).Special cases:  if the left-operand (the graph) is nil, returns nil  if the right-hand operand is not an edge of the given graph, weight_of checks whether it is a node of the graph and tries to return its weight  if the right-hand operand is neither a node, nor an edge, returns 1.Examples:graph graphFromMap &lt;-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);float var1 &lt;- graphFromMap weight_of(link({1,5}::{12,45})); \t// var1 equals 1.0weighted_means_DMPossible use:  list&lt;list&gt; weighted_means_DM list&lt;map&lt;string,object&gt;&gt; —&gt;  int  weighted_means_DM (list&lt;list&gt; , list&lt;map&lt;string,object&gt;&gt;) —&gt;  intResult:The index of the candidate that maximizes the weighted mean of its criterion values. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion (list of map)Special cases:  returns -1 is the list of candidates is nil or emptyExamples:int var0 &lt;- weighted_means_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"weight\" :: 2.0],[\"name\"::\"price\", \"weight\" :: 1.0]]); \t// var0 equals 1See also:promethee_DM, electre_DM, evidence_theory_DM,wherePossible use:  container where any expression —&gt;  container  where (container , any expression) —&gt;  containerResult:a list containing all the elements of the left-hand operand that make the right-hand operand evaluate to true.Comment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  if the left-hand operand is a list nil, where returns a new empty list  if the left-operand is a map, the keyword each will contain each valuecontainer var4 &lt;- [1::2, 3::4, 5::6] where (each &gt;= 4); \t// var4 equals [4, 6]Examples:container var0 &lt;- [1,2,3,4,5,6,7,8] where (each &gt; 3); \t// var0 equals [4, 5, 6, 7, 8] container var2 &lt;- g2 where (length(g2 out_edges_of each) = 0 ); \t// var2 equals [node9, node7, node10, node8, node11]container var3 &lt;- (list(node) where (round(node(each).location.x) &gt; 32); \t// var3 equals [node2, node3]See also:first_with, last_with, where,with_lifetimePossible use:  predicate with_lifetime int —&gt;  predicate  with_lifetime (predicate , int) —&gt;  predicateResult:change the parameters of the given predicateExamples:predicate with_lifetime 10with_max_ofPossible use:  container with_max_of any expression —&gt;  unknown  with_max_of (container , any expression) —&gt;  unknownResult:one of elements of the left-hand operand that maximizes the value of the right-hand operandComment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  if the left-hand operand is nil, with_max_of returns the default value of the right-hand operandExamples:unknown var0 &lt;- [1,2,3,4,5,6,7,8] with_max_of (each ); \t// var0 equals 8unknown var2 &lt;- g2 with_max_of (length(g2 out_edges_of each)  ) ; \t// var2 equals node4unknown var3 &lt;- (list(node) with_max_of (round(node(each).location.x)); \t// var3 equals node3unknown var4 &lt;- [1::2, 3::4, 5::6] with_max_of (each); \t// var4 equals 6See also:where, with_min_of,with_min_ofPossible use:  container with_min_of any expression —&gt;  unknown  with_min_of (container , any expression) —&gt;  unknownResult:one of elements of the left-hand operand that minimizes the value of the right-hand operandComment:in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.Special cases:  if the left-hand operand is nil, with_max_of returns the default value of the right-hand operandExamples:unknown var0 &lt;- [1,2,3,4,5,6,7,8] with_min_of (each ); \t// var0 equals 1unknown var2 &lt;- g2 with_min_of (length(g2 out_edges_of each)  ); \t// var2 equals node11unknown var3 &lt;- (list(node) with_min_of (round(node(each).location.x)); \t// var3 equals node0unknown var4 &lt;- [1::2, 3::4, 5::6] with_min_of (each); \t// var4 equals 2See also:where, with_max_of,with_optimizer_typePossible use:  graph with_optimizer_type string —&gt;  graph  with_optimizer_type (graph , string) —&gt;  graphResult:changes the shortest path computation method of the given graphComment:the right-hand operand can be “Djikstra”, “Bellmann”, “Astar” to use the associated algorithm. Note that these methods are dynamic: the path is computed when needed. In contrarily, if the operand is another string, a static method will be used, i.e. all the shortest are previously computed.Examples:graphEpidemio &lt;- graphEpidemio with_optimizer_type \"static\";See also:set_verbose,with_praiseworthinessPossible use:  predicate with_praiseworthiness float —&gt;  predicate  with_praiseworthiness (predicate , float) —&gt;  predicateResult:change the praiseworthiness value of the given predicateExamples:predicate set_truth falsewith_precisionPossible use:  float with_precision int —&gt;  float  with_precision (float , int) —&gt;  float  point with_precision int —&gt;  point  with_precision (point , int) —&gt;  pointResult:Rounds off the value of left-hand operand to the precision given by the value of right-hand operandRounds off the ordinates of the left-hand point to the precision given by the value of right-hand operandExamples:float var0 &lt;- 12345.78943 with_precision 2; \t// var0 equals 12345.79float var1 &lt;- 123 with_precision 2; \t// var1 equals 123.00point var2 &lt;- {12345.78943, 12345.78943, 12345.78943} with_precision 2 ; \t// var2 equals {12345.79, 12345.79, 12345.79}See also:round,with_priorityPossible use:  predicate with_priority float —&gt;  predicate  with_priority (predicate , float) —&gt;  predicateResult:change the priority of the given predicateExamples:predicate with_priority 2with_valuesPossible use:  predicate with_values map —&gt;  predicate  with_values (predicate , map) —&gt;  predicateResult:change the parameters of the given predicateExamples:predicate with_values [\"time\"::10]with_weightsPossible use:  graph with_weights map —&gt;  graph  with_weights (graph , map) —&gt;  graph  graph with_weights container —&gt;  graph  with_weights (graph , container) —&gt;  graphResult:returns the graph (left-hand operand) with weight given in the map (right-hand operand).Comment:this operand re-initializes the path finderSpecial cases:  if the right-hand operand is a list, affects the n elements of the list to the n first edges. Note that the ordering of edges may change overtime, which can create some problems…  if the left-hand operand is a map, the map should contains pairs such as: vertex/edge::doublegraph_from_edges (list(ant) as_map each::one_of (list(ant))) with_weights (list(ant) as_map each::each.food)without_holesPossible use:  without_holes (geometry) —&gt;  geometryResult:A geometry corresponding to the operand geometry (geometry, agent, point) without its holesExamples:geometry var0 &lt;- solid(self); \t// var0 equals the geometry corresponding to the geometry of the agent applying the operator without its holes.writablePossible use:  file writable bool —&gt;  file  writable (file , bool) —&gt;  fileResult:Marks the file as read-only or not, depending on the second boolean argument, and returns the first argumentComment:A file is created using its native flags. This operator can change them. Beware that this change is system-wide (and not only restrained to GAMA): changing a file to read-only mode (e.g. “writable(f, false)”)Examples:file var0 &lt;- shape_file(\"../images/point_eau.shp\") writable false; \t// var0 equals returns a file in read-only modeSee also:file,xml_filePossible use:  xml_file (string) —&gt;  fileResult:Constructs a file of type xml. Allowed extensions are limited to xmlyears_betweenPossible use:  date years_between date —&gt;  int  years_between (date , date) —&gt;  intResult:Provide the exact number of years between two dates. This number can be positive or negative (if the second operand is smaller than the first one)Examples:years_between(d1, d2) -: 10 ",
        "url":"/wiki/OperatorsNZ.html"
      }
      ,
    
      "wiki-optimizingmodels-html": {
        "title": "Optimizing Models",
        "content": "Optimizing ModelsThis page aims at presenting some tips to optimize the memory footprint or the execution time of a model in GAMA.Note:  since GAMA 1.6.1, some optimizations have become obsolete because they have been included in the compiler. They have, then, been removed from this page. For instance, writing ‘rgb(0,0,0)’ is now compiled directly as ‘#black’.Table of contents  machine_time  Scheduling  Grid          Optimization Facets                  use_regular_agents          use_individual_shapes                      Operators          List operators                  first_with          where / count                    Spatial operators                  container of agents in closest_to, at_distance, overlapping, inside          Accelerate  with a first spatial filtering                      Displays          shape      circle vs square / sphere vs cube      OpenGL refresh facets      machine_timeIn order to optimize a model, it is important to exactly know which part of the model take times. The simplest to do that is to use the machine_time built-in global variable that gives the current time in milliseconds. Then to compute the time taken by a statement, a possible way is to write:float t &lt;- machine_time;// here a block of instructions that you consider as \"critical\"// ...write \"duration of the last instructions: \" + (machine_time - t);SchedulingIf you have a species of agents that, once created, are not supposed to do anything more (i.e. no behavior, no reflex, their actions triggered by other agents, their attributes being simply read and written by other agents), such as a “data” grid, or agents representing a “background” (from a shape file, etc.), consider using the schedules: [] facet on the definition of their species. This trick allows to tell GAMA to not schedule any of these agents.grid my_grid height: 100 width: 100 schedules: [] {      ...}The schedules: facet is dynamically computed (even if the agents are not scheduled), so, if you happen to define agents that only need to be scheduled every x cycles, or depending on a condition, you can also write schedules: to implement this. For instance, the following species will see its instances scheduled every 10 steps and only if a certain condition is met:species my_species schedules: (every 10) ? (condition ? my_species : []) : [] {     ...}In the same way, modelers can use the frequency facet to define when the agents of a species are going to be activated. By setting this facet to 0, the agents are never activated.species my_species frequency: 0{     ...}GridOptimization FacetsIn this section, we present some facets that allow to optimize the use of grid (in particular in terms of memories). Note that all these facet can be combined (see the Life model from the Models library).use_regular_agentsIf false, then a special class of agents is used. This special class of agents used less memories but has some limitation: the agents cannot inherit from a “normal” species, they cannot have sub-populations, their name cannot be modified, etc.grid cell width: 50 height: 50 use_regular_agents: false ;use_individual_shapesIf false, then only one geometry is used for all agents. This facet allows to gain a lot of memory, but should not be used if the geometries of the agents are often activated (for instance, by an aspect).grid cell width: 50 height: 50 use_individual_shapes: false ;\tOperatorsList operatorsfirst_withIt is sometimes necessary to randomly select an element of a list that verifies a certain condition.Many modelers use the one_of and the where operators to do this:bug one_big_bug &lt;- one_of (bug where (each.size &gt; 10));Whereas it is often more optimized to use the shuffle operator to shuffle the list, then the first_with operator to select the first element that verifies the condition:bug one_big_bug &lt;- shuffle(bug) first_with (each.size &gt; 10);where / countIt is quite common to want to count the number of elements of a list or a container that verify a condition.The obvious to do it is :int n &lt;- length(my_container where (each.size &gt; 10));This will however create an intermediary list before counting it, and this operation can be time consuming if the number of elements is important. To alleviate this problem, GAMA includes an operator called count that will count the elements that verify the condition by iterating directly on the container (no useless list created) :int n &lt;- my_container count (each.size &gt; 10);Spatial operatorscontainer of agents in closest_to, at_distance, overlapping, insideSeveral spatial query operators (such as closest_to, at_distance, overlapping or inside) allow to restrict the agents being queried to a container of agents. For instance, one can write:agent closest_agent &lt;- a_container_containing_agents closest_to self;This expression is formally equivalent to :agent closest_agent &lt;- a_container_containing_agent with_min_of (each distance_to self);But it is much faster if your container is large, as it will query the agents using a spatial index (instead of browsing through the whole container). Note that in some cases, when you have a small number of agents, the first syntax will be faster. The same applies for the other operators.Now consider a very common case: you need to restrict the agents being queried, not to a container, but to a species (which, actually, acts as a container in most cases). For instance, you want to know which predator is the closest to the current agent. If we apply the pattern above, we would write:predator closest_predator &lt;- predator with_min_of (each distance_to self);orpredator closest_predator &lt;- list(predator) closest_to self;But these two operators can be painfully slow if your species has many instances (even in the second form). In that case, always prefer using directly the species as the left member:predator closest_ predator &lt;- predator closest_to self;Not only is the syntax clearer, but the speed gain can be phenomenal because, in that case, the list of instances is not used (we just check if the agent is an instance of the left species).However, what happens if one wants to query instances belonging to 2 or more species ? If we follow our reasoning, the immediate way to write it would be (if predator 1 and predator 2 are two species):agent closest_agent &lt;- (list(predator1) + list(predator2)) closest_to self; or, more simply:agent closest_agent &lt;- (predator1 + predator2) closest_to self;The first syntax suffers from the same problem than the previous syntax: GAMA has to browse through the list (created by the concatenation of the species populations) to filter agents. The solution, then, is again to use directly the species, as GAMA is clever enough to create a temporary “fake” population out of the concatenation of several species, which can be used exactly like a list of agents, but provides the advantages of a species population (no iteration made during filtering).Accelerate closest_to with a first spatial filteringThe closest_to operator can sometimes be slow if numerous agents are concerned by this query. If the modeler is just interested by a small subset of agents, it is possible to apply a first spatial filtering on the agent list by using the at_distance operator.For example, if the modeler wants first to do a spatial filtering of 10m:agent closest_agent &lt;- (predator1 at_distance 10) closest_to self;To be sure to find an agent, the modeler can use a test statement:agent closest_agent &lt;- (predator1 at_distance 10) closest_to self;if (closest_agent = nil) {closest_agent  &lt;- predator1 closest_to self;}DisplaysshapeIt is quite common to want to display an agent as a circle or a square. A common mistake is to mix up the shape to draw and the geometry of the agent in the model. If the modeler just wants to display a particular shape, he/she should not modify the agent geometry (which is a point by default), but just specify the shape to draw in the agent aspect.species bug {     int size &lt;- rnd(100);\t      aspect circle {          draw circle(2) color: °blue;      }}circle vs square / sphere vs cubeNote that in OpenGL and Java2D (the two rendering subsystems used in GAMA), creating and drawing a circle geometry is more time consuming than creating and drawing a square (or a rectangle). In the same way, drawing a sphere is more time consuming than drawing a cube. Hence, if you want to optimize your model displays and if the rendering does not explicitly need “rounded” agents, try to use squares/cubes rather than circles/spheres.OpenGL refresh facetsIn OpenGL display, it is possible to specify that it is not necessary to refresh a layer with the facet refresh. If a species of agents is never modified in terms of visualization (location, shape or color), you can set refresh to false. Example:display city_display_opengl type: opengl{     species building aspect: base refresh: false;     species road aspect: base refresh: false;     species people aspect: base;}",
        "url":"/wiki/OptimizingModels.html"
      }
      ,
    
      "wiki-optimizingmodelssection-html": {
        "title": "Optimizing Models",
        "content": "Optimizing ModelsNow you are becoming more comfortable with GAML, it is time to think about how the runtime works, to be able to run some more optimized models. Indeed, if you already tried to write some models by yourself using GAML, you could have notice that the execution time depends a lot of how you implemented your model !We will first present you in this part some runtime concepts (and present you the species facet scheduler), and we will then show you some tips to optimize your models (how to increase performances using scheduler, grids, displays and how to choose your operators).",
        "url":"/wiki/OptimizingModelsSection.html"
      }
      ,
    
      "wiki-ordinary-differential-equations-built-in-equations-html": {
        "title": "Predefined equestions",
        "content": "Predefined equestionsAuthor : Benoit GaudouPresentation of all the predefined equation systems.Comparaison with hand-written systems to test them. == $0 == $0 == $0 == $0 == $0 == $0 == $0Code of the model :model all_predefined_equationsglobal {\tfloat mu &lt;- 0.02;\tfloat alpha &lt;- 35.842;\tfloat gamma &lt;- 100.0;\tfloat beta0 &lt;- 1884.95;\tfloat beta1 &lt;- 0.255;\tfloat hKR4 &lt;- 0.01;\t\tinit {\t\tcreate preSI  with: [h::0.1,N::500,I::1.0];\t\tcreate userSI with: [h::0.1,N::500,I::1.0];\t\tcreate preSIS  with: [h::0.1,N::500,I::1.0];\t\tcreate userSIS with: [h::0.1,N::500,I::1.0];\t\t\t\t\t\tcreate preSIR  with: [h::0.1,N::500,I::1.0];\t\tcreate userSIR with: [h::0.1,N::500,I::1.0];\t\t\t\tcreate preSIRS  with: [h::0.1,N::500,I::1.0];\t\tcreate userSIRS with: [h::0.1,N::500,I::1.0];\t\t\t\t\tcreate preSEIR  with: [h::0.1,N::500,I::1.0];\t\tcreate userSEIR with: [h::0.1,N::500,I::1.0];\t\t\t\t\t\tcreate preLV  with: [h::0.1,x::2.0,y::2.0];\t\tcreate userLV with: [h::0.1,x::2.0,y::2.0];\t\t\t\t}}species preSI {\tfloat t;\tint N;\tfloat I ; \tfloat S &lt;- N - I; \tfloat h;\tfloat beta&lt;-0.4;\t// must be followed with exact order S, I, t  and N,beta\tequation eqSI type: SI vars: [S,I,t] params: [N,beta] ;\t/*reflex solving {\t\tlist i_list;\t\t//solve eqSI method: \"dp853\" step: 0.01 cycle_length: 100 min_step: 1 max_step: 1 scalAbsoluteTolerance: 1 scalRelativeTolerance: 1 integrated_times: i_list ;\t\t//solve eqSI method:rk4 step:h;\t}*/\t\treflex solving {\t\tlist i_list;\t\tlist v_list ;\t\tsolve eqSI method: \"rk4\" step: h ;//cycle_length: 1/h integrated_times: i_list integrated_values: v_list;\t\twrite \"i_list: \" + i_list;\t\twrite \"v_list:\" + v_list;\t}}species userSI {\tfloat t;\tint N;\tfloat I ; \tfloat S &lt;- N - I; \tfloat h;\tfloat beta&lt;-0.4;\t\tequation eqSI {\t\tdiff(S,t) = -beta * S * I / N ;\t\tdiff(I,t) = beta * S * I / N ;\t}\t\t\treflex solving{solve eqSI method:rk4 step:h;}\t}species preSIS {\tfloat t;\tint N;\tfloat I ; \tfloat S &lt;- N - I; \tfloat h;\tfloat beta&lt;-0.4;\tfloat gamma&lt;-0.01;    \t\t\t// must be followed with exact order S, I, t  and N,beta\tequation eqSIS type: SIS vars: [S,I,t] params: [N,beta,gamma] ;\treflex solving {\t\tsolve eqSIS method:rk4 step:h;\t}}species userSIS {\tfloat t;\tint N;\tfloat I ; \tfloat S &lt;- N - I; \tfloat h;\tfloat beta&lt;-0.4;\tfloat gamma&lt;-0.01;    \t\t\t\tequation eqSIS {\t\tdiff(S,t) = -beta * S * I / N + gamma * I;\t\tdiff(I,t) = beta * S * I / N - gamma * I;\t}\t\t\treflex solving {\t\t\tsolve eqSIS method:rk4 step:h;\t}}species preSIR {\tfloat t;\tint N;\tfloat I ; \tfloat S &lt;- N - I; \tfloat R &lt;- 0.0; \tfloat h;\tfloat beta&lt;-0.4;\tfloat gamma&lt;-0.01; \t// must be followed with exact order S, I, R, t  and N,beta,delta\tequation eqSIR type:SIR vars:[S,I,R,t] params:[N,beta,gamma] ;\treflex solving {\t\t\tsolve eqSIR method:rk4 step:h;\t}}species userSIR{\tfloat t;\tint N;\tfloat I ; \tfloat S &lt;- N - I; \tfloat R &lt;- 0.0; \tfloat h;\tfloat beta&lt;-0.4;\tfloat gamma&lt;-0.01; \t\t\t\t\t\tequation eqSIR {\t\tdiff(S,t) = (- beta * S * I / N);\t\tdiff(I,t) = (beta * S * I / N) - (gamma * I);\t\tdiff(R,t) = (gamma * I);\t}\t\t\treflex solving {\t\tsolve eqSIR method:rk4 step:h;\t}}species preSIRS {\tfloat t;\tint N;\tfloat I ; \tfloat S &lt;- N - I; \tfloat R &lt;- 0.0; \tfloat h;\tfloat beta&lt;-0.4;\tfloat gamma&lt;-0.01; \tfloat omega &lt;- 0.05;\tfloat mu &lt;- 0.01;\t// must be followed with exact order S, I, R, t  and N,beta,delta\tequation eqSIRS type: SIRS vars: [S,I,R,t] params: [N,beta,gamma,omega,mu] ;\treflex solving {\t\tsolve eqSIRS method:rk4 step:h;\t}}species userSIRS {\tfloat t;\tint N;\tfloat I ; \tfloat S &lt;- N - I; \tfloat R &lt;- 0.0; \tfloat h;\tfloat beta&lt;-0.4;\tfloat gamma&lt;-0.01; \t\tfloat omega &lt;- 0.05;\tfloat mu &lt;- 0.01;   \t\t\t\t\t\t\tequation eqSIRS {\t\t diff(S,t) = mu * N + omega * R + - beta * S * I / N - mu * S ;\t\t diff(I,t) = beta * S * I / N - gamma * I - mu * I ;\t\t diff(R,t) = gamma * I - omega * R - mu * R ;\t}\t\t\treflex solving {\t\tsolve eqSIRS method:rk4 step:h;\t}}species preSEIR {\tfloat t;\tint N;\tfloat S &lt;- N - I;     \t\tfloat E &lt;- 0.0;\tfloat I ; \tfloat R &lt;- 0.0; \tfloat h;\tfloat beta&lt;-0.4;\tfloat gamma&lt;-0.01; \tfloat sigma &lt;- 0.05;\tfloat mu &lt;- 0.01;\t// must be followed with exact order S, E, I, R, t  and N,beta,gamma,sigma,mu\tequation eqSEIR type: SEIR vars: [S,E,I,R,t] params: [N,beta,gamma,sigma,mu] ;\treflex solving {\t\tsolve eqSEIR method:rk4 step:h;\t}}species userSEIR {\tfloat t;\tint N;\tfloat S &lt;- N - I;     \t\tfloat E &lt;- 0.0;\tfloat I ; \tfloat R &lt;- 0.0; \tfloat h;\tfloat beta&lt;-0.4;\tfloat gamma&lt;-0.01; \t\tfloat sigma &lt;- 0.05;\tfloat mu &lt;- 0.01;   \t\t\t\t\t\t\tequation eqSEIR {\t\tdiff(S,t) = mu * N - beta * S * I / N - mu * S ;\t\tdiff(E,t) = beta * S * I / N - mu * E - sigma * E ;\t\tdiff(I,t) = sigma * E - mu * I - gamma * I;\t\tdiff(R,t) = gamma * I - mu * R ;\t}\t\t\treflex solving {\tsolve eqSEIR method:rk4 step:h;\t}}species preLV {\tfloat t;\tfloat x ; \tfloat y ; \tfloat h;\tfloat alpha &lt;- 0.8 ;\tfloat beta  &lt;- 0.3 ;\tfloat gamma &lt;- 0.2 ;\tfloat delta &lt;- 0.85;\t// must be followed with exact order x, y, t  and  alpha,beta,delta,gamma\tequation eqLV type: LV vars: [x,y,t] params: [alpha,beta,delta,gamma] ;\treflex solving {\t\tsolve eqLV method:rk4 step:h;\t}}species userLV {\tfloat t;\tfloat x ; \tfloat y ; \tfloat h;\tfloat alpha &lt;- 0.8 ;\tfloat beta  &lt;- 0.3 ;\tfloat gamma &lt;- 0.2 ;\tfloat delta &lt;- 0.85;\t\tequation eqLV { \t\tdiff(x,t) =   x * (alpha - beta * y);\t\tdiff(y,t) = - y * (delta - gamma * x);    }\t\t\treflex solving {\t\tsolve eqLV method:rk4 step:h;\t}}experiment examples type: gui {\toutput {\t\t\t\tdisplay SI  {\t\t\tchart 'examplePreSI' type: series background: #lightgray position: {0,0} size:{1,0.5} {\t\t\t\tdata \"S\" value: first(preSI).S color: #green;\t\t\t\tdata \"I\" value: first(preSI).I color: #red;\t\t\t}\t\t\tchart 'examplesUserSI' type: series background: #lightgray position: {0,0.5} size:{1,0.5} {\t\t\t\tdata \"S\" value: first(userSI).S color: #green;\t\t\t\tdata \"I\" value: first(userSI).I color: #red;\t\t\t}\t\t}\t\tdisplay SISs  {\t\t\tchart 'examplePreSIS' type: series background: #lightgray position: {0,0} size:{1,0.5} {\t\t\t\tdata \"S\" value: first(preSIS).S color: #green;\t\t\t\tdata \"I\" value: first(preSIS).I color: #red;\t\t\t}\t\t\tchart 'examplesUserSIS' type: series background: #lightgray position: {0,0.5} size:{1,0.5} {\t\t\t\tdata \"S\" value: first(userSIS).S color: #green;\t\t\t\tdata \"I\" value: first(userSIS).I color: #red;\t\t\t}\t\t\t\t\t}\t\t\t\tdisplay SIR  {\t\t\tchart 'examplePreSIR' type: series background: #lightgray position: {0,0} size:{1,0.5} {\t\t\t\tdata \"S\" value: first(preSIR).S color: #green;\t\t\t\tdata \"I\" value: first(preSIR).I color: #red;\t\t\t\tdata \"R\" value: first(preSIR).R color: #blue;\t\t\t}\t\t\tchart 'examplesUserSIR' type: series background: #lightgray position: {0,0.5} size:{1,0.5} {\t\t\t\tdata \"S\" value: first(userSIR).S color: #green;\t\t\t\tdata \"I\" value: first(userSIR).I color: #red;\t\t\t\tdata \"R\" value: first(userSIR).R color: #blue;\t\t\t}\t\t\t\t\t}\t\tdisplay SIRS  {\t\t\tchart 'examplePreSIRS' type: series background: #lightgray position: {0,0} size:{1,0.5} {\t\t\t\tdata \"S\" value: first(preSIRS).S color: #green;\t\t\t\tdata \"I\" value: first(preSIRS).I color: #red;\t\t\t\tdata \"R\" value: first(preSIRS).R color: #blue;\t\t\t}\t\t\tchart 'examplesUserSIRS' type: series background: #lightgray position: {0,0.5} size:{1,0.5} {\t\t\t\tdata \"S\" value: first(userSIRS).S color: #green;\t\t\t\tdata \"I\" value: first(userSIRS).I color: #red;\t\t\t\tdata \"R\" value: first(userSIRS).R color: #blue;\t\t\t}\t\t\t\t\t}\t\tdisplay SEIR  {\t\t\tchart 'examplePreSEIR' type: series background: #lightgray position: {0,0} size:{1,0.5} {\t\t\t\tdata \"S\" value: first(preSEIR).S color: #green;\t\t\t\tdata \"E\" value: first(preSEIR).E color: #yellow;\t\t\t\tdata \"I\" value: first(preSEIR).I color: #red;\t\t\t\tdata \"R\" value: first(preSEIR).R color: #blue;\t\t\t}\t\t\tchart 'examplesUserSEIR' type: series background: #lightgray position: {0,0.5} size:{1,0.5} {\t\t\t\tdata \"S\" value: first(userSEIR).S color: #green;\t\t\t\tdata \"E\" value: first(userSEIR).E color: #yellow;\t\t\t\t\t\t\t\tdata \"I\" value: first(userSEIR).I color: #red;\t\t\t\tdata \"R\" value: first(userSEIR).R color: #blue;\t\t\t}\t\t}\t\tdisplay LV  {\t\t\tchart 'examplePreLV' type: series background: #lightgray position: {0,0} size:{1,0.5} {\t\t\t\tdata \"x\" value: first(preLV).x color: #yellow;\t\t\t\tdata \"y\" value: first(preLV).y color: #blue;\t\t\t}\t\t\tchart 'examplesUserLV' type: series background: #lightgray position: {0,0.5} size:{1,0.5} {\t\t\t\tdata \"x\" value: first(userLV).x color: #yellow;\t\t\t\tdata \"y\" value: first(userLV).y color: #blue;\t\t\t}\t\t\t\t\t}\t\t\t\t\t\t\t}}experiment diff_predefined_defined_by_user type: gui {\toutput {\t\tdisplay diff  {\t\t\tchart 'diffSI' type: series background: #lightgray  position: {0,0} size:{0.5, 0.33} {\t\t\t\tdata \"dS\" value: (first(userSI).S - first(preSI).S) color: #yellow;\t\t\t\tdata \"dI\" value: (first(userSI).I - first(preSI).I) color: #blue;\t\t\t}\t\t\tchart 'diffSIS' type: series background: #lightgray position: {0.5,0} size:{0.5, 0.33} {\t\t\t\tdata \"dS\" value: (first(userSIS).S - first(preSIS).S) color: #yellow;\t\t\t\tdata \"dI\" value: (first(userSIS).I - first(preSIS).I) color: #blue;\t\t\t}\t\t\tchart 'diffSIR' type: series background: #lightgray position: {0,0.33} size:{0.5, 0.33} {\t\t\t\tdata \"dS\" value: (first(userSIR).S - first(preSIR).S) color: #yellow;\t\t\t\tdata \"dI\" value: (first(userSIR).I - first(preSIR).I) color: #blue;\t\t\t\tdata \"dR\" value: (first(userSIR).R - first(preSIR).R) color: #red;\t\t\t}\t\t\t\t\tchart 'diffSIRS' type: series background: #lightgray position: {0.5,0.33} size:{0.5, 0.33} {\t\t\t\tdata \"dS\" value: (first(userSIRS).S - first(preSIRS).S) color: #yellow;\t\t\t\tdata \"dI\" value: (first(userSIRS).I - first(preSIRS).I) color: #blue;\t\t\t\tdata \"dR\" value: (first(userSIRS).R - first(preSIRS).R) color: #red;\t\t\t}\t\t\t\tchart 'diffSEIR' type: series background: #lightgray position: {0,0.66} size:{0.5, 0.33} {\t\t\t\tdata \"dS\" value: (first(userSEIR).S - first(preSEIR).S) color: #yellow;\t\t\t\tdata \"dE\" value: (first(userSEIR).E - first(preSEIR).E) color: #yellow;\t\t\t\t\t\t\t\tdata \"dI\" value: (first(userSEIR).I - first(preSEIR).I) color: #blue;\t\t\t\tdata \"dR\" value: (first(userSEIR).R - first(preSEIR).R) color: #red;\t\t\t}\t\t\t\tchart 'diffLV' type: series background: #lightgray position: {0.5,0.66} size:{0.5, 0.33} {\t\t\t\tdata \"dx\" value: (first(userLV).x - first(preLV).x) color: #yellow;\t\t\t\tdata \"dy\" value: (first(userLV).y - first(preLV).y) color: #red;\t\t\t\t\t\t\t}\t\t\t\t\t\t\t}\t\t}}",
        "url":"/wiki/Ordinary-Differential-Equations-Built-In-Equations.html"
      }
      ,
    
      "wiki-ordinary-differential-equations-sir-influence-of-integration-step-html": {
        "title": "SIR (Influence of Integration Step).gaml",
        "content": "SIR (Influence of Integration Step).gamlAuthor : hqnghiA SIR model to illustrate the impact of the change of the integration parameters. == $0 == $0 == $0Code of the model :model SIR_influence_of_integration_stepglobal { \tfloat step&lt;-1#s;\tfloat beta &lt;- 0.8 ; \t\tfloat delta &lt;- 0.01 ; \t\tfloat s1 &lt;- 1#s;\tfloat s2 &lt;- 1.5#s;\tfloat s3 &lt;- 2#s;\t\tinit {\t\tcreate SIR_agt with: [h::1,myUnit::s1];\t\tcreate SIR_agt with: [h::0.1,myUnit::s2];\t\tcreate SIR_agt with: [h::0.01,myUnit::s3];\t  \t}  }species SIR_agt {\tint N &lt;- 500;    float t;    \tfloat I &lt;- 1.0; \tfloat S &lt;- N - I; \tfloat R &lt;- 0.0; \t\t   \tfloat h;   \t\t\tfloat myUnit&lt;-1#s;\tequation SIR{ \t\tdiff(S,t) =myUnit* (- beta  * S * I / N);\t\tdiff(I,t) =myUnit* (beta * S * I / N) - (delta * I);\t\tdiff(R,t) =myUnit* (delta * I);\t} \treflex solving {\t\tsolve SIR method: \"rk4\" step: h;// cycle_length:mycycle ;//\t\tS&lt;-S*myUnit;//\t\tI&lt;-I*myUnit;//\t\tR&lt;-R*myUnit;\t}      }experiment mysimulation1 type: gui {  \toutput { \t\tdisplay SIR_1  {\t\t\tchart \"SI - h=1\" type: series background: #white {\t\t\t\tdata 'S' value: first(SIR_agt where (each.myUnit = s1)).S color: #green;\t\t\t\t\t\t\t\tdata 'I' value: first(SIR_agt where (each.myUnit = s1)).I color: #red ;\t\t\t\tdata 'R' value: first(SIR_agt where (each.myUnit = s1)).R color: #blue ;\t\t\t\t\t\t\t}\t\t}\t\t\t\tdisplay SIR_10 {\t\t\tchart \"SI - h=0.1\" type: series background: #white{\t\t\t\tdata 'S' value: first(SIR_agt where (each.myUnit = s2)).S color: #green;\t\t\t\t\t\t\t\tdata 'I' value: first(SIR_agt where (each.myUnit = s2)).I color: #red ;\t\t\t\tdata 'R' value: first(SIR_agt where (each.myUnit = s2)).R color: #blue ;\t\t\t\t\t\t\t}\t\t}\t\t\t\tdisplay SIR_100  {\t\t\tchart \"SI - h=0.01\" type: series background: #white {\t\t\t\tdata 'S' value: first(SIR_agt where (each.myUnit = s3)).S color: #green;\t\t\t\t\t\t\t\tdata 'I' value: first(SIR_agt where (each.myUnit = s3)).I color: #red ;\t\t\t\tdata 'R' value: first(SIR_agt where (each.myUnit = s3)).R color: #blue ;\t\t\t\t\t\t\t}\t\t}\t\t}}",
        "url":"/wiki/Ordinary-Differential-Equations-SIR-(Influence-of-Integration-Step).html"
      }
      ,
    
      "wiki-ordinary-differential-equations-sir-simple-html": {
        "title": "SIR (Simple)",
        "content": "SIR (Simple)Author : hqnghiA simple example of ODE use into agents with the example of the SIR equation system. == $0Code of the model :model simple_ODE_SIRglobal {\tinit{\t\tcreate agent_with_SIR_dynamic number:1;\t}}species agent_with_SIR_dynamic {\tint N &lt;- 1500 ;\tint iInit &lt;- 1;\t\t    float t;  \tfloat S &lt;- N - float(iInit); \t      \tfloat I &lt;- float(iInit); \tfloat R &lt;- 0.0; \t\tfloat alpha &lt;- 0.2 min: 0.0 max: 1.0;\tfloat beta &lt;- 0.8 min: 0.0 max: 1.0;\tfloat h &lt;- 0.01;   \tequation SIR{ \t\tdiff(S,t) = (- beta * S * I / N);\t\tdiff(I,t) = (beta * S * I / N) - (alpha * I);\t\tdiff(R,t) = (alpha * I);\t}                    reflex solving {    \tsolve SIR method: \"rk4\" step: h ;//cycle_length: 1/h ;    }    }experiment maths type: gui {\toutput { \t\tdisplay display_charts {\t\t\tchart \"SIR_agent\" type: series background: #white {\t\t\t\tdata 'S' value: first(list(agent_with_SIR_dynamic)).S color: #green ;\t\t\t\t\t\t\t\tdata 'I' value: first(list(agent_with_SIR_dynamic)).I color: #red ;\t\t\t\tdata 'R' value: first(list(agent_with_SIR_dynamic)).R color: #blue ;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Ordinary-Differential-Equations-SIR-(Simple).html"
      }
      ,
    
      "wiki-ordinary-differential-equations-sir-simple-with-charts-html": {
        "title": "SIR (Simple)",
        "content": "SIR (Simple)Author : hqnghiA simple example of ODE use into agents with the example of the SIR equation system. == $0 == $0 == $0Code of the model :model simple_ODE_SIRglobal {\tinit{\t\tcreate aSIR number:10{\t\t\tS&lt;-S-(int(self)*10000);\t\t}\t}\tlist S_3d-&gt;{aSIR collect each.S};\tlist I_3d-&gt;{aSIR collect each.I};\tlist R_3d-&gt;{aSIR collect each.R};\treflex ss when: cycle&gt;=40{    \tdo pause;\t\t\t}}species aSIR {\tint N &lt;- 150000 ;\tint iInit &lt;- 1000;\t\t    float t;  \tfloat S &lt;- N - float(iInit); \t      \tfloat I &lt;- float(iInit); \tfloat R &lt;- 0.0; \t\tfloat alpha &lt;- 0.2 min: 0.0 max: 1.0;\tfloat beta &lt;- 0.8  min: 0.0 max: 1.0;\tfloat h &lt;- 0.1;   \tequation SIR{ \t\tdiff(S,t) = (- beta * S * I / N);\t\tdiff(I,t) = (beta * S * I / N) - (alpha * I);\t\tdiff(R,t) = (alpha * I);\t}                    reflex solving {    \tsolve SIR method: \"rk4\" step: h ;//cycle_length: 1/h ;    }    }experiment maths type: gui {\t\tfloat minimum_cycle_duration&lt;-0.2;\t\toutput { \t\tdisplay display_charts {\t\t\tchart \"SIR_agent\" type: series background: #white {\t\t\t\tdata 'S0' value: (aSIR[0]).S color: #green ;\t\t\t\t\t\t\t\tdata 'S1' value: (aSIR[1]).S color: #green ;\t\t\t\t\t\t\t\tdata 'S2' value: (aSIR[2]).S color: #green ;\t\t\t\t\t\t\t\tdata 'S3' value: (aSIR[3]).S color: #green ;\t\t\t\t\t\t\t\tdata 'S4' value: (aSIR[4]).S color: #green ;\t\t\t\t\t\t\t\tdata 'S5' value: (aSIR[5]).S color: #green ;\t\t\t\t\t\t\t\tdata 'S6' value: (aSIR[6]).S color: #green ;\t\t\t\t\t\t\t\tdata 'S7' value: (aSIR[7]).S color: #green ;\t\t\t\t\t\t\t\tdata 'S8' value: (aSIR[8]).S color: #green ;\t\t\t\t\t\tdata 'S9' value: (aSIR[9]).S color: #green ;\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata 'I0' value: (aSIR[0]).I color: #red ;\t\t\t\t\t\t\t\tdata 'I1' value: (aSIR[1]).I color: #red ;\t\t\t\t\t\t\t\tdata 'I2' value: (aSIR[2]).I color: #red ;\t\t\t\t\t\t\t\tdata 'I3' value: (aSIR[3]).I color: #red ;\t\t\t\t\t\t\t\tdata 'I4' value: (aSIR[4]).I color: #red ;\t\t\t\t\t\t\t\tdata 'I5' value: (aSIR[5]).I color: #red ;\t\t\t\t\t\t\t\tdata 'I6' value: (aSIR[6]).I color: #red ;\t\t\t\t\t\t\t\tdata 'I7' value: (aSIR[7]).I color: #red ;\t\t\t\t\t\t\t\tdata 'I8' value: (aSIR[8]).I color: #red ;\t\t\t\t\t\tdata 'I9' value: (aSIR[9]).I color: #red ;\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata 'R0' value: (aSIR[0]).R color: #blue ;\t\t\t\t\t\t\t\tdata 'R1' value: (aSIR[1]).R color: #blue ;\t\t\t\t\t\t\t\tdata 'R2' value: (aSIR[2]).R color: #blue ;\t\t\t\t\t\t\t\tdata 'R3' value: (aSIR[3]).R color: #blue ;\t\t\t\t\t\t\t\tdata 'R4' value: (aSIR[4]).R color: #blue ;\t\t\t\t\t\t\t\tdata 'R5' value: (aSIR[5]).R color: #blue ;\t\t\t\t\t\t\t\tdata 'R6' value: (aSIR[6]).R color: #blue ;\t\t\t\t\t\t\t\tdata 'R7' value: (aSIR[7]).R color: #blue ;\t\t\t\t\t\t\t\tdata 'R8' value: (aSIR[8]).R color: #blue ;\t\t\t\t\t\tdata 'R9' value: (aSIR[9]).R color: #blue ;\t\t\t\t\t\t}\t\t}\t\t\t\tdisplay display_charts_radar {\t\t\tchart \"SIR_agent\" type: radar background: #white axes:#white {\t\t\t\tdata 'S0' value: (aSIR[0]).S[] color: #green ;\t\t\t\t\t\t\tdata 'I0' value: (aSIR[0]).I[] color: #red ;\t\t\t\t\tdata 'R0' value: (aSIR[0]).R[] color: #blue ;\t\t\t\t\t}\t\t}\t\t\t\t\t\t\t\tdisplay display_chartsH {\t\t\tchart \"SIR_agent\" type: heatmap background: #white\t\t\treverse_axes: true\t\t\t {\t\t\t\tdata 'S0' value: S_3d color: #green ;\t\t\t\t\tdata 'I0' value: I_3d color: #red ;\t\t\t\t\tdata 'R0' value: R_3d color: #blue ;\t\t\t\t}\t\t}\t}}",
        "url":"/wiki/Ordinary-Differential-Equations-SIR-(Simple-with-charts).html"
      }
      ,
    
      "wiki-ordinary-differential-equations-sir-split-in-agents-multiple-strains-html": {
        "title": "SIR (Split in Agents, Multiple Strains)",
        "content": "SIR (Split in Agents, Multiple Strains)Author : tri and nghiThis model is an extension of the model SIR_split_in_agents.gaml. It creates several agents of one compartment type (here typically several I_agt). == $0 == $0Code of the model :model SIR_split_in_agents_multiple_strainsglobal {\t// Parameters\tint number_S &lt;- 495 ; // The number of susceptible\tint number_I &lt;- 5 ; // The number of infected\tint number_R &lt;- 0 ; // The number of removed \tfloat _beta &lt;- 1.0 ; // The parameter Beta\tfloat _delta &lt;- 0.01 ; // The parameter Delta\t\t// Global variables\tint strain_number &lt;- 2;\tint N &lt;- number_S + number_I * strain_number + number_R;\t\tfloat hKR4 &lt;- 0.01;\t\tinit {\t\tcreate S_agt {\t\t\tSsize &lt;- float(number_S);\t\t}\t\tcreate I_agt number: strain_number {\t\t\tIsize &lt;- float(number_I);\t\t\tself.beta &lt;- _beta; \t\t\tself.delta &lt;- _delta; \t\t}\t\tcreate R_agt {\t\t\tRsize &lt;- float(number_R);\t\t}\t\tcreate my_SIR_maths {\t\t\tself.Sm &lt;- float(number_S);\t\t\tself.Im &lt;- float(number_I) * strain_number;\t\t\tself.Rm &lt;- float(number_R);\t\t}\t\twrite 'Basic Reproduction Number (R0): ' + string(_beta * number_S / (_delta));\t}}species S_agt {\tfloat t;\t\t\tfloat Ssize;\t\tequation evol simultaneously: [I_agt, R_agt] {\t\tdiff(self.Ssize, t) = (- sum(I_agt accumulate [each.beta * each.Isize]) * self.Ssize / N);\t}\treflex solving {solve evol method: \"rk4\" step: hKR4 ;}}species I_agt {\tfloat t;\t\t\tfloat Isize;\t \tfloat beta;\tfloat delta;\t\tequation evol simultaneously: [S_agt, R_agt] {\t\tdiff(self.Isize, t) = (beta * first(S_agt).Ssize * self.Isize / N) - (delta * self.Isize);\t}}species R_agt {\tfloat t;\t\t\tfloat Rsize;\tequation evol simultaneously: [I_agt] {\t\tdiff(self.Rsize, t) = (sum(I_agt collect (each.delta * each.Isize)));\t}}species my_SIR_maths {\tfloat t;\tfloat Im;\tfloat Sm;\tfloat Rm;\t\tequation SIR {\t\tdiff(self.Sm, t) = (-_beta * Sm * Im / N);\t\tdiff(self.Im, t) = (_beta * Sm * Im / N) - (_delta * Im);\t\tdiff(self.Rm, t) = (_delta * Im);\t}\treflex solving {solve SIR method: \"rk4\" step: hKR4;}}experiment Simulation type: gui {\tparameter 'Number of Susceptible' type: int var: number_S &lt;- 495 category: \"Initial population\"; \tparameter 'Number of Infected'    type: int var: number_I &lt;- 5   category: \"Initial population\";\tparameter 'Number of Removed'     type: int var: number_R &lt;- 0   category: \"Initial population\";\tparameter 'Beta (S-&gt;I)'  type: float var: _beta &lt;- 1.0   category: \"Parameters\";\tparameter 'Delta (I-&gt;R)' type: float var: _delta &lt;- 0.01 category: \"Parameters\";\t\t\toutput {\t\tdisplay chart_3system_eq {\t\t\tchart 'Split system' type: series background: #lightgray {\t\t\t\tdata 'susceptible' value: first(S_agt).Ssize color: #green;\t\t\t\tdata 'infected0' value: first(I_agt).beta * first(I_agt).Isize color: #white;\t\t\t\tdata 'infected1' value: last(I_agt).beta * last(I_agt).Isize color: #yellow;\t\t\t\tdata 'i1+i2' value: sum(I_agt accumulate (each.beta * each. Isize)) color: rgb ( 'red' ) ;\t\t\t\t\t\t\t\tdata 'recovered' value: first(R_agt).Rsize color: #blue;\t\t\t}\t\t}\t\tdisplay chart_1system_eq  {\t\t\tchart 'unified system' type: series background: #lightgray {\t\t\t\tdata 'susceptible_maths' value: first(my_SIR_maths).Sm color: #green;\t\t\t\tdata 'infected_maths' value: first(my_SIR_maths).Im color: #red;\t\t\t\tdata 'recovered_maths' value: first(my_SIR_maths).Rm color: #blue;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Ordinary-Differential-Equations-SIR-(Split-in-Agents,-Multiple-Strains).html"
      }
      ,
    
      "wiki-ordinary-differential-equations-html": {
        "title": "Ordinary Differential Equations",
        "content": "Ordinary Differential EquationsThis sub-section is composed of the following models :  Predefined equestions == $0 == $0 == $0 == $0 == $0 == $0 == $0  SIR (Influence of Integration Step).gaml == $0 == $0 == $0  SIR (Simple) == $0 == $0 == $0  SIR (Simple) == $0  SIR (Split in Agents, Multiple Strains) == $0 == $0",
        "url":"/wiki/Ordinary-Differential-Equations.html"
      }
      ,
    
      "wiki-otherbuiltinspecies-html": {
        "title": "Other Built-in Species (Under Construction)",
        "content": "Other Built-in Species (Under Construction)TODO",
        "url":"/wiki/OtherBuiltInSpecies.html"
      }
      ,
    
      "wiki-overlay-overlay-html": {
        "title": "Overlay",
        "content": "OverlayAuthor : Alexis Drogoul and Patrick TaillandierModel to show how to use overlay layers in a displayCode of the model :model Overlayglobal{\t//define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\tmap&lt;string,rgb&gt; color_per_type &lt;- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];}//define a simple grid with 10 rows and 10 columnsgrid cell width: 10 height: 10 {\t//each cell has a random type\tstring type &lt;- one_of(color_per_type.keys);\trgb color &lt;- color_per_type[type];}experiment overlay type: gui{    output     {        display map         {        \t//define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.            overlay \"Overlay\" position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true            {            \t//for each possible type, we draw a square with the corresponding color and we write the name of the type                float y &lt;- 30#px;                loop type over: color_per_type.keys                {                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"SansSerif\", 18, #bold);                    y &lt;- y + 25#px;                }            }            //then we display the grid\t\t\tgrid cell lines: #black;        }    }}",
        "url":"/wiki/Overlay-Overlay.html"
      }
      ,
    
      "wiki-overlay-html": {
        "title": "Overlay",
        "content": "OverlayThis sub-section is composed of the following models :  Overlay",
        "url":"/wiki/Overlay.html"
      }
      ,
    
      "wiki-overview-html": {
        "title": "Introduction",
        "content": "Introduction| &lt;img src=’http://img.youtube.com/vi/6m_-UY8UBuk/0.jpg’ width=’425’ height=344 /&gt; | &lt;img src=’http://img.youtube.com/vi/ycbeYxV2B7M/0.jpg’ width=’425’ height=344 /&gt; ||—|—|GAMA is a simulation platform, which aims at providing field experts, modellers, and computer scientists with a complete modelling and simulation development environment for building spatially explicit multi-agent simulations. It has been first developed by the Vietnamese-French research team MSI (located at IFI, Hanoi, and part of the IRD/UPMC International Research Unit UMMISCO) from 2007 to 2010, and is now developed by a consortium of academic and industrial partners led by UMMISCO, among which the University of Rouen, France, the University of Toulouse 1, France, the University of Orsay, France, the University of Can Tho, Vietnam, the National University of Hanoi, EDF R&amp;D, France, and CEA LISC, France.Some of the features of GAMA are illustrated in the videos above (more can be found in our Youtube channel).Beyond these features, GAMA also offers:  A complete modeling language, GAML, for modeling agents and environments  A large and extensible library of primitives (agent’s movement, communication, mathematical functions, graphical features, …)  A cross-platform reproducibility of experiments and simulations  A powerful declarative drawing and plotting subsystem  A flexible user interface based on the Eclipse platform  A complete set of batch tools, allowing for a systematic or “intelligent” exploration of models parameters spacesDocumentationThe documentation of GAMA is available online on the wiki of the project. It is organized around a few central activities (installing GAMA, writing models, running experiments, developing new extensions to the platform) and provides complete references on both the GAML language, the platform itself, and the scientific aspects of our work (with a complete bibliography). Several tutorials are also provided in the documentation in order to minimize the learning curve, allowing users to build, step by step, the models corresponding to these tutorials, which are of course shipped with the platform.The documentation can be accessed from the side bar of this page. A good starting point for new users is the installation page.A standalone version of the documentation, in PDF format, can be directly downloaded from hereSource CodeGAMA can be downloaded as a regular application or built from source, which is necessary if you want to contribute to the platform.The source code is available from this GITHub repository:https://github.com/gama-platform/gamaWhich you can also browse from the web here.It is, in any case, recommended to follow the instructions on this page in order to build GAMA from source.Copyright InformationThis is a free software (distributed under the GNU GPL v3 license), so you can have access to the code, edit it and redistribute it under the same terms. Independently of the licensing issues, if you plan on reusing part of our code, we would be glad to know it !DevelopersGAMA is being designed, developed and maintained by an active group of researchers coming from different institutions in France and Vietnam. Please find below a short introduction to each of them and a summary of their contributions to the platform:  Alexis Drogoul, Senior Researcher at the IRD, member of the UMMISCO International Research Unit. Mostly working on agent-based modeling and simulation. Has contributed and still contributes to the original design of the platform, including the GAML language (from the meta-model to the editor) and simulation facilities like Java2D displays.  Patrick Taillandier, Associate Professor at the University of Rouen, member of the IDEES CNRS Mixed Research Unit. Contributes since 2008 to the spatial and graph features (GIS integration, spatial operators) and to parameter space search algorithms. Currently working on new features related to graphical modeling and traffic simulation.  Benoit Gaudou, Associate Professor at the University Toulouse 1 Capitole, member of the IRIT CNRS Mixed Research Unit. Contributes since 2010 to documentation and unit test generation and coupling mathematical (ODE and PDE) and agent paradigms.  Arnaud Grignard, software engineer and PhD fellow (PDI-MSC) at UPMC. Contributes since 2011 to the development of new features related to visualization (3D Display), online analysis and interaction.  Huynh Quang Nghi, software engineering lecturer at CTU and PhD fellow (PDI-MSC) at UPMC. Contributes since 2012 to the development of new features related to GAML parser, coupling formalisms in EBM-ABM and ABM-ABM.  Truong Minh Thai, software engineering lecturer at CTU and PhD fellow (PRJ322-MOET) at IRIT-UT1. Contributes since 2012 to the development of new features related to data management and analysis.  Nicolas Marilleau, Researcher at the IRD, member of the UMMISCO International Research Unit and associate researcher at DISC team of FEMTO-ST institute. Contributes since 2010 to the development of headless mode and the high performance computing module.  Philippe Caillou, Associate professor at the University Paris Sud 11, member of the LRI and INRIA project-team TAO. Contributes since 2012 and actually working on charts, simulation analysis and BDI agents.  Vo Duc An, Post-doctoral Researcher, working on synthetic population generation in agent-based modelling, at the UMMISCO International Research Unit of the IRD. Has contributed to bringing the platform to the Eclipse RCP environment and to the development of several features (e.g., the FIPA-compliant agent communication capability, the multi-level architecture).  Truong Xuan Viet, software engineering lecturer at CTU and PhD fellow (PDI-MSC) at UPMC. Contributes since 2011 to the development of new features related to R caller, online GIS (OPENGIS: Web Map Service - WMS, Web Feature Services - WMS, Google map, etc).          Samuel Thiriot      Citing GAMAIf you use GAMA in your research and want to cite it (in a paper, presentation, whatever), please use this reference:  A. Grignard, P. Taillandier, B. Gaudou, D-A. Vo, N-Q. Huynh, A. Drogoul (2013), GAMA 1.6: Advancing the Art of Complex Agent-Based Modeling and Simulation. In ‘PRIMA 2013: Principles and Practice of Multi-Agent Systems’, Lecture Notes in Computer Science, Vol. 8291, Springer, pp. 117-131.or you can choose to cite the website instead:  GAMA Platform website, http://gama-platform.orgA complete list of references (papers and PhD theses on or using GAMA) is available on the references page.Contact UsThe best way to get in touch with the developers of GAMA is to sign in for the gama-platform@googlegroups.com mailing list. If you wish to contribute to the platform, you might want, instead or in addition, to sign in for the gama-dev@googlegroups.com mailing list. On both lists, we generally answer quite quickly to requests.Finally, if you think you have found a bug in GAMA, or if you absolutely need a feature that does not exist yet, it is much more efficient and time-saving for everyone (including current and future users) to create a new issue report. Please refer to these instructions to do so.",
        "url":"/wiki/Overview.html"
      }
      ,
    
      "wiki-parametersview-html": {
        "title": "Parameters View",
        "content": "Parameters ViewIn the case of an experiment, the modeler can define the parameters he wants to be able to modify to explore the simulation, and thus the ones he wants to be able to display and alter in the GUI interface.It important to notice that all modification made in the parameters are used for simulation reload only. Creation of a new simulation from the model will erase the modifications.Table of contents  Parameters View          Built-in parameters      Parameters View      Modification of parameters values      Built-in parametersEvery GUI experiment displays a pane named “Parameters” containing at least two built-in parameters related to the random generator:  the Random Number Generator, with a choice between 3 RNG implementations,  the Random SeedParameters ViewThe modeler can define himself parameters that can be displayed in the GUI and that are sorted by categories. Note that the interface will depend on the data type of the parameter: for example, for integer or float parameters, a simple text box will be displayed whereas a color selector will be available for color parameters. The parameters value displayed are the initial value provided to the variables associated to the parameters in the model.The above parameters view is generated from the following code:global{\tint i;\tfloat f;\tstring s;\tlist l;\tmatrix m;\tpair p;\trgb c;}experiment maths type: gui {    parameter \"my_integer\" var: i &lt;- 0 category:\"Simple types\";    parameter \"my_float\" var: f &lt;- 0.0 category:\"Simple types\";    parameter \"my_string\" var: s &lt;- \"\" category:\"Simple types\";    parameter \"my_list\" var: l &lt;- [] category:\"Complex types\";    parameter \"my_matrix\" var: m &lt;- matrix([[1,2],[3,4]]) category:\"Complex types\";    parameter \"my_pair\" var: p &lt;- 3::5 category:\"Complex types\";    parameter \"my_color\" var: c &lt;- #green category:\"Complex types\";    output {}}Click on Edit button in case of list or map parameters or the color or matrix will open an additional window to modify the parameter value.Modification of parameters valuesThe modeler can modify the parameter values. After modifying the parameter values, you can reload the simulation by clicking on the top-right circular arrow button.You can also add a new simulation to the old one, using those new parameters, by clicking on the top-right plus symbol button.If he wants to come back to the initial value of parameters, he can click on the top-right red curved arrow of the parameters view.",
        "url":"/wiki/ParametersView.html"
      }
      ,
    
      "wiki-pedagogicalmaterials-html": {
        "title": "Initiation to algorithms with Scratch",
        "content": "Initiation to algorithms with ScratchA set of exercices for your first step to algorithms using the graphical tool Scratch: PDF.Memo GAMLA summary of the organization of a GAML model, its main parts and the main keywords, statements: PDF.Exercice (*): Firefly synchronizationFrom UML diagram, implement a GAMA model.  Keywords: grid, displays, plot, synchronization.  Subject: PDF, Keynote, PPTX  UML diagrams: asta version  A model: gaml fileExercice (*): Firefighter modelImplement the model given in the model description file. The guide file helps you to separate the implementation of the structure of the model, its initialization, its dynamics and ways to visualize it.  Keywords: grid, inheritance, displays, plot, 3D.  Model description: PDF  Guide: PDF, Keynote, PPTX  UML diagrams: asta version  A model: gaml fileExercice (**): Wolves, Goats, Cabbages modelImplement the model given in the model description file. The detailed subject divides the model in 3 steps and contains helps and advices to implement the model.  Keywords: grid, inheritance, displays, plot, prey-predator model.  Model description: PDF  Detailed subject: PDF, Word  Guide: PDF, PPTX  A model: gaml fileExercice (**): Schelling model  Keywords: grid, GIS data, displays, plot, Graphical modeling, Schelling model.  Subject: PDF, Keynote, PPTX  A model: gaml fileExercice (**): Traffic model  Keywords: GIS data, graph, skills, moving skill, displays, plot, mobillity model.  Subject: PDF, Keynote, PPTX  A model: gaml fileExercice (***): Shortest path on grid by distance diffusion  Keywords: grid, move, displays, diffusion model, algorithm.  Subject: PDF, Word  A model: gaml file",
        "url":"/wiki/PedagogicalMaterials.html"
      }
      ,
    
      "wiki-physics-engine-hello-world-html": {
        "title": "Falling Balls",
        "content": "Falling BallsAuthor : Arnaud GrignardThis is a model that shows how the physics engine work by displaying two species (a floor and balls). Ball agents use the skill physical3D. The ball agents fall on a floor and fall from the floor to the void.Code of the model :model FallingHelloWorldglobal {\tint environment_size &lt;- 500;  \t \tint number_of_ball parameter: 'Number of ball' min:1 &lt;- 100  category: 'Model'; \tint ball_radius parameter: 'Ball radius' min:1 &lt;- 25  category: 'Model'; \t\tfile imageRaster &lt;- file('./../images/wood-floor.jpg') ;\tgeometry shape &lt;- square(environment_size);\t\t\t//Physic World used to simulate gravity and compute forces\tphysic_world world2;\t\t\tinit {\t\tcreate ball number: number_of_ball{\t\t\tlocation &lt;-  {rnd(environment_size),rnd(environment_size),rnd(environment_size)};            radius &lt;-float(rnd(ball_radius)+1);            //Bounds to compute the collision for the ball agents\t\t\tcollisionBound &lt;-  [\"shape\"::\"sphere\",\"radius\"::radius];\t\t\tmass &lt;-1.0;\t\t}\t\t\t\tcreate ground {\t\t\tlocation &lt;- {environment_size/2,environment_size/2,0};            //Bounds to compute the collision for the floor agent\t\t\tcollisionBound &lt;-  [\"shape\"::\"floor\",\"x\"::environment_size/2, \"y\":: environment_size/2, \"z\"::0];\t\t\tmass &lt;-0.0;\t\t}\t\tcreate physic_world{\t\t  world2 &lt;- self;\t\t  //Add to the agents that will be used to compute the forces.\t\t  ask world2 {agents &lt;-  (ball as list) + (ground as list);}\t\t  //Boolean to set gravity \t\t\t  world2.gravity &lt;- true;\t\t}\t}\t\t//Reflex to compute the forces at each step\treflex computeForces  {\t  ask world2 {do compute_forces step: 1;}\t} \t\t\t} species physic_world parent: physical_world ;species ground skills: [physics]{    \t\taspect image{\t\tdraw imageRaster size: environment_size;\t}} species ball skills: [physics] {  \trgb color &lt;- rgb (217,229,143); \tfloat radius;\taspect sphere{\t\tdraw sphere(radius) color: color ;\t}\t}experiment Falling_Hello_world type: gui {\tinit{\t\tminimum_cycle_duration &lt;-0.001;\t}\t\toutput {\t\t\t\tdisplay Rain  type: opengl background:rgb(0,58,64) draw_env:false{\t\t\tspecies ground aspect:image;\t\t    species ball aspect:sphere;\t\t\t\t\t}\t}}",
        "url":"/wiki/Physics-Engine-Hello-World.html"
      }
      ,
    
      "wiki-physics-engine-perfect-gas-html": {
        "title": "Balls without gravity",
        "content": "Balls without gravityAuthor : Arnaud GrignardThis is a model that shows how the physics engine work without gravity. Balls can collide each other and can’t go further than the wall and the ground agents.Code of the model :model Perfect_Gas  global {\t//Bounds of the environment\tint width_of_environment parameter: 'Dimensions' init:200 ; \tint height_of_environment parameter: 'Dimensions' init:200  ; \t\t//Range, Speed ans Size of the agents\tint range_of_agents parameter: 'Range of Agents' min: 1 &lt;- 25 ;\tfloat speed_of_agents parameter: 'Speed of Agents' min: 0.1  &lt;- 2.0 ; \tint size_of_agents &lt;- 10;\t\t\tfloat size_of_the_wall &lt;- 10.0;\tint offset&lt;-10;\tgeometry shape &lt;- rectangle(width_of_environment, height_of_environment);\t//Physic engines that will compute the forces\tphysic_world world2;\tinit {\t\tcreate ball number: 1000{\t\t\tradius &lt;-2;\t\t\tlocation &lt;-  {offset+ rnd(width_of_environment-offset*2), offset+ rnd(height_of_environment- offset*2),offset+ rnd(width_of_environment-offset*2)};\t\t\tmass &lt;-0.001;\t\t\tcollisionBound &lt;-  [\"shape\"::\"sphere\",\"radius\"::radius];\t\t}\t\t\t\tcreate ground \t\t{   \t\t\tlocation &lt;- {width_of_environment/2,height_of_environment/2,0};\t\t\tcollisionBound &lt;-  [\"shape\"::\"floor\",\"x\"::width_of_environment/2 , \"y\":: height_of_environment/2, \"z\"::size_of_the_wall];\t\t\tshape &lt;- rectangle(width_of_environment,height_of_environment);\t\t\tmass &lt;-0.0;\t\t}\t\t\t\t//Sky\t\tcreate ground{\t\t\tlocation &lt;- {width_of_environment/2,height_of_environment/2,width_of_environment};\t\t\tcollisionBound &lt;-  [\"shape\"::\"floor\",\"x\"::width_of_environment/2 , \"y\":: height_of_environment/2, \"z\"::size_of_the_wall];\t\t\tshape &lt;- rectangle(width_of_environment,height_of_environment);\t\t\tmass &lt;-0.0;\t\t}\t\t//down wall\t\tcreate wall{\t\t\tlocation &lt;- {width_of_environment/2,height_of_environment,0};\t\t\theight &lt;- float(width_of_environment);\t\t\tshape &lt;- rectangle(width_of_environment,2);\t\t\tcollisionBound &lt;-  [\"shape\"::\"floor\",\"x\"::width_of_environment/2, \"y\":: size_of_the_wall, \"z\"::height];\t\t\tmass &lt;-0.0;\t\t}\t\t//upper wall\t\tcreate wall{\t\t\tlocation &lt;- {width_of_environment/2,0,0};\t\t\theight &lt;- float(width_of_environment);\t\t\tshape &lt;- rectangle(width_of_environment,2);\t\t\tcollisionBound &lt;-  [\"shape\"::\"floor\",\"x\"::width_of_environment/2, \"y\":: size_of_the_wall, \"z\"::height];\t\t\tmass &lt;-0.0;\t\t}\t\t//left wall\t\tcreate wall{\t\t\tlocation &lt;- {0.0,height_of_environment/2,0.0};\t\t\theight &lt;- float(width_of_environment);\t\t\tshape &lt;- rectangle(2,height_of_environment);\t\t\tcollisionBound &lt;-  [\"shape\"::\"floor\",\"x\"::size_of_the_wall, \"y\":: height_of_environment/2, \"z\"::height];\t\t\tmass &lt;-0.0;\t\t\t\t\t}\t\t//right wall\t\tcreate wall{\t\t\tlocation &lt;- {width_of_environment,height_of_environment/2,0};\t\t\theight &lt;- float(width_of_environment);\t\t\tshape &lt;- rectangle(2,height_of_environment);\t\t\tcollisionBound &lt;-  [\"shape\"::\"floor\",\"x\"::size_of_the_wall, \"y\":: height_of_environment/2, \"z\"::height];\t\t\tmass &lt;-0.0;\t\t\t\t\t}\t\t\t\t//Create the physic engine without gravity computed\t\tcreate physic_world {\t\t\tgravity &lt;- false;\t\t\tworld2 &lt;- self;\t\t}\t\t\t\t//Add the agents to compute their forces\t\task world2 {agents &lt;-  (ball as list) + (ground as list) + (wall as list);}\t\t\t}\t\t//Reflex to compute the forces at each step\treflex computeForces  {\t\task world2 {do compute_forces step: 1;}\t} \t\t\t} //Species to represent the physic engine, derivated from the Physical3DWorld built-in speciesspecies physic_world parent: physical_world ; //Species to represent the ground using the physical3D skillspecies ground skills: [physics]{\taspect default {\t\tdraw shape color: #black empty:true;\t}}//Species to represent the wall using the physical3D skillspecies wall skills: [physics]{\trgb color;\tfloat height;    aspect default {\t\tdraw shape color: #black depth:height empty:true;\t}} \t//Species to represent the ball using the physical3D skillspecies ball skills: [physics] {  \trgb color;\tint radius;\tint size  &lt;- size_of_agents;\tint range  &lt;- range_of_agents; \tfloat speed  &lt;- speed_of_agents;  \tint heading &lt;- rnd(359);\taspect sphere{\t\tdraw sphere(radius) color: rgb(135,201,255) ;\t}\t}experiment perfect_gas type: gui {\tinit{\t\tminimum_cycle_duration &lt;-0.001;\t}\toutput {\t\tdisplay Cube type:opengl background:rgb(20,79,127) draw_env:false{\t\t\tspecies ground transparency:0.5;\t\t\tspecies wall transparency:0.5;\t    \tspecies ball aspect:sphere;\t\t\t\t\t}\t}}",
        "url":"/wiki/Physics-Engine-Perfect-Gas.html"
      }
      ,
    
      "wiki-physics-engine-pool-html": {
        "title": "Pool using Physic Engine",
        "content": "Pool using Physic EngineAuthor : Arnaud GrignardThis is a model that shows how the physics engine works using a pool with balls, collided by a white ball. The balls use the skill Physical3D.Code of the model :model pool3Dglobal {\t//Parameters for the environment\tint width_of_environment &lt;- 200;\tint height_of_environment &lt;- 300;\t\t//Parameters for the balls\tfloat speed_of_agents &lt;- 2.0;\tint size_of_agents &lt;- 10;\t\trgb colorwood &lt;- rgb([178, 112, 62]);\t\t//Physical Engine\tphysic_world world2;\tgeometry shape &lt;- rectangle(width_of_environment, height_of_environment);\tinit {\t\t\t\t//Creation of the white ball\t\tcreate ball {\t\t\tlocation &lt;- { width_of_environment / 2, 4 * height_of_environment / 5, 5.0 };\t\t\tmass &lt;- 3.0;\t\t\t//a random velocity between 500 and 1000\t\t\tvelocity &lt;- [0.0, -float(500 + rnd(500)), 0.0];\t\t\tcollisionBound &lt;- [\"shape\"::\"sphere\", \"radius\"::5];\t\t}\t\tint i &lt;- 0;\t\tint deltaI &lt;- 0;\t\tint initX &lt;- 75;\t\tint initY &lt;- int(height_of_environment / 8);\t\t\t\t//Create the other balls for the pool\t\tcreate ball number: 15 {\t\t\tlocation &lt;- { initX + (i - deltaI) * 10, initY, 5.0 };\t\t\theading &lt;- 90;\t\t\tspeed &lt;- 0.0;\t\t\tmass &lt;- 3.0;\t\t\tcollisionBound &lt;- [\"shape\"::\"sphere\", \"radius\"::5];\t\t\ti &lt;- i + 1;\t\t\t\t\t\tif ((i mod 2) = 0) {\t\t\t\t\tcolor &lt;- #red;\t\t\t} else {\t\t\t\tcolor &lt;- #yellow;\t\t\t}\t\t\tif (i = 5) {\t\t\t\tinitX &lt;- initX + 5;\t\t\t\tinitY &lt;- initY + 9;\t\t\t\tdeltaI &lt;- 5;\t\t\t}\t\t\tif (i = 9) {\t\t\t\tinitX &lt;- initX + 5;\t\t\t\tinitY &lt;- initY + 9;\t\t\t\tdeltaI &lt;- 9;\t\t\t}\t\t\tif (i = 12) {\t\t\t\tinitX &lt;- initX + 5;\t\t\t\tinitY &lt;- initY + 9;\t\t\t\tdeltaI &lt;- 12;\t\t\t}\t\t\tif (i = 14) {\t\t\t\tinitX &lt;- initX + 5;\t\t\t\tinitY &lt;- initY + 9;\t\t\t\tdeltaI &lt;- 14;\t\t\t}\t\t}\t\tcreate ground {\t\t\tlocation &lt;- { width_of_environment / 2, height_of_environment / 2, 0 };\t\t\tshape &lt;- rectangle({ width_of_environment - 24, height_of_environment - 24 });\t\t\tcollisionBound &lt;- [\"shape\"::\"floor\", \"x\"::width_of_environment / 2 - 12, \"y\"::height_of_environment / 2 - 12, \"z\"::0];\t\t\tmass &lt;- 0.0;\t\t}\t\tcreate ground {\t\t\tlocation &lt;- { width_of_environment / 2, 6, 0 };\t\t\tshape &lt;- rectangle({ width_of_environment - 24, 12 });\t\t\tcollisionBound &lt;- [\"shape\"::\"floor\", \"x\"::width_of_environment / 2 - 12, \"y\"::6, \"z\"::0];\t\t\tmass &lt;- 0.0;\t\t}\t\tcreate ground {\t\t\tlocation &lt;- { width_of_environment / 2, height_of_environment - 6, 0 };\t\t\tshape &lt;- rectangle({ width_of_environment - 24, 12 });\t\t\tcollisionBound &lt;- [\"shape\"::\"floor\", \"x\"::width_of_environment / 2 - 12, \"y\"::6, \"z\"::0];\t\t\tmass &lt;- 0.0;\t\t}\t\tcreate ground {\t\t\tlocation &lt;- { 6, height_of_environment / 4 + 3, 0 };\t\t\tshape &lt;- rectangle({ 12, height_of_environment / 2 - 18 });\t\t\tcollisionBound &lt;- [\"shape\"::\"floor\", \"x\"::6, \"y\"::height_of_environment / 4 - 9, \"z\"::0];\t\t\tmass &lt;- 0.0;\t\t}\t\tcreate ground {\t\t\tlocation &lt;- { 6, 3 * height_of_environment / 4 - 3, 0 };\t\t\tshape &lt;- rectangle({ 12, height_of_environment / 2 - 18 });\t\t\tcollisionBound &lt;- [\"shape\"::\"floor\", \"x\"::6, \"y\"::height_of_environment / 4 - 9, \"z\"::0];\t\t\tmass &lt;- 0.0;\t\t}\t\tcreate ground {\t\t\tlocation &lt;- { width_of_environment - 6, height_of_environment / 4 + 3, 0 };\t\t\tshape &lt;- rectangle({ 12, height_of_environment / 2 - 18 });\t\t\tcollisionBound &lt;- [\"shape\"::\"floor\", \"x\"::6, \"y\"::height_of_environment / 4 - 9, \"z\"::0];\t\t\tmass &lt;- 0.0;\t\t}\t\tcreate ground {\t\t\tlocation &lt;- { width_of_environment - 6, 3 * height_of_environment / 4 - 3, 0 };\t\t\tshape &lt;- rectangle({ 12, height_of_environment / 2 - 18 });\t\t\tcollisionBound &lt;- [\"shape\"::\"floor\", \"x\"::6, \"y\"::height_of_environment / 4 - 9, \"z\"::0];\t\t\tmass &lt;- 0.0;\t\t}\t\t//down wall\t\tcreate wall {\t\t\tlocation &lt;- { width_of_environment / 2, height_of_environment, 0 };\t\t\tshape &lt;- rectangle({ width_of_environment, 2 });\t\t\tcollisionBound &lt;- [\"shape\"::\"floor\", \"x\"::width_of_environment / 2, \"y\"::1, \"z\"::10];\t\t\tmass &lt;- 0.0;\t\t\tcolor &lt;- colorwood;\t\t}\t\t//upper wall\t\tcreate wall {\t\t\tlocation &lt;- { width_of_environment / 2, 0, 0 };\t\t\tshape &lt;- rectangle({ width_of_environment, 2 });\t\t\tcollisionBound &lt;- [\"shape\"::\"floor\", \"x\"::width_of_environment / 2, \"y\"::1, \"z\"::10];\t\t\tmass &lt;- 0.0;\t\t\tcolor &lt;- colorwood;\t\t}\t\t//left wall\t\tcreate wall {\t\t\tlocation &lt;- { 0, height_of_environment / 2, 0 };\t\t\tshape &lt;- rectangle({ 2, height_of_environment });\t\t\tcollisionBound &lt;- [\"shape\"::\"floor\", \"x\"::1, \"y\"::height_of_environment / 2, \"z\"::10];\t\t\tmass &lt;- 0.0;\t\t\tcolor &lt;- colorwood;\t\t}\t\t//right wall\t\tcreate wall {\t\t\tlocation &lt;- { width_of_environment, height_of_environment / 2, 0 };\t\t\tshape &lt;- rectangle({ 2, height_of_environment });\t\t\tcollisionBound &lt;- [\"shape\"::\"floor\", \"x\"::1, \"y\"::height_of_environment / 2, \"z\"::10];\t\t\tmass &lt;- 0.0;\t\t\tcolor &lt;- colorwood;\t\t}\t\t\t\t//Create the physic engine with gravity\t\tcreate physic_world {\t\t\tgravity &lt;- true;\t\t\tworld2 &lt;- self;\t\t}\t\t//Add the agents inside the registered agents in the physic engine\t\task world2 {\t\t\tagents &lt;- (ball as list) + (ground as list) + (wall as list);\t\t}\t}\t//Reflex to compute the forces at each step\treflex computeForces {\t\task world2 {\t\t\tdo compute_forces step: 1;\t\t}\t}}//Species corresponding to the physics engine, derivated from the built-in species Physical3DWorldspecies physic_world parent: physical_world ;//Species representing the ground agents used for the computation of the forces, using the skill physical3Dspecies ground skills: [physics] {\taspect default {\t\tdraw shape color: rgb([10, 114, 63]) border: rgb([10, 114, 63]);\t}}//Species representing the wall agents of the pool using the skill physical3Dspecies wall skills: [physics] {\trgb color;\taspect default {\t\tdraw shape color: color depth: 10;\t}}//Species representing the ball agents of the pool using the skill physical3Dspecies ball skills: [physics] {\trgb color&lt;-#white;\tint size &lt;- size_of_agents;\tfloat speed &lt;- speed_of_agents;\tint heading &lt;- rnd(359);\taspect sphere {\t\tdraw sphere(5) color:color;\t}}experiment pool type: gui {\toutput {\t\tdisplay Circle type: opengl tesselation: true background: #white draw_env: false { species ground aspect: default;\t\tspecies wall aspect: default;\t\tspecies ball aspect: sphere;\t\t}\t}}",
        "url":"/wiki/Physics-Engine-Pool.html"
      }
      ,
    
      "wiki-physics-engine-water-tank-html": {
        "title": "Water Tank",
        "content": "Water TankAuthor : Arnaud GrignardThis is a model that shows how the physics engine works using a tank, with a floor and 4 walls, and balls falling into it. The floor doesn’t have any mass,Code of the model :model Tankglobal {\t\t//Dimensions of the environment\tint width_of_environment parameter: 'Dimensions' init: 100;\tint height_of_environment parameter: 'Dimensions' init: 100;\t\t//Parameters for the ball species\tint nb_balls parameter: 'Number of Agents' min: 1 &lt;- 500;\tint size_of_agents parameter: 'Size of Agents' min: 1 &lt;- 1;\t\t\tint wall_height parameter: 'Wall height' min: 1 &lt;- 25;\tgeometry shape &lt;- rectangle(width_of_environment, height_of_environment);\t\t//Physics engine\tphysic_world world2;\t\t\tinit {\t\t\t\t//Creation of the ball agents\t\tcreate ball number: nb_balls {\t\t\tlocation &lt;- { rnd(width_of_environment - size_of_agents), rnd(height_of_environment - size_of_agents), rnd(height_of_environment - size_of_agents) };\t\t\tradius &lt;- float(size_of_agents);\t\t\t\t\t\t//Attributes to know the collision bounds of the agent\t\t\tcollisionBound &lt;- [\"shape\"::\"sphere\", \"radius\"::radius];\t\t}\t\t//Create the ground of the tank\t\tcreate ground {\t\t\tlocation &lt;- { width_of_environment / 2, height_of_environment / 2, 0 };\t\t\tcollisionBound &lt;- [\"shape\"::\"floor\", \"x\"::width_of_environment / 2, \"y\"::height_of_environment / 2, \"z\"::0];\t\t\tshape &lt;- rectangle({ width_of_environment, height_of_environment });\t\t\tmass &lt;- 0.0;\t\t}\t\t//down wall\t\tcreate wall {\t\t\tlocation &lt;- { width_of_environment / 2, height_of_environment, 0 };\t\t\tshape &lt;- rectangle({ width_of_environment, 2 });\t\t\tcollisionBound &lt;- [\"shape\"::\"floor\", \"x\"::width_of_environment / 2, \"y\"::1, \"z\"::wall_height];\t\t\tmass &lt;- 0.0;\t\t}\t\t//upper wall\t\tcreate wall {\t\t\tlocation &lt;- { width_of_environment / 2, 0, 0 };\t\t\tshape &lt;- rectangle({ width_of_environment, 2 });\t\t\tcollisionBound &lt;- [\"shape\"::\"floor\", \"x\"::width_of_environment / 2, \"y\"::1, \"z\"::wall_height];\t\t\tmass &lt;- 0.0;\t\t}\t\t//left wall\t\tcreate wall {\t\t\tlocation &lt;- { 0, height_of_environment / 2, 0 };\t\t\tshape &lt;- rectangle({ 2, height_of_environment });\t\t\tcollisionBound &lt;- [\"shape\"::\"floor\", \"x\"::1, \"y\"::height_of_environment / 2, \"z\"::wall_height];\t\t\tmass &lt;- 0.0;\t\t}\t\t//right wall\t\tcreate wall {\t\t\tlocation &lt;- { width_of_environment, height_of_environment / 2, 0 };\t\t\tshape &lt;- rectangle({ 2, height_of_environment });\t\t\tcollisionBound &lt;- [\"shape\"::\"floor\", \"x\"::1, \"y\"::height_of_environment / 2, \"z\"::wall_height];\t\t\tmass &lt;- 0.0;\t\t}\t\t//Initialisation of the physic engine\t\tcreate physic_world {\t\t\tworld2 &lt;- self;\t\t}\t\t\t\t//The physic engine agent gets all the other agents of the world to compute their forces\t\task world2 {\t\t\tagents &lt;- (ball as list) + (ground as list) + (wall as list);\t\t}\t\tworld2.gravity &lt;- true;\t}\t//Reflex to compute the forces at each step\treflex computeForces {\t\task world2 {\t\t\tdo compute_forces step: 1;\t\t}\t}}//Species that will represent the physic engine, derivated from builti-in species Physical3DWorldspecies physic_world parent: physical_world ;//Species that will represent the ground of the tank, using the skill physical 3Dspecies ground skills: [physics] {\taspect default {\t\tdraw shape color: rgb(60, 60, 60);\t}}//Species that will represent the walls of the tank, using the skill physical 3Dspecies wall skills: [physics] {\trgb color;\taspect default {\t\tdraw shape color: rgb(40, 40, 40) depth: wall_height;\t}}//Species that will represent the balls falling in the tank, using the skill physical 3Dspecies ball skills: [physics] {\tfloat radius;\taspect default {\t\tdraw sphere(radius) color: rgb(4, 158, 189);\t}}experiment tank type: gui {\tinit{\t\tminimum_cycle_duration &lt;-0.001;\t}\toutput {\t\tdisplay Circle type: opengl background: rgb(230, 230, 230) { \t\t\tspecies ground;\t\t\tspecies wall;\t\t\tspecies ball;\t\t}\t}}",
        "url":"/wiki/Physics-Engine-Water-Tank.html"
      }
      ,
    
      "wiki-physics-engine-html": {
        "title": "Physics Engine",
        "content": "Physics EngineThis sub-section is composed of the following models :      Falling Balls        Balls without gravity        Pool using Physic Engine        Water Tank  ",
        "url":"/wiki/Physics-Engine.html"
      }
      ,
    
      "wiki-platformdocumentation-html": {
        "title": "Platform",
        "content": "PlatformGAMA consists of a single application that is based on the RCP architecture provided by Eclipse. Within this single application software, often referred to as a platform, users can undertake, without the need of additional third-parties softwares, most of the activities related to modeling and simulation, namely editing models and simulating, visualizing and exploring them using dedicated tools.First-time users may however be intimidated by the apparent complexity of the platform, so this part of the documentation has been designed to ease their first contact with it, by clearly identifying tasks of interest to modelers and how they can be accomplished within GAMA.It is accomplished by firstly providing some background about important notions found throughout the platform, especially those of workspace and projects and explaining how to organize and navigate through models. Then we take a look at the edition of models and its various tools and components (dedicated editors and related tools, of course, but also validators). Finally, we show how to run experiments on these models and what support the user interface can provide to users in this task.",
        "url":"/wiki/PlatformDocumentation.html"
      }
      ,
    
      "wiki-plugindocumentation-html": {
        "title": "Extensions",
        "content": "ExtensionsIn this part, we will present you all the different plugins available for GAMA.IntroductionThis page provides a link to each of the extension pages. Extensions are the additional GAMA plugins that exist in the GAMA GitHub repository but will not be packaged with the release. These extensions are not maintained by GAMA core team but by their authors.  msi.gaml.extensions.humanmoving  ummisco.gaml.extensions.stats  ummisco.gama.gpu  ummisco.gama.communicator  ummisco.gaml.extensions.rjava  ummisco.gaml.extensions.sound  ummisco.miro.extension.traffic  cenres.gaml.extensions.hydro  irit.maelia.gaml.additions  ummisco.miro.extension  dream.gama.opengis  msi.gaml.extensions.cplex  idees.gama.weka  msi.gaml.extensions.traffic2d  simtools.graphanalysis.fr",
        "url":"/wiki/PluginDocumentation.html"
      }
      ,
    
      "wiki-predator-prey-lotka-volterra-influence-of-integration-step-html": {
        "title": "ODE_LotkaVolterra",
        "content": "ODE_LotkaVolterraAuthor : Huynh Quang Nghi &amp; Nathalie CorsonCode of the model :model ODE_LotkaVolterra_InfluenceTimeStepglobal {\tfloat prey_birth_rate ; \t\t// natural birth rate of preys\tfloat predation_rate ; \t\t\t// death rate of preys due to predators\tfloat predator_death_rate ; \t// natural death rate of predators\tfloat predation_efficiency ; \t// birth rate of predators due to prey consumption\t\tfloat nb_prey_init ; \t\t\t// initial number of preys\tfloat nb_predator_init  ; \t\t// initial number of predators\t\tfloat integration_step ; \t// integration time step of the Runge Kutta 4 method\tfloat t;   \t\t\t\t\t// simulation time : t = n * integration_time_step  where n is the number of already computed time step\t\t\tfloat integration_time_step1  &lt;- 1.0;  // first integration time step to compare \tfloat integration_time_step2  &lt;- 0.1;  // second integration time step to compare \tfloat integration_time_step3  &lt;- 0.01;  // third integration time step to compare \t\tlist&lt;LotkaVolterra_agent&gt; LV_agents;\t\tinit{\t\tcreate LotkaVolterra_agent number: 1 with:[integration_time_step::integration_time_step1]; \t// creation of an agent containing the ODE model with an integration time step of value integration_time_step1\t\tcreate LotkaVolterra_agent number: 1 with:[integration_time_step::integration_time_step2]; \t// creation of an agent containing the ODE model with an integration time step of value integration_time_step2\t\tcreate LotkaVolterra_agent number: 1 with:[integration_time_step::integration_time_step3]; \t// creation of an agent containing the ODE model with an integration time step of value integration_time_step3\t\tLV_agents &lt;- list(LotkaVolterra_agent);\t}}species LotkaVolterra_agent {\t    float nb_prey &lt;- nb_prey_init ; \t\t\t\t// number of preys initialized with the values given by the user\tfloat nb_predator &lt;- nb_predator_init ; \t\t// number of predators initialized with the values given by the user\t\tfloat integration_time_step ; \t\t\t\t\t// integration time step used in the Runge Kutta 4 method  \tequation lotka_volterra { \t\tdiff(nb_prey,t) =   nb_prey * (prey_birth_rate - predation_rate * nb_predator); \t\t\t\t\t// evolution of the number of preys duting an integration time step\t\tdiff(nb_predator,t) = - nb_predator * (predator_death_rate - predation_efficiency * nb_prey); \t\t// evolution of the number of predator during an integration time step      }      reflex solving {               \tsolve lotka_volterra method: \"rk4\" step:integration_time_step;// cycle_length:1/integration_time_step; \t\t\t// use of runge kutta 4 method with an integration time step of value integration_time_step       }}experiment maths type: gui {\t\t\tparameter \"Prey birth rate\" var: prey_birth_rate &lt;- 0.05 min: 0.0 max: 1.0 category: \"Prey\";\t\t\t\t\t\t// the user defines the value of parameter prey_birth_rate on the interface, the default value is 0.05 and this value must be between 0 and 1\tparameter \"Predation rate\" var: predation_rate &lt;- 0.001 min: 0.0 max: 1.0 category: \"Prey\"; \t\t\t\t\t\t// the user defines the value of parameter prey_birth_rate on the interface, the default value is 0.001 and this value must be between 0 and 1\tparameter \"Predator death rate\" var: predator_death_rate &lt;- 0.03 min: 0.0 max: 1.0 category: \"Predator\";\t \t\t// the user defines the value of parameter predator_death_rate on the interface, the default value is 0.03 and this value must be between 0 and 1\tparameter \"Predation efficiency\" var: predation_efficiency &lt;- 0.0002 min: 0.0 max: 1.0 category: \"Predator\";\t\t// the user defines the value of parameter predation_efficiency on the interface, the default value is 0.0002 and this value must be between 0 and 1\t\tparameter \"Initial number of prey\" var: nb_prey_init &lt;- 250.0 min: 1.0 category: \"Prey\"; \t\t\t\t\t\t\t// the user defines the value of parameter predation_efficiency on the interface, the default value is 250, the minimum possible value is 1\tparameter \"Initial number of predator\" var: nb_predator_init &lt;- 45.0 min: 1.0 category: \"Predator\"; \t\t\t\t// the user defines the value of parameter predation_efficiency on the interface, the default value is 45, the minimum possible value is 1\t\tparameter \"Integration time step of the first chart \" var:  integration_time_step1 &lt;- 1.0  min: 0.0 max:1.0 category: \"Integration time steps\"; \t// the user defines the value of the first integration step he wants to compare, the default value is 1 and this value must be between 0 and 1\tparameter \"Integration time step of the second chart \" var:  integration_time_step2 &lt;- 0.1  min: 0.0 max: 1.0 category: \"Integration time steps\"; \t// the user defines the value of the second integration step he wants to compare, the default value is 0.1 and this value must be between 0 and 1\tparameter \"Integration time step of the third chart \" var:  integration_time_step3 &lt;- 0.01  min: 0.0 max: 1.0 category: \"Integration time steps\"; \t// the user defines the value of the third integration step he wants to compare, the default value is 0.01 and this value must be between 0 and 1\t\t\toutput {\t\t \t\tdisplay TimeSeries  {\t// creation of a display to show time series of the model, values are plotted at every step. Since there is more than one chart plotted in one display, every chart has a position and a size\t\t\tchart \"Lotka Volterra Time Series - Integration time step = 1 \" type: series background: #white position: {0,0} size:{1,0.33} x_range: 1000 { \t\t// one chart, of type 'serie', is named Lotka Volterra Time Series - Integration time step = 1, it shows quantities according to time, and the background is white\t\t\t\tdata 'Number of preys' value: first(LotkaVolterra_agent where (each.integration_time_step = 1.0)).nb_prey color: #green ;\t\t\t// number of preys in the case where the integration time step is 1 is plotted in green\t\t\t\t\t\tdata 'Number of predators' value: first(LotkaVolterra_agent where (each.integration_time_step = 1.0)).nb_predator color: #red ; \t// number of predators in the case where the integration time step is 1 is plotted in red\t\t\t\t}\t\t\tchart \"Lotka Volterra Time Series - Integration time step = 0.1 \" type: series background: #white position: {0,0.33} size:{1,0.33} x_range: 1000{\t\t\t\tdata 'Number of preys' value: first(LotkaVolterra_agent where (each.integration_time_step = 0.1)).nb_prey color: #green ;\t\t\t\t\t\t\t\tdata 'Number of predators' value: first(LotkaVolterra_agent where (each.integration_time_step = 0.1)).nb_predator color: #red ;\t\t\t}\t\t\tchart \"Lotka Volterra Time Series - Integration time step = 0.01 \" type: series background: #white position: {0,0.66} size:{1,0.33}x_range: 1000{\t\t\t\tdata 'Number of preys' value: first(LotkaVolterra_agent where (each.integration_time_step = 0.01)).nb_prey color: #green ;\t\t\t\t\t\t\t\tdata 'Number of predators' value: first(LotkaVolterra_agent where (each.integration_time_step = 0.01)).nb_predator color: #red ;\t\t\t}\t\t}\t\tdisplay PhasePortrait {\t\t\t\t\t\tchart \"Lotka Volterra Phase Portrait - Integration time step = 1\" type: xy background: #white position: {0,0} size:{1,0.33} {\t\t// creation of a display to show phase portrait of the model, values are plotted at every step. Since there is more than one chart plotted in one display, every chart has a position and a size\t\t\tdata 'Number of preys according to number of predators' value:{LV_agents[0].nb_prey, LV_agents[0].nb_predator} color: #black ;\t// number of predators are plotted in black according to the number of preys in the case where the integration time step is 1\t\t\t\t\t}\t\t\tchart \"Lotka Volterra Phase Portrait - Integration time step = 0.1\" type: xy background: #white position: {0,0.33} size:{1,0.33}{\t\t\tdata 'Number of preys according to number of predators' value:{LV_agents[1].nb_prey, LV_agents[1].nb_predator} color: #black ;\t\t\t\t\t\t\t}\t\t\tchart \"Lotka Volterra Phase Portrait - Integration time step = 0.01\" type: xy background: #white position: {0,0.66} size:{1,0.33} {\t\t\tdata 'Number of preys according to number of predators' value:{LV_agents[1].nb_prey, LV_agents[1].nb_predator} color: #black ;\t\t\t\t\t\t\t}\t\t}\t}}",
        "url":"/wiki/Predator-Prey-Lotka-Volterra-(Influence-of-Integration-Step).html"
      }
      ,
    
      "wiki-predator-prey-lotka-volterra-simple-html": {
        "title": "ODE_LotkaVolterra",
        "content": "ODE_LotkaVolterraAuthor : Huynh Quang Nghi &amp; Nathalie CorsonCode of the model :model ODE_LotkaVolterraglobal {\tfloat prey_birth_rate&lt;- 0.05 ; \t\t// natural birth rate of preys\tfloat predation_rate &lt;- 0.001; \t\t\t// death rate of preys due to predators\tfloat predator_death_rate&lt;- 0.03 ; \t// natural death rate of predators\tfloat predation_efficiency&lt;- 0.0002 ; \t// birth rate of predators due to prey consumption\tfloat nb_prey_init &lt;- 250.0; \t\t\t// initial number of preys\tfloat nb_predator_init &lt;- 45.0 ; \t\t// initial number of predators\tfloat integration_time_step &lt;- 0.01; \t// integration time step used in the Runge Kutta 4 method\tfloat t; \t\t\t\t\t\t// simulation time : t = n * integration_time_step  where n is the number of already computed time step\tinit{\t\tcreate LotkaVolterra_agent number:1 ; \t// creation of an agent containing the ODE model\t}}species LotkaVolterra_agent {\tfloat nb_prey &lt;- nb_prey_init ; \t\t\t// number of preys initialized with the values given by the user\tfloat nb_predator &lt;- nb_predator_init ; \t\t// number of predators initialized with the values given by the user\tequation lotka_volterra {\t\tdiff(nb_prey,t) =   nb_prey * (prey_birth_rate - predation_rate * nb_predator); \t\t\t\t\t// evolution of the number of preys duting an integration time step\t\tdiff(nb_predator,t) = - nb_predator * (predator_death_rate - predation_efficiency * nb_prey); \t\t// evolution of the number of predator during an integration time step      }      reflex solving {       \tsolve lotka_volterra method: \"rk4\" step:integration_time_step ;//cycle_length:1/step; \t\t\t// use of runge kutta 4 method with an integration time step of value integration_time_step       }}experiment maths type: gui {\tparameter \"Prey birth rate\" var: prey_birth_rate &lt;- 0.05 min: 0.0 max: 1.0 category: \"Prey\";\t\t\t\t\t\t// the user defines the value of parameter prey_birth_rate on the interface, the default value is 0.05 and this value must be between 0 and 1\tparameter \"Predation rate\" var: predation_rate &lt;- 0.001 min: 0.0 max: 1.0 category: \"Prey\"; \t\t\t\t\t\t// the user defines the value of parameter prey_birth_rate on the interface, the default value is 0.001 and this value must be between 0 and 1\tparameter \"Predator death rate\" var: predator_death_rate &lt;- 0.03 min: 0.0 max: 1.0 category: \"Predator\";\t \t\t// the user defines the value of parameter predator_death_rate on the interface, the default value is 0.03 and this value must be between 0 and 1\tparameter \"Predation efficiency\" var: predation_efficiency &lt;- 0.0002 min: 0.0 max: 1.0 category: \"Predator\";\t\t// the user defines the value of parameter predation_efficiency on the interface, the default value is 0.0002 and this value must be between 0 and 1\tparameter \"Initial number of prey\" var: nb_prey_init &lt;- 250.0 min: 1.0 category: \"Prey\"; \t\t\t\t\t\t\t// the user defines the value of parameter predation_efficiency on the interface, the default value is 250, the minimum possible value is 1\tparameter \"Initial number of predator\" var: nb_predator_init &lt;- 45.0 min: 1.0 category: \"Predator\"; \t\t\t\t// the user defines the value of parameter predation_efficiency on the interface, the default value is 45, the minimum possible value is 1\tparameter \"Integration time step\" var: integration_time_step &lt;- 0.01 min: 0.0 max:0.1 category: \"Integration method\";  // the user defines the value of the integration step, the default value is 0.01 and this value must be between 0 and 1\toutput { \t\tdisplay TimeSeries  {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// creation of a display to show time series of the model, values are plotted at every step\t\t\tchart \"Lotka Volterra Time Series\" type: series background: #white {  \t\t\t\t\t\t// the chart, of type 'serie', is named Lotka Volterra Time Series, it shows quantities according to time, and the background is white\t\t\t\tdata 'Number of preys' value: first(LotkaVolterra_agent).nb_prey color: #green ;\t\t\t// number of preys is plotted in green\t\t\t\tdata 'Number of predators' value: first(LotkaVolterra_agent).nb_predator color: #red ; \t// number of predators is plotted in red\t\t\t}\t\t}\t\tdisplay PhasePortrait  {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// creation of a display to show the phase portait, values are plotted at every time step\t\t\tchart \"Lotka Volterra Phase Portrait\" type: xy background: #white {\t\t\t\t\t\t\t// the chart, os type 'xy', is named Lotka Volterra Phase portrait, it shows a quantity according to another one, and the background is white\t\t\tdata ' ' value: {predator_death_rate / predation_efficiency, prey_birth_rate/predation_rate} color: °blue; // equilibrium point\t\t\tdata 'Number of preys according to number of predators' value:{first(LotkaVolterra_agent).nb_prey, first(LotkaVolterra_agent).nb_predator} color: #black ;\t// number of predators according to the number of preys plotted in black\t\t\t}\t\t}\t}}",
        "url":"/wiki/Predator-Prey-Lotka-Volterra-(Simple).html"
      }
      ,
    
      "wiki-predator-prey-model-01-html": {
        "title": "Basic model (prey agents)",
        "content": "Basic model (prey agents)First part of the tutorial : Predator PreyCode of the model :model prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tinit {\t\tcreate prey number: nb_preys_init ;\t}}species prey {\tfloat size &lt;- 1.0 ;\trgb color &lt;- #blue;\t\t\taspect base {\t\tdraw circle(size) color: color ;\t}} experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;\toutput {\t\tdisplay main_display {\t\t\tspecies prey aspect: base ;\t\t}\t}} ",
        "url":"/wiki/Predator-Prey-Model-01.html"
      }
      ,
    
      "wiki-predator-prey-model-02-html": {
        "title": "Dynamic of the vegetation (grid)",
        "content": "Dynamic of the vegetation (grid)Second part of the tutorial : Predator PreyCode of the model :model prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tinit {\t\tcreate prey number: nb_preys_init ;\t}}species prey {\tfloat size &lt;- 1.0 ;\trgb color &lt;- #blue;\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ;\t\t\tinit {\t\tlocation &lt;- myCell.location;\t}\t\t\taspect base {\t\tdraw circle(size) color: color ;\t}}grid vegetation_cell width: 50 height: 50 neighbors: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;}experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: base ;\t\t}\t}} ",
        "url":"/wiki/Predator-Prey-Model-02.html"
      }
      ,
    
      "wiki-predator-prey-model-03-html": {
        "title": "Behavior of the prey agent",
        "content": "Behavior of the prey agentThird part of the tutorial : Predator PreyCode of the model :model prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfert &lt;- 0.1;\tfloat prey_energy_consum &lt;- 0.05;\t\tinit {\t\tcreate prey number: nb_preys_init ;\t}}species prey {\tfloat size &lt;- 1.0 ;\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfert &lt;- prey_max_transfert ;\tfloat energy_consum &lt;- prey_energy_consum ;\t\t\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ; \tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\t\tinit { \t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move { \t\tmyCell &lt;- one_of (myCell.neighbours) ;\t\tlocation &lt;- myCell.location ;\t}\treflex eat when: myCell.food &gt; 0 { \t\tfloat energy_transfert &lt;- min([max_transfert, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfert ;\t\tenergy &lt;- energy + energy_transfert ;\t}\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\taspect base {\t\tdraw circle(size) color: color ;\t}}grid vegetation_cell width: 50 height: 50 neighbors: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbors_at 2);}experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: base ;\t\t}\t}}",
        "url":"/wiki/Predator-Prey-Model-03.html"
      }
      ,
    
      "wiki-predator-prey-model-04-html": {
        "title": "Use of Inspectors/monitors",
        "content": "Use of Inspectors/monitors4th part of the tutorial : Predator PreyCode of the model :model prey_predatorglobal {\tint nb_preys_init &lt;- 200 ;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfert &lt;- 0.1;\tfloat prey_energy_consum &lt;- 0.05;\tint nb_preys -&gt; {length (prey)};\t\tinit {\t\tcreate prey number: nb_preys_init ;\t}}species prey {\tfloat size &lt;- 1.0 ;\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfert &lt;- prey_max_transfert ;\tfloat energy_consum &lt;- prey_energy_consum ;\t\t\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ; \tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\t\tinit { \t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move { \t\tmyCell &lt;- one_of (myCell.neighbours) ;\t\tlocation &lt;- myCell.location ;\t}\treflex eat when: myCell.food &gt; 0 { \t\tfloat energy_transfert &lt;- min([max_transfert, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfert ;\t\tenergy &lt;- energy + energy_transfert ;\t}\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\taspect base {\t\tdraw circle(size) color: color ;\t}}grid vegetation_cell width: 50 height: 50 neighbors: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbors_at 2);}experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: base ;\t\t}\t\tmonitor \"Number of preys\" value: nb_preys ;\t}}",
        "url":"/wiki/Predator-Prey-Model-04.html"
      }
      ,
    
      "wiki-predator-prey-model-05-html": {
        "title": "Predator agents (parent species)",
        "content": "Predator agents (parent species)5th part of the tutorial : Predator PreyCode of the model :model prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tint nb_predators_init &lt;- 20;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfert &lt;- 0.1 ;\tfloat prey_energy_consum &lt;- 0.05;\tfloat predator_max_energy &lt;- 1.0;\tfloat predator_energy_transfert &lt;- 0.5;\tfloat predator_energy_consum &lt;- 0.02;\tint nb_preys -&gt; {length (prey)};\tint nb_predators -&gt; {length (predator)};\t\tinit {\t\tcreate prey number: nb_preys_init ; \t\tcreate predator number: nb_predators_init ;\t}}species generic_species {\tfloat size &lt;- 1.0;\trgb color  ;\tfloat max_energy;\tfloat max_transfert;\tfloat energy_consum;\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ;\tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\tinit {\t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move {\t\tmyCell &lt;- one_of (myCell.neighbours) ;\t\tlocation &lt;- myCell.location ;\t}\t\t\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\t\taspect base {\t\tdraw circle(size) color: color ;\t}}species prey parent: generic_species {\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfert &lt;- prey_max_transfert ;\tfloat energy_consum &lt;- prey_energy_consum ;\t\t\treflex eat when: myCell.food &gt; 0 {\t\tfloat energy_transfert &lt;- min([max_transfert, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfert ;\t\tenergy &lt;- energy + energy_transfert ;\t}}\tspecies predator parent: generic_species {\trgb color &lt;- #red ;\tfloat max_energy &lt;- predator_max_energy ;\tfloat energy_transfert &lt;- predator_energy_transfert ;\tfloat energy_consum &lt;- predator_energy_consum ;\tlist&lt;prey&gt; reachable_preys update: prey inside (myCell);\t\t\treflex eat when: ! empty(reachable_preys) {\t\task one_of (reachable_preys) {\t\t\tdo die ;\t\t}\t\tenergy &lt;- energy + energy_transfert ;\t}}\tgrid vegetation_cell width: 50 height: 50 neighbors: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbors_at 2); }experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\t\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: base ;\t\t\tspecies predator aspect: base ;\t\t}\t\tmonitor \"Number of preys\" value: nb_preys;\t\tmonitor \"Number of predators\" value: nb_predators;\t}} ",
        "url":"/wiki/Predator-Prey-Model-05.html"
      }
      ,
    
      "wiki-predator-prey-model-06-html": {
        "title": "Breeding of prey and predator agents",
        "content": "Breeding of prey and predator agents6th part of the tutorial : Predator PreyCode of the model :model prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tint nb_predators_init &lt;- 20;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfert &lt;- 0.1 ;\tfloat prey_energy_consum &lt;- 0.05;\tfloat predator_max_energy &lt;- 1.0;\tfloat predator_energy_transfert &lt;- 0.5;\tfloat predator_energy_consum &lt;- 0.02;\tfloat prey_proba_reproduce &lt;- 0.01;\tint prey_nb_max_offsprings &lt;- 5; \tfloat prey_energy_reproduce &lt;- 0.5; \tfloat predator_proba_reproduce &lt;- 0.01;\tint predator_nb_max_offsprings &lt;- 3;\tfloat predator_energy_reproduce &lt;- 0.5;\t\tint nb_preys -&gt; {length (prey)};\tint nb_predators -&gt; {length (predator)};\t\tinit {\t\tcreate prey number: nb_preys_init ; \t\tcreate predator number: nb_predators_init ;\t}}species generic_species {\tfloat size &lt;- 1.0;\trgb color  ;\tfloat max_energy;\tfloat max_transfert;\tfloat energy_consum;\tfloat proba_reproduce ;\tfloat nb_max_offsprings;\tfloat energy_reproduce;\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ;\tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\tinit {\t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move {\t\tmyCell &lt;- one_of (myCell.neighbours) ;\t\tlocation &lt;- myCell.location ;\t}\t\t\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\t\treflex reproduce when: (energy &gt;= energy_reproduce) and (flip(proba_reproduce)) {\t\t\tint nb_offsprings &lt;-int(1 + rnd(nb_max_offsprings -1));\t\t\tcreate species(self) number: nb_offsprings {\t\t\t\tmyCell &lt;- myself.myCell ;\t\t\t\tlocation &lt;- myCell.location ;\t\t\t\tenergy &lt;- myself.energy / nb_offsprings ;\t\t\t}\t\t\tenergy &lt;- energy / nb_offsprings ;\t\t}\t\taspect base {\t\tdraw circle(size) color: color ;\t}}species prey parent: generic_species {\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfert &lt;- prey_max_transfert ;\tfloat energy_consum &lt;- prey_energy_consum ;\tfloat proba_reproduce &lt;- prey_proba_reproduce ;\tint nb_max_offsprings &lt;- prey_nb_max_offsprings ;\tfloat energy_reproduce &lt;- prey_energy_reproduce ;\t\t\treflex eat when: myCell.food &gt; 0 {\t\tfloat energy_transfert &lt;- min([max_transfert, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfert ;\t\tenergy &lt;- energy + energy_transfert ;\t}}\tspecies predator parent: generic_species {\trgb color &lt;- #red ;\tfloat max_energy &lt;- predator_max_energy ;\tfloat energy_transfert &lt;- predator_energy_transfert ;\tfloat energy_consum &lt;- predator_energy_consum ;\tlist&lt;prey&gt; reachable_preys update: prey inside (myCell);\tfloat proba_reproduce &lt;- predator_proba_reproduce ;\tint nb_max_offsprings &lt;- predator_nb_max_offsprings ;\tfloat energy_reproduce &lt;- predator_energy_reproduce ;\t\t\treflex eat when: ! empty(reachable_preys) {\t\task one_of (reachable_preys) {\t\t\tdo die ;\t\t}\t\tenergy &lt;- energy + energy_transfert ;\t}}\tgrid vegetation_cell width: 50 height: 50 neighbors: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbors_at 2); }experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\t\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: base ;\t\t\tspecies predator aspect: base ;\t\t}\t\tmonitor \"Number of preys\" value: nb_preys;\t\tmonitor \"Number of predators\" value: nb_predators;\t}}",
        "url":"/wiki/Predator-Prey-Model-06.html"
      }
      ,
    
      "wiki-predator-prey-model-07-html": {
        "title": "Agent display (aspect)",
        "content": "Agent display (aspect)6th part of the tutorial: Predator PreyCode of the model :model prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tint nb_predators_init &lt;- 20;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfert &lt;- 0.1 ;\tfloat prey_energy_consum &lt;- 0.05;\tfloat predator_max_energy &lt;- 1.0;\tfloat predator_energy_transfert &lt;- 0.5;\tfloat predator_energy_consum &lt;- 0.02;\tfloat prey_proba_reproduce &lt;- 0.01;\tint prey_nb_max_offsprings &lt;- 5; \tfloat prey_energy_reproduce &lt;- 0.5; \tfloat predator_proba_reproduce &lt;- 0.01;\tint predator_nb_max_offsprings &lt;- 3;\tfloat predator_energy_reproduce &lt;- 0.5;\t\tint nb_preys -&gt; {length (prey)};\tint nb_predators -&gt; {length (predator)};\t\tinit {\t\tcreate prey number: nb_preys_init ; \t\tcreate predator number: nb_predators_init ;\t}}species generic_species {\tfloat size &lt;- 1.0;\trgb color  ;\tfloat max_energy;\tfloat max_transfert;\tfloat energy_consum;\tfloat proba_reproduce ;\tfloat nb_max_offsprings;\tfloat energy_reproduce;\timage_file my_icon;\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ;\tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\tinit {\t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move {\t\tmyCell &lt;- one_of (myCell.neighbours) ;\t\tlocation &lt;- myCell.location ;\t}\t\t\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\t\treflex reproduce when: (energy &gt;= energy_reproduce) and (flip(proba_reproduce)) {\t\t\tint nb_offsprings &lt;- int(1 + rnd(nb_max_offsprings -1));\t\t\tcreate species(self) number: nb_offsprings {\t\t\t\tmyCell &lt;- myself.myCell ;\t\t\t\tlocation &lt;- myCell.location ;\t\t\t\tenergy &lt;- myself.energy / nb_offsprings ;\t\t\t}\t\t\tenergy &lt;- energy / nb_offsprings ;\t\t}\t\taspect base {\t\tdraw circle(size) color: color ;\t}\taspect icon {\t\tdraw my_icon size: 2 * size ;\t}\taspect info {\t\tdraw square(size) color: color ;\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\t}}species prey parent: generic_species {\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfert &lt;- prey_max_transfert ;\tfloat energy_consum &lt;- prey_energy_consum ;\tfloat proba_reproduce &lt;- prey_proba_reproduce ;\tint nb_max_offsprings &lt;- prey_nb_max_offsprings ;\tfloat energy_reproduce &lt;- prey_energy_reproduce ;\tfile my_icon &lt;- file(\"../includes/data/sheep.png\") ;\t\t\treflex eat when: myCell.food &gt; 0 {\t\tfloat energy_transfert &lt;- min([max_transfert, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfert ;\t\tenergy &lt;- energy + energy_transfert ;\t}}\tspecies predator parent: generic_species {\trgb color &lt;- #red ;\tfloat max_energy &lt;- predator_max_energy ;\tfloat energy_transfert &lt;- predator_energy_transfert ;\tfloat energy_consum &lt;- predator_energy_consum ;\tlist&lt;prey&gt; reachable_preys update: prey inside (myCell);\tfloat proba_reproduce &lt;- predator_proba_reproduce ;\tint nb_max_offsprings &lt;- predator_nb_max_offsprings ;\tfloat energy_reproduce &lt;- predator_energy_reproduce ;\tfile my_icon &lt;- file(\"../includes/data/wolf.png\") ;\t\treflex eat when: ! empty(reachable_preys) {\t\task one_of (reachable_preys) {\t\t\tdo die ;\t\t}\t\tenergy &lt;- energy + energy_transfert ;\t}}\tgrid vegetation_cell width: 50 height: 50 neighbors: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbors_at 2); }experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\t\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: icon ;\t\t\tspecies predator aspect: icon ;\t\t}\t\tdisplay info_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: info ;\t\t\tspecies predator aspect: info ;\t\t}\t\tmonitor \"Number of preys\" value: nb_preys;\t\tmonitor \"Number of predators\" value: nb_predators;\t}}",
        "url":"/wiki/Predator-Prey-Model-07.html"
      }
      ,
    
      "wiki-predator-prey-model-08-html": {
        "title": "Complex behaviors for the preys and predators",
        "content": "Complex behaviors for the preys and predators8th part of the tutorial: Predator PreyCode of the model :model prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tint nb_predators_init &lt;- 20;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfert &lt;- 0.1 ;\tfloat prey_energy_consum &lt;- 0.05;\tfloat predator_max_energy &lt;- 1.0;\tfloat predator_energy_transfert &lt;- 0.5;\tfloat predator_energy_consum &lt;- 0.02;\tfloat prey_proba_reproduce &lt;- 0.01;\tint prey_nb_max_offsprings &lt;- 5; \tfloat prey_energy_reproduce &lt;- 0.5; \tfloat predator_proba_reproduce &lt;- 0.01;\tint predator_nb_max_offsprings &lt;- 3;\tfloat predator_energy_reproduce &lt;- 0.5;\t\tint nb_preys -&gt; {length (prey)};\tint nb_predators -&gt; {length (predator)};\t\tinit {\t\tcreate prey number: nb_preys_init ; \t\tcreate predator number: nb_predators_init ;\t}}species generic_species {\tfloat size &lt;- 1.0;\trgb color  ;\tfloat max_energy;\tfloat max_transfert;\tfloat energy_consum;\tfloat proba_reproduce ;\tfloat nb_max_offsprings;\tfloat energy_reproduce;\timage_file my_icon;\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ;\tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\tinit {\t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move {\t\t\tmyCell &lt;- choose_cell();\t\t\tlocation &lt;- myCell.location; \t} \t\tvegetation_cell choose_cell {\t\treturn nil;\t}\t\t\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\t\treflex reproduce when: (energy &gt;= energy_reproduce) and (flip(proba_reproduce)) {\t\t\tint nb_offsprings &lt;- int(1 + rnd(nb_max_offsprings -1));\t\t\tcreate species(self) number: nb_offsprings {\t\t\t\tmyCell &lt;- myself.myCell ;\t\t\t\tlocation &lt;- myCell.location ;\t\t\t\tenergy &lt;- myself.energy / nb_offsprings ;\t\t\t}\t\t\tenergy &lt;- energy / nb_offsprings ;\t\t}\t\taspect base {\t\tdraw circle(size) color: color ;\t}\taspect icon {\t\tdraw my_icon size: 2 * size ;\t}\taspect info {\t\tdraw square(size) color: color ;\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\t}}species prey parent: generic_species {\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfert &lt;- prey_max_transfert ;\tfloat energy_consum &lt;- prey_energy_consum ;\tfloat proba_reproduce &lt;- prey_proba_reproduce ;\tint nb_max_offsprings &lt;- prey_nb_max_offsprings ;\tfloat energy_reproduce &lt;- prey_energy_reproduce ;\tfile my_icon &lt;- file(\"../includes/data/sheep.png\") ;\t\t\treflex eat when: myCell.food &gt; 0 {\t\tfloat energy_transfert &lt;- min([max_transfert, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfert ;\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\treturn (myCell.neighbours) with_max_of (each.food);\t}}\tspecies predator parent: generic_species {\trgb color &lt;- #red ;\tfloat max_energy &lt;- predator_max_energy ;\tfloat energy_transfert &lt;- predator_energy_transfert ;\tfloat energy_consum &lt;- predator_energy_consum ;\tlist&lt;prey&gt; reachable_preys update: prey inside (myCell);\tfloat proba_reproduce &lt;- predator_proba_reproduce ;\tint nb_max_offsprings &lt;- predator_nb_max_offsprings ;\tfloat energy_reproduce &lt;- predator_energy_reproduce ;\tfile my_icon &lt;- file(\"../includes/data/wolf.png\") ;\t\treflex eat when: ! empty(reachable_preys) {\t\task one_of (reachable_preys) {\t\t\tdo die ;\t\t}\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\tvegetation_cell myCell_tmp &lt;- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\t\tif myCell_tmp != nil {\t\t\treturn myCell_tmp;\t\t} else {\t\t\treturn one_of (myCell.neighbours);\t\t} \t}}\tgrid vegetation_cell width: 50 height: 50 neighbors: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbors_at 2); }experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\t\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: icon ;\t\t\tspecies predator aspect: icon ;\t\t}\t\tdisplay info_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: info ;\t\t\tspecies predator aspect: info ;\t\t}\t\tmonitor \"Number of preys\" value: nb_preys;\t\tmonitor \"Number of predators\" value: nb_predators;\t}}",
        "url":"/wiki/Predator-Prey-Model-08.html"
      }
      ,
    
      "wiki-predator-prey-model-09-html": {
        "title": "Adding of a stopping condition",
        "content": "Adding of a stopping condition9th part of the tutorial: Predator PreyCode of the model :model prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tint nb_predators_init &lt;- 20;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfert &lt;- 0.1 ;\tfloat prey_energy_consum &lt;- 0.05;\tfloat predator_max_energy &lt;- 1.0;\tfloat predator_energy_transfert &lt;- 0.5;\tfloat predator_energy_consum &lt;- 0.02;\tfloat prey_proba_reproduce &lt;- 0.01;\tint prey_nb_max_offsprings &lt;- 5; \tfloat prey_energy_reproduce &lt;- 0.5; \tfloat predator_proba_reproduce &lt;- 0.01;\tint predator_nb_max_offsprings &lt;- 3;\tfloat predator_energy_reproduce &lt;- 0.5;\t\tint nb_preys -&gt; {length (prey)};\tint nb_predators -&gt; {length (predator)};\t\tinit {\t\tcreate prey number: nb_preys_init ; \t\tcreate predator number: nb_predators_init ;\t}\t\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\t\tdo halt ;\t} }species generic_species {\tfloat size &lt;- 1.0;\trgb color  ;\tfloat max_energy;\tfloat max_transfert;\tfloat energy_consum;\tfloat proba_reproduce ;\tfloat nb_max_offsprings;\tfloat energy_reproduce;\timage_file my_icon;\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ;\tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\tinit {\t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move {\t\t\tmyCell &lt;- choose_cell();\t\t\tlocation &lt;- myCell.location; \t} \t\tvegetation_cell choose_cell {\t\treturn nil;\t}\t\t\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\t\treflex reproduce when: (energy &gt;= energy_reproduce) and (flip(proba_reproduce)) {\t\t\tint nb_offsprings &lt;- int(1 + rnd(nb_max_offsprings -1));\t\t\tcreate species(self) number: nb_offsprings {\t\t\t\tmyCell &lt;- myself.myCell ;\t\t\t\tlocation &lt;- myCell.location ;\t\t\t\tenergy &lt;- myself.energy / nb_offsprings ;\t\t\t}\t\t\tenergy &lt;- energy / nb_offsprings ;\t\t}\t\taspect base {\t\tdraw circle(size) color: color ;\t}\taspect icon {\t\tdraw my_icon size: 2 * size ;\t}\taspect info {\t\tdraw square(size) color: color ;\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\t}}species prey parent: generic_species {\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfert &lt;- prey_max_transfert ;\tfloat energy_consum &lt;- prey_energy_consum ;\tfloat proba_reproduce &lt;- prey_proba_reproduce ;\tint nb_max_offsprings &lt;- prey_nb_max_offsprings ;\tfloat energy_reproduce &lt;- prey_energy_reproduce ;\tfile my_icon &lt;- file(\"../includes/data/sheep.png\") ;\t\t\treflex eat when: myCell.food &gt; 0 {\t\tfloat energy_transfert &lt;- min([max_transfert, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfert ;\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\treturn (myCell.neighbours) with_max_of (each.food);\t}}\tspecies predator parent: generic_species {\trgb color &lt;- #red ;\tfloat max_energy &lt;- predator_max_energy ;\tfloat energy_transfert &lt;- predator_energy_transfert ;\tfloat energy_consum &lt;- predator_energy_consum ;\tlist&lt;prey&gt; reachable_preys update: prey inside (myCell);\tfloat proba_reproduce &lt;- predator_proba_reproduce ;\tint nb_max_offsprings &lt;- predator_nb_max_offsprings ;\tfloat energy_reproduce &lt;- predator_energy_reproduce ;\tfile my_icon &lt;- file(\"../includes/data/wolf.png\") ;\t\treflex eat when: ! empty(reachable_preys) {\t\task one_of (reachable_preys) {\t\t\tdo die ;\t\t}\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\tvegetation_cell myCell_tmp &lt;- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\t\tif myCell_tmp != nil {\t\t\treturn myCell_tmp;\t\t} else {\t\t\treturn one_of (myCell.neighbours);\t\t} \t}}\tgrid vegetation_cell width: 50 height: 50 neighbors: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbors_at 2); }experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\t\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: icon ;\t\t\tspecies predator aspect: icon ;\t\t}\t\tdisplay info_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: info ;\t\t\tspecies predator aspect: info ;\t\t}\t\tmonitor \"Number of preys\" value: nb_preys;\t\tmonitor \"Number of predators\" value: nb_predators;\t}}",
        "url":"/wiki/Predator-Prey-Model-09.html"
      }
      ,
    
      "wiki-predator-prey-model-10-html": {
        "title": "Definition of charts",
        "content": "Definition of charts10th part of the tutorial: Predator PreyCode of the model :model prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tint nb_predators_init &lt;- 20;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfert &lt;- 0.1 ;\tfloat prey_energy_consum &lt;- 0.05;\tfloat predator_max_energy &lt;- 1.0;\tfloat predator_energy_transfert &lt;- 0.5;\tfloat predator_energy_consum &lt;- 0.02;\tfloat prey_proba_reproduce &lt;- 0.01;\tint prey_nb_max_offsprings &lt;- 5; \tfloat prey_energy_reproduce &lt;- 0.5; \tfloat predator_proba_reproduce &lt;- 0.01;\tint predator_nb_max_offsprings &lt;- 3;\tfloat predator_energy_reproduce &lt;- 0.5;\t\tint nb_preys -&gt; {length (prey)};\tint nb_predators -&gt; {length (predator)};\t\tinit {\t\tcreate prey number: nb_preys_init ; \t\tcreate predator number: nb_predators_init ;\t}\t\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\t\tdo halt ;\t} }species generic_species {\tfloat size &lt;- 1.0;\trgb color  ;\tfloat max_energy;\tfloat max_transfert;\tfloat energy_consum;\tfloat proba_reproduce ;\tfloat nb_max_offsprings;\tfloat energy_reproduce;\timage_file my_icon;\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ;\tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\tinit {\t\tlocation &lt;- myCell.location;\t} \t\t\treflex basic_move {\t\t\tmyCell &lt;- choose_cell();\t\t\tlocation &lt;- myCell.location; \t} \t\tvegetation_cell choose_cell {\t\treturn nil;\t}\t\t\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\t\treflex reproduce when: (energy &gt;= energy_reproduce) and (flip(proba_reproduce)) {\t\t\tint nb_offsprings &lt;- int(1 + rnd(nb_max_offsprings -1));\t\t\tcreate species(self) number: nb_offsprings {\t\t\t\tmyCell &lt;- myself.myCell ;\t\t\t\tlocation &lt;- myCell.location ;\t\t\t\tenergy &lt;- myself.energy / nb_offsprings ;\t\t\t}\t\t\tenergy &lt;- energy / nb_offsprings ;\t\t}\t\taspect base {\t\tdraw circle(size) color: color ;\t}\taspect icon {\t\tdraw my_icon size: 2 * size ;\t}\taspect info {\t\tdraw square(size) color: color ;\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\t}}species prey parent: generic_species {\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfert &lt;- prey_max_transfert ;\tfloat energy_consum &lt;- prey_energy_consum ;\tfloat proba_reproduce &lt;- prey_proba_reproduce ;\tint nb_max_offsprings &lt;- prey_nb_max_offsprings ;\tfloat energy_reproduce &lt;- prey_energy_reproduce ;\tfile my_icon &lt;- file(\"../includes/data/sheep.png\") ;\t\t\treflex eat when: myCell.food &gt; 0 {\t\tfloat energy_transfert &lt;- min([max_transfert, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfert ;\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\treturn (myCell.neighbours) with_max_of (each.food);\t}}\tspecies predator parent: generic_species {\trgb color &lt;- #red ;\tfloat max_energy &lt;- predator_max_energy ;\tfloat energy_transfert &lt;- predator_energy_transfert ;\tfloat energy_consum &lt;- predator_energy_consum ;\tlist&lt;prey&gt; reachable_preys update: prey inside (myCell);\tfloat proba_reproduce &lt;- predator_proba_reproduce ;\tint nb_max_offsprings &lt;- predator_nb_max_offsprings ;\tfloat energy_reproduce &lt;- predator_energy_reproduce ;\tfile my_icon &lt;- file(\"../includes/data/wolf.png\") ;\t\treflex eat when: ! empty(reachable_preys) {\t\task one_of (reachable_preys) {\t\t\tdo die ;\t\t}\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\tvegetation_cell myCell_tmp &lt;- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\t\tif myCell_tmp != nil {\t\t\treturn myCell_tmp;\t\t} else {\t\t\treturn one_of (myCell.neighbours);\t\t} \t}}\tgrid vegetation_cell width: 50 height: 50 neighbors: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbors_at 2); }experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\t\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: icon ;\t\t\tspecies predator aspect: icon ;\t\t}\t\tdisplay info_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: info ;\t\t\tspecies predator aspect: info ;\t\t}\t\tdisplay Population_information refresh: every(5) {\t\t\tchart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\t\t\t\tdata \"number_of_preys\" value: nb_preys color: #blue ;\t\t\t\tdata \"number_of_predator\" value: nb_predators color: #red ;\t\t\t}\t\t\tchart \"Prey Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0, 0.5} {\t\t\t\tdata \"]0;0.25]\" value: prey count (each.energy &lt;= 0.25) color:#blue;\t\t\t\tdata \"]0.25;0.5]\" value: prey count ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) color:#blue;\t\t\t\tdata \"]0.5;0.75]\" value: prey count ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) color:#blue;\t\t\t\tdata \"]0.75;1]\" value: prey count (each.energy &gt; 0.75) color:#blue;\t\t\t}\t\t\tchart \"Predator Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0.5, 0.5} {\t\t\t\tdata \"]0;0.25]\" value: predator count (each.energy &lt;= 0.25) color: #red ;\t\t\t\tdata \"]0.25;0.5]\" value: predator count ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) color: #red ;\t\t\t\tdata \"]0.5;0.75]\" value: predator count ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) color: #red ;\t\t\t\tdata \"]0.75;1]\" value: predator count (each.energy &gt; 0.75) color: #red;\t\t\t}\t\t}\t\tmonitor \"Number of preys\" value: nb_preys;\t\tmonitor \"Number of predators\" value: nb_predators;\t}}",
        "url":"/wiki/Predator-Prey-Model-10.html"
      }
      ,
    
      "wiki-predator-prey-model-11-html": {
        "title": "Writing files",
        "content": "Writing files11th part of the tutorial: Predator PreyCode of the model :model prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tint nb_predators_init &lt;- 20;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfert &lt;- 0.1 ;\tfloat prey_energy_consum &lt;- 0.05;\tfloat predator_max_energy &lt;- 1.0;\tfloat predator_energy_transfert &lt;- 0.5;\tfloat predator_energy_consum &lt;- 0.02;\tfloat prey_proba_reproduce &lt;- 0.01;\tint prey_nb_max_offsprings &lt;- 5; \tfloat prey_energy_reproduce &lt;- 0.5; \tfloat predator_proba_reproduce &lt;- 0.01;\tint predator_nb_max_offsprings &lt;- 3;\tfloat predator_energy_reproduce &lt;- 0.5;\t\tint nb_preys -&gt; {length (prey)};\tint nb_predators -&gt; {length (predator)};\t\tinit {\t\tcreate prey number: nb_preys_init ; \t\tcreate predator number: nb_predators_init ;\t}\t\treflex save_result when: (nb_preys &gt; 0) and (nb_predators &gt; 0){\t\tsave (\"cycle: \"+ cycle + \"; nbPreys: \" + nb_preys\t\t\t+ \"; minEnergyPreys: \" + ((prey as list) min_of each.energy)\t\t\t+ \"; maxSizePreys: \" + ((prey as list) max_of each.energy) \t   \t\t+ \"; nbPredators: \" + nb_predators           \t   \t\t+ \"; minEnergyPredators: \" + ((predator as list) min_of each.energy)          \t   \t\t+ \"; maxSizePredators: \" + ((predator as list) max_of each.energy)) \t   \t\tto: \"results.txt\" type: \"text\" ;\t}\t\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\t\tdo halt ;\t} }species generic_species {\tfloat size &lt;- 1.0;\trgb color  ;\tfloat max_energy;\tfloat max_transfert;\tfloat energy_consum;\tfloat proba_reproduce ;\tfloat nb_max_offsprings;\tfloat energy_reproduce;\timage_file my_icon;\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ;\tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\tinit {\t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move {\t\t\tmyCell &lt;- choose_cell();\t\t\tlocation &lt;- myCell.location; \t} \t\tvegetation_cell choose_cell {\t\treturn nil;\t}\t\t\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\t\treflex reproduce when: (energy &gt;= energy_reproduce) and (flip(proba_reproduce)) {\t\t\tint nb_offsprings &lt;- int(1 + rnd(nb_max_offsprings -1));\t\t\tcreate species(self) number: nb_offsprings {\t\t\t\tmyCell &lt;- myself.myCell ;\t\t\t\tlocation &lt;- myCell.location ;\t\t\t\tenergy &lt;- myself.energy / nb_offsprings ;\t\t\t}\t\t\tenergy &lt;- energy / nb_offsprings ;\t\t}\t\taspect base {\t\tdraw circle(size) color: color ;\t}\taspect icon {\t\tdraw my_icon size: 2 * size ;\t}\taspect info {\t\tdraw square(size) color: color ;\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\t}}species prey parent: generic_species {\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfert &lt;- prey_max_transfert ;\tfloat energy_consum &lt;- prey_energy_consum ;\tfloat proba_reproduce &lt;- prey_proba_reproduce ;\tint nb_max_offsprings &lt;- prey_nb_max_offsprings ;\tfloat energy_reproduce &lt;- prey_energy_reproduce ;\tfile my_icon &lt;- file(\"../includes/data/sheep.png\") ;\t\t\treflex eat when: myCell.food &gt; 0 {\t\tfloat energy_transfert &lt;- min([max_transfert, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfert ;\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\treturn (myCell.neighbours) with_max_of (each.food);\t}}\tspecies predator parent: generic_species {\trgb color &lt;- #red ;\tfloat max_energy &lt;- predator_max_energy ;\tfloat energy_transfert &lt;- predator_energy_transfert ;\tfloat energy_consum &lt;- predator_energy_consum ;\tlist&lt;prey&gt; reachable_preys update: prey inside (myCell);\tfloat proba_reproduce &lt;- predator_proba_reproduce ;\tint nb_max_offsprings &lt;- predator_nb_max_offsprings ;\tfloat energy_reproduce &lt;- predator_energy_reproduce ;\tfile my_icon &lt;- file(\"../includes/data/wolf.png\") ;\t\treflex eat when: ! empty(reachable_preys) {\t\task one_of (reachable_preys) {\t\t\tdo die ;\t\t}\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\tvegetation_cell myCell_tmp &lt;- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\t\tif myCell_tmp != nil {\t\t\treturn myCell_tmp;\t\t} else {\t\t\treturn one_of (myCell.neighbours);\t\t} \t}}\tgrid vegetation_cell width: 50 height: 50 neighbors: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbors_at 2); }experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\t\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: icon ;\t\t\tspecies predator aspect: icon ;\t\t}\t\tdisplay info_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: info ;\t\t\tspecies predator aspect: info ;\t\t}\t\tdisplay Population_information refresh: every(5) {\t\t\tchart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\t\t\t\tdata \"number_of_preys\" value: nb_preys color: #blue ;\t\t\t\tdata \"number_of_predator\" value: nb_predators color: #red ;\t\t\t}\t\t\tchart \"Prey Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0, 0.5} {\t\t\t\tdata \"]0;0.25]\" value: prey count (each.energy &lt;= 0.25) color:#blue;\t\t\t\tdata \"]0.25;0.5]\" value: prey count ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) color:#blue;\t\t\t\tdata \"]0.5;0.75]\" value: prey count ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) color:#blue;\t\t\t\tdata \"]0.75;1]\" value: prey count (each.energy &gt; 0.75) color:#blue;\t\t\t}\t\t\tchart \"Predator Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0.5, 0.5} {\t\t\t\tdata \"]0;0.25]\" value: predator count (each.energy &lt;= 0.25) color: #red ;\t\t\t\tdata \"]0.25;0.5]\" value: predator count ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) color: #red ;\t\t\t\tdata \"]0.5;0.75]\" value: predator count ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) color: #red ;\t\t\t\tdata \"]0.75;1]\" value: predator count (each.energy &gt; 0.75) color: #red;\t\t\t}\t\t}\t\tmonitor \"Number of preys\" value: nb_preys;\t\tmonitor \"Number of predators\" value: nb_predators;\t}}",
        "url":"/wiki/Predator-Prey-Model-11.html"
      }
      ,
    
      "wiki-predator-prey-model-12-html": {
        "title": "Image loading (raster data)",
        "content": "Image loading (raster data)12th part of the tutorial: Predator PreyCode of the model :model prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tint nb_predators_init &lt;- 20;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfert &lt;- 0.1 ;\tfloat prey_energy_consum &lt;- 0.05;\tfloat predator_max_energy &lt;- 1.0;\tfloat predator_energy_transfert &lt;- 0.5;\tfloat predator_energy_consum &lt;- 0.02;\tfloat prey_proba_reproduce &lt;- 0.01;\tint prey_nb_max_offsprings &lt;- 5; \tfloat prey_energy_reproduce &lt;- 0.5; \tfloat predator_proba_reproduce &lt;- 0.01;\tint predator_nb_max_offsprings &lt;- 3;\tfloat predator_energy_reproduce &lt;- 0.5;\tfile map_init &lt;- image_file(\"../includes/data/raster_map.png\");\t\tint nb_preys -&gt; {length (prey)};\tint nb_predators -&gt; {length (predator)};\t\tinit {\t\tcreate prey number: nb_preys_init ; \t\tcreate predator number: nb_predators_init ;\t\task vegetation_cell {\t\t\tcolor &lt;- rgb (map_init at {grid_x,grid_y}) ;\t\t\tfood &lt;- 1 - (((color as list) at 0) / 255) ;\t\t\tfoodProd &lt;- food / 100 ; \t\t}\t}\t\treflex save_result when: (nb_preys &gt; 0) and (nb_predators &gt; 0){\t\tsave (\"cycle: \"+ cycle + \"; nbPreys: \" + nb_preys\t\t\t+ \"; minEnergyPreys: \" + ((prey as list) min_of each.energy)\t\t\t+ \"; maxSizePreys: \" + ((prey as list) max_of each.energy) \t   \t\t+ \"; nbPredators: \" + nb_predators           \t   \t\t+ \"; minEnergyPredators: \" + ((predator as list) min_of each.energy)          \t   \t\t+ \"; maxSizePredators: \" + ((predator as list) max_of each.energy)) \t   \t\tto: \"results.txt\" type: \"text\" ;\t}\t\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\t\tdo halt ;\t} }species generic_species {\tfloat size &lt;- 1.0;\trgb color  ;\tfloat max_energy;\tfloat max_transfert;\tfloat energy_consum;\tfloat proba_reproduce ;\tfloat nb_max_offsprings;\tfloat energy_reproduce;\timage_file my_icon;\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ;\tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\tinit {\t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move {\t\t\tmyCell &lt;- choose_cell();\t\t\tlocation &lt;- myCell.location; \t} \t\tvegetation_cell choose_cell {\t\treturn nil;\t}\t\t\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\t\treflex reproduce when: (energy &gt;= energy_reproduce) and (flip(proba_reproduce)) {\t\t\tint nb_offsprings &lt;- int(1 + rnd(nb_max_offsprings -1));\t\t\tcreate species(self) number: nb_offsprings {\t\t\t\tmyCell &lt;- myself.myCell ;\t\t\t\tlocation &lt;- myCell.location ;\t\t\t\tenergy &lt;- myself.energy / nb_offsprings ;\t\t\t}\t\t\tenergy &lt;- energy / nb_offsprings ;\t\t}\t\taspect base {\t\tdraw circle(size) color: color ;\t}\taspect icon {\t\tdraw my_icon size: 2 * size ;\t}\taspect info {\t\tdraw square(size) color: color ;\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\t}}species prey parent: generic_species {\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfert &lt;- prey_max_transfert ;\tfloat energy_consum &lt;- prey_energy_consum ;\tfloat proba_reproduce &lt;- prey_proba_reproduce ;\tint nb_max_offsprings &lt;- prey_nb_max_offsprings ;\tfloat energy_reproduce &lt;- prey_energy_reproduce ;\tfile my_icon &lt;- file(\"../includes/data/sheep.png\") ;\t\t\treflex eat when: myCell.food &gt; 0 {\t\tfloat energy_transfert &lt;- min([max_transfert, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfert ;\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\treturn (myCell.neighbours) with_max_of (each.food);\t}}\tspecies predator parent: generic_species {\trgb color &lt;- #red ;\tfloat max_energy &lt;- predator_max_energy ;\tfloat energy_transfert &lt;- predator_energy_transfert ;\tfloat energy_consum &lt;- predator_energy_consum ;\tlist&lt;prey&gt; reachable_preys update: prey inside (myCell);\tfloat proba_reproduce &lt;- predator_proba_reproduce ;\tint nb_max_offsprings &lt;- predator_nb_max_offsprings ;\tfloat energy_reproduce &lt;- predator_energy_reproduce ;\tfile my_icon &lt;- file(\"../includes/data/wolf.png\") ;\t\treflex eat when: ! empty(reachable_preys) {\t\task one_of (reachable_preys) {\t\t\tdo die ;\t\t}\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\tvegetation_cell myCell_tmp &lt;- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\t\tif myCell_tmp != nil {\t\t\treturn myCell_tmp;\t\t} else {\t\t\treturn one_of (myCell.neighbours);\t\t} \t}}\tgrid vegetation_cell width: 50 height: 50 neighbors: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbors_at 2); }experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\t\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: icon ;\t\t\tspecies predator aspect: icon ;\t\t}\t\tdisplay info_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: info ;\t\t\tspecies predator aspect: info ;\t\t}\t\tdisplay Population_information refresh: every(5) {\t\t\tchart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\t\t\t\tdata \"number_of_preys\" value: nb_preys color: #blue ;\t\t\t\tdata \"number_of_predator\" value: nb_predators color: #red ;\t\t\t}\t\t\tchart \"Prey Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0, 0.5} {\t\t\t\tdata \"]0;0.25]\" value: prey count (each.energy &lt;= 0.25) color:#blue;\t\t\t\tdata \"]0.25;0.5]\" value: prey count ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) color:#blue;\t\t\t\tdata \"]0.5;0.75]\" value: prey count ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) color:#blue;\t\t\t\tdata \"]0.75;1]\" value: prey count (each.energy &gt; 0.75) color:#blue;\t\t\t}\t\t\tchart \"Predator Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0.5, 0.5} {\t\t\t\tdata \"]0;0.25]\" value: predator count (each.energy &lt;= 0.25) color: #red ;\t\t\t\tdata \"]0.25;0.5]\" value: predator count ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) color: #red ;\t\t\t\tdata \"]0.5;0.75]\" value: predator count ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) color: #red ;\t\t\t\tdata \"]0.75;1]\" value: predator count (each.energy &gt; 0.75) color: #red;\t\t\t}\t\t}\t\tmonitor \"Number of preys\" value: nb_preys;\t\tmonitor \"Number of predators\" value: nb_predators;\t}}",
        "url":"/wiki/Predator-Prey-Model-12.html"
      }
      ,
    
      "wiki-predator-prey-model-13-html": {
        "title": "Exploration (batch)",
        "content": "Exploration (batch)13th part of the tutorial: Predator PreyCode of the model :model prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tint nb_predators_init &lt;- 20;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfert &lt;- 0.1 ;\tfloat prey_energy_consum &lt;- 0.05;\tfloat predator_max_energy &lt;- 1.0;\tfloat predator_energy_transfert &lt;- 0.5;\tfloat predator_energy_consum &lt;- 0.02;\tfloat prey_proba_reproduce &lt;- 0.01;\tint prey_nb_max_offsprings &lt;- 5; \tfloat prey_energy_reproduce &lt;- 0.5; \tfloat predator_proba_reproduce &lt;- 0.01;\tint predator_nb_max_offsprings &lt;- 3;\tfloat predator_energy_reproduce &lt;- 0.5;\tfile map_init &lt;- image_file(\"../includes/data/raster_map.png\");\t\tint nb_preys -&gt; {length (prey)};\tint nb_predators -&gt; {length (predator)};\t\tinit {\t\tcreate prey number: nb_preys_init ; \t\tcreate predator number: nb_predators_init ;\t\task vegetation_cell {\t\t\tcolor &lt;- rgb (map_init at {grid_x,grid_y}) ;\t\t\tfood &lt;- 1 - (((color as list) at 0) / 255) ;\t\t\tfoodProd &lt;- food / 100 ; \t\t}\t}\t\treflex save_result when: (nb_preys &gt; 0) and (nb_predators &gt; 0){\t\tsave (\"cycle: \"+ cycle + \"; nbPreys: \" + nb_preys\t\t\t+ \"; minEnergyPreys: \" + ((prey as list) min_of each.energy)\t\t\t+ \"; maxSizePreys: \" + ((prey as list) max_of each.energy) \t   \t\t+ \"; nbPredators: \" + nb_predators           \t   \t\t+ \"; minEnergyPredators: \" + ((predator as list) min_of each.energy)          \t   \t\t+ \"; maxSizePredators: \" + ((predator as list) max_of each.energy)) \t   \t\tto: \"results.txt\" type: \"text\" ;\t}\t\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\t\tdo halt ;\t} }species generic_species {\tfloat size &lt;- 1.0;\trgb color  ;\tfloat max_energy;\tfloat max_transfert;\tfloat energy_consum;\tfloat proba_reproduce ;\tfloat nb_max_offsprings;\tfloat energy_reproduce;\timage_file my_icon;\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ;\tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\tinit {\t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move {\t\t\tmyCell &lt;- choose_cell();\t\t\tlocation &lt;- myCell.location; \t} \t\tvegetation_cell choose_cell {\t\treturn nil;\t}\t\t\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\t\treflex reproduce when: (energy &gt;= energy_reproduce) and (flip(proba_reproduce)) {\t\t\tint nb_offsprings &lt;- int(1 + rnd(nb_max_offsprings -1));\t\t\tcreate species(self) number: nb_offsprings {\t\t\t\tmyCell &lt;- myself.myCell ;\t\t\t\tlocation &lt;- myCell.location ;\t\t\t\tenergy &lt;- myself.energy / nb_offsprings ;\t\t\t}\t\t\tenergy &lt;- energy / nb_offsprings ;\t\t}\t\taspect base {\t\tdraw circle(size) color: color ;\t}\taspect icon {\t\tdraw my_icon size: 2 * size ;\t}\taspect info {\t\tdraw square(size) color: color ;\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\t}}species prey parent: generic_species {\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfert &lt;- prey_max_transfert ;\tfloat energy_consum &lt;- prey_energy_consum ;\tfloat proba_reproduce &lt;- prey_proba_reproduce ;\tint nb_max_offsprings &lt;- prey_nb_max_offsprings ;\tfloat energy_reproduce &lt;- prey_energy_reproduce ;\tfile my_icon &lt;- file(\"../includes/data/sheep.png\") ;\t\t\treflex eat when: myCell.food &gt; 0 {\t\tfloat energy_transfert &lt;- min([max_transfert, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfert ;\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\treturn (myCell.neighbours) with_max_of (each.food);\t}}\tspecies predator parent: generic_species {\trgb color &lt;- #red ;\tfloat max_energy &lt;- predator_max_energy ;\tfloat energy_transfert &lt;- predator_energy_transfert ;\tfloat energy_consum &lt;- predator_energy_consum ;\tlist&lt;prey&gt; reachable_preys update: prey inside (myCell);\tfloat proba_reproduce &lt;- predator_proba_reproduce ;\tint nb_max_offsprings &lt;- predator_nb_max_offsprings ;\tfloat energy_reproduce &lt;- predator_energy_reproduce ;\tfile my_icon &lt;- file(\"../includes/data/wolf.png\") ;\t\treflex eat when: ! empty(reachable_preys) {\t\task one_of (reachable_preys) {\t\t\tdo die ;\t\t}\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\tvegetation_cell myCell_tmp &lt;- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\t\tif myCell_tmp != nil {\t\t\treturn myCell_tmp;\t\t} else {\t\t\treturn one_of (myCell.neighbours);\t\t} \t}}\tgrid vegetation_cell width: 50 height: 50 neighbors: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbors_at 2); }experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\t\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: icon ;\t\t\tspecies predator aspect: icon ;\t\t}\t\tdisplay info_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: info ;\t\t\tspecies predator aspect: info ;\t\t}\t\tdisplay Population_information refresh: every(5) {\t\t\tchart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\t\t\t\tdata \"number_of_preys\" value: nb_preys color: #blue ;\t\t\t\tdata \"number_of_predator\" value: nb_predators color: #red ;\t\t\t}\t\t\tchart \"Prey Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0, 0.5} {\t\t\t\tdata \"]0;0.25]\" value: prey count (each.energy &lt;= 0.25) color:#blue;\t\t\t\tdata \"]0.25;0.5]\" value: prey count ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) color:#blue;\t\t\t\tdata \"]0.5;0.75]\" value: prey count ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) color:#blue;\t\t\t\tdata \"]0.75;1]\" value: prey count (each.energy &gt; 0.75) color:#blue;\t\t\t}\t\t\tchart \"Predator Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0.5, 0.5} {\t\t\t\tdata \"]0;0.25]\" value: predator count (each.energy &lt;= 0.25) color: #red ;\t\t\t\tdata \"]0.25;0.5]\" value: predator count ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) color: #red ;\t\t\t\tdata \"]0.5;0.75]\" value: predator count ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) color: #red ;\t\t\t\tdata \"]0.75;1]\" value: predator count (each.energy &gt; 0.75) color: #red;\t\t\t}\t\t}\t\tmonitor \"Number of preys\" value: nb_preys;\t\tmonitor \"Number of predators\" value: nb_predators;\t}}experiment Optimization type: batch repeat: 2 keep_seed: true until: ( time &gt; 200 ) {\tparameter \"Prey max transfert:\" var: prey_max_transfert min: 0.05 max: 0.5 step: 0.05 ;\tparameter \"Prey energy reproduce:\" var: prey_energy_reproduce min: 0.05 max: 0.75 step: 0.05;\tparameter \"Predator energy transfert:\" var: predator_energy_transfert min: 0.1 max: 1.0 step: 0.1 ;\tparameter \"Predator energy reproduce:\" var: predator_energy_reproduce min: 0.1 max: 1.0 step: 0.1;\tmethod tabu maximize: nb_preys + nb_predators iter_max: 10 tabu_list_size: 3;}",
        "url":"/wiki/Predator-Prey-Model-13.html"
      }
      ,
    
      "wiki-predator-prey-html": {
        "title": "Predator Prey",
        "content": "Predator PreyThis sub-section is composed of the following models :      Basic model (prey agents)        Dynamic of the vegetation (grid)        Behavior of the prey agent        Use of Inspectors/monitors        Predator agents (parent species)        Breeding of prey and predator agents        Agent display (aspect)        Complex behaviors for the preys and predators        Adding of a stopping condition        Definition of charts        Writing files        Image loading (raster data)        Exploration (batch)  ",
        "url":"/wiki/Predator-Prey.html"
      }
      ,
    
      "wiki-predatorprey-html": {
        "title": "Predator Prey",
        "content": "Predator PreyThis tutorial presents the structure of a GAMA model as well as the use of a grid topology. In particular, this tutorial shows how to define a basic model, to define “grid agents” which are able to move within the constraints. It also introduce the displays and agents’ aspect.All the files related to this tutorial (images and models) are available in the Models Library (project Tutorials/Predator Prey).ContentModel OverviewIn this model, three types of entities are considered: preys, predators and vegetation cells. Preyseat grass on the vegetation cells and predators eat preys. At each simulation step, grass grows on the vegetation cells. Concerning the predators and preys, at each simulation step, they move (to a neighbor cell), eat, die if they do not have enough energy, and eventually reproduce.Step ListThis tutorial is composed of 12 incremental steps corresponding to 12 models. For each step we present its purpose, an explicit formulation and the corresponding GAML code of the model.  Basic model (prey agents)  Dynamic of the vegetation (grid)  Behavior of the prey agent  Use of Inspectors/monitors  predator agents (parent species)  Breeding of prey and predator agents  Agent display (aspect)  Complex behaviors for the preys and predators  Adding of a stopping condition  Definition of charts  Writing files  Image loading (raster data)",
        "url":"/wiki/PredatorPrey.html"
      }
      ,
    
      "wiki-predatorprey-step1-html": {
        "title": "1. Basic Model",
        "content": "1. Basic ModelThis first step Illustrates how to write a model in GAMA. In particular, it describes how to structure a model and how to define species - that are the key components of GAMA models.ContentFormulation  Definition of the prey species  Definition of a nb_prey_init parameter  Creation of nb_prey_init prey agents randomly located in the environment (size: 100x100)Model Definitionmodel structureA GAMA model is composed of three type of sections:  global : this section, that is unique, defines the “world” agent, a special agent of a GAMA model. It represents all that is global to the model: dynamics, variables, actions. In addition, it allows to initialize the simulation (init block).  species and grid: these sections define the species of agents composing the model. Grid are defined in the following model step “vegetation dynamic”;  experiment : these sections define a context of execution of the simulations. In particular, it defines the input (parameters) and output (displays, files…) of a model.More details about the different sections of a GAMA model can be found here.speciesA species represents a «prototype» of agents: it defines their common properties.A species definition requires the definition of three different elements :  the internal state of its agents (attributes)  their behavior  how they are displayed (aspects)Internal stateAn attribute is defined as follows: type of the attribute  and name. Numerous types of attributes are available: int (integer), float (floating point number), string, bool (boolean, true or false), point (coordinates), list, pair, map, file, matrix, espèce d’agents, rgb (color), graph, path…  Optional facets: &lt;- (initial value), update (value recomputed at each step of the simulation), function:{..} (value computed each time the variable is used), min, maxIn addition to the attributes the modeler explicitly defines, species “inherits” other attributes called “built-in” variables:  A name (name): the identifier of the species  A shape (shape): the default shape of the agents to be construct after the species. It can be a point, a polygon, etc.  A location (location) : the centroid of its shape.BehaviorIn this first model, we define one species of agents: the prey agents. For the moment, these agents will not have a particular behavior, they will just exist and be displayed.DisplayAn agent aspects have to be defined. An aspect is a way to display the agents of a species : aspect aspect_name {…}In the block of an aspect, it is possible to draw :  A geometry :  for instance, the shape of the agent (but it may be a different one, for instance a disk instead of a complex polygon)  An image : to draw icons  A text : to draw a textIn order to display our prey agents we define two attributes:  size of type float, with for initial value: 1.0  color of type rgb, with for initial value: “blue”. It is possible to get a color value by using the symbol # + color name: e.g. #blue, #red, #white, #yellow, #magenta, #pink…Prey species codeFor the moment, we only define an aspect for this species. We want to display for each prey agent a circle of radius size and color color. We then use the keyword draw with a circle shape.species prey {\tfloat size &lt;- 1.0 ;\trgb color &lt;- #blue;\t\t\taspect base {\t\tdraw circle(size) color: color ;\t}} global sectionThe global section represents a specific agent, called world. Defining this agent follows the same principle as any agent and is, thus, defined after a species.The world agent represents everything that is global to the model : dynamics, variables…It allows to initialize simulations (init block): the world is always created and initialized first when a simulation is launched (before any other agents). The geometry (shape) of the world agent is by default a square with 100m for side size, but can be redefined if necessary (see the Road traffic tutorial).global variableIn the current model, we will only have a certain numbers of preys thus we need to hold this number in a global or world’s variable of type integer (int) which can be done as follows:global {   int nb_preys_init &lt;- 200;}Model initializationThe init section of the global block allows to initialize the model which is executing certain commands, here we will create nb_preys_init number of prey agents. We use the statement create  to create agents of a specific species: create species_name + :  number : number of agents to create (int, 1 by default)  from : GIS file to use to create the agents (optional, string or file)  returns: list of created agents (list)Definition of the init block in order to create nb_preys_init prey agents:   init {      create prey number: nb_preys_init ;   }experimentAn experiment block defines how a model can be simulated (executed). Several experiments can be defined for a given model. They are defined using : experiment exp_name type: gui/batch {[input] [output]}  gui : experiment with a graphical interface, which displays its input parameters and outputs.  batch : Allows to setup a series of simulations (w/o graphical interface).In our model, we define a gui experiment called prey_predator  :experiment prey_predator type: gui {}inputExperiments can define (input) parameters. A parameter definition allows to make the value of a global variable definable by the user through the graphic interface.A parameter is defined as follows:parameter title var: global_var category: cat;  title : string to display  var : reference to a global variable (defined in the global section)  category : string used to «store» the operators on the UI - optional  &lt;- : init value - optional  min : min value - optional  max : min value - optionalNote that the init, min and max values can be defined in the global variable definition.In the experiment, definition of a parameter from the the global variable nb_preys_init :experiment prey_predator type: gui {   parameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;}outputOutput blocks are defined in an experiment and define how to visualize a simulation (with one or more display blocks that define separate windows). Each display can be refreshed independently by defining the facet refresh_every: nb (int) (the display will be refreshed every nb steps of the simulation).Each display can include different layers (like in a GIS) :  Agents lists : agents layer_name value: agents_list aspect: my_aspect;  Agents species : species  my_species aspect: my_aspect  Images: image layer_name file: image_file;  Texts : texte layer_name value: my_text;  Charts : see later.Note that it is possible to define a opengl display (for 3D display) by using the facet type: opengl.In our model, we define a display to draw the prey agents. output {      display main_display {         species prey aspect: base ;      }   }Complete Modelmodel prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tinit {\t\tcreate prey number: nb_preys_init ;\t}}species prey {\tfloat size &lt;- 1.0 ;\trgb color &lt;- #blue;\t\t\taspect base {\t\tdraw circle(size) color: color ;\t}} experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;\toutput {\t\tdisplay main_display {\t\t\tspecies prey aspect: base ;\t\t}\t}}",
        "url":"/wiki/PredatorPrey_step1.html"
      }
      ,
    
      "wiki-predatorprey-step10-html": {
        "title": "10. Charts",
        "content": "10. ChartsThis 10th step Illustrates how to define charts.Formulation  Adding a new display to visualize:          One chart representing the evolution of the quantity of prey and predator agents over the time      Two histograms representing the energy distribution of the prey and predator agents      Model DefinitionoutputGAMA can display various chart types:  Time series  Pie charts  HistogramsA chart must be defined in a display : it behaves exactly like any other layer.Definition of a chart :chart chart_name type: chart_type  {     [data]}The data to draw are define inside the chart block as follow:    data data_legend value: data_valueWe add a new display called Population_information that refreshes every 5 simulation steps.Inside this display, we define 3 charts: one of type series (i.e. time series chart), two of type histogram :  “Species evolution”; background : white; size : {1, 0.5}; position : {0, 0}          data1: number_of_preys; color : blue      data2: number_of_predator; color : red        “Prey Energy Distribution”; background : lightGray; size : {0.5, 0.5}; position : {0, 0.5}          data “]0;0.25]” : number of preys with (each.energy &lt;= 0.25) ;      data “]0.25;0.5]” number of preys with ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) ;      data “]0.5;0.75]” number of preys with ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) ;      data “]0.75;1]” number of preys with  (each.energy &gt; 0.75) ;        “Predator Energy Distribution”; background : lightGray; size : {0.5, 0.5}; position : {0.5, 0.5}          data “]0;0.25]” : number of predators with (each.energy &lt;= 0.25) ;      data “]0.25;0.5]” number of predators with ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) ;      data “]0.5;0.75]” number of predators with ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) ;      data “]0.75;1]” number of predators with  (each.energy &gt; 0.75) ;      To evaluate the value of the data of the two histogram, we use the operator list count condition” that returns the number of elements oflistfor which the condition is true.display Population_information refresh:every(5) {\tchart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\t\tdata \"number_of_preys\" value: nb_preys color: #blue ;\t\tdata \"number_of_predator\" value: nb_predators color: #red ;\t}\tchart \"Prey Energy Distribution\" type: histogram background: rgb(\"white\") size: {0.5,0.5} position: {0, 0.5} {\t\tdata \"]0;0.25]\" value: prey count (each.energy &lt;= 0.25) color:#blue;\t\tdata \"]0.25;0.5]\" value: prey count ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) color:#blue;\t\tdata \"]0.5;0.75]\" value: prey count ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) color:#blue;\t\tdata \"]0.75;1]\" value: prey count (each.energy &gt; 0.75) color:#blue;\t}\tchart \"Predator Energy Distribution\" type: histogram background: rgb(\"white\") size: {0.5,0.5} position: {0.5, 0.5} {\t\tdata \"]0;0.25]\" value: predator count (each.energy &lt;= 0.25) color: #red ;\t\tdata \"]0.25;0.5]\" value: predator count ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) color: #red ;\t\tdata \"]0.5;0.75]\" value: predator count ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) color: #red ;\t\tdata \"]0.75;1]\" value: predator count (each.energy &gt; 0.75) color: #red;\t}}Complete Modelmodel prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tint nb_predators_init &lt;- 20;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfert &lt;- 0.1 ;\tfloat prey_energy_consum &lt;- 0.05;\tfloat predator_max_energy &lt;- 1.0;\tfloat predator_energy_transfert &lt;- 0.5;\tfloat predator_energy_consum &lt;- 0.02;\tfloat prey_proba_reproduce &lt;- 0.01;\tint prey_nb_max_offsprings &lt;- 5; \tfloat prey_energy_reproduce &lt;- 0.5; \tfloat predator_proba_reproduce &lt;- 0.01;\tint predator_nb_max_offsprings &lt;- 3;\tfloat predator_energy_reproduce &lt;- 0.5;\t\tint nb_preys -&gt; {length (prey)};\tint nb_predators -&gt; {length (predator)};\t\tinit {\t\tcreate prey number: nb_preys_init ; \t\tcreate predator number: nb_predators_init ;\t}\t\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\t\tdo halt ;\t} }species generic_species {\tfloat size &lt;- 1.0;\trgb color  ;\tfloat max_energy;\tfloat max_transfert;\tfloat energy_consum;\tfloat proba_reproduce ;\tfloat nb_max_offsprings;\tfloat energy_reproduce;\tfile my_icon;\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ;\tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\tinit {\t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move {\t\tmyCell &lt;- choose_cell();\t\tlocation &lt;- myCell.location; \t} \t\tvegetation_cell choose_cell {\t\treturn nil;\t}\t\t\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\t\treflex reproduce when: (energy &gt;= energy_reproduce) and (flip(proba_reproduce)) {\t\tint nb_offsprings &lt;- 1 + rnd(nb_max_offsprings -1);\t\tcreate species(self) number: nb_offsprings {\t\t\tmyCell &lt;- myself.myCell ;\t\t\tlocation &lt;- myCell.location ;\t\t\tenergy &lt;- myself.energy / nb_offsprings ;\t\t}\t\tenergy &lt;- energy / nb_offsprings ;\t}\t\taspect base {\t\tdraw circle(size) color: color ;\t}\taspect icon {\t\tdraw my_icon size: 2 * size ;\t}\taspect info {\t\tdraw square(size) color: color ;\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\t}}species prey parent: generic_species {\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfert &lt;- prey_max_transfert ;\tfloat energy_consum &lt;- prey_energy_consum ;\tfloat proba_reproduce &lt;- prey_proba_reproduce ;\tint nb_max_offsprings &lt;- prey_nb_max_offsprings ;\tfloat energy_reproduce &lt;- prey_energy_reproduce ;\tfile my_icon &lt;- file(\"../images/predator_prey_sheep.png\") ;\t\t\treflex eat when: myCell.food &gt; 0 {\t\tfloat energy_transfert &lt;- min([max_transfert, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfert ;\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\treturn (myCell.neighbours) with_max_of (each.food);\t}}\tspecies predator parent: generic_species {\trgb color &lt;- #red ;\tfloat max_energy &lt;- predator_max_energy ;\tfloat energy_transfert &lt;- predator_energy_transfert ;\tfloat energy_consum &lt;- predator_energy_consum ;\tlist&lt;prey&gt; reachable_preys update: prey inside (myCell);\tfloat proba_reproduce &lt;- predator_proba_reproduce ;\tint nb_max_offsprings &lt;- predator_nb_max_offsprings ;\tfloat energy_reproduce &lt;- predator_energy_reproduce ;\tfile my_icon &lt;- file(\"../images/predator_prey_wolf.png\") ;\t\treflex eat when: ! empty(reachable_preys) {\t\task one_of (reachable_preys) {\t\t\tdo die ;\t\t}\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\tvegetation_cell myCell_tmp &lt;- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\t\tif myCell_tmp != nil {\t\t\treturn myCell_tmp;\t\t} else {\t\t\treturn one_of (myCell.neighbours);\t\t} \t}}\tgrid vegetation_cell width: 50 height: 50 neighbours: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbours_at 2); }experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\t\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: icon ;\t\t\tspecies predator aspect: icon ;\t\t}\t\tdisplay info_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: info ;\t\t\tspecies predator aspect: info ;\t\t}\t\tdisplay Population_information refresh:every(5) {\t\t\tchart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\t\t\t\tdata \"number_of_preys\" value: nb_preys color: #blue ;\t\t\t\tdata \"number_of_predator\" value: nb_predators color: #red ;\t\t\t}\t\t\tchart \"Prey Energy Distribution\" type: histogram background: rgb(\"lightGray\") size: {0.5,0.5} position: {0, 0.5} {\t\t\t\tdata \"]0;0.25]\" value: prey count (each.energy &lt;= 0.25) color:#blue;\t\t\t\tdata \"]0.25;0.5]\" value: prey count ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) color:#blue;\t\t\t\tdata \"]0.5;0.75]\" value: prey count ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) color:#blue;\t\t\t\tdata \"]0.75;1]\" value: prey count (each.energy &gt; 0.75) color:#blue;\t\t\t}\t\t\tchart \"Predator Energy Distribution\" type: histogram background: rgb(\"lightGray\") size: {0.5,0.5} position: {0.5, 0.5} {\t\t\t\tdata \"]0;0.25]\" value: predator count (each.energy &lt;= 0.25) color: #red ;\t\t\t\tdata \"]0.25;0.5]\" value: predator count ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) color: #red ;\t\t\t\tdata \"]0.5;0.75]\" value: predator count ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) color: #red ;\t\t\t\tdata \"]0.75;1]\" value: predator count (each.energy &gt; 0.75) color: #red;\t\t\t}\t\t}\t\tmonitor \"Number of preys\" value: nb_preys;\t\tmonitor \"Number of predators\" value: nb_predators;\t}}",
        "url":"/wiki/PredatorPrey_step10.html"
      }
      ,
    
      "wiki-predatorprey-step11-html": {
        "title": "11. Writing Files",
        "content": "11. Writing FilesThis 11th step Illustrates how to save data in a text file.Formulation  At each simulation step, write in a text file:          The time step      The number of prey and predator agents      The min and max energy of the prey and predator agents      Model Definitionglobal sectionGAMA provides several ways to write file.A first ways consist in using the statement file in the output section: at each simulation step, the expression given is written in the given file.  file file_name type: file_type data: data_to_write;  With:  file_name: string (by default the file in saved in the /models/ of your project directory)  file_type: stringThere are 2 possible types :  ‘txt’ (text) : in that case, my_data is treated as a string, which is written directly in the file  ‘csv’ : in that case, my_data is treated as a list of variables to write : [“var1”, “var2”, “var3”].A second way to write file consists in using the save statement:  save my_data type: file_type to: file_name;  With:  file_type : string  file_name : stringThere are 3 possible types :  ‘shp’ (shapefile - GIS data) : in that case, my_data is treated as a list of agents : all their geometries are saved in the file (with some variables as attributes)  ‘txt’ (text) : in that case, my_data is treated as a string, which is written directly in the file  ‘csv’ : in that case, my_data is treated as a list of values : [val1, val2, val3].We use this statement (in a global reflex called save_result) to write:  The cycle step: use of the cycle keyword that returns the current simulation step.  The number of prey and predator agents: use of nb_preys and nb_predators variables  The min and max energy of the prey and predator agents: use of list min_of expression and list max_of expression keywords. In addition, we verify with the tertiary operator (condition ? val_if : val_else).    reflex save_result when: (nb_preys &gt; 0) and (nb_predators &gt; 0){save (\"cycle: \"+ cycle + \"; nbPreys: \" + nb_preys    + \"; minEnergyPreys: \" + ((prey as list) min_of each.energy)    + \"; maxSizePreys: \" + ((prey as list) max_of each.energy)    \t+ \"; nbPredators: \" + nb_predators              \t+ \"; minEnergyPredators: \" + ((predator as list) min_of each.energy)             \t+ \"; maxSizePredators: \" + ((predator as list) max_of each.energy))    \tto: \"results.txt\" type: \"text\" ;}      Complete Modelmodel prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tint nb_predators_init &lt;- 20;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfert &lt;- 0.1 ;\tfloat prey_energy_consum &lt;- 0.05;\tfloat predator_max_energy &lt;- 1.0;\tfloat predator_energy_transfert &lt;- 0.5;\tfloat predator_energy_consum &lt;- 0.02;\tfloat prey_proba_reproduce &lt;- 0.01;\tint prey_nb_max_offsprings &lt;- 5; \tfloat prey_energy_reproduce &lt;- 0.5; \tfloat predator_proba_reproduce &lt;- 0.01;\tint predator_nb_max_offsprings &lt;- 3;\tfloat predator_energy_reproduce &lt;- 0.5;\t\tint nb_preys -&gt; {length (prey)};\tint nb_predators -&gt; {length (predator)};\t\tinit {\t\tcreate prey number: nb_preys_init ; \t\tcreate predator number: nb_predators_init ;\t}\t\treflex save_result when: (nb_preys &gt; 0) and (nb_predators &gt; 0){\t\tsave (\"cycle: \"+ cycle + \"; nbPreys: \" + nb_preys\t\t\t+ \"; minEnergyPreys: \" + ((prey as list) min_of each.energy)\t\t\t+ \"; maxSizePreys: \" + ((prey as list) max_of each.energy) \t   \t\t+ \"; nbPredators: \" + nb_predators           \t   \t\t+ \"; minEnergyPredators: \" + ((predator as list) min_of each.energy)          \t   \t\t+ \"; maxSizePredators: \" + ((predator as list) max_of each.energy)) \t   \t\tto: \"results.txt\" type: \"text\" ;\t}\t\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\t\tdo halt ;\t} }species generic_species {\tfloat size &lt;- 1.0;\trgb color  ;\tfloat max_energy;\tfloat max_transfert;\tfloat energy_consum;\tfloat proba_reproduce ;\tfloat nb_max_offsprings;\tfloat energy_reproduce;\tfile my_icon;\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ;\tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\tinit {\t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move {\t\tmyCell &lt;- choose_cell();\t\tlocation &lt;- myCell.location; \t} \t\tvegetation_cell choose_cell {\t\treturn nil;\t}\t\t\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\t\treflex reproduce when: (energy &gt;= energy_reproduce) and (flip(proba_reproduce)) {\t\tint nb_offsprings &lt;- 1 + rnd(nb_max_offsprings -1);\t\tcreate species(self) number: nb_offsprings {\t\t\tmyCell &lt;- myself.myCell ;\t\t\tlocation &lt;- myCell.location ;\t\t\tenergy &lt;- myself.energy / nb_offsprings ;\t\t}\t\tenergy &lt;- energy / nb_offsprings ;\t}\t\taspect base {\t\tdraw circle(size) color: color ;\t}\taspect icon {\t\tdraw my_icon size: 2 * size ;\t}\taspect info {\t\tdraw square(size) color: color ;\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\t}}species prey parent: generic_species {\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfert &lt;- prey_max_transfert ;\tfloat energy_consum &lt;- prey_energy_consum ;\tfloat proba_reproduce &lt;- prey_proba_reproduce ;\tint nb_max_offsprings &lt;- prey_nb_max_offsprings ;\tfloat energy_reproduce &lt;- prey_energy_reproduce ;\tfile my_icon &lt;- file(\"../images/predator_prey_sheep.png\") ;\t\t\treflex eat when: myCell.food &gt; 0 {\t\tfloat energy_transfert &lt;- min([max_transfert, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfert ;\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\treturn (myCell.neighbours) with_max_of (each.food);\t}}\tspecies predator parent: generic_species {\trgb color &lt;- #red ;\tfloat max_energy &lt;- predator_max_energy ;\tfloat energy_transfert &lt;- predator_energy_transfert ;\tfloat energy_consum &lt;- predator_energy_consum ;\tlist&lt;prey&gt; reachable_preys update: prey inside (myCell);\tfloat proba_reproduce &lt;- predator_proba_reproduce ;\tint nb_max_offsprings &lt;- predator_nb_max_offsprings ;\tfloat energy_reproduce &lt;- predator_energy_reproduce ;\tfile my_icon &lt;- file(\"../images/predator_prey_wolf.png\") ;\t\treflex eat when: ! empty(reachable_preys) {\t\task one_of (reachable_preys) {\t\t\tdo die ;\t\t}\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\tvegetation_cell myCell_tmp &lt;- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\t\tif myCell_tmp != nil {\t\t\treturn myCell_tmp;\t\t} else {\t\t\treturn one_of (myCell.neighbours);\t\t} \t}}\tgrid vegetation_cell width: 50 height: 50 neighbours: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbours_at 2); }experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\t\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: icon ;\t\t\tspecies predator aspect: icon ;\t\t}\t\tdisplay info_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: info ;\t\t\tspecies predator aspect: info ;\t\t}\t\tdisplay Population_information refresh:every(5) {\t\t\tchart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\t\t\t\tdata \"number_of_preys\" value: nb_preys color: #blue ;\t\t\t\tdata \"number_of_predator\" value: nb_predators color: #red ;\t\t\t}\t\t\tchart \"Prey Energy Distribution\" type: histogram background: rgb(\"lightGray\") size: {0.5,0.5} position: {0, 0.5} {\t\t\t\tdata \"]0;0.25]\" value: prey count (each.energy &lt;= 0.25) color:#blue;\t\t\t\tdata \"]0.25;0.5]\" value: prey count ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) color:#blue;\t\t\t\tdata \"]0.5;0.75]\" value: prey count ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) color:#blue;\t\t\t\tdata \"]0.75;1]\" value: prey count (each.energy &gt; 0.75) color:#blue;\t\t\t}\t\t\tchart \"Predator Energy Distribution\" type: histogram background: rgb(\"lightGray\") size: {0.5,0.5} position: {0.5, 0.5} {\t\t\t\tdata \"]0;0.25]\" value: predator count (each.energy &lt;= 0.25) color: #red ;\t\t\t\tdata \"]0.25;0.5]\" value: predator count ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) color: #red ;\t\t\t\tdata \"]0.5;0.75]\" value: predator count ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) color: #red ;\t\t\t\tdata \"]0.75;1]\" value: predator count (each.energy &gt; 0.75) color: #red;\t\t\t}\t\t}\t\tmonitor \"Number of preys\" value: nb_preys;\t\tmonitor \"Number of predators\" value: nb_predators;\t}}",
        "url":"/wiki/PredatorPrey_step11.html"
      }
      ,
    
      "wiki-predatorprey-step12-html": {
        "title": "12. Image loading",
        "content": "12. Image loadingThis 12th step illustrates how to load an image file and to use it to initialize a grid.Formulation  Building of the initial environment (food and foodProd of the cells) from a image fileModel Definitionglobal variableWe add a new global variable: the image file:\tfile map_init &lt;- image_file(\"../images/predator_prey_raster_map.png\");The image file is here: You have to copy it in your project folder: images/model initializationIn order to have a more complex environment, we want to use this image as the initialization of the environment. The food level available in a vegetation_cell will be based on the green level of the corresponding pixel in the image. You will be able to use such process to represent existing real environment in your model.We modify the global init of the model in order to cast the image file in a matrix. We use for that the file as_matrix  {nb_cols, nb_lines} operator that allows to convert a file (image, csv) to a matrix composed of nb_cols columns and nb_lines lines.Concerning the manipulation of matrix, it is possible to obtain the element [i,j] of a matrix by using my_matrix [i,j].A  grid can be view as spatial matrix: each cell of a grid has two built-in variables grid_x and grid_y that represent the column and line indexes of the cell.  init {      create prey number: nb_preys_init ;      create predator number: nb_predators_init ;      matrix init_data &lt;- map_init as_matrix {50,50};      ask vegetation_cell {         color &lt;- rgb (init_data[grid_x,grid_y]) ;         food &lt;- 1 - ((color as list)[0] / 255) ;         foodProd &lt;- food / 100 ;      }   }ConclusionCongratulations, you have complete your first GAMA models! Now, you know have enough knowledge to create many models that includes: dynamic grid-based environment, moving and interacting agents and the needed viusalization to make good use of your simulation. Feel free to use this knowledge to create your very own models! Or perhaps you want to continue your study with the more advanced tutorials?Complete Modelmodel prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tint nb_predators_init &lt;- 20;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfert &lt;- 0.1 ;\tfloat prey_energy_consum &lt;- 0.05;\tfloat predator_max_energy &lt;- 1.0;\tfloat predator_energy_transfert &lt;- 0.5;\tfloat predator_energy_consum &lt;- 0.02;\tfloat prey_proba_reproduce &lt;- 0.01;\tint prey_nb_max_offsprings &lt;- 5; \tfloat prey_energy_reproduce &lt;- 0.5; \tfloat predator_proba_reproduce &lt;- 0.01;\tint predator_nb_max_offsprings &lt;- 3;\tfloat predator_energy_reproduce &lt;- 0.5;\tfile map_init &lt;- image_file(\"../images/predator_prey_raster_map.png\");\t\tint nb_preys -&gt; {length (prey)};\tint nb_predators -&gt; {length (predator)};\t\tinit {\t\tcreate prey number: nb_preys_init ; \t\tcreate predator number: nb_predators_init ;\t\task vegetation_cell {\t\t\tcolor &lt;- rgb (map_init at {grid_x,grid_y}) ;\t\t\tfood &lt;- 1 - (((color as list)[0]) / 255) ;\t\t\tfoodProd &lt;- food / 100 ; \t\t}\t}\t\treflex save_result when: (nb_preys &gt; 0) and (nb_predators &gt; 0){\t\tsave (\"cycle: \"+ cycle + \"; nbPreys: \" + nb_preys\t\t\t+ \"; minEnergyPreys: \" + ((prey as list) min_of each.energy)\t\t\t+ \"; maxSizePreys: \" + ((prey as list) max_of each.energy) \t   \t\t+ \"; nbPredators: \" + nb_predators           \t   \t\t+ \"; minEnergyPredators: \" + ((predator as list) min_of each.energy)          \t   \t\t+ \"; maxSizePredators: \" + ((predator as list) max_of each.energy)) \t   \t\tto: \"results.txt\" type: \"text\" ;\t}\t\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\t\tdo halt ;\t} }species generic_species {\tfloat size &lt;- 1.0;\trgb color  ;\tfloat max_energy;\tfloat max_transfert;\tfloat energy_consum;\tfloat proba_reproduce ;\tfloat nb_max_offsprings;\tfloat energy_reproduce;\tfile my_icon;\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ;\tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\tinit {\t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move {\t\tmyCell &lt;- choose_cell();\t\tlocation &lt;- myCell.location; \t} \t\tvegetation_cell choose_cell {\t\treturn nil;\t}\t\t\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\t\treflex reproduce when: (energy &gt;= energy_reproduce) and (flip(proba_reproduce)) {\t\tint nb_offsprings &lt;- 1 + rnd(nb_max_offsprings -1);\t\tcreate species(self) number: nb_offsprings {\t\t\tmyCell &lt;- myself.myCell ;\t\t\tlocation &lt;- myCell.location ;\t\t\tenergy &lt;- myself.energy / nb_offsprings ;\t\t}\t\tenergy &lt;- energy / nb_offsprings ;\t}\t\taspect base {\t\tdraw circle(size) color: color ;\t}\taspect icon {\t\tdraw my_icon size: 2 * size ;\t}\taspect info {\t\tdraw square(size) color: color ;\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\t}}species prey parent: generic_species {\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfert &lt;- prey_max_transfert ;\tfloat energy_consum &lt;- prey_energy_consum ;\tfloat proba_reproduce &lt;- prey_proba_reproduce ;\tint nb_max_offsprings &lt;- prey_nb_max_offsprings ;\tfloat energy_reproduce &lt;- prey_energy_reproduce ;\tfile my_icon &lt;- file(\"../images/predator_prey_sheep.png\") ;\t\t\treflex eat when: myCell.food &gt; 0 {\t\tfloat energy_transfert &lt;- min([max_transfert, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfert ;\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\treturn (myCell.neighbours) with_max_of (each.food);\t}}\tspecies predator parent: generic_species {\trgb color &lt;- #red ;\tfloat max_energy &lt;- predator_max_energy ;\tfloat energy_transfert &lt;- predator_energy_transfert ;\tfloat energy_consum &lt;- predator_energy_consum ;\tlist&lt;prey&gt; reachable_preys update: prey inside (myCell);\tfloat proba_reproduce &lt;- predator_proba_reproduce ;\tint nb_max_offsprings &lt;- predator_nb_max_offsprings ;\tfloat energy_reproduce &lt;- predator_energy_reproduce ;\tfile my_icon &lt;- file(\"../images/predator_prey_wolf.png\") ;\t\treflex eat when: ! empty(reachable_preys) {\t\task one_of (reachable_preys) {\t\t\tdo die ;\t\t}\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\tvegetation_cell myCell_tmp &lt;- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\t\tif myCell_tmp != nil {\t\t\treturn myCell_tmp;\t\t} else {\t\t\treturn one_of (myCell.neighbours);\t\t} \t}}\tgrid vegetation_cell width: 50 height: 50 neighbours: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbours_at 2); }experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\t\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: icon ;\t\t\tspecies predator aspect: icon ;\t\t}\t\tdisplay info_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: info ;\t\t\tspecies predator aspect: info ;\t\t}\t\tdisplay Population_information refresh:every(5) {\t\t\tchart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\t\t\t\tdata \"number_of_preys\" value: nb_preys color: #blue ;\t\t\t\tdata \"number_of_predator\" value: nb_predators color: #red ;\t\t\t}\t\t\tchart \"Prey Energy Distribution\" type: histogram background: rgb(\"lightGray\") size: {0.5,0.5} position: {0, 0.5} {\t\t\t\tdata \"]0;0.25]\" value: prey count (each.energy &lt;= 0.25) color:#blue;\t\t\t\tdata \"]0.25;0.5]\" value: prey count ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) color:#blue;\t\t\t\tdata \"]0.5;0.75]\" value: prey count ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) color:#blue;\t\t\t\tdata \"]0.75;1]\" value: prey count (each.energy &gt; 0.75) color:#blue;\t\t\t}\t\t\tchart \"Predator Energy Distribution\" type: histogram background: rgb(\"lightGray\") size: {0.5,0.5} position: {0.5, 0.5} {\t\t\t\tdata \"]0;0.25]\" value: predator count (each.energy &lt;= 0.25) color: #red ;\t\t\t\tdata \"]0.25;0.5]\" value: predator count ((each.energy &gt; 0.25) and (each.energy &lt;= 0.5)) color: #red ;\t\t\t\tdata \"]0.5;0.75]\" value: predator count ((each.energy &gt; 0.5) and (each.energy &lt;= 0.75)) color: #red ;\t\t\t\tdata \"]0.75;1]\" value: predator count (each.energy &gt; 0.75) color: #red;\t\t\t}\t\t}\t\tmonitor \"Number of preys\" value: nb_preys;\t\tmonitor \"Number of predators\" value: nb_predators;\t}}",
        "url":"/wiki/PredatorPrey_step12.html"
      }
      ,
    
      "wiki-predatorprey-step2-html": {
        "title": "2. Vegetation Dynamic",
        "content": "[IN PROGRESS]2. Vegetation DynamicThis second steps present the idea of environment or topological space. Defining a “vegetation” environment allows to define the movement of the preys through dynamic variables (use of the update facet). We will also discover more about displays.Formulation  Definition of a grid (for the vegetation)  Definition of a dynamic for each cell (food production)  Display of the cell color according to the quantity of food  Localization of the prey agents on the cells (at its center)Model DefinitiongridIn GAMA, grids are specific agent species with a particular topology. First, a grid allow yet constrains the movement of other (moving) agents but they can have variables and behaviors.A grid is defined as follows:   grid grid_name width: nb_cols height: nb_lines neighbors: 4/6/8 {      ...   }With:  width : number of cells along x-axis  height : number of cells along y-axis  neighbours : neighborhood type (4 - Von Neumann, 6 - hexagon or 8 - Moore)In our model, we define a grid species, called vegetation_cell composed of 50x50 cells and with a Von Neumann neighborhood.In order for each grid agents (or cell of the grid) to represent the vegetation, we provide them with four variables:  maxFood : maximum food that a cell can contain -&gt; type: float ; init value: 1.0  foodProd : food produced at each simulation step -&gt; type: float ; init value: random number between 0 and 0.01  food : current quantity of food -&gt; type: float ; init value: random number between 0 and 1.0; at each simulation step : food &lt;- food + foodProd  color : color of the cell -&gt; type: rgb ; init value: color computed according to the food value: more the food value is close to 1.0, greener the color is, more the food value is close to 0,  whiter the color is; update : computation of the new color depending on the current level of food (at each simulation step).The update facet allows to give a behavior to the agents. Indeed, at each simulation step, each agent is activated (by default, in a random order) and first applies for each dynamic variable (in their definition order) its update expression. In the present case, it allows us to link the displayed color of the cell to its food level.   grid vegetation_cell width: 50 height: 50 neighbours: 4 {      float maxFood &lt;- 1.0 ;      float foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;      float food &lt;- (rnd(1000) / 1000) update: food + foodProd max: maxFood;      rgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) ;   }There are several ways to define colors in GAML:  the simplest way consists in using the symbol # + the color name (for a limited set of  colors):       #blue   #red        Another way consists in defining the 3 rgb integer values: rgb(red, green, blue) with red, green and blue between 0 and 255 (as we used in the current model.       rgb(0,0,0) : black ; rgb(255,255,255) : white   rgb(255,0,0) : red ;  rgb(0,255,0) : green ;  rgb(0,0,255) : blue      prey agentsIn order to relate our prey agents to the vegetation cell grid, we add them with one new variable : my_cell of type vegetation_cell and for init value one of the vegetation_cell (chosen randomly).   species prey {      ...      vegetation_cell myCell &lt;- one_of (vegetation_cell) ;   } It is possible to obtain the list of all agents of a given species by using the name of the species while one_of to pick one element randomly from this list.We linked each prey agent to a vegetation_cell but we need to locate them onto the cell. To do so, we set the prey location as equals to the location of the vegetation cell (i.e. its centroid location), we use in the init block the &lt;- statement that allows to modify the value of a variable :species prey {     ...     init {         location &lt;- myCell.location;     }}displayIn order to visualize the vegetation , we need to add it to the display. We use for that the statement grid with the optional facet lines to draw the border of the cells. Note that grid agents have built-in aspect thus it is not necessary to define one.   output {      display main_display {         grid vegetation_cell lines: #black;         species prey aspect: base ;      }   }Note that the layers in a display work like layers in a GIS; the drawing order will be respected. In our model, the prey agents will be drawn above the vegetation_cell grid thus they need to be declared afterward.Complete Modelmodel prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tinit {\t\tcreate prey number: nb_preys_init ;\t}}species prey {\tfloat size &lt;- 1.0 ;\trgb color &lt;- #blue;\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ;\t\t\tinit {\t\tlocation &lt;- myCell.location;\t}\t\t\taspect base {\t\tdraw circle(size) color: color ;\t}}grid vegetation_cell width: 50 height: 50 neighbours: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;}experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: base ;\t\t}\t}}",
        "url":"/wiki/PredatorPrey_step2.html"
      }
      ,
    
      "wiki-predatorprey-step3-html": {
        "title": "3. Prey Agent Behavior",
        "content": "3. Prey Agent BehaviorThis third step Illustrates how to define the behaviors of prey agents and the concept of spatial topology.Formulation  Random movement of the prey agents to a distance of 2 cells (Von Neumann neighborhood)  At each step, the prey agents loss energy  At each step, the prey agents eat food if there is food on the cell on which they are localized (with a max of max_transfer) and gain energy  If a prey agent has no more energy, it diesModel DefinitionparametersTo define a behavior for the prey agents we add them three new parameters:  The max energy of the prey agents  The maximum energy that can a prey agent consume from vegetation per tick  The energy used by a prey agent at each time stepAs we consider these parameters to be global to all prey, we define them in the  global section as follows:   float prey_max_energy &lt;- 1.0;   float prey_max_transfer &lt;- 0.1;   float prey_energy_consum &lt;- 0.05;   Yet we may allow the user to change it from an experiment to another through the user interface. To do so we add the following definition of parameters within the experiment section :   parameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;   parameter \"Prey max transfer: \" var: prey_max_transfer  category: \"Prey\" ;   parameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;vegetation_cell gridWe add a new variable for the vegetation_cell grid called neighbours, that contains for each vegetation cell the list of the neighbor vegetation cells (distance of 2 - Von Neumann neighborhood). We will use these neighbors list for the movement of the prey.  grid vegetation_cell width: 50 height: 50 neighbours: 4 {      ...      list&lt;vegetation_cell&gt; neighbours &lt;- self neighbours_at 2;   }Note that the result of the operator neighbours_at dist depends on the type of topology of the agent applying this operator:  For a grid topology (grid species), the operator returns the neighbor cells (with a Von Neumann or Moore neighborhood).  For a continuous topology, the operator returns the list of agents of which the shape is located at a distance equals or inferior dist meters to the agent shape.Also note the use of the self pseudo variable which is a reference to the agent currently executing the statementPrey agentsWe copy the values of the three global parameters into the prey species in order for it to be available for each agent and possibly modified locally.species prey {   ...   float max_energy &lt;- prey_max_energy ;   float max_transfer &lt;- prey_max_transfer ;   float energy_consum &lt;- prey_energy_consum ;   ...}\t\tThe energy used by each prey at each timestep is randomly computed initially (within ]0;max_energy]).species prey {   ...   float energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;   ...}    In order to define the movement behaviour of a prey we will add a reflex. A reflex is a block of statements (that can be defined in global or any species) that will be automatically executed at each simulation step if its condition is true, it is defined as follows:   reflex reflex_name when: condition {...}The when facet is optional: when it is omitted, the reflex is activated at each time step. Note that if several reflexes are defined for a species, the reflexes will be activated following their definition order.We define a first reflex called basic_move that allows the prey agents to choose (randomly) a new vegetation_cell in the neighborhood of my_cell and to move to this cell.species prey {   ...   reflex basic_move {        myCell &lt;- one_of (myCell.neighbours) ;       location &lt;- myCell.location ;   }}We define a second reflex called eat that will only be activated when there is food in my_cell and that will allows the prey agents to eat food and gain energy. In order to store the energy gain by the eating (that is equals to the minimum between the max_transfer value and the quantity of food available in myCell), we define a local variable called energy_transfer.  A local variable is a variable that will only exist within this block: once it has been executed, the variable is forgotten. To define it, we have to use the following statement:var_type var_name &lt;- value; Thus, the reflex eat is defined by:species prey {   ...   reflex eat when: myCell.food &gt; 0 {       float energy_transfer &lt;- min([max_transfer, myCell.food]) ;      myCell.food &lt;- myCell.food - energy_transfer ;      energy &lt;- energy + energy_transfer ;   }}We define a third reflex for the prey agent: when the agent has no more energy, it dies (application of the built-in die action):species prey {   ...   reflex die when: energy &lt;= 0 {      do die ;   }}Note that an action is a capability available to the agents of a species (what they can do). It is a block of statements that can be used and reused whenever needed. Some actions, called primitives, are directly coded in Java: for instance, the die action defined for all the agents.  An action can accept arguments. For instance, write takes an argument called message.  An action can return a result.There are two ways to call an action: using a statement or as part of an expression  for actions that do not return a result:    do action_name arg1: v1 arg2: v2;        for actions that return a result:    my_var &lt;- self action_name (arg1:v1, arg2:v2);      Complete Modelmodel prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfer &lt;- 0.1;\tfloat prey_energy_consum &lt;- 0.05;\t\tinit {\t\tcreate prey number: nb_preys_init ;\t}}species prey {\tfloat size &lt;- 1.0 ;\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfer &lt;- prey_max_transfer ;\tfloat energy_consum &lt;- prey_energy_consum ;\t\t\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ; \tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\t\tinit { \t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move { \t\tmyCell &lt;- one_of (myCell.neighbours) ;\t\tlocation &lt;- myCell.location ;\t}\treflex eat when: myCell.food &gt; 0 { \t\tfloat energy_transfer &lt;- min([max_transfer, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfer ;\t\tenergy &lt;- energy + energy_transfer ;\t}\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\taspect base {\t\tdraw circle(size) color: color ;\t}}grid vegetation_cell width: 50 height: 50 neighbours: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbours_at 2);}experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfer: \" var: prey_max_transfer  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: base ;\t\t}\t}}",
        "url":"/wiki/PredatorPrey_step3.html"
      }
      ,
    
      "wiki-predatorprey-step4-html": {
        "title": "4. Inspectors and Monitors",
        "content": "4. Inspectors and MonitorsThis fourth step Illustrates how to monitor more precisely the simulation. Practically, we will define monitors to follow the evolution of specific variables (or expression) whereas inspector allows to follow the state of a given agent (or a species).Formulation  Adding of a monitor to follow the evolution of the number of prey agentsModel Definitionglobal variableWe add a new global variable:  nb_preys : returns, each time it is called, the current number of (live) prey agentsTo do so we use the -&gt;{expression} facet which returns the value of expression, each time it is called..We use as well the operator length that returns the number of elements in a list.Thus, In the global section, we add the nb_preys global variable:   int nb_preys -&gt; {length (prey)};monitorA monitor allows to follow the value of an arbitrary expression in GAML. It has to be defined in an output section. A monitor is defined as follows:      monitor monitor_name value: an_expression refresh:every(nb_steps);With:  value: mandatory, its that value will be displayed in the monitor.  refresh: bool, optional : if the expression is true, compute (default is true).In this model, we define a monitor to follow the value of the variable nb_preys:      monitor \"number of preys\" value: nb_preys;inspectorInspectors allow to obtain informations about a species or an agent. There are two kinds of agent information features:  Species browser: provides informations about all the agents of a species. Available in the Agents menu.  Agent inspector: provides information about one specific agent. Also allows to change the values of its variables during the simulation. Available from the Agents menu, by right_clicking on a display, in the species inspector or when inspecting another agent. It provides also the possibility to «highlight» the inspected agent.Complete Modelmodel prey_predatorglobal {\tint nb_preys_init &lt;- 200 ;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfert &lt;- 0.1;\tfloat prey_energy_consum &lt;- 0.05;\tint nb_preys -&gt; {length (prey)};\t\tinit {\t\tcreate prey number: nb_preys_init ;\t}}species prey {\tfloat size &lt;- 1.0 ;\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfert &lt;- prey_max_transfert ;\tfloat energy_consum &lt;- prey_energy_consum ;\t\t\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ; \tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\t\tinit { \t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move { \t\tmyCell &lt;- one_of (myCell.neighbours) ;\t\tlocation &lt;- myCell.location ;\t}\treflex eat when: myCell.food &gt; 0 { \t\tfloat energy_transfert &lt;- min([max_transfert, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfert ;\t\tenergy &lt;- energy + energy_transfert ;\t}\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\taspect base {\t\tdraw circle(size) color: color ;\t}}grid vegetation_cell width: 50 height: 50 neighbours: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbours_at 2);}experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: base ;\t\t}\t\tmonitor \"Number of preys\" value: nb_preys ;\t}}",
        "url":"/wiki/PredatorPrey_step4.html"
      }
      ,
    
      "wiki-predatorprey-step5-html": {
        "title": "5. Predator Agent",
        "content": "5. Predator AgentThis fifth step Illustrates how to use parent species. Indeed,prey and predators share a few common features thus we will define a generic species that will regroup all the common elements (variables, behaviors and aspects) between the prey and the predator species.Formulation  Definition of a new generic species: generic_species  Definition of a new species: predator  predator agents move randomly  At each simulation step, a predator agent can eat a prey that is localized at its grid cellModel DefinitionparametersWe add four new parameters related to predator agents:  The init number of predator agents  The max energy of the predator agents  The energy gained by a predator agent while eating a prey agent  The energy consumed by a predator agent at each time stepWe define four new global variables in the global section:global {   ...   int nb_predators_init &lt;- 20;   float predator_max_energy &lt;- 1.0;   float predator_energy_transfer &lt;- 0.5;   float predator_energy_consum &lt;- 0.02;}We define then the four corresponding parameters in the experiment:   parameter \"Initial number of predators: \" var: nb_predators_init min: 0 max: 200 category: \"Predator\" ;   parameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;   parameter \"Predator energy transfer: \" var: predator_energy_transfer  category: \"Predator\" ;   parameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;parent speciesA species can have a parent species: it automatically get all the variables, skill and actions/reflex of the parent speciesWe define a species called generic_species that is the parent of the species prey and predator:This species integrates all of the common feature between the prey and predotor species:  the variables:          size      color      max_energy      max_transfer      energy_consum      myCell      energy        the behaviors:          basic_move reflex      die reflex        the aspect:          base aspect      species generic_species {\tfloat size &lt;- 1.0;\trgb color  ;\tfloat max_energy;\tfloat max_transfer;\tfloat energy_consum;\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ;\tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\tinit {\t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move {\t\tmyCell &lt;- one_of (myCell.neighbours) ;\t\tlocation &lt;- myCell.location ;\t}\t\t\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\t\taspect base {\t\tdraw circle(size) color: color ;\t}}prey speciesWe specialize the prey species from the generic_species species:  definition of the initial value of the agent variables  definition of the eat reflexspecies prey parent: generic_species {\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfer &lt;- prey_max_transfer ;\tfloat energy_consum &lt;- prey_energy_consum ;\t\t\treflex eat when: myCell.food &gt; 0 {\t\tfloat energy_transfer &lt;- min([max_transfer, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfer ;\t\tenergy &lt;- energy + energy_transfer ;\t}}predator speciesAs done for the prey species, we specialize the predator species from the generic_species species:  definition of the initial value of the agent variables  definition of a new variable reachable_preys consisting in the list of prey agents contains in myCell; compute at each simulation step (when the agent is activated).  definition of the eat reflex: activated when reachable_preys is not empty; choose one of the element of this list, ask it to die; and update the predator energy.species predator parent: generic_species {\trgb color &lt;- #red ;\tfloat max_energy &lt;- predator_max_energy ;\tfloat energy_transfer &lt;- predator_energy_transfer ;\tfloat energy_consum &lt;- predator_energy_consum ;\tlist&lt;prey&gt; reachable_preys update: prey inside (myCell);\t\t\treflex eat when: ! empty(reachable_preys) {\t\task one_of (reachable_preys) {\t\t\tdo die ;\t\t}\t\tenergy &lt;- energy + energy_transfer ;\t}}Note that we used the ask statement. This statement allows to make a remote agent executes a list of statements.Use of the ask statement as follows:ask one_agent or ask agents_listWe used as well the species/agent list inside geometry/agent operator. This operator returns all the agents of the specified species (or from the specified agent list) that are inside the given geometry or agent geometry.global init blockLike in the previous model, in the init block of the model, we create nb_predators_init.global {   ...   init {      create prey number: nb_preys_init ;      create predator number: nb_predators_init ;   }}monitorLike in the previous model, we define a monitor to display the number of predator agents.Definition of a global variable nb_predator that returns the current number of predator agents:global {   ...   int nb_predators -&gt; {length (predator)};   ...}Definition of the corresponding monitor:monitor \"number of predators\" value: nb_predators ;Complete Modelmodel prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tint nb_predators_init &lt;- 20;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfer &lt;- 0.1 ;\tfloat prey_energy_consum &lt;- 0.05;\tfloat predator_max_energy &lt;- 1.0;\tfloat predator_energy_transfer &lt;- 0.5;\tfloat predator_energy_consum &lt;- 0.02;\tint nb_preys -&gt; {length (prey)};\tint nb_predators -&gt; {length (predator)};\t\tinit {\t\tcreate prey number: nb_preys_init ; \t\tcreate predator number: nb_predators_init ;\t}}species generic_species {\tfloat size &lt;- 1.0;\trgb color  ;\tfloat max_energy;\tfloat max_transfer;\tfloat energy_consum;\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ;\tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\tinit {\t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move {\t\tmyCell &lt;- one_of (myCell.neighbours) ;\t\tlocation &lt;- myCell.location ;\t}\t\t\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\t\taspect base {\t\tdraw circle(size) color: color ;\t}}species prey parent: generic_species {\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfer &lt;- prey_max_transfer ;\tfloat energy_consum &lt;- prey_energy_consum ;\t\t\treflex eat when: myCell.food &gt; 0 {\t\tfloat energy_transfer &lt;- min([max_transfer, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfer ;\t\tenergy &lt;- energy + energy_transfer ;\t}}\tspecies predator parent: generic_species {\trgb color &lt;- #red ;\tfloat max_energy &lt;- predator_max_energy ;\tfloat energy_transfer &lt;- predator_energy_transfer ;\tfloat energy_consum &lt;- predator_energy_consum ;\tlist&lt;prey&gt; reachable_preys update: prey inside (myCell);\t\t\treflex eat when: ! empty(reachable_preys) {\t\task one_of (reachable_preys) {\t\t\tdo die ;\t\t}\t\tenergy &lt;- energy + energy_transfer ;\t}}\tgrid vegetation_cell width: 50 height: 50 neighbours: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food)));\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbours_at 2); }experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfer: \" var: prey_max_transfer  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\tparameter \"Predator energy transfer: \" var: predator_energy_transfer  category: \"Predator\" ;\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\t\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: base ;\t\t\tspecies predator aspect: base ;\t\t}\t\tmonitor \"Number of preys\" value: nb_preys;\t\tmonitor \"Number of predators\" value: nb_predators;\t}}",
        "url":"/wiki/PredatorPrey_step5.html"
      }
      ,
    
      "wiki-predatorprey-step6-html": {
        "title": "6. Breeding",
        "content": "6. BreedingSo far we created agents only during the initialisation of the simulation. In this sixth step we Illustrate how to create new agents during a simulation of a dynamic species.Formulation  Adding of a reproduce action of the prey and predator agents:          When a agent has energy enough, it has a certain probability to have a certain number of offspring      The energy of the offspring is equal to the parent energy divided by the number of offspring      The parent get the same energy as its offspring      Model DefinitionparametersWe add six new parameters related to breeding:  The reproduction probability for prey agents  The max number of offspring for prey agents  The minimum energy to reproduce for prey agents  The reproduction probability for predator agents  The max number of offspring for predator agents  The minimum energy to reproduce for predator agentsWe define six new global variables in the global section:global {   ...   float prey_proba_reproduce &lt;- 0.01;   int prey_nb_max_offsprings &lt;- 5;    float prey_energy_reproduce &lt;- 0.5;    float predator_proba_reproduce &lt;- 0.01;   int predator_nb_max_offsprings &lt;- 3;   float predator_energy_reproduce &lt;- 0.5;}We define then the six corresponding parameters in the experiment:   parameter \"Prey probability reproduce: \" var: prey_proba_reproduce category: \"Prey\" ;   parameter \"Prey nb max offsprings: \" var: prey_nb_max_offsprings category: \"Prey\" ;   parameter \"Prey energy reproduce: \" var: prey_energy_reproduce category: \"Prey\" ;   parameter \"Predator probability reproduce: \" var: predator_proba_reproduce category: \"Predator\" ;   parameter \"Predator nb max offsprings: \" var: predator_nb_max_offsprings category: \"Predator\" ;   parameter \"Predator energy reproduce: \" var: predator_energy_reproduce category: \"Predator\" ;parent speciesWe add three new variables for the generic_species:  proba_reproduce  nb_max_offsprings  energy_reproduceWe add as well a new reflex called reproduce:  this reflex is activated only when:          the energy of the agent is greater or equals to energy_reproduce      AND according to the probability proba_reproduce: for this second condition, we use the flip(proba) operator that returns true according to the probability proba (false otherwise).        this reflex creates nb_offsprings (random number between 1 and nb_max_offsprings) new agent of species the species of the agent using the create statement: we use a species casting operator on the current agent.          the created agents are initialized as follows:                  myCell: myCell of the agent creating the agents          location: location of myCell          energy: energy of the agent creating the agents (use of keyword myself) divided by the number of offsprings.                      after the agent creation, the reflex updates the energy value of the current agent with the value: energy / nb_offsprings   species generic_species {      ...      float proba_reproduce ;      int nb_max_offsprings;      float energy_reproduce;      ...       reflex reproduce when: (energy &gt;= energy_reproduce) and (flip(proba_reproduce)) {         int nb_offsprings &lt;- 1 + rnd(nb_max_offsprings -1);         create species(self) number: nb_offsprings {            myCell &lt;- myself.myCell ;            location &lt;- myCell.location ;            energy &lt;- myself.energy / nb_offsprings ;         }         energy &lt;- energy / nb_offsprings ;      }   }Note that two keywords can be used to make explicit references to some agents :  The agent that is currently executing the statements inside the block (for example a newly created agent): self  The agent that is executing the statement that contains this block (for instance, the agent that has called the create statement): myselfprey speciesWe specialize the prey species from the generic_species species:  definition of the initial value of the agent variables   species prey parent: generic_species {      ...      float proba_reproduce &lt;- prey_proba_reproduce ;      int nb_max_offsprings &lt;- prey_nb_max_offsprings ;      float energy_reproduce &lt;- prey_energy_reproduce ;      ...   }predator speciesAs done for the prey species, we specialize the predator species from the generic_species species:  definition of the initial value of the agent variables   species predator parent: generic_species {      ...      float proba_reproduce &lt;- predator_proba_reproduce ;      int nb_max_offsprings &lt;- predator_nb_max_offsprings ;      float energy_reproduce &lt;- predator_energy_reproduce ;      ...   }Complete Modelmodel prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tint nb_predators_init &lt;- 20;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfert &lt;- 0.1 ;\tfloat prey_energy_consum &lt;- 0.05;\tfloat predator_max_energy &lt;- 1.0;\tfloat predator_energy_transfert &lt;- 0.5;\tfloat predator_energy_consum &lt;- 0.02;\tfloat prey_proba_reproduce &lt;- 0.01;\tint prey_nb_max_offsprings &lt;- 5; \tfloat prey_energy_reproduce &lt;- 0.5; \tfloat predator_proba_reproduce &lt;- 0.01;\tint predator_nb_max_offsprings &lt;- 3;\tfloat predator_energy_reproduce &lt;- 0.5;\t\tint nb_preys -&gt; {length (prey)};\tint nb_predators -&gt; {length (predator)};\t\tinit {\t\tcreate prey number: nb_preys_init ; \t\tcreate predator number: nb_predators_init ;\t}}species generic_species {\tfloat size &lt;- 1.0;\trgb color  ;\tfloat max_energy;\tfloat max_transfert;\tfloat energy_consum;\tfloat proba_reproduce ;\tint nb_max_offsprings;\tfloat energy_reproduce;\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ;\tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\tinit {\t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move {\t\tmyCell &lt;- one_of (myCell.neighbours) ;\t\tlocation &lt;- myCell.location ;\t}\t\t\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\t\treflex reproduce when: (energy &gt;= energy_reproduce) and (flip(proba_reproduce)) {\t\tint nb_offsprings &lt;- 1 + rnd(nb_max_offsprings -1);\t\tcreate species(self) number: nb_offsprings {\t\t\tmyCell &lt;- myself.myCell ;\t\t\tlocation &lt;- myCell.location ;\t\t\tenergy &lt;- myself.energy / nb_offsprings ;\t\t}\t\tenergy &lt;- energy / nb_offsprings ;\t}\t\taspect base {\t\tdraw circle(size) color: color ;\t}}species prey parent: generic_species {\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfert &lt;- prey_max_transfert ;\tfloat energy_consum &lt;- prey_energy_consum ;\tfloat proba_reproduce &lt;- prey_proba_reproduce ;\tint nb_max_offsprings &lt;- prey_nb_max_offsprings ;\tfloat energy_reproduce &lt;- prey_energy_reproduce ;\t\t\treflex eat when: myCell.food &gt; 0 {\t\tfloat energy_transfert &lt;- min([max_transfert, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfert ;\t\tenergy &lt;- energy + energy_transfert ;\t}}\tspecies predator parent: generic_species {\trgb color &lt;- #red ;\tfloat max_energy &lt;- predator_max_energy ;\tfloat energy_transfert &lt;- predator_energy_transfert ;\tfloat energy_consum &lt;- predator_energy_consum ;\tlist&lt;prey&gt; reachable_preys update: prey inside (myCell);\tfloat proba_reproduce &lt;- predator_proba_reproduce ;\tint nb_max_offsprings &lt;- predator_nb_max_offsprings ;\tfloat energy_reproduce &lt;- predator_energy_reproduce ;\t\t\treflex eat when: ! empty(reachable_preys) {\t\task one_of (reachable_preys) {\t\t\tdo die ;\t\t}\t\tenergy &lt;- energy + energy_transfert ;\t}}\tgrid vegetation_cell width: 50 height: 50 neighbours: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food)));\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbours_at 2); }experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\t\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: base ;\t\t\tspecies predator aspect: base ;\t\t}\t\tmonitor \"Number of preys\" value: nb_preys;\t\tmonitor \"Number of predators\" value: nb_predators;\t}}",
        "url":"/wiki/PredatorPrey_step6.html"
      }
      ,
    
      "wiki-predatorprey-step7-html": {
        "title": "7. Agent Aspect",
        "content": "7. Agent AspectIn this seventh step we will focus on the display and more specifically the aspects of the agents: how they are represented. It can be a simple shape (circle, square, etc.), an icon, a polygon (see later GIS support).Formulation  Definition of two new aspects for the prey and predator agents:          A icon      A square with information about the agent energy        Use of the icon aspect as default aspect for the prey and predator agents.Model Definitionparent speciesWe add a new variable of type file called my_icon to the generic_species.We define as well two new aspects:  icon : draw the image given by the variable icon  info : draw a square of side size size and color color; draw as a text the energy of the agent (with a precision of 2)   species generic_species {      ...      file my_icon;      ...      aspect base {         draw circle(size) color: color ;      }      aspect icon {         draw my_icon size: 2 * size ;      }      aspect info {         draw square(size) color: color ;         draw string(energy with_precision 2) size: 3 color: #black ;      }   }prey speciesWe specialize the prey species from the generic_species species:  definition of the initial value of the agent variables       species prey parent: generic_species {  ...    file my_icon &lt;- file(\"../images/predator_prey_sheep.png\") ;  ...   }      The image file is here: You have to copy it in your project folder: images/predator speciesAs done for the prey species, we specialize the predator species from the generic_species species:  definition of the initial value of the agent variables   species predator parent: generic_species {      ...      file my_icon &lt;- file(\"../images/predator_prey_wolf.png\") ;      ...   }The image file is here: You have to copy it in your project folder: imagesdisplayWe change the default aspect of the prey and predator agents to icon aspect.   output {      display main_display {         grid vegetation_cell lines: #black ;         species prey aspect: icon ;         species predator aspect: icon ;      }   }We define a new display called info_display that displays the prey and predator agents with the info aspect.   output {      display info_display {         species prey aspect: info;         species predator aspect: info;      }   }Complete Modelmodel prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tint nb_predators_init &lt;- 20;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfert &lt;- 0.1 ;\tfloat prey_energy_consum &lt;- 0.05;\tfloat predator_max_energy &lt;- 1.0;\tfloat predator_energy_transfert &lt;- 0.5;\tfloat predator_energy_consum &lt;- 0.02;\tfloat prey_proba_reproduce &lt;- 0.01;\tint prey_nb_max_offsprings &lt;- 5; \tfloat prey_energy_reproduce &lt;- 0.5; \tfloat predator_proba_reproduce &lt;- 0.01;\tint predator_nb_max_offsprings &lt;- 3;\tfloat predator_energy_reproduce &lt;- 0.5;\t\tint nb_preys -&gt; {length (prey)};\tint nb_predators -&gt; {length (predator)};\t\tinit {\t\tcreate prey number: nb_preys_init ; \t\tcreate predator number: nb_predators_init ;\t}}species generic_species {\tfloat size &lt;- 1.0;\trgb color  ;\tfloat max_energy;\tfloat max_transfert;\tfloat energy_consum;\tfloat proba_reproduce ;\tfloat nb_max_offsprings;\tfloat energy_reproduce;\tfile my_icon;\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ;\tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\tinit {\t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move {\t\tmyCell &lt;- one_of (myCell.neighbours) ;\t\tlocation &lt;- myCell.location ;\t}\t\t\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\t\treflex reproduce when: (energy &gt;= energy_reproduce) and (flip(proba_reproduce)) {\t\tint nb_offsprings &lt;- 1 + rnd(nb_max_offsprings -1);\t\tcreate species(self) number: nb_offsprings {\t\t\tmyCell &lt;- myself.myCell ;\t\t\tlocation &lt;- myCell.location ;\t\t\tenergy &lt;- myself.energy / nb_offsprings ;\t\t}\t\tenergy &lt;- energy / nb_offsprings ;\t}\t\taspect base {\t\tdraw circle(size) color: color ;\t}\taspect icon {\t\tdraw my_icon size: 2 * size ;\t}\taspect info {\t\tdraw square(size) color: color ;\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\t}}species prey parent: generic_species {\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfert &lt;- prey_max_transfert ;\tfloat energy_consum &lt;- prey_energy_consum ;\tfloat proba_reproduce &lt;- prey_proba_reproduce ;\tint nb_max_offsprings &lt;- prey_nb_max_offsprings ;\tfloat energy_reproduce &lt;- prey_energy_reproduce ;\tfile my_icon &lt;- file(\"../images/predator_prey_sheep.png\") ;\t\t\treflex eat when: myCell.food &gt; 0 {\t\tfloat energy_transfert &lt;- min([max_transfert, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfert ;\t\tenergy &lt;- energy + energy_transfert ;\t}}\tspecies predator parent: generic_species {\trgb color &lt;- #red ;\tfloat max_energy &lt;- predator_max_energy ;\tfloat energy_transfert &lt;- predator_energy_transfert ;\tfloat energy_consum &lt;- predator_energy_consum ;\tlist&lt;prey&gt; reachable_preys update: prey inside (myCell);\tfloat proba_reproduce &lt;- predator_proba_reproduce ;\tint nb_max_offsprings &lt;- predator_nb_max_offsprings ;\tfloat energy_reproduce &lt;- predator_energy_reproduce ;        file my_icon &lt;- file(\"../images/predator_prey_wolf.png\") ;\t\treflex eat when: ! empty(reachable_preys) {\t\task one_of (reachable_preys) {\t\t\tdo die ;\t\t}\t\tenergy &lt;- energy + energy_transfert ;\t}}\tgrid vegetation_cell width: 50 height: 50 neighbours: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbours_at 2); }experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\t\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: icon ;\t\t\tspecies predator aspect: icon ;\t\t}\t\tdisplay info_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: info ;\t\t\tspecies predator aspect: info ;\t\t}\t\tmonitor \"Number of preys\" value: nb_preys;\t\tmonitor \"Number of predators\" value: nb_predators;\t}}",
        "url":"/wiki/PredatorPrey_step7.html"
      }
      ,
    
      "wiki-predatorprey-step8-html": {
        "title": "8. Complex Behavior",
        "content": "8. Complex BehaviorThis eighth step Illustrates how to define and call actions and how to use conditional statements.Formulation  Definition of more complex behaviors for prey and predator agents:          The preys agents are moving to the cell containing the highest quantity of food      The predator agents are moving if possible to a cell that contains preys; otherwise random cell      Model Definitionparent speciesWe modify the basic_move reflex of the generic_species in order to give the prey and predator a more complex behaviors: instead of choose a random vegetation cell in the neighborhood, the agent will choose a vegetation cell (still in the neighborhood) thanks to a choose_cell action.This action will be specialized for each species.   species generic_species {        ...        reflex basic_move {\t\tmyCell &lt;- choose_cell();\t\tlocation &lt;- myCell.location; \t} \t\tvegetation_cell choose_cell {\t\treturn nil;\t}        ...   }We remind that an action is a capability available to the agents of a species (what they can do). It is a block of statements that can be used and reused whenever needed.  An action can accept arguments.  An action can return a result (statement return)There are two ways to call an action: using a statement or as part of an expression  for actions that do not return a result:    do action_name (arg1: v1 arg2: v2);do action_name (v1, v2);        for actions that return a result (which is stored in my_var):    my_var &lt;- action_name (arg1:v1, arg2:v2);my_var &lt;- action_name (v1, v2);      prey speciesWe specialize the choose_cell species for the prey species: the agent will choose the vegetation cell of the neighborhood (list myCell.neighbours) that maximizes the quantity of food.Note that GAMA offers numerous operators to manipulate lists and containers:  Unary operators : min, max, sum…  Binary operators :          where : returns a sub-list where all the elements verify the condition defined in the right operand.      first_with : returns the first element of the list that verifies the condition defined in the right operand.      …In the case of binary operators, each element (of the first operand list) can be accessed with the keyword each      Thus the choose_cell action of the prey species is defined by:   species prey parent: generic_species {      ...        vegetation_cell choose_cell {\t  return (myCell.neighbours) with_max_of (each.food);      }      ...   }predator speciesWe specialize the choose_cell species for the predator species: the agent will choose, if possible, a vegetation cell of the neighborhood (list myCell.neighbours) that contains at least a prey agent; otherwise it will choose a random cell.We use for this action the first_with operator on the list neighbor vegetation cells (myCell.neighbours) with the following condition: the list of prey agents contained in the cell is not empty. Note that we use the shuffle operator to randomize the order of the list of neighbor cell.If all the neighbor cells are empty (myCell_tmp = nil, nil is the null value), then the agent choosse a random cell in the neighborhood (one_of (myCell.neighbours)).GAMA contains statements that allow to execute blocks depending on some conditions:   if condition1 {...}    else if condition2{...}    ...    else {...} This statement means that if condition1 = true then the first block is executed; otherwise if condition2 = true, then it is the second block, etc. When no conditions are satisfied and an else block is defined (it is optional), this latter is executed.We then write the choose_cell action as follows:   species predator parent: generic_species {      ...      vegetation_cell choose_cell {\t  vegetation_cell myCell_tmp &lt;- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\t  if myCell_tmp != nil {\t\treturn myCell_tmp;\t  } else {\t\treturn one_of (myCell.neighbours);\t  }       }      ...   }Note there is ternary operator allowing to directly use a condition structure to evaluate a variable:   condition ? value1 : value2if condition is true, then returns value1; otherwise, returns value2.Complete Modelmodel prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tint nb_predators_init &lt;- 20;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfert &lt;- 0.1 ;\tfloat prey_energy_consum &lt;- 0.05;\tfloat predator_max_energy &lt;- 1.0;\tfloat predator_energy_transfert &lt;- 0.5;\tfloat predator_energy_consum &lt;- 0.02;\tfloat prey_proba_reproduce &lt;- 0.01;\tint prey_nb_max_offsprings &lt;- 5; \tfloat prey_energy_reproduce &lt;- 0.5; \tfloat predator_proba_reproduce &lt;- 0.01;\tint predator_nb_max_offsprings &lt;- 3;\tfloat predator_energy_reproduce &lt;- 0.5;\t\tint nb_preys -&gt; {length (prey)};\tint nb_predators -&gt; {length (predator)};\t\tinit {\t\tcreate prey number: nb_preys_init ; \t\tcreate predator number: nb_predators_init ;\t}}species generic_species {\tfloat size &lt;- 1.0;\trgb color  ;\tfloat max_energy;\tfloat max_transfert;\tfloat energy_consum;\tfloat proba_reproduce ;\tfloat nb_max_offsprings;\tfloat energy_reproduce;\tfile my_icon;\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ;\tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\tinit {\t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move {\t\tmyCell &lt;- choose_cell();\t\tlocation &lt;- myCell.location; \t} \t\tvegetation_cell choose_cell {\t\treturn nil;\t}\t\t\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\t\treflex reproduce when: (energy &gt;= energy_reproduce) and (flip(proba_reproduce)) {\t\tint nb_offsprings &lt;- 1 + rnd(nb_max_offsprings -1);\t\tcreate species(self) number: nb_offsprings {\t\t\tmyCell &lt;- myself.myCell ;\t\t\tlocation &lt;- myCell.location ;\t\t\tenergy &lt;- myself.energy / nb_offsprings ;\t\t}\t\tenergy &lt;- energy / nb_offsprings ;\t}\t\taspect base {\t\tdraw circle(size) color: color ;\t}\taspect icon {\t\tdraw my_icon size: 2 * size ;\t}\taspect info {\t\tdraw square(size) color: color ;\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\t}}species prey parent: generic_species {\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfert &lt;- prey_max_transfert ;\tfloat energy_consum &lt;- prey_energy_consum ;\tfloat proba_reproduce &lt;- prey_proba_reproduce ;\tint nb_max_offsprings &lt;- prey_nb_max_offsprings ;\tfloat energy_reproduce &lt;- prey_energy_reproduce ;\tfile my_icon &lt;- file(\"../images/predator_prey_sheep.png\") ;\t\t\treflex eat when: myCell.food &gt; 0 {\t\tfloat energy_transfert &lt;- min([max_transfert, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfert ;\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\treturn (myCell.neighbours) with_max_of (each.food);\t}}\tspecies predator parent: generic_species {\trgb color &lt;- #red ;\tfloat max_energy &lt;- predator_max_energy ;\tfloat energy_transfert &lt;- predator_energy_transfert ;\tfloat energy_consum &lt;- predator_energy_consum ;\tlist&lt;prey&gt; reachable_preys update: prey inside (myCell);\tfloat proba_reproduce &lt;- predator_proba_reproduce ;\tint nb_max_offsprings &lt;- predator_nb_max_offsprings ;\tfloat energy_reproduce &lt;- predator_energy_reproduce ;\tfile my_icon &lt;- file(\"../images/predator_prey_wolf.png\") ;\t\treflex eat when: ! empty(reachable_preys) {\t\task one_of (reachable_preys) {\t\t\tdo die ;\t\t}\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\tvegetation_cell myCell_tmp &lt;- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\t\tif myCell_tmp != nil {\t\t\treturn myCell_tmp;\t\t} else {\t\t\treturn one_of (myCell.neighbours);\t\t} \t}}\tgrid vegetation_cell width: 50 height: 50 neighbours: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbours_at 2); }experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\t\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: icon ;\t\t\tspecies predator aspect: icon ;\t\t}\t\tdisplay info_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: info ;\t\t\tspecies predator aspect: info ;\t\t}\t\tmonitor \"Number of preys\" value: nb_preys;\t\tmonitor \"Number of predators\" value: nb_predators;\t}}",
        "url":"/wiki/PredatorPrey_step8.html"
      }
      ,
    
      "wiki-predatorprey-step9-html": {
        "title": "9. Stopping condition",
        "content": "9. Stopping conditionThis 9th step Illustrates how to use the halt action to stop a simulationFormulation  Adding of a stopping condition for the simulation: when there is no more prey or predator agents, the simulation stopsModel DefinitionWe add a new reflex that stops the simulation if the number of preys or the number of predator is null.global {   ...   reflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {      do halt ;   } }Note that it would have been possible to use the pause action that pauses the simulation instead of the halt action that stops the simulation.Complete Modelmodel prey_predatorglobal {\tint nb_preys_init &lt;- 200;\tint nb_predators_init &lt;- 20;\tfloat prey_max_energy &lt;- 1.0;\tfloat prey_max_transfert &lt;- 0.1 ;\tfloat prey_energy_consum &lt;- 0.05;\tfloat predator_max_energy &lt;- 1.0;\tfloat predator_energy_transfert &lt;- 0.5;\tfloat predator_energy_consum &lt;- 0.02;\tfloat prey_proba_reproduce &lt;- 0.01;\tint prey_nb_max_offsprings &lt;- 5; \tfloat prey_energy_reproduce &lt;- 0.5; \tfloat predator_proba_reproduce &lt;- 0.01;\tint predator_nb_max_offsprings &lt;- 3;\tfloat predator_energy_reproduce &lt;- 0.5;\t\tint nb_preys -&gt; {length (prey)};\tint nb_predators -&gt; {length (predator)};\t\tinit {\t\tcreate prey number: nb_preys_init ; \t\tcreate predator number: nb_predators_init ;\t}\t\treflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {\t\tdo halt ;\t} }species generic_species {\tfloat size &lt;- 1.0;\trgb color  ;\tfloat max_energy;\tfloat max_transfert;\tfloat energy_consum;\tfloat proba_reproduce ;\tfloat nb_max_offsprings;\tfloat energy_reproduce;\tfile my_icon;\tvegetation_cell myCell &lt;- one_of (vegetation_cell) ;\tfloat energy &lt;- (rnd(1000) / 1000) * max_energy  update: energy - energy_consum max: max_energy ;\t\tinit {\t\tlocation &lt;- myCell.location;\t}\t\t\treflex basic_move {\t\tmyCell &lt;- choose_cell();\t\tlocation &lt;- myCell.location; \t} \t\tvegetation_cell choose_cell {\t\treturn nil;\t}\t\t\treflex die when: energy &lt;= 0 {\t\tdo die ;\t}\t\treflex reproduce when: (energy &gt;= energy_reproduce) and (flip(proba_reproduce)) {\t\tint nb_offsprings &lt;- 1 + rnd(nb_max_offsprings -1);\t\tcreate species(self) number: nb_offsprings {\t\t\tmyCell &lt;- myself.myCell ;\t\t\tlocation &lt;- myCell.location ;\t\t\tenergy &lt;- myself.energy / nb_offsprings ;\t\t}\t\tenergy &lt;- energy / nb_offsprings ;\t}\t\taspect base {\t\tdraw circle(size) color: color ;\t}\taspect icon {\t\tdraw my_icon size: 2 * size ;\t}\taspect info {\t\tdraw square(size) color: color ;\t\tdraw string(energy with_precision 2) size: 3 color: #black ;\t}}species prey parent: generic_species {\trgb color &lt;- #blue;\tfloat max_energy &lt;- prey_max_energy ;\tfloat max_transfert &lt;- prey_max_transfert ;\tfloat energy_consum &lt;- prey_energy_consum ;\tfloat proba_reproduce &lt;- prey_proba_reproduce ;\tint nb_max_offsprings &lt;- prey_nb_max_offsprings ;\tfloat energy_reproduce &lt;- prey_energy_reproduce ;\tfile my_icon &lt;- file(\"../images/predator_prey_sheep.png\") ;\t\t\treflex eat when: myCell.food &gt; 0 {\t\tfloat energy_transfert &lt;- min([max_transfert, myCell.food]) ;\t\tmyCell.food &lt;- myCell.food - energy_transfert ;\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\treturn (myCell.neighbours) with_max_of (each.food);\t}}\tspecies predator parent: generic_species {\trgb color &lt;- #red ;\tfloat max_energy &lt;- predator_max_energy ;\tfloat energy_transfert &lt;- predator_energy_transfert ;\tfloat energy_consum &lt;- predator_energy_consum ;\tlist&lt;prey&gt; reachable_preys update: prey inside (myCell);\tfloat proba_reproduce &lt;- predator_proba_reproduce ;\tint nb_max_offsprings &lt;- predator_nb_max_offsprings ;\tfloat energy_reproduce &lt;- predator_energy_reproduce ;\tfile my_icon &lt;- file(\"../images/predator_prey_wolf.png\") ;\t\treflex eat when: ! empty(reachable_preys) {\t\task one_of (reachable_preys) {\t\t\tdo die ;\t\t}\t\tenergy &lt;- energy + energy_transfert ;\t}\t\tvegetation_cell choose_cell {\t\tvegetation_cell myCell_tmp &lt;- shuffle(myCell.neighbours) first_with (!(empty (prey inside (each))));\t\tif myCell_tmp != nil {\t\t\treturn myCell_tmp;\t\t} else {\t\t\treturn one_of (myCell.neighbours);\t\t} \t}}\tgrid vegetation_cell width: 50 height: 50 neighbours: 4 {\tfloat maxFood &lt;- 1.0 ;\tfloat foodProd &lt;- (rnd(1000) / 1000) * 0.01 ;\tfloat food &lt;- (rnd(1000) / 1000) max: maxFood update: food + foodProd ;\trgb color &lt;- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 *(1 - food))) ;\tlist&lt;vegetation_cell&gt; neighbours  &lt;- (self neighbours_at 2); }experiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init  min: 0 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\tparameter \"Initial number of predators: \" var: nb_predators_init  min: 0 max: 200 category: \"Predator\" ;\tparameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;\tparameter \"Predator energy transfert: \" var: predator_energy_transfert  category: \"Predator\" ;\tparameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\tparameter 'Prey probability reproduce: ' var: prey_proba_reproduce category: 'Prey' ;\tparameter 'Prey nb max offsprings: ' var: prey_nb_max_offsprings category: 'Prey' ;\tparameter 'Prey energy reproduce: ' var: prey_energy_reproduce category: 'Prey' ;\tparameter 'Predator probability reproduce: ' var: predator_proba_reproduce category: 'Predator' ;\tparameter 'Predator nb max offsprings: ' var: predator_nb_max_offsprings category: 'Predator' ;\tparameter 'Predator energy reproduce: ' var: predator_energy_reproduce category: 'Predator' ;\t\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: icon ;\t\t\tspecies predator aspect: icon ;\t\t}\t\tdisplay info_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: info ;\t\t\tspecies predator aspect: info ;\t\t}\t\tmonitor \"Number of preys\" value: nb_preys;\t\tmonitor \"Number of predators\" value: nb_predators;\t}}",
        "url":"/wiki/PredatorPrey_step9.html"
      }
      ,
    
      "wiki-preferences-html": {
        "title": "Preferences",
        "content": "PreferencesVarious preferences are accessible in GAMA to allow users and modelers to personalize their working environment. This section review the different preference tabs available in the current version of GAMA, as well as how to access the preferences and settings inherited by GAMA from Eclipse.Please note that the preferences specific to GAMA will be shared, on a same machine, and for a same user, among all the workspaces managed by GAMA. Changing workspace will not alter them. If you happen to run several instances of GAMA, they will also share these preferences.Table of contents  Preferences          Opening Preferences      Simulation      Display      Editor      External      Advanced Preferences      Opening PreferencesTo open the preferences dialog of GAMA, either click on the small “form” button on the top-left corner of the window or select “Preferences…” from the Gama, “Help” or “Views” menu depending on your OS.Simulation  Random Number Generation: all the options pertaining to generating random numbers in simulations          Random Number Generator: the name of the generator to use by default (if none is specified in the model).      Define a default seed: whether or not a default seed should be used if none is specified in the model  (otherwise it is chosen randomly by GAMA)      Default Seed value: the value of this default seed      Include in the parameters of models: whether the choice of generator and seed is included by default in the parameters views of experiments or not.        Errors: how to manage and consider simulation errors          Display Errors: whether errors should be displayed or not.      Number of errors to display: how many errors should be displayed at once      Display most recent first: errors will be sorted in the inverse chronological order if true.      Stop simulation at first error: if false, the simulations will display the errors and continue (or try to).      Treat warnings as errors: if true, no more distinction is made between warnings (which do not stop the simulation) and errors (which can potentially stop it.        Runtime: various settings regarding the execution of experiments.          Default Step for Delay Slider: the number of seconds that one step of the slider used to impose a delay between two cycles of a simulation lasts.      Auto-run experiments when they are launched: see this page.      Ask to close the previous simulation before launching a new one: if false, previous simulations (if any) will be closed without warning.      UI  Menus          Break down agents in menu every: when inspecting a large number of agents, how many should be displayed before the decision is made to separate the population in sub-menus.      Sort colors menu by      Sort operators menu by        Console          Max. number of characters to display in the console (-1 means no limit)      Max. number of characters to keep in memory when console is paused (-1 means no limit)        Icons          Icons and buttons dark mode (restart to see the change): Change the highlight for the icons and the button.      Size of icons in the UI (restart to see the change): Size of the icons in pixel        Viewers          Default shapefile viewer fill color:      Default shapefile viewer line color:      Default image viewer background color: Background color for the image viewer (when you select an image from the model explorer for example)      General  Startup          Display welcome page at startup: if true, and if no editors are opened, the welcome page is displayed when opening GAMA.      Display  Properties: various properties of displays          Default display method: use either ‘Java2D’ or ‘OpenGL’ if nothing is specified in the declaration of a display.      Synchronize displays with simulations: if true, simulation cycles will wait for the displays to have finished their rendering before passing to the next cycle (this setting can be changed on an individual basis dynamically here).      Show display overlay: if true, the bottom overlay is visible when opening a display.      Show scale bar in overlay: if true, the scale bar is displayed in the bottom overlay.      Apply antialiasing: if true, displays are drawn using antialiasing, which is slower but renders a better quality of image and text (this setting can be changed on an individual basis dynamically here).      Default background color: indicates which color to use when none is specified in the declaration of a display.      Default highlight color: indicates which color to use for highlighting agents in the displays.      Stack displays on screen…: if true, the display views, in case they are stacked on one another, will put the first display declared in the model on top of the stack.        Default Aspect: which aspect to use when an ‘agent’ or ‘species’ layer does not indicate it          Default shape: a choice between ‘shape’ (which represents the actual geometrical shape of the agent) and geometrical operators (‘square’, etc.).      Default size: what size to use. This expression must be a constant.      Default color: what color to use.      Default font to use in text layers or draw statements when none is specified        OpenGL: various properties specific to OpenGL-based displays          Use improved z positioning: if true, two agents positioned at the same z value will be slightly shifted in z in order to draw them more accurately.      Draw 3D referential: if true, the shape of the world and the 3 axes are drawn      Show number of frames per second      Enable lighting: if true, lights can be defined in the display      Draw normals to objects: if true, the ‘normal’ of each object is displayed together with it.      Display as a cube: if true, the scene is drawn on all the facets of a cube.      EditorMost of the settings and preferences regarding editors can be found in the advanced preferences.  Options          Automatically switch to Modeling Persepective: if true, if a model is edited in the Simulation Perspective, then the perspective is automatically switched to Modeling (inactive for the moment)      Automatically close curly brackets ({)      Automatically close square brackets (])      Automatically close parenthesis      Mark occurrences of symbols in models: if true, when a symbol is selected in a model, all its occurrences are also highlighted.      Applying formatting to models on save: if true, every time a model file is saved, its code is formatted.      Save all model files before launching an experiment      Ask before saving each file        Validation          Show warning markers when editing a model      Show information markers when editing a model        Presentation          Turn on colorization of code sections by default      Font of editors      Background color of editors        Toolbars          Show edition toolbar by default      Show other models’ experiments in toolbar: if true, you are able to launch other models’ experiments from a particular model.      ExternalThese preferences pertain to the use of external libraries or data with GAMA.  Paths          Path to Spatialite: the path to the Spatialite library (http://www.gaia-gis.it/gaia-sins/) in the system.      Path to RScript: the path to the RScript library (http://www.r-project.org) in the system.        GIS Coordinate Reference Systems: settings about CRS to use when loading or saving GIS files          Let GAMA decide which CRS to use to project GIS data: if true, GAMA will decide which CRS, based on input, should be used to project GIS data. Default is false (i.e. only one CRS, entered below, is used to project data in the models)      …or use the following CRS (EPSG code): choose a CRS that will be applied to all GIS data when projected in the models. Please refer to http://spatialreference.org/ref/epsg/ for a list of EPSG codes.      When no .prj file or CRS is supplied, consider GIS data to be already projected: if true, GIS data that is not accompanied by a CRS information will be considered as projected using the above code.      …or use the following CRS (EPSG code): choose a CRS that will represent the default code for loading uninformed GIS data.      When no CRS is provided, save the GIS data with the current CRS: if true, saving GIS data will use the projected CRS unless a CRS is provided.      …or use the following CRS (EPSG code): otherwise, you might enter a CRS to use to save files.      Advanced PreferencesThe set of preferences described above are specific to GAMA. But there are other preferences or settings that are inherited from the Eclipse underpinnings of GAMA, which concern either the “core” of the platform (workspace, editors, updates, etc.) or plugins (like SVN, for instance) that are part of the distribution of GAMA.These “advanced” preferences are accessible by clicking on the “Advanced…” button in the Preferences view.Depending on what is installed, the second view that appears will contain a tree of options on the left and preference pages on the right. Contrary to the first set of preferences, please note that these preferences will be saved in the current workspace, which means that changing workspace will revert them to their default values. It is however possible to import them in the new workspace using of the wizards provided in the standard “Import…” command (see here).",
        "url":"/wiki/Preferences.html"
      }
      ,
    
      "wiki-projects-html": {
        "title": "Projects",
        "content": "ProjectsReferencesThis page contains a subset of the scientific papers that have been written either about GAMA or using the platform as an experimental/modeling support.If you happen to publish a paper that uses or discusses GAMA, please let us know, so that we can include it in this list.If you need to cite GAMA in a paper, we kindly ask you to use this reference:  A. Grignard, P. Taillandier, B. Gaudou, D-A. Vo, N-Q. Huynh, A. Drogoul (2013), GAMA 1.6: Advancing the Art of Complex Agent-Based Modeling and Simulation. In ‘PRIMA 2013: Principles and Practice of Multi-Agent Systems’, Lecture Notes in Computer Science, Vol. 8291, Springer, pp. 117-131.Papers about GAMA      Taillandier, Patrick, Arnaud Grignard, Benoit Gaudou, and Alexis Drogoul. “Des données géographiques à la simulation à base d’agents: application de la plate-forme GAMA.” Cybergeo: European Journal of Geography (2014).        A. Grignard, P. Taillandier, B. Gaudou, D-A. Vo, N-Q. Huynh, A. Drogoul (2013), GAMA 1.6: Advancing the Art of Complex Agent-Based Modeling and Simulation. In ‘PRIMA 2013: Principles and Practice of Multi-Agent Systems’, Lecture Notes in Computer Science, Vol. 8291, Springer, pp. 117-131.        Grignard, Arnaud, Alexis Drogoul, and Jean-Daniel Zucker. “Online analysis and visualization of agent based models.” Computational Science and Its Applications–ICCSA 2013. Springer Berlin Heidelberg, 2013. 662-672.        Taillandier, P., Drogoul, A., Vo, D.A. and Amouroux, E. (2012), GAMA: a simulation platform that integrates geographical information data, agent-based modeling and multi-scale control. In ‘The 13th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA)’, India, Volume 7057/2012, pp 242-258.        Taillandier, P. &amp; Drogoul, A. (2011), From Grid Environment to Geographic Vector Agents, Modeling with the GAMA simulation platform. In ‘25th Conference of the International Cartographic Association’, Paris, France.        Taillandier, P. ; Drogoul A. ; Vo D.A. &amp; Amouroux, E. (2010), GAMA : bringing GIS and multi-level capabilities to multi-agent simulation, in ‘the 8th European Workshop on Multi-Agent Systems’, Paris, France.        Amouroux, E., Taillandier, P. &amp;  Drogoul, A. (2010), Complex environment representation in epidemiology ABM: application on H5N1 propagation. In ‘the 3rd International Conference on Theories and Applications of Computer Science’ (ICTACS’10).        Amouroux, E., Chu, T.Q., Boucher, A. and Drogoul, A. (2007), GAMA: an environment for implementing and running spatially explicit multi-agent simulations. In ‘Pacific Rim International Workshop on Multi-Agents’, Bangkoku, Thailand, pp. 359–371.  PhD theses      Truong Xuan Viet, “Optimization by Simulation of an Environmental Surveillance Network: Application to the Fight against Rice Pests in the Mekong Delta (Vietnam)”, University of Paris 6 &amp; Ho Chi Minh University of Technology, defended June 24th, 2014.        Nguyen Nhi Gia Vinh, “Designing multi-scale models to support environmental decision: application to the control of Brown Plant Hopper invasions in the Mekong Delta (Vietnam)”, University of Paris 6, defended Oct. 31st, 2013.        Vo Duc An, “An operational architecture to handle multiple levels of representation in agent-based models”, University of Paris 6, defended Nov. 30th 2012.        Amouroux Edouard, “KIMONO: a descriptive agent-based modeling methodology for the exploration of complex systems: an application to epidemiology”, University of Paris 6, defended Sept. 30th, 2011.        Chu Thanh Quang, “Using agent-based models and machine learning to enhance spatial decision support systems: Application to resource allocation in situations of urban catastrophes”, University of Paris 6, defended July 1st, 2011.        Nguyen Ngoc Doanh, “Coupling Equation-Based and Individual-Based Models in the Study of Complex Systems: A Case Study in Theoretical Population Ecology”, University of Paris 6, defended Dec. 14th, 2010.  Research papers that use GAMA as modeling/simulation support2014      E. G. Macatulad , A. C. Blanco (2014) 3DGIS-BASED MULTI-AGENT GEOSIMULATION AND VISUALIZATION OF BUILDING EVACUATION USING GAMA PLATFORM. The International Archives of the Photogrammetry, Remote Sensing and Spatial Information Sciences, Volume XL-2, 2014. ISPRS Technical Commission II Symposium, 6 – 8 October 2014, Toronto, Canada. Retrieved from http://www.int-arch-photogramm-remote-sens-spatial-inf-sci.net/XL-2/87/2014/isprsarchives-XL-2-87-2014.pdf        S. Bhamidipati (2014) A simulation framework for asset management in climate-change adaptation of transportation infrastructure. In: Proceedings of 42nd European Transport Conference. Frankfurt, Germany. Retrieved from http://abstracts.aetransport.org/paper/download/id/4317        Gaudou, B., Sibertin-Blanc, C., Thérond, O., Amblard, F., Auda, Y., Arcangeli, J.-P., Balestrat, M., Charron-Moirez, M.-H., Gondet, E., Hong, Y., Lardy, R., Louail, T., Mayor, E., Panzoli, D., Sauvage, S., Sanchez-Perez, J., Taillandier, P., Nguyen, V. B., Vavasseur, M., Mazzega, P. (2014). The MAELIA multi-agent platform for integrated assessment of low-water management issues. In: International Workshop on Multi-Agent-Based Simulation (MABS 2013), Saint-Paul, MN, USA, 06/05/2013-07/05/2013, Vol. 8235, Shah Jamal Alam, H. Van Dyke Parunak, (Eds.), Springer, Lecture Notes in Computer Science, p. 85-110.        Gaudou, B., Lorini, E., Mayor, E. (2014.) Moral Guilt: An Agent-Based Model Analysis. In: Conference of the European Social Simulation Association (ESSA 2013), Warsaw, 16/09/2013-20/09/2013, Vol. 229, Springer, Advances in Intelligent Systems and Computing, p. 95-106.  2013      Drogoul, A., Gaudou, B., Grignard, A., Taillandier, P., &amp; Vo, D. A. (2013). Practical Approach To Agent-Based Modelling. In: Water and its Many Issues. Methods and Cross-cutting Analysis. Stéphane Lagrée (Eds.), Journées de Tam Dao, p. 277-300, Regional Social Sciences Summer University.        Drogoul, A., Gaudou, B. (2013) Methods for Agent-Based Computer Modelling. In: Water and its Many Issues. Methods and Cross-cutting Analysis. Stéphane Lagrée (Eds.), Journées de Tam Dao, 1.6, p. 130-154, Regional Social Sciences Summer University.         Truong, M.-T., Amblard, F., Gaudou, B., Sibertin-Blanc, C., Truong, V. X., Drogoul, A., Hyunh, X. H., Le, M. N. (2013). An implementation of framework of business intelligence for agent-based simulation. In: Symposium on Information and Communication Technology (SoICT 2013), Da Nang, Viet Nam, 05/12/2013-06/12/2013, Quyet Thang Huynh, Thanh Binh Nguyen, Van Tien Do, Marc Bui, Hong Son Ngo (Eds.), ACM, p. 35-44.        Le, V. M., Gaudou, B., Taillandier, P., Vo, D. A (2013). A New BDI Architecture To Formalize Cognitive Agent Behaviors Into Simulations. In: Advanced Methods and Technologies for Agent and Multi-Agent Systems (KES-AMSTA 2013), Hue, Vietnam, 27/05/2013-29/05/2013, Vol. 252, Dariusz Barbucha, Manh Thanh Le, Robert J. Howlett, C. Jain Lakhmi (Eds.), IOS Press, Frontiers in Artificial Intelligence and Applications, p. 395-403.  2012      Taillandier, P., Therond, O., Gaudou B. (2012), A new BDI agent architecture based on the belief theory. Application to the modelling of cropping plan decision-making. In ‘International Environmental Modelling and Software Society’, Germany, pp. 107-116.        Taillandier, P., Therond, O., Gaudou B. (2012), Une architecture d’agent BDI basée sur la théorie des fonctions de croyance: application à la simulation du comportement des agriculteurs. In ‘Journées Francophones sur les Systèmes Multi-Agents’, France, pp. 107-116.        NGUYEN, Quoc Tuan, Alain BOUJU, and Pascal ESTRAILLIER. “Multi-agent architecture with space-time components for the simulation of urban transportation systems.” (2012).        Cisse, A., Bah, A., Drogoul, A., Cisse, A.T., Ndione, J.A., Kebe, C.M.F. &amp; Taillandier P. (2012), Un modèle à base d’agents sur la transmission et la diffusion de la fièvre de la Vallée du Rift à Barkédji (Ferlo, Sénégal), Studia Informatica Universalis 10 (1), pp. 77-97.        Taillandier, P., Amouroux, E., Vo, D.A. and Olteanu-Raimond A.M. (2012), Using Belief Theory to formalize the agent behavior: application to the simulation of avian flu propagation. In ‘The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS)’, India, Volume 7057/2012, pp. 575-587.        Le, V.M., Adam, C., Canal, R., Gaudou, B., Ho, T.V. and Taillandier, P. (2012), Simulation of the emotion dynamics in a group of agents in an evacuation situation. In ‘The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS)’, India, Volume 7057/2012, pp. 604-619.        Nguyen Vu, Q. A., Canal, R., Gaudou, B., Hassas, S., Armetta, F. (2012), TrustSets - Using trust to detect deceitful agents in a distributed information collecting system. In: Journal of Ambient Intelligence and Humanized Computing, Springer-Verlag, Vol. 3 N. 4, p. 251-263.  2011      Taillandier, P. &amp; Therond, O. (2011), Use of the Belief Theory to formalize Agent Decision Making Processes : Application to cropping Plan Decision Making. In ’25th European Simulation and Modelling Conference’, Guimaraes, Portugal, pp. 138-142.        Taillandier, P. &amp; Amblard, F. (2011), Cartography of Multi-Agent Model Parameter Space through a reactive Dicotomous Approach. In ’25th European Simulation and Modelling Conference’, Guimaraes, Portugal, pp. 38-42.        Taillandier, P. &amp; Stinckwich, S. (2011), Using the PROMETHEE Multi-Criteria Decision Making Method to Define New Exploration Strategies for Rescue Robots’, IEEE International Symposium on Safety, Security, and Rescue Robotics, Kyoto, Japon, pp. 321 - 326.  2010      Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S. and Armetta, F. (2010), A cluster-based approach for disturbed, spatialized, distributed information gathering systems,  in ‘The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS)’, India, pp. 588-603.        Nguyen, N.D., Taillandier, P., Drogoul, A. and Augier, P. (2010), Inferring Equation-Based Models from Agent-Based Models: A Case Study in Competition Dynamics.In ‘The 13th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA)’, India, Volume 7057/2012, pp. 413-427.        Amouroux, E., Gaudou, B. Desvaux, S. and Drogoul, A. (2010), O.D.D.: a Promising but Incomplete Formalism For Individual-Based Model Specification. in ‘IEEE International Conference on Computing and Telecommunication Technologies ’(2010 IEEE RIVF’), pp. 1-4.        Nguyen, N.D., Phan, T.H.D., Nguyen, T.N.A., Drogoul, A. and Zucker, J-D. (2010), Disk Graph-Based Model for Competition Dynamic, Paper to appear in ‘IEEE International Conference on Computing and Telecommunication Technologies ’(2010 IEEE RIVF’).        Nguyen, T.K., Marilleau, N., Ho T.V. and El Fallah Seghrouchni, A. (2010), A meta-model for specifying collaborative simulation, Paper to appear in ‘IEEE International Conference on Computing and Telecommunication Technologies ’(2010 IEEE RIVF’).        Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S. and Armetta, F. (2010), TrustSets - Using trust to detect deceitful agents in a distributed information collecting system, Paper to appear in ‘IEEE International Conference on Computing and Telecommunication Technologies ’(2010 IEEE RIVF’), the best student paper award.        Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S., Armetta, F. and Stinckwich, S. (2010), Using trust and cluster organisation to improve robot swarm mapping, Paper to appear in ‘Workshop on Robots and Sensors integration in future rescue INformation system ’ (ROSIN 2010).  2009      Taillandier, P. and Buard, E. (2009), Designing Agent Behaviour in Agent-Based Simulation through participatory method. In ‘The 12th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA)’, Nagoya, Japan, pp. 571–578.        Taillandier, P. and Chu, T.Q. (2009), Using Participatory Paradigm to Learn Human Behaviour. In ‘International Conference on Knowledge and Systems Engineering’, Ha noi, Viet Nam, pp. 55–60.        Gaudou, B., Ho, T.V. and Marilleau, N. (2009), Introduce collaboration in methodologies of modeling and simulation of Complex Systems. In ‘International Conference on Intelligent Networking and Collaborative Systems (INCOS ‘09)’. Barcelona, pp. 1–8.        Nguyen, T.K., Gaudou B., Ho T.V. and Marilleau N. (2009), Application of PAMS Collaboration Platform to Simulation-Based Researches in Soil Science: The Case of the MIcro-ORganism Project. In ‘IEEE International Conference on Computing and Telecommunication Technologies (IEEE-RIVF 09)’. Da Nang, Viet Nam, pp. 296–303.        Nguyen, V.Q., Gaudou B., Canal R., Hassas S. and Armetta F. (2009), Stratégie de communication dans un système de collecte d’information à base d’agents perturbés. In ‘Journées Francophones sur les Systèmes Multi-Agents (JFSMA’09)’.  2008      Chu, T.Q., Boucher, A., Drogoul, A., Vo, D.A., Nguyen, H.P. and Zucker, J.D. (2008). Interactive Learning of Expert Criteria for Rescue Simulations. In ‘Pacific Rim International Workshop on Multi-Agents’, Ha Noi, Viet Nam, pp. 127–138.        Amouroux, E., Desvaux, S. and Drogoul, A. (2008), Towards Virtual Epidemiology: An Agent-Based Approach to the Modeling of H5N1 Propagation and Persistence in North-Vietnam. In ‘Pacific Rim International Workshop on Multi-Agents’, Ha Noi, Viet Nam, pp. 26–33.  ",
        "url":"/wiki/Projects.html"
      }
      ,
    
      "wiki-pseudovariables-html": {
        "title": "Pseudo-variables",
        "content": "Pseudo-variablesThe expressions known as pseudo-variables are special read-only variables that are not declared anywhere (at least not in a species), and which represent a value that changes depending on the context of execution.Table of contents  Pseudo-variables          self      myself      each      selfThe pseudo-variable self always holds a reference to the agent executing the current statement.  Example (sets the friend attribute of another random agent of the same species to self and conversely):friend potential_friend &lt;- one_of (species(self) - self);if potential_friend != nil {    potential_friend.friend &lt;- self;    friend &lt;- potential_friend;}myselfmyself plays the same role as self but in remotely-executed code (ask, create, capture and release statements), where it represents the calling agent when the code is executed by the remote agent.  Example (asks the first agent of my species to set its color to my color):ask first (species (self)){    color &lt;- myself.color;}  Example (create 10 new agents of the species of my species, share the energy between them, turn them towards me, and make them move 4 times to get closer to me):create species (self) number: 10 {   energy &lt;- myself.energy / 10.0;   loop times: 4 {       heading &lt;- towards (myself);       do move;   }}eacheach is available only in the right-hand argument of iterators.  It is a pseudo-variable that represents, in turn, each of the elements of the left-hand container. It can then take any type depending on the context.  Example:    list&lt;string&gt; names &lt;- my_species collect each.name;  // each is of type my_species    int max &lt;- max(['aa', 'bbb', 'cccc'] collect length(each)); // each is of type string",
        "url":"/wiki/PseudoVariables.html"
      }
      ,
    
      "wiki-recipes-html": {
        "title": "Recipes",
        "content": "RecipesUnderstanding the structure of models in GAML and gaining some insight of the language is required, but is usually not sufficient to build correct models or models that need to deal with specific approaches (like equation-based modeling). This section is intended to provide readers with practical “how to”s on various subjects, ranging from the use of database access to the design of agent communication languages. It is by no means exhaustive, and will progressively be extended with more “recipes” in the future, depending on the concrete questions asked by users.",
        "url":"/wiki/Recipes.html"
      }
      ,
    
      "wiki-references-html": {
        "title": "References",
        "content": "ReferencesThis page contains a subset of the scientific papers that have been written either about GAMA or using the platform as an experimental/modeling support.If you happen to publish a paper that uses or discusses GAMA, please let us know, so that we can include it in this list.As stated in the first page, if you need to cite GAMA in a paper, we kindly ask you to use this reference:  A. Grignard, P. Taillandier, B. Gaudou, D-A. Vo, N-Q. Huynh, A. Drogoul (2013), GAMA 1.6: Advancing the Art of Complex Agent-Based Modeling and Simulation. In ‘PRIMA 2013: Principles and Practice of Multi-Agent Systems’, Lecture Notes in Computer Science, Vol. 8291, Springer, pp. 117-131.Papers about GAMA      Taillandier, Patrick, Arnaud Grignard, Benoit Gaudou, and Alexis Drogoul. “Des données géographiques à la simulation à base d’agents: application de la plate-forme GAMA.” Cybergeo: European Journal of Geography (2014).        A. Grignard, P. Taillandier, B. Gaudou, D-A. Vo, N-Q. Huynh, A. Drogoul (2013), GAMA 1.6: Advancing the Art of Complex Agent-Based Modeling and Simulation. In ‘PRIMA 2013: Principles and Practice of Multi-Agent Systems’, Lecture Notes in Computer Science, Vol. 8291, Springer, pp. 117-131.        Grignard, Arnaud, Alexis Drogoul, and Jean-Daniel Zucker. “Online analysis and visualization of agent based models.” Computational Science and Its Applications–ICCSA 2013. Springer Berlin Heidelberg, 2013. 662-672.        Taillandier, P., Drogoul, A., Vo, D.A. and Amouroux, E. (2012), GAMA: a simulation platform that integrates geographical information data, agent-based modeling and multi-scale control. In ‘The 13th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA)’, India, Volume 7057/2012, pp 242-258.        Taillandier, P. &amp; Drogoul, A. (2011), From Grid Environment to Geographic Vector Agents, Modeling with the GAMA simulation platform. In ‘25th Conference of the International Cartographic Association’, Paris, France.        Taillandier, P. ; Drogoul A. ; Vo D.A. &amp; Amouroux, E. (2010), GAMA : bringing GIS and multi-level capabilities to multi-agent simulation, in ‘the 8th European Workshop on Multi-Agent Systems’, Paris, France.        Amouroux, E., Taillandier, P. &amp;  Drogoul, A. (2010), Complex environment representation in epidemiology ABM: application on H5N1 propagation. In ‘the 3rd International Conference on Theories and Applications of Computer Science’ (ICTACS’10).        Amouroux, E., Chu, T.Q., Boucher, A. and Drogoul, A. (2007), GAMA: an environment for implementing and running spatially explicit multi-agent simulations. In ‘Pacific Rim International Workshop on Multi-Agents’, Bangkoku, Thailand, pp. 359–371.  PhD theses      Truong Xuan Viet, “Optimization by Simulation of an Environmental Surveillance Network: Application to the Fight against Rice Pests in the Mekong Delta (Vietnam)”, University of Paris 6 &amp; Ho Chi Minh University of Technology, defended June 24th, 2014.        Nguyen Nhi Gia Vinh, “Designing multi-scale models to support environmental decision: application to the control of Brown Plant Hopper invasions in the Mekong Delta (Vietnam)”, University of Paris 6, defended Oct. 31st, 2013.        Vo Duc An, “An operational architecture to handle multiple levels of representation in agent-based models”, University of Paris 6, defended Nov. 30th 2012.        Amouroux Edouard, “KIMONO: a descriptive agent-based modeling methodology for the exploration of complex systems: an application to epidemiology”, University of Paris 6, defended Sept. 30th, 2011.        Chu Thanh Quang, “Using agent-based models and machine learning to enhance spatial decision support systems: Application to resource allocation in situations of urban catastrophes”, University of Paris 6, defended July 1st, 2011.        Nguyen Ngoc Doanh, “Coupling Equation-Based and Individual-Based Models in the Study of Complex Systems: A Case Study in Theoretical Population Ecology”, University of Paris 6, defended Dec. 14th, 2010.  Research papers that use GAMA as modeling/simulation support2016  Bhamidipati, S., van der Lei, T., &amp; Herder, P. (2016). A layered approach to model interconnected infrastructure and its significance for asset management. EJTIR, 16(1), 254-272.2014      E. G. Macatulad , A. C. Blanco (2014) 3DGIS-BASED MULTI-AGENT GEOSIMULATION AND VISUALIZATION OF BUILDING EVACUATION USING GAMA PLATFORM. The International Archives of the Photogrammetry, Remote Sensing and Spatial Information Sciences, Volume XL-2, 2014. ISPRS Technical Commission II Symposium, 6 – 8 October 2014, Toronto, Canada. Retrieved from http://www.int-arch-photogramm-remote-sens-spatial-inf-sci.net/XL-2/87/2014/isprsarchives-XL-2-87-2014.pdf        S. Bhamidipati (2014) A simulation framework for asset management in climate-change adaptation of transportation infrastructure. In: Proceedings of 42nd European Transport Conference. Frankfurt, Germany. Retrieved from http://abstracts.aetransport.org/paper/download/id/4317        Gaudou, B., Sibertin-Blanc, C., Thérond, O., Amblard, F., Auda, Y., Arcangeli, J.-P., Balestrat, M., Charron-Moirez, M.-H., Gondet, E., Hong, Y., Lardy, R., Louail, T., Mayor, E., Panzoli, D., Sauvage, S., Sanchez-Perez, J., Taillandier, P., Nguyen, V. B., Vavasseur, M., Mazzega, P. (2014). The MAELIA multi-agent platform for integrated assessment of low-water management issues. In: International Workshop on Multi-Agent-Based Simulation (MABS 2013), Saint-Paul, MN, USA, 06/05/2013-07/05/2013, Vol. 8235, Shah Jamal Alam, H. Van Dyke Parunak, (Eds.), Springer, Lecture Notes in Computer Science, p. 85-110.        Gaudou, B., Lorini, E., Mayor, E. (2014.) Moral Guilt: An Agent-Based Model Analysis. In: Conference of the European Social Simulation Association (ESSA 2013), Warsaw, 16/09/2013-20/09/2013, Vol. 229, Springer, Advances in Intelligent Systems and Computing, p. 95-106.  2013      Drogoul, A., Gaudou, B., Grignard, A., Taillandier, P., &amp; Vo, D. A. (2013). Practical Approach To Agent-Based Modelling. In: Water and its Many Issues. Methods and Cross-cutting Analysis. Stéphane Lagrée (Eds.), Journées de Tam Dao, p. 277-300, Regional Social Sciences Summer University.        Drogoul, A., Gaudou, B. (2013) Methods for Agent-Based Computer Modelling. In: Water and its Many Issues. Methods and Cross-cutting Analysis. Stéphane Lagrée (Eds.), Journées de Tam Dao, 1.6, p. 130-154, Regional Social Sciences Summer University.         Truong, M.-T., Amblard, F., Gaudou, B., Sibertin-Blanc, C., Truong, V. X., Drogoul, A., Hyunh, X. H., Le, M. N. (2013). An implementation of framework of business intelligence for agent-based simulation. In: Symposium on Information and Communication Technology (SoICT 2013), Da Nang, Viet Nam, 05/12/2013-06/12/2013, Quyet Thang Huynh, Thanh Binh Nguyen, Van Tien Do, Marc Bui, Hong Son Ngo (Eds.), ACM, p. 35-44.        Le, V. M., Gaudou, B., Taillandier, P., Vo, D. A (2013). A New BDI Architecture To Formalize Cognitive Agent Behaviors Into Simulations. In: Advanced Methods and Technologies for Agent and Multi-Agent Systems (KES-AMSTA 2013), Hue, Vietnam, 27/05/2013-29/05/2013, Vol. 252, Dariusz Barbucha, Manh Thanh Le, Robert J. Howlett, C. Jain Lakhmi (Eds.), IOS Press, Frontiers in Artificial Intelligence and Applications, p. 395-403.  2012      Taillandier, P., Therond, O., Gaudou B. (2012), A new BDI agent architecture based on the belief theory. Application to the modelling of cropping plan decision-making. In ‘International Environmental Modelling and Software Society’, Germany, pp. 107-116.        Taillandier, P., Therond, O., Gaudou B. (2012), Une architecture d’agent BDI basée sur la théorie des fonctions de croyance: application à la simulation du comportement des agriculteurs. In ‘Journées Francophones sur les Systèmes Multi-Agents’, France, pp. 107-116.        NGUYEN, Quoc Tuan, Alain BOUJU, and Pascal ESTRAILLIER. “Multi-agent architecture with space-time components for the simulation of urban transportation systems.” (2012).        Cisse, A., Bah, A., Drogoul, A., Cisse, A.T., Ndione, J.A., Kebe, C.M.F. &amp; Taillandier P. (2012), Un modèle à base d’agents sur la transmission et la diffusion de la fièvre de la Vallée du Rift à Barkédji (Ferlo, Sénégal), Studia Informatica Universalis 10 (1), pp. 77-97.        Taillandier, P., Amouroux, E., Vo, D.A. and Olteanu-Raimond A.M. (2012), Using Belief Theory to formalize the agent behavior: application to the simulation of avian flu propagation. In ‘The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS)’, India, Volume 7057/2012, pp. 575-587.        Le, V.M., Adam, C., Canal, R., Gaudou, B., Ho, T.V. and Taillandier, P. (2012), Simulation of the emotion dynamics in a group of agents in an evacuation situation. In ‘The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS)’, India, Volume 7057/2012, pp. 604-619.        Nguyen Vu, Q. A., Canal, R., Gaudou, B., Hassas, S., Armetta, F. (2012), TrustSets - Using trust to detect deceitful agents in a distributed information collecting system. In: Journal of Ambient Intelligence and Humanized Computing, Springer-Verlag, Vol. 3 N. 4, p. 251-263.  2011      Taillandier, P. &amp; Therond, O. (2011), Use of the Belief Theory to formalize Agent Decision Making Processes : Application to cropping Plan Decision Making. In ’25th European Simulation and Modelling Conference’, Guimaraes, Portugal, pp. 138-142.        Taillandier, P. &amp; Amblard, F. (2011), Cartography of Multi-Agent Model Parameter Space through a reactive Dicotomous Approach. In ’25th European Simulation and Modelling Conference’, Guimaraes, Portugal, pp. 38-42.        Taillandier, P. &amp; Stinckwich, S. (2011), Using the PROMETHEE Multi-Criteria Decision Making Method to Define New Exploration Strategies for Rescue Robots’, IEEE International Symposium on Safety, Security, and Rescue Robotics, Kyoto, Japon, pp. 321 - 326.  2010      Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S. and Armetta, F. (2010), A cluster-based approach for disturbed, spatialized, distributed information gathering systems,  in ‘The first Pacific Rim workshop on Agent-based modeling and simulation of Complex Systems (PRACSYS)’, India, pp. 588-603.        Nguyen, N.D., Taillandier, P., Drogoul, A. and Augier, P. (2010), Inferring Equation-Based Models from Agent-Based Models: A Case Study in Competition Dynamics.In ‘The 13th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA)’, India, Volume 7057/2012, pp. 413-427.        Amouroux, E., Gaudou, B. Desvaux, S. and Drogoul, A. (2010), O.D.D.: a Promising but Incomplete Formalism For Individual-Based Model Specification. in ‘IEEE International Conference on Computing and Telecommunication Technologies ’(2010 IEEE RIVF’), pp. 1-4.        Nguyen, N.D., Phan, T.H.D., Nguyen, T.N.A., Drogoul, A. and Zucker, J-D. (2010), Disk Graph-Based Model for Competition Dynamic, Paper to appear in ‘IEEE International Conference on Computing and Telecommunication Technologies ’(2010 IEEE RIVF’).        Nguyen, T.K., Marilleau, N., Ho T.V. and El Fallah Seghrouchni, A. (2010), A meta-model for specifying collaborative simulation, Paper to appear in ‘IEEE International Conference on Computing and Telecommunication Technologies ’(2010 IEEE RIVF’).        Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S. and Armetta, F. (2010), TrustSets - Using trust to detect deceitful agents in a distributed information collecting system, Paper to appear in ‘IEEE International Conference on Computing and Telecommunication Technologies ’(2010 IEEE RIVF’), the best student paper award.        Nguyen Vu, Q.A. , Gaudou, B., Canal, R., Hassas, S., Armetta, F. and Stinckwich, S. (2010), Using trust and cluster organisation to improve robot swarm mapping, Paper to appear in ‘Workshop on Robots and Sensors integration in future rescue INformation system ’ (ROSIN 2010).  2009      Taillandier, P. and Buard, E. (2009), Designing Agent Behaviour in Agent-Based Simulation through participatory method. In ‘The 12th International Conference on Principles and Practices in Multi-Agent Systems (PRIMA)’, Nagoya, Japan, pp. 571–578.        Taillandier, P. and Chu, T.Q. (2009), Using Participatory Paradigm to Learn Human Behaviour. In ‘International Conference on Knowledge and Systems Engineering’, Ha noi, Viet Nam, pp. 55–60.        Gaudou, B., Ho, T.V. and Marilleau, N. (2009), Introduce collaboration in methodologies of modeling and simulation of Complex Systems. In ‘International Conference on Intelligent Networking and Collaborative Systems (INCOS ‘09)’. Barcelona, pp. 1–8.        Nguyen, T.K., Gaudou B., Ho T.V. and Marilleau N. (2009), Application of PAMS Collaboration Platform to Simulation-Based Researches in Soil Science: The Case of the MIcro-ORganism Project. In ‘IEEE International Conference on Computing and Telecommunication Technologies (IEEE-RIVF 09)’. Da Nang, Viet Nam, pp. 296–303.        Nguyen, V.Q., Gaudou B., Canal R., Hassas S. and Armetta F. (2009), Stratégie de communication dans un système de collecte d’information à base d’agents perturbés. In ‘Journées Francophones sur les Systèmes Multi-Agents (JFSMA’09)’.  2008      Chu, T.Q., Boucher, A., Drogoul, A., Vo, D.A., Nguyen, H.P. and Zucker, J.D. (2008). Interactive Learning of Expert Criteria for Rescue Simulations. In ‘Pacific Rim International Workshop on Multi-Agents’, Ha Noi, Viet Nam, pp. 127–138.        Amouroux, E., Desvaux, S. and Drogoul, A. (2008), Towards Virtual Epidemiology: An Agent-Based Approach to the Modeling of H5N1 Propagation and Persistence in North-Vietnam. In ‘Pacific Rim International Workshop on Multi-Agents’, Ha Noi, Viet Nam, pp. 26–33.  ",
        "url":"/wiki/References.html"
      }
      ,
    
      "wiki-regularspecies-html": {
        "title": "Regular species",
        "content": "Regular speciesRegular species are composed of attributes, actions, reflex, aspect etc… They describes the behavior of our agents. You can instantiate as much as you want agents from a regular species, and you can define as much as you want different regular species. You can see a species as a “class” in OOP.Index  Declaration  Built-in Attributes  Built-in Actions  The init statement  The aspect statement  Instantiate an agentDeclarationThe regular species declaration starts with the keyword species followed by the name (or followed by the facet name:) :species my_specie {}or:species name:my_specie {}Directly in the “species” scope, you have to declare all your attributes (or “member” in OOP). You declare them exactly the way you declare basic variables. Those attributes are accessible wherever you want inside the species scope.species my_specie {\tint variableA;}Built-in attributesAs for the global species, some attributes exist already by default in a regular species. Here is the list of built-in attributes:  name (type: string) is used to name your agent. By default, the name is equal to the name of your species + an incremental number. This name is the one visible on the species inspector.  location (type: point) is used to control the position of your agent. It refers to the center of the envelop of the shape associated to the agent.  shape (type: geometry) is used to describe the geometry of your agent. If you want to use some intersection operator between agents for instance, it is this geometry that is computed (nb : it can be totally different from the aspect you want to display for your agent !). By default, the shape is a point.  host (type: agent) is used when your agent is part of another agent. We will see this concept a bit further, in the topic multi-level architecture.All those 4 built-in attributes can be accessed in both reading and writing very easily:species my_species {\tinit {\t\tname &lt;- \"custom_name\";\t\tlocation &lt;- {0,1};\t\tshape &lt;- rectangle(5,1);\t}}All those built-in attributes are attributes of an agent (an instance of a species). Species has also their own attributes, which can be accessed with the following syntax (read only) :name_of_your_species.attribute_you_wantNotice that the world agent is also an agent ! It has all the built-in attributes declared above. The world agent is defined inside the global scope. From the global scope then, you can for example access to the center of the envelop of the world shape :global{    init {    \twrite location; // writes {50.0,50.0,0.0}    }}Here is the list of those attributes:  name (type: string) returns the name of your species  attributes (type: list of string) returns the list of the names of the attributes of your species  population (type: list) returns the list of agent that belong to it  subspecies (type: list of string) returns the list of species that inherit directly from this species (we will talk about the concept of inheritance later)  parent (type: species) returns its parent species if it belongs to the model, or nil otherwise (we will talk about the concept of inheritance later)Built-in actionSome actions are define by default for a minimal agent. We already saw quickly the action write, used to display a message in the console.Another very useful built-in action is the action die, used to destroy an agent.species my_species{    reflex being_killed {        do die;    }}Here is the list of the other built-in actions which you can find in the documentation: debug, message, tell.The init statementAfter declaring all the attributes of your species, you can define an initial state (before launching the simulation). It can be seen as the “constructor of the class” in OOP.species my_species {\tint variableA;\tinit {\t\tvariableA &lt;- 5;\t}}The aspect statementInside each species, you can define one or several aspects. This scope allows you to define how you want your species to be represented in the simulation.Each aspect has a special name (so that they can be called from the experiment). Once again, you can name your aspect by using the facet name:, or simply by naming it just after the aspect keyword.species my_species {\taspect standard_aspect { // or \"aspect name:standard_aspect\"\t}}You can then define your aspect by using the statement draw. You can then choose a geometry for your aspect (facet geometry), a color (facet color), an image (facet image), a text (facet text)… We invite you to read the documentation about the draw statement to know more about.species name:my_species {\taspect name:standard_aspect {\t\tdraw geometry:circle(1) color:#blue;\t}}In the experiment scope, you have to tell the program to display a particular species with a particular aspect (nb : you can also choose to display your species with several aspect in the same display).experiment my_experiment type:gui{\toutput{\t\tdisplay my_display {\t\t\tspecies my_species aspect:standard_aspect;\t\t}\t}}Now there is only one thing missing to display our agent: we have to instantiate them.Instantiate an agentAs already said quickly in the last session, the instantiation of the agents is most often in the init scope of the global species (this is not mandatory of course. You can instantiate your agents from an action / behavior of any specie). Use the statement create to instantiate an agent. The facet species is used to specify which species you want to instantiate. The facet number is used to tell how many instantiation you want. The facet with is used to specify some default values for some attributes of your instance. For example, you can specify the location.global{\tinit{\t\tcreate species:my_species number:1 with:(location:{0,0},vA:8);\t}}species name:my_specie {\tint vA;}Here is an example of model that display an agent with a circle aspect in the center of the environment:model display_one_agentglobal{\tfloat worldDimension &lt;- 50#m;\tgeometry shape &lt;- square(worldDimension);\tinit{\t\tpoint center &lt;- {(worldDimension/2),(worldDimension/2)};\t\tcreate species:my_species number:1 with:(location:center);\t}}species name:my_species {\taspect name:standard_aspect {\t\tdraw geometry:circle(1#m);\t}}experiment my_experiment type:gui{\toutput{\t\tdisplay myDisplay {\t\t\tspecies my_species aspect:standard_aspect;\t\t}\t}}",
        "url":"/wiki/RegularSpecies.html"
      }
      ,
    
      "wiki-road-traffic-model-01-html": {
        "title": "Loading of GIS data (buildings and roads)",
        "content": "Loading of GIS data (buildings and roads)first part of the tutorial: Road TrafficCode of the model :model tutorial_gis_city_trafficglobal {\tfile buildings_shapefile &lt;- file(\"../includes/building.shp\");\tfile roads_shapefile &lt;- file(\"../includes/road.shp\");\tgeometry shape &lt;- envelope(envelope(buildings_shapefile) + envelope(roads_shapefile));\tfloat step &lt;- 10 #mn;\t\tinit {\t\tcreate building from: buildings_shapefile ;\t\tcreate road from: roads_shapefile ;\t}}species building {\tstring type; \trgb color &lt;- #gray  ;\t\taspect base {\t\tdraw shape color: color ;\t}}species road  {\trgb color &lt;- #red ;\taspect base {\t\tdraw shape color: color ;\t}}experiment road_traffic type: gui {\t\t\toutput {\t\tdisplay city_display type:opengl {\t\t\tspecies building aspect: base ;\t\t\tspecies road aspect: base ;\t\t}\t}}",
        "url":"/wiki/Road-Traffic-Model-01.html"
      }
      ,
    
      "wiki-road-traffic-model-02-html": {
        "title": "Definition of people agents",
        "content": "Definition of people agentssecond part of the tutorial: Road TrafficCode of the model :model tutorial_gis_city_trafficglobal {\tfile shape_file_buildings &lt;- file(\"../includes/building.shp\");\tfile shape_file_roads &lt;- file(\"../includes/road.shp\");\tfile shape_file_bounds &lt;- file(\"../includes/bounds.shp\");\tgeometry shape &lt;- envelope(shape_file_bounds);\tfloat step &lt;- 10 #mn;\tint nb_people &lt;- 100;\t\tinit {\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\t\t\tif type=\"Industrial\" {\t\t\t\tcolor &lt;- #blue ;\t\t\t}\t\t}\t\tcreate road from: shape_file_roads ;\t\tlist&lt;building&gt; residential_buildings &lt;- building where (each.type=\"Residential\");\t\tcreate people number: nb_people {\t\t\tlocation &lt;- any_location_in (one_of (residential_buildings));\t\t}\t}}species building {\tstring type; \trgb color &lt;- #gray  ;\t\taspect base {\t\tdraw shape color: color ;\t}}species road  {\trgb color &lt;- #black ;\taspect base {\t\tdraw shape color: color ;\t}}species people {\trgb color &lt;- #yellow ;\t\taspect base {\t\tdraw circle(10) color: color;\t}}experiment road_traffic type: gui {\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\t\toutput {\t\tdisplay city_display type:opengl {\t\t\tspecies building aspect: base ;\t\t\tspecies road aspect: base ;\t\t\tspecies people aspect: base ;\t\t}\t}}",
        "url":"/wiki/Road-Traffic-Model-02.html"
      }
      ,
    
      "wiki-road-traffic-model-03-html": {
        "title": "Movement of the people agents",
        "content": "Movement of the people agentsthird part of the tutorial: Road TrafficCode of the model :model tutorial_gis_city_trafficglobal {\tfile shape_file_buildings &lt;- file(\"../includes/building.shp\");\tfile shape_file_roads &lt;- file(\"../includes/road.shp\");\tfile shape_file_bounds &lt;- file(\"../includes/bounds.shp\");\tgeometry shape &lt;- envelope(shape_file_bounds);\tfloat step &lt;- 10 #mn;\tint nb_people &lt;- 100;\tint current_hour update: (time / #hour) mod 24;\tint min_work_start &lt;- 6;\tint max_work_start &lt;- 8;\tint min_work_end &lt;- 16; \tint max_work_end &lt;- 20; \tfloat min_speed &lt;- 1.0 #km / #h;\tfloat max_speed &lt;- 5.0 #km / #h; \tgraph the_graph;\t\tinit {\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\t\t\tif type=\"Industrial\" {\t\t\t\tcolor &lt;- #blue ;\t\t\t}\t\t}\t\tcreate road from: shape_file_roads ;\t\tthe_graph &lt;- as_edge_graph(road);\t\t\t\t\t\tlist&lt;building&gt; residential_buildings &lt;- building where (each.type=\"Residential\");\t\tlist&lt;building&gt;  industrial_buildings &lt;- building  where (each.type=\"Industrial\") ;\t\tcreate people number: nb_people {\t\t\tspeed &lt;- min_speed + rnd (max_speed - min_speed) ;\t\t\tstart_work &lt;- min_work_start + rnd (max_work_start - min_work_start) ;\t\t\tend_work &lt;- min_work_end + rnd (max_work_end - min_work_end) ;\t\t\tliving_place &lt;- one_of(residential_buildings) ;\t\t\tworking_place &lt;- one_of(industrial_buildings) ;\t\t\tobjective &lt;- \"resting\";\t\t\tlocation &lt;- any_location_in (living_place); \t\t}\t}}species building {\tstring type; \trgb color &lt;- #gray  ;\t\taspect base {\t\tdraw shape color: color ;\t}}species road  {\trgb color &lt;- #black ;\taspect base {\t\tdraw shape color: color ;\t}}species people skills:[moving] {\trgb color &lt;- #yellow ;\tbuilding living_place &lt;- nil ;\tbuilding working_place &lt;- nil ;\tint start_work ;\tint end_work  ;\tstring objective ; \tpoint the_target &lt;- nil ;\t\t\treflex time_to_work when: current_hour = start_work and objective = \"resting\"{\t\tobjective &lt;- \"working\" ;\t\tthe_target &lt;- any_location_in (working_place);\t}\t\t\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\t\tobjective &lt;- \"resting\" ;\t\tthe_target &lt;- any_location_in (living_place); \t} \t \treflex move when: the_target != nil {\t\tdo goto target: the_target on: the_graph ; \t\tif the_target = location {\t\t\tthe_target &lt;- nil ;\t\t}\t}\t\taspect base {\t\tdraw circle(10) color: color;\t}}experiment road_traffic type: gui {\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 50 #km/#h;\t\toutput {\t\tdisplay city_display type: opengl {\t\t\tspecies building aspect: base refresh: false;\t\t\tspecies road aspect: base refresh: false;\t\t\tspecies people aspect: base ;\t\t}\t}}",
        "url":"/wiki/Road-Traffic-Model-03.html"
      }
      ,
    
      "wiki-road-traffic-model-04-html": {
        "title": "Definition of weight for the road network",
        "content": "Definition of weight for the road network4th part of the tutorial: Road TrafficCode of the model :model tutorial_gis_city_trafficglobal {\tfile shape_file_buildings &lt;- file(\"../includes/building.shp\");\tfile shape_file_roads &lt;- file(\"../includes/road.shp\");\tfile shape_file_bounds &lt;- file(\"../includes/bounds.shp\");\tgeometry shape &lt;- envelope(shape_file_bounds);\tfloat step &lt;- 10 #mn;\tint nb_people &lt;- 100;\tint current_hour update: (time / #hour) mod 24;\tint min_work_start &lt;- 6;\tint max_work_start &lt;- 8;\tint min_work_end &lt;- 16; \tint max_work_end &lt;- 20; \tfloat min_speed &lt;- 1.0 #km / #h;\tfloat max_speed &lt;- 5.0 #km / #h; \tgraph the_graph;\t\tinit {\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\t\t\tif type=\"Industrial\" {\t\t\t\tcolor &lt;- #blue ;\t\t\t}\t\t}\t\tcreate road from: shape_file_roads ;\t\tmap&lt;road,float&gt; weights_map &lt;- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\t\tthe_graph &lt;- as_edge_graph(road) with_weights weights_map;\t\t\t\t\t\tlist&lt;building&gt; residential_buildings &lt;- building where (each.type=\"Residential\");\t\tlist&lt;building&gt;  industrial_buildings &lt;- building  where (each.type=\"Industrial\") ;\t\tcreate people number: nb_people {\t\t\tspeed &lt;- min_speed + rnd (max_speed - min_speed) ;\t\t\tstart_work &lt;- min_work_start + rnd (max_work_start - min_work_start) ;\t\t\tend_work &lt;- min_work_end + rnd (max_work_end - min_work_end) ;\t\t\tliving_place &lt;- one_of(residential_buildings) ;\t\t\tworking_place &lt;- one_of(industrial_buildings) ;\t\t\tobjective &lt;- \"resting\";\t\t\tlocation &lt;- any_location_in (living_place); \t\t}\t}}species building {\tstring type; \trgb color &lt;- #gray  ;\t\taspect base {\t\tdraw shape color: color ;\t}}species road  {\tfloat destruction_coeff &lt;- 1 + ((rnd(100))/ 100.0) max: 2.0;\tint colorValue &lt;- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\trgb color &lt;- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\t\taspect base {\t\tdraw shape color: color ;\t}}species people skills:[moving] {\trgb color &lt;- #yellow ;\tbuilding living_place &lt;- nil ;\tbuilding working_place &lt;- nil ;\tint start_work ;\tint end_work  ;\tstring objective ; \tpoint the_target &lt;- nil ;\t\t\treflex time_to_work when: current_hour = start_work and objective = \"resting\"{\t\tobjective &lt;- \"working\" ;\t\tthe_target &lt;- any_location_in (working_place);\t}\t\t\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\t\tobjective &lt;- \"resting\" ;\t\tthe_target &lt;- any_location_in (living_place); \t} \t \treflex move when: the_target != nil {\t\tdo goto target: the_target on: the_graph ; \t\tif the_target = location {\t\t\tthe_target &lt;- nil ;\t\t}\t}\t\taspect base {\t\tdraw circle(10) color: color;\t}}experiment road_traffic type: gui {\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\t\toutput {\t\tdisplay city_display type:opengl {\t\t\tspecies building aspect: base ;\t\t\tspecies road aspect: base ;\t\t\tspecies people aspect: base ;\t\t}\t}}",
        "url":"/wiki/Road-Traffic-Model-04.html"
      }
      ,
    
      "wiki-road-traffic-model-05-html": {
        "title": "Dynamic update of the road network",
        "content": "Dynamic update of the road network5th part of the tutorial: Road TrafficCode of the model :model tutorial_gis_city_trafficglobal {\tfile shape_file_buildings &lt;- file(\"../includes/building.shp\");\tfile shape_file_roads &lt;- file(\"../includes/road.shp\");\tfile shape_file_bounds &lt;- file(\"../includes/bounds.shp\");\tgeometry shape &lt;- envelope(shape_file_bounds);\tfloat step &lt;- 10 #mn;\tint nb_people &lt;- 100;\tint current_hour update: (time / #hour) mod 24;\tint min_work_start &lt;- 6;\tint max_work_start &lt;- 8;\tint min_work_end &lt;- 16; \tint max_work_end &lt;- 20; \tfloat min_speed &lt;- 1.0 #km / #h;\tfloat max_speed &lt;- 5.0 #km / #h; \tfloat destroy &lt;- 0.02;\tgraph the_graph;\t\tinit {\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\t\t\tif type=\"Industrial\" {\t\t\t\tcolor &lt;- #blue ;\t\t\t}\t\t}\t\tcreate road from: shape_file_roads ;\t\tmap&lt;road,float&gt; weights_map &lt;- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\t\tthe_graph &lt;- as_edge_graph(road) with_weights weights_map;\t\t\t\t\t\tlist&lt;building&gt; residential_buildings &lt;- building where (each.type=\"Residential\");\t\tlist&lt;building&gt;  industrial_buildings &lt;- building  where (each.type=\"Industrial\") ;\t\tcreate people number: nb_people {\t\t\tspeed &lt;- min_speed + rnd (max_speed - min_speed) ;\t\t\tstart_work &lt;- min_work_start + rnd (max_work_start - min_work_start) ;\t\t\tend_work &lt;- min_work_end + rnd (max_work_end - min_work_end) ;\t\t\tliving_place &lt;- one_of(residential_buildings) ;\t\t\tworking_place &lt;- one_of(industrial_buildings) ;\t\t\tobjective &lt;- \"resting\";\t\t\tlocation &lt;- any_location_in (living_place); \t\t}\t}\t\treflex update_graph{\t\tmap&lt;road,float&gt; weights_map &lt;- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\t\tthe_graph &lt;- the_graph with_weights weights_map;\t}}species building {\tstring type; \trgb color &lt;- #gray  ;\t\taspect base {\t\tdraw shape color: color ;\t}}species road  {\tfloat destruction_coeff &lt;- 1 + ((rnd(100))/ 100.0) max: 2.0;\tint colorValue &lt;- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\trgb color &lt;- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\t\taspect base {\t\tdraw shape color: color ;\t}}species people skills:[moving] {\trgb color &lt;- #yellow ;\tbuilding living_place &lt;- nil ;\tbuilding working_place &lt;- nil ;\tint start_work ;\tint end_work  ;\tstring objective ; \tpoint the_target &lt;- nil ;\t\t\treflex time_to_work when: current_hour = start_work and objective = \"resting\"{\t\tobjective &lt;- \"working\" ;\t\tthe_target &lt;- any_location_in (working_place);\t}\t\t\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\t\tobjective &lt;- \"resting\" ;\t\tthe_target &lt;- any_location_in (living_place); \t} \t \treflex move when: the_target != nil {\t\tpath path_followed &lt;- self goto [target::the_target, on::the_graph, return_path:: true];\t\tlist&lt;geometry&gt; segments &lt;- path_followed.segments;\t\tloop line over: segments {\t\t\tfloat dist &lt;- line.perimeter;\t\t\task road(path_followed agent_from_geometry line) { \t\t\t\tdestruction_coeff &lt;- destruction_coeff + (destroy * dist / shape.perimeter);\t\t\t}\t\t}\t\tif the_target = location {\t\t\tthe_target &lt;- nil ;\t\t}\t}\t\taspect base {\t\tdraw circle(10) color: color;\t}}experiment road_traffic type: gui {\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\tparameter \"Value of destruction when a people agent takes a road\" var: destroy category: \"Road\" ;\toutput {\t\tdisplay city_display type:opengl {\t\t\tspecies building aspect: base ;\t\t\tspecies road aspect: base ;\t\t\tspecies people aspect: base ;\t\t}\t}}",
        "url":"/wiki/Road-Traffic-Model-05.html"
      }
      ,
    
      "wiki-road-traffic-model-06-html": {
        "title": "Definition of a chart display",
        "content": "Definition of a chart display6th part of the tutorial: Road TrafficCode of the model :model tutorial_gis_city_trafficglobal {\tfile shape_file_buildings &lt;- file(\"../includes/building.shp\");\tfile shape_file_roads &lt;- file(\"../includes/road.shp\");\tfile shape_file_bounds &lt;- file(\"../includes/bounds.shp\");\tgeometry shape &lt;- envelope(shape_file_bounds);\tfloat step &lt;- 10 #mn;\tint nb_people &lt;- 100;\tint current_hour update: (time / #hour) mod 24;\tint min_work_start &lt;- 6;\tint max_work_start &lt;- 8;\tint min_work_end &lt;- 16; \tint max_work_end &lt;- 20; \tfloat min_speed &lt;- 1.0 #km / #h;\tfloat max_speed &lt;- 5.0 #km / #h; \tfloat destroy &lt;- 0.02;\tgraph the_graph;\t\tinit {\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\t\t\tif type=\"Industrial\" {\t\t\t\tcolor &lt;- #blue ;\t\t\t}\t\t}\t\tcreate road from: shape_file_roads ;\t\tmap&lt;road,float&gt; weights_map &lt;- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\t\tthe_graph &lt;- as_edge_graph(road) with_weights weights_map;\t\t\t\t\t\tlist&lt;building&gt; residential_buildings &lt;- building where (each.type=\"Residential\");\t\tlist&lt;building&gt;  industrial_buildings &lt;- building  where (each.type=\"Industrial\") ;\t\tcreate people number: nb_people {\t\t\tspeed &lt;- min_speed + rnd (max_speed - min_speed) ;\t\t\tstart_work &lt;- min_work_start + rnd (max_work_start - min_work_start) ;\t\t\tend_work &lt;- min_work_end + rnd (max_work_end - min_work_end) ;\t\t\tliving_place &lt;- one_of(residential_buildings) ;\t\t\tworking_place &lt;- one_of(industrial_buildings) ;\t\t\tobjective &lt;- \"resting\";\t\t\tlocation &lt;- any_location_in (living_place); \t\t}\t}\t\treflex update_graph{\t\tmap&lt;road,float&gt; weights_map &lt;- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\t\tthe_graph &lt;- the_graph with_weights weights_map;\t}}species building {\tstring type; \trgb color &lt;- #gray  ;\t\taspect base {\t\tdraw shape color: color ;\t}}species road  {\tfloat destruction_coeff &lt;- 1 + ((rnd(100))/ 100.0) max: 2.0;\tint colorValue &lt;- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\trgb color &lt;- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\t\taspect base {\t\tdraw shape color: color ;\t}}species people skills:[moving] {\trgb color &lt;- #yellow ;\tbuilding living_place &lt;- nil ;\tbuilding working_place &lt;- nil ;\tint start_work ;\tint end_work  ;\tstring objective ; \tpoint the_target &lt;- nil ;\t\t\treflex time_to_work when: current_hour = start_work and objective = \"resting\"{\t\tobjective &lt;- \"working\" ;\t\tthe_target &lt;- any_location_in (working_place);\t}\t\t\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\t\tobjective &lt;- \"resting\" ;\t\tthe_target &lt;- any_location_in (living_place); \t} \t \treflex move when: the_target != nil {\t\tpath path_followed &lt;- self goto [target::the_target, on::the_graph, return_path:: true];\t\tlist&lt;geometry&gt; segments &lt;- path_followed.segments;\t\tloop line over: segments {\t\t\tfloat dist &lt;- line.perimeter;\t\t\task road(path_followed agent_from_geometry line) { \t\t\t\tdestruction_coeff &lt;- destruction_coeff + (destroy * dist / shape.perimeter);\t\t\t}\t\t}\t\tif the_target = location {\t\t\tthe_target &lt;- nil ;\t\t}\t}\t\taspect base {\t\tdraw circle(10) color: color;\t}}experiment road_traffic type: gui {\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\tparameter \"Value of destruction when a people agent takes a road\" var: destroy category: \"Road\" ;\toutput {\t\tdisplay city_display type:opengl {\t\t\tspecies building aspect: base ;\t\t\tspecies road aspect: base ;\t\t\tspecies people aspect: base ;\t\t}\t\tdisplay chart_display refresh: every(10) { \t\t\tchart \"Road Status\" type: series size: {1, 0.5} position: {0, 0} {\t\t\t\tdata \"Mean road destruction\" value: mean (road collect each.destruction_coeff) style: line color: #green ;\t\t\t\tdata \"Max road destruction\" value: road max_of each.destruction_coeff style: line color: #red ;\t\t\t}\t\t\tchart \"People Objectif\" type: pie style: exploded size: {1, 0.5} position: {0, 0.5}{\t\t\t\tdata \"Working\" value: people count (each.objective=\"working\") color: #magenta ;\t\t\t\tdata \"Resting\" value: people count (each.objective=\"resting\") color: #blue ;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Road-Traffic-Model-06.html"
      }
      ,
    
      "wiki-road-traffic-model-07-html": {
        "title": "Automatic repair of roads",
        "content": "Automatic repair of roads7th part of the tutorial: Road TrafficCode of the model :model tutorial_gis_city_trafficglobal {\tfile shape_file_buildings &lt;- file(\"../includes/building.shp\");\tfile shape_file_roads &lt;- file(\"../includes/road.shp\");\tfile shape_file_bounds &lt;- file(\"../includes/bounds.shp\");\tgeometry shape &lt;- envelope(shape_file_bounds);\tfloat step &lt;- 10 #mn;\tint nb_people &lt;- 100;\tint current_hour update: (time / #hour) mod 24;\tint min_work_start &lt;- 6;\tint max_work_start &lt;- 8;\tint min_work_end &lt;- 16; \tint max_work_end &lt;- 20; \tfloat min_speed &lt;- 1.0 #km / #h;\tfloat max_speed &lt;- 5.0 #km / #h; \tfloat destroy &lt;- 0.02;\tint repair_time &lt;- 2 ;\tgraph the_graph;\t\tinit {\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\t\t\tif type=\"Industrial\" {\t\t\t\tcolor &lt;- #blue ;\t\t\t}\t\t}\t\tcreate road from: shape_file_roads ;\t\tmap&lt;road,float&gt; weights_map &lt;- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\t\tthe_graph &lt;- as_edge_graph(road) with_weights weights_map;\t\t\t\t\t\tlist&lt;building&gt; residential_buildings &lt;- building where (each.type=\"Residential\");\t\tlist&lt;building&gt;  industrial_buildings &lt;- building  where (each.type=\"Industrial\") ;\t\tcreate people number: nb_people {\t\t\tspeed &lt;- min_speed + rnd (max_speed - min_speed) ;\t\t\tstart_work &lt;- min_work_start + rnd (max_work_start - min_work_start) ;\t\t\tend_work &lt;- min_work_end + rnd (max_work_end - min_work_end) ;\t\t\tliving_place &lt;- one_of(residential_buildings) ;\t\t\tworking_place &lt;- one_of(industrial_buildings) ;\t\t\tobjective &lt;- \"resting\";\t\t\tlocation &lt;- any_location_in (living_place); \t\t}\t}\t\treflex update_graph{\t\tmap&lt;road,float&gt; weights_map &lt;- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\t\tthe_graph &lt;- the_graph with_weights weights_map;\t}\treflex repair_road when: every(repair_time #hour / step) {\t\troad the_road_to_repair &lt;- road with_max_of (each.destruction_coeff) ;\t\task the_road_to_repair {\t\t\tdestruction_coeff &lt;- 1.0 ;\t\t}\t}}species building {\tstring type; \trgb color &lt;- #gray  ;\t\taspect base {\t\tdraw shape color: color ;\t}}species road  {\tfloat destruction_coeff &lt;- 1 + ((rnd(100))/ 100.0) max: 2.0;\tint colorValue &lt;- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\trgb color &lt;- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\t\taspect base {\t\tdraw shape color: color ;\t}}species people skills:[moving] {\trgb color &lt;- #yellow ;\tbuilding living_place &lt;- nil ;\tbuilding working_place &lt;- nil ;\tint start_work ;\tint end_work  ;\tstring objective ; \tpoint the_target &lt;- nil ;\t\t\treflex time_to_work when: current_hour = start_work and objective = \"resting\"{\t\tobjective &lt;- \"working\" ;\t\tthe_target &lt;- any_location_in (working_place);\t}\t\t\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\t\tobjective &lt;- \"resting\" ;\t\tthe_target &lt;- any_location_in (living_place); \t} \t \treflex move when: the_target != nil {\t\tpath path_followed &lt;- self goto [target::the_target, on::the_graph, return_path:: true];\t\tlist&lt;geometry&gt; segments &lt;- path_followed.segments;\t\tloop line over: segments {\t\t\tfloat dist &lt;- line.perimeter;\t\t\task road(path_followed agent_from_geometry line) { \t\t\t\tdestruction_coeff &lt;- destruction_coeff + (destroy * dist / shape.perimeter);\t\t\t}\t\t}\t\tif the_target = location {\t\t\tthe_target &lt;- nil ;\t\t}\t}\t\taspect base {\t\tdraw circle(10) color: color;\t}}experiment road_traffic type: gui {\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\tparameter \"Value of destruction when a people agent takes a road\" var: destroy category: \"Road\" ;\tparameter \"Number of hours between two road repairs\" var: repair_time category: \"Road\" ;\t\toutput {\t\tdisplay city_display type:opengl {\t\t\tspecies building aspect: base ;\t\t\tspecies road aspect: base ;\t\t\tspecies people aspect: base ;\t\t}\t\tdisplay chart_display refresh: every(10) { \t\t\tchart \"Road Status\" type: series size: {1, 0.5} position: {0, 0} {\t\t\t\tdata \"Mean road destruction\" value: mean (road collect each.destruction_coeff) style: line color: #green ;\t\t\t\tdata \"Max road destruction\" value: road max_of each.destruction_coeff style: line color: #red ;\t\t\t}\t\t\tchart \"People Objectif\" type: pie style: exploded size: {1, 0.5} position: {0, 0.5}{\t\t\t\tdata \"Working\" value: people count (each.objective=\"working\") color: #magenta ;\t\t\t\tdata \"Resting\" value: people count (each.objective=\"resting\") color: #blue ;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Road-Traffic-Model-07.html"
      }
      ,
    
      "wiki-road-traffic-html": {
        "title": "Road Traffic",
        "content": "Road TrafficThis sub-section is composed of the following models :      Loading of GIS data (buildings and roads)        Definition of people agents        Movement of the people agents        Definition of weight for the road network        Dynamic update of the road network        Definition of a chart display        Automatic repair of roads  ",
        "url":"/wiki/Road-Traffic.html"
      }
      ,
    
      "wiki-roadtrafficmodel-html": {
        "title": "Road Traffic",
        "content": "Road TrafficThis tutorial has for goal to present the use of GIS data and complex geometries. In particular, this tutorial shows how to load gis data, to agentify them and to use a network of polylines to constraint the movement of agents. All the files related to this tutorial (shapefiles and models) are available in the Models Library (project road_traffic_tutorial).If you are not familiar with agent-based models or GAMA we advice you to have a look at the prey-predator model first.Model OverviewThe model built in this tutorial concerns the study of the road traffic in a small city. Two layers of GIS data are used: a road layer (polylines) and a building layer (polygons). The building GIS data contain an attribute: the ‘NATURE’ of each building: a building can be either ‘Residential’ or ‘Industrial’. In this model, people agents are moving along the road network. Each morning, they are going to an industrial building to work, and each night they are coming back home. Each time a people agent takes a road, it wears it out. More a road is worn out, more a people agent takes time to go all over it. The town council is able to repair some roads.Step ListThis tutorial is composed of 7 steps corresponding to 7 models. For each step we present its purpose, an explicit formulation and the corresponding GAML code.  Loading of GIS data (buildings and roads)  Definition of people agents  Movement of the people agents  Definition of weight for the road network  Dynamic update of the road network  Definition of a chart display  Automatic repair of roads",
        "url":"/wiki/RoadTrafficModel.html"
      }
      ,
    
      "wiki-roadtrafficmodel-step1-html": {
        "title": "1. Loading of GIS Data",
        "content": "1. Loading of GIS DataThis first step Illustrates how to load GIS data (shapefiles) and to read attributes from GIS data.Formulation  Set the time duration of a time step to 10 minutes  Load, agentify and display two layers of GIS data (building and road). Agentifying a GIS element will allow us to give it a behavior later on (thus not being simply a static/passive object).  Read the ‘NATURE’ attribute of the building data: the buildings of ‘Residential’ type will be colored in gray, the buildings of ‘Industrial’ type will be color in blue.Model DefinitionspeciesIn this first model, we have to define two species of agents: the building agents and the road ones. These agents will not have a particular behavior, they will just be displayed.For each of these species, we define a new attribute: color of type rgb, with for initial value: “black” for the road agent and “gray” (by default) for the building agent.Concerning the building agent, we define a second attribute named type representing the type of the building (“Residential” or “Industrial”).At last, we define an aspect for these species. In this model, we want to represent the geometry of the agent, we then use the keyword draw that allow to draw a given geometry. In order to draw the geometry of the agent we use the attribute shape (which is a built-in attribute of all agents).species building {\tstring type; \trgb color &lt;- #gray  ;\t\taspect base {\t\tdraw shape color: color ;\t}}species road  {\trgb color &lt;- #black ;\t        aspect base {\t\tdraw shape color: color ;\t}}parametersGAMA allows to automatically read GIS data that are formatted as shapefiles. In order to let the user chooses his/her shapefiles, we define three parameters. One allowing the user to choose the road shapefile, one allowing him/her to choose the building shapefile, and, at last, one allowing him/her to choose the bounds shapefile. We will come back later on the notion of “bounds” in GAMA.Definition of the three global variables of type file concerning the GIS files:global {   file shape_file_buildings &lt;- file(\"../includes/building.shp\");   file shape_file_roads &lt;- file(\"../includes/road.shp\");   file shape_file_bounds &lt;- file(\"../includes/bounds.shp\");}In the experiment section, we add three parameters to allow the user to change the shapefile used directly through the UI:experiment road_traffic type: gui {   parameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;   parameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;   parameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;}agentification of GIS dataIn GAMA, the agentification of GIS data is very straightforward: it only requires to use the create command with the from facet to pass the shapefile. Each object of the shapefile will be directly used to instantiate an agent of the specified species. The reading of an attribute in a shapefile is also very simple. It only requires to use the with facet: the argument of this facet is a dictionary of which the keys are the names of the agent attributes and the value the read command followed by the name of the shapefile attribute (“NATURE” in our case).Init section of the global block: creation of the road and building agents from the shape files. Concerning the building agents, reading of the “NATURE” attribute of the shapefile to initiate the value of the type attribute. If the type attribute is equal to “Industrial” set the color attribute to “blue”.global {  ...  init {   create building from: shape_file_buildings with: [type::read (\"NATURE\")] {      if type=\"Industrial\" {         color &lt;- #blue ;      }   }   create road from: shape_file_roads ;  } time stepIn GAMA, by default, a time step represents 1 second. It is possible to redefine this value by overriding the step global variable. This value of the time step is used by the moving primitives of GAMA.In our model, we define that a step represent 10 minutes. Note that it is possible to define the unit of a value by using # + unit name. For instance, #mn or #km for kilometers.global {  ...  float step &lt;- 10 #mn;  ...}environmentBuilding a GIS environment in GAMA requires nothing special, just to define the bounds of the environment, i.e. the geometry of the world agent. It is possible to use a shapefile to automatically define it by computing its envelope. In this model, we use a specific shapefile to define it. However, it would been possible to use the road shapefile to define it and let GAMA computes it enveloppe automatically.global {  ...  geometry shape &lt;- envelope(shape_file_bounds);   ...}displayWe define a display to visualize the road and building agents. We use for that the classic species keyword. In order to optimize the display we use an opengl display (facet type: opengl).In the experiment block:output {   display city_display type:opengl {      species building aspect: base ;      species road aspect: base ;   }}Complete Modelmodel tutorial_gis_city_trafficglobal {\tfile shape_file_buildings &lt;- file(\"../includes/building.shp\");\tfile shape_file_roads &lt;- file(\"../includes/road.shp\");\tfile shape_file_bounds &lt;- file(\"../includes/bounds.shp\");\tgeometry shape &lt;- envelope(shape_file_bounds);\tfloat step &lt;- 10 #mn;\t\tinit {\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\t\t\tif type=\"Industrial\" {\t\t\t\tcolor &lt;- #blue ;\t\t\t}\t\t}\t\tcreate road from: shape_file_roads ;\t}}species building {\tstring type; \trgb color &lt;- #gray  ;\t\taspect base {\t\tdraw shape color: color ;\t}}species road  {\trgb color &lt;- #black ;\taspect base {\t\tdraw shape color: color ;\t}}experiment road_traffic type: gui {\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\t\toutput {\t\tdisplay city_display type:opengl {\t\t\tspecies building aspect: base ;\t\t\tspecies road aspect: base ;\t\t}\t}}",
        "url":"/wiki/RoadTrafficModel_step1.html"
      }
      ,
    
      "wiki-roadtrafficmodel-step2-html": {
        "title": "2. People Agents",
        "content": "2. People AgentsThis second step Illustrates how to obtain a random point inside a geometry. We will also define some moving agent called people.Formulation  Define a new species of agents: the people agents. The people agents have a point for geometry and are represented by a yellow circle of radius 10m.  At initialization, 100 people agents are created. Each people agent is placed inside a building of type ‘Residential’ (randomly selected).Model DefinitionspeciesWe define a new species of agents: the people agents. In this model, these agents will not have a specific behavior yet. They will be just displayed. Thus, we just have to define an aspect for the agents. We want to represent the people agents by a yellow circle of radius 10m. We then use the circle value for the shape facet of the draw command, with the expected color and radius size (defined by the facet size).species people {\trgb color &lt;- #yellow ;\t\taspect base {\t\tdraw circle(10) color: color;\t}}parameterWe have to add a new parameter: the number of people agents createdIn the global section, definition of the nb_people variable:   int nb_people &lt;- 100;In the experiment section, definition of the parameter:   parameter \"Number of people agents\" var: nb_people category: \"People\" ;creation and placement of the people agentsWe have to create nb_people people agents. Each people is placed in a buildings of type ‘Residential’ randomly selected. In order to simplify the GAML code, we defined a local variable residential_buildings that represent the list of buildings of type ‘Residential’. To filter the list of building agents (obtained by building), we use the where operator. We use the operator one_of to randomly select one agent of this list. There are several ways to place a people agent inside this building. In this tutorial, we choose to use the any_location_in operator. This operator returns a random point situated inside the operand geometry.global {\t...\tinit {\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\t\t\tif type=\"Industrial\" {\t\t\t\tcolor &lt;- #blue ;\t\t\t}\t\t}\t\tcreate road from: shape_file_roads ;\t\tlist&lt;building&gt; residential_buildings &lt;- building where (each.type=\"Residential\");\t\tcreate people number: nb_people {\t\t\tlocation &lt;- any_location_in (one_of (residential_buildings));\t\t}\t}}displayWe add the people agent in the defined display.   output {      display city_display {         species building aspect: base ;         species road aspect: base ;         species people aspect: base ;      }   }Complete Modelmodel tutorial_gis_city_trafficglobal {\tfile shape_file_buildings &lt;- file(\"../includes/building.shp\");\tfile shape_file_roads &lt;- file(\"../includes/road.shp\");\tfile shape_file_bounds &lt;- file(\"../includes/bounds.shp\");\tgeometry shape &lt;- envelope(shape_file_bounds);\tfloat step &lt;- 10 #mn;\tint nb_people &lt;- 100;\t\tinit {\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\t\t\tif type=\"Industrial\" {\t\t\t\tcolor &lt;- #blue ;\t\t\t}\t\t}\t\tcreate road from: shape_file_roads ;\t\tlist&lt;building&gt; residential_buildings &lt;- building where (each.type=\"Residential\");\t\tcreate people number: nb_people {\t\t\tlocation &lt;- any_location_in (one_of (residential_buildings));\t\t}\t}}species building {\tstring type; \trgb color &lt;- #gray  ;\t\taspect base {\t\tdraw shape color: color ;\t}}species road  {\trgb color &lt;- #black ;\taspect base {\t\tdraw shape color: color ;\t}}species people {\trgb color &lt;- #yellow ;\t\taspect base {\t\tdraw circle(10) color: color;\t}}experiment road_traffic type: gui {\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\t\toutput {\t\tdisplay city_display type:opengl {\t\t\tspecies building aspect: base ;\t\t\tspecies road aspect: base ;\t\t\tspecies people aspect: base ;\t\t}\t}}",
        "url":"/wiki/RoadTrafficModel_step2.html"
      }
      ,
    
      "wiki-roadtrafficmodel-step3-html": {
        "title": "3. Movement of People",
        "content": "3. Movement of PeopleThis third step presents how to create a road system from GIS data. More precisely, it shows how to build a graph from a list of polylines and to constrain the movement of an agent according to this graph.Formulation  Definition of day_time global variable that will indicate, according to the simulation step, the time of the day: each simulation step will represent 10 minutes, then the day_time variable will be ranged between 0 and 144.  For each people agent: define a living_place(building of type ‘Residential’) and working place (building of type ‘Industrial’).  For each people agent: define start_work and end_work hours that respectively represent when the agent leaves its house to go to work and when it leaves its working_place to go back home. These hours will be randomly define between 36 (6 a.m;) and 60 (10 a.m.) for the start_work and 84 (2p.m.) and 132 (10p.m.) for the end_work.  For each people agent: define a objective variable: this one can ‘go home’ or ‘working’.  For each people agent: define a speed. The speed will be randomly define between 50 and 100.  The people agents move along the road, taking the shortest path.Model Definitionpeople agentsFirst, we have to change the skill of the people agents: as we want to use an action of the moving skill (goto), we will provide the people agents with this skill. A skill is a built-in module that provide the modeler a self-contain and relevant set of actions and variables.   species people skills: [moving]{       ...   }Then, we have to add new variables to the people agents: living_place, working_place, start_work, end_work, objective. In addition, we will add a “the_target” variable that will represents the point toward which the agent will be currently moving.   species people skills: [moving]{\trgb color &lt;- #yellow ;\tbuilding living_place &lt;- nil ;\tbuilding working_place &lt;- nil ;\tint start_work ;\tint end_work  ;\tstring objective ; \tpoint the_target &lt;- nil ;             ...   }We define two reflex methods that allow to change the objective (and the_target) of the agent at the start_work and en_work hours. Concerning the target value, we choose a random point in the objective building (working_place or living_place) by using the any_location_in operator.   species people skills: [moving]{        ...      reflex time_to_work when: current_hour = start_work and objective = \"resting\"{           objective &lt;- \"working\" ;\t   the_target &lt;- any_location_in (working_place);      }\t\t      reflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\t   objective &lt;- \"resting\" ;\t   the_target &lt;- any_location_in (living_place);       }       ...  }At last, we define a reflex method that allows the agent to move. If a target point is defined (the_target != nil), the agent moves in direction to its target using the goto action (provided by the moving skill). Note that we specified a graph to constraint the movement of the agents on the road network with the facet on. We will see later how this graph is built. The agent uses the shortest path (according to the graph) to go to the target point. When the agent arrives at destination (the_target = location), the target is set to nil (the agent will stop moving).  species people skills: [moving]{      ...      reflex move when: the_target != nil {\t  do goto target: the_target on: the_graph ; \t  if the_target = location {\t\tthe_target &lt;- nil ;\t  }     }  }parametersWe add several parameters (min_work_start, max_work_start, min_work_end, max_work_end, min_speed and max_speed) and two global variables: the_graph (graph computed from the road network) and current_hour (current hour of the day). The value of the current_hour variable is automatically computed at each simulation step and is equals to “(time(the simulation step step) / 1 hour) modulo 24”.In the global section:global {        ...        int current_hour update: (time / #hour) mod 24;\tint min_work_start &lt;- 6;\tint max_work_start &lt;- 8;\tint min_work_end &lt;- 16; \tint max_work_end &lt;- 20; \tfloat min_speed &lt;- 1.0 #km / #h;\tfloat max_speed &lt;- 5.0 #km / #h; \tgraph the_graph;        ...}In the experiment section:experiment road_traffic type: gui {        ... \tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;        ...}initializationFirst, we need to compute from the road agents, a graph for the moving of the people agents. The operator as_edge_graph allows to do that. It automatically builds from a set of agents or geometries a graph where the agents are the edges of the graph, a node represent the extremities of the agent geometry.   init {      ...      create road from: shape_file_roads ;      the_graph &lt;- as_edge_graph(road);      ...   }We randomly assign one working place and one house to each people agent. To simplify the GAML code, we define two temporary variables: the list of buildings of type ‘Residential’ and the list of buildings of type ‘Industrial’ (by using the where command). At the creation of each people agent, we define a speed, a start_work and end_work to each people agent (according to the min and max define in the parameters). We define as well an initial objective (“resting”). Concerning the definition of the living_place and working_place, these ones are randomly chosen in the residential_buildings and industrial_buildings lists.   init {      ...      list&lt;building&gt; residential_buildings &lt;- building where (each.type=\"Residential\");      list&lt;building&gt;  industrial_buildings &lt;- building  where (each.type=\"Industrial\") ;      create people number: nb_people {          speed &lt;- min_speed + rnd (max_speed - min_speed) ;          start_work &lt;- min_work_start + rnd (max_work_start - min_work_start) ;          end_work &lt;- min_work_end + rnd (max_work_end - min_work_end) ;          living_place &lt;- one_of(residential_buildings) ;          working_place &lt;- one_of(industrial_buildings) ;          objective &lt;- \"resting\";          location &lt;- any_location_in (living_place);       }      ...  }Complete Modelmodel tutorial_gis_city_trafficglobal {\tfile shape_file_buildings &lt;- file(\"../includes/building.shp\");\tfile shape_file_roads &lt;- file(\"../includes/road.shp\");\tfile shape_file_bounds &lt;- file(\"../includes/bounds.shp\");\tgeometry shape &lt;- envelope(shape_file_bounds);\tfloat step &lt;- 10 #mn;\tint nb_people &lt;- 100;\tint current_hour update: (time / #hour) mod 24;\tint min_work_start &lt;- 6;\tint max_work_start &lt;- 8;\tint min_work_end &lt;- 16; \tint max_work_end &lt;- 20; \tfloat min_speed &lt;- 1.0 #km / #h;\tfloat max_speed &lt;- 5.0 #km / #h; \tgraph the_graph;\t\tinit {\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\t\t\tif type=\"Industrial\" {\t\t\t\tcolor &lt;- #blue ;\t\t\t}\t\t}\t\tcreate road from: shape_file_roads ;\t\tthe_graph &lt;- as_edge_graph(road);\t\t\t\tlist&lt;building&gt; residential_buildings &lt;- building where (each.type=\"Residential\");\t\tlist&lt;building&gt;  industrial_buildings &lt;- building  where (each.type=\"Industrial\") ;\t\tcreate people number: nb_people {\t\t\tspeed &lt;- min_speed + rnd (max_speed - min_speed) ;\t\t\tstart_work &lt;- min_work_start + rnd (max_work_start - min_work_start) ;\t\t\tend_work &lt;- min_work_end + rnd (max_work_end - min_work_end) ;\t\t\tliving_place &lt;- one_of(residential_buildings) ;\t\t\tworking_place &lt;- one_of(industrial_buildings) ;\t\t\tobjective &lt;- \"resting\";\t\t\tlocation &lt;- any_location_in (living_place); \t\t}\t}}species building {\tstring type; \trgb color &lt;- #gray  ;\t\taspect base {\t\tdraw shape color: color ;\t}}species road  {\trgb color &lt;- #black ;\taspect base {\t\tdraw shape color: color ;\t}}species people skills:[moving] {\trgb color &lt;- #yellow ;\tbuilding living_place &lt;- nil ;\tbuilding working_place &lt;- nil ;\tint start_work ;\tint end_work  ;\tstring objective ; \tpoint the_target &lt;- nil ;\t\t\treflex time_to_work when: current_hour = start_work and objective = \"resting\"{\t\tobjective &lt;- \"working\" ;\t\tthe_target &lt;- any_location_in (working_place);\t}\t\t\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\t\tobjective &lt;- \"resting\" ;\t\tthe_target &lt;- any_location_in (living_place); \t} \t \treflex move when: the_target != nil {\t\tdo goto target: the_target on: the_graph ; \t\tif the_target = location {\t\t\tthe_target &lt;- nil ;\t\t}\t}\t\taspect base {\t\tdraw circle(10) color: color;\t}}experiment road_traffic type: gui {\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\t\toutput {\t\tdisplay city_display type:opengl {\t\t\tspecies building aspect: base ;\t\t\tspecies road aspect: base ;\t\t\tspecies people aspect: base ;\t\t}\t}}",
        "url":"/wiki/RoadTrafficModel_step3.html"
      }
      ,
    
      "wiki-roadtrafficmodel-step4-html": {
        "title": "4. Weight for Road Network",
        "content": "4. Weight for Road NetworkThe present model will introduce how to design a road system, or graph, based on the road GIS data and provide each edge a weightrepresenting the destruction level of the road.Formulation  Add a destruction_coeff variable to the road agent. The value of this variable is higher or equal to 1 or lower or equal to 2. At initialization, the value of this variable is randomly defined between 1 and 2.  In the road network graph, more a road is worn out (destruction_coeff high), more a people agent takes time to go all over it. Then the value of the arc representing the road in the graph is equal to “length of the road * destruction_coeff”.  The color of the road depends of the destruction_coeff. If “destruction_coeff = 1”, the road is green, if “destruction_coeff = 2”, the road is red.Model Definitionroad agentWe add a destruction_coeff variable which initial value is randomly defined between 1 and 2 and that have a max of 2. The color of the agent will depend of this variable. In order to simplify the GAML code, we define a new variable  colorValue that represents the value of red color and that will be defined between 0 and 255.   species road  {\tfloat destruction_coeff &lt;- 1 + ((rnd(100))/ 100.0) max: 2.0;\tint colorValue &lt;- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\trgb color &lt;- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;        ...   }weigthed road networkIn GAMA, adding a weight for a graph is very simple, we use the as_edge_graph operator with the graph for left-operand and a weight map for the right-operand. A weight contains the weight of each edge: [edge1::weight1, edge2:: weight2,…]. In this model, the weight will be equal to the length of the road (perimeter of the polyline) **its destruction coefficient.    init {      ...      create road from: shape_file_roads ;      map&lt;road,float&gt; weights_map &lt;- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));      the_graph &lt;- as_edge_graph(road) with_weights weights_map;      ...   }```**## Complete Modelmodel tutorial_gis_city_trafficglobal {\tfile shape_file_buildings &lt;- file(“../includes/building.shp”);\tfile shape_file_roads &lt;- file(“../includes/road.shp”);\tfile shape_file_bounds &lt;- file(“../includes/bounds.shp”);\tgeometry shape &lt;- envelope(shape_file_bounds);\tfloat step &lt;- 10 #mn;\tint nb_people &lt;- 100;\tint current_hour update: (time / #hour) mod 24;\tint min_work_start &lt;- 6;\tint max_work_start &lt;- 8;\tint min_work_end &lt;- 16; \tint max_work_end &lt;- 20; \tfloat min_speed &lt;- 1.0 #km / #h;\tfloat max_speed &lt;- 5.0 #km / #h; \tgraph the_graph;init {\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\t\tif type=\"Industrial\" {\t\t\tcolor &lt;- #blue ;\t\t}\t}\tcreate road from: shape_file_roads ;\tmap&lt;road,float&gt; weights_map &lt;- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\tthe_graph &lt;- as_edge_graph(road) with_weights weights_map;\t\t\tlist&lt;building&gt; residential_buildings &lt;- building where (each.type=\"Residential\");\tlist&lt;building&gt;  industrial_buildings &lt;- building  where (each.type=\"Industrial\") ;\tcreate people number: nb_people {\t\tspeed &lt;- min_speed + rnd (max_speed - min_speed) ;\t\tstart_work &lt;- min_work_start + rnd (max_work_start - min_work_start) ;\t\tend_work &lt;- min_work_end + rnd (max_work_end - min_work_end) ;\t\tliving_place &lt;- one_of(residential_buildings) ;\t\tworking_place &lt;- one_of(industrial_buildings) ;\t\tobjective &lt;- \"resting\";\t\tlocation &lt;- any_location_in (living_place); \t}} }species building {\tstring type; \trgb color &lt;- #gray  ;aspect base {\tdraw shape color: color ;} }species road  {\tfloat destruction_coeff &lt;- 1 + ((rnd(100))/ 100.0) max: 2.0;\tint colorValue &lt;- int(255(destruction_coeff - 1)) update: int(255(destruction_coeff - 1));\trgb color &lt;- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;aspect base {\tdraw shape color: color ;} }species people skills:[moving] {\trgb color &lt;- #yellow ;\tbuilding living_place &lt;- nil ;\tbuilding working_place &lt;- nil ;\tint start_work ;\tint end_work  ;\tstring objective ; \tpoint the_target &lt;- nil ;reflex time_to_work when: current_hour = start_work and objective = \"resting\"{\tobjective &lt;- \"working\" ;\tthe_target &lt;- any_location_in (working_place);}\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\tobjective &lt;- \"resting\" ;\tthe_target &lt;- any_location_in (living_place); }  reflex move when: the_target != nil {\tdo goto target: the_target on: the_graph ; \tif the_target = location {\t\tthe_target &lt;- nil ;\t}}aspect base {\tdraw circle(10) color: color;} }experiment road_traffic type: gui {\tparameter “Shapefile for the buildings:” var: shape_file_buildings category: “GIS” ;\tparameter “Shapefile for the roads:” var: shape_file_roads category: “GIS” ;\tparameter “Shapefile for the bounds:” var: shape_file_bounds category: “GIS” ;\tparameter “Number of people agents” var: nb_people category: “People” ;\tparameter “Earliest hour to start work” var: min_work_start category: “People” min: 2 max: 8;\tparameter “Latest hour to start work” var: max_work_start category: “People” min: 8 max: 12;\tparameter “Earliest hour to end work” var: min_work_end category: “People” min: 12 max: 16;\tparameter “Latest hour to end work” var: max_work_end category: “People” min: 16 max: 23;\tparameter “minimal speed” var: min_speed category: “People” min: 0.1 #km/#h ;\tparameter “maximal speed” var: max_speed category: “People” max: 10 #km/#h;output {\tdisplay city_display type:opengl {\t\tspecies building aspect: base ;\t\tspecies road aspect: base ;\t\tspecies people aspect: base ;\t}} } ```",
        "url":"/wiki/RoadTrafficModel_step4.html"
      }
      ,
    
      "wiki-roadtrafficmodel-step5-html": {
        "title": "5. Dynamic weights",
        "content": "5. Dynamic weightsThis 5th step illustrates how to obtain a shortest path from a point to another and to update the weights of an existing graph.Formulation  At initialization, the value of the destruction_coeff of the road agents will be equal to 1.  Add a new parameter: the destroy parameter that represents the value of destruction when a people agent takes a road. By default, it is equal to 0.02.  When an people arrive at its destination (home or work), it updates the destruction_coeff of the road agents it took to reach its destination:  “destruction_coeff = destruction_coeff - destroy”. Then, the graph is updated.Model Definitionglobal sectionWe add the destroy parameter.In the global section, definition of the destroy and update_roads variables:   float destroy &lt;- 0.02;In the experiment section, definition of the parameter:   parameter \"Value of destruction when a people agent takes a road\" var: destroy category: \"Road\" ;We define a new reflex that updates the graph at each simulation step. For that, we use the with_weights operator. This operator allows to update the weights of an existing graph.   global {      ...      reflex update_graph{         map&lt;road,float&gt; weights_map &lt;- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));         the_graph &lt;- the_graph with_weights weights_map;      }   }people agentsAt each time-step, after a people agent have moved over one or multiple segments, it updates the value of the destruction coefficient of road agents crossed (i.e. roads belonging to the path followed). We have for that to set the argument return_path to true in the goto action to obtain the path followed, then to compute the list of agents concerned by this path with the operator agent_from_geometry.   species people skills: [moving]{      ...      reflex move when: the_target != nil {\t\tpath path_followed &lt;- self goto [target::the_target, on::the_graph, return_path:: true];\t\tlist&lt;geometry&gt; segments &lt;- path_followed.segments;\t\tloop line over: segments {\t\t\tfloat dist &lt;- line.perimeter;\t\t\task road(path_followed agent_from_geometry line) { \t\t\t\tdestruction_coeff &lt;- destruction_coeff + (destroy * dist / shape.perimeter);\t\t\t}\t\t}\t\tif the_target = location {\t\t\tthe_target &lt;- nil ;\t\t}\t}   ...   }\tComplete Modelmodel tutorial_gis_city_trafficglobal {\tfile shape_file_buildings &lt;- file(\"../includes/building.shp\");\tfile shape_file_roads &lt;- file(\"../includes/road.shp\");\tfile shape_file_bounds &lt;- file(\"../includes/bounds.shp\");\tgeometry shape &lt;- envelope(shape_file_bounds);\tfloat step &lt;- 10 #mn;\tint nb_people &lt;- 100;\tint current_hour update: (time / #hour) mod 24;\tint min_work_start &lt;- 6;\tint max_work_start &lt;- 8;\tint min_work_end &lt;- 16; \tint max_work_end &lt;- 20; \tfloat min_speed &lt;- 1.0 #km / #h;\tfloat max_speed &lt;- 5.0 #km / #h; \tfloat destroy &lt;- 0.02;\tgraph the_graph;\t\tinit {\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\t\t\tif type=\"Industrial\" {\t\t\t\tcolor &lt;- #blue ;\t\t\t}\t\t}\t\tcreate road from: shape_file_roads ;\t\tmap&lt;road,float&gt; weights_map &lt;- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\t\tthe_graph &lt;- as_edge_graph(road) with_weights weights_map;\t\t\t\t\t\tlist&lt;building&gt; residential_buildings &lt;- building where (each.type=\"Residential\");\t\tlist&lt;building&gt;  industrial_buildings &lt;- building  where (each.type=\"Industrial\") ;\t\tcreate people number: nb_people {\t\t\tspeed &lt;- min_speed + rnd (max_speed - min_speed) ;\t\t\tstart_work &lt;- min_work_start + rnd (max_work_start - min_work_start) ;\t\t\tend_work &lt;- min_work_end + rnd (max_work_end - min_work_end) ;\t\t\tliving_place &lt;- one_of(residential_buildings) ;\t\t\tworking_place &lt;- one_of(industrial_buildings) ;\t\t\tobjective &lt;- \"resting\";\t\t\tlocation &lt;- any_location_in (living_place); \t\t}\t}\t\treflex update_graph{\t\tmap&lt;road,float&gt; weights_map &lt;- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\t\tthe_graph &lt;- the_graph with_weights weights_map;\t}}species building {\tstring type; \trgb color &lt;- #gray  ;\t\taspect base {\t\tdraw shape color: color ;\t}}species road  {\tfloat destruction_coeff &lt;- 1 + ((rnd(100))/ 100.0) max: 2.0;\tint colorValue &lt;- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\trgb color &lt;- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\t\taspect base {\t\tdraw shape color: color ;\t}}species people skills:[moving] {\trgb color &lt;- #yellow ;\tbuilding living_place &lt;- nil ;\tbuilding working_place &lt;- nil ;\tint start_work ;\tint end_work  ;\tstring objective ; \tpoint the_target &lt;- nil ;\t\t\treflex time_to_work when: current_hour = start_work and objective = \"resting\"{\t\tobjective &lt;- \"working\" ;\t\tthe_target &lt;- any_location_in (working_place);\t}\t\t\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\t\tobjective &lt;- \"resting\" ;\t\tthe_target &lt;- any_location_in (living_place); \t} \t \treflex move when: the_target != nil {\t\tpath path_followed &lt;- self goto [target::the_target, on::the_graph, return_path:: true];\t\tlist&lt;geometry&gt; segments &lt;- path_followed.segments;\t\tloop line over: segments {\t\t\tfloat dist &lt;- line.perimeter;\t\t\task road(path_followed agent_from_geometry line) { \t\t\t\tdestruction_coeff &lt;- destruction_coeff + (destroy * dist / shape.perimeter);\t\t\t}\t\t}\t\tif the_target = location {\t\t\tthe_target &lt;- nil ;\t\t}\t}\t\taspect base {\t\tdraw circle(10) color: color;\t}}experiment road_traffic type: gui {\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\tparameter \"Value of destruction when a people agent takes a road\" var: destroy category: \"Road\" ;\toutput {\t\tdisplay city_display type:opengl {\t\t\tspecies building aspect: base ;\t\t\tspecies road aspect: base ;\t\t\tspecies people aspect: base ;\t\t}\t}}",
        "url":"/wiki/RoadTrafficModel_step5.html"
      }
      ,
    
      "wiki-roadtrafficmodel-step6-html": {
        "title": "6. Charts",
        "content": "6. ChartsThis 6th step illustrates how to display charts.Formulation  Add a chart to display the evolution of the road destruction: the mean value of the destruction_coeff of the road agents, and its max value (refreshed every 10 simulation steps).  Add a chart to display the activity of the people agent (working or staying home, refreshed every 10 simulation steps).Model Definitionchart displayFirst we add a chart of type series to display the road destruction evolution. To compute the mean of the destruction_coeff, we use the mean operator. For the max, we use the max_of operator.     output {       display chart_display refresh:every(10) {             chart \"Road Status\" type: series size: {1, 0.5} position: {0, 0} {                  data \"Mean road destruction\" value: mean (road collect each.destruction_coeff) style: line color: #green ;\t\t  data \"Max road destruction\" value: road max_of each.destruction_coeff style: line color: #red ;\t    }         ...      }   }Second, we add a chart of type pie to display the activity of the people agents. We use for that the objective variable of the people agents and the count operator that allows to compute the number of elements of a list that verify a condition.    output {      ...      display chart_display refresh:every(10) {          ...          chart \"People Objectif\" type: pie style: exploded size: {1, 0.5} position: {0, 0.5}{\t       data \"Working\" value: people count (each.objective=\"working\") color: #magenta ;\t       data \"Resting\" value: people count (each.objective=\"resting\") color: #blue ;\t  }     }   }Complete Modelmodel tutorial_gis_city_trafficglobal {\tfile shape_file_buildings &lt;- file(\"../includes/building.shp\");\tfile shape_file_roads &lt;- file(\"../includes/road.shp\");\tfile shape_file_bounds &lt;- file(\"../includes/bounds.shp\");\tgeometry shape &lt;- envelope(shape_file_bounds);\tfloat step &lt;- 10 #mn;\tint nb_people &lt;- 100;\tint current_hour update: (time / #hour) mod 24;\tint min_work_start &lt;- 6;\tint max_work_start &lt;- 8;\tint min_work_end &lt;- 16; \tint max_work_end &lt;- 20; \tfloat min_speed &lt;- 1.0 #km / #h;\tfloat max_speed &lt;- 5.0 #km / #h; \tfloat destroy &lt;- 0.02;\tgraph the_graph;\t\tinit {\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\t\t\tif type=\"Industrial\" {\t\t\t\tcolor &lt;- #blue ;\t\t\t}\t\t}\t\tcreate road from: shape_file_roads ;\t\tmap&lt;road,float&gt; weights_map &lt;- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\t\tthe_graph &lt;- as_edge_graph(road) with_weights weights_map;\t\t\t\t\t\tlist&lt;building&gt; residential_buildings &lt;- building where (each.type=\"Residential\");\t\tlist&lt;building&gt;  industrial_buildings &lt;- building  where (each.type=\"Industrial\") ;\t\tcreate people number: nb_people {\t\t\tspeed &lt;- min_speed + rnd (max_speed - min_speed) ;\t\t\tstart_work &lt;- min_work_start + rnd (max_work_start - min_work_start) ;\t\t\tend_work &lt;- min_work_end + rnd (max_work_end - min_work_end) ;\t\t\tliving_place &lt;- one_of(residential_buildings) ;\t\t\tworking_place &lt;- one_of(industrial_buildings) ;\t\t\tobjective &lt;- \"resting\";\t\t\tlocation &lt;- any_location_in (living_place); \t\t}\t}\t\treflex update_graph{\t\tmap&lt;road,float&gt; weights_map &lt;- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\t\tthe_graph &lt;- the_graph with_weights weights_map;\t}}species building {\tstring type; \trgb color &lt;- #gray  ;\t\taspect base {\t\tdraw shape color: color ;\t}}species road  {\tfloat destruction_coeff &lt;- 1 + ((rnd(100))/ 100.0) max: 2.0;\tint colorValue &lt;- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\trgb color &lt;- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\t\taspect base {\t\tdraw shape color: color ;\t}}species people skills:[moving] {\trgb color &lt;- #yellow ;\tbuilding living_place &lt;- nil ;\tbuilding working_place &lt;- nil ;\tint start_work ;\tint end_work  ;\tstring objective ; \tpoint the_target &lt;- nil ;\t\t\treflex time_to_work when: current_hour = start_work and objective = \"resting\"{\t\tobjective &lt;- \"working\" ;\t\tthe_target &lt;- any_location_in (working_place);\t}\t\t\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\t\tobjective &lt;- \"resting\" ;\t\tthe_target &lt;- any_location_in (living_place); \t} \t \treflex move when: the_target != nil {\t\tpath path_followed &lt;- self goto [target::the_target, on::the_graph, return_path:: true];\t\tlist&lt;geometry&gt; segments &lt;- path_followed.segments;\t\tloop line over: segments {\t\t\tfloat dist &lt;- line.perimeter;\t\t\task road(path_followed agent_from_geometry line) { \t\t\t\tdestruction_coeff &lt;- destruction_coeff + (destroy * dist / shape.perimeter);\t\t\t}\t\t}\t\tif the_target = location {\t\t\tthe_target &lt;- nil ;\t\t}\t}\t\taspect base {\t\tdraw circle(10) color: color;\t}}experiment road_traffic type: gui {\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\tparameter \"Value of destruction when a people agent takes a road\" var: destroy category: \"Road\" ;\toutput {\t\tdisplay city_display type:opengl {\t\t\tspecies building aspect: base ;\t\t\tspecies road aspect: base ;\t\t\tspecies people aspect: base ;\t\t}\t\tdisplay chart_display refresh:every(10) { \t\t\tchart \"Road Status\" type: series size: {1, 0.5} position: {0, 0} {\t\t\t\tdata \"Mean road destruction\" value: mean (road collect each.destruction_coeff) style: line color: #green ;\t\t\t\tdata \"Max road destruction\" value: road max_of each.destruction_coeff style: line color: #red ;\t\t\t}\t\t\tchart \"People Objectif\" type: pie style: exploded size: {1, 0.5} position: {0, 0.5}{\t\t\t\tdata \"Working\" value: people count (each.objective=\"working\") color: #magenta ;\t\t\t\tdata \"Resting\" value: people count (each.objective=\"resting\") color: #blue ;\t\t\t}\t\t}\t}}",
        "url":"/wiki/RoadTrafficModel_step6.html"
      }
      ,
    
      "wiki-roadtrafficmodel-step7-html": {
        "title": "7. Automatic Road Repair",
        "content": "7. Automatic Road RepairThis 7th step illustrates how how to select in a list an element that optimize a given function.Formulation  Add a new parameter, repair_time, that is equal to 2.  Every repair_time, the road with the highest destruction_coeff value is repaired (set its destruction_coeff to 1).Model DefinitionparametersWe add a new parameter: the repair_time.In the global section, definition of the repair_time variable:   int repair_time &lt;- 2 ;In the experiment section, definition of the parameter:   parameter \"Number of steps between two road repairs\" var: repair_time category: \"Road\" ;road repairingWe have to add a reflex method in the global section that is triggered every repair_time hours / step. This method selects, thanks to the with_max_of operation the road agent with the highest destruction_coeff value, then sets this value at 1.global {   ...   reflex repair_road when: every(repair_time #hour / step) {\troad the_road_to_repair &lt;- road with_max_of (each.destruction_coeff) ;\task the_road_to_repair {\t\tdestruction_coeff &lt;- 1.0 ;\t}   }}Complete Modelmodel tutorial_gis_city_trafficglobal {\tfile shape_file_buildings &lt;- file(\"../includes/building.shp\");\tfile shape_file_roads &lt;- file(\"../includes/road.shp\");\tfile shape_file_bounds &lt;- file(\"../includes/bounds.shp\");\tgeometry shape &lt;- envelope(shape_file_bounds);\tfloat step &lt;- 10 #mn;\tint nb_people &lt;- 100;\tint current_hour update: (time / #hour) mod 24;\tint min_work_start &lt;- 6;\tint max_work_start &lt;- 8;\tint min_work_end &lt;- 16; \tint max_work_end &lt;- 20; \tfloat min_speed &lt;- 1.0 #km / #h;\tfloat max_speed &lt;- 5.0 #km / #h; \tfloat destroy &lt;- 0.02;\tint repair_time &lt;- 2 ;\tgraph the_graph;\t\tinit {\t\tcreate building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\t\t\tif type=\"Industrial\" {\t\t\t\tcolor &lt;- #blue ;\t\t\t}\t\t}\t\tcreate road from: shape_file_roads ;\t\tmap&lt;road,float&gt; weights_map &lt;- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\t\tthe_graph &lt;- as_edge_graph(road) with_weights weights_map;\t\t\t\t\t\tlist&lt;building&gt; residential_buildings &lt;- building where (each.type=\"Residential\");\t\tlist&lt;building&gt;  industrial_buildings &lt;- building  where (each.type=\"Industrial\") ;\t\tcreate people number: nb_people {\t\t\tspeed &lt;- min_speed + rnd (max_speed - min_speed) ;\t\t\tstart_work &lt;- min_work_start + rnd (max_work_start - min_work_start) ;\t\t\tend_work &lt;- min_work_end + rnd (max_work_end - min_work_end) ;\t\t\tliving_place &lt;- one_of(residential_buildings) ;\t\t\tworking_place &lt;- one_of(industrial_buildings) ;\t\t\tobjective &lt;- \"resting\";\t\t\tlocation &lt;- any_location_in (living_place); \t\t}\t}\t\treflex update_graph{\t\tmap&lt;road,float&gt; weights_map &lt;- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));\t\tthe_graph &lt;- the_graph with_weights weights_map;\t}\treflex repair_road when: every(repair_time #hour / step) {\t\troad the_road_to_repair &lt;- road with_max_of (each.destruction_coeff) ;\t\task the_road_to_repair {\t\t\tdestruction_coeff &lt;- 1.0 ;\t\t}\t}}species building {\tstring type; \trgb color &lt;- #gray  ;\t\taspect base {\t\tdraw shape color: color ;\t}}species road  {\tfloat destruction_coeff &lt;- 1 + ((rnd(100))/ 100.0) max: 2.0;\tint colorValue &lt;- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));\trgb color &lt;- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;\t\taspect base {\t\tdraw shape color: color ;\t}}species people skills:[moving] {\trgb color &lt;- #yellow ;\tbuilding living_place &lt;- nil ;\tbuilding working_place &lt;- nil ;\tint start_work ;\tint end_work  ;\tstring objective ; \tpoint the_target &lt;- nil ;\t\t\treflex time_to_work when: current_hour = start_work and objective = \"resting\"{\t\tobjective &lt;- \"working\" ;\t\tthe_target &lt;- any_location_in (working_place);\t}\t\t\treflex time_to_go_home when: current_hour = end_work and objective = \"working\"{\t\tobjective &lt;- \"resting\" ;\t\tthe_target &lt;- any_location_in (living_place); \t} \t \treflex move when: the_target != nil {\t\tpath path_followed &lt;- self goto [target::the_target, on::the_graph, return_path:: true];\t\tlist&lt;geometry&gt; segments &lt;- path_followed.segments;\t\tloop line over: segments {\t\t\tfloat dist &lt;- line.perimeter;\t\t\task road(path_followed agent_from_geometry line) { \t\t\t\tdestruction_coeff &lt;- destruction_coeff + (destroy * dist / shape.perimeter);\t\t\t}\t\t}\t\tif the_target = location {\t\t\tthe_target &lt;- nil ;\t\t}\t}\t\taspect base {\t\tdraw circle(10) color: color;\t}}experiment road_traffic type: gui {\tparameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\tparameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\tparameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\tparameter \"Number of people agents\" var: nb_people category: \"People\" ;\tparameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;\tparameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;\tparameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;\tparameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;\tparameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;\tparameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;\tparameter \"Value of destruction when a people agent takes a road\" var: destroy category: \"Road\" ;\tparameter \"Number of hours between two road repairs\" var: repair_time category: \"Road\" ;\t\toutput {\t\tdisplay city_display type:opengl {\t\t\tspecies building aspect: base ;\t\t\tspecies road aspect: base ;\t\t\tspecies people aspect: base ;\t\t}\t\tdisplay chart_display refresh:every(10) { \t\t\tchart \"Road Status\" type: series size: {1, 0.5} position: {0, 0} {\t\t\t\tdata \"Mean road destruction\" value: mean (road collect each.destruction_coeff) style: line color: #green ;\t\t\t\tdata \"Max road destruction\" value: road max_of each.destruction_coeff style: line color: #red ;\t\t\t}\t\t\tchart \"People Objectif\" type: pie style: exploded size: {1, 0.5} position: {0, 0.5}{\t\t\t\tdata \"Working\" value: people count (each.objective=\"working\") color: #magenta ;\t\t\t\tdata \"Resting\" value: people count (each.objective=\"resting\") color: #blue ;\t\t\t}\t\t}\t}}",
        "url":"/wiki/RoadTrafficModel_step7.html"
      }
      ,
    
      "wiki-runseveralsimulations-html": {
        "title": "Run Several Simulations",
        "content": "Run Several SimulationsTo explore a model, the easiest and the most intuitive way to proceed is running several simulations with several parameter value, and see the differences from the output. GAMA provides you the possibility to launch several simulations from the GUI.Index  Create a simulation  Manipulate simulations  Random seed          Defining the seed from the model      Defining the seed from the experiment      Run several simulations with the same random numbers      Change the RNG      Create a simulationLet’s remind you that in GAMA, everything is an agent. We already saw that the “world” agent is the agent of the model. The model is thus a species, called modelName_model :model toto // &lt;- the name of the species is \"toto_model\"New highlight of the day : an Experiment is also an agent ! It’s a special agent which will instantiate automatically an agent from the model species. You can then perfectly create agents (model agents) from your experiment, using the statement create :model multi_simulations // the \"world\" is an instance of the \"multi_simulations_model\"global {}experiment my_experiment type:gui  {\tinit {\t\tcreate multi_simulations_model;\t}}This sort model will instantiate 2 simulations (two instance of the model) : one is created automatically by the experiment, and the second one is explicitly created through the statement create.To simplify the syntax, you can use the built-in attribute simulation of your experiment. When you have a model called “multi_simulations”, the two following lines are strictly equal :create multi_simulations_model;create simulation;As it was the case for creating regular species, you can specify the parameters of your agent during the creation through the facet with: :model multi_simulationsglobal {\trgb bgd_color;}experiment my_experiment type:gui  {\tparameter name:\"background color:\" var:bgd_color init:#blue;\tinit {\t\tcreate simulation with:[bgd_color::#red];\t}\toutput {\t\tdisplay \"my_display\" background:bgd_color{}\t}}Manipulate simulationsWhen you think the simulations as agents, it gives you a lot of new possibilities. You can for example create a reflex from your experiment, asking to create simulations during the experiment execution !The following short model for example will create a new simulation at each 10 cycles :model multi_simulationsglobal {\tinit {\t\twrite \"new simulation created ! Its name is \"+name;\t}}experiment my_experiment type:gui  {\tinit {\t}\treflex when:(mod(cycle,10)=0 and cycle!=0) {\t\tcreate simulation;\t}\toutput {\t}}You may ask, what is the purpose of such a thing ? Well, with such a short model, it is not very interesting, for sure. But you can imagine running a simulation, and if the simulation reaches a certain state, it can be closed, and another simulation can be run instead with different parameters (a simulation can be closed by doing a “do die” on itself). You can also imagine to run two simulations, and to communicate from one to an other through the experiment, as it is shown in this easy model, where agents can move from one simulation to another :model smallWorldglobal {\tint grid_size &lt;- 10;\tbool modelleft &lt;- true;\tint id&lt;- 0;\tint nb_agents &lt;- 50;\t\tinit {\t\tcreate people number: nb_agents {\t\t\tmy_cell &lt;- one_of(cell);\t\t\tlocation &lt;- my_cell.location;\t\t}\t\tif (modelleft) {\t\t\task cell where (each.grid_x = (grid_size - 1))  {\t\t\t\tcolor &lt;- #red;\t\t\t\t}\t\t} else {\t\t\task cell where (each.grid_x = 0)  {\t\t\t\tcolor &lt;- #red;\t\t\t\t}\t\t}\t}\t\taction changeWorld(rgb color, point loc) {\t\tcreate people with:[color::color, location::loc] {\t\t\tmy_cell &lt;- cell(location);\t\t}\t}}species people {\trgb color &lt;- rnd_color(255);\tcell my_cell;\treflex move {\t\tif (modelleft and my_cell.color = #red) {\t\t\task smallWorld_model[1] {\t\t\t\tdo changeWorld(myself.color, {100 - myself.location.x,myself.location.y});\t\t \t}\t\t \tdo die;\t\t} else {\t\t\tlist&lt;cell&gt; free_cells &lt;- list&lt;cell&gt; (my_cell.neighbors) where empty(people inside each);\t\t\tif not empty(free_cells) {\t\t\t\tmy_cell &lt;- one_of(free_cells);\t\t\t\tlocation &lt;- my_cell.location;\t\t\t}\t\t}\t\t\t} \taspect default {\t\tdraw circle(50/grid_size) color: color;\t}\t}grid cell width: grid_size height: grid_size;experiment fromWorldToWorld type: gui {\tinit {\t\t create simulation with:[grid_size::20, modelleft::false, id::1, nb_agents::0];\t}\t\toutput {\t\tdisplay map {\t\t\tgrid cell lines: #black;\t\t\tspecies people;\t\t}\t}}Here is an other example of application of application, available in the model library. Here we run 4 times the Ant Foraging model, with different parameters.            //: # (endConcept      run_simulations_as_agents)              //: # (startConcept      control_randomness)      Random seedDefining the seed from the modelIf you run several simulations, you may want to use the same seed for each one of those simulations (to compare the influence of a certain parameter, in exactly the same conditions).Let’s remind you that seed is a built-in attribute of the model. You than just need to specify the value of your seed during the creation of the simulation if you want to fix the seed :create simulation with:[seed::10.0];You can also specify the seed if you are inside the init scope of your global agent.global {\tinit {\t\tseed&lt;-10.0;\t}}Notice that if you affect the value of your seed built-in directly in the global scope, the affectation of the parameters (for instance specified with the facet with of the statement create), and the “init” will be done after  will be done at the end.Defining the seed from the experimentThe experiment agent also have a built-in attribute seed. The value of this seed is defined in your simulation preferences. The first simulation created is created with the seed value of the experiment.The following sequence diagram can explain you better how the affectation of the seed attribute works :The affectation of an attribute is always done in this order :(1) the attribute is affected with a specific value in the species scope. If no attribute value is specified, the value is a default value.(2) if a value is specified for this attribute in the create statement, then the attribute value is affected again.(3) the attribute value can be changed again in the init scope.Run several simulations with the same random numbersThe following code shows how to run several simulations with a specific seed, determined from the experiment agent :model multi_simulationsglobal {\tinit {\t\tcreate my_species;\t}}species my_species skills:[moving] {\treflex update {\t\tdo wander;\t}\taspect base {\t\tdraw circle(2) color:#green;\t}}experiment my_experiment type:gui  {\tfloat seedValue &lt;- 10.0;\tfloat seed &lt;- seedValue; // force the value of the seed.\tinit {\t\t// create a second simulation with the same seed as the main simulation\t\tcreate simulation with:[seed::seedValue];\t}\toutput {\t\tdisplay my_display {\t\t\tspecies my_species aspect:base;\t\t}\t}}When you run this simulation, their execution is exactly similar.Let’s try now to add a new species in this model, and to add a parameter to the simulation for the number of agents created for this species.model multi_simulationsglobal {\tint number_of_speciesB &lt;- 1;\tinit {\t\tcreate my_speciesA;\t\tcreate my_speciesB number:number_of_speciesB;\t}}species my_speciesA skills:[moving] {\treflex update {\t\tdo wander;\t}\taspect base {\t\tdraw circle(2) color:#green;\t}}species my_speciesB skills:[moving] {\treflex update {\t\tdo wander;\t}\taspect base {\t\tdraw circle(2) color:#red;\t}}experiment my_experiment type:gui  {\tfloat seedValue &lt;- 10.0;\tfloat seed &lt;- seedValue; // force the value of the seed.\tinit {\t\tcreate simulation with:[seed::seedValue,number_of_speciesB::2];\t}\toutput {\t\tdisplay my_display {\t\t\tspecies my_speciesA aspect:base;\t\t\tspecies my_speciesB aspect:base;\t\t}\t}}Then you run the experiment, you may find something strange…Even if the first step seems ok (the greed agent and one of the two red agent is initialized with the same location), the simulation differs completly. You should have expected to have the same behavior for the greed agent in both of the simulation, but it is not the case. The explaination of this behavior is that a random number generator has generated more random numbers in the second simulation than in the first one.If you don’t understand, here is a short example that may help you to understand better :model multi_simulationsglobal {\tint iteration_number &lt;- 1;\treflex update {\t\tfloat value;\t\tloop times:iteration_number {\t\t\tvalue&lt;-rnd(10.0);\t\t\twrite value;\t\t}\t\twrite \"cycle \"+cycle+\" in experiment \"+name+\" : \"+value;\t}}experiment my_experiment type:gui  {\tfloat seedValue &lt;- 10.0;\tfloat seed &lt;- seedValue; // force the value of the seed.\tinit {\t\tcreate simulation with:[seed::seedValue,iteration_number::2];\t}\toutput {\t}}The output will be something like that :7.67003069780383cycle 0 in experiment multi_simulations_model0 : 7.670030697803837.670030697803830.22889843360303863cycle 0 in experiment multi_simulations_model1 : 0.228898433603038630.22889843360303863cycle 1 in experiment multi_simulations_model0 : 0.228898433603038634.52209133062638550.8363180333035425cycle 1 in experiment multi_simulations_model1 : 0.83631803330354254.5220913306263855cycle 2 in experiment multi_simulations_model0 : 4.52209133062638555.4601485681408194.158355846617511cycle 2 in experiment multi_simulations_model1 : 4.1583558466175110.8363180333035425cycle 3 in experiment multi_simulations_model0 : 0.83631803330354251.8860916591695624.371253083874633cycle 3 in experiment multi_simulations_model1 : 4.371253083874633Which means :            Cycle      Value generated in simulation 0      Value generated in simulation 1                  1      7.67003069780383      7.67003069780383                            0.22889843360303863              2      0.22889843360303863      4.5220913306263855                            0.8363180333035425              3      4.5220913306263855      5.460148568140819                            4.158355846617511      When writing your models, you have to be aware of this behavior. Remember that each simulation has it’s own random number generator.Change the RNGThe RNG (random number generator) can also be changed : rng is a string built-in attribute of the experiment (and also of the model). You can choose among the following rng :  mersenne (by default)  cellular  javaThe following model shows how to run 4 simulations with the same seed but with some different RNG :model multi_simulationsglobal {\tinit {\t\tcreate my_species number:50;\t}}species my_species skills:[moving] {\treflex update {\t\tdo wander;\t}\taspect base {\t\tdraw square(2) color:#blue;\t}}experiment my_experiment type:gui  {\tfloat seed &lt;- 10.0;\tinit {\t\tcreate simulation with:[rng::\"cellular\",seed::10.0];\t\tcreate simulation with:[rng::\"java\",seed::10.0];\t}\toutput {\t\tdisplay my_display {\t\t\tspecies my_species aspect:base;\t\t\tgraphics \"my_graphic\" {\t\t\t\tdraw rectangle(35,10) at:{0,0} color:#lightgrey;\t\t\t\tdraw rng at:{3,3} font:font(\"Helvetica\", 20 , #plain) color:#black;\t\t\t}\t\t}\t}}",
        "url":"/wiki/RunSeveralSimulations.html"
      }
      ,
    
      "wiki-runningexperiments-html": {
        "title": "Running Experiments",
        "content": "Running ExperimentsRunning an experiment is the only way, in GAMA, to execute simulations on a model. Experiments can be run in different ways.  The first, and most common way, consists in launching an experiment from the Modeling perspective, using the user interface proposed by the simulation perspective to run simulations.  The second way, detailed on this page, allows to automatically launch an experiment when opening GAMA, subsequently using the same user interface.  The last way, known as running headless experiments, does not make use of the user interface and allows to manipulate GAMA entirely from the command line.All three ways are strictly equivalent in terms of computations (with the exception of the last one omitting all the computations necessary to render simulations on displays or in the UI). They simply differ by their usage:  The first one is heavily used when designing models or demonstrating several models.  The second is intended to be used when demonstrating or experimenting a single model.  The last one is useful when running large sets of simulations, especially over networks or grids of computers.",
        "url":"/wiki/RunningExperiments.html"
      }
      ,
    
      "wiki-runtimeconcepts-html": {
        "title": "Runtime Concepts",
        "content": "Runtime ConceptsWhen a model is being simulated, a number of algorithms are applied, for instance to determine the order in which to run the different agents, or the order in which the initialization of agents is performed, etc. This section details some of them, which can be important when building models and understanding how they will be effectively simulated.Table of contents  Simulation initialization  Agents Creation  Agents Step  Schedule AgentsSimulation initializationOnce the user launches an experiment, GAMA starts the initialization of the simulation.First it creates a world agent.It initializes all its attributes with their init values. This includes its shape (that will be used as environment of the simulation).If a species of type grid exists in the model, agents of species are created.Finally the init statement is executed. It should include the creation of all the other agents of regular species of the simulation. After their creation and initialization, they are added in the list members the world (that contains all the micro-agent of the world).Agents CreationExcept grid agents, other agents are created using the create statement. It is used to allocate memory for each agent and to initialize all its attributes.If no explicit initialization exists for an attribute, it will get the default value corresponding to its type.The initialization of an attribute can be located at several places in the code; they are executed in the following order (which means that, if several ways are used, the attribute will finally have the value of the last applied one):  using the from: facet of the create statement;  in the embedded block of the create statement;  in the attribute declaration, using the init facet;  in the init block of the species.Agents StepWhen an agent is asked to step, it means that it is expected to update its variables, run its behaviors and then step its micro-agents (if any).step of agent agent_a    {        species_a &lt;- agent_a.species        architecture_a &lt;- species_a.architecture        ask architecture_a to step agent_a {             ask agent_a to update species_a.variables             ask agent_a to run architecture_a.behaviors        }        ask each micro-population mp of agent_a to step {            list&lt;agent&gt; sub-agents &lt;- mp.compute_agents_to_schedule            ask each agent_b of sub-agents to step //... recursive call...        }    }Schedule AgentsThe global scheduling of agents is then simply the application of this previous step to the experiment agent, keeping in mind that this agent has only one micro-population (of simulation agents, each instance of the model species), and that the simulation(s) inside this population contain(s), in turn, all the “regular” populations of agents of the model.To influence this schedule, then, one possible way is to change the way populations compute their lists of agents to schedule, which can be done in a model by providing custom definitions to the “schedules:” facet of one or several species.A practical application of this facet is to reduce simulation artifacts created by the default scheduling of populations, which is sequential (i.e. their agents are executed in turn in their order of creation). To enable a pseudo-parallel scheduling based on a random scheduling recomputed at each step, one has simply to define the corresponding species like in the following example:species A schedules: shuffle(A) {...}Moving further, it is possible to enable a completely random scheduling that will eliminate the sequential scheduling of populations:global schedules: [world] + shuffle(A + B + C) {...}species A schedules: [] {...}species B schedules: [] {...}species C schedules: [] {...}It is important to (1) explicitly invoke the scheduling of the world (although it doesn’t have to be the first); (2) suppress the population-based scheduling to avoid having agent being scheduled 2 times (one time in the custom definition, one time by their population).Other schemes are possible. For instance, the following definition will completely suppress the default scheduling mechanism to replace it with a custom scheduler that will execute the world, then all agents of species A in a random way and then all agents of species B in their order of creation:global schedules: [world] + shuffle(A) + B {...} // explicit scheduling in the worldspecies A schedules [];species B schedules: [];Complex conditions can be used to express which agents need to be scheduled each step. For instance, in the following definition, only agents of A that return true to a particular condition are scheduled:species A schedules: A where each.can_be_scheduled() {    bool can_be_scheduled() {         ...         returns true_or_false;    }}Be aware that enabling a custom scheduling can potentially end up in non-functional simulations. For example, the following definitions will result in a simulation that will never be executed:global schedules: [] {}; // the world is NEVER scheduled species my_scheduler schedules: [world] ; // so its micro-species 'my_scheduler' is NOT scheduled either. and this one will result in an infinite loop (which will trigger a stack overflow at some point):global {} // The world is normally scheduled...species my_scheduler schedules: [world]; // ... but schedules itself again as a consequence of scheduling the micro-species 'my_scheduler'",
        "url":"/wiki/RuntimeConcepts.html"
      }
      ,
    
      "wiki-save-statement-save-to-csv-html": {
        "title": "Save to CSV",
        "content": "Save to CSVAuthor : Patrick TaillandierThis is a model that shows how to save agents inside a CSV File to reuse it later or to keep it.Code of the model :model SavetoCSVglobal {\tinit {\t\t//Create all the agents\t\tcreate bug number: 50;\t}\t//Save the agents bug when the cycle is equals to 100\treflex save_bug_attribute when: cycle = 100{\t\task bug {\t\t\t// save the values of the variables name, speed and size to the csv file\t\t\tsave [name,speed, size] to: \"../results/bug.csv\" type:\"csv\";\t\t}\t\t//Pause the model as the data are saved\t\tdo pause;\t}}//Species that will be savedspecies bug skills:[moving]{\tfloat size &lt;- 1.0 + rnd(4) min: 1.0 max: 5.0;\tfloat speed &lt;- 1.0 + rnd(4.0);\t\treflex update_size {\t\tint nb_neigh &lt;- length(bug at_distance 20.0);\t\tif (nb_neigh &gt; 5) {\t\t\tsize &lt;- size + 1;\t\t} else {\t\t\tsize &lt;- size - 1;\t\t}\t} \t\treflex move {\t\tdo wander;\t}\t\taspect default {\t\tdraw circle(size) color: #red;\t}}experiment main type: gui {\toutput {\t\tdisplay map {\t\t\tspecies bug;\t\t}\t}}",
        "url":"/wiki/Save-statement-Save_to_CSV.html"
      }
      ,
    
      "wiki-save-statement-save-to-asc-html": {
        "title": "Save to Ascii",
        "content": "Save to AsciiAuthor : Patrick TaillandierThis is a model that shows how to save a grid inside a ASCII File to reuse it later or to keep it.Code of the model :model SavetoAscglobal {\tinit {\t\t\t//save grid \"grid_value\" attribute into the asc file.\t\tsave cell to:\"../results/grid.asc\" type:\"asc\";\t}}//Grid that will be saved in the ASC Filegrid cell width: 50 height: 50 {\tfloat grid_value &lt;- self distance_to world.location;\trgb color &lt;- rgb(255 * (1 - grid_value / 50), 0,0);}experiment main type: gui {\toutput {\t\tdisplay map {\t\t\tgrid cell lines: #black;\t\t}\t}}",
        "url":"/wiki/Save-statement-Save_to_asc.html"
      }
      ,
    
      "wiki-save-statement-save-to-shapefile-html": {
        "title": "Save to Shapefile",
        "content": "Save to ShapefileAuthor : Patrick TaillandierThis is a model that shows how to save agents inside a Shapefile to reuse it later or to keep it.Code of the model :model Savetoshapefileglobal {\tinit {\t\tgeometry free_space &lt;- copy(shape);\t\t\t\t//creation of the building agents that will be saved\t\tcreate building number: 50 {\t\t\tshape &lt;- square(5.0);\t\t\tlocation &lt;- any_location_in (free_space - 5.0);\t\t\tfree_space &lt;- free_space - shape;\t\t}\t\t//save building geometry into the shapefile: add the attribute TYPE which value is set by the type variable of the building agent\t\tsave building to:\"../results/buildings.shp\" type:\"shp\" with:[type::\"TYPE\"];\t}}//species that represent the building agents that will be savedspecies building {\tstring type &lt;- flip(0.8) ? \"residential\" : \"industrial\";\taspect default {\t\tdraw shape color: type = \"residential\" ? #gray : #pink;\t}}experiment main type: gui {\toutput {\t\tdisplay map {\t\t\tspecies building;\t\t}\t}}",
        "url":"/wiki/Save-statement-Save_to_shapefile.html"
      }
      ,
    
      "wiki-save-statement-save-to-text-html": {
        "title": "Save to Text",
        "content": "Save to TextAuthor : Patrick TaillandierThis is a model that shows how to save agents inside a text file to reuse it later or to keep it.Code of the model :model SavetoTextglobal {\tinit {\t\t//Create the agents that will be saved in the text file.\t\tcreate bug number: 50;\t}\t\t//Reflex saving the agents every 10 steps. \treflex save_data when: every(10){\t\t//save the following text into the given text file. Note that each time the save statement is used, a new line is added at the end of the file.\t\tsave (\"cycle:\" + cycle + \", mean size: \" + mean(bug collect each.size)) to: \"../results/data.txt\";\t}\t//Reflex that will pause the simulation when the number of cycles reach 100.\treflex end_simulation when: cycle = 100 {\t\tdo pause;\t}}//Species bug that will be saved using the skill movingspecies bug skills:[moving]{\tfloat size &lt;- 1.0 + rnd(4) min: 1.0 max: 5.0;\tfloat speed &lt;- 1.0 + rnd(4.0);\t\t//At each step, the size of the agent is update according to the number of bugs close to the agent\treflex update_size {\t\tint nb_neigh &lt;- length(bug at_distance 20.0);\t\tif (nb_neigh &gt; 5) {\t\t\tsize &lt;- size + 1;\t\t} else {\t\t\tsize &lt;- size - 1;\t\t}\t} \t\t\t//Make the agent move randomly\treflex move {\t\tdo wander;\t}\t\taspect default {\t\tdraw circle(size) color: #red;\t}}experiment main type: gui {\toutput {\t\tdisplay map {\t\t\tspecies bug;\t\t}\t}}",
        "url":"/wiki/Save-statement-Save_to_text.html"
      }
      ,
    
      "wiki-save-statement-html": {
        "title": "Save statement",
        "content": "Save statementThis sub-section is composed of the following models :      Save to Ascii        Save to CSV        Save to Shapefile        Save to Text  ",
        "url":"/wiki/Save-statement.html"
      }
      ,
    
      "wiki-segregation-schelling-segregation-agents-html": {
        "title": "segregationAgents",
        "content": "segregationAgents_Author : _A model showing the segregation of the people just by putting a similarity wanted parameter using agents to represent the individualsImported model :model segregation_baseglobal {\t//Different colors for the group\trgb color_1 &lt;- rgb (\"yellow\") parameter: \"Color of group 1:\" category: \"User interface\";\trgb color_2 &lt;- rgb (\"red\") parameter: \"Color of group 2:\" category: \"User interface\";\trgb color_3 &lt;- rgb (\"blue\") parameter: \"Color of group 3:\" category: \"User interface\";\trgb color_4 &lt;- rgb (\"orange\") parameter: \"Color of group 4:\" category: \"User interface\";\trgb color_5 &lt;- rgb (\"green\") parameter: \"Color of group 5:\" category: \"User interface\";\trgb color_6 &lt;- rgb (\"pink\") parameter: \"Color of group 6:\" category: \"User interface\";   \trgb color_7 &lt;- rgb (\"magenta\") parameter: \"Color of group 7:\" category: \"User interface\";\trgb color_8 &lt;- rgb (\"cyan\") parameter: \"Color of group 8:\" category: \"User interface\";    list colors &lt;- [color_1, color_2, color_3, color_4, color_5, color_6, color_7, color_8] of: rgb;\t\t//Number of groups\tint number_of_groups &lt;- 2 max: 8 parameter: \"Number of groups:\" category: \"Population\";\t//Density of the people\tfloat density_of_people &lt;- 0.7 parameter: \"Density of people:\" category: \"Population\" min: 0.01 max: 0.99;\t//Percentage of similar wanted for segregation\tfloat percent_similar_wanted &lt;- 0.5 min: float (0) max: float (1) parameter: \"Desired percentage of similarity:\" category: \"Population\";\t//Dimension of the grid\tint dimensions &lt;- 40 max: 400 min: 10 parameter: \"Width and height of the environment:\" category: \"Environment\";\t//Neighbours distance for the perception of the agents\tint neighbours_distance &lt;- 2 max: 10 min: 1 parameter: \"Distance of perception:\" category: \"Population\";\t//Number of people agents\tint number_of_people &lt;- 0;\t//Number of happy people\tint sum_happy_people &lt;- 0 update: all_people count (each.is_happy);\t//Number of similar neighbours\tint sum_similar_neighbours &lt;- 0 update: sum (all_people collect each.similar_nearby);\t//Number of neighbours\tint sum_total_neighbours &lt;- 1 update: sum (all_people collect each.total_nearby) min: 1;\t//List of all the places\tlist&lt;agent&gt; all_places;\t//List of all the people\tlist&lt;base&gt; all_people;  \t\t//Action to write the description of the model in the console\taction description {\t\twrite\t\t\"\\\\n\\\\u25B6 Description. \\\\n\\\\u25B6 Thomas Schelling model of residential segregation is a classic study of the effects of local decisions on global dynamics. Agents with mild preferences for same-type neighbors, but without preferences for segregated neighborhoods, can wind up producing complete segregation.\\\\n\\\\u25B6 In this model, agents populate a grid with a given *density*. They are in two different states : happy when the percentage of same-color neighbours is above their *desired percentage of similarity*; unhappy otherwise. In the latter case, they change their location randomly until they find a neighbourhood that fits their desire. \\\\n\\\\u25B6 In addition to the previous parameter, one can adjust the *distance of perception* (i.e.  the distance at which they consider other agents as neighbours) of the agents to see how it affects the global process. \";\t}\t//Initialization of the model\tinit {\t\t//Write the description of the model \t\tdo description;\t\t//Initialization of the places\t\tdo initialize_places;\t\t//Computation of the number of people according to the density of people\t\tnumber_of_people &lt;- int( length (all_places) * density_of_people);\t\t//Initialization of the people\t\tdo initialize_people;\t}\t//Action to initialize places defined in the subclasses\taction initialize_places virtual: true;\t//Action to initialize people in the subclasses\taction initialize_people virtual: true;}//Species base representing the people agentsspecies base {\trgb color;\t//List of all the neighbours agents\tlist&lt;base&gt; my_neighbours;\t//computation of the similar neighbours\tint similar_nearby -&gt; {\t\t(my_neighbours count (each.color = color))\t};\t//Computation of the total neighbours nearby\tint total_nearby -&gt; {\t\tlength (my_neighbours)\t};\t//Boolean to know if the agent is happy or not\tbool is_happy -&gt; {similar_nearby &gt;= (percent_similar_wanted * total_nearby )} ;}Code of the model :model segregation//import the Common Schelling Segregation modelimport \"../include/Common Schelling Segregation.gaml\"global {\t//List of all the free places\tlist&lt;space&gt; free_places ;\t//List of all the places\tlist&lt;space&gt; all_places ;\t//Shape of the world\tgeometry shape &lt;- square(dimensions);\t\t//Action to initialize the people agents\taction initialize_people { \t\tcreate people number: number_of_people; \t\tall_people &lt;- people as list ;  \t} \t//Action to initialize the places\taction initialize_places { \t\tall_places &lt;- shuffle (space);\t\tfree_places &lt;- all_places;  \t} }//Grid to discretize space, each cell representing a free space for the people agentsgrid space width: dimensions height: dimensions neighbors: 8 use_regular_agents: false frequency: 0{\trgb color  &lt;- #black;}//Species representing the people agentsspecies people parent: base  {\t//Color of the people agent\trgb color &lt;- colors at (rnd (number_of_groups - 1));\t//List of all the neighbours of the agent\tlist&lt;people&gt; my_neighbours -&gt; {people at_distance neighbours_distance} ;\t//Cell representing the place of the agent\tspace my_place;\tinit {\t\t//The agent will be located on one of the free places\t\tmy_place &lt;- one_of(free_places);\t\tlocation &lt;- my_place.location; \t\t//As one agent is in the place, the place is removed from the free places\t\tfree_places &gt;&gt; my_place;\t} \t//Reflex to migrate the people agent when it is not happy \treflex migrate when: !is_happy {\t\t//Add the place to the free places as it will move to another place\t\tfree_places &lt;&lt; my_place;\t\t//Change the place of the agent\t\tmy_place &lt;- one_of(free_places);\t\tlocation &lt;- my_place.location; \t\t//Remove the new place from the free places\t\tfree_places &gt;&gt; my_place;\t}\t\taspect default{ \t\tdraw circle (0.5) color: color; \t}}experiment schelling type: gui {\t\toutput {\t\tdisplay Segregation {\t\t\tspecies people;\t\t}\t\t\tdisplay Charts {\t\t\tchart \"Proportion of happiness\" type: pie background: #gray style: exploded position: {0,0} size: {1.0,0.5}{\t\t\t\tdata \"Unhappy\" value: number_of_people - sum_happy_people color: #green;\t\t\t\tdata \"Happy\" value: sum_happy_people color: #yellow;\t\t\t}\t\t\tchart \"Global happiness and similarity\" type: series background: #gray axes: #white position: {0,0.5} size: {1.0,0.5} {\t\t\t\tdata \"happy\" color: #blue value:  (sum_happy_people / number_of_people) * 100 style: spline ;\t\t\t\tdata \"similarity\" color: #red value:  (sum_similar_neighbours / sum_total_neighbours) * 100 style: step ;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Segregation-(Schelling)-Segregation-(Agents).html"
      }
      ,
    
      "wiki-segregation-schelling-segregation-cellular-automata-html": {
        "title": "segregationGrid",
        "content": "segregationGrid_Author : _Imported model :model segregation_baseglobal {\t//Different colors for the group\trgb color_1 &lt;- rgb (\"yellow\") parameter: \"Color of group 1:\" category: \"User interface\";\trgb color_2 &lt;- rgb (\"red\") parameter: \"Color of group 2:\" category: \"User interface\";\trgb color_3 &lt;- rgb (\"blue\") parameter: \"Color of group 3:\" category: \"User interface\";\trgb color_4 &lt;- rgb (\"orange\") parameter: \"Color of group 4:\" category: \"User interface\";\trgb color_5 &lt;- rgb (\"green\") parameter: \"Color of group 5:\" category: \"User interface\";\trgb color_6 &lt;- rgb (\"pink\") parameter: \"Color of group 6:\" category: \"User interface\";   \trgb color_7 &lt;- rgb (\"magenta\") parameter: \"Color of group 7:\" category: \"User interface\";\trgb color_8 &lt;- rgb (\"cyan\") parameter: \"Color of group 8:\" category: \"User interface\";    list colors &lt;- [color_1, color_2, color_3, color_4, color_5, color_6, color_7, color_8] of: rgb;\t\t//Number of groups\tint number_of_groups &lt;- 2 max: 8 parameter: \"Number of groups:\" category: \"Population\";\t//Density of the people\tfloat density_of_people &lt;- 0.7 parameter: \"Density of people:\" category: \"Population\" min: 0.01 max: 0.99;\t//Percentage of similar wanted for segregation\tfloat percent_similar_wanted &lt;- 0.5 min: float (0) max: float (1) parameter: \"Desired percentage of similarity:\" category: \"Population\";\t//Dimension of the grid\tint dimensions &lt;- 40 max: 400 min: 10 parameter: \"Width and height of the environment:\" category: \"Environment\";\t//Neighbours distance for the perception of the agents\tint neighbours_distance &lt;- 2 max: 10 min: 1 parameter: \"Distance of perception:\" category: \"Population\";\t//Number of people agents\tint number_of_people &lt;- 0;\t//Number of happy people\tint sum_happy_people &lt;- 0 update: all_people count (each.is_happy);\t//Number of similar neighbours\tint sum_similar_neighbours &lt;- 0 update: sum (all_people collect each.similar_nearby);\t//Number of neighbours\tint sum_total_neighbours &lt;- 1 update: sum (all_people collect each.total_nearby) min: 1;\t//List of all the places\tlist&lt;agent&gt; all_places;\t//List of all the people\tlist&lt;base&gt; all_people;  \t\t//Action to write the description of the model in the console\taction description {\t\twrite\t\t\"\\\\n\\\\u25B6 Description. \\\\n\\\\u25B6 Thomas Schelling model of residential segregation is a classic study of the effects of local decisions on global dynamics. Agents with mild preferences for same-type neighbors, but without preferences for segregated neighborhoods, can wind up producing complete segregation.\\\\n\\\\u25B6 In this model, agents populate a grid with a given *density*. They are in two different states : happy when the percentage of same-color neighbours is above their *desired percentage of similarity*; unhappy otherwise. In the latter case, they change their location randomly until they find a neighbourhood that fits their desire. \\\\n\\\\u25B6 In addition to the previous parameter, one can adjust the *distance of perception* (i.e.  the distance at which they consider other agents as neighbours) of the agents to see how it affects the global process. \";\t}\t//Initialization of the model\tinit {\t\t//Write the description of the model \t\tdo description;\t\t//Initialization of the places\t\tdo initialize_places;\t\t//Computation of the number of people according to the density of people\t\tnumber_of_people &lt;- int( length (all_places) * density_of_people);\t\t//Initialization of the people\t\tdo initialize_people;\t}\t//Action to initialize places defined in the subclasses\taction initialize_places virtual: true;\t//Action to initialize people in the subclasses\taction initialize_people virtual: true;}//Species base representing the people agentsspecies base {\trgb color;\t//List of all the neighbours agents\tlist&lt;base&gt; my_neighbours;\t//computation of the similar neighbours\tint similar_nearby -&gt; {\t\t(my_neighbours count (each.color = color))\t};\t//Computation of the total neighbours nearby\tint total_nearby -&gt; {\t\tlength (my_neighbours)\t};\t//Boolean to know if the agent is happy or not\tbool is_happy -&gt; {similar_nearby &gt;= (percent_similar_wanted * total_nearby )} ;}Code of the model :model segregation//Importation of the Common Schelling Segregation modelimport \"../include/Common Schelling Segregation.gaml\"//Define the environment as torusglobal torus: true{\t//List of all the free places\tlist&lt;space&gt; free_places ;\t//List of all the places\tlist&lt;space&gt; all_places  ;\t//List of all the people\tlist&lt;space&gt; all_people;\t//Shape of the environment\tgeometry shape &lt;- square(dimensions);\t\t//Action to initialize the places\taction initialize_places {\t\tall_places &lt;- shuffle(space);\t\tfree_places &lt;- shuffle(all_places);\t}\t//Action to initialize the people agents\taction initialize_people {\t\t//Place all the people agent in the cellular automata\t\tloop i from: 0 to: number_of_people - 1 {\t\t\tspace pp &lt;- all_places at i;\t\t\tremove pp from: free_places;\t\t\tadd pp to: all_people;\t\t\tpp.color &lt;- colors at (rnd(number_of_groups - 1));\t\t}\t}\t//Reflex to migrate all the people agents\treflex migrate {\t\task copy(all_people) {\t\t\tdo migrate;\t\t}\t}}//Grid species representing the places and the people in each cellgrid space parent: base width: dimensions height: dimensions neighbors: 8  {\trgb color &lt;- #black;\t//List of the neighbours of the places\tlist&lt;space&gt; my_neighbours &lt;- self neighbors_at neighbours_distance;\t//Action to migrate the agent in another cell if it is not happy\taction migrate {\t\tif !is_happy {\t\t\t//Change the space of the agent to a free space\t\t\tspace pp &lt;- any(my_neighbours where (each.color = #black));\t\t\tif (pp != nil) {\t\t\t\tfree_places &lt;+ self;\t\t\t\tfree_places &gt;- pp;\t\t\t\tall_people &gt;- self;\t\t\t\tall_people &lt;&lt; pp;\t\t\t\tpp.color &lt;- color;\t\t\t\tcolor &lt;- #black;\t\t\t}\t\t}\t}}experiment schelling type: gui {\toutput {\t\tdisplay Segregation {\t\t\tgrid space;\t\t}\t\tdisplay Charts {\t\t\tchart \"Proportion of happiness\" type: pie background: #lightgray style: exploded position: { 0, 0 } size: { 1.0, 0.5 } {\t\t\t\tdata \"Unhappy\" value: number_of_people - sum_happy_people color: #green;\t\t\t\tdata \"Happy\" value: sum_happy_people color: #yellow;\t\t\t}\t\t\tchart \"Global happiness and similarity\" type: series background: #lightgray axes: #white position: { 0, 0.5 } size: { 1.0, 0.5 }  x_range: 50{\t\t\t\tdata \"happy\" color: #blue value: (sum_happy_people / number_of_people) * 100 style: spline;\t\t\t\tdata \"similarity\" color: #red value: (sum_similar_neighbours / sum_total_neighbours) * 100 style: step;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Segregation-(Schelling)-Segregation-(Cellular-Automata).html"
      }
      ,
    
      "wiki-segregation-schelling-segregation-gis-html": {
        "title": "segregationGIS",
        "content": "segregationGIS_Author : _A model showing the segregation of the people just by putting a similarity wanted parameter using agents to represent the individuals and GIS file for the placesImported model :model segregation_baseglobal {\t//Different colors for the group\trgb color_1 &lt;- rgb (\"yellow\") parameter: \"Color of group 1:\" category: \"User interface\";\trgb color_2 &lt;- rgb (\"red\") parameter: \"Color of group 2:\" category: \"User interface\";\trgb color_3 &lt;- rgb (\"blue\") parameter: \"Color of group 3:\" category: \"User interface\";\trgb color_4 &lt;- rgb (\"orange\") parameter: \"Color of group 4:\" category: \"User interface\";\trgb color_5 &lt;- rgb (\"green\") parameter: \"Color of group 5:\" category: \"User interface\";\trgb color_6 &lt;- rgb (\"pink\") parameter: \"Color of group 6:\" category: \"User interface\";   \trgb color_7 &lt;- rgb (\"magenta\") parameter: \"Color of group 7:\" category: \"User interface\";\trgb color_8 &lt;- rgb (\"cyan\") parameter: \"Color of group 8:\" category: \"User interface\";    list colors &lt;- [color_1, color_2, color_3, color_4, color_5, color_6, color_7, color_8] of: rgb;\t\t//Number of groups\tint number_of_groups &lt;- 2 max: 8 parameter: \"Number of groups:\" category: \"Population\";\t//Density of the people\tfloat density_of_people &lt;- 0.7 parameter: \"Density of people:\" category: \"Population\" min: 0.01 max: 0.99;\t//Percentage of similar wanted for segregation\tfloat percent_similar_wanted &lt;- 0.5 min: float (0) max: float (1) parameter: \"Desired percentage of similarity:\" category: \"Population\";\t//Dimension of the grid\tint dimensions &lt;- 40 max: 400 min: 10 parameter: \"Width and height of the environment:\" category: \"Environment\";\t//Neighbours distance for the perception of the agents\tint neighbours_distance &lt;- 2 max: 10 min: 1 parameter: \"Distance of perception:\" category: \"Population\";\t//Number of people agents\tint number_of_people &lt;- 0;\t//Number of happy people\tint sum_happy_people &lt;- 0 update: all_people count (each.is_happy);\t//Number of similar neighbours\tint sum_similar_neighbours &lt;- 0 update: sum (all_people collect each.similar_nearby);\t//Number of neighbours\tint sum_total_neighbours &lt;- 1 update: sum (all_people collect each.total_nearby) min: 1;\t//List of all the places\tlist&lt;agent&gt; all_places;\t//List of all the people\tlist&lt;base&gt; all_people;  \t\t//Action to write the description of the model in the console\taction description {\t\twrite\t\t\"\\\\n\\\\u25B6 Description. \\\\n\\\\u25B6 Thomas Schelling model of residential segregation is a classic study of the effects of local decisions on global dynamics. Agents with mild preferences for same-type neighbors, but without preferences for segregated neighborhoods, can wind up producing complete segregation.\\\\n\\\\u25B6 In this model, agents populate a grid with a given *density*. They are in two different states : happy when the percentage of same-color neighbours is above their *desired percentage of similarity*; unhappy otherwise. In the latter case, they change their location randomly until they find a neighbourhood that fits their desire. \\\\n\\\\u25B6 In addition to the previous parameter, one can adjust the *distance of perception* (i.e.  the distance at which they consider other agents as neighbours) of the agents to see how it affects the global process. \";\t}\t//Initialization of the model\tinit {\t\t//Write the description of the model \t\tdo description;\t\t//Initialization of the places\t\tdo initialize_places;\t\t//Computation of the number of people according to the density of people\t\tnumber_of_people &lt;- int( length (all_places) * density_of_people);\t\t//Initialization of the people\t\tdo initialize_people;\t}\t//Action to initialize places defined in the subclasses\taction initialize_places virtual: true;\t//Action to initialize people in the subclasses\taction initialize_people virtual: true;}//Species base representing the people agentsspecies base {\trgb color;\t//List of all the neighbours agents\tlist&lt;base&gt; my_neighbours;\t//computation of the similar neighbours\tint similar_nearby -&gt; {\t\t(my_neighbours count (each.color = color))\t};\t//Computation of the total neighbours nearby\tint total_nearby -&gt; {\t\tlength (my_neighbours)\t};\t//Boolean to know if the agent is happy or not\tbool is_happy -&gt; {similar_nearby &gt;= (percent_similar_wanted * total_nearby )} ;}Code of the model :model segregation//Import the model Common Schelling Segregationimport \"../include/Common Schelling Segregation.gaml\" global {\t//List of all the free places\tlist&lt;space&gt; free_places  ;  \t//List of all the places\tlist&lt;space&gt; all_places ;\t//Neighbours distance for the perception of an agent\tint neighbours_distance &lt;- 50 min: 1 parameter: \"Distance of perception:\" category: \"Population\" max: 1000;\t//Shapefile to load\tfile shape_file_name &lt;- file(\"../gis/nha2.shp\") parameter: \"Shapefile to load:\" category: \"GIS specific\";\t//Shape of the environment\tgeometry shape &lt;- envelope(shape_file_name);\t//Square meters per people in m2\tint square_meters_per_people &lt;- 200 parameter: \"Occupancy of people (in m2):\" category: \"GIS specific\";\t\t//Action to initialize people agents\taction initialize_people { \t\t//Create all the places with a surface given within the shapefile\t\tcreate space from: shape_file_name with: [surface :: float(read(\"AREA\"))];\t\tall_places  &lt;- shuffle(space);\t\t//Compute the number of people to create considering the density of people\t\tnumber_of_people &lt;- int( density_of_people * sum (all_places collect (each.capacity))); \t\tcreate people number: number_of_people;  \t    all_people &lt;- people as list ; \t    //Move all the people to a new place\t\task people  {  \t\t\tdo move_to_new_place;       \t\t}   \t}      \t//Action to initialize the places\taction initialize_places {}   \t} //Species people representing the peoplespecies people parent: base { \t//Size of the people agent\tfloat size const: true &lt;- 2.0;\t//Color of the people agent  \trgb color const: true &lt;- colors at (rnd (number_of_groups - 1)); \tint red const: true &lt;- (color as list) at 0; \tint green const: true &lt;- (color as list) at 1;  \tint blue const: true &lt;- (color as list) at 2;  \t//Building in which the agent lives\tspace current_building &lt;- nil;\t//List of all the neighbour people agents\tlist&lt;people&gt; my_neighbours -&gt; {people at_distance neighbours_distance}; \t\t//Action to move to a new place\taction move_to_new_place {  \t\tcurrent_building &lt;- (shuffle(all_places) first_with (((each).capacity) &gt; 0));\t\task current_building {\t\t\tdo accept one_people: myself;   \t\t}\t}\t//Reflex to migrate to another place if the agent isn't happy\treflex migrate when: !is_happy {\t\tif current_building != nil {\t\t\task current_building { \t\t\t\tdo remove_one one_people: myself;\t\t\t}\t\t} \t\tdo move_to_new_place;\t}\taspect simple {\t\tdraw circle(5) color: color;\t}}//Species space representing a space for a people agent to live inspecies space {\t\t//List of all the people agents living within\tlist&lt;people&gt; insiders;\trgb color &lt;- rgb(255, 255, 255); \t//Surface of the place\tfloat surface;\t//Capacity of the place\tint capacity  &lt;- 1 + int(surface / square_meters_per_people);\t\t//Action to accept a people agent  \taction accept (people one_people) {\t\tadd one_people to: insiders;\t\tlocation of one_people &lt;- any_location_in(shape);\t\tcapacity &lt;- capacity - 1;\t}\t//Action to remove a people agent\taction remove_one (people one_people){\t\tremove one_people from: insiders;\t\tcapacity &lt;- capacity + 1;\t}\taspect simple {\t\tcolor &lt;- empty(insiders) ? #white : rgb ([mean (insiders collect each.red), mean (insiders collect each.green), mean (insiders collect each.blue)]);\t\tdraw  square(40) color: color;\t}\taspect gis {\t\tcolor &lt;- empty(insiders) ? #white : rgb( [mean (insiders collect each.red), mean (insiders collect each.green), mean (insiders collect each.blue)]);\t\tdraw shape color: color border: #black;\t} \taspect highlighted {\t\tcolor &lt;- #blue;\t\tdraw shape+10 color: color;\t}}experiment schelling type: gui {\t\toutput {\t\tdisplay Town_display  {\t\t\tspecies space aspect: gis;\t\t\tspecies people  aspect: simple;\t\t}\t\tdisplay Charts {\t\t\tchart \"Proportion of happiness\" type: histogram background: #lightgray gap:0.05 position: {0,0} size: {1.0,0.5}{\t\t\t\tdata \"Unhappy\" value: number_of_people - sum_happy_people color: #green;\t\t\t\tdata \"Happy\" value: sum_happy_people color: #yellow ;\t\t\t}\t\t\tchart \"Global happiness and similarity\" type: series background: #lightgray axes: #white position: {0,0.5} size: {1.0,0.5} {\t\t\t\tdata \"happy\" color: #blue value:  ((sum_happy_people * 100) / number_of_people)  style: spline ;\t\t\t\tdata \"similarity\" color: #red value:  (sum_similar_neighbours / sum_total_neighbours) * 100 style: step ;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Segregation-(Schelling)-Segregation-(GIS).html"
      }
      ,
    
      "wiki-segregation-schelling-segregation-google-map-html": {
        "title": "segregationGoogleMap",
        "content": "segregationGoogleMap_Author : _A model showing the segregation of the people just by putting a similarity wanted parameter using agents to represent the individuals and a grid to discretize space. Use the colors of the image to know if it is a possible space or notImported model :model segregation_baseglobal {\t//Different colors for the group\trgb color_1 &lt;- rgb (\"yellow\") parameter: \"Color of group 1:\" category: \"User interface\";\trgb color_2 &lt;- rgb (\"red\") parameter: \"Color of group 2:\" category: \"User interface\";\trgb color_3 &lt;- rgb (\"blue\") parameter: \"Color of group 3:\" category: \"User interface\";\trgb color_4 &lt;- rgb (\"orange\") parameter: \"Color of group 4:\" category: \"User interface\";\trgb color_5 &lt;- rgb (\"green\") parameter: \"Color of group 5:\" category: \"User interface\";\trgb color_6 &lt;- rgb (\"pink\") parameter: \"Color of group 6:\" category: \"User interface\";   \trgb color_7 &lt;- rgb (\"magenta\") parameter: \"Color of group 7:\" category: \"User interface\";\trgb color_8 &lt;- rgb (\"cyan\") parameter: \"Color of group 8:\" category: \"User interface\";    list colors &lt;- [color_1, color_2, color_3, color_4, color_5, color_6, color_7, color_8] of: rgb;\t\t//Number of groups\tint number_of_groups &lt;- 2 max: 8 parameter: \"Number of groups:\" category: \"Population\";\t//Density of the people\tfloat density_of_people &lt;- 0.7 parameter: \"Density of people:\" category: \"Population\" min: 0.01 max: 0.99;\t//Percentage of similar wanted for segregation\tfloat percent_similar_wanted &lt;- 0.5 min: float (0) max: float (1) parameter: \"Desired percentage of similarity:\" category: \"Population\";\t//Dimension of the grid\tint dimensions &lt;- 40 max: 400 min: 10 parameter: \"Width and height of the environment:\" category: \"Environment\";\t//Neighbours distance for the perception of the agents\tint neighbours_distance &lt;- 2 max: 10 min: 1 parameter: \"Distance of perception:\" category: \"Population\";\t//Number of people agents\tint number_of_people &lt;- 0;\t//Number of happy people\tint sum_happy_people &lt;- 0 update: all_people count (each.is_happy);\t//Number of similar neighbours\tint sum_similar_neighbours &lt;- 0 update: sum (all_people collect each.similar_nearby);\t//Number of neighbours\tint sum_total_neighbours &lt;- 1 update: sum (all_people collect each.total_nearby) min: 1;\t//List of all the places\tlist&lt;agent&gt; all_places;\t//List of all the people\tlist&lt;base&gt; all_people;  \t\t//Action to write the description of the model in the console\taction description {\t\twrite\t\t\"\\\\n\\\\u25B6 Description. \\\\n\\\\u25B6 Thomas Schelling model of residential segregation is a classic study of the effects of local decisions on global dynamics. Agents with mild preferences for same-type neighbors, but without preferences for segregated neighborhoods, can wind up producing complete segregation.\\\\n\\\\u25B6 In this model, agents populate a grid with a given *density*. They are in two different states : happy when the percentage of same-color neighbours is above their *desired percentage of similarity*; unhappy otherwise. In the latter case, they change their location randomly until they find a neighbourhood that fits their desire. \\\\n\\\\u25B6 In addition to the previous parameter, one can adjust the *distance of perception* (i.e.  the distance at which they consider other agents as neighbours) of the agents to see how it affects the global process. \";\t}\t//Initialization of the model\tinit {\t\t//Write the description of the model \t\tdo description;\t\t//Initialization of the places\t\tdo initialize_places;\t\t//Computation of the number of people according to the density of people\t\tnumber_of_people &lt;- int( length (all_places) * density_of_people);\t\t//Initialization of the people\t\tdo initialize_people;\t}\t//Action to initialize places defined in the subclasses\taction initialize_places virtual: true;\t//Action to initialize people in the subclasses\taction initialize_people virtual: true;}//Species base representing the people agentsspecies base {\trgb color;\t//List of all the neighbours agents\tlist&lt;base&gt; my_neighbours;\t//computation of the similar neighbours\tint similar_nearby -&gt; {\t\t(my_neighbours count (each.color = color))\t};\t//Computation of the total neighbours nearby\tint total_nearby -&gt; {\t\tlength (my_neighbours)\t};\t//Boolean to know if the agent is happy or not\tbool is_happy -&gt; {similar_nearby &gt;= (percent_similar_wanted * total_nearby )} ;}Code of the model :model segregation//Import the model Common Schelling Segregationimport \"../include/Common Schelling Segregation.gaml\"    global {\t//List of all the free places\tlist&lt;space&gt; free_places ; \t//List of all the places\tlist&lt;space&gt; all_places;\t//Shape of the environment\tgeometry shape &lt;- square(dimensions);\t//Percentage of similarity wanted by an agent\tfloat percent_similar_wanted &lt;- 0.6;\t//Distance of perception of the neighbours\tint neighbours_distance &lt;- 4; \t//Number of groups of people\tint number_of_groups &lt;- 3;\tlist google_buildings  &lt;- [rgb(\"#EBE6DC\"), rgb(\"#D1D0CD\"), rgb(\"#F2EFE9\"), rgb(\"#EEEBE1\"), rgb(\"#F9EFE8\")] ;\t//List of all the available places\tlist&lt;space&gt; available_places ;\t//Image file to load\tfile bitmap_file_name &lt;- file&lt;unknown, int&gt;(\"../images/hanoi.png\") parameter: \"Name of image file to load:\" category: \"Environment\" ;\tmatrix&lt;int&gt; map_colors;  \t//Action to initialize the people agents\taction initialize_people {\t\tcreate people number: number_of_people ;  \t\tall_people &lt;- people as list ;  \t}\t//Action to initialize the places using the color in the image\taction initialize_places { \t\tmap_colors &lt;- (bitmap_file_name) as_matrix {dimensions,dimensions} ;\t\task space as list {\t\t\tcolor &lt;- rgb(map_colors at {grid_x,grid_y}) ;\t\t}\t\tall_places &lt;- shuffle (space where (each.color in google_buildings)) ;\t\tfree_places &lt;- copy(all_places);\t}  }//Grid to discretize the spacegrid space width: dimensions height: dimensions neighbors: 8 use_individual_shapes: false use_regular_agents: false frequency: 0 ;  //Species people representing the people agentspecies people parent: base  {\trgb color &lt;- colors at (rnd (number_of_groups - 1));\t//List of all the neighbours\tlist&lt;people&gt; my_neighbours -&gt; {(self neighbors_at neighbours_distance) of_species people};\t\t//Launched at the initialization of the agent\tinit {\t\t//Set the place of the agent as one of the free place\t\tlocation &lt;- (one_of(free_places)).location; \t\tremove location as space from: free_places;\t} \t//Reflex to migrate the agent when it's not happy\treflex migrate when: !is_happy { \t\tadd location as space to: free_places;\t\tlocation &lt;- any(free_places).location;\t\tremove location as space from: free_places;\t}\taspect geom {\t\tdraw square(1) color: color  ;\t}\taspect default {\t\tdraw  square(2) color: #black ;\t}}experiment schelling type: gui {\t\toutput {\t\tdisplay Segregation {\t\t\timage \"bg\" file: bitmap_file_name.path ;\t\t\tspecies people transparency: 0.5 aspect: geom;\t\t}\t\t\tdisplay Charts {\t\t\tchart \"Proportion of happiness\" type: pie background: #lightgray style: exploded position: { 0, 0 } size: { 1.0, 0.5 } {\t\t\t\tdata \"Unhappy\" value: number_of_people - sum_happy_people color: #green;\t\t\t\tdata \"Happy\" value: sum_happy_people color: #yellow;\t\t\t}\t\t\tchart \"Global happiness and similarity\" type: series background: #lightgray axes: #white position: { 0, 0.5 } size: { 1.0, 0.5 } x_range: 20 y_range: 20 {\t\t\t\tdata \"happy\" color: °blue value: (sum_happy_people / number_of_people) * 100 style: spline fill: false;\t\t\t\tdata \"similarity\" color: °red value: (sum_similar_neighbours / sum_total_neighbours) * 100 style: line fill: true ;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Segregation-(Schelling)-Segregation-(Google-Map).html"
      }
      ,
    
      "wiki-segregation-schelling-html": {
        "title": "Segregation (Schelling)",
        "content": "Segregation (Schelling)This sub-section is composed of the following models :      segregationAgents        segregationGrid        segregationGIS        segregationGoogleMap  ",
        "url":"/wiki/Segregation-(Schelling).html"
      }
      ,
    
      "wiki-serializeagents-html": {
        "title": "Syntax in GAML",
        "content": "Using SavedAgent kind of GamlAgent, it is now possible to serialize and unserialize agents and simulations as a string. It can be done using the operators: serializeSimulation, unserializeSimulation, saveSimulation of ummisco.gama.serialize.Need to be improved:  serialization of random generator  serialization of shapes  to allow any agent to be serializedExample of use of the two operators:experiment toto {\tlist&lt;string&gt; history &lt;- [];\treflex store when: (cycle &lt; 6){\t\tadd serializeSimulation(cycle) to: history;\t}\t\treflex restore when: (cycle = 6){\t\tint i &lt;- unSerializeSimulation(string(history[0]));\t} \t\treflex store22 when: cycle=2{\t\twrite \"Sauvegarde de la simulation \" + saveSimulation(\"file.xml\");\t}}Syntax in GAMLHow to make it as simple as possible for the modeler to save and restore simulation states, or come back in time ?(like the creation of new simulations, for instance, which reuses exactly the same syntax than the creation of agents) ?Statementsstore (to differentiate it from save) ?  to:  a filerestore with facets that could allow to precise:  at: a cycle number (to come back at a certain point in time)  at:  a negative number (to come back relatively in time)  at:  a date ?  from: a file  `",
        "url":"/wiki/SerializeAgents.html"
      }
      ,
    
      "wiki-soccer-soccer-html": {
        "title": "Soccer Game",
        "content": "Soccer GameAuthor : JulienThis model shows how can we make an easy simulation of collective games, such as soccer. Each player have an offensive and a defensive position, and a behavior associated. Each player of the defensive team can either search to catch the ball or mark an other player (offensive player) according to his defensive position.Each player of the offensive team can either run to its offensive place (when he does not have the ball), run with the balloon / pass the ball / try to score a goal (when he has the ball). By changing the different parameters, you can see the concequences in real time.Code of the model :model soccerglobal {\tgeometry shape &lt;- rectangle(120#m,90#m);\tfloat red_players_speed &lt;- 1.0;\tfloat blue_players_speed &lt;- 1.0;\tfloat red_size_play_area &lt;- 30.0 min:1.0 max:100.0;\tfloat blue_size_play_area &lt;- 30.0 min: 1.0 max:100.0;\tfloat previous_red_size_play_area &lt;- red_size_play_area; // just to check if the parameter value has been changed\tfloat previous_blue_size_play_area &lt;- blue_size_play_area; // just to check if the parameter value has been changed\tfloat red_collective_play &lt;- 0.5 min:0.0 max:1.0;\tfloat blue_collective_play &lt;- 0.5 min:0.0 max:1.0;\tfloat red_recuperation_ability &lt;- 0.5 min:0.0 max:1.0;\tfloat blue_recuperation_ability &lt;- 0.5 min:0.0 max:1.0;\t\tint red_score &lt;- 0;\tint red_possession &lt;- 0;\tint nb_red_pass &lt;- 0;\tint nb_red_pass_succeed &lt;- 0;\tint nb_red_interception &lt;- 0;\tint blue_score &lt;- 0;\tint blue_possession &lt;- 0;\tint nb_blue_pass &lt;- 0;\tint nb_blue_pass_succeed &lt;- 0;\tint nb_blue_interception &lt;- 0;\t\tbool show_status &lt;- false;\tbool show_area &lt;- false;\tbool show_marked_player &lt;- false;\tbool show_ball_indicator &lt;- false;\t\tbool play_with_offside &lt;- true;\t\tlist&lt;point&gt; bluePlayerPosition &lt;- [{8,10}, {8,80}, {10,30}, {10,60},\t\t{30,25}, {28,45}, {30,65},\t\t{50,25}, {50,65}, {55,45}\t];\t\tlist&lt;point&gt; redPlayerPosition &lt;- [{120-8,10}, {120-8,80}, {120-10,30}, {120-10,60},\t\t{120-30,25}, {120-28,45}, {120-30,65},\t\t{120-50,25}, {120-50,65}, {120-55,45}\t];\t\tball ball_agent;\tplayer closest_red_player_from_the_ball;\tplayer closest_blue_player_from_the_ball;\tplayer called_player;\tstring team_possession &lt;- \"\";\tfloat blue_offside_pos &lt;- 120.0;\tfloat red_offside_pos &lt;- 0.0;\t\tinit {\t\tloop pos over:redPlayerPosition {\t\t\tcreate player with:[team::\"red\", location::pos];\t\t}\t\tloop pos over:bluePlayerPosition {\t\t\tcreate player with:[team::\"blue\", location::pos];\t\t}\t\tcreate ball with:[location::location] returns:ball_agt;\t\tball_agent&lt;-ball_agt at 0;\t\tcreate goal with:[location::{0,location.y}, team::\"blue\"];\t\tcreate goal with:[location::{120,location.y}, team::\"red\"];\t}\t\treflex update {\t\tfloat shortest_distance &lt;- 100.0;\t\tfloat offside_pos &lt;- 0.0;\t\task player where (each.team = \"red\") {\t\t\tif (distance_to_ball &lt; shortest_distance and inactivity_time=0) {\t\t\t\tclosest_red_player_from_the_ball &lt;- self;\t\t\t\tshortest_distance &lt;- distance_to_ball;\t\t\t}\t\t\tif (location.x &gt; offside_pos) {\t\t\t\toffside_pos &lt;- location.x;\t\t\t\tred_offside_pos &lt;- offside_pos;\t\t\t}\t\t}\t\tif (not play_with_offside) {\t\t\tred_offside_pos &lt;- 120.0;\t\t}\t\t\t\tshortest_distance &lt;- 100.0;\t\toffside_pos &lt;- 100.0;\t\task player where (each.team = \"blue\") {\t\t\tif (distance_to_ball &lt; shortest_distance and inactivity_time=0) {\t\t\t\tclosest_blue_player_from_the_ball &lt;- self;\t\t\t\tshortest_distance &lt;- distance_to_ball;\t\t\t}\t\t\tif (location.x &lt; offside_pos) {\t\t\t\toffside_pos &lt;- location.x;\t\t\t\tblue_offside_pos &lt;- offside_pos;\t\t\t}\t\t}\t\tif (not play_with_offside) {\t\t\tblue_offside_pos &lt;- 0.0;\t\t}\t\t\t\tif (previous_red_size_play_area != red_size_play_area) {\t\t\task area where (each.team = \"red\") {\t\t\t\tdo update_size;\t\t\t}\t\t\tprevious_red_size_play_area &lt;- red_size_play_area;\t\t}\t\tif (previous_blue_size_play_area != blue_size_play_area) {\t\t\task area where (each.team = \"blue\") {\t\t\t\tdo update_size;\t\t\t}\t\t\tprevious_blue_size_play_area &lt;- blue_size_play_area;\t\t}\t\tif (team_possession = \"blue\") {\t\t\tblue_possession &lt;- blue_possession + 1;\t\t}\t\tif (team_possession = \"red\") {\t\t\tred_possession &lt;- red_possession + 1;\t\t}\t}\t\taction reinit_phase {\t\task player {\t\t\tlocation &lt;- init_pos;\t\t\tprevious_pos &lt;- init_pos;\t\t}\t\tball_agent.location &lt;- location;\t\tball_agent.destination &lt;- location;\t\tball_agent.speed &lt;- 0.0;\t}}species player skills:[moving] {\tstring team &lt;- \"\"; // value : \"blue\" (left side) or \"red\" (right side)\tbool possess_ball &lt;- false;\tint inactivity_time &lt;- 0 update:(inactivity_time&lt;=0) ? 0 : inactivity_time-1;\tint seed &lt;- rnd(100);\tpoint init_pos;\tpoint previous_pos;\t\t// strategy\tarea defensive_pos;\tarea offensive_pos;\tplayer marked_player;\tfloat collective_mark &lt;- 0.5 update:(team=\"red\") ? red_collective_play : blue_collective_play;\tfloat recuperation_mark &lt;- 0.5 update:(team=\"red\") ? red_recuperation_ability : blue_recuperation_ability;\t\tstring status &lt;- \"\";\t\t// moving attributes\tfloat running_speed_without_ball &lt;- 0.8 update:(team=\"red\") ? red_players_speed*0.8 : blue_players_speed*0.8;\tfloat running_speed_with_ball &lt;- 0.6 update:(team=\"red\") ? red_players_speed*0.5 : blue_players_speed*0.5;\tfloat speed &lt;- 0.0 max:1.2;\tpoint velocity &lt;- {0,0};\t\tfloat distance_to_closest_ennemy &lt;- 100.0;\tfloat distance_to_ennemy_goal &lt;- 100.0 update:self distance_to ( (goal where (each.team != team)) at 0);\tfloat distance_to_ball &lt;- 100.0 update:self distance_to ball_agent;\t\tinit {\t\tinit_pos &lt;- location;\t\tprevious_pos &lt;- location;\t\tcreate area with:[location::init_pos, team::self.team, position::init_pos] returns:def_pos;\t\tdefensive_pos &lt;- def_pos at 0;\t\tpoint offensivePos &lt;- {(team=\"red\") ? init_pos.x-60 : init_pos.x+60,init_pos.y};\t\tcreate area with:[location::offensivePos, team::self.team, position::offensivePos] returns:off_pos;\t\toffensive_pos &lt;- off_pos at 0;\t}\t\treflex update_status {\t\tdistance_to_closest_ennemy &lt;- 100.0;\t\tloop pl over:player where (each.team != team) {\t\t\tfloat distance_to_ennemy &lt;- self distance_to pl;\t\t\tif (distance_to_ennemy &lt; distance_to_closest_ennemy) {\t\t\t\tdistance_to_closest_ennemy &lt;- distance_to_ennemy;\t\t\t}\t\t}\t}\t\treflex defensive_behavior when:team_possession != team {\t\t// the ball is not possessed by the team.\t\tdo apply_inertia;\t\tif (self = closest_red_player_from_the_ball or self = closest_blue_player_from_the_ball) {\t\t\tdo run_to_ball;\t\t}\t\telse {\t\t\tdo defensive_move;\t\t}\t}\t\treflex offensive_behavior when:team_possession = team {\t\tdo apply_inertia;\t\tif (possess_ball) {\t\t\tdo run_with_ball;\t\t\tif (distance_to_ennemy_goal &lt; 30 and flip(1/(distance_to_ennemy_goal*distance_to_ennemy_goal/10+1))) {\t\t\t\t// shoot !\t\t\t\tdo kick_ball_to_goal;\t\t\t}\t\t\telse {\t\t\t\t// pass !\t\t\t\tif (distance_to_closest_ennemy &lt; 5) {\t\t\t\t\tif (flip(collective_mark)) {\t\t\t\t\t\tdo pass_the_ball;\t\t\t\t\t}\t\t\t\t}\t\t\t\telse if flip(collective_mark/50) {\t\t\t\t\tdo pass_the_ball;\t\t\t\t}\t\t\t}\t\t}\t\telse if (ball_agent.belong_to_team = \"\" and\t\t\t(self = closest_red_player_from_the_ball or self = closest_blue_player_from_the_ball\t\t\tor self = called_player)\t\t) {\t\t\tdo run_to_ball;\t\t}\t\telse {\t\t\tdo offensive_move;\t\t}\t}\t\treflex choose_player_to_mark when:(cycle mod 20=seed or cycle=0) {\t\tif ( not empty(player where(each.offensive_pos intersects defensive_pos)) ) {\t\t\tmarked_player &lt;- 1 among (player where((each.offensive_pos intersects defensive_pos) and (each.team != team))) at 0;\t\t}\t}\t\taction apply_inertia {\t\tpoint prev_pos &lt;- location;\t\tpoint inertia_vect &lt;- {(location.x-previous_pos.x)*0.8,(location.y-previous_pos.y)*0.8};\t\tfloat max_inertia &lt;- running_speed_without_ball;\t\tif (norm(inertia_vect) &gt; max_inertia) {\t\t\tfloat inertia_x &lt;-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));\t\t\tfloat inertia_y &lt;-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));\t\t\tinertia_x &lt;- (inertia_vect.x &lt; 0) ? -inertia_x : inertia_x;\t\t\tinertia_y &lt;- (inertia_vect.y &lt; 0) ? -inertia_y : inertia_y;\t\t\tinertia_vect &lt;- {inertia_x,inertia_y};\t\t}\t\tlocation &lt;- location + inertia_vect;\t\tprevious_pos &lt;- prev_pos;\t}\t\taction run_to_ball {\t\tpoint targetPos;\t\tif (ball_agent.ball_direction intersects circle(1)) {\t\t\ttargetPos &lt;- ball_agent.location;\t\t}\t\telse {\t\t\ttargetPos &lt;- (ball_agent.ball_direction closest_points_with self) at 0;\t\t}\t\tdo goto with:[target::targetPos, speed::running_speed_without_ball];\t\t\t\tstatus &lt;- \"run to the ball\";\t\t\t\t// if close enough, catch the ball\t\tif (location distance_to ball_agent.location &lt; 1.5#m) {\t\t\tif (self = called_player) {\t\t\t\tdo take_ball;\t\t\t}\t\t\telse if (ball_agent.belong_to_team = \"\") {\t\t\t\tif flip(1/(ball_agent.speed*recuperation_mark+1)) {\t\t\t\t\tdo take_ball;\t\t\t\t}\t\t\t}\t\t\telse {\t\t\t\tif (team_possession = team) {\t\t\t\t\t// result of a long pass for instance\t\t\t\t\tif (flip(recuperation_mark*1.5)) {\t\t\t\t\t\tdo take_ball;\t\t\t\t\t}\t\t\t\t}\t\t\t\telse {\t\t\t\t\t// interception of the ball\t\t\t\t\tif (flip(recuperation_mark*0.8)) {\t\t\t\t\t\tdo take_ball;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t}\t\taction run_with_ball {\t\tstatus &lt;- \"run with the ball\";\t\tpoint goal_pos;\t\task goal {\t\t\tif (self.team != myself.team) {\t\t\t\tgoal_pos &lt;- location;\t\t\t}\t\t}\t\tdo goto with:[target::goal_pos, speed::running_speed_with_ball];\t\tball_agent.location &lt;- location;\t}\t\taction offensive_move {\t\t// try to reach an offensive postion\t\tpoint target_location;\t\tgeometry possible_pos &lt;- (team=\"red\") ? world inter (rectangle({blue_offside_pos,0},{120,90}))\t\t: world inter (rectangle({0,0},{red_offside_pos,90}));\t\t\t\t\t\t// check if the player is in the field\t\tif (location.y &lt; 0) {\t\t\ttarget_location &lt;- {location.x,90};\t\t}\t\telse if (location.y &gt; 90) {\t\t\ttarget_location &lt;- {location.x,0};\t\t}\t\t// check if the player is in offside position\t\telse if ( (location.x &gt; red_offside_pos and team = \"blue\") or (location.x &lt; blue_offside_pos and team = \"red\")) {\t\t\ttarget_location &lt;- (team=\"red\") ? {120,location.y} : {0,location.y};\t\t\tstatus &lt;- \"run to a non offside position\";\t\t}\t\telse {\t\t\tstatus &lt;- \"run to a offensive place\";\t\t\tif (not (possible_pos intersects offensive_pos)) {\t\t\t\ttarget_location &lt;- (team=\"red\") ? {blue_offside_pos,location.y} : {red_offside_pos,location.y};\t\t\t}\t\t\telse\t\t\t{\t\t\t\ttarget_location &lt;- any_location_in(offensive_pos inter possible_pos);\t\t\t}\t\t}\t\tdo goto target:target_location speed:running_speed_without_ball;\t}\t\taction defensive_move {\t\t// try to mark an ennemy player\t\tstatus &lt;- \"mark ennemy player\";\t\tif (not (marked_player = nil)) {\t\t\tdo goto with:[target::marked_player.location+((team=\"red\")?{2+rnd(5.0),rnd(2.0)-1} : {-2-rnd(5.0),rnd(2.0)-1}), speed::running_speed_without_ball];\t\t}\t}\t\taction kick_ball_to_goal {\t\tdo loose_ball;\t\task ball_agent {\t\t\tdo shooted speed_atr:4.0 target_position:((goal where (each.team != myself.team)) at 0).location;\t\t}\t\tinactivity_time &lt;- 20;\t}\t\taction pass_the_ball {\t\tfloat wisest_choice_mark &lt;- -100.0;\t\tplayer wisest_target;\t\task player  where(each.team = team and each != self and (self distance_to each &gt; 15)) {\t\t\tint number_of_ennemies_on_range &lt;- length(player at_distance 5 where (each.team != myself.team));\t\t\tfloat wise_choice_mark &lt;- 100-distance_to_ball+number_of_ennemies_on_range*10-2*distance_to_ennemy_goal;\t\t\tif (wise_choice_mark &gt; wisest_choice_mark) {\t\t\t\twisest_target &lt;- self;\t\t\t\twisest_choice_mark &lt;- wise_choice_mark;\t\t\t}\t\t}\t\tif (wisest_choice_mark &gt; -100.0) {\t\t\t// a target has been found\t\t\tdo loose_ball;\t\t\task ball_agent {\t\t\t\tdo shooted target_position:wisest_target.location speed_atr:wisest_target.distance_to_ball/8;\t\t\t}\t\t\tcalled_player &lt;- wisest_target;\t\t\tinactivity_time &lt;- 20;\t\t\tif (team = \"red\") {nb_red_pass &lt;- nb_red_pass+1;}\t\t\telse {nb_blue_pass &lt;- nb_blue_pass+1;}\t\t}\t}\t\taction take_ball {\t\tif (ball_agent.belong_to_team != \"\" and ball_agent.belong_to_team != team) {\t\t\task ball_agent.belong_to_player {\t\t\t\tdo loose_ball;\t\t\t}\t\t}\t\tteam_possession &lt;- team;\t\tpossess_ball &lt;- true;\t\tball_agent.belong_to_team &lt;- team;\t\tball_agent.belong_to_player &lt;- self;\t\tball_agent.speed &lt;- 0.0;\t\tif (self = called_player) {\t\t\tif (team = \"red\") {nb_red_pass_succeed &lt;- nb_red_pass_succeed+1;}\t\t\telse {nb_blue_pass_succeed &lt;- nb_blue_pass_succeed+1;}\t\t}\t\telse {\t\t\tif (team = \"red\") {nb_red_interception &lt;- nb_red_interception+1;}\t\t\telse {nb_blue_interception &lt;- nb_blue_interception+1;}\t\t}\t\tcalled_player &lt;- nil;\t}\t\taction loose_ball {\t\tpossess_ball &lt;- false;\t\tball_agent.belong_to_team &lt;- \"\";\t}\t\taspect base {\t\tdraw circle(1) color:(team=\"red\") ? #red : #blue;\t\tif (show_status) {\t\t\tdraw string(status);\t\t\tif (marked_player != nil) {\t\t\t\tdraw polyline([location,marked_player.location]);\t\t\t}\t\t}\t\tif (marked_player != nil and show_marked_player) {\t\t\tdraw polyline([location,marked_player.location]) end_arrow:1 color:#chartreuse;\t\t}\t}}species area {\tstring team &lt;- \"\";\tpoint position;\t\tinit {\t\tshape &lt;- ((team=\"red\") ? square(red_size_play_area) : square(blue_size_play_area)) inter world;\t}\t\taction update_size {\t\tlocation &lt;- position;\t\tshape &lt;- ((team=\"red\") ? square(red_size_play_area) : square(blue_size_play_area)) inter world;\t}\t\taspect base {\t\tif (show_area) {\t\t\tdraw shape color:rgb(128,128,128,50) border:(team=\"red\") ? rgb(256,0.0,0.0,100) : rgb(0.0,0.0,256.0,100);\t\t}\t}}species ball skills:[moving]{\tstring belong_to_team &lt;- \"\";\tplayer belong_to_player;\tfloat speed &lt;- 0.0 update:speed*0.9;\tlist&lt;point&gt; nextPlace;\tgeometry ball_direction;\treflex update {\t\tfloat future_speed &lt;- speed;\t\tpoint tmpPos&lt;-location;\t\tloop i from:0 to:10 {\t\t\ttmpPos &lt;- {tmpPos.x+cos(heading)*speed,tmpPos.y+sin(heading)*speed};\t\t\tfuture_speed &lt;- future_speed*0.9;\t\t}\t\tball_direction &lt;- line([location,tmpPos]);\t\tif ((location.x+cos(heading)*speed) &gt; 120) {\t\t\tblue_score &lt;- blue_score + 1;\t\t\task world {\t\t\t\tdo reinit_phase;\t\t\t}\t\t}\t\tif ((location.x+cos(heading)*speed) &lt; 0) {\t\t\tred_score &lt;- red_score + 1;\t\t\task world {\t\t\t\tdo reinit_phase;\t\t\t}\t\t}\t\tdo wander amplitude:1;\t}\taction shooted (point target_position, float speed_atr) {\t\tspeed &lt;- speed_atr;\t\tdo goto target:target_position;\t}\taspect base {\t\tdraw circle(0.5) color:#white border:#black;\t\tif (show_ball_indicator) {\t\t\tdraw ball_direction end_arrow:1 color:#chartreuse;\t\t\tif (team_possession=\"red\") {\t\t\t\tdraw circle(0.5) color:#darkred border:#black;\t\t\t}\t\t\telse if (team_possession=\"blue\") {\t\t\t\tdraw circle(0.5) color:#darkblue border:#black;\t\t\t}\t\t}\t}}species goal {\tstring team &lt;- \"\";\taspect base {\t\tdraw rectangle(0.1,7.32) color:#black;\t}}experiment match type:gui {\tparameter \"blue running speed\" var:blue_players_speed category:\"Blue Team\";\tparameter \"red running speed\" var:red_players_speed category:\"Red Team\";\t// speed of players when they run. Note that a player which have the ball will run at 50% of his max capacity, and he will run at 80% of his max capacity if he does not have the ball.\t\tparameter \"blue collective play\" var:blue_collective_play category:\"Blue Team\";\tparameter \"red collective play\" var:red_collective_play category:\"Red Team\";\t// propention of giving the ball to an other player of the team. If the value is 0, the player will never pass the ball.\t\tparameter \"blue recuperation ability\" var:blue_recuperation_ability category:\"Blue Team\";\tparameter \"red recuperation ability\" var:red_recuperation_ability category:\"Red Team\";\t// ability to catch the ball when no player has it and when a player of the other team has it. 1 for very good hability, 0 for very poor hability.\t\tparameter \"blue play area size\" var:blue_size_play_area category:\"Blue Team\";\tparameter \"red play area size\" var:red_size_play_area category:\"Red Team\";\t// change the size of the area of each player. The bigger this area is, the less players will maintains their position.\t\tparameter \"display status\" var:show_status category:\"Display\";\t// displays or not the current status of the player (his intentions)\t\tparameter \"display play area\" var:show_area category:\"Display\";\t// displays or not the offensive and defensive area of each player. The bigger this area is, the less players will maintains their position.\t\tparameter \"display marked player\" var:show_marked_player category:\"Display\";\t// displays or not an arrow between the player that are marked each other.\t\tparameter \"display ball indicators\" var:show_ball_indicator category:\"Display\";\t// changes the color of the ball if the ball is possessed by the blue or the red team. Display also the direction of the ball when it has been shooted.\t\tparameter \"play with offside position\" var:play_with_offside category:\"Rules\";\t// play with or without the \"offside\" rule.\t\toutput {\t\tdisplay \"soccer_field\" {\t\t\t// display the field.\t\t\timage \"../images/soccer_field.png\";\t\t\tspecies player aspect:base;\t\t\tspecies ball aspect:base;\t\t\tspecies goal aspect:base;\t\t\tspecies area aspect:base;\t\t\tgraphics \"score_display\" {\t\t\t\tdraw \"Blue side - \"+string(blue_score) color:#blue at: {10,5} font: font(\"Helvetica\", 18 * #zoom, #bold) perspective:true;\t\t\t\tdraw string(red_score)+\" - Red side\" color:#red at: {100,5} font: font(\"Helvetica\", 18 * #zoom, #bold) perspective:true;\t\t\t\tif (show_status) {\t\t\t\t\tdraw line([{red_offside_pos,0},{red_offside_pos,90}]) color:#red;\t\t\t\t\tdraw line([{blue_offside_pos,0},{blue_offside_pos,90}]) color:#blue;\t\t\t\t}\t\t\t}\t\t}\t\tdisplay \"match_stats\" {\t\t\t// display some statistics about the game\t\t\tchart \"ball_possession\" type:pie position:{0,0} size:{0.5,0.5} {\t\t\t\tdata \"Red possession\" value:red_possession color:#red;\t\t\t\tdata \"Blue possession\" value:blue_possession color:#blue;\t\t\t}\t\t\tchart \"red pass\" type:pie position:{0,0.5} size:{0.5,0.5} {\t\t\t\t// note that a pass is said \"successful\" if the player that has the ball was the player called initially. A \"failed pass\" does not necessary means that the team have lost the ball.\t\t\t\t\tdata \"Red pass succeed\" value:(nb_red_pass = 0) ? 0 : float(nb_red_pass_succeed)/float(nb_red_pass) color:#red;\t\t\t\t\tdata \"Red pass failed\" value:(nb_red_pass = 0) ? 0 : 1-float(nb_red_pass_succeed)/float(nb_red_pass) color:#darkred;\t\t\t}\t\t\tchart \"blue pass\" type:pie position:{0.5,0.5} size:{0.5,0.5} {\t\t\t\t// note that a pass is said \"successful\" if the player that has the ball was the player called initially. A \"failed pass\" does not necessary means that the team have lost the ball.\t\t\t\tdata \"Blue pass succeed\" value:(nb_blue_pass = 0) ? 0 : float(nb_blue_pass_succeed)/float(nb_blue_pass) color:#blue;\t\t\t\tdata \"Blue pass failed\" value:(nb_blue_pass = 0) ? 0 : 1-float(nb_blue_pass_succeed)/float(nb_blue_pass) color:#darkblue;\t\t\t}\t\t\tchart \"number pass\" type:series position:{0.5,0} size:{0.5,0.5} {\t\t\t\tdata \"Number pass red\" value:nb_red_pass color:#red;\t\t\t\tdata \"Number pass blue\" value:nb_blue_pass color:#blue;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Soccer-soccer.html"
      }
      ,
    
      "wiki-soccer-soccer-base-html": {
        "title": "_soccerbase",
        "content": "_soccerbaseAuthor : JulienThis model contains the parent classes of the modelCode of the model :model soccerbasespecies soccer_game {\t// contains the global informations of the game\trgb back_color_team;\trgb front_color_team;\t\tball_sp ball; // the ball agent\tgoal_sp front_goal; // contains the goal at the front of the field (y = 120)\tgoal_sp back_goal; // contains the goal at the back of the field (y = 0)\tlist&lt;base_team&gt; teams; // contains the 2 teams\tlist&lt;base_player&gt; players; // contains all the players of the game\t\tbase_team team_possession; // the last team which possess the ball. This value is used to determine if the behavior of the team has to be defensive or offensive.\t\tinit {\t\t// create the entities ball and the 2 goals\t\tcreate ball_sp with:[location::world.location] returns:var_ball;\t\tball &lt;- first(var_ball);\t\tcreate goal_sp with:[location::{world.location.x,120},position::\"front\"] returns:var_goal1;\t\tfront_goal &lt;- first(var_goal1);\t\tcreate goal_sp with:[location::{world.location.x,0},position::\"back\"] returns:var_goal2;\t\tback_goal &lt;- first(var_goal2);\t}\t\taction reinit_phase {\t\t// this action is called when a goal has been scored : the players are placed with their initial position, and the ball is reset to the center\t\task players {\t\t\tlocation &lt;- init_pos;\t\t\tprevious_pos &lt;- init_pos;\t\t}\t\tball.location &lt;- world.location;\t\tball.destination &lt;- world.location;\t\tball.speed &lt;- 0.0;\t}}species base_player skills:[moving] {\t// ATTRIBUTES ////////////////////////////////////////////////\t\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\tfloat recuperation_ability &lt;- 0.2; // a mark from 0 to 1 to be able to catch the ball if another player has it\tfloat speed_without_ball;\tfloat speed_with_ball;\tpoint previous_pos; // used to apply inertia\tbool displacement_effectued&lt;-false update:false; // we can apply only one displacement by step !\t\t// ATTRIBUTE USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\tbase_team team;\tsoccer_game game;\tbase_team ennemy_team &lt;- nil update:first(game.teams where (each.position != team.position));\tball_sp ball &lt;- nil update:first(ball_sp);\tgoal_sp own_goal &lt;- nil update:first(goal_sp where (each.position = team.position));\tgoal_sp ennemy_goal &lt;- nil update:first(goal_sp where (each.position != team.position));\t// ratio of avancement of the ball (from the point of view of the current team)\tfloat ball_advancement &lt;- 0.0 update:(team.position = \"back\") ? ball.location.y / 120 : 1 - ball.location.y / 120;\t\tbool possess_ball;\tpoint init_pos;\tpoint init_pos_in_percent;\tfloat distance_to_closest_ennemy_player &lt;- 100.0 update:self distance_to closest_ennemy_player;\t// the number of ennemy players in a range of 15 meters\tint number_of_ennemy_player_in_range &lt;- 0 update:length((game.players where (each.team != team)) where ((each intersects circle(15))=true));\tfloat distance_to_ball &lt;- 100.0 update:(ball = nil) ? 100.0 : self distance_to ball;\tfloat distance_to_goal &lt;- 100.0 update:(ennemy_goal = nil) ? 100.0 : self distance_to ennemy_goal;\t// the closest player of this team\tbase_player closest_friend_player &lt;- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team = team and each != self)) \t\twhere (each distance_to self = min( (game.players where (each.team = team and each != self)) collect (each distance_to self) ) ) \t);\t// the closest ennemy player\tbase_player closest_ennemy_player &lt;- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team != team and each != self)) \t\twhere (each distance_to self = min( (game.players where (each.team != team and each != self)) collect (each distance_to self) ) ) \t);\t// the player of this team wich has the best \"position_mark\"\tbase_player best_position_player &lt;- nil update:first((team.players where (each != self)) \t\twhere (each.position_mark = max((team.players where (each != self)) collect (each.position_mark)))\t);\tfloat current_speed&lt;-1.0 update:(possess_ball) ? speed_with_ball : speed_without_ball;\t\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRAGEGY FILE\tfloat position_mark &lt;- 0.0 update:-distance_to_goal; // a mark attributed according to the position of the player (the higher the note is, the best the position is). \t// By default, this mark is equal to -distance_to_goal.\tstring status &lt;- \"\"; // the current status of the player (can be useful to build the model)\tgeometry influence_area &lt;- nil update:circle(15); // the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\t\t// CONSTRUCTOR /////////////////////////////////////////////\tinit {\t\tinit_pos &lt;- location;\t\tprevious_pos &lt;- location;\t\tpossess_ball &lt;- false;\t\tspeed_with_ball &lt;- 0.4;\t\tspeed_without_ball &lt;- 0.5;\t}\t\t// ACTIONS ////////////////////////////////////////////////////\t\t// ACTIONS TO CALL FROM THE STRATEGY FILE\t// action to run to a particular position\taction run_to(point target) {\t\tif (!displacement_effectued) {\t\t\t\tdo goto target:target speed:current_speed;\t\t\tif (possess_ball) {\t\t\t\tball.location &lt;- location;\t\t\t}\t\t\tdisplacement_effectued &lt;- true;\t\t}\t\telse {\t\t\twrite \"WARNING : only ONE action of displacement is allowed each step\";\t\t}\t}\t\t// action to run to the ball\taction run_to_ball {\t\tpoint targetPos;\t\tif (ball.ball_direction intersects circle(1)) {\t\t\ttargetPos &lt;- ball.location;\t\t}\t\telse {\t\t\ttargetPos &lt;- (ball.ball_direction closest_points_with self) at 0;\t\t}\t\tdo run_to(targetPos);\t}\t\t// action to run to the ennemy goal\taction run_to_ennemy_goal {\t\tdo run_to( ennemy_goal.location );\t}\t\t// action to run to its own goal\taction run_to_own_goal {\t\tdo run_to( own_goal.location );\t}\t\t// action to mark a player\taction mark_player (base_player player) {\t\tfloat rnd_area &lt;- 4.0; // the player will choose a position in a square of rnd_area m.\t\tpoint pos &lt;- (team.position = \"front\") ? {player.location.x,player.location.y-rnd_area/2} : {player.location.x,player.location.y+rnd_area/2};\t\tdo run_to( {pos.x-rnd_area/2+rnd(rnd_area),pos.y-rnd_area/2+rnd(rnd_area)} );\t}\t\t// action ot shoot the ball to the ennemy goal\taction shoot {\t\tdo loose_ball;\t\task ball {\t\t\tdo shooted speed_atr:3.0 target_position:myself.ennemy_goal.location;\t\t}\t}\t\t// action to pass the ball to an ally\taction pass_the_ball (base_player target_player) {\t\tdo loose_ball;\t\task ball {\t\t\tdo shooted target_position:target_player.location speed_atr:target_player.distance_to_ball/15;\t\t}\t\tteam.called_player &lt;- target_player;\t}\t\t// action to pass the ball to an ally\taction pass_the_ball_ahead (base_player target_player,float number_of_meter_ahead) {\t\tdo loose_ball;\t\task ball {\t\t\tfloat offset &lt;- ((myself.team.position = \"back\") ? number_of_meter_ahead : -number_of_meter_ahead);\t\t\tpoint target_point &lt;- {target_player.location.x,target_player.location.y+offset};\t\t\tdo shooted target_position:target_point speed_atr:target_player.distance_to_ball/15;\t\t}\t\tteam.called_player &lt;- target_player;\t}\t\t// ACTION AUTOMATICALLY CALLED IN THE BASE CLASSE\t// try to take the ball if it is close enough\taction try_to_take_ball {\t\t// if no player has the ball\t\tif (!team.possess_ball and !ennemy_team.possess_ball) {\t\t\t// if the player is the one called (result of a pass)\t\t\tif (team.called_player = self) {\t\t\t\tdo take_ball;\t\t\t}\t\t\t// if the player is not the one called (interception of the ball), probability to catch the ball inversly proportionnal with the speed of the ball\t\t\telse {\t\t\t\tif (flip(1/(1+2*ball.speed))) {\t\t\t\t\tdo take_ball;\t\t\t\t}\t\t\t}\t\t}\t\t// the ball is possessed by the ennemy team\t\telse if (ennemy_team.possess_ball) {\t\t\t// try to catch the ball from the other player\t\t\tif flip(recuperation_ability) {\t\t\t\tdo take_ball;\t\t\t}\t\t}\t}\t\t// action of taking the ball\taction take_ball {\t\tif (ennemy_team.possess_ball) {\t\t\task ennemy_team.player_with_ball {\t\t\t\tdo loose_ball;\t\t\t}\t\t}\t\tpossess_ball &lt;- true;\t\tball.speed &lt;- 0.0;\t\tball.destination &lt;- ball.location;\t\tteam.called_player &lt;- nil;\t\tteam.player_with_ball &lt;- self;\t\tteam.possess_ball &lt;- true;\t\tgame.team_possession &lt;- team;\t}\t\t// action of loosing the ball\taction loose_ball {\t\tpossess_ball &lt;- false;\t\tteam.player_with_ball &lt;- nil;\t\tteam.possess_ball &lt;- false;\t}\t\t// apply the inertia\taction apply_inertia {\t\tpoint prev_pos &lt;- location;\t\tpoint inertia_vect &lt;- {(location.x-previous_pos.x)*0.7,(location.y-previous_pos.y)*0.7};\t\tfloat max_inertia &lt;- current_speed;\t\tif (norm(inertia_vect) &gt; max_inertia) {\t\t\tfloat inertia_x &lt;-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));\t\t\tfloat inertia_y &lt;-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));\t\t\tinertia_x &lt;- (inertia_vect.x &lt; 0) ? -inertia_x : inertia_x;\t\t\tinertia_y &lt;- (inertia_vect.y &lt; 0) ? -inertia_y : inertia_y;\t\t\tinertia_vect &lt;- {inertia_x,inertia_y};\t\t}\t\tlocation &lt;- location + inertia_vect;\t\tprevious_pos &lt;- prev_pos;\t}\t\t// useful functions\t// this function returns the real x if we pass a percentage : 0 is the extreme left point, 100 is the extreme right point.\tfloat getXPos(float x_ratio) {\t\tfloat result;\t\tif (team.position=\"back\") {\t\t\tresult &lt;- 90-x_ratio*90;\t\t}\t\telse {\t\t\tresult &lt;- x_ratio*90;\t\t}\t\treturn result;\t}\t\t// this function returns the real y if we pass a percentage : 0 is the extreme defensive point, 100 is the extreme attack point.\tfloat getYPos(float y_ratio) {\t\tfloat result;\t\tif (team.position=\"back\") {\t\t\tresult &lt;- y_ratio*120;\t\t}\t\telse {\t\t\tresult &lt;- 120-y_ratio*120;\t\t}\t\treturn result;\t}\t\t///////////////////////////////////////////////////////\t\t// The update function, calls the adequate behavior\treflex update when:cycle&gt;1 {\t\tdo apply_inertia;\t\t// verify if it is a non-offside position\t\tif ( (((team.position = \"back\") and (location.y &gt; team.offside_pos))\t\t\tor ((team.position = \"front\") and (location.y &lt; team.offside_pos))) \t\t\tand (!possess_ball) and (self != team.called_player)\t\t) {\t\t\t// offside position, go back to a correct position\t\t\tpoint target_pos &lt;- {location.x,(team.position = \"back\") ? location.y-current_speed:location.y+current_speed};\t\t\tdo run_to(target_pos);\t\t\tstatus &lt;- \"offside position !\";\t\t}\t\telse if ((distance_to_ball &lt; 2) and !possess_ball) {\t\t\tdo try_to_take_ball;\t\t}\t\telse if (game.team_possession = team) {\t\t\tdo offensive_behavior;\t\t}\t\telse {\t\t\tdo defensive_behavior;\t\t}\t}\t\t// defensive behavior, need to be redefined in the strategy file.\t// this action is called when the last player who was holding the ball was a player of the ennemy team\taction defensive_behavior virtual:true {\t\t\t}\t// defensive behavior, need to be redefined in the strategy file.\t// this action is called when the last player who was holding the ball was a player of this team\taction offensive_behavior virtual:true {\t\t\t}\t\t\t// ASPECT ////////////////////////////////////////////////////////\taspect player {\t\t// the player wich possess the ball is displayed with a square. It is displayed with a circle otherwise.\t\tif (possess_ball) {\t\t\tdraw square(2) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\t\t}\t\telse {\t\t\tdraw circle(1) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\t\t}\t}}species base_team {\t// ATTRIBUTES ////////////////////////////////////////////////\t\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\tfloat offside_pos &lt;- 0.0 update: (position = \"back\") ? max((game.players where (each.team != self)) collect (each.location.y))\t\t: min((game.players where (each.team != self)) collect (each.location.y));\t\t// ATTRIBUTES USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\tstring position; // can be \"front\" or \"back\".\tlist&lt;base_player&gt; players; // all the players of the team.\tsoccer_game game;\t\tbase_player closest_player_to_ball &lt;- first(players) update: first( players where (each distance_to each.ball = min (players collect (each distance_to each.ball) ) ) );\tbase_player called_player;\tbool possess_ball &lt;- false;// update: ! empty ( players where (each.possess_ball=true) );\tbase_player player_with_ball &lt;- nil;// update: first(players where (each.possess_ball = true));\t\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRATEGY FILE\tlist&lt;point&gt; player_init_position;}species ball_sp skills:[moving] {\t// The ball agent.\tfloat speed &lt;- 0.0;\tgeometry ball_direction; // the direction of the ball is used to be followed by the player\treflex update {\t\tspeed &lt;- speed*0.95;\t\tfloat future_speed &lt;- speed;\t\tpoint tmpPos&lt;-location;\t\tloop i from:0 to:10 {\t\t\ttmpPos &lt;- {tmpPos.x+cos(heading)*speed,tmpPos.y+sin(heading)*speed};\t\t\tfuture_speed &lt;- future_speed*0.9;\t\t}\t\tball_direction &lt;- line([location,tmpPos]);\t\tdo wander amplitude:1;\t\t\t\t// anticipation of the ball position to detect a goal\t\tif ((location.y+sin(heading)*speed) &gt; 120) {\t\t\twrite \"back team score a goal !!\";\t\t\task first(soccer_game) {\t\t\t\tdo reinit_phase;\t\t\t}\t\t}\t\tif ((location.y+sin(heading)*speed) &lt; 0) {\t\t\twrite \"front team score a goal !!\";\t\t\task first(soccer_game) {\t\t\t\tdo reinit_phase;\t\t\t}\t\t}\t}\taction shooted (point target_position, float speed_atr) {\t\t// action called when a player shoots the ball\t\tspeed &lt;- speed_atr;\t\tdo goto target:target_position;\t}\t\taspect ball {\t\tdraw circle(0.5) color:#white;\t}}species goal_sp {\tstring position; // can be \"front\" or \"back\".\t\tinit {\t\tcreate goal_keeper with:[position::position];\t}\t\taspect goal {\t\tdraw rectangle(7.32,1.0) color:#black;\t}}species goal_keeper {\t// the goal has a basic behavior : he tries to catch the ball when it is close enough, and when \tstring position; // can be \"front\" or \"back\".\tball_sp ball &lt;- nil update:first(ball_sp);\t\treflex update when:cycle&gt;0 {\t\tlocation &lt;- {ball.location.x/90*12+(90-12)/2,location.y};\t\tif (ball distance_to self &lt; 2) {\t\t\tif (flip(1/(1+2*ball.speed))) {\t\t\t\tfirst(soccer_game).team_possession &lt;- first(first(soccer_game).teams where (each.position = position));\t\t\t\task ball {\t\t\t\t\tdo shooted ({30+rnd(30),60},5.0);\t\t\t\t}\t\t\t}\t\t}\t}\t\tinit {\t\tlocation &lt;- {45,(position=\"front\") ? 117 : 3};\t}\t\taction offensive_behavior {\t}\t\taction defensive_behavior {\t}\t\taspect goal_keeper {\t\tdraw circle(1) color:(position = \"back\") ? first(soccer_game).back_color_team : first(soccer_game).front_color_team;\t}}",
        "url":"/wiki/Soccer-soccer_base.html"
      }
      ,
    
      "wiki-soccer-soccer-expe-html": {
        "title": "Soccer game (Various strategies)",
        "content": "Soccer game (Various strategies)Author : JulienThis model shows a game between two teams, with the same of with different strategies :  The “stupidTeam” has a very basic strategy : when a player has the ball, he runs to the ennemy goal, he runs to the ball otherwise.  The “intelligentTeam” is composed of players that each one have a strategical place wich they are able to keep. They also do pass when they are in dangerous position, to the “safer” player.This model is designed to show how, with the same set of rules and some predefined actions, we can build a strategy of a team. You are free to change the imported files “team1_strategy.gaml” and “team2_strategy.gaml”, using the read-only and the read-write attributes of the mother species.Imported models :model soccerbasespecies soccer_game {\t// contains the global informations of the game\trgb back_color_team;\trgb front_color_team;\t\tball_sp ball; // the ball agent\tgoal_sp front_goal; // contains the goal at the front of the field (y = 120)\tgoal_sp back_goal; // contains the goal at the back of the field (y = 0)\tlist&lt;base_team&gt; teams; // contains the 2 teams\tlist&lt;base_player&gt; players; // contains all the players of the game\t\tbase_team team_possession; // the last team which possess the ball. This value is used to determine if the behavior of the team has to be defensive or offensive.\t\tinit {\t\t// create the entities ball and the 2 goals\t\tcreate ball_sp with:[location::world.location] returns:var_ball;\t\tball &lt;- first(var_ball);\t\tcreate goal_sp with:[location::{world.location.x,120},position::\"front\"] returns:var_goal1;\t\tfront_goal &lt;- first(var_goal1);\t\tcreate goal_sp with:[location::{world.location.x,0},position::\"back\"] returns:var_goal2;\t\tback_goal &lt;- first(var_goal2);\t}\t\taction reinit_phase {\t\t// this action is called when a goal has been scored : the players are placed with their initial position, and the ball is reset to the center\t\task players {\t\t\tlocation &lt;- init_pos;\t\t\tprevious_pos &lt;- init_pos;\t\t}\t\tball.location &lt;- world.location;\t\tball.destination &lt;- world.location;\t\tball.speed &lt;- 0.0;\t}}species base_player skills:[moving] {\t// ATTRIBUTES ////////////////////////////////////////////////\t\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\tfloat recuperation_ability &lt;- 0.2; // a mark from 0 to 1 to be able to catch the ball if another player has it\tfloat speed_without_ball;\tfloat speed_with_ball;\tpoint previous_pos; // used to apply inertia\tbool displacement_effectued&lt;-false update:false; // we can apply only one displacement by step !\t\t// ATTRIBUTE USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\tbase_team team;\tsoccer_game game;\tbase_team ennemy_team &lt;- nil update:first(game.teams where (each.position != team.position));\tball_sp ball &lt;- nil update:first(ball_sp);\tgoal_sp own_goal &lt;- nil update:first(goal_sp where (each.position = team.position));\tgoal_sp ennemy_goal &lt;- nil update:first(goal_sp where (each.position != team.position));\t// ratio of avancement of the ball (from the point of view of the current team)\tfloat ball_advancement &lt;- 0.0 update:(team.position = \"back\") ? ball.location.y / 120 : 1 - ball.location.y / 120;\t\tbool possess_ball;\tpoint init_pos;\tpoint init_pos_in_percent;\tfloat distance_to_closest_ennemy_player &lt;- 100.0 update:self distance_to closest_ennemy_player;\t// the number of ennemy players in a range of 15 meters\tint number_of_ennemy_player_in_range &lt;- 0 update:length((game.players where (each.team != team)) where ((each intersects circle(15))=true));\tfloat distance_to_ball &lt;- 100.0 update:(ball = nil) ? 100.0 : self distance_to ball;\tfloat distance_to_goal &lt;- 100.0 update:(ennemy_goal = nil) ? 100.0 : self distance_to ennemy_goal;\t// the closest player of this team\tbase_player closest_friend_player &lt;- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team = team and each != self)) \t\twhere (each distance_to self = min( (game.players where (each.team = team and each != self)) collect (each distance_to self) ) ) \t);\t// the closest ennemy player\tbase_player closest_ennemy_player &lt;- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team != team and each != self)) \t\twhere (each distance_to self = min( (game.players where (each.team != team and each != self)) collect (each distance_to self) ) ) \t);\t// the player of this team wich has the best \"position_mark\"\tbase_player best_position_player &lt;- nil update:first((team.players where (each != self)) \t\twhere (each.position_mark = max((team.players where (each != self)) collect (each.position_mark)))\t);\tfloat current_speed&lt;-1.0 update:(possess_ball) ? speed_with_ball : speed_without_ball;\t\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRAGEGY FILE\tfloat position_mark &lt;- 0.0 update:-distance_to_goal; // a mark attributed according to the position of the player (the higher the note is, the best the position is). \t// By default, this mark is equal to -distance_to_goal.\tstring status &lt;- \"\"; // the current status of the player (can be useful to build the model)\tgeometry influence_area &lt;- nil update:circle(15); // the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\t\t// CONSTRUCTOR /////////////////////////////////////////////\tinit {\t\tinit_pos &lt;- location;\t\tprevious_pos &lt;- location;\t\tpossess_ball &lt;- false;\t\tspeed_with_ball &lt;- 0.4;\t\tspeed_without_ball &lt;- 0.5;\t}\t\t// ACTIONS ////////////////////////////////////////////////////\t\t// ACTIONS TO CALL FROM THE STRATEGY FILE\t// action to run to a particular position\taction run_to(point target) {\t\tif (!displacement_effectued) {\t\t\t\tdo goto target:target speed:current_speed;\t\t\tif (possess_ball) {\t\t\t\tball.location &lt;- location;\t\t\t}\t\t\tdisplacement_effectued &lt;- true;\t\t}\t\telse {\t\t\twrite \"WARNING : only ONE action of displacement is allowed each step\";\t\t}\t}\t\t// action to run to the ball\taction run_to_ball {\t\tpoint targetPos;\t\tif (ball.ball_direction intersects circle(1)) {\t\t\ttargetPos &lt;- ball.location;\t\t}\t\telse {\t\t\ttargetPos &lt;- (ball.ball_direction closest_points_with self) at 0;\t\t}\t\tdo run_to(targetPos);\t}\t\t// action to run to the ennemy goal\taction run_to_ennemy_goal {\t\tdo run_to( ennemy_goal.location );\t}\t\t// action to run to its own goal\taction run_to_own_goal {\t\tdo run_to( own_goal.location );\t}\t\t// action to mark a player\taction mark_player (base_player player) {\t\tfloat rnd_area &lt;- 4.0; // the player will choose a position in a square of rnd_area m.\t\tpoint pos &lt;- (team.position = \"front\") ? {player.location.x,player.location.y-rnd_area/2} : {player.location.x,player.location.y+rnd_area/2};\t\tdo run_to( {pos.x-rnd_area/2+rnd(rnd_area),pos.y-rnd_area/2+rnd(rnd_area)} );\t}\t\t// action ot shoot the ball to the ennemy goal\taction shoot {\t\tdo loose_ball;\t\task ball {\t\t\tdo shooted speed_atr:3.0 target_position:myself.ennemy_goal.location;\t\t}\t}\t\t// action to pass the ball to an ally\taction pass_the_ball (base_player target_player) {\t\tdo loose_ball;\t\task ball {\t\t\tdo shooted target_position:target_player.location speed_atr:target_player.distance_to_ball/15;\t\t}\t\tteam.called_player &lt;- target_player;\t}\t\t// action to pass the ball to an ally\taction pass_the_ball_ahead (base_player target_player,float number_of_meter_ahead) {\t\tdo loose_ball;\t\task ball {\t\t\tfloat offset &lt;- ((myself.team.position = \"back\") ? number_of_meter_ahead : -number_of_meter_ahead);\t\t\tpoint target_point &lt;- {target_player.location.x,target_player.location.y+offset};\t\t\tdo shooted target_position:target_point speed_atr:target_player.distance_to_ball/15;\t\t}\t\tteam.called_player &lt;- target_player;\t}\t\t// ACTION AUTOMATICALLY CALLED IN THE BASE CLASSE\t// try to take the ball if it is close enough\taction try_to_take_ball {\t\t// if no player has the ball\t\tif (!team.possess_ball and !ennemy_team.possess_ball) {\t\t\t// if the player is the one called (result of a pass)\t\t\tif (team.called_player = self) {\t\t\t\tdo take_ball;\t\t\t}\t\t\t// if the player is not the one called (interception of the ball), probability to catch the ball inversly proportionnal with the speed of the ball\t\t\telse {\t\t\t\tif (flip(1/(1+2*ball.speed))) {\t\t\t\t\tdo take_ball;\t\t\t\t}\t\t\t}\t\t}\t\t// the ball is possessed by the ennemy team\t\telse if (ennemy_team.possess_ball) {\t\t\t// try to catch the ball from the other player\t\t\tif flip(recuperation_ability) {\t\t\t\tdo take_ball;\t\t\t}\t\t}\t}\t\t// action of taking the ball\taction take_ball {\t\tif (ennemy_team.possess_ball) {\t\t\task ennemy_team.player_with_ball {\t\t\t\tdo loose_ball;\t\t\t}\t\t}\t\tpossess_ball &lt;- true;\t\tball.speed &lt;- 0.0;\t\tball.destination &lt;- ball.location;\t\tteam.called_player &lt;- nil;\t\tteam.player_with_ball &lt;- self;\t\tteam.possess_ball &lt;- true;\t\tgame.team_possession &lt;- team;\t}\t\t// action of loosing the ball\taction loose_ball {\t\tpossess_ball &lt;- false;\t\tteam.player_with_ball &lt;- nil;\t\tteam.possess_ball &lt;- false;\t}\t\t// apply the inertia\taction apply_inertia {\t\tpoint prev_pos &lt;- location;\t\tpoint inertia_vect &lt;- {(location.x-previous_pos.x)*0.7,(location.y-previous_pos.y)*0.7};\t\tfloat max_inertia &lt;- current_speed;\t\tif (norm(inertia_vect) &gt; max_inertia) {\t\t\tfloat inertia_x &lt;-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));\t\t\tfloat inertia_y &lt;-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));\t\t\tinertia_x &lt;- (inertia_vect.x &lt; 0) ? -inertia_x : inertia_x;\t\t\tinertia_y &lt;- (inertia_vect.y &lt; 0) ? -inertia_y : inertia_y;\t\t\tinertia_vect &lt;- {inertia_x,inertia_y};\t\t}\t\tlocation &lt;- location + inertia_vect;\t\tprevious_pos &lt;- prev_pos;\t}\t\t// useful functions\t// this function returns the real x if we pass a percentage : 0 is the extreme left point, 100 is the extreme right point.\tfloat getXPos(float x_ratio) {\t\tfloat result;\t\tif (team.position=\"back\") {\t\t\tresult &lt;- 90-x_ratio*90;\t\t}\t\telse {\t\t\tresult &lt;- x_ratio*90;\t\t}\t\treturn result;\t}\t\t// this function returns the real y if we pass a percentage : 0 is the extreme defensive point, 100 is the extreme attack point.\tfloat getYPos(float y_ratio) {\t\tfloat result;\t\tif (team.position=\"back\") {\t\t\tresult &lt;- y_ratio*120;\t\t}\t\telse {\t\t\tresult &lt;- 120-y_ratio*120;\t\t}\t\treturn result;\t}\t\t///////////////////////////////////////////////////////\t\t// The update function, calls the adequate behavior\treflex update when:cycle&gt;1 {\t\tdo apply_inertia;\t\t// verify if it is a non-offside position\t\tif ( (((team.position = \"back\") and (location.y &gt; team.offside_pos))\t\t\tor ((team.position = \"front\") and (location.y &lt; team.offside_pos))) \t\t\tand (!possess_ball) and (self != team.called_player)\t\t) {\t\t\t// offside position, go back to a correct position\t\t\tpoint target_pos &lt;- {location.x,(team.position = \"back\") ? location.y-current_speed:location.y+current_speed};\t\t\tdo run_to(target_pos);\t\t\tstatus &lt;- \"offside position !\";\t\t}\t\telse if ((distance_to_ball &lt; 2) and !possess_ball) {\t\t\tdo try_to_take_ball;\t\t}\t\telse if (game.team_possession = team) {\t\t\tdo offensive_behavior;\t\t}\t\telse {\t\t\tdo defensive_behavior;\t\t}\t}\t\t// defensive behavior, need to be redefined in the strategy file.\t// this action is called when the last player who was holding the ball was a player of the ennemy team\taction defensive_behavior virtual:true {\t\t\t}\t// defensive behavior, need to be redefined in the strategy file.\t// this action is called when the last player who was holding the ball was a player of this team\taction offensive_behavior virtual:true {\t\t\t}\t\t\t// ASPECT ////////////////////////////////////////////////////////\taspect player {\t\t// the player wich possess the ball is displayed with a square. It is displayed with a circle otherwise.\t\tif (possess_ball) {\t\t\tdraw square(2) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\t\t}\t\telse {\t\t\tdraw circle(1) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\t\t}\t}}species base_team {\t// ATTRIBUTES ////////////////////////////////////////////////\t\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\tfloat offside_pos &lt;- 0.0 update: (position = \"back\") ? max((game.players where (each.team != self)) collect (each.location.y))\t\t: min((game.players where (each.team != self)) collect (each.location.y));\t\t// ATTRIBUTES USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\tstring position; // can be \"front\" or \"back\".\tlist&lt;base_player&gt; players; // all the players of the team.\tsoccer_game game;\t\tbase_player closest_player_to_ball &lt;- first(players) update: first( players where (each distance_to each.ball = min (players collect (each distance_to each.ball) ) ) );\tbase_player called_player;\tbool possess_ball &lt;- false;// update: ! empty ( players where (each.possess_ball=true) );\tbase_player player_with_ball &lt;- nil;// update: first(players where (each.possess_ball = true));\t\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRATEGY FILE\tlist&lt;point&gt; player_init_position;}species ball_sp skills:[moving] {\t// The ball agent.\tfloat speed &lt;- 0.0;\tgeometry ball_direction; // the direction of the ball is used to be followed by the player\treflex update {\t\tspeed &lt;- speed*0.95;\t\tfloat future_speed &lt;- speed;\t\tpoint tmpPos&lt;-location;\t\tloop i from:0 to:10 {\t\t\ttmpPos &lt;- {tmpPos.x+cos(heading)*speed,tmpPos.y+sin(heading)*speed};\t\t\tfuture_speed &lt;- future_speed*0.9;\t\t}\t\tball_direction &lt;- line([location,tmpPos]);\t\tdo wander amplitude:1;\t\t\t\t// anticipation of the ball position to detect a goal\t\tif ((location.y+sin(heading)*speed) &gt; 120) {\t\t\twrite \"back team score a goal !!\";\t\t\task first(soccer_game) {\t\t\t\tdo reinit_phase;\t\t\t}\t\t}\t\tif ((location.y+sin(heading)*speed) &lt; 0) {\t\t\twrite \"front team score a goal !!\";\t\t\task first(soccer_game) {\t\t\t\tdo reinit_phase;\t\t\t}\t\t}\t}\taction shooted (point target_position, float speed_atr) {\t\t// action called when a player shoots the ball\t\tspeed &lt;- speed_atr;\t\tdo goto target:target_position;\t}\t\taspect ball {\t\tdraw circle(0.5) color:#white;\t}}species goal_sp {\tstring position; // can be \"front\" or \"back\".\t\tinit {\t\tcreate goal_keeper with:[position::position];\t}\t\taspect goal {\t\tdraw rectangle(7.32,1.0) color:#black;\t}}species goal_keeper {\t// the goal has a basic behavior : he tries to catch the ball when it is close enough, and when \tstring position; // can be \"front\" or \"back\".\tball_sp ball &lt;- nil update:first(ball_sp);\t\treflex update when:cycle&gt;0 {\t\tlocation &lt;- {ball.location.x/90*12+(90-12)/2,location.y};\t\tif (ball distance_to self &lt; 2) {\t\t\tif (flip(1/(1+2*ball.speed))) {\t\t\t\tfirst(soccer_game).team_possession &lt;- first(first(soccer_game).teams where (each.position = position));\t\t\t\task ball {\t\t\t\t\tdo shooted ({30+rnd(30),60},5.0);\t\t\t\t}\t\t\t}\t\t}\t}\t\tinit {\t\tlocation &lt;- {45,(position=\"front\") ? 117 : 3};\t}\t\taction offensive_behavior {\t}\t\taction defensive_behavior {\t}\t\taspect goal_keeper {\t\tdraw circle(1) color:(position = \"back\") ? first(soccer_game).back_color_team : first(soccer_game).front_color_team;\t}}model team2strategyimport \"./soccer_base.gaml\"species player_stupidTeam parent:base_player {\t// READ ONLY ATTRIBUTES :\t// position : can be \"front\" or \"back\".\t// players : list of all the players of the team.\t// game\t//closest_player_to_ball\t// called_player : the player called for a pass\t// possess_ball : true or false\t// player_with_ball : player currently with the ball\t\t// READ AND WRITE ATTRIBUTES :\t// position_mark\t// status : the current status of the player (can be useful to build the model)\t// influence_area : the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\t\t\taction defensive_behavior {\t\t\t// very basic defensive behavior : run to the ball\t\tdo run_to_ball;\t}\t\taction offensive_behavior {\t\t\t// very basic offensive behavior : run to the ennemy goal, or shoot the ball when close enough from the ennemy goal.\t\tif ((possess_ball) and (distance_to_goal &lt; 30)) {\t\t\tdo shoot;\t\t}\t\telse {\t\t\tdo run_to_ennemy_goal;\t\t}\t}\t}species stupidTeam parent:base_team {\t// READ ONLY ATTRIBUTES :\t// position : can be \"front\" or \"back\".\t// players : list of all the players of the team.\t// game.\t// closest_player_to_ball.\t// called_player : the player called for a pass.\t// possess_ball : true when a player of the team possess the ball.\t// player_with_ball\t\t// READ AND WRITE ATTRIBUTES :\t// player_init_position\t\t// initial position of the player in percentage : for each point,\t//    the first value corresponds to the percentage from left to right (0 for the point the most in the left side)\t//    the second value corresponds to the percentage from the goal position to the mid position (0 for the goal position)\tlist&lt;point&gt; player_init_position &lt;- [{20,20},{50,20},{80,20},{30,50},{70,50},{50,70},{30,90},{50,90},{70,90}];}model soccerbasespecies soccer_game {\t// contains the global informations of the game\trgb back_color_team;\trgb front_color_team;\t\tball_sp ball; // the ball agent\tgoal_sp front_goal; // contains the goal at the front of the field (y = 120)\tgoal_sp back_goal; // contains the goal at the back of the field (y = 0)\tlist&lt;base_team&gt; teams; // contains the 2 teams\tlist&lt;base_player&gt; players; // contains all the players of the game\t\tbase_team team_possession; // the last team which possess the ball. This value is used to determine if the behavior of the team has to be defensive or offensive.\t\tinit {\t\t// create the entities ball and the 2 goals\t\tcreate ball_sp with:[location::world.location] returns:var_ball;\t\tball &lt;- first(var_ball);\t\tcreate goal_sp with:[location::{world.location.x,120},position::\"front\"] returns:var_goal1;\t\tfront_goal &lt;- first(var_goal1);\t\tcreate goal_sp with:[location::{world.location.x,0},position::\"back\"] returns:var_goal2;\t\tback_goal &lt;- first(var_goal2);\t}\t\taction reinit_phase {\t\t// this action is called when a goal has been scored : the players are placed with their initial position, and the ball is reset to the center\t\task players {\t\t\tlocation &lt;- init_pos;\t\t\tprevious_pos &lt;- init_pos;\t\t}\t\tball.location &lt;- world.location;\t\tball.destination &lt;- world.location;\t\tball.speed &lt;- 0.0;\t}}species base_player skills:[moving] {\t// ATTRIBUTES ////////////////////////////////////////////////\t\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\tfloat recuperation_ability &lt;- 0.2; // a mark from 0 to 1 to be able to catch the ball if another player has it\tfloat speed_without_ball;\tfloat speed_with_ball;\tpoint previous_pos; // used to apply inertia\tbool displacement_effectued&lt;-false update:false; // we can apply only one displacement by step !\t\t// ATTRIBUTE USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\tbase_team team;\tsoccer_game game;\tbase_team ennemy_team &lt;- nil update:first(game.teams where (each.position != team.position));\tball_sp ball &lt;- nil update:first(ball_sp);\tgoal_sp own_goal &lt;- nil update:first(goal_sp where (each.position = team.position));\tgoal_sp ennemy_goal &lt;- nil update:first(goal_sp where (each.position != team.position));\t// ratio of avancement of the ball (from the point of view of the current team)\tfloat ball_advancement &lt;- 0.0 update:(team.position = \"back\") ? ball.location.y / 120 : 1 - ball.location.y / 120;\t\tbool possess_ball;\tpoint init_pos;\tpoint init_pos_in_percent;\tfloat distance_to_closest_ennemy_player &lt;- 100.0 update:self distance_to closest_ennemy_player;\t// the number of ennemy players in a range of 15 meters\tint number_of_ennemy_player_in_range &lt;- 0 update:length((game.players where (each.team != team)) where ((each intersects circle(15))=true));\tfloat distance_to_ball &lt;- 100.0 update:(ball = nil) ? 100.0 : self distance_to ball;\tfloat distance_to_goal &lt;- 100.0 update:(ennemy_goal = nil) ? 100.0 : self distance_to ennemy_goal;\t// the closest player of this team\tbase_player closest_friend_player &lt;- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team = team and each != self)) \t\twhere (each distance_to self = min( (game.players where (each.team = team and each != self)) collect (each distance_to self) ) ) \t);\t// the closest ennemy player\tbase_player closest_ennemy_player &lt;- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team != team and each != self)) \t\twhere (each distance_to self = min( (game.players where (each.team != team and each != self)) collect (each distance_to self) ) ) \t);\t// the player of this team wich has the best \"position_mark\"\tbase_player best_position_player &lt;- nil update:first((team.players where (each != self)) \t\twhere (each.position_mark = max((team.players where (each != self)) collect (each.position_mark)))\t);\tfloat current_speed&lt;-1.0 update:(possess_ball) ? speed_with_ball : speed_without_ball;\t\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRAGEGY FILE\tfloat position_mark &lt;- 0.0 update:-distance_to_goal; // a mark attributed according to the position of the player (the higher the note is, the best the position is). \t// By default, this mark is equal to -distance_to_goal.\tstring status &lt;- \"\"; // the current status of the player (can be useful to build the model)\tgeometry influence_area &lt;- nil update:circle(15); // the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\t\t// CONSTRUCTOR /////////////////////////////////////////////\tinit {\t\tinit_pos &lt;- location;\t\tprevious_pos &lt;- location;\t\tpossess_ball &lt;- false;\t\tspeed_with_ball &lt;- 0.4;\t\tspeed_without_ball &lt;- 0.5;\t}\t\t// ACTIONS ////////////////////////////////////////////////////\t\t// ACTIONS TO CALL FROM THE STRATEGY FILE\t// action to run to a particular position\taction run_to(point target) {\t\tif (!displacement_effectued) {\t\t\t\tdo goto target:target speed:current_speed;\t\t\tif (possess_ball) {\t\t\t\tball.location &lt;- location;\t\t\t}\t\t\tdisplacement_effectued &lt;- true;\t\t}\t\telse {\t\t\twrite \"WARNING : only ONE action of displacement is allowed each step\";\t\t}\t}\t\t// action to run to the ball\taction run_to_ball {\t\tpoint targetPos;\t\tif (ball.ball_direction intersects circle(1)) {\t\t\ttargetPos &lt;- ball.location;\t\t}\t\telse {\t\t\ttargetPos &lt;- (ball.ball_direction closest_points_with self) at 0;\t\t}\t\tdo run_to(targetPos);\t}\t\t// action to run to the ennemy goal\taction run_to_ennemy_goal {\t\tdo run_to( ennemy_goal.location );\t}\t\t// action to run to its own goal\taction run_to_own_goal {\t\tdo run_to( own_goal.location );\t}\t\t// action to mark a player\taction mark_player (base_player player) {\t\tfloat rnd_area &lt;- 4.0; // the player will choose a position in a square of rnd_area m.\t\tpoint pos &lt;- (team.position = \"front\") ? {player.location.x,player.location.y-rnd_area/2} : {player.location.x,player.location.y+rnd_area/2};\t\tdo run_to( {pos.x-rnd_area/2+rnd(rnd_area),pos.y-rnd_area/2+rnd(rnd_area)} );\t}\t\t// action ot shoot the ball to the ennemy goal\taction shoot {\t\tdo loose_ball;\t\task ball {\t\t\tdo shooted speed_atr:3.0 target_position:myself.ennemy_goal.location;\t\t}\t}\t\t// action to pass the ball to an ally\taction pass_the_ball (base_player target_player) {\t\tdo loose_ball;\t\task ball {\t\t\tdo shooted target_position:target_player.location speed_atr:target_player.distance_to_ball/15;\t\t}\t\tteam.called_player &lt;- target_player;\t}\t\t// action to pass the ball to an ally\taction pass_the_ball_ahead (base_player target_player,float number_of_meter_ahead) {\t\tdo loose_ball;\t\task ball {\t\t\tfloat offset &lt;- ((myself.team.position = \"back\") ? number_of_meter_ahead : -number_of_meter_ahead);\t\t\tpoint target_point &lt;- {target_player.location.x,target_player.location.y+offset};\t\t\tdo shooted target_position:target_point speed_atr:target_player.distance_to_ball/15;\t\t}\t\tteam.called_player &lt;- target_player;\t}\t\t// ACTION AUTOMATICALLY CALLED IN THE BASE CLASSE\t// try to take the ball if it is close enough\taction try_to_take_ball {\t\t// if no player has the ball\t\tif (!team.possess_ball and !ennemy_team.possess_ball) {\t\t\t// if the player is the one called (result of a pass)\t\t\tif (team.called_player = self) {\t\t\t\tdo take_ball;\t\t\t}\t\t\t// if the player is not the one called (interception of the ball), probability to catch the ball inversly proportionnal with the speed of the ball\t\t\telse {\t\t\t\tif (flip(1/(1+2*ball.speed))) {\t\t\t\t\tdo take_ball;\t\t\t\t}\t\t\t}\t\t}\t\t// the ball is possessed by the ennemy team\t\telse if (ennemy_team.possess_ball) {\t\t\t// try to catch the ball from the other player\t\t\tif flip(recuperation_ability) {\t\t\t\tdo take_ball;\t\t\t}\t\t}\t}\t\t// action of taking the ball\taction take_ball {\t\tif (ennemy_team.possess_ball) {\t\t\task ennemy_team.player_with_ball {\t\t\t\tdo loose_ball;\t\t\t}\t\t}\t\tpossess_ball &lt;- true;\t\tball.speed &lt;- 0.0;\t\tball.destination &lt;- ball.location;\t\tteam.called_player &lt;- nil;\t\tteam.player_with_ball &lt;- self;\t\tteam.possess_ball &lt;- true;\t\tgame.team_possession &lt;- team;\t}\t\t// action of loosing the ball\taction loose_ball {\t\tpossess_ball &lt;- false;\t\tteam.player_with_ball &lt;- nil;\t\tteam.possess_ball &lt;- false;\t}\t\t// apply the inertia\taction apply_inertia {\t\tpoint prev_pos &lt;- location;\t\tpoint inertia_vect &lt;- {(location.x-previous_pos.x)*0.7,(location.y-previous_pos.y)*0.7};\t\tfloat max_inertia &lt;- current_speed;\t\tif (norm(inertia_vect) &gt; max_inertia) {\t\t\tfloat inertia_x &lt;-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));\t\t\tfloat inertia_y &lt;-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));\t\t\tinertia_x &lt;- (inertia_vect.x &lt; 0) ? -inertia_x : inertia_x;\t\t\tinertia_y &lt;- (inertia_vect.y &lt; 0) ? -inertia_y : inertia_y;\t\t\tinertia_vect &lt;- {inertia_x,inertia_y};\t\t}\t\tlocation &lt;- location + inertia_vect;\t\tprevious_pos &lt;- prev_pos;\t}\t\t// useful functions\t// this function returns the real x if we pass a percentage : 0 is the extreme left point, 100 is the extreme right point.\tfloat getXPos(float x_ratio) {\t\tfloat result;\t\tif (team.position=\"back\") {\t\t\tresult &lt;- 90-x_ratio*90;\t\t}\t\telse {\t\t\tresult &lt;- x_ratio*90;\t\t}\t\treturn result;\t}\t\t// this function returns the real y if we pass a percentage : 0 is the extreme defensive point, 100 is the extreme attack point.\tfloat getYPos(float y_ratio) {\t\tfloat result;\t\tif (team.position=\"back\") {\t\t\tresult &lt;- y_ratio*120;\t\t}\t\telse {\t\t\tresult &lt;- 120-y_ratio*120;\t\t}\t\treturn result;\t}\t\t///////////////////////////////////////////////////////\t\t// The update function, calls the adequate behavior\treflex update when:cycle&gt;1 {\t\tdo apply_inertia;\t\t// verify if it is a non-offside position\t\tif ( (((team.position = \"back\") and (location.y &gt; team.offside_pos))\t\t\tor ((team.position = \"front\") and (location.y &lt; team.offside_pos))) \t\t\tand (!possess_ball) and (self != team.called_player)\t\t) {\t\t\t// offside position, go back to a correct position\t\t\tpoint target_pos &lt;- {location.x,(team.position = \"back\") ? location.y-current_speed:location.y+current_speed};\t\t\tdo run_to(target_pos);\t\t\tstatus &lt;- \"offside position !\";\t\t}\t\telse if ((distance_to_ball &lt; 2) and !possess_ball) {\t\t\tdo try_to_take_ball;\t\t}\t\telse if (game.team_possession = team) {\t\t\tdo offensive_behavior;\t\t}\t\telse {\t\t\tdo defensive_behavior;\t\t}\t}\t\t// defensive behavior, need to be redefined in the strategy file.\t// this action is called when the last player who was holding the ball was a player of the ennemy team\taction defensive_behavior virtual:true {\t\t\t}\t// defensive behavior, need to be redefined in the strategy file.\t// this action is called when the last player who was holding the ball was a player of this team\taction offensive_behavior virtual:true {\t\t\t}\t\t\t// ASPECT ////////////////////////////////////////////////////////\taspect player {\t\t// the player wich possess the ball is displayed with a square. It is displayed with a circle otherwise.\t\tif (possess_ball) {\t\t\tdraw square(2) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\t\t}\t\telse {\t\t\tdraw circle(1) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\t\t}\t}}species base_team {\t// ATTRIBUTES ////////////////////////////////////////////////\t\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\tfloat offside_pos &lt;- 0.0 update: (position = \"back\") ? max((game.players where (each.team != self)) collect (each.location.y))\t\t: min((game.players where (each.team != self)) collect (each.location.y));\t\t// ATTRIBUTES USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\tstring position; // can be \"front\" or \"back\".\tlist&lt;base_player&gt; players; // all the players of the team.\tsoccer_game game;\t\tbase_player closest_player_to_ball &lt;- first(players) update: first( players where (each distance_to each.ball = min (players collect (each distance_to each.ball) ) ) );\tbase_player called_player;\tbool possess_ball &lt;- false;// update: ! empty ( players where (each.possess_ball=true) );\tbase_player player_with_ball &lt;- nil;// update: first(players where (each.possess_ball = true));\t\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRATEGY FILE\tlist&lt;point&gt; player_init_position;}species ball_sp skills:[moving] {\t// The ball agent.\tfloat speed &lt;- 0.0;\tgeometry ball_direction; // the direction of the ball is used to be followed by the player\treflex update {\t\tspeed &lt;- speed*0.95;\t\tfloat future_speed &lt;- speed;\t\tpoint tmpPos&lt;-location;\t\tloop i from:0 to:10 {\t\t\ttmpPos &lt;- {tmpPos.x+cos(heading)*speed,tmpPos.y+sin(heading)*speed};\t\t\tfuture_speed &lt;- future_speed*0.9;\t\t}\t\tball_direction &lt;- line([location,tmpPos]);\t\tdo wander amplitude:1;\t\t\t\t// anticipation of the ball position to detect a goal\t\tif ((location.y+sin(heading)*speed) &gt; 120) {\t\t\twrite \"back team score a goal !!\";\t\t\task first(soccer_game) {\t\t\t\tdo reinit_phase;\t\t\t}\t\t}\t\tif ((location.y+sin(heading)*speed) &lt; 0) {\t\t\twrite \"front team score a goal !!\";\t\t\task first(soccer_game) {\t\t\t\tdo reinit_phase;\t\t\t}\t\t}\t}\taction shooted (point target_position, float speed_atr) {\t\t// action called when a player shoots the ball\t\tspeed &lt;- speed_atr;\t\tdo goto target:target_position;\t}\t\taspect ball {\t\tdraw circle(0.5) color:#white;\t}}species goal_sp {\tstring position; // can be \"front\" or \"back\".\t\tinit {\t\tcreate goal_keeper with:[position::position];\t}\t\taspect goal {\t\tdraw rectangle(7.32,1.0) color:#black;\t}}species goal_keeper {\t// the goal has a basic behavior : he tries to catch the ball when it is close enough, and when \tstring position; // can be \"front\" or \"back\".\tball_sp ball &lt;- nil update:first(ball_sp);\t\treflex update when:cycle&gt;0 {\t\tlocation &lt;- {ball.location.x/90*12+(90-12)/2,location.y};\t\tif (ball distance_to self &lt; 2) {\t\t\tif (flip(1/(1+2*ball.speed))) {\t\t\t\tfirst(soccer_game).team_possession &lt;- first(first(soccer_game).teams where (each.position = position));\t\t\t\task ball {\t\t\t\t\tdo shooted ({30+rnd(30),60},5.0);\t\t\t\t}\t\t\t}\t\t}\t}\t\tinit {\t\tlocation &lt;- {45,(position=\"front\") ? 117 : 3};\t}\t\taction offensive_behavior {\t}\t\taction defensive_behavior {\t}\t\taspect goal_keeper {\t\tdraw circle(1) color:(position = \"back\") ? first(soccer_game).back_color_team : first(soccer_game).front_color_team;\t}}model team1strategyimport \"./soccer_base.gaml\"species player_intelligentTeam parent:base_player {\t// READ ONLY ATTRIBUTES :\t// position : can be \"front\" or \"back\".\t// players : list of all the players of the team.\t// game\t//closest_player_to_ball\t// called_player : the player called for a pass\t// possess_ball : true or false\t// player_with_ball : player currently with the ball\t\t// READ AND WRITE ATTRIBUTES :\t// position_mark\t// status : the current status of the player (can be useful to build the model)\t// influence_area : the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\t\tfloat position_mark &lt;- 0.0 update: location.y - 20*number_of_ennemy_player_in_range + self.distance_to_closest_ennemy_player;\t\tstring role; // a value between \"defense\", \"mid\" and \"attack\".\tstring wing; // a value between \"left\", \"center\" and \"right\".\tgeometry influence_area &lt;- circle(15,init_pos);\t\tfloat defense_mid_pos &lt;- 30.0; // the y percent chosed to separate the defense from the mid position.\tfloat mid_attack_pos &lt;- 60.0; // the y percent chosen to separate the mid from the attack position.\t\tinit {\t\t// set the role of the player (between \"defense\", \"mid\" and \"attack\").\t\tif ( init_pos_in_percent.y &lt; defense_mid_pos ) {\t\t\trole &lt;- \"defense\";\t\t}\t\telse if ( (init_pos_in_percent.y &gt; mid_attack_pos ) ) {\t\t\trole &lt;- \"attack\";\t\t}\t\telse {\t\t\trole &lt;- \"mid\";\t\t}\t\t// set the wing of the player (between \"left\", \"center\" and \"right\")\t\tif ( init_pos_in_percent.x &lt; 40 ) {\t\t\twing &lt;- \"left\";\t\t}\t\telse if ( init_pos_in_percent.x &gt; 60 ) {\t\t\twing &lt;- \"right\";\t\t}\t\telse {\t\t\twing &lt;- \"center\";\t\t}\t}\t\taction update_influence_area {\t\tstatus &lt;- wing + \" \" + role;\t\tfloat y_ratio;\t\tif (role = \"defense\") { // defense position from 0% to 70% from the own goal, multiplied by the percentage of advancement of the ball\t\t\ty_ratio &lt;- 0.7 * ball_advancement;\t\t}\t\tif (role = \"mid\") { // mid position from 15% to 85% from the own goal, multiplied by the percentage of advancement of the ball\t\t\ty_ratio &lt;- 0.15 + 0.7 * ball_advancement;\t\t}\t\tif (role = \"attack\") { // attack position from 30% to 100% from the own goal, multiplied by the percentage of advancement of the ball\t\t\ty_ratio &lt;- 0.3 + 0.7 * ball_advancement;\t\t}\t\tfloat x_ratio;\t\tif (wing = \"center\") {\t\t\tx_ratio &lt;- 0.5;\t\t}\t\telse if (wing = \"left\") {\t\t\tx_ratio &lt;- 0.5 - 0.3 * cos( (y_ratio-0.5)*120 ); // the \"side\" wings are more marked if the player is in the center of the field.\t\t}\t\telse {\t\t\tx_ratio &lt;- 0.5 + 0.3 * cos( (y_ratio-0.5)*120 );\t\t}\t\tinfluence_area &lt;- circle(15,{getXPos(x_ratio),getYPos(y_ratio)});\t}\t\taction defensive_behavior {\t\t\tdo update_influence_area;\t\t// advanced defensive behavior\t\t// run to the ball if the player is the closest player from the ball.\t\tif ((self = team.closest_player_to_ball) or (self distance_to ball &lt; 5)) {\t\t\tstatus &lt;- getStatus(\"run to ball\");\t\t\tdo run_to_ball;\t\t}\t\telse {\t\t\t// if there is an ennemy player in the influence area, mark the player.\t\t\tif ( length(self.ennemy_team.players where (each intersects influence_area)) != 0 ) {\t\t\t\tbase_player marked_player &lt;- first(1 among (self.ennemy_team.players where (each intersects influence_area)));\t\t\t\tstatus &lt;- getStatus(\"mark player \"+marked_player);\t\t\t\tdo mark_player( marked_player );\t\t\t}\t\t\t// if there is no ennemy player in the influence area, stay in influence area.\t\t\telse {\t\t\t\tstatus &lt;- getStatus(\"run to influence area\");\t\t\t\tdo run_to(influence_area.location);\t\t\t}\t\t}\t}\t\taction offensive_behavior {\t\t\tdo update_influence_area;\t\t// advanced offensive behavior\t\tif (possess_ball) {\t\t\t// if the player has the ball and is close enough to the ennemy goal, shoot.\t\t\tif (distance_to_goal &lt; 35 and flip(1/(0.1+(self.distance_to_goal/10)^2))) {\t\t\t\tstatus &lt;- getStatus(\"shoot the ball\");\t\t\t\tdo shoot;\t\t\t}\t\t\t// if the player has the ball and is in a safe position, run to the ennemy goal.\t\t\telse if ( (position_mark = max( team.players collect (each.position_mark) )) or (distance_to_closest_ennemy_player &gt; 2) )\t\t\t{\t\t\t\tstatus &lt;- getStatus(\"run to ennemy goal\");\t\t\t\tdo run_to_ennemy_goal;\t\t\t}\t\t\t// if the player has the ball but is in a dangerous situation, pass the ball to another player.\t\t\telse {\t\t\t\tbase_player target_player &lt;- first(team.players where (each.position_mark = max( team.players collect (each.position_mark)) ) );\t\t\t\tstatus &lt;- getStatus(\"pass the ball to \"+target_player);\t\t\t\tdo pass_the_ball_ahead ( target_player,10.0 );\t\t\t}\t\t}\t\t// if the player has not the ball but is the called player, run to the ball.\t\telse if (self = team.called_player) {\t\t\tstatus &lt;- getStatus(\"run to ball\");\t\t\tdo run_to_ball;\t\t\tstatus &lt;- \"called player\";\t\t}\t\t// else, run to influence area.\t\telse {\t\t\tstatus &lt;- getStatus(\"run to influence area\");\t\t\tdo run_to(influence_area.location);\t\t}\t}\t\tstring getStatus(string str) {\t\treturn wing + \" \" + role + \"| action : \" + str;\t}\t}species intelligentTeam parent:base_team {\t// READ ONLY ATTRIBUTES :\t// position : can be \"front\" or \"back\".\t// players : list of all the players of the team.\t// game.\t// closest_player_to_ball.\t// called_player : the player called for a pass.\t// possess_ball : true when a player of the team possess the ball.\t// player_with_ball\t\t// READ AND WRITE ATTRIBUTES :\t// player_init_position\t\t// initial position of the player in percentage : for each point,\t//    the first value corresponds to the percentage from left to right (0 for the point the most in the left side)\t//    the second value corresponds to the percentage from the goal position to the mid position (0 for the goal position)\tlist&lt;point&gt; player_init_position &lt;- [{20,20},{50,20},{80,20},{30,50},{70,50},{50,70},{30,90},{50,90},{70,90}];}Code of the model :model soccerexpe// import the 2 strategiesimport \"./team1_strategy.gaml\"import \"./team2_strategy.gaml\"global {\t// set the size of the environment\tgeometry shape &lt;- rectangle(90#m,120#m);\t\tbool show_info &lt;- false;\t\trgb back_color_team &lt;- #blue;\trgb front_color_team &lt;- #red;}species info_player1 mirrors:player_intelligentTeam {\t// mirror species that shows additionnal information about the player\tpoint location &lt;- target.location update:target.location;\tstring status &lt;- target.status update:target.status;\tfloat speed &lt;- target.speed update:target.speed;\tgeometry influence_area &lt;- target.influence_area update:target.influence_area;\taspect info {\t\tif (show_info) {\t\t\tdraw status color:#black;\t\t\tdraw influence_area color:rgb(200,200,255,0) border:rgb(200,200,255,255);\t\t}\t}}species info_player2 mirrors:player_stupidTeam {\t// mirror species that shows additionnal information about the player\tpoint location &lt;- target.location update:target.location;\tstring status &lt;- target.status update:target.status;\tfloat speed &lt;- target.speed update:target.speed;\tgeometry influence_area &lt;- target.influence_area update:target.influence_area;\taspect info {\t\tif (show_info) {\t\t\tdraw status color:#black;\t\t\tdraw influence_area color:rgb(255,200,200,0) border:rgb(255,200,200,255);\t\t}\t}}experiment intelligentTeam_vs_stupidTeam type:gui {\tinit {\t\t// instantialization of the game (contains global information about the game)\t\tcreate soccer_game with:(back_color_team::back_color_team,front_color_team::front_color_team) returns:soccerGame;\t\t// instantialization of the teams\t\tcreate intelligentTeam with:(game:first(soccerGame),position:\"back\");\t\tcreate stupidTeam with:(game:first(soccerGame),position:\"front\");\t\tadd first(intelligentTeam) to:first(soccerGame).teams;\t\tadd first(stupidTeam) to:first(soccerGame).teams;\t\t// create players of the team1\t\tlist&lt;player_intelligentTeam&gt; player_list1;\t\tloop pos over:first(intelligentTeam).player_init_position {\t\t\t// compute the \"real position\" of each player according to the percentage given in \"player_init_position\"\t\t\tpoint real_pos &lt;- (first(intelligentTeam).position = \"back\") ? {90-pos.x/100*90,pos.y/100*60} : {pos.x/100*90,120-pos.y/100*60};\t\t\tcreate player_intelligentTeam with:(team:first(intelligentTeam),game:first(intelligentTeam).game,location:real_pos,init_pos_in_percent:pos) returns:pl;\t\t\tadd first(pl) to:player_list1;\t\t}\t\tfirst(intelligentTeam).players &lt;- player_list1;\t\t// create players of the team2\t\tlist&lt;player_stupidTeam&gt; player_list2;\t\tloop pos over:first(stupidTeam).player_init_position {\t\t\t// compute the \"real position\" of each player according to the percentage given in \"player_init_position\"\t\t\tpoint real_pos &lt;- (first(stupidTeam).position = \"back\") ? {90-pos.x/100*90,pos.y/100*60} : {pos.x/100*90,120-pos.y/100*60};\t\t\tcreate player_stupidTeam with:(team:first(stupidTeam),game:first(stupidTeam).game,location:real_pos,init_pos_in_percent:pos) returns:pl;\t\t\tadd first(pl) to:player_list2;\t\t}\t\tfirst(stupidTeam).players &lt;- player_list2;\t\tfirst(soccerGame).players &lt;- player_list1+player_list2;\t}\tparameter \"show player info\" var:show_info;\toutput {\t\tdisplay \"soccer_field\"  {\t\t\t// display the field.\t\t\timage \"../images/soccer_field2.png\";\t\t\t// display the species with their correct aspect\t\t\tspecies player_intelligentTeam aspect:player;\t\t\tspecies player_stupidTeam aspect:player;\t\t\tspecies ball_sp aspect:ball;\t\t\tspecies goal_sp aspect:goal;\t\t\tspecies goal_keeper aspect:goal_keeper;\t\t\tspecies info_player1 aspect:info;\t\t\tspecies info_player2 aspect:info;\t\t}\t}}experiment intelligentTeam_vs_intelligentTeam type:gui {\tinit {\t\t// instantialization of the game (contains global information about the game)\t\tcreate soccer_game with:(back_color_team::back_color_team,front_color_team::front_color_team) returns:soccerGame;\t\t// instantialization of the teams\t\tcreate intelligentTeam with:(game:first(soccerGame),position:\"back\") returns:backTeam;\t\tcreate intelligentTeam with:(game:first(soccerGame),position:\"front\") returns:frontTeam;\t\t\t\tadd first(backTeam) to:first(soccerGame).teams;\t\tadd first(frontTeam) to:first(soccerGame).teams;\t\t// create players of the team1\t\tlist&lt;player_intelligentTeam&gt; player_list1;\t\tloop pos over:first(backTeam).player_init_position {\t\t\t// compute the \"real position\" of each player according to the percentage given in \"player_init_position\"\t\t\tpoint real_pos &lt;- (first(backTeam).position = \"back\") ? {90-pos.x/100*90,pos.y/100*60} : {pos.x/100*90,120-pos.y/100*60};\t\t\tcreate player_intelligentTeam with:(team:first(backTeam),game:first(backTeam).game,location:real_pos,init_pos_in_percent:pos) returns:pl;\t\t\tadd first(pl) to:player_list1;\t\t}\t\tfirst(backTeam).players &lt;- player_list1;\t\t// create players of the team2\t\tlist&lt;player_intelligentTeam&gt; player_list2;\t\tloop pos over:first(frontTeam).player_init_position {\t\t\t// compute the \"real position\" of each player according to the percentage given in \"player_init_position\"\t\t\tpoint real_pos &lt;- (first(frontTeam).position = \"back\") ? {90-pos.x/100*90,pos.y/100*60} : {pos.x/100*90,120-pos.y/100*60};\t\t\tcreate player_intelligentTeam with:(team:first(frontTeam),game:first(frontTeam).game,location:real_pos,init_pos_in_percent:pos) returns:pl;\t\t\tadd first(pl) to:player_list2;\t\t}\t\tfirst(frontTeam).players &lt;- player_list2;\t\tfirst(soccerGame).players &lt;- player_list1+player_list2;\t}\tparameter \"show player info\" var:show_info;\toutput {\t\tdisplay \"soccer_field\"  {\t\t\t// display the field.\t\t\timage \"../images/soccer_field2.png\";\t\t\t// display the species with their correct aspect\t\t\tspecies player_intelligentTeam aspect:player;\t\t\tspecies ball_sp aspect:ball;\t\t\tspecies goal_sp aspect:goal;\t\t\tspecies goal_keeper aspect:goal_keeper;\t\t\tspecies info_player1 aspect:info;\t\t\tspecies info_player2 aspect:info;\t\t}\t}}",
        "url":"/wiki/Soccer-soccer_expe.html"
      }
      ,
    
      "wiki-soccer-team1-strategy-html": {
        "title": "_team1strategy",
        "content": "_team1strategyAuthor : JulienThis model contains one of the 2 team strategy. This strategy is quite advanced, attributing role for each player, with a custom influence_area and a custom position_mark.Imported model :model soccerbasespecies soccer_game {\t// contains the global informations of the game\trgb back_color_team;\trgb front_color_team;\t\tball_sp ball; // the ball agent\tgoal_sp front_goal; // contains the goal at the front of the field (y = 120)\tgoal_sp back_goal; // contains the goal at the back of the field (y = 0)\tlist&lt;base_team&gt; teams; // contains the 2 teams\tlist&lt;base_player&gt; players; // contains all the players of the game\t\tbase_team team_possession; // the last team which possess the ball. This value is used to determine if the behavior of the team has to be defensive or offensive.\t\tinit {\t\t// create the entities ball and the 2 goals\t\tcreate ball_sp with:[location::world.location] returns:var_ball;\t\tball &lt;- first(var_ball);\t\tcreate goal_sp with:[location::{world.location.x,120},position::\"front\"] returns:var_goal1;\t\tfront_goal &lt;- first(var_goal1);\t\tcreate goal_sp with:[location::{world.location.x,0},position::\"back\"] returns:var_goal2;\t\tback_goal &lt;- first(var_goal2);\t}\t\taction reinit_phase {\t\t// this action is called when a goal has been scored : the players are placed with their initial position, and the ball is reset to the center\t\task players {\t\t\tlocation &lt;- init_pos;\t\t\tprevious_pos &lt;- init_pos;\t\t}\t\tball.location &lt;- world.location;\t\tball.destination &lt;- world.location;\t\tball.speed &lt;- 0.0;\t}}species base_player skills:[moving] {\t// ATTRIBUTES ////////////////////////////////////////////////\t\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\tfloat recuperation_ability &lt;- 0.2; // a mark from 0 to 1 to be able to catch the ball if another player has it\tfloat speed_without_ball;\tfloat speed_with_ball;\tpoint previous_pos; // used to apply inertia\tbool displacement_effectued&lt;-false update:false; // we can apply only one displacement by step !\t\t// ATTRIBUTE USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\tbase_team team;\tsoccer_game game;\tbase_team ennemy_team &lt;- nil update:first(game.teams where (each.position != team.position));\tball_sp ball &lt;- nil update:first(ball_sp);\tgoal_sp own_goal &lt;- nil update:first(goal_sp where (each.position = team.position));\tgoal_sp ennemy_goal &lt;- nil update:first(goal_sp where (each.position != team.position));\t// ratio of avancement of the ball (from the point of view of the current team)\tfloat ball_advancement &lt;- 0.0 update:(team.position = \"back\") ? ball.location.y / 120 : 1 - ball.location.y / 120;\t\tbool possess_ball;\tpoint init_pos;\tpoint init_pos_in_percent;\tfloat distance_to_closest_ennemy_player &lt;- 100.0 update:self distance_to closest_ennemy_player;\t// the number of ennemy players in a range of 15 meters\tint number_of_ennemy_player_in_range &lt;- 0 update:length((game.players where (each.team != team)) where ((each intersects circle(15))=true));\tfloat distance_to_ball &lt;- 100.0 update:(ball = nil) ? 100.0 : self distance_to ball;\tfloat distance_to_goal &lt;- 100.0 update:(ennemy_goal = nil) ? 100.0 : self distance_to ennemy_goal;\t// the closest player of this team\tbase_player closest_friend_player &lt;- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team = team and each != self)) \t\twhere (each distance_to self = min( (game.players where (each.team = team and each != self)) collect (each distance_to self) ) ) \t);\t// the closest ennemy player\tbase_player closest_ennemy_player &lt;- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team != team and each != self)) \t\twhere (each distance_to self = min( (game.players where (each.team != team and each != self)) collect (each distance_to self) ) ) \t);\t// the player of this team wich has the best \"position_mark\"\tbase_player best_position_player &lt;- nil update:first((team.players where (each != self)) \t\twhere (each.position_mark = max((team.players where (each != self)) collect (each.position_mark)))\t);\tfloat current_speed&lt;-1.0 update:(possess_ball) ? speed_with_ball : speed_without_ball;\t\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRAGEGY FILE\tfloat position_mark &lt;- 0.0 update:-distance_to_goal; // a mark attributed according to the position of the player (the higher the note is, the best the position is). \t// By default, this mark is equal to -distance_to_goal.\tstring status &lt;- \"\"; // the current status of the player (can be useful to build the model)\tgeometry influence_area &lt;- nil update:circle(15); // the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\t\t// CONSTRUCTOR /////////////////////////////////////////////\tinit {\t\tinit_pos &lt;- location;\t\tprevious_pos &lt;- location;\t\tpossess_ball &lt;- false;\t\tspeed_with_ball &lt;- 0.4;\t\tspeed_without_ball &lt;- 0.5;\t}\t\t// ACTIONS ////////////////////////////////////////////////////\t\t// ACTIONS TO CALL FROM THE STRATEGY FILE\t// action to run to a particular position\taction run_to(point target) {\t\tif (!displacement_effectued) {\t\t\t\tdo goto target:target speed:current_speed;\t\t\tif (possess_ball) {\t\t\t\tball.location &lt;- location;\t\t\t}\t\t\tdisplacement_effectued &lt;- true;\t\t}\t\telse {\t\t\twrite \"WARNING : only ONE action of displacement is allowed each step\";\t\t}\t}\t\t// action to run to the ball\taction run_to_ball {\t\tpoint targetPos;\t\tif (ball.ball_direction intersects circle(1)) {\t\t\ttargetPos &lt;- ball.location;\t\t}\t\telse {\t\t\ttargetPos &lt;- (ball.ball_direction closest_points_with self) at 0;\t\t}\t\tdo run_to(targetPos);\t}\t\t// action to run to the ennemy goal\taction run_to_ennemy_goal {\t\tdo run_to( ennemy_goal.location );\t}\t\t// action to run to its own goal\taction run_to_own_goal {\t\tdo run_to( own_goal.location );\t}\t\t// action to mark a player\taction mark_player (base_player player) {\t\tfloat rnd_area &lt;- 4.0; // the player will choose a position in a square of rnd_area m.\t\tpoint pos &lt;- (team.position = \"front\") ? {player.location.x,player.location.y-rnd_area/2} : {player.location.x,player.location.y+rnd_area/2};\t\tdo run_to( {pos.x-rnd_area/2+rnd(rnd_area),pos.y-rnd_area/2+rnd(rnd_area)} );\t}\t\t// action ot shoot the ball to the ennemy goal\taction shoot {\t\tdo loose_ball;\t\task ball {\t\t\tdo shooted speed_atr:3.0 target_position:myself.ennemy_goal.location;\t\t}\t}\t\t// action to pass the ball to an ally\taction pass_the_ball (base_player target_player) {\t\tdo loose_ball;\t\task ball {\t\t\tdo shooted target_position:target_player.location speed_atr:target_player.distance_to_ball/15;\t\t}\t\tteam.called_player &lt;- target_player;\t}\t\t// action to pass the ball to an ally\taction pass_the_ball_ahead (base_player target_player,float number_of_meter_ahead) {\t\tdo loose_ball;\t\task ball {\t\t\tfloat offset &lt;- ((myself.team.position = \"back\") ? number_of_meter_ahead : -number_of_meter_ahead);\t\t\tpoint target_point &lt;- {target_player.location.x,target_player.location.y+offset};\t\t\tdo shooted target_position:target_point speed_atr:target_player.distance_to_ball/15;\t\t}\t\tteam.called_player &lt;- target_player;\t}\t\t// ACTION AUTOMATICALLY CALLED IN THE BASE CLASSE\t// try to take the ball if it is close enough\taction try_to_take_ball {\t\t// if no player has the ball\t\tif (!team.possess_ball and !ennemy_team.possess_ball) {\t\t\t// if the player is the one called (result of a pass)\t\t\tif (team.called_player = self) {\t\t\t\tdo take_ball;\t\t\t}\t\t\t// if the player is not the one called (interception of the ball), probability to catch the ball inversly proportionnal with the speed of the ball\t\t\telse {\t\t\t\tif (flip(1/(1+2*ball.speed))) {\t\t\t\t\tdo take_ball;\t\t\t\t}\t\t\t}\t\t}\t\t// the ball is possessed by the ennemy team\t\telse if (ennemy_team.possess_ball) {\t\t\t// try to catch the ball from the other player\t\t\tif flip(recuperation_ability) {\t\t\t\tdo take_ball;\t\t\t}\t\t}\t}\t\t// action of taking the ball\taction take_ball {\t\tif (ennemy_team.possess_ball) {\t\t\task ennemy_team.player_with_ball {\t\t\t\tdo loose_ball;\t\t\t}\t\t}\t\tpossess_ball &lt;- true;\t\tball.speed &lt;- 0.0;\t\tball.destination &lt;- ball.location;\t\tteam.called_player &lt;- nil;\t\tteam.player_with_ball &lt;- self;\t\tteam.possess_ball &lt;- true;\t\tgame.team_possession &lt;- team;\t}\t\t// action of loosing the ball\taction loose_ball {\t\tpossess_ball &lt;- false;\t\tteam.player_with_ball &lt;- nil;\t\tteam.possess_ball &lt;- false;\t}\t\t// apply the inertia\taction apply_inertia {\t\tpoint prev_pos &lt;- location;\t\tpoint inertia_vect &lt;- {(location.x-previous_pos.x)*0.7,(location.y-previous_pos.y)*0.7};\t\tfloat max_inertia &lt;- current_speed;\t\tif (norm(inertia_vect) &gt; max_inertia) {\t\t\tfloat inertia_x &lt;-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));\t\t\tfloat inertia_y &lt;-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));\t\t\tinertia_x &lt;- (inertia_vect.x &lt; 0) ? -inertia_x : inertia_x;\t\t\tinertia_y &lt;- (inertia_vect.y &lt; 0) ? -inertia_y : inertia_y;\t\t\tinertia_vect &lt;- {inertia_x,inertia_y};\t\t}\t\tlocation &lt;- location + inertia_vect;\t\tprevious_pos &lt;- prev_pos;\t}\t\t// useful functions\t// this function returns the real x if we pass a percentage : 0 is the extreme left point, 100 is the extreme right point.\tfloat getXPos(float x_ratio) {\t\tfloat result;\t\tif (team.position=\"back\") {\t\t\tresult &lt;- 90-x_ratio*90;\t\t}\t\telse {\t\t\tresult &lt;- x_ratio*90;\t\t}\t\treturn result;\t}\t\t// this function returns the real y if we pass a percentage : 0 is the extreme defensive point, 100 is the extreme attack point.\tfloat getYPos(float y_ratio) {\t\tfloat result;\t\tif (team.position=\"back\") {\t\t\tresult &lt;- y_ratio*120;\t\t}\t\telse {\t\t\tresult &lt;- 120-y_ratio*120;\t\t}\t\treturn result;\t}\t\t///////////////////////////////////////////////////////\t\t// The update function, calls the adequate behavior\treflex update when:cycle&gt;1 {\t\tdo apply_inertia;\t\t// verify if it is a non-offside position\t\tif ( (((team.position = \"back\") and (location.y &gt; team.offside_pos))\t\t\tor ((team.position = \"front\") and (location.y &lt; team.offside_pos))) \t\t\tand (!possess_ball) and (self != team.called_player)\t\t) {\t\t\t// offside position, go back to a correct position\t\t\tpoint target_pos &lt;- {location.x,(team.position = \"back\") ? location.y-current_speed:location.y+current_speed};\t\t\tdo run_to(target_pos);\t\t\tstatus &lt;- \"offside position !\";\t\t}\t\telse if ((distance_to_ball &lt; 2) and !possess_ball) {\t\t\tdo try_to_take_ball;\t\t}\t\telse if (game.team_possession = team) {\t\t\tdo offensive_behavior;\t\t}\t\telse {\t\t\tdo defensive_behavior;\t\t}\t}\t\t// defensive behavior, need to be redefined in the strategy file.\t// this action is called when the last player who was holding the ball was a player of the ennemy team\taction defensive_behavior virtual:true {\t\t\t}\t// defensive behavior, need to be redefined in the strategy file.\t// this action is called when the last player who was holding the ball was a player of this team\taction offensive_behavior virtual:true {\t\t\t}\t\t\t// ASPECT ////////////////////////////////////////////////////////\taspect player {\t\t// the player wich possess the ball is displayed with a square. It is displayed with a circle otherwise.\t\tif (possess_ball) {\t\t\tdraw square(2) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\t\t}\t\telse {\t\t\tdraw circle(1) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\t\t}\t}}species base_team {\t// ATTRIBUTES ////////////////////////////////////////////////\t\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\tfloat offside_pos &lt;- 0.0 update: (position = \"back\") ? max((game.players where (each.team != self)) collect (each.location.y))\t\t: min((game.players where (each.team != self)) collect (each.location.y));\t\t// ATTRIBUTES USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\tstring position; // can be \"front\" or \"back\".\tlist&lt;base_player&gt; players; // all the players of the team.\tsoccer_game game;\t\tbase_player closest_player_to_ball &lt;- first(players) update: first( players where (each distance_to each.ball = min (players collect (each distance_to each.ball) ) ) );\tbase_player called_player;\tbool possess_ball &lt;- false;// update: ! empty ( players where (each.possess_ball=true) );\tbase_player player_with_ball &lt;- nil;// update: first(players where (each.possess_ball = true));\t\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRATEGY FILE\tlist&lt;point&gt; player_init_position;}species ball_sp skills:[moving] {\t// The ball agent.\tfloat speed &lt;- 0.0;\tgeometry ball_direction; // the direction of the ball is used to be followed by the player\treflex update {\t\tspeed &lt;- speed*0.95;\t\tfloat future_speed &lt;- speed;\t\tpoint tmpPos&lt;-location;\t\tloop i from:0 to:10 {\t\t\ttmpPos &lt;- {tmpPos.x+cos(heading)*speed,tmpPos.y+sin(heading)*speed};\t\t\tfuture_speed &lt;- future_speed*0.9;\t\t}\t\tball_direction &lt;- line([location,tmpPos]);\t\tdo wander amplitude:1;\t\t\t\t// anticipation of the ball position to detect a goal\t\tif ((location.y+sin(heading)*speed) &gt; 120) {\t\t\twrite \"back team score a goal !!\";\t\t\task first(soccer_game) {\t\t\t\tdo reinit_phase;\t\t\t}\t\t}\t\tif ((location.y+sin(heading)*speed) &lt; 0) {\t\t\twrite \"front team score a goal !!\";\t\t\task first(soccer_game) {\t\t\t\tdo reinit_phase;\t\t\t}\t\t}\t}\taction shooted (point target_position, float speed_atr) {\t\t// action called when a player shoots the ball\t\tspeed &lt;- speed_atr;\t\tdo goto target:target_position;\t}\t\taspect ball {\t\tdraw circle(0.5) color:#white;\t}}species goal_sp {\tstring position; // can be \"front\" or \"back\".\t\tinit {\t\tcreate goal_keeper with:[position::position];\t}\t\taspect goal {\t\tdraw rectangle(7.32,1.0) color:#black;\t}}species goal_keeper {\t// the goal has a basic behavior : he tries to catch the ball when it is close enough, and when \tstring position; // can be \"front\" or \"back\".\tball_sp ball &lt;- nil update:first(ball_sp);\t\treflex update when:cycle&gt;0 {\t\tlocation &lt;- {ball.location.x/90*12+(90-12)/2,location.y};\t\tif (ball distance_to self &lt; 2) {\t\t\tif (flip(1/(1+2*ball.speed))) {\t\t\t\tfirst(soccer_game).team_possession &lt;- first(first(soccer_game).teams where (each.position = position));\t\t\t\task ball {\t\t\t\t\tdo shooted ({30+rnd(30),60},5.0);\t\t\t\t}\t\t\t}\t\t}\t}\t\tinit {\t\tlocation &lt;- {45,(position=\"front\") ? 117 : 3};\t}\t\taction offensive_behavior {\t}\t\taction defensive_behavior {\t}\t\taspect goal_keeper {\t\tdraw circle(1) color:(position = \"back\") ? first(soccer_game).back_color_team : first(soccer_game).front_color_team;\t}}Code of the model :model team1strategyimport \"./soccer_base.gaml\"species player_intelligentTeam parent:base_player {\t// READ ONLY ATTRIBUTES :\t// position : can be \"front\" or \"back\".\t// players : list of all the players of the team.\t// game\t//closest_player_to_ball\t// called_player : the player called for a pass\t// possess_ball : true or false\t// player_with_ball : player currently with the ball\t\t// READ AND WRITE ATTRIBUTES :\t// position_mark\t// status : the current status of the player (can be useful to build the model)\t// influence_area : the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\t\tfloat position_mark &lt;- 0.0 update: location.y - 20*number_of_ennemy_player_in_range + self.distance_to_closest_ennemy_player;\t\tstring role; // a value between \"defense\", \"mid\" and \"attack\".\tstring wing; // a value between \"left\", \"center\" and \"right\".\tgeometry influence_area &lt;- circle(15,init_pos);\t\tfloat defense_mid_pos &lt;- 30.0; // the y percent chosed to separate the defense from the mid position.\tfloat mid_attack_pos &lt;- 60.0; // the y percent chosen to separate the mid from the attack position.\t\tinit {\t\t// set the role of the player (between \"defense\", \"mid\" and \"attack\").\t\tif ( init_pos_in_percent.y &lt; defense_mid_pos ) {\t\t\trole &lt;- \"defense\";\t\t}\t\telse if ( (init_pos_in_percent.y &gt; mid_attack_pos ) ) {\t\t\trole &lt;- \"attack\";\t\t}\t\telse {\t\t\trole &lt;- \"mid\";\t\t}\t\t// set the wing of the player (between \"left\", \"center\" and \"right\")\t\tif ( init_pos_in_percent.x &lt; 40 ) {\t\t\twing &lt;- \"left\";\t\t}\t\telse if ( init_pos_in_percent.x &gt; 60 ) {\t\t\twing &lt;- \"right\";\t\t}\t\telse {\t\t\twing &lt;- \"center\";\t\t}\t}\t\taction update_influence_area {\t\tstatus &lt;- wing + \" \" + role;\t\tfloat y_ratio;\t\tif (role = \"defense\") { // defense position from 0% to 70% from the own goal, multiplied by the percentage of advancement of the ball\t\t\ty_ratio &lt;- 0.7 * ball_advancement;\t\t}\t\tif (role = \"mid\") { // mid position from 15% to 85% from the own goal, multiplied by the percentage of advancement of the ball\t\t\ty_ratio &lt;- 0.15 + 0.7 * ball_advancement;\t\t}\t\tif (role = \"attack\") { // attack position from 30% to 100% from the own goal, multiplied by the percentage of advancement of the ball\t\t\ty_ratio &lt;- 0.3 + 0.7 * ball_advancement;\t\t}\t\tfloat x_ratio;\t\tif (wing = \"center\") {\t\t\tx_ratio &lt;- 0.5;\t\t}\t\telse if (wing = \"left\") {\t\t\tx_ratio &lt;- 0.5 - 0.3 * cos( (y_ratio-0.5)*120 ); // the \"side\" wings are more marked if the player is in the center of the field.\t\t}\t\telse {\t\t\tx_ratio &lt;- 0.5 + 0.3 * cos( (y_ratio-0.5)*120 );\t\t}\t\tinfluence_area &lt;- circle(15,{getXPos(x_ratio),getYPos(y_ratio)});\t}\t\taction defensive_behavior {\t\t\tdo update_influence_area;\t\t// advanced defensive behavior\t\t// run to the ball if the player is the closest player from the ball.\t\tif ((self = team.closest_player_to_ball) or (self distance_to ball &lt; 5)) {\t\t\tstatus &lt;- getStatus(\"run to ball\");\t\t\tdo run_to_ball;\t\t}\t\telse {\t\t\t// if there is an ennemy player in the influence area, mark the player.\t\t\tif ( length(self.ennemy_team.players where (each intersects influence_area)) != 0 ) {\t\t\t\tbase_player marked_player &lt;- first(1 among (self.ennemy_team.players where (each intersects influence_area)));\t\t\t\tstatus &lt;- getStatus(\"mark player \"+marked_player);\t\t\t\tdo mark_player( marked_player );\t\t\t}\t\t\t// if there is no ennemy player in the influence area, stay in influence area.\t\t\telse {\t\t\t\tstatus &lt;- getStatus(\"run to influence area\");\t\t\t\tdo run_to(influence_area.location);\t\t\t}\t\t}\t}\t\taction offensive_behavior {\t\t\tdo update_influence_area;\t\t// advanced offensive behavior\t\tif (possess_ball) {\t\t\t// if the player has the ball and is close enough to the ennemy goal, shoot.\t\t\tif (distance_to_goal &lt; 35 and flip(1/(0.1+(self.distance_to_goal/10)^2))) {\t\t\t\tstatus &lt;- getStatus(\"shoot the ball\");\t\t\t\tdo shoot;\t\t\t}\t\t\t// if the player has the ball and is in a safe position, run to the ennemy goal.\t\t\telse if ( (position_mark = max( team.players collect (each.position_mark) )) or (distance_to_closest_ennemy_player &gt; 2) )\t\t\t{\t\t\t\tstatus &lt;- getStatus(\"run to ennemy goal\");\t\t\t\tdo run_to_ennemy_goal;\t\t\t}\t\t\t// if the player has the ball but is in a dangerous situation, pass the ball to another player.\t\t\telse {\t\t\t\tbase_player target_player &lt;- first(team.players where (each.position_mark = max( team.players collect (each.position_mark)) ) );\t\t\t\tstatus &lt;- getStatus(\"pass the ball to \"+target_player);\t\t\t\tdo pass_the_ball_ahead ( target_player,10.0 );\t\t\t}\t\t}\t\t// if the player has not the ball but is the called player, run to the ball.\t\telse if (self = team.called_player) {\t\t\tstatus &lt;- getStatus(\"run to ball\");\t\t\tdo run_to_ball;\t\t\tstatus &lt;- \"called player\";\t\t}\t\t// else, run to influence area.\t\telse {\t\t\tstatus &lt;- getStatus(\"run to influence area\");\t\t\tdo run_to(influence_area.location);\t\t}\t}\t\tstring getStatus(string str) {\t\treturn wing + \" \" + role + \"| action : \" + str;\t}\t}species intelligentTeam parent:base_team {\t// READ ONLY ATTRIBUTES :\t// position : can be \"front\" or \"back\".\t// players : list of all the players of the team.\t// game.\t// closest_player_to_ball.\t// called_player : the player called for a pass.\t// possess_ball : true when a player of the team possess the ball.\t// player_with_ball\t\t// READ AND WRITE ATTRIBUTES :\t// player_init_position\t\t// initial position of the player in percentage : for each point,\t//    the first value corresponds to the percentage from left to right (0 for the point the most in the left side)\t//    the second value corresponds to the percentage from the goal position to the mid position (0 for the goal position)\tlist&lt;point&gt; player_init_position &lt;- [{20,20},{50,20},{80,20},{30,50},{70,50},{50,70},{30,90},{50,90},{70,90}];}",
        "url":"/wiki/Soccer-team1_strategy.html"
      }
      ,
    
      "wiki-soccer-team2-strategy-html": {
        "title": "_team2strategy",
        "content": "_team2strategyAuthor : JulienThis model contains one of the 2 team strategy. This strategy is very stupid : when you have the ball, run to the ennemy goal, else run to the ballImported model :model soccerbasespecies soccer_game {\t// contains the global informations of the game\trgb back_color_team;\trgb front_color_team;\t\tball_sp ball; // the ball agent\tgoal_sp front_goal; // contains the goal at the front of the field (y = 120)\tgoal_sp back_goal; // contains the goal at the back of the field (y = 0)\tlist&lt;base_team&gt; teams; // contains the 2 teams\tlist&lt;base_player&gt; players; // contains all the players of the game\t\tbase_team team_possession; // the last team which possess the ball. This value is used to determine if the behavior of the team has to be defensive or offensive.\t\tinit {\t\t// create the entities ball and the 2 goals\t\tcreate ball_sp with:[location::world.location] returns:var_ball;\t\tball &lt;- first(var_ball);\t\tcreate goal_sp with:[location::{world.location.x,120},position::\"front\"] returns:var_goal1;\t\tfront_goal &lt;- first(var_goal1);\t\tcreate goal_sp with:[location::{world.location.x,0},position::\"back\"] returns:var_goal2;\t\tback_goal &lt;- first(var_goal2);\t}\t\taction reinit_phase {\t\t// this action is called when a goal has been scored : the players are placed with their initial position, and the ball is reset to the center\t\task players {\t\t\tlocation &lt;- init_pos;\t\t\tprevious_pos &lt;- init_pos;\t\t}\t\tball.location &lt;- world.location;\t\tball.destination &lt;- world.location;\t\tball.speed &lt;- 0.0;\t}}species base_player skills:[moving] {\t// ATTRIBUTES ////////////////////////////////////////////////\t\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\tfloat recuperation_ability &lt;- 0.2; // a mark from 0 to 1 to be able to catch the ball if another player has it\tfloat speed_without_ball;\tfloat speed_with_ball;\tpoint previous_pos; // used to apply inertia\tbool displacement_effectued&lt;-false update:false; // we can apply only one displacement by step !\t\t// ATTRIBUTE USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\tbase_team team;\tsoccer_game game;\tbase_team ennemy_team &lt;- nil update:first(game.teams where (each.position != team.position));\tball_sp ball &lt;- nil update:first(ball_sp);\tgoal_sp own_goal &lt;- nil update:first(goal_sp where (each.position = team.position));\tgoal_sp ennemy_goal &lt;- nil update:first(goal_sp where (each.position != team.position));\t// ratio of avancement of the ball (from the point of view of the current team)\tfloat ball_advancement &lt;- 0.0 update:(team.position = \"back\") ? ball.location.y / 120 : 1 - ball.location.y / 120;\t\tbool possess_ball;\tpoint init_pos;\tpoint init_pos_in_percent;\tfloat distance_to_closest_ennemy_player &lt;- 100.0 update:self distance_to closest_ennemy_player;\t// the number of ennemy players in a range of 15 meters\tint number_of_ennemy_player_in_range &lt;- 0 update:length((game.players where (each.team != team)) where ((each intersects circle(15))=true));\tfloat distance_to_ball &lt;- 100.0 update:(ball = nil) ? 100.0 : self distance_to ball;\tfloat distance_to_goal &lt;- 100.0 update:(ennemy_goal = nil) ? 100.0 : self distance_to ennemy_goal;\t// the closest player of this team\tbase_player closest_friend_player &lt;- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team = team and each != self)) \t\twhere (each distance_to self = min( (game.players where (each.team = team and each != self)) collect (each distance_to self) ) ) \t);\t// the closest ennemy player\tbase_player closest_ennemy_player &lt;- nil update:(ball = nil) ? base_player(nil) : first( (game.players where (each.team != team and each != self)) \t\twhere (each distance_to self = min( (game.players where (each.team != team and each != self)) collect (each distance_to self) ) ) \t);\t// the player of this team wich has the best \"position_mark\"\tbase_player best_position_player &lt;- nil update:first((team.players where (each != self)) \t\twhere (each.position_mark = max((team.players where (each != self)) collect (each.position_mark)))\t);\tfloat current_speed&lt;-1.0 update:(possess_ball) ? speed_with_ball : speed_without_ball;\t\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRAGEGY FILE\tfloat position_mark &lt;- 0.0 update:-distance_to_goal; // a mark attributed according to the position of the player (the higher the note is, the best the position is). \t// By default, this mark is equal to -distance_to_goal.\tstring status &lt;- \"\"; // the current status of the player (can be useful to build the model)\tgeometry influence_area &lt;- nil update:circle(15); // the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\t\t// CONSTRUCTOR /////////////////////////////////////////////\tinit {\t\tinit_pos &lt;- location;\t\tprevious_pos &lt;- location;\t\tpossess_ball &lt;- false;\t\tspeed_with_ball &lt;- 0.4;\t\tspeed_without_ball &lt;- 0.5;\t}\t\t// ACTIONS ////////////////////////////////////////////////////\t\t// ACTIONS TO CALL FROM THE STRATEGY FILE\t// action to run to a particular position\taction run_to(point target) {\t\tif (!displacement_effectued) {\t\t\t\tdo goto target:target speed:current_speed;\t\t\tif (possess_ball) {\t\t\t\tball.location &lt;- location;\t\t\t}\t\t\tdisplacement_effectued &lt;- true;\t\t}\t\telse {\t\t\twrite \"WARNING : only ONE action of displacement is allowed each step\";\t\t}\t}\t\t// action to run to the ball\taction run_to_ball {\t\tpoint targetPos;\t\tif (ball.ball_direction intersects circle(1)) {\t\t\ttargetPos &lt;- ball.location;\t\t}\t\telse {\t\t\ttargetPos &lt;- (ball.ball_direction closest_points_with self) at 0;\t\t}\t\tdo run_to(targetPos);\t}\t\t// action to run to the ennemy goal\taction run_to_ennemy_goal {\t\tdo run_to( ennemy_goal.location );\t}\t\t// action to run to its own goal\taction run_to_own_goal {\t\tdo run_to( own_goal.location );\t}\t\t// action to mark a player\taction mark_player (base_player player) {\t\tfloat rnd_area &lt;- 4.0; // the player will choose a position in a square of rnd_area m.\t\tpoint pos &lt;- (team.position = \"front\") ? {player.location.x,player.location.y-rnd_area/2} : {player.location.x,player.location.y+rnd_area/2};\t\tdo run_to( {pos.x-rnd_area/2+rnd(rnd_area),pos.y-rnd_area/2+rnd(rnd_area)} );\t}\t\t// action ot shoot the ball to the ennemy goal\taction shoot {\t\tdo loose_ball;\t\task ball {\t\t\tdo shooted speed_atr:3.0 target_position:myself.ennemy_goal.location;\t\t}\t}\t\t// action to pass the ball to an ally\taction pass_the_ball (base_player target_player) {\t\tdo loose_ball;\t\task ball {\t\t\tdo shooted target_position:target_player.location speed_atr:target_player.distance_to_ball/15;\t\t}\t\tteam.called_player &lt;- target_player;\t}\t\t// action to pass the ball to an ally\taction pass_the_ball_ahead (base_player target_player,float number_of_meter_ahead) {\t\tdo loose_ball;\t\task ball {\t\t\tfloat offset &lt;- ((myself.team.position = \"back\") ? number_of_meter_ahead : -number_of_meter_ahead);\t\t\tpoint target_point &lt;- {target_player.location.x,target_player.location.y+offset};\t\t\tdo shooted target_position:target_point speed_atr:target_player.distance_to_ball/15;\t\t}\t\tteam.called_player &lt;- target_player;\t}\t\t// ACTION AUTOMATICALLY CALLED IN THE BASE CLASSE\t// try to take the ball if it is close enough\taction try_to_take_ball {\t\t// if no player has the ball\t\tif (!team.possess_ball and !ennemy_team.possess_ball) {\t\t\t// if the player is the one called (result of a pass)\t\t\tif (team.called_player = self) {\t\t\t\tdo take_ball;\t\t\t}\t\t\t// if the player is not the one called (interception of the ball), probability to catch the ball inversly proportionnal with the speed of the ball\t\t\telse {\t\t\t\tif (flip(1/(1+2*ball.speed))) {\t\t\t\t\tdo take_ball;\t\t\t\t}\t\t\t}\t\t}\t\t// the ball is possessed by the ennemy team\t\telse if (ennemy_team.possess_ball) {\t\t\t// try to catch the ball from the other player\t\t\tif flip(recuperation_ability) {\t\t\t\tdo take_ball;\t\t\t}\t\t}\t}\t\t// action of taking the ball\taction take_ball {\t\tif (ennemy_team.possess_ball) {\t\t\task ennemy_team.player_with_ball {\t\t\t\tdo loose_ball;\t\t\t}\t\t}\t\tpossess_ball &lt;- true;\t\tball.speed &lt;- 0.0;\t\tball.destination &lt;- ball.location;\t\tteam.called_player &lt;- nil;\t\tteam.player_with_ball &lt;- self;\t\tteam.possess_ball &lt;- true;\t\tgame.team_possession &lt;- team;\t}\t\t// action of loosing the ball\taction loose_ball {\t\tpossess_ball &lt;- false;\t\tteam.player_with_ball &lt;- nil;\t\tteam.possess_ball &lt;- false;\t}\t\t// apply the inertia\taction apply_inertia {\t\tpoint prev_pos &lt;- location;\t\tpoint inertia_vect &lt;- {(location.x-previous_pos.x)*0.7,(location.y-previous_pos.y)*0.7};\t\tfloat max_inertia &lt;- current_speed;\t\tif (norm(inertia_vect) &gt; max_inertia) {\t\t\tfloat inertia_x &lt;-  sqrt(abs(max_inertia*max_inertia-inertia_vect.y*inertia_vect.y));\t\t\tfloat inertia_y &lt;-  sqrt(abs(max_inertia*max_inertia-inertia_vect.x*inertia_vect.x));\t\t\tinertia_x &lt;- (inertia_vect.x &lt; 0) ? -inertia_x : inertia_x;\t\t\tinertia_y &lt;- (inertia_vect.y &lt; 0) ? -inertia_y : inertia_y;\t\t\tinertia_vect &lt;- {inertia_x,inertia_y};\t\t}\t\tlocation &lt;- location + inertia_vect;\t\tprevious_pos &lt;- prev_pos;\t}\t\t// useful functions\t// this function returns the real x if we pass a percentage : 0 is the extreme left point, 100 is the extreme right point.\tfloat getXPos(float x_ratio) {\t\tfloat result;\t\tif (team.position=\"back\") {\t\t\tresult &lt;- 90-x_ratio*90;\t\t}\t\telse {\t\t\tresult &lt;- x_ratio*90;\t\t}\t\treturn result;\t}\t\t// this function returns the real y if we pass a percentage : 0 is the extreme defensive point, 100 is the extreme attack point.\tfloat getYPos(float y_ratio) {\t\tfloat result;\t\tif (team.position=\"back\") {\t\t\tresult &lt;- y_ratio*120;\t\t}\t\telse {\t\t\tresult &lt;- 120-y_ratio*120;\t\t}\t\treturn result;\t}\t\t///////////////////////////////////////////////////////\t\t// The update function, calls the adequate behavior\treflex update when:cycle&gt;1 {\t\tdo apply_inertia;\t\t// verify if it is a non-offside position\t\tif ( (((team.position = \"back\") and (location.y &gt; team.offside_pos))\t\t\tor ((team.position = \"front\") and (location.y &lt; team.offside_pos))) \t\t\tand (!possess_ball) and (self != team.called_player)\t\t) {\t\t\t// offside position, go back to a correct position\t\t\tpoint target_pos &lt;- {location.x,(team.position = \"back\") ? location.y-current_speed:location.y+current_speed};\t\t\tdo run_to(target_pos);\t\t\tstatus &lt;- \"offside position !\";\t\t}\t\telse if ((distance_to_ball &lt; 2) and !possess_ball) {\t\t\tdo try_to_take_ball;\t\t}\t\telse if (game.team_possession = team) {\t\t\tdo offensive_behavior;\t\t}\t\telse {\t\t\tdo defensive_behavior;\t\t}\t}\t\t// defensive behavior, need to be redefined in the strategy file.\t// this action is called when the last player who was holding the ball was a player of the ennemy team\taction defensive_behavior virtual:true {\t\t\t}\t// defensive behavior, need to be redefined in the strategy file.\t// this action is called when the last player who was holding the ball was a player of this team\taction offensive_behavior virtual:true {\t\t\t}\t\t\t// ASPECT ////////////////////////////////////////////////////////\taspect player {\t\t// the player wich possess the ball is displayed with a square. It is displayed with a circle otherwise.\t\tif (possess_ball) {\t\t\tdraw square(2) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\t\t}\t\telse {\t\t\tdraw circle(1) color:(team.position = \"back\") ? game.back_color_team : game.front_color_team;\t\t}\t}}species base_team {\t// ATTRIBUTES ////////////////////////////////////////////////\t\t// ATTRIBUTES ONLY USED IN THIS BASE CLASSE, SHOULD NEVER BEEN CALLED IN STRATEGY FILE\tfloat offside_pos &lt;- 0.0 update: (position = \"back\") ? max((game.players where (each.team != self)) collect (each.location.y))\t\t: min((game.players where (each.team != self)) collect (each.location.y));\t\t// ATTRIBUTES USEFUL TO BE READ IN THE TEAM STRATEGY FILE (READ ONLY !)\tstring position; // can be \"front\" or \"back\".\tlist&lt;base_player&gt; players; // all the players of the team.\tsoccer_game game;\t\tbase_player closest_player_to_ball &lt;- first(players) update: first( players where (each distance_to each.ball = min (players collect (each distance_to each.ball) ) ) );\tbase_player called_player;\tbool possess_ball &lt;- false;// update: ! empty ( players where (each.possess_ball=true) );\tbase_player player_with_ball &lt;- nil;// update: first(players where (each.possess_ball = true));\t\t// ATTRIBUTES WICH CAN BE CHANGED FROM THE TEAM STRATEGY FILE\tlist&lt;point&gt; player_init_position;}species ball_sp skills:[moving] {\t// The ball agent.\tfloat speed &lt;- 0.0;\tgeometry ball_direction; // the direction of the ball is used to be followed by the player\treflex update {\t\tspeed &lt;- speed*0.95;\t\tfloat future_speed &lt;- speed;\t\tpoint tmpPos&lt;-location;\t\tloop i from:0 to:10 {\t\t\ttmpPos &lt;- {tmpPos.x+cos(heading)*speed,tmpPos.y+sin(heading)*speed};\t\t\tfuture_speed &lt;- future_speed*0.9;\t\t}\t\tball_direction &lt;- line([location,tmpPos]);\t\tdo wander amplitude:1;\t\t\t\t// anticipation of the ball position to detect a goal\t\tif ((location.y+sin(heading)*speed) &gt; 120) {\t\t\twrite \"back team score a goal !!\";\t\t\task first(soccer_game) {\t\t\t\tdo reinit_phase;\t\t\t}\t\t}\t\tif ((location.y+sin(heading)*speed) &lt; 0) {\t\t\twrite \"front team score a goal !!\";\t\t\task first(soccer_game) {\t\t\t\tdo reinit_phase;\t\t\t}\t\t}\t}\taction shooted (point target_position, float speed_atr) {\t\t// action called when a player shoots the ball\t\tspeed &lt;- speed_atr;\t\tdo goto target:target_position;\t}\t\taspect ball {\t\tdraw circle(0.5) color:#white;\t}}species goal_sp {\tstring position; // can be \"front\" or \"back\".\t\tinit {\t\tcreate goal_keeper with:[position::position];\t}\t\taspect goal {\t\tdraw rectangle(7.32,1.0) color:#black;\t}}species goal_keeper {\t// the goal has a basic behavior : he tries to catch the ball when it is close enough, and when \tstring position; // can be \"front\" or \"back\".\tball_sp ball &lt;- nil update:first(ball_sp);\t\treflex update when:cycle&gt;0 {\t\tlocation &lt;- {ball.location.x/90*12+(90-12)/2,location.y};\t\tif (ball distance_to self &lt; 2) {\t\t\tif (flip(1/(1+2*ball.speed))) {\t\t\t\tfirst(soccer_game).team_possession &lt;- first(first(soccer_game).teams where (each.position = position));\t\t\t\task ball {\t\t\t\t\tdo shooted ({30+rnd(30),60},5.0);\t\t\t\t}\t\t\t}\t\t}\t}\t\tinit {\t\tlocation &lt;- {45,(position=\"front\") ? 117 : 3};\t}\t\taction offensive_behavior {\t}\t\taction defensive_behavior {\t}\t\taspect goal_keeper {\t\tdraw circle(1) color:(position = \"back\") ? first(soccer_game).back_color_team : first(soccer_game).front_color_team;\t}}Code of the model :model team2strategyimport \"./soccer_base.gaml\"species player_stupidTeam parent:base_player {\t// READ ONLY ATTRIBUTES :\t// position : can be \"front\" or \"back\".\t// players : list of all the players of the team.\t// game\t//closest_player_to_ball\t// called_player : the player called for a pass\t// possess_ball : true or false\t// player_with_ball : player currently with the ball\t\t// READ AND WRITE ATTRIBUTES :\t// position_mark\t// status : the current status of the player (can be useful to build the model)\t// influence_area : the area of interest of the player. By default, this area is a circle 15m diameter centered in the player location.\t\t\taction defensive_behavior {\t\t\t// very basic defensive behavior : run to the ball\t\tdo run_to_ball;\t}\t\taction offensive_behavior {\t\t\t// very basic offensive behavior : run to the ennemy goal, or shoot the ball when close enough from the ennemy goal.\t\tif ((possess_ball) and (distance_to_goal &lt; 30)) {\t\t\tdo shoot;\t\t}\t\telse {\t\t\tdo run_to_ennemy_goal;\t\t}\t}\t}species stupidTeam parent:base_team {\t// READ ONLY ATTRIBUTES :\t// position : can be \"front\" or \"back\".\t// players : list of all the players of the team.\t// game.\t// closest_player_to_ball.\t// called_player : the player called for a pass.\t// possess_ball : true when a player of the team possess the ball.\t// player_with_ball\t\t// READ AND WRITE ATTRIBUTES :\t// player_init_position\t\t// initial position of the player in percentage : for each point,\t//    the first value corresponds to the percentage from left to right (0 for the point the most in the left side)\t//    the second value corresponds to the percentage from the goal position to the mid position (0 for the goal position)\tlist&lt;point&gt; player_init_position &lt;- [{20,20},{50,20},{80,20},{30,50},{70,50},{50,70},{30,90},{50,90},{70,90}];}",
        "url":"/wiki/Soccer-team2_strategy.html"
      }
      ,
    
      "wiki-soccer-html": {
        "title": "Soccer",
        "content": "SoccerThis sub-section is composed of the following models :      Soccer Game        Soccer game (Various strategies)  ",
        "url":"/wiki/Soccer.html"
      }
      ,
    
      "wiki-spatial-operators-geometry-discretization-html": {
        "title": "Discretization of Topology",
        "content": "Discretization of TopologyAuthor : Patrick TaillandierA model which shows how to use the different convert topologies operators : to_square, to_rectangle, points_on, triangulate, voronoi.Code of the model :model discretizationglobal {\t//Geometry that will be used for each display : a circle\tgeometry init_geom &lt;- circle (35);}experiment main type: gui {\toutput {\t\t//Display that will show a circle converted in squares\t\tdisplay decretization_squares {\t\t\tgraphics \"init_geom\" {draw init_geom color: °black;}\t\t\tgraphics \"geoms\" transparency: 0.5{\t\t\t\t//Convert the initial circle into squares of 5.0 \t\t\t\tloop g over: to_squares(init_geom, 5.0) {\t\t\t\t\tdraw g color: °red;\t\t\t\t} \t\t\t} \t\t}\t\t//Display that will show a circle converted in squares overlapping the shape\t\tdisplay squares_overlapping {\t\t\tgraphics \"init_geom\" {draw init_geom color: °black;}\t\t\tgraphics \"squares\" transparency: 0.5{\t\t\t\t//Convert the initial circle into rectangles of 5.0 and keep the squares going out of the borders of the circle but still overlapping it\t\t\t\tloop g over: to_squares(init_geom,5.0, true) {\t\t\t\t\tdraw g color: °red;\t\t\t\t} \t\t\t} \t\t}\t\t//Display that will show a circle converted in squares inside the shape\t\tdisplay squares_inside {\t\t\tgraphics \"init_geom\" {draw init_geom color: °black;}\t\t\tgraphics \"squares\" transparency: 0.5{\t\t\t\t//Convert the initial circle into squares of 5.0 and remove the squares going out of the borders of the circle\t\t\t\tloop g over: to_squares(init_geom, 5.0, false) {\t\t\t\t\tdraw g color: °red;\t\t\t\t} \t\t\t} \t\t}\t\t//Display that will show a circle converted in rectangles with a size of 10.0 and 5.0\t\tdisplay decretization_rectangles {\t\t\tgraphics \"init_geom\" {draw init_geom color: °black;}\t\t\tgraphics \"geoms\" transparency: 0.5{\t\t\t\tloop g over: to_rectangles(init_geom, {10.0,5.0}) {\t\t\t\t\tdraw g color: °red;\t\t\t\t} \t\t\t} \t\t}\t\t//Display that will show a circle converted in rectangles forming a grid of 15 cols and 20 rows\t\tdisplay decretization_rectangles_grid {\t\t\tgraphics \"init_geom\" {draw init_geom color: °black;}\t\t\tgraphics \"geoms\" transparency: 0.5{\t\t\t\tloop g over: to_rectangles(init_geom, 15,20) {\t\t\t\t\tdraw g color: °red;\t\t\t\t} \t\t\t} \t\t}\t\t//Display that will show a circle converted in rectangles overlapping the shape\t\tdisplay rectangles_overlapping {\t\t\tgraphics \"init_geom\" {draw init_geom color: °black;}\t\t\tgraphics \"rectangles\" transparency: 0.5{\t\t\t\t//Convert the initial circle into rectangles of 5.0 and keep the rectangles going out of the borders of the circle but still overlapping it\t\t\t\tloop g over:  to_rectangles(init_geom, {10.0,5.0}, true){\t\t\t\t\tdraw g color: °red;\t\t\t\t} \t\t\t} \t\t}\t\t//Display that will show a circle converted in rectangles inside the shape\t\tdisplay rectangles_inside {\t\t\tgraphics \"init_geom\" {draw init_geom color: °black;}\t\t\tgraphics \"rectangles\" transparency: 0.5{\t\t\t\t//Convert the initial circle into rectangles of 5.0 and remove the rectanges going out of the borders of the circle\t\t\t\tloop g over: to_rectangles(init_geom, {10.0,5.0}, false) {\t\t\t\t\tdraw g color: °red;\t\t\t\t} \t\t\t} \t\t}\t\t\t\t//Display that will show a circle triangulated\t\tdisplay triangles {\t\t\tgraphics \"init_geom\" {draw init_geom color: °black;}\t\t\tgraphics \"triangles\" transparency: 0.5{\t\t\t\tloop g over: triangulate(init_geom) {\t\t\t\t\tdraw g color: °red;\t\t\t\t}\t\t\t} \t\t}\t\t\t\t//Display that will show a circle with points on its perimeter every 10.0\t\tdisplay points_on_contours {\t\t\tgraphics \"init_geom\" {draw init_geom color: °black;}\t\t\tgraphics \"geoms\" transparency: 0.5{\t\t\t\tloop g over: points_on(init_geom,10.0) {\t\t\t\t\tdraw circle(2) at: g color: °red;\t\t\t\t} \t\t\t} \t\t}\t\t\t\tdisplay voronoi {\t\t\t//Creates a voronoi diagram from the points given and display them\t\t\tgraphics \"geoms\" transparency: 0.5{\t\t\t\tloop g over: voronoi([{10,10},{10,10},{80,80},{80,10},{10,80}, {40,40}]) {\t\t\t\t\tdraw g color: °red;\t\t\t\t}\t\t\t}\t\t\tgraphics \"points\" {\t\t\t\tloop pt over: [{10,10},{10,10},{80,80},{80,10},{10,80}, {40,40}] {\t\t\t\t\tdraw circle(2) at: pt color: °black;\t\t\t\t}\t\t\t} \t\t}\t}}",
        "url":"/wiki/Spatial-Operators-Geometry-discretization.html"
      }
      ,
    
      "wiki-spatial-operators-spatial-operators-examples-html": {
        "title": "Spatial Operators",
        "content": "Spatial OperatorsAuthor : Patrick TaillandierA model which shows how to use spatial operators like rotated_by, scaled_by and convex_hullCode of the model :model example_spatial_operatorsglobal {\t// Parameters for the shapefiles\tfile shape_file_name_init  &lt;- file('../gis/init.shp') ;\tfile shape_file_name_background  &lt;- file('../gis/background.shp');\t\t//Parameters for the agents\t\t\tfloat dying_size min: 100.0  &lt;-10000.0 ; \tfloat crossover_size min: 100.0  &lt;- 1000.0;\tfloat minimum_size min: 100.0 &lt;- 500.0; \tint time_wthout_co min: 1 &lt;- 7;\tfloat speed min: 1.0  &lt;- 10.0; \tfloat crossover_rate min: 0.1  &lt;- 0.95; \tfloat scaling_factor min: 1.001 &lt;- 1.05;\tfloat angle_rotation_max min: 0.0 &lt;- 45.0;\tint nb_partners_max min: 1  &lt;- 1;\tint max_side_size min: 1 &lt;- 5;  \tint background_size_side min: 20 max: 100 &lt;- 80 ;\t\t// Environment\tgeometry shape &lt;- envelope(shape_file_name_background);\t\treflex stop when: empty ( object ) {\t\tdo halt;  \t} }species object topology: topology(shape_file_name_init) {\trgb color &lt;- rgb ( [ rnd ( 255 ) , rnd ( 255 ) , rnd ( 255 ) ]);\tpoint location_new_Ag &lt;- nil;\trgb color_new_Ag &lt;- nil;\tint nb_last_rep &lt;- 0;\t\t\t//Reflex making the shape of the agent growing and rotate it randomly\treflex evolve {\t\tnb_last_rep &lt;- nb_last_rep + 1;\t\tshape &lt;- shape scaled_by scaling_factor;\t\tshape &lt;- shape rotated_by ((rnd ( 100 * angle_rotation_max))/ 100.0);\t\t\t}\t\t//Make the agent move, kill it if is area is greater than the dying size or intersecting contours of the world\treflex move {\t\tlocation &lt;- location + { speed * ( 1 - rnd ( 2 ) ) , speed * ( 1 - rnd ( 2 ) ) };\t\tif ( (shape.area &gt; dying_size) or (shape intersects world.shape.contour)) {\t\t\tdo die; \t\t}\t\t\t\t}\t\t\t//Reflex to change the shape of the agent intersects an other agent and create a convex hull of the shape of the new agent resulting in the intersection of the shapes of the agent and an other one\treflex crossover when: ( shape.area &gt; crossover_size ) and ( nb_last_rep &gt; time_wthout_co ) { \t\tint nb_partners  &lt;- 0;\t\tlist&lt;object&gt; list_people &lt;- shuffle ( object );\t\tloop p over: list_people {\t\t\tif ( p != self ) and ( nb_partners &lt;= nb_partners_max ) and (rnd ( 100 ) &lt; ( crossover_rate * 100 ) ) and ( (p.shape).area &gt; crossover_size ) and ( p . nb_last_rep &gt; time_wthout_co ) and (shape intersects p.shape) {\t\t\t\tnb_partners &lt;- nb_partners + 1;\t\t\t\tgeometry new_ag &lt;- (shape inter p.shape);\t\t\t\tif ( new_ag != nil ) and ( new_ag.area &gt; minimum_size ) {\t\t\t\t\tnb_last_rep &lt;- 0;\t\t\t\t\task p {\t\t\t\t\t\tnb_last_rep &lt;- 0;\t\t\t\t\t}\t\t\t\t\tcreate object  {\t\t\t\t\t\tcolor &lt;- (myself.color + p.color) / 2;\t\t\t\t\t\tshape &lt;-  convex_hull(new_ag);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t\t}\t\taspect geometry {\t\tdraw shape color: color;\t}}experiment example_spatial_operators type: gui {\tparameter 'Path of shapefile to load for the initial agent:' var: shape_file_name_init  category: 'GIS specific' ;\tparameter 'Path of shapefile to load for the background:' var: shape_file_name_background category: 'GIS specific';\tparameter 'Size (area) from which an agent dies:' var: dying_size min: 100.0  category: 'Population'; \tparameter 'Min size (area) for crossover:' var:crossover_size category: 'Population';\tparameter 'Minimum size (area) of a agent produced by a crossover:' var:minimum_size category: 'Population';\tparameter 'Number of steps without crossing-over for an agent:' var:time_wthout_co category: 'Population';\tparameter 'Agent deplacement speed:' var:speed category: 'Population' ; \tparameter 'Rate of crossover' var:crossover_rate category: 'Population'; \tparameter 'Scaling factor for agent geometry (at each step):' var:scaling_factor category: 'Population';\tparameter 'Max rotation angle for agent geometry (at each step):' var:angle_rotation_max category:'Population';\tparameter 'Max number of possible partners for crossing-overs (per step)' var:nb_partners_max category: 'Population' ;\tparameter 'Size max of the initiale side of an agent:' var:max_side_size category: 'Population'; \tparameter 'Size background side:' var: background_size_side category: 'Population' ;\toutput {\t\tdisplay space_display {\t\t\tgraphics \"background\" {\t\t\t\tdraw world.shape color: rgb ([ 255 , 240 , 240 ]);\t\t\t}\t\t\tspecies object aspect: geometry;\t\t}\t}}",
        "url":"/wiki/Spatial-Operators-Spatial-Operators-(Examples).html"
      }
      ,
    
      "wiki-spatial-operators-topologies-html": {
        "title": "Spatial Operators",
        "content": "Spatial OperatorsAuthor : Patrick TaillandierA model which shows how to use spatial operator, allowing the user to change the parameter operator in the experiment to test the different operators and see the resultsCode of the model :model gridfilterglobal {\tmap&lt;string,map&lt;dummy,rgb&gt;&gt; theDummies;\tmap&lt;string,map&lt;cell,rgb&gt;&gt; theCells; \tstring parameter_operator &lt;-\"closest_to\" among:[\"closest_to\",\"at_distance\",\"neighbors_at\",\"distance_to\",\"path_to\",\"cluster_distance\",\"cluster_hierarchical\"];\tinit {\t\t\t\t//Create the agents\t\tdo create_dummy_agents; \t\t//Different actions to test the operators\t\tdo test_agents_at_distance;\t\tdo test_distance_to;\t\tdo test_neighbors_at;\t\tdo test_path_to;\t\tdo test_simple_clustering_by_distance;\t\tdo test_hierarchical_clustering;\t\tdo test_agent_closest_to; \t\t}  \t\taction test_agent_closest_to {\t\t//It is possible to use the topology of the world (default), the graph or the grid\t\tadd [dummy(8)::#yellow] at:\"closest_to\" to:theDummies;\t\tadd #red at:dummy closest_to (dummy(8)) to:theDummies[\"closest_to\"];\t\t\t\t\t\tadd [cell(40)::#yellow] at:\"closest_to\" to:theCells;\t\tadd #red at:cell closest_to (cell(40)) to:theCells[\"closest_to\"];\t}\taction test_agents_at_distance {\t\t\t\t//It is possible to use the topology of the world (default), the graph or the grid\t\task dummy(8)\t\t{\t\t\tadd [self::#yellow] at:\"at_distance\" to:theDummies;\t\t\tloop a_dummy over: agents_at_distance(30) of_species dummy\t\t\t{\t\t\t\t\tadd #red at:a_dummy to:theDummies[\"at_distance\"];\t\t\t}\t\t}\t\task cell(40)\t\t{\t\t\tadd [self::#yellow] at:\"at_distance\" to:theCells;\t\t\tloop a_cell over: agents_at_distance(10) of_species cell\t\t\t{\t\t\t\t\tadd #red at:a_cell to:theCells[\"at_distance\"];\t\t\t}\t\t}\t}\t\taction test_neighbors_at {\t\t\t\t//It is possible to use the topology of the world (default), the graph or the grid\t\t//The operator neighbors_at gives the same results that neighbors_of( an_agent, a_distance )\t\t\t\tadd [dummy(8)::#yellow] at:\"neighbors_at\" to:theDummies;\t\tloop a_dummy over: dummy(8) neighbors_at 30\t\t{\t\t\t\tadd #red at:a_dummy to:theDummies[\"neighbors_at\"];\t\t}\t\tadd [cell(40)::#yellow] at:\"neighbors_at\" to:theCells;\t\tloop a_cell over: cell(40) neighbors_at 20\t\t{\t\t\t\tadd #red at:a_cell to:theCells[\"neighbors_at\"];\t\t}\t}\t\taction test_distance_to {\t\t\t\t//It is possible to use the topology of the world (default), the graph or the grid\t\t//The operator distance_to gives the same results that the operator topology distance_between[an_agent_A,an_agent_B]\t\tadd [dummy(8)::#yellow] at:\"distance_to\" to:theDummies;\t\tadd #red at:dummy(5) to:theDummies[\"distance_to\"];\t\t\t\tadd [cell(40)::#yellow] at:\"distance_to\" to:theCells;\t\tadd #red at:cell(27) to:theCells[\"distance_to\"];\t}\t\taction test_path_to {\t\t\t\t//It is possible to use the topology of the world (default), the graph or the grid\t\t//The operator distance_to gives the same results that the operator topology path_between[an_agent_A,an_agent_B]\t\tadd [dummy(8)::#yellow] at:\"path_to\" to:theDummies;\t\tadd #red at:dummy(9) to:theDummies[\"path_to\"];\t\t\t\tadd [cell(40)::#yellow] at:\"path_to\" to:theCells;\t\tadd #red at:cell(28) to:theCells[\"path_to\"];\t}\taction test_simple_clustering_by_distance \t{\t\t//Can be used for other topologies by adding using(topology(cell)) for example\t\t\t\tlist&lt;list&lt;dummy&gt;&gt; clusteredDummies &lt;- list&lt;list&lt;dummy&gt;&gt;(dummy simple_clustering_by_distance 30);\t\tloop a_list over: clusteredDummies\t\t{\t\t\trgb colorList &lt;- rgb(rnd(255),rnd(255),rnd(255));\t\t\tloop a_dummy over: a_list\t\t\t{\t\t\t\tif(length(theDummies[\"cluster_distance\"])=0)\t\t\t\t{\t\t\t\t\tadd map&lt;dummy,rgb&gt;([a_dummy::colorList]) at:\"cluster_distance\" to:theDummies;\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tadd colorList at:a_dummy to:theDummies[\"cluster_distance\"];\t\t\t\t}\t\t\t}\t\t}\t}\taction test_hierarchical_clustering {\t\t//Can be used for other topologies by adding using(topology(cell)) for example\t\tlist&lt;list&lt;dummy&gt;&gt; clusteredDummies &lt;- list&lt;list&lt;dummy&gt;&gt;(dummy hierarchical_clustering 10);\t\t\t\tloop a_list over: clusteredDummies\t\t{\t\t\trgb colorList &lt;- rgb(rnd(255),rnd(255),rnd(255));\t\t\tloop a_dummy over: a_list\t\t\t{\t\t\t\tif(length(theDummies[\"cluster_hierarchical\"])=0)\t\t\t\t{\t\t\t\t\tadd map&lt;dummy,rgb&gt;([a_dummy::colorList]) at:\"cluster_hierarchical\" to:theDummies;\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tadd colorList at:a_dummy to:theDummies[\"cluster_hierarchical\"];\t\t\t\t}\t\t\t}\t\t}\t}\taction create_dummy_agents {\t\tcreate dummy with: [location :: {5,5}];\t\tcreate dummy with: [location :: {8,9}];\t\tcreate dummy with: [location :: {14,6}];\t\tcreate dummy with: [location :: {35,55}];\t\tcreate dummy with: [location :: {25,75}];\t\tcreate dummy with: [location :: {56,80}];\t\tcreate dummy with: [location :: {10,70}];\t\tcreate dummy with: [location :: {80,8}];\t\tcreate dummy with: [location :: {34,78}];\t\tcreate dummy with: [location :: {67,32}];\t\tloop i from: 0 to: length(dummy) - 1 {\t\t\task dummy[i] {id &lt;- string(i);}\t\t}\t}\t}grid cell width: 10 height: 10 neighbors: 4{\trgb color &lt;- #green;}species dummy {\tstring id;\taspect default {\t\tdraw circle(2) color: #yellow;\t\tdraw id size: 6 color: #black;\t}}experiment topology_test type: gui {\t/** Insert here the definition of the input and output of the model */\tparameter \"Operator\" var: parameter_operator;\toutput {\t\t\t\tdisplay Continuous_Environment  \t\t{\t\t\tgraphics cell\t\t\t{\t\t\t\tloop a_key over: theCells[parameter_operator].pairs {\t\t\t\t\tdraw a_key.key at:a_key.key.location color: theCells[parameter_operator][a_key.key] ;\t\t\t\t}\t\t\t\tloop a_cell over: cell-theCells[parameter_operator].keys\t\t\t\t{\t\t\t\t\tdraw a_cell at:a_cell.location color: #green ;\t\t\t\t}\t\t\t\t\t\t\t\t//Display a line between the two chosen cell for the distance_to operator\t\t\t\tif(parameter_operator=\"distance_to\")\t\t\t\t{\t\t\t\t\tgeometry aLine &lt;- line([theCells[parameter_operator].keys[0].location,theCells[parameter_operator].keys[1].location]) +1.2;\t\t\t\t\tdraw (aLine) color:#silver;\t\t\t\t\tdraw string(distance_to (theCells[parameter_operator].keys[0].location,theCells[parameter_operator].keys[1].location)) at:aLine.location size: 6 color: #silver;\t\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\t//Display a path between the two chosen cell for the path_to operator\t\t\t\t\tif(parameter_operator=\"path_to\")\t\t\t\t\t{\t\t\t\t\t\t\tpath aPath &lt;- theCells[parameter_operator].keys[0] path_to theCells[parameter_operator].keys[1].location;\t\t\t\t\t\t\tloop eg over: aPath.edges\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\tdraw (geometry(eg)+1.2) color:#silver;\t\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tgraphics dummy\t\t\t{\t\t\t\tloop a_key over: theDummies[parameter_operator].pairs {\t\t\t\t\tdraw circle(2) at:a_key.key.location color: theDummies[parameter_operator][a_key.key] ;\t\t\t\t\tdraw a_key.key.id at:a_key.key.location size: 6 color: #black;\t\t\t\t\t}\t\t\t\tloop a_dummy over: dummy-theDummies[parameter_operator].keys\t\t\t\t{\t\t\t\t\tdraw circle(2) at:a_dummy.location color: #grey ;\t\t\t\t\tdraw a_dummy.id at:a_dummy.location size: 6 color: #black;\t\t\t\t\t}\t\t\t\t//Display a line between the two chosen dummies for the distance_to operator\t\t\t\tif(parameter_operator=\"distance_to\")\t\t\t\t{\t\t\t\t\tgeometry aLine &lt;- line([theDummies[parameter_operator].keys[0].location,theDummies[parameter_operator].keys[1].location]) +1.2;\t\t\t\t\tdraw (aLine) color:#pink;\t\t\t\t\tdraw string(distance_to (theDummies[parameter_operator].keys[0].location,theDummies[parameter_operator].keys[1].location)) at:aLine.location size: 6 color: #pink;\t\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\t//Display a path between the two chosen dummies for the path_to operator\t\t\t\t\tif(parameter_operator=\"path_to\")\t\t\t\t\t{\t\t\t\t\t\t\tpath aPath &lt;- theDummies[parameter_operator].keys[0] path_to theDummies[parameter_operator].keys[1].location;\t\t\t\t\t\t\tloop eg over: aPath.edges\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\tdraw (geometry(eg)+1.2) color:#pink;\t\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t}}",
        "url":"/wiki/Spatial-Operators-Topologies.html"
      }
      ,
    
      "wiki-spatial-operators-spatialinterpolation-html": {
        "title": "Spatial Interpolation",
        "content": "Spatial InterpolationAuthor : Patrick TaillandierA model which shows how to use spatial interpolationCode of the model :model spatialinterpolationglobal {\tmap&lt;point, float&gt; pts;\tfloat max_val; \tfloat min_val ; \t\t//power parameter\tint power &lt;- 2;\t\t//cell properties\tint nb_rows &lt;- 50;\tint nb_columns &lt;- 50;\t\tinit {\t\t//creation of random point for demo puporse\t\tloop times: 50 {\t\t\tpoint pt &lt;- any_location_in(world);\t\t\tpts[pt] &lt;-pt.x ^2 + pt.y ^2;\t\t}\t\t\t\t//computation of the min and max values of the points (just use to define the color of the cells).\t\tmax_val &lt;- max(pts.values);  \t\tmin_val &lt;- min(pts.values); \t\t\t\t//computation of the value for each cell\t\tmap&lt;cell_shape, float&gt; results_shape &lt;- map&lt;cell_shape, float&gt;(IDW(cell_shape, pts, power));\t\t\t\t//setting of the value and color of each cell\t\task cell_shape {\t\t\tval &lt;- results_shape[self];\t\t\tfloat val_col &lt;- 255 * (val - min_val) / (max_val - min_val);\t\t\tcolor &lt;- rgb(val_col,0,0);\t\t}\t\t\t\t//same computation, but in this case, we consider only the centroid (location) of the cell for the computation of the distance\t\tmap&lt;point, float&gt; results_location &lt;- map&lt;point, float&gt;(IDW(cell_location collect each.location, pts, power));\t\t\t\t\task cell_location {\t\t\tval &lt;- results_location[self.location];\t\t\tfloat val_col &lt;- 255 * (val - min_val) / (max_val - min_val);\t\t\tcolor &lt;- rgb(val_col,0,0);\t\t}\t}}//cells where the distance is based on the shape of the cell (min distance between the rectangle and the points)grid cell_shape width: nb_columns height: nb_rows {\tfloat val;}//cells where the distance is based on the centroid of the cell (distance between the centroid and the points)grid cell_location width: nb_columns height: nb_rows {\tfloat val;}experiment spatialinterpolation type: gui {\tparameter \"nb of columns\" var: nb_columns;\tparameter \"nb of rows\" var: nb_rows;\tparameter \"power parameter\" var: power;\toutput {\t\tdisplay map_shape {\t\t\tgrid cell_shape;\t\t\tgraphics \"points\" {\t\t\t\tloop pt over: pts.keys {\t\t\t\t\tfloat val &lt;- pts[pt];\t\t\t\t\tfloat val_col &lt;- 255 * (val - min_val) / (max_val - min_val);\t\t\t\t\tdraw circle(1) at: pt color: rgb(val_col,0,0) border: #white;\t\t\t\t}\t\t\t}\t\t}\t\tdisplay map_location {\t\t\tgrid cell_location;\t\t\tgraphics \"points\" {\t\t\t\tloop pt over: pts.keys {\t\t\t\t\tfloat val &lt;- pts[pt];\t\t\t\t\tfloat val_col &lt;- 255 * (val - min_val) / (max_val - min_val);\t\t\t\t\tdraw circle(1) at: pt color: rgb(val_col,0,0) border: #white;\t\t\t\t}\t\t\t}\t\t}\t}}",
        "url":"/wiki/Spatial-Operators-spatialinterpolation.html"
      }
      ,
    
      "wiki-spatial-operators-html": {
        "title": "Spatial Operators",
        "content": "Spatial OperatorsThis sub-section is composed of the following models :      Discretization of Topology        Spatial Operators        Spatial Interpolation        Spatial Operators  ",
        "url":"/wiki/Spatial-Operators.html"
      }
      ,
    
      "wiki-speciesbuiltin-html": {
        "title": "Built-in Species",
        "content": "Built-in Species This file is automatically generated from java files. Do Not Edit It. It is possible to use in the models a set of built-in agents. These agents allow to directly use some advance features like clustering, multi-criteria analysis, etc. The creation of these agents are similar as for other kinds of agents:create species: my_built_in_agent returns: the_agent;So, for instance, to be able to use clustering techniques in the model:create cluster_builder returns: clusterer;The list of available built-in agents in GAMA is:  cluster_builder: allows to use clustering techniques on a set of agents.  multicriteria_analyzer: allows to use multi-criteria analysis methods.Top of the pageTable of ContentsagentActionsinit  returns: unknownstep  returns: unknownTop of the pageAgentDBActionsclose  returns: unknownconnect  returns: unknown  → params (map): Connection parametersexecuteUpdate  returns: int  → updateComm (string): SQL commands such as Create, Update, Delete, Drop with question mark  → values (list): List of values that are used to replace question markgetParameter  returns: unknownhelloWorld  returns: unknowninsert  returns: int  → into (string): Table name  → columns (list): List of column name of table  → values (list): List of values that are used to insert into table. Columns and values must have same sizeisConnected  returns: boolselect  returns: list  → select (string): select string  → values (list): List of values that are used to replace question markssetParameter  returns: unknown  → params (map): Connection parameterstestConnection  returns: bool  → params (map): Connection parameterstimeStamp  returns: floatTop of the pagebase_edgeActionsTop of the pageexperimentActionsTop of the pagegraph_edgeActionsTop of the pagegraph_nodeActionsrelated_to  returns: bool  → other (agent):Top of the pagemodelActionshaltAllows to stop the current simulation so that cannot be continued after. All the behaviors and updates are stopped.  returns: unknownpauseAllows to pause the current simulation ACTUALLY EXPERIMENT FOR THE MOMENT. It can be set to continue with the manual intervention of the user.  returns: unknownTop of the pagemulticriteria_analyzerActionselectre_DM  returns: intevidence_theory_DM  returns: intpromethee_DM  returns: intweighted_means_DM  returns: intTop of the pagePhysical3DWorldActionscomputeForces  returns: unknownTop of the page",
        "url":"/wiki/SpeciesBuiltIn.html"
      }
      ,
    
      "wiki-startwithgaml-html": {
        "title": "Start with GAML",
        "content": "Start with GAMLIn this part, we will present you some basic concepts of GAML that will help you a lot for the next pages.You will first learn how to organize a standard model, then you will learn about some basis about GAML, such as how to declare a variable, how to use the basic operators, how to write a conditional structure or a loop, how to manipulate containers and how to generate random values.",
        "url":"/wiki/StartWithGAML.html"
      }
      ,
    
      "wiki-statements-html": {
        "title": "Statements",
        "content": "StatementsThis file is automatically generated from java files. Do Not Edit It.Table of Contents=, action, add, agents, annealing, ask, aspect, assert, benchmark, break, camera, capture, chart, conscious_contagion, create, data, datalist, default, diffuse, display, display_grid, display_population, do, draw, else, emotional_contagion, enter, equation, error, event, exhaustive, exit, experiment, export, focus, focus_on, genetic, graphics, highlight, hill_climbing, if, image, inspect, let, light, loop, match, migrate, monitor, output, output_file, overlay, parameter, perceive, permanent, plan, put, reactive_tabu, reflex, release, remove, return, rule, run, save, save_batch, set, setup, simulate, socialize, solve, species, state, status, switch, tabu, task, test, trace, transition, unconscious_contagion, user_command, user_init, user_input, user_panel, using, Variable_container, Variable_number, Variable_regular, warn, write,Statements by kinds  Batch method          annealing,  exhaustive,  genetic,  hill_climbing,  reactive_tabu,  save_batch,  tabu,        Behavior          aspect,  plan,  reflex,  state,  task,  test,  user_init,  user_panel,        Experiment          experiment,        Layer          agents,  camera,  chart,  display_grid,  display_population,  event,  graphics,  image,  light,  overlay,        Output          display,  inspect,  monitor,  output,  output_file,  permanent,        Parameter          parameter,        Sequence of statements or action          action,  ask,  benchmark,  capture,  create,  default,  else,  enter,  equation,  exit,  if,  loop,  match,  migrate,  perceive,  release,  run,  setup,  switch,  trace,  transition,  user_command,  using,        Single statement          =,  add,  assert,  break,  conscious_contagion,  data,  datalist,  diffuse,  do,  draw,  emotional_contagion,  error,  export,  focus,  focus_on,  highlight,  let,  put,  remove,  return,  rule,  save,  set,  simulate,  socialize,  solve,  status,  unconscious_contagion,  user_input,  warn,  write,        Species          species,        Variable (container)          Variable_container,        Variable (number)          Variable_number,        Variable (regular)          Variable_regular,      Statements by embedment  Behavior          add, ask, benchmark, capture, conscious_contagion, create, diffuse, do, emotional_contagion, error, focus, focus_on, highlight, if, inspect, let, loop, migrate, put, release, remove, return, run, save, set, simulate, socialize, solve, status, switch, trace, transition, unconscious_contagion, using, warn, write,        Environment          species,        Experiment          action, annealing, exhaustive, export, genetic, hill_climbing, output, parameter, permanent, reactive_tabu, reflex, save_batch, setup, simulate, state, tabu, task, test, user_command, user_init, user_panel, Variable_container, Variable_number, Variable_regular,        Layer          add, benchmark, draw, error, focus_on, highlight, if, let, loop, put, remove, set, status, switch, trace, using, warn, write,        Model          action, aspect, equation, experiment, output, perceive, plan, reflex, rule, run, setup, species, state, task, test, user_command, user_init, user_panel, Variable_container, Variable_number, Variable_regular,        Sequence of statements or action          add, ask, benchmark, break, capture, conscious_contagion, create, data, datalist, diffuse, do, draw, emotional_contagion, error, focus, focus_on, highlight, if, inspect, let, loop, migrate, put, release, remove, return, save, set, simulate, socialize, solve, status, switch, trace, transition, unconscious_contagion, using, warn, write,        Single statement          run,        Species          action, aspect, equation, perceive, plan, reflex, rule, run, setup, simulate, species, state, task, test, user_command, user_init, user_panel, Variable_container, Variable_number, Variable_regular,        action          return,        aspect          draw,        chart          add, ask, data, datalist, do, put, remove, set, simulate, using,        display          agents, camera, chart, display_grid, display_population, event, graphics, image, light, overlay,        display_population          display_population,        equation          =,        fsm          state, user_panel,        if          else,        output          display, inspect, monitor, output_file,        permanent          display, inspect, monitor, output_file,        probabilistic_tasks          task,        sorted_tasks          task,        state          enter, exit,        switch          default, match,        test          assert,        user_command          user_input,        user_first          user_panel,        user_init          user_panel,        user_last          user_panel,        user_only          user_panel,        user_panel          user_command,        weighted_tasks          task,      General syntaxA statement represents either a declaration or an imperative command. It consists in a keyword, followed by specific facets, some of them mandatory (in bold), some of them optional. One of the facet names can be omitted (the one denoted as omissible). It has to be the first one.statement_keyword expression1 facet2: expression2 ... ;orstatement_keyword facet1: expression1 facet2: expression2 ...;If the statement encloses other statements, it is called a sequence statement, and its sub-statements (either sequence statements or single statements) are declared between curly brackets, as in:statement_keyword1 expression1 facet2: expression2... { // a sequence statement     statement_keyword2 expression1 facet2: expression2...;  // a single statement     statement_keyword3 expression1 facet2: expression2...;}=Facets  right (float), (omissible) : the right part of the equation (it is mandatory that it can be evaluated as a float  left (any type): the left part of the equation (it should be a variable or a call to the diff() or diff2() operators)DefinitionAllows to implement an equation in the form function(n, t) = expression. The left function is only here as a placeholder for enabling a simpler syntax and grabbing the variable as its left member.Usages  The syntax of the = statement is a bit different from the other statements. It has to be used as follows (in an equation):float t;float S;float I;equation SI {    diff(S,t) = (- 0.3 * S * I / 100);   diff(I,t) = (0.3 * S * I / 100);}   See also: equation, solve,Embedments  The = statement is of type: Single statement  The = statement can be embedded into: equation,  The = statement embeds statements:actionFacets  name (an identifier), (omissible) : identifier of the action  index (a datatype identifier): if the action returns a map, the type of its keys  of (a datatype identifier): if the action returns a container, the type of its elements  type (a datatype identifier): the action returned type  virtual (boolean): whether the action is virtual (defined without a set of instructions) (false by default)DefinitionAllows to define in a species, model or experiment a new action that can be called elsewhere.Usages  The simplest syntax to define an action that does not take any parameter and does not return anything is:action simple_action {   // [set of statements]}  If the action needs some parameters, they can be specified betwee, braquets after the identifier of the action:action action_parameters(int i, string s){   // [set of statements using i and s]}  If the action returns any value, the returned type should be used instead of the “action” keyword. A return statement inside the body of the action statement is mandatory.int action_return_val(int i, string s){   // [set of statements using i and s]   return i + i;}  If virtual: is true, then the action is abstract, which means that the action is defined without body. A species containing at least one abstract action is abstract. Agents of this species cannot be created. The common use of an abstract action is to define an action that can be used by all its sub-species, which should redefine all abstract actions and implements its body.species parent_species {   int virtual_action(int i, string s);}species children parent: parent_species {   int virtual_action(int i, string s) {      return i + i;   }}  See also: do,Embedments  The action statement is of type: Sequence of statements or action  The action statement can be embedded into: Species, Experiment, Model,  The action statement embeds statements: return,addFacets  to (any type in [container, species, agent, geometry]): an expression that evaluates to a container  item (any type), (omissible) : any expression to add in the container  all (any type): Allows to either pass a container so as to add all its element, or ‘true’, if the item to add is already a container.  at (any type): position in the container of added element  edge (any type): a pair that will be added to a graph as an edge (if nodes do not exist, they are also added)  node (any type): an expression that will be added to a graph as a node.  vertex (any type):  weight (float):DefinitionAllows to add, i.e. to insert, a new element in a container (a list, matrix, map, …).Incorrect use: The addition of a new element at a position out of the bounds of the container will produce a warning and let the container unmodified. If all: is specified, it has no effect if its argument is not a container, or if its argument is ‘true’ and the item to add is not a container. In that latter caseUsages  The new element can be added either at the end of the container or at a particular position.add expr to: expr_container;    // Add at the endadd expr at: expr to: expr_container;   // Add at position expr  Case of a list, the expression in the facet at: should be an integer.list&lt;int&gt; workingList &lt;- [];add 0 at: 0 to: workingList ; \t// workingList equals [0]add 10 at: 0 to: workingList ; \t// workingList equals [10,0]add 20 at: 2 to: workingList ; \t// workingList equals [10,0,20]add 50 to: workingList; \t// workingList equals [10,0,20,50]add [60,70] all: true to: workingList; \t// workingList equals [10,0,20,50,60,70]  Case of a map: As a map is basically a list of pairs key::value, we can also use the add statement on it. It is important to note that the behavior of the statement is slightly different, in particular in the use of the at facet, which denotes the key of the pair.map&lt;string,string&gt; workingMap &lt;- [];add \"val1\" at: \"x\" to: workingMap; \t// workingMap equals [\"x\"::\"val1\"]  If the at facet is omitted, a pair expr_item::expr_item will be added to the map. An important exception is the case where the expr_item is a pair: in this case the pair is added.add \"val2\" to: workingMap; \t// workingMap equals [\"x\"::\"val1\", \"val2\"::\"val2\"]add \"5\"::\"val4\" to: workingMap;  \t// workingMap equals [\"x\"::\"val1\", \"val2\"::\"val2\", \"5\"::\"val4\"]  Notice that, as the key should be unique, the addition of an item at an existing position (i.e. existing key) will only modify the value associated with the given key.add \"val3\" at: \"x\" to: workingMap; \t// workingMap equals [\"x\"::\"val3\", \"val2\"::\"val2\", \"5\"::\"val4\"]  On a map, the all facet will add all value of a container  in the map (so as pair val_cont::val_cont)add [\"val4\",\"val5\"] all: true at: \"x\" to: workingMap; \t// workingMap equals [\"x\"::\"val3\", \"val2\"::\"val2\", \"5\"::\"val4\",\"val4\"::\"val4\",\"val5\"::\"val5\"]  In case of a graph, we can use the facets node, edge and weight to add a node, an edge or weights to the graph. However, these facets are now considered as deprecated, and it is advised to use the various edge(), node(), edges(), nodes() operators, which can build the correct objects to add to the graphgraph g &lt;- as_edge_graph([{1,5}::{12,45}]);add edge: {1,5}::{2,3} to: g;list var &lt;- g.vertices; \t// var equals [{1,5},{12,45},{2,3}]list var &lt;- g.edges; \t// var equals [polyline({1.0,5.0}::{12.0,45.0}),polyline({1.0,5.0}::{2.0,3.0})]add node: {5,5} to: g;list var &lt;- g.vertices; \t// var equals [{1.0,5.0},{12.0,45.0},{2.0,3.0},{5.0,5.0}]list var &lt;- g.edges; \t// var equals [polyline({1.0,5.0}::{12.0,45.0}),polyline({1.0,5.0}::{2.0,3.0})]  Case of a matrix: this statement can not be used on matrix. Please refer to the statement put.  See also: put, remove,Embedments  The add statement is of type: Single statement  The add statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer,  The add statement embeds statements:agentsFacets  value (container): the set of agents to display  name (a label), (omissible) : Human readable title of the layer  aspect (an identifier): the name of the aspect that should be used to display the species  fading (boolean): Used in conjunction with ‘trace:’, allows to apply a fading effect to the previous traces. Default is false  focus (agent): the agent on which the camera will be focused (it is dynamically computed)  position (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.  refresh (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, useful in case of agents that do not move)  selectable (boolean): Indicates whether the agents present on this layer are selectable by the user. Default is true  size (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates &gt; 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in ‘position’, an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions  trace (any type in [boolean, int]): Allows to aggregate the visualization of agents at each timestep on the display. Default is false. If set to an int value, only the last n-th steps will be visualized. If set to true, no limit of timesteps is applied.  transparency (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency)Definitionagents allows the modeler to display only the agents that fulfill a given condition.Usages  The general syntax is:display my_display {   agents layer_name value: expression [additional options];}  For instance, in a segregation model, agents will only display unhappy agents:display Segregation {   agents agentDisappear value: people as list where (each.is_happy = false) aspect: with_group_color;}  See also: display, chart, event, graphics, display_grid, image, overlay, display_population,Embedments  The agents statement is of type: Layer  The agents statement can be embedded into: display,  The agents statement embeds statements:annealingFacets  name (an identifier), (omissible) :  aggregation (a label), takes values in: {min, max}: the agregation method  maximize (float): the value the algorithm tries to maximize  minimize (float): the value the algorithm tries to minimize  nb_iter_cst_temp (int): number of iterations per level of temperature  temp_decrease (float): temperature decrease coefficient  temp_end (float): final temperature  temp_init (float): initial temperatureDefinitionThis algorithm is an implementation of the Simulated Annealing algorithm. See the wikipedia article and [batch161 the batch dedicated page].Usages  As other batch methods, the basic syntax of the annealing statement uses method annealing instead of the expected annealing name: id :method annealing [facet: value];  For example:method annealing temp_init: 100  temp_end: 1 temp_decrease: 0.5 nb_iter_cst_temp: 5 maximize: food_gathered;Embedments  The annealing statement is of type: Batch method  The annealing statement can be embedded into: Experiment,  The annealing statement embeds statements:askFacets  target (any type in [container, agent]), (omissible) : an expression that evaluates to an agent or a list of agents  as (species): an expression that evaluates to a species  parallel (any type in [boolean, int]): (experimental) setting this facet to ‘true’ will allow ‘ask’ to use concurrency when traversing the targets; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet is false by default.DefinitionAllows an agent, the sender agent (that can be the [Sections161#global world agent]), to ask another (or other) agent(s) to perform a set of statements. If the value of the target facet is nil or empty, the statement is ignored.Usages  Ask  a set of receiver agents, stored in a container, to perform a block of statements. The block is evaluated in the context of the agents’ speciesask ${receiver_agents} {     ${cursor}}  Ask  one agent to perform a block of statements. The block is evaluated in the context of the agent’s speciesask ${one_agent} {     ${cursor}}  If the species of the receiver agent(s) cannot be determined, it is possible to force it using the as facet. An error is thrown if an agent is not a direct or undirect instance of this speciesask${receiver_agent(s)} as: ${a_species_expression} {     ${cursor}}  To ask a set of agents to do something only if they belong to a given species, the of_species operator can be used. If none of the agents belong to the species, nothing happensask ${receiver_agents} of_species ${species_name} {     ${cursor}}  Any statement can be declared in the block statements. All the statements will be evaluated in the context of the receiver agent(s), as if they were defined in their species, which means that an expression like self will represent the receiver agent and not the sender. If the sender needs to refer to itself, some of its own attributes (or temporary variables) within the block statements, it has to use the keyword myself.species animal {    float energy &lt;- rnd (1000) min: 0.0 {    reflex when: energy &gt; 500 { // executed when the energy is above the given threshold         list&lt;animal&gt; others &lt;- (animal at_distance 5); // find all the neighboring animals in a radius of 5 meters         float shared_energy  &lt;- (energy - 500) / length (others); // compute the amount of energy to share with each of them         ask others { // no need to cast, since others has already been filtered to only include animals              if (energy &lt; 500) { // refers to the energy of each animal in others                   energy &lt;- energy + myself.shared_energy; // increases the energy of each animal                   myself.energy &lt;- myself.energy - myself.shared_energy; // decreases the energy of the sender              }         }    }}  If the species of the receiver agent cannot be determined, it is possible to force it by casting the agent. Nothing happens if the agent cannot be casted to this speciesEmbedments  The ask statement is of type: Sequence of statements or action  The ask statement can be embedded into: chart, Behavior, Sequence of statements or action,  The ask statement embeds statements:aspectFacets  name (an identifier), (omissible) : identifier of the aspect (it can be used in a display to identify which aspect should be used for the given species). Two special names can also be used: ‘default’ will allow this aspect to be used as a replacement for the default aspect defined in preferences; ‘highlighted’ will allow the aspect to be used when the agent is highlighted as a replacement for the default (application of a color)DefinitionAspect statement is used to define a way to draw the current agent. Several aspects can be defined in one species. It can use attributes to customize each agent’s aspect. The aspect is evaluate for each agent each time it has to be displayed.Usages  An example of use of the aspect statement:species one_species {\tint a &lt;- rnd(10);\taspect aspect1 {\t\tif(a mod 2 = 0) { draw circle(a);}\t\telse {draw square(a);}\t\tdraw text: \"a= \" + a color: #black size: 5;\t}}Embedments  The aspect statement is of type: Behavior  The aspect statement can be embedded into: Species, Model,  The aspect statement embeds statements: draw,assertFacets  value (any type), (omissible) : the value that is evaluated and compared to other facets  equals (any type): an expression, assert tests whether the value is equals to this expression  is_not (any type): an expression, assert tests whether the value is not equals to this expression  raises (an identifier): “error” or “warning”, used in testing what raises the evaluation of the value: expressionDefinitionAllows to check whether the evaluation of a given expression fulfills a given condition. If it is not fulfilled, an exception is raised.Usages  if the equals: facet is used, the equality between the evaluation of expressions in the value: and in the equals: facets is testedassert (2+2) equals: 4;  if the is_not: facet is used, the inequality between the evaluation of expressions in the value: and in the equals: facets is testedassert self is_not: nil;  if the raises: facet is used with either “warning” or “error”, the statement tests whether the evaluation of the value: expression raises an error (resp. a warning)int z &lt;- 0;assert (3/z) raises: \"error\";  See also: test, setup,Embedments  The assert statement is of type: Single statement  The assert statement can be embedded into: test,  The assert statement embeds statements:benchmarkFacets  message (any type), (omissible) : A message to display alongside the results. Should concisely describe the contents of the benchmark  repeat (int): An int expression describing how many executions of the block must be handled. The output in this case will return the min, max and average durationsDefinitionDisplays in the console the duration in ms of the execution of the statements included in the block. It is possible to indicate, with the ‘repeat’ facet, how many times the sequence should be runUsagesEmbedments  The benchmark statement is of type: Sequence of statements or action  The benchmark statement can be embedded into: Behavior, Sequence of statements or action, Layer,  The benchmark statement embeds statements:breakFacetsDefinitionbreak allows to interrupt the current sequence of statements.UsagesEmbedments  The break statement is of type: Single statement  The break statement can be embedded into: Sequence of statements or action,  The break statement embeds statements:cameraFacets  name (string), (omissible) : The name of the camera  location (point): The location of the camera in the world  look_at (point): The location that the camera is looking  up_vector (point): The up-vector of the camera.Definitioncamera allows the modeler to define a camera. The display will then be able to choose among the camera defined (either within this statement or globally in GAMA) in a dynamic way.Usages  See also: display, agents, chart, event, graphics, display_grid, image, display_population,Embedments  The camera statement is of type: Layer  The camera statement can be embedded into: display,  The camera statement embeds statements:captureFacets  target (any type in [agent, container]), (omissible) : an expression that is evaluated as an agent or a list of the agent to be captured  as (species): the species that the captured agent(s) will become, this is a micro-species of the calling agent’s species  returns (a new identifier): a list of the newly captured agent(s)DefinitionAllows an agent to capture other agent(s) as its micro-agent(s).Usages  The preliminary for an agent A to capture an agent B as its micro-agent is that the A’s species must defined a micro-species which is a sub-species of B’s species (cf. [Species161#Nesting_species Nesting species]).species A {...}species B {...   species C parent: A {   ...   }...}  To capture all “A” agents as “C” agents, we can ask an “B” agent to execute the following statement:capture list(B) as: C;  Deprecated writing:capture target: list (B) as: C;  See also: release,Embedments  The capture statement is of type: Sequence of statements or action  The capture statement can be embedded into: Behavior, Sequence of statements or action,  The capture statement embeds statements:chartFacets  name (a label), (omissible) : the identifier of the chart layer  axes (rgb): the axis color  background (rgb): the background color  color (rgb): Text color  gap (float): minimum gap between bars (in proportion)  label_font (string): Label font face  label_font_size (int): Label font size  label_font_style (an identifier), takes values in: {plain, bold, italic}: the style used to display labels  legend_font (string): Legend font face  legend_font_size (int): Legend font size  legend_font_style (an identifier), takes values in: {plain, bold, italic}: the style used to display legend  memorize (boolean): Whether or not to keep the values in memory (in order to produce a csv file, for instance). The default value, true, can also be changed in the preferences  position (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.  reverse_axes (boolean): reverse X and Y axis (for example to get horizental bar charts  series_label_position (an identifier), takes values in: {default, none, legend, onchart, yaxis, xaxis}: Position of the Series names: default (best guess), none, legend, onchart, xaxis (for category plots) or yaxis (uses the first serie name).  size (point): the layer resize factor: {1,1} refers to the original size whereas {0.5,0.5} divides by 2 the height and the width of the layer. In case of a 3D layer, a 3D point can be used (note that {1,1} is equivalent to {1,1,0}, so a resize of a layer containing 3D objects with a 2D points will remove the elevation)  style (an identifier), takes values in: {line, whisker, area, bar, dot, step, spline, stack, 3d, ring, exploded, default}: The sub-style style, also default style for the series.  tick_font (string): Tick font face  tick_font_size (int): Tick font size  tick_font_style (an identifier), takes values in: {plain, bold, italic}: the style used to display ticks  title_font (string): Title font face  title_font_size (int): Title font size  title_font_style (an identifier), takes values in: {plain, bold, italic}: the style used to display titles  type (an identifier), takes values in: {xy, scatter, histogram, series, pie, radar, heatmap, box_whisker}: the type of chart. It could be histogram, series, xy, pie, radar, heatmap or box whisker. The difference between series and xy is that the former adds an implicit x-axis that refers to the numbers of cycles, while the latter considers the first declaration of data to be its x-axis.  x_label (string): the title for the X axis  x_range (any type in [float, int, point, list]): range of the x-axis. Can be a number (which will set the axis total range) or a point (which will set the min and max of the axis).  x_serie (any type in [list, float, int]): for series charts, change the default common x serie (simulation cycle) for an other value (list or numerical).  x_serie_labels (any type in [list, float, int, a label]): change the default common x series labels (replace x value or categories) for an other value (string or numerical).  x_tick_unit (float): the tick unit for the y-axis (distance between horyzontal lines and values on the left of the axis).  y_label (string): the title for the Y axis  y_range (any type in [float, int, point, list]): range of the y-axis. Can be a number (which will set the axis total range) or a point (which will set the min and max of the axis).  y_serie_labels (any type in [list, float, int, a label]): for heatmaps/3d charts, change the default y serie for an other value (string or numerical in a list or cumulative).  y_tick_unit (float): the tick unit for the x-axis (distance between vertical lines and values bellow the axis).Definitionchart allows modeler to display a chart: this enables to display specific values of the model at each iteration. GAMA can display various chart types: time series (series), pie charts (pie) and histograms (histogram).Usages  The general syntax is:display chart_display {   chart \"chart name\" type: series [additional options] {      [Set of data, datalists statements]   }}  See also: display, agents, event, graphics, display_grid, image, overlay, quadtree, display_population, text,Embedments  The chart statement is of type: Layer  The chart statement can be embedded into: display,  The chart statement embeds statements: add,  ask,  data,  datalist,  do,  put,  remove,  set,  simulate,  using,conscious_contagionFacets  emotion_created (546706): the emotion that will be created with the contagion  emotion_detected (546706): the emotion that will start the contagion  name (an identifier), (omissible) : the identifier of the unconscious contagion  charisma (float): The charisma value of the perceived agent (between 0 and 1)  receptivity (float): The receptivity value of the current agent (between 0 and 1)  threshold (float): The threshold value to make the contagion  when (boolean): A boolean value to get the emotion only with a certain conditionDefinitionenables to directly add an emotion of a perceived specie if the perceived agent ges a patricular emotion.Usages  Other examples of use:    conscious_contagion emotion_detected:fear emotion_created:fearConfirmed;conscious_contagion emotion_detected:fear emotion_created:fearConfirmed charisma: 0.5 receptivity: 0.5;      Embedments  The conscious_contagion statement is of type: Single statement  The conscious_contagion statement can be embedded into: Behavior, Sequence of statements or action,  The conscious_contagion statement embeds statements:createFacets  species (any type in [species, agent]), (omissible) : an expression that evaluates to a species, the species of the agents to be created. In the case of simulations, the name ‘simulation’, which represents the current instance of simulation, can also be used as a proxy to their species  as (species):  from (any type): an expression that evaluates to a localized entity, a list of localized entities, a string (the path of a file), a file (shapefile, a .csv, a .asc or a OSM file) or a container returned by a request to a database  header (boolean): an expression that evaluates to a boolean, when creating agents from csv file, specify whether the file header is loaded  number (int): an expression that evaluates to an int, the number of created agents  returns (a new identifier): a new temporary variable name containing the list of created agents (a list, even if only one agent has been created)  with (map): an expression that evaluates to a map, for each pair the key is a species attribute and the value the assigned valueDefinitionAllows an agent to create number agents of species species, to create agents of species species from a shapefile or to create agents of species species from one or several localized entities (discretization of the localized entity geometries).Usages  Its simple syntax to create an_int agents of species a_species is:create a_species number: an_int;create species_of(self) number: 5 returns: list5Agents;5  In GAML modelers can create agents of species a_species  (with two attributes type and nature with types corresponding to the types of the shapefile attributes) from a shapefile the_shapefile` while reading attributes ‘TYPE_OCC’ and ‘NATURE’ of the shapefile. One agent will be created by object contained in the shapefile:create a_species from: the_shapefile with: [type:: read('TYPE_OCC'), nature::read('NATURE')];  In order to create agents from a .csv file, facet header can be used to specified whether we can use columns header:create toto from: \"toto.csv\" header: true with:[att1::read(\"NAME\"), att2::read(\"TYPE\")];orcreate toto from: \"toto.csv\" with:[att1::read(0), att2::read(1)]; //with read(int), the index of the column  Similarly to the creation from shapefile, modelers can create agents from a set of geometries. In this case, one agent per geometry will be created (with the geometry as shape)create species_of(self) from: [square(4),circle(4)]; \t// 2 agents have been created, with shapes respectively square(4) and circle(4)  Created agents are initialized following the rules of their species. If one wants to refer to them after the statement is executed, the returns keyword has to be defined: the agents created will then be referred to by the temporary variable it declares. For instance, the following statement creates 0 to 4 agents of the same species as the sender, and puts them in the temporary variable children for later use.create species (self) number: rnd (4) returns: children;ask children {        // ...}  If one wants to specify a special initialization sequence for the agents created, create provides the same possibilities as ask. This extended syntax is:create a_species number: an_int {     [statements]}  The same rules as in ask apply. The only difference is that, for the agents created, the assignments of variables will bypass the initialization defined in species. For instance:create species(self) number: rnd (4) returns: children {     set location &lt;- myself.location + {rnd (2), rnd (2)}; // tells the children to be initially located close to me     set parent &lt;- myself; // tells the children that their parent is me (provided the variable parent is declared in this species) }  Desprecated uses:// Simple syntaxcreate species: a_species number: an_int;  If number equals 0 or species is not a species, the statement is ignored.Embedments  The create statement is of type: Sequence of statements or action  The create statement can be embedded into: Behavior, Sequence of statements or action,  The create statement embeds statements:dataFacets  legend (string), (omissible) :  value (any type in [float, point, list]):  accumulate_values (boolean): Force to replace values at each step (false) or accumulate with previous steps (true)  color (any type in [rgb, list]): color of the serie, for heatmap can be a list to specify [minColor,maxColor] or [minColor,medColor,maxColor]  fill (boolean): Marker filled (true) or not (false)  line_visible (boolean): Line visible or not  marker (boolean): marker visible or not  marker_shape (an identifier), takes values in: {marker_empty, marker_square, marker_circle, marker_up_triangle, marker_diamond, marker_hor_rectangle, marker_down_triangle, marker_hor_ellipse, marker_right_triangle, marker_vert_rectangle, marker_left_triangle}: Shape of the marker  marker_size (float): Size in pixels of the marker  style (an identifier), takes values in: {line, whisker, area, bar, dot, step, spline, stack, 3d, ring, exploded}: Style for the serie (if not the default one sepecified on chart statement)  thickness (float): The thickness of the lines to draw  x_err_values (any type in [float, list]): the X Error bar values to display. Has to be a List. Each element can be a number or a list with two values (low and high value)  y_err_values (any type in [float, list]): the Y Error bar values to display. Has to be a List. Each element can be a number or a list with two values (low and high value)  y_minmax_values (list): the Y MinMax bar values to display (BW charts). Has to be a List. Each element can be a number or a list with two values (low and high value)Embedments  The data statement is of type: Single statement  The data statement can be embedded into: chart, Sequence of statements or action,  The data statement embeds statements:datalistFacets  value (list): the values to display. Has to be a matrix, a list or a List of List. Each element can be a number (series/histogram) or a list with two values (XY chart)  legend (list), (omissible) : the name of the series: a list of strings (can be a variable with dynamic names)  accumulate_values (boolean): Force to replace values at each step (false) or accumulate with previous steps (true)  color (list): list of colors, for heatmaps can be a list of [minColor,maxColor] or [minColor,medColor,maxColor]  fill (boolean): Marker filled (true) or not (false), same for all series.  line_visible (boolean): Line visible or not (same for all series)  marker (boolean): marker visible or not  marker_shape (an identifier), takes values in: {marker_empty, marker_square, marker_circle, marker_up_triangle, marker_diamond, marker_hor_rectangle, marker_down_triangle, marker_hor_ellipse, marker_right_triangle, marker_vert_rectangle, marker_left_triangle}: Shape of the marker. Same one for all series.  marker_size (list): the marker sizes to display. Can be a list of numbers (same size for each marker of the series) or a list of list (different sizes by point)  style (an identifier), takes values in: {line, whisker, area, bar, dot, step, spline, stack, 3d, ring, exploded}: Style for the serie (if not the default one sepecified on chart statement)  x_err_values (list): the X Error bar values to display. Has to be a List. Each element can be a number or a list with two values (low and high value)  y_err_values (list): the Y Error bar values to display. Has to be a List. Each element can be a number or a list with two values (low and high value)  y_minmax_values (list): the Y MinMax bar values to display (BW charts). Has to be a List. Each element can be a number or a list with two values (low and high value)Embedments  The datalist statement is of type: Single statement  The datalist statement can be embedded into: chart, Sequence of statements or action,  The datalist statement embeds statements:defaultFacets  value (any type), (omissible) :DefinitionUsed in a switch match structure, the block prefixed by default is executed only if no other block has matched (otherwise it is not).Usages  See also: switch, match,Embedments  The default statement is of type: Sequence of statements or action  The default statement can be embedded into: switch,  The default statement embeds statements:diffuseFacets  var (an identifier), (omissible) : the variable to be diffused  on (any type in [container, species]): the list of agents (in general cells of a grid), on which the diffusion will occur  avoid_mask (boolean): if true, the value will not be diffused in the masked cells, but will be restitute to the neighboring cells, multiplied by the proportion value (no signal lost). If false, the value will be diffused in the masked cells, but masked cells won’t diffuse the value afterward (lost of signal). (default value : false)  cycle_length (int): the number of diffusion operation applied in one simulation step  mask (matrix): a matrix masking the diffusion (matrix created from a image for example). The cells corresponding to the values smaller than “-1” in the mask matrix will not diffuse, and the other will diffuse.  mat_diffu (matrix): the diffusion matrix (can have any size)  matrix (matrix): the diffusion matrix (“kernel” or “filter” in image processing). Can have any size, as long as dimensions are odd values.  method (an identifier), takes values in: {convolution, dot_product}: the diffusion method  min_value (float): if a value is smaller than this value, it will not be diffused. By default, this value is equal to 0.0. This value cannot be smaller than 0.  propagation (a label), takes values in: {diffusion, gradient}: represents both the way the signal is propagated and the way to treat multiple propagation of the same signal occurring at once from different places. If propagation equals ‘diffusion’, the intensity of a signal is shared between its neighbors with respect to ‘proportion’, ‘variation’ and the number of neighbors of the environment places (4, 6 or 8). I.e., for a given signal S propagated from place P, the value transmitted to its N neighbors is : S’ = (S / N / proportion) - variation. The intensity of S is then diminished by S * proportion on P. In a diffusion, the different signals of the same name see their intensities added to each other on each place. If propagation equals ‘gradient’, the original intensity is not modified, and each neighbors receives the intensity : S / proportion - variation. If multiple propagation occur at once, only the maximum intensity is kept on each place. If ‘propagation’ is not defined, it is assumed that it is equal to ‘diffusion’.  proportion (float): a diffusion rate  radius (int): a diffusion radius (in number of cells from the center)  variation (float): an absolute value to decrease at each neighborsDefinitionThis statements allows a value to diffuse among a species on agents (generally on a grid) depending on a given diffusion matrix.Usages  A basic example of diffusion of the variable phero defined in the species cells, given a diffusion matrix math_diff is:matrix&lt;float&gt; math_diff &lt;- matrix([[1/9,1/9,1/9],[1/9,1/9,1/9],[1/9,1/9,1/9]]);diffuse var: phero on: cells mat_diffu: math_diff;  The diffusion can be masked by obstacles, created from a bitmap image:diffuse var: phero on: cells mat_diffu: math_diff mask: mymask;  A convenient way to have an uniform diffusion in a given radius is (which is equivalent to the above diffusion):diffuse var: phero on: cells proportion: 1/9 radius: 1;Embedments  The diffuse statement is of type: Single statement  The diffuse statement can be embedded into: Behavior, Sequence of statements or action,  The diffuse statement embeds statements:displayFacets  name (a label), (omissible) : the identifier of the display  ambient_light (any type in [int, rgb]): Allows to define the value of the ambient light either using an int (ambient_light:(125)) or a rgb color ((ambient_light:rgb(255,255,255)). default is rgb(127,127,127,255)  autosave (any type in [boolean, point]): Allows to save this display on disk. A value of true/false will save it at a resolution of 500x500. A point can be passed to personalize these dimensions  background (rgb): Allows to fill the background of the display with a specific color  camera_interaction (boolean): If false, the user will not be able to modify the position and the orientation of the camera, and neither using the ROI. Default is true.  camera_lens (int): Allows to define the lens of the camera  camera_look_pos (point): Allows to define the direction of the camera  camera_pos (any type in [point, agent]): Allows to define the position of the camera  camera_up_vector (point): Allows to define the orientation of the camera  diffuse_light (any type in [int, rgb]): Allows to define the value of the diffuse light either using an int (diffuse_light:(125)) or a rgb color ((diffuse_light:rgb(255,255,255)). default is (127,127,127,255)  diffuse_light_pos (point): Allows to define the position of the diffuse light either using an point (diffuse_light_pos:{x,y,z}). default is {world.shape.width/2,world.shape.height/2,world.shape.width*2}  draw_diffuse_light (boolean): Allows to show/hide a representation of the lights. Default is false.  draw_env (boolean): Allows to enable/disable the drawing of the world shape and the ordinate axes. Default can be configured in Preferences  focus (geometry): the geometry (or agent) on which the display will (dynamically) focus  fullscreen (any type in [boolean, int]): Indicates, when using a boolean value, whether or not the display should cover the whole screen (default is false). If an integer is passed, specifies also the screen to use: 0 for the primary monitor, 1 for the secondary one, and so on and so forth. If the monitor is not available, the first one is used  keystone (container): Set the position of the 4 corners of your screen ([topLeft,topRight,botLeft,botRight]), in (x,y) coordinate ( the (0,0) position is the top left corner, while the (1,1) position is the bottom right corner). The default value is : [{0,0},{1,0},{0,1},{1,1}]  light (boolean): Allows to enable/disable the light. Default is true  orthographic_projection (boolean): Allows to enable/disable the orthographic projection. Default can be configured in Preferences  refresh (boolean): Indicates the condition under which this output should be refreshed (default is true)  refresh_every (int): Allows to refresh the display every n time steps (default is 1)  rotate (float): Set the angle for the rotation around the Z axis  scale (any type in [boolean, float]): Allows to display a scale bar in the overlay. Accepts true/false or an unit name  show_fps (boolean): Allows to enable/disable the drawing of the number of frames per second  synchronized (boolean): Indicates whether the display should be directly synchronized with the simulation  type (a label): Allows to use either Java2D (for planar models) or OpenGL (for 3D models) as the rendering subsystem  use_shader (boolean): Under construction…  z_fighting (boolean): Allows to alleviate a problem where agents at the same z would overlap each other in random waysDefinitionA display refers to a independent and mobile part of the interface that can display species, images, texts or charts.Usages  The general syntax is:display my_display [additional options] { ... }  Each display can include different layers (like in a GIS).display gridWithElevationTriangulated type: opengl ambient_light: 100 {\tgrid cell elevation: true triangulation: true;\tspecies people aspect: base;}Embedments  The display statement is of type: Output  The display statement can be embedded into: output, permanent,  The display statement embeds statements: agents,  camera,  chart,  display_grid,  display_population,  event,  graphics,  image,  light,  overlay,display_gridFacets  species (species), (omissible) : the species of the agents in the grid  dem (matrix):  draw_as_dem (boolean):  elevation (any type in [matrix, float, int, boolean]): Allows to specify the elevation of each cell, if any. Can be a matrix of float (provided it has the same size than the grid), an int or float variable of the grid species, or simply true (in which case, the variable called ‘grid_value’ is used to compute the elevation of each cell)  grayscale (boolean): if true, givse a grey value to each polygon depending on its elevation (false by default)  lines (rgb): the color to draw lines (borders of cells)  position (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.  refresh (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, usefull in case of agents that do not move)  selectable (boolean): Indicates whether the agents present on this layer are selectable by the user. Default is true  size (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates &gt; 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in ‘position’, an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions  text (boolean): specify whether the attribute used to compute the elevation is displayed on each cells (false by default)  texture (any type in [boolean, file]): Either file  containing the texture image to be applied on the grid or, if true, the use of the image composed by the colors of the cells. If false, no texture is applied  transparency (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency)  triangulation (boolean): specifies whther the cells will be triangulated: if it is false, they will be displayed as horizontal squares at a given elevation, whereas if it is true, cells will be triangulated and linked to neighbors in order to have a continuous surface (false by default)Definitiondisplay_grid is used using the grid keyword. It allows the modeler to display in an optimized way all cell agents of a grid (i.e. all agents of a species having a grid topology).Usages  The general syntax is:display my_display {   grid ant_grid lines: #black position: { 0.5, 0 } size: {0.5,0.5};}  To display a grid as a DEM:display my_display {    grid cell texture: texture_file text: false triangulation: true elevation: true;}  See also: display, agents, chart, event, graphics, image, overlay, display_population,Embedments  The display_grid statement is of type: Layer  The display_grid statement can be embedded into: display,  The display_grid statement embeds statements:display_populationFacets  species (species), (omissible) : the species to be displayed  aspect (an identifier): the name of the aspect that should be used to display the species  fading (boolean): Used in conjunction with ‘trace:’, allows to apply a fading effect to the previous traces. Default is false  position (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.  refresh (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, usefull in case of agents that do not move)  selectable (boolean): Indicates whether the agents present on this layer are selectable by the user. Default is true  size (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates &gt; 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in ‘position’, an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions  trace (any type in [boolean, int]): Allows to aggregate the visualization of agents at each timestep on the display. Default is false. If set to an int value, only the last n-th steps will be visualized. If set to true, no limit of timesteps is applied.  transparency (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency)DefinitionThe display_population statement is used using the species keyword. It allows modeler to display all the agent of a given species in the current display. In particular, modeler can choose the aspect used to display them.Usages  The general syntax is:display my_display {   species species_name [additional options];}  Species can be superposed on the same plan (be careful with the order, the last one will be above all the others):display my_display {   species agent1 aspect: base;   species agent2 aspect: base;   species agent3 aspect: base;}  Each species layer can be placed at a different z value using the opengl display. position:{0,0,0} means the layer will be placed on the ground and position:{0,0,1} means it will be placed at an height equal to the maximum size of the environment.display my_display type: opengl{   species agent1 aspect: base ;   species agent2 aspect: base position:{0,0,0.5};   species agent3 aspect: base position:{0,0,1};}  See also: display, agents, chart, event, graphics, display_grid, image, overlay,Embedments  The display_population statement is of type: Layer  The display_population statement can be embedded into: display, display_population,  The display_population statement embeds statements: display_population,doFacets  action (an identifier), (omissible) : the name of an action or a primitive  internal_function (any type):  returns (a new identifier): create a new variable and assign to it the result of the action  with (map): a map expression containing the parameters of the actionDefinitionAllows the agent to execute an action or a primitive.  For a list of primitives available in every species, see this [BuiltIn161 page]; for the list of primitives defined by the different skills, see this [Skills161 page]. Finally, see this [Species161 page] to know how to declare custom actions.Usages  The simple syntax (when the action does not expect any argument and the result is not to be kept) is:do name_of_action_or_primitive;  In case the action expects one or more arguments to be passed, they are defined by using facets (enclosed tags or a map are now deprecated):do name_of_action_or_primitive arg1: expression1 arg2: expression2;  In case the result of the action needs to be made available to the agent, the action can be called with the agent calling the action (self when the agent itself calls the action) instead of do; the result should be assigned to a temporary variable:type_returned_by_action result &lt;- self name_of_action_or_primitive [];  In case of an action expecting arguments and returning a value, the following syntax is used:type_returned_by_action result &lt;- self name_of_action_or_primitive [arg1::expression1, arg2::expression2];  Deprecated uses: following uses of the do statement (still accepted) are now deprecated:// Simple syntax: do action: name_of_action_or_primitive;// In case the result of the action needs to be made available to the agent, the `returns` keyword can be defined; the result will then be referred to by the temporary variable declared in this attribute:do name_of_action_or_primitive returns: result;do name_of_action_or_primitive arg1: expression1 arg2: expression2 returns: result;type_returned_by_action result &lt;- name_of_action_or_primitive(self, [arg1::expression1, arg2::expression2]);// In case the result of the action needs to be made available to the agentlet result &lt;- name_of_action_or_primitive(self, []);// In case the action expects one or more arguments to be passed, they can also be defined by using enclosed `arg` statements, or the `with` facet with a map of parameters:do name_of_action_or_primitive with: [arg1::expression1, arg2::expression2];ordo name_of_action_or_primitive {     arg arg1 value: expression1;     arg arg2 value: expression2;     ...}Embedments  The do statement is of type: Single statement  The do statement can be embedded into: chart, Behavior, Sequence of statements or action,  The do statement embeds statements:drawFacets  geometry (any type), (omissible) : any type of data (it can be geometry, image, text)  at (point): location where the shape/text/icon is drawn  begin_arrow (any type in [int, float]): the size of the arrow, located at the beginning of the drawn geometry  bitmap (boolean): Whether to render the text in 3D or not  border (any type in [rgb, boolean]): if used with a color, represents the color of the geometry border. If set to false, expresses that no border should be drawn. If not set, the borders will be drawn using the color of the geometry.  color (any type in [rgb, container]): the color to use to display the object. In case of images, will try to colorize it. You can also pass a list of colors : in that case, each color will be matched to its corresponding vertex.  depth (float): (only if the display type is opengl) Add an artificial depth to the geometry previously defined (a line becomes a plan, a circle becomes a cylinder, a square becomes a cube, a polygon becomes a polyhedron with height equal to the depth value). Note: This only works if the geometry is not a point  empty (boolean): a condition specifying whether the geometry is empty or full  end_arrow (any type in [int, float]): the size of the arrow, located at the end of the drawn geometry  font (any type in [19, string]): the font used to draw the text, if any. Applying this facet to geometries or images has no effect. You can construct here your font with the operator “font”. ex : font:font(“Helvetica”, 20 , #plain)  material (25): Set a particular material to the object (only if you are in the “use_shader” mode).  perspective (boolean): Whether to render the text in perspective or facing the user. Default is true.  rotate (any type in [float, int, pair]): orientation of the shape/text/icon; can be either an int/float (angle) or a pair float::point (angle::rotation axis). The rotation axis, when expressed as an angle, is by defaut {0,0,1}  rounded (boolean): specify whether the geometry have to be rounded (e.g. for squares)  size (any type in [float, point]): size of the object to draw, expressed as a bounding box (width, height, depth). If expressed as a float, represents the size in the three directions.  texture (any type in [string, list, file]): the texture(s) that should be applied to the geometry. Either a path to a file or a list of paths  width (float): The line width to use for drawing this objectDefinitiondraw is used in an aspect block to express how agents of the species will be drawn. It is evaluated each time the agent has to be drawn. It can also be used in the graphics block.Usages  Any kind of geometry as any location can be drawn when displaying an agent (independently of his shape)aspect geometryAspect {\tdraw circle(1.0) empty: !hasFood color: #orange ;}  Image or text can also be drawnaspect arrowAspect {\tdraw \"Current state= \"+state at: location + {-3,1.5} color: #white font: font('Default', 12, #bold) ;\tdraw file(ant_shape_full) rotate: heading at: location size: 5}  Arrows can be drawn with any kind of geometry, using begin_arrow and end_arrow facets, combined with the empty: facet to specify whether it is plain or emptyaspect arrowAspect {\tdraw line([{20, 20}, {40, 40}]) color: #black begin_arrow:5;\tdraw line([{10, 10},{20, 50}, {40, 70}]) color: #green end_arrow: 2 begin_arrow: 2 empty: true;\tdraw square(10) at: {80,20} color: #purple begin_arrow: 2 empty: true;}Embedments  The draw statement is of type: Single statement  The draw statement can be embedded into: aspect, Sequence of statements or action, Layer,  The draw statement embeds statements:elseFacetsDefinitionThis statement cannot be used aloneUsages  See also: if,Embedments  The else statement is of type: Sequence of statements or action  The else statement can be embedded into: if,  The else statement embeds statements:emotional_contagionFacets  emotion_detected (546706): the emotion that will start the contagion  name (an identifier), (omissible) : the identifier of the emotional contagion  charisma (float): The charisma value of the perceived agent (between 0 and 1)  emotion_created (546706): the emotion that will be created with the contagion  receptivity (float): The receptivity value of the current agent (between 0 and 1)  threshold (float): The threshold value to make the contagion  when (boolean): A boolean value to get the emotion only with a certain conditionDefinitionenables to make conscious or unconscious emotional contagionUsages  Other examples of use:    emotional_contagion emotion_detected:fearConfirmed;emotional_contagion emotion_detected:fear emotion_created:fearConfirmed;emotional_contagion emotion_detected:fear emotion_created:fearConfirmed charisma: 0.5 receptivity: 0.5;      Embedments  The emotional_contagion statement is of type: Single statement  The emotional_contagion statement can be embedded into: Behavior, Sequence of statements or action,  The emotional_contagion statement embeds statements:enterFacetsDefinitionIn an FSM architecture, enter introduces a sequence of statements to execute upon entering a state.Usages  In the following example, at the step it enters into the state s_init, the message ‘Enter in s_init’ is displayed followed by the display of the state name:\tstate s_init {\t\tenter { write \"Enter in\" + state; }\t\t\twrite \"Enter in\" + state;\t\t}\t\twrite state;\t}  See also: state, exit, transition,Embedments  The enter statement is of type: Sequence of statements or action  The enter statement can be embedded into: state,  The enter statement embeds statements:equationFacets  name (an identifier), (omissible) : the equation identifier  params (list): the list of parameters used in predefined equation systems  simultaneously (list): a list of species containing a system of equations (all systems will be solved simultaneously)  type (an identifier), takes values in: {SI, SIS, SIR, SIRS, SEIR, LV}: the choice of one among classical models (SI, SIS, SIR, SIRS, SEIR, LV)  vars (list): the list of variables used in predefined equation systemsDefinitionThe equation statement is used to create an equation system from several single equations.Usages  The basic syntax to define an equation system is:float t;float S;float I;equation SI {    diff(S,t) = (- 0.3 * S * I / 100);   diff(I,t) = (0.3 * S * I / 100);}   If the type: facet is used, a predefined equation system is defined using variables vars: and parameters params: in the right order. All possible predefined equation systems are the following ones (see [EquationPresentation161 EquationPresentation161] for precise definition of each classical equation system):equation eqSI type: SI vars: [S,I,t] params: [N,beta];equation eqSIS type: SIS vars: [S,I,t] params: [N,beta,gamma];equation eqSIR type:SIR vars:[S,I,R,t] params:[N,beta,gamma];equation eqSIRS type: SIRS vars: [S,I,R,t] params: [N,beta,gamma,omega,mu];equation eqSEIR type: SEIR vars: [S,E,I,R,t] params: [N,beta,gamma,sigma,mu];equation eqLV type: LV vars: [x,y,t] params: [alpha,beta,delta,gamma] ;  If the simultaneously: facet is used, system of all the agents will be solved simultaneously.  See also: =, solve,Embedments  The equation statement is of type: Sequence of statements or action  The equation statement can be embedded into: Species, Model,  The equation statement embeds statements: =,errorFacets  message (string), (omissible) : the message to display in the error.DefinitionThe statement makes the agent output an error dialog (if the simulation contains a user interface). Otherwise displays the error in the console.Usages  Throwing an errorerror 'This is an error raised by ' + self;Embedments  The error statement is of type: Single statement  The error statement can be embedded into: Behavior, Sequence of statements or action, Layer,  The error statement embeds statements:eventFacets  name (an identifier), (omissible) : the type of event captured: can be  “mouse_up”, “mouse_down”, “mouse_move”, “mouse_exit”, “mouse_enter” or a character  action (26): Either a block of statements to execute in the context of the simulation or the identifier of the action to be executed. This action needs to be defined in ‘global’ or in the current experiment, without any arguments. The location of the mouse in the world can be retrieved in this action with the pseudo-constant #user_location  unused (an identifier), takes values in: {mouse_up, mouse_down, mouse_move, mouse_enter, mouse_exit}: an unused facet that serves only for the purpose of declaring the string valuesDefinitionevent allows to interact with the simulation by capturing mouse or key events and doing an action. This action needs to be defined in ‘global’ or in the current experiment, without any arguments. The location of the mouse in the world can be retrieved in this action with the pseudo-constant #user_locationUsages  The general syntax is:event [event_type] action: myAction;  For instance:global {   // ...    action myAction () {      point loc &lt;- #user_location; // contains the location of the mouse in the world      list&lt;agent&gt; selected_agents &lt;- agents inside (10#m around loc); // contains agents clicked by the event            // code written by modelers   }}experiment Simple type:gui {   display my_display {      event mouse_up action: myAction;   }}  See also: display, agents, chart, graphics, display_grid, image, overlay, display_population,Embedments  The event statement is of type: Layer  The event statement can be embedded into: display,  The event statement embeds statements:exhaustiveFacets  name (an identifier), (omissible) :  aggregation (a label), takes values in: {min, max}: the agregation method  maximize (float): the value the algorithm tries to maximize  minimize (float): the value the algorithm tries to minimizeDefinitionThis is the standard batch method. The exhaustive mode is defined by default when there is no method element present in the batch section. It explores all the combination of parameter values in a sequential way. See [batch161 the batch dedicated page].Usages  As other batch methods, the basic syntax of the exhaustive statement uses method exhaustive instead of the expected exhaustive name: id :method exhaustive [facet: value];  For example:method exhaustive maximize: food_gathered;Embedments  The exhaustive statement is of type: Batch method  The exhaustive statement can be embedded into: Experiment,  The exhaustive statement embeds statements:exitFacetsDefinitionIn an FSM architecture, exit introduces a sequence of statements to execute right before exiting the state.Usages  In the following example, at the state it leaves the state s_init, he will display the message ‘EXIT from s_init’:\tstate s_init initial: true {\t\twrite state;\t\ttransition to: s1 when: (cycle &gt; 2) {\t\t\twrite \"transition s_init -&gt; s1\";\t\t}\t\texit {\t\t\twrite \"EXIT from \"+state;\t\t}\t}  See also: enter, state, transition,Embedments  The exit statement is of type: Sequence of statements or action  The exit statement can be embedded into: state,  The exit statement embeds statements:experimentFacets  name (a label), (omissible) : identifier of the experiment  title (a label):  type (a label), takes values in: {batch, memorize, gui, headless}: the type of the experiment (either ‘gui’ or ‘batch’  control (an identifier):  frequency (int): the execution frequence of the experiment (default value: 1). If frequency: 10, the experiment is executed only each 10 steps.  keep_seed (boolean):  keep_simulations (boolean): In the case of a batch experiment, specifies whether or not the simulations should be kept in memory for further analysis or immediately discarded with only their fitness kept in memory  parallel (any type in [boolean, int]): When set to true, use multiple threads to run its simulations. Setting it to n will set the numbers of threads to use  parent (an identifier): the parent experiment (in case of inheritance between experiments)  repeat (int): In the case of a batch experiment, expresses hom many times the simulations must be repeated  schedules (container): A container of agents (a species, a dynamic list, or a combination of species and containers) , which represents which agents will be actually scheduled when the population is scheduled for execution. For instance, ‘species a schedules: (10 among a)’ will result in a population that schedules only 10 of its own agents every cycle. ‘species b schedules: []’ will prevent the agents of ‘b’ to be scheduled. Note that the scope of agents covered here can be larger than the population, which allows to build complex scheduling controls; for instance, defining ‘global schedules: [] {…} species b schedules: []; species c schedules: b + world; ‘ allows to simulate a model where the agents of b are scheduled first, followed by the world, without even having to create an instance of c.  skills (list):  until (boolean): In the case of a batch experiment, an expression that will be evaluated to know when a simulation should be terminatedEmbedments  The experiment statement is of type: Experiment  The experiment statement can be embedded into: Model,  The experiment statement embeds statements:exportFacets  var (an identifier), (omissible) :  framerate (int):  name (string):Embedments  The export statement is of type: Single statement  The export statement can be embedded into: Experiment,  The export statement embeds statements:focusFacets  name (an identifier), (omissible) : the identifier of the focus  agent_cause (agent): the agentCause value of the created belief (can be nil  expression (any type): an expression that will be the value kept in the belief  lifetime (int): the lifetime value of the created belief  priority (any type in [float, int]): The priority of the created predicate  truth (boolean): the truth value of the created belief  var (any type in [any type, list, container]): the variable of the perceived agent you want to add to your beliefs  when (boolean): A boolean value to focus only with a certain conditionDefinitionenables to directly add a belief from the variable of a perceived specie.Usages  Other examples of use:    focus var:speed /*where speed is a variable from a species that is being perceived*/      Embedments  The focus statement is of type: Single statement  The focus statement can be embedded into: Behavior, Sequence of statements or action,  The focus statement embeds statements:focus_onFacets  value (any type), (omissible) : The agent, list of agents, geometry to focus onDefinitionAllows to focus on the passed parameter in all available displays. Passing ‘nil’ for the parameter will make all screens return to their normal zoomUsages  Focuses on an agent, a geometry, a set of agents, etc…)focus_on my_species(0);Embedments  The focus_on statement is of type: Single statement  The focus_on statement can be embedded into: Behavior, Sequence of statements or action, Layer,  The focus_on statement embeds statements:geneticFacets  name (an identifier), (omissible) :  aggregation (a label), takes values in: {min, max}: the agregation method  crossover_prob (float): crossover probability between two individual solutions  max_gen (int): number of generations  maximize (float): the value the algorithm tries to maximize  minimize (float): the value the algorithm tries to minimize  mutation_prob (float): mutation probability for an individual solution  nb_prelim_gen (int): number of random populations used to build the initial population  pop_dim (int): size of the population (number of individual solutions)DefinitionThis is a simple implementation of Genetic Algorithms (GA). See the wikipedia article and [batch161 the batch dedicated page]. The principle of the GA is to search an optimal solution by applying evolution operators on an initial population of solutions. There are three types of evolution operators: crossover, mutation and selection. Different techniques can be applied for this selection. Most of them are based on the solution quality (fitness).Usages  As other batch methods, the basic syntax of the genetic statement uses method genetic instead of the expected genetic name: id :method genetic [facet: value];  For example:method genetic maximize: food_gathered pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 20; Embedments  The genetic statement is of type: Batch method  The genetic statement can be embedded into: Experiment,  The genetic statement embeds statements:graphicsFacets  name (a label), (omissible) : the human readable title of the graphics  fading (boolean): Used in conjunction with ‘trace:’, allows to apply a fading effect to the previous traces. Default is false  position (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.  refresh (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, usefull in case of agents that do not move)  size (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates &gt; 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in ‘position’, an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions  trace (any type in [boolean, int]): Allows to aggregate the visualization at each timestep on the display. Default is false. If set to an int value, only the last n-th steps will be visualized. If set to true, no limit of timesteps is applied.  transparency (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency)Definitiongraphics allows the modeler to freely draw shapes/geometries/texts without having to define a species. It works exactly like a species [Aspect161 aspect]: the draw statement can be used in the same way.Usages  The general syntax is:display my_display {   graphics \"my new layer\" {      draw circle(5) at: {10,10} color: #red;      draw \"test\" at: {10,10} size: 20 color: #black;   }}  See also: display, agents, chart, event, graphics, display_grid, image, overlay, display_population,Embedments  The graphics statement is of type: Layer  The graphics statement can be embedded into: display,  The graphics statement embeds statements:highlightFacets  value (agent), (omissible) : The agent to hightlight  color (rgb): An optional color to highlight the agent. Note that this color will become the default color for further higlight operationsDefinitionAllows to highlight the agent passed in parameter in all available displays, optionaly setting a color. Passing ‘nil’ for the agent will remove the current highlightUsages  Highlighting an agenthighlight my_species(0) color: #blue;Embedments  The highlight statement is of type: Single statement  The highlight statement can be embedded into: Behavior, Sequence of statements or action, Layer,  The highlight statement embeds statements:hill_climbingFacets  name (an identifier), (omissible) :  aggregation (a label), takes values in: {min, max}: the agregation method  iter_max (int): number of iterations  maximize (float): the value the algorithm tries to maximize  minimize (float): the value the algorithm tries to minimizeDefinitionThis algorithm is an implementation of the Hill Climbing algorithm. See the wikipedia article and [batch161 the batch dedicated page].Usages  As other batch methods, the basic syntax of the hill_climbing statement uses method hill_climbing instead of the expected hill_climbing name: id :method hill_climbing [facet: value];  For example:method hill_climbing iter_max: 50 maximize : food_gathered; Embedments  The hill_climbing statement is of type: Batch method  The hill_climbing statement can be embedded into: Experiment,  The hill_climbing statement embeds statements:ifFacets  condition (boolean), (omissible) : A boolean expression: the condition that is evaluated.DefinitionAllows the agent to execute a sequence of statements if and only if the condition evaluates to true.Usages  The generic syntax is:if bool_expr {    [statements]}  Optionally, the statements to execute when the condition evaluates to false can be defined in a following statement else. The syntax then becomes:if bool_expr {    [statements]}else {    [statements]}string valTrue &lt;- \"\";if true {\tvalTrue &lt;- \"true\";}else {\tvalTrue &lt;- \"false\";} \t// valTrue equals \"true\"string valFalse &lt;- \"\";if false {\tvalFalse &lt;- \"true\";}else {\tvalFalse &lt;- \"false\";} \t// valFalse equals \"false\"  ifs and elses can be imbricated as needed. For instance:if bool_expr {    [statements]}else if bool_expr2 {    [statements]}else {    [statements]}Embedments  The if statement is of type: Sequence of statements or action  The if statement can be embedded into: Behavior, Sequence of statements or action, Layer,  The if statement embeds statements: else,imageFacets  name (any type in [string, file]), (omissible) : Human readable title of the image layer  color (rgb): in the case of a shapefile, this the color used to fill in geometries of the shapefile  file (any type in [string, file]): the name/path of the image (in the case of a raster image)  gis (any type in [file, string]): the name/path of the shape file (to display a shapefile as background, without creating agents from it)  position (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.  refresh (boolean): (openGL only) specify whether the image display is refreshed. (true by default, usefull in case of images that is not modified over the simulation)  size (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates &gt; 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in ‘position’, an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions  transparency (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency)Definitionimage allows modeler to display an image (e.g. as background of a simulation).Usages  The general syntax is:display my_display {   image layer_name file: image_file [additional options];}  For instance, in the case of a bitmap imagedisplay my_display {   image background file:\"../images/my_backgound.jpg\";}  Or in the case of a shapefile:display my_display {   image testGIS gis: \"../includes/building.shp\" color: rgb('blue');}  It is also possible to superpose images on different layers in the same way as for species using opengl display:display my_display {  image image1 file:\"../images/image1.jpg\";  image image2 file:\"../images/image2.jpg\";  image image3 file:\"../images/image3.jpg\" position: {0,0,0.5};}  See also: display, agents, chart, event, graphics, display_grid, overlay, display_population,Embedments  The image statement is of type: Layer  The image statement can be embedded into: display,  The image statement embeds statements:inspectFacets  name (any type), (omissible) : the identifier of the inspector  attributes (list): the list of attributes to inspect  refresh (boolean): Indicates the condition under which this output should be refreshed (default is true)  refresh_every (int): Allows to refresh the inspector every n time steps (default is 1)  type (an identifier), takes values in: {agent, table}: the way to inspect agents: in a table, or a set of inspectors  value (any type): the set of agents to inspect, could be a species, a list of agents or an agentDefinitioninspect (and browse) statements allows modeler to inspect a set of agents, in a table with agents and all their attributes or an agent inspector per agent, depending on the type: chosen. Modeler can choose which attributes to display. When browse is used, type: default value is table, whereas wheninspect is used, type: default value is agent.Usages  An example of syntax is:inspect \"my_inspector\" value: ant attributes: [\"name\", \"location\"];Embedments  The inspect statement is of type: Output  The inspect statement can be embedded into: output, permanent, Behavior, Sequence of statements or action,  The inspect statement embeds statements:letFacets  name (a new identifier), (omissible) :  index (a datatype identifier):  of (a datatype identifier):  type (a datatype identifier):  value (any type):Embedments  The let statement is of type: Single statement  The let statement can be embedded into: Behavior, Sequence of statements or action, Layer,  The let statement embeds statements:lightFacets  id (int), (omissible) : a number from 1 to 7 to specify which light we are using  active (boolean): a boolean expression telling if you want this light to be switch on or not. (default value : true)  color (any type in [int, rgb]): an int / rgb / rgba value to specify the color and the intensity of the light. (default value : (127,127,127,255) ).  direction (point): the direction of the light (only for direction and spot light). (default value : {0.5,0.5,-1})  draw_light (boolean): draw or not the light. (default value : false).  linear_attenuation (float): the linear attenuation of the positionnal light. (default value : 0)  position (point): the position of the light (only for point and spot light). (default value : {0,0,1})  quadratic_attenuation (float): the linear attenuation of the positionnal light. (default value : 0)  spot_angle (float): the angle of the spot light in degree (only for spot light). (default value : 45)  type (a label): the type of light to create. A value among {point, direction, spot}. (default value : direction)  update (boolean): specify if the light has to be updated. (default value : true).Definitionlight allows to define diffusion lights in your 3D display.Usages  The general syntax is:light 1 type:point position:{20,20,20} color:255, linear_attenuation:0.01 quadratic_attenuation:0.0001 draw_light:true update:falselight 2 type:spot position:{20,20,20} direction:{0,0,-1} color:255 spot_angle:25 linear_attenuation:0.01 quadratic_attenuation:0.0001 draw_light:true update:falselight 3 type:point direction:{1,1,-1} color:255 draw_light:true update:false  See also: display,Embedments  The light statement is of type: Layer  The light statement can be embedded into: display,  The light statement embeds statements:loopFacets  name (a new identifier), (omissible) : a temporary variable name  from (int): an int expression  over (any type in [container, point]): a list, point, matrix or map expression  step (int): an int expression  times (int): an int expression  to (int): an int expression  while (boolean): a boolean expressionDefinitionAllows the agent to perform the same set of statements either a fixed number of times, or while a condition is true, or by progressing in a collection of elements or along an interval of integers. Be aware that there are no prevention of infinite loops. As a consequence, open loops should be used with caution, as one agent may block the execution of the whole model.Usages  The basic syntax for repeating a fixed number of times a set of statements is:loop times: an_int_expression {     // [statements]}  The basic syntax for repeating a set of statements while a condition holds is:loop while: a_bool_expression {     // [statements]}  The basic syntax for repeating a set of statements by progressing over a container of a point is:loop a_temp_var over: a_collection_expression {     // [statements]}  The basic syntax for repeating a set of statements while an index iterates over a range of values with a fixed step of 1 is:loop a_temp_var from: int_expression_1 to: int_expression_2 {     // [statements]}  The incrementation step of the index can also be chosen:loop a_temp_var from: int_expression_1 to: int_expression_2 step: int_expression3 {     // [statements]}  In these latter three cases, the name facet designates the name of a temporary variable, whose scope is the loop, and that takes, in turn, the value of each of the element of the list (or each value in the interval). For example, in the first instance of the “loop over” syntax :int a &lt;- 0;loop i over: [10, 20, 30] {     a &lt;- a + i;} // a now equals 60  The second (quite common) case of the loop syntax allows one to use an interval of integers. The from and to facets take an integer expression as arguments, with the first (resp. the last) specifying the beginning (resp. end) of the inclusive interval (i.e. [to, from]). If the step is not defined, it is assumed to be equal to 1 or -1, depending on the direction of the range. If it is defined, its sign will be respected, so that a positive step will never allow the loop to enter a loop from i to j where i is greater than jlist the_list &lt;-list (species_of (self));loop i from: 0 to: length (the_list) - 1 {     ask the_list at i {        // ...     }} // every  agent of the list is asked to do somethingEmbedments  The loop statement is of type: Sequence of statements or action  The loop statement can be embedded into: Behavior, Sequence of statements or action, Layer,  The loop statement embeds statements:matchFacets  value (any type), (omissible) :DefinitionIn a switch…match structure, the value of each match block is compared to the value in the switch. If they match, the embedded statement set is executed. Three kinds of match can be usedUsages  match block is executed if the switch value is equals to the value of the match:switch 3 {   match 1 {write \"Match 1\"; }   match 3 {write \"Match 2\"; }}  match_between block is executed if the switch value is in the interval given in value of the match_between:switch 3 {   match_between [1,2] {write \"Match OK between [1,2]\"; }   match_between [2,5] {write \"Match OK between [2,5]\"; }}  match_one block is executed if the switch value is equals to one of the values of the match_one:switch 3 {   match_one [0,1,2] {write \"Match OK with one of [0,1,2]\"; }   match_between [2,3,4,5] {write \"Match OK with one of [2,3,4,5]\"; }}  See also: switch, default,Embedments  The match statement is of type: Sequence of statements or action  The match statement can be embedded into: switch,  The match statement embeds statements:migrateFacets  source (any type in [agent, species, container, an identifier]), (omissible) : can be an agent, a list of agents, a agent’s population to be migrated  target (species): target species/population that source agent(s) migrate to.  returns (a new identifier): the list of returned agents in a new local variableDefinitionThis command permits agents to migrate from one population/species to another population/species and stay in the same host after the migration. Species of source agents and target species respect the following constraints: (i) they are “peer” species (sharing the same direct macro-species), (ii) they have sub-species vs. parent-species relationship.Usages  It can be used in a 3-levels model, in case where individual agents can be captured into group meso agents and groups into clouds macro agents. migrate is used to allows agents captured by groups to migrate into clouds. See the model ‘Balls, Groups and Clouds.gaml’ in the library.migrate ball_in_group target: ball_in_cloud;  See also: capture, release,Embedments  The migrate statement is of type: Sequence of statements or action  The migrate statement can be embedded into: Behavior, Sequence of statements or action,  The migrate statement embeds statements:monitorFacets  name (a label), (omissible) : identifier of the monitor  value (any type): expression that will be evaluated to be displayed in the monitor  color (rgb): Indicates the (possibly dynamic) color of this output (default is a light gray)  refresh (boolean): Indicates the condition under which this output should be refreshed (default is true)  refresh_every (int): Allows to refresh the monitor every n time steps (default is 1)DefinitionA monitor allows to follow the value of an arbitrary expression in GAML.Usages  An example of use is:monitor \"nb preys\" value: length(prey as list) refresh_every: 5;  Embedments  The monitor statement is of type: Output  The monitor statement can be embedded into: output, permanent,  The monitor statement embeds statements:outputFacetsDefinitionoutput blocks define how to visualize a simulation (with one or more display blocks that define separate windows). It will include a set of displays, monitors and files statements. It will be taken into account only if the experiment type is gui.Usages  Its basic syntax is:experiment exp_name type: gui {   // [inputs]   output {      // [display, file, inspect, layout or monitor statements]   }}  See also: display, monitor, inspect, output_file, layout,Embedments  The output statement is of type: Output  The output statement can be embedded into: Model, Experiment,  The output statement embeds statements: display,  inspect,  monitor,  output_file,output_fileFacets  name (an identifier), (omissible) : The name of the file where you want to export the data  data (string): The data you want to export  footer (string): Define a footer for your export file  header (string): Define a header for your export file  refresh (boolean): Indicates the condition under which this file should be saved (default is true)  refresh_every (int): Allows to save the file every n time steps (default is 1)  rewrite (boolean): Rewrite or not the existing file  type (an identifier), takes values in: {csv, text, xml}: The type of your output dataEmbedments  The output_file statement is of type: Output  The output_file statement can be embedded into: output, permanent,  The output_file statement embeds statements:overlayFacets  background (rgb): the background color of the overlay displayed inside the view (the bottom overlay remains black)  border (rgb): Color to apply to the border of the rectangular shape of the overlay. Nil by default  center (any type): an expression that will be evaluated and displayed in the center section of the bottom overlay  color (any type in [list, rgb]): the color(s) used to display the expressions given in the ‘left’, ‘center’ and ‘right’ facets  left (any type): an expression that will be evaluated and displayed in the left section of the bottom overlay  position (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.  right (any type): an expression that will be evaluated and displayed in the right section of the bottom overlay  rounded (boolean): Whether or not the rectangular shape of the overlay should be rounded. True by default  size (point): extent of the layer in the view from its position. Coordinates in [0,1[ are treated as percentages of the total surface of the view, while coordinates &gt; 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Unlike  ‘position’, no elevation can be provided with the z coordinate  transparency (float): the transparency rate of the overlay (between 0 and 1, 1 means no transparency) when it is displayed inside the view. The bottom overlay will remain at 0.75Definitionoverlay allows the modeler to display a line to the already existing bottom overlay, where the results of ‘left’, ‘center’ and ‘right’ facets, when they are defined, are displayed with the corresponding color if defined.Usages  To display information in the bottom overlay, the syntax is:overlay \"Cycle: \" + (cycle) center: \"Duration: \" + total_duration + \"ms\" right: \"Model time: \" + as_date(time,\"\") color: [#yellow, #orange, #yellow];  See also: display, agents, chart, event, graphics, display_grid, image, display_population,Embedments  The overlay statement is of type: Layer  The overlay statement can be embedded into: display,  The overlay statement embeds statements:parameterFacets  var (an identifier): the name of the variable (that should be declared in the global)  name (a label), (omissible) : The message displayed in the interface  among (list): the list of possible values  category (a label): a category label, used to group parameters in the interface  init (any type): the init value  max (any type): the maximum value  min (any type): the minimum value  on_change (any type): Provides a block of statements that will be executed whenever the value of the parameter changes  slider (boolean): Whether or not to display a slider for entering an int or float value. Default is true when max and min values are defined, false otherwise. If no max or min value is defined, setting this facet to true will have no effect  step (float): the increment step (mainly used in batch mode to express the variation step between simulation)  type (a datatype identifier): the variable type  unit (a label): the variable unitDefinitionThe parameter statement specifies which global attributes (i) will change through the successive simulations (in batch experiments), (ii) can be modified by user via the interface (in gui experiments). In GUI experiments, parameters are displayed depending on their type.Usages  In gui experiment, the general syntax is the following:parameter title var: global_var category: cat;  In batch experiment, the two following syntaxes can be used to describe the possible values of a parameter:parameter 'Value of toto:' var: toto among: [1, 3, 7, 15, 100]; parameter 'Value of titi:' var: titi min: 1 max: 100 step: 2; Embedments  The parameter statement is of type: Parameter  The parameter statement can be embedded into: Experiment,  The parameter statement embeds statements:perceiveFacets  target (any type in [container, point, agent]): the list of the agent you want to perceive  name (an identifier), (omissible) : the name of the perception  as (species): an expression that evaluates to a species  emotion (546706): The emotion needed to do the perception  in (any type in [float, geometry]): a float or a geometry. If it is a float, it’s a radius of a detection area. If it is a geometry, it is the area of detection of others species.  parallel (any type in [boolean, int]): setting this facet to ‘true’ will allow ‘perceive’ to use concurrency with a parallel_bdi architecture; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet is true by default.  threshold (float): Threshold linked to the emotion.  when (boolean): a boolean to tell when does the perceive is activeDefinitionAllow the agent, with a bdi architecture, to perceive others agentsUsages  the basic syntax to perceive agents inside a circle of perceptionperceive name_of-perception target: the_agents_you_want_to_perceive in: a_distance when: a_certain_condition {Here you are in the context of the perceived agents. To refer to the agent who does the perception, use myself.If you want to make an action (such as adding a belief for example), use ask myself{ do the_action}}Embedments  The perceive statement is of type: Sequence of statements or action  The perceive statement can be embedded into: Species, Model,  The perceive statement embeds statements:permanentFacets  layout (int), (omissible) : Either #none, to indicate that no layout will be imposed, or one of the four possible predefined layouts: #stack, #split, #horizontal or #vertical. This layout will be applied to both experiment and simulation display viewsDefinitionRepresents the outputs of the experiment itself. In a batch experiment, the permanent section allows to define an output block that will NOT be re-initialized at the beginning of each simulation but will be filled at the end of each simulation.Usages  For instance, this permanent section will allow to display for each simulation the end value of the food_gathered variable:permanent {\tdisplay Ants background: rgb('white') refresh_every: 1 {\t\tchart \"Food Gathered\" type: series {\t\t\tdata \"Food\" value: food_gathered;\t\t}\t}}Embedments  The permanent statement is of type: Output  The permanent statement can be embedded into: Experiment,  The permanent statement embeds statements: display,  inspect,  monitor,  output_file,planFacets  name (an identifier), (omissible) :  emotion (546706):  finished_when (boolean):  instantaneous (boolean):  intention (546704):  priority (float):  threshold (float):  when (boolean):Embedments  The plan statement is of type: Behavior  The plan statement can be embedded into: Species, Model,  The plan statement embeds statements:putFacets  in (any type in [container, species, agent, geometry]): an expression that evaluates to a container  item (any type), (omissible) : any expression  all (any type): any expression  at (any type): any expression  edge (any type): Indicates that the item to put should be considered as an edge of the receiving graph. Soon to be deprecated, use ‘put edge(item)…’ instead  key (any type): any expression  weight (float): an expression that evaluates to a floatDefinitionAllows the agent to replace a value in a container at a given position (in a list or a map) or for a given key (in a map). Note that the behavior and the type of the attributes depends on the specific kind of container.Usages  The allowed parameters configurations are the following ones:put expr at: expr in: expr_container;put all: expr in: expr_container;  In the case of a list, the position should an integer in the bound of the list. The facet all: is used to replace all the elements of the list by the given value.list&lt;int&gt; putList &lt;- [1,2,3,4,5]; \t// putList equals [1,2,3,4,5]put -10 at: 1 in: putList; \t// putList equals [1,-10,3,4,5]put 10 all: true in: putList; \t// putList equals [10,10,10,10,10]  In the case of a matrix, the position should be a point in the bound of the matrix. The facet all: is used to replace all the elements of the matrix by the given value.matrix&lt;int&gt; putMatrix &lt;- matrix([[0,1],[2,3]]); \t// putMatrix equals matrix([[0,1],[2,3]])put -10 at: {1,1} in: putMatrix; \t// putMatrix equals matrix([[0,1],[2,-10]])put 10 all: true in: putMatrix; \t// putMatrix equals matrix([[10,10],[10,10]])  In the case of a map, the position should be one of the key values of the map. Notice that if the given key value does not exist in the map, the given pair key::value will be added to the map. The facet all is used to replace the value of all the pairs of the map.map&lt;string,int&gt; putMap &lt;- [\"x\"::4,\"y\"::7]; \t// putMap equals [\"x\"::4,\"y\"::7]put -10 key: \"y\" in: putMap; \t// putMap equals [\"x\"::4,\"y\"::-10]put -20 key: \"z\" in: putMap; \t// putMap equals [\"x\"::4,\"y\"::-10, \"z\"::-20]put -30 all: true in: putMap; \t// putMap equals [\"x\"::-30,\"y\"::-30, \"z\"::-30]Embedments  The put statement is of type: Single statement  The put statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer,  The put statement embeds statements:reactive_tabuFacets  name (an identifier), (omissible) :  aggregation (a label), takes values in: {min, max}: the agregation method  cycle_size_max (int): minimal size of the considered cycles  cycle_size_min (int): maximal size of the considered cycles  iter_max (int): number of iterations  maximize (float): the value the algorithm tries to maximize  minimize (float): the value the algorithm tries to minimize  nb_tests_wthout_col_max (int): number of movements without collision before shortening the tabu list  tabu_list_size_init (int): initial size of the tabu list  tabu_list_size_max (int): maximal size of the tabu list  tabu_list_size_min (int): minimal size of the tabu listDefinitionThis algorithm is a simple implementation of the Reactive Tabu Search algorithm ((Battiti et al., 1993)). This Reactive Tabu Search is an enhance version of the Tabu search. It adds two new elements to the classic Tabu Search. The first one concerns the size of the tabu list: in the Reactive Tabu Search, this one is not constant anymore but it dynamically evolves according to the context. Thus, when the exploration process visits too often the same solutions, the tabu list is extended in order to favor the diversification of the search process. On the other hand, when the process has not visited an already known solution for a high number of iterations, the tabu list is shortened in order to favor the intensification of the search process. The second new element concerns the adding of cycle detection capacities. Thus, when a cycle is detected, the process applies random movements in order to break the cycle. See [batch161 the batch dedicated page].Usages  As other batch methods, the basic syntax of the reactive_tabu statement uses method reactive_tabu instead of the expected reactive_tabu name: id :method reactive_tabu [facet: value];  For example:method reactive_tabu iter_max: 50 tabu_list_size_init: 5 tabu_list_size_min: 2 tabu_list_size_max: 10 nb_tests_wthout_col_max: 20 cycle_size_min: 2 cycle_size_max: 20 maximize: food_gathered;Embedments  The reactive_tabu statement is of type: Batch method  The reactive_tabu statement can be embedded into: Experiment,  The reactive_tabu statement embeds statements:reflexFacets  name (an identifier), (omissible) : the identifier of the reflex  when (boolean): an expression that evaluates a boolean, the condition to fulfill in order to execute the statements embedded in the reflex.DefinitionReflexes are sequences of statements that can be executed by the agent. Reflexes prefixed by the ‘reflex’ keyword are executed continuously. Reflexes prefixed by ‘init’ are executed only immediately after the agent has been created. Reflexes prefixed by ‘abort’ just before the agent is killed. If a facet when: is defined, a reflex is executed only if the boolean expression evaluates to true.Usages  Example:reflex my_reflex when: flip (0.5){ \t\t//Only executed when flip returns true    write \"Executing the unconditional reflex\";}Embedments  The reflex statement is of type: Behavior  The reflex statement can be embedded into: Species, Experiment, Model,  The reflex statement embeds statements:releaseFacets  target (any type in [agent, list, 27]), (omissible) : an expression that is evaluated as an agent/a list of the agents to be released or an agent saved as a map  as (species): an expression that is evaluated as a species in which the micro-agent will be released  in (agent): an expression that is evaluated as an agent that will be the macro-agent in which micro-agent will be released, i.e. their new host  returns (a new identifier): a new variable containing a list of the newly released agent(s)DefinitionAllows an agent to release its micro-agent(s). The preliminary for an agent to release its micro-agents is that species of these micro-agents are sub-species of other species (cf. [Species161#Nesting_species Nesting species]). The released agents won’t be micro-agents of the calling agent anymore. Being released from a macro-agent, the micro-agents will change their species and host (macro-agent).Usages  We consider the following species. Agents of “C” species can be released from a “B” agent to become agents of “A” species. Agents of “D” species cannot be released from the “A” agent because species “D” has no parent species.species A {...}species B {...   species C parent: A {   ...   }   species D {   ...   }...}  To release all “C” agents from a “B” agent, agent “C” has to execute the following statement. The “C” agent will change to “A” agent. The won’t consider “B” agent as their macro-agent (host) anymore. Their host (macro-agent) will the be the host (macro-agent) of the “B” agent.release list(C);  The modeler can specify the new host and the new species of the released agents:release list (C) as: new_species in: new host;  See also: capture,Embedments  The release statement is of type: Sequence of statements or action  The release statement can be embedded into: Behavior, Sequence of statements or action,  The release statement embeds statements:removeFacets  from (any type in [container, species, agent, geometry]): an expression that evaluates to a container  item (any type), (omissible) : any expression to remove from the container  all (any type): an expression that evaluates to a container. If it is true and if the value a list, it removes the first instance of each element of the list. If it is true and the value is not a container, it will remove all instances of this value.  edge (any type): Indicates that the item to remove should be considered as an edge of the receiving graph  index (any type): any expression, the key at which to remove the element from the container  key (any type): any expression, the key at which to remove the element from the container  node (any type): Indicates that the item to remove should be considered as a node of the receiving graph  vertex (any type):DefinitionAllows the agent to remove an element from a container (a list, matrix, map…).Usages  This statement should be used in the following ways, depending on the kind of container used and the expected action on it:remove expr from: expr_container;remove index: expr from: expr_container;remove key: expr from: expr_container;remove all: expr from: expr_container;  In the case of list, the facet item: is used to remove the first occurence of a given expression, whereas all is used to remove all the occurrences of the given expression.list&lt;int&gt; removeList &lt;- [3,2,1,2,3];remove 2 from: removeList; \t// removeList equals [3,1,2,3]remove 3 all: true from: removeList; \t// removeList equals [1,2]remove index: 1 from: removeList; \t// removeList equals [1]  In the case of map, the facet key: is used to remove the pair identified by the given key.map&lt;string,int&gt; removeMap &lt;- [\"x\"::5, \"y\"::7, \"z\"::7];remove key: \"x\" from: removeMap; \t// removeMap equals [\"y\"::7, \"z\"::7]remove 7 all: true from: removeMap; \t// removeMap equals map([])  In addition, a map a be managed as a list with pair key as index. Given that, facets item:, all: and index: can be used in the same way:map&lt;string,int&gt; removeMapList &lt;- [\"x\"::5, \"y\"::7, \"z\"::7, \"t\"::5];remove 7 from: removeMapList; \t// removeMapList equals [\"x\"::5, \"z\"::7, \"t\"::5]remove [5,7] all: true from: removeMapList; \t// removeMapList equals [\"t\"::5]remove index: \"t\" from: removeMapList; \t// removeMapList equals map([])  In the case of a graph, both edges and nodes can be removes using node: and edge facets. If a node is removed, all edges to and from this node are also removed.graph removeGraph &lt;- as_edge_graph([{1,2}::{3,4},{3,4}::{5,6}]);remove node: {1,2} from: removeGraph;remove node(1,2) from: removeGraph;list var &lt;- removeGraph.vertices; \t// var equals [{3,4},{5,6}]list var &lt;- removeGraph.edges; \t// var equals [polyline({3,4}::{5,6})]remove edge: {3,4}::{5,6} from: removeGraph;remove edge({3,4},{5,6}) from: removeGraph;list var &lt;- removeGraph.vertices; \t// var equals [{3,4},{5,6}]list var &lt;- removeGraph.edges; \t// var equals []  In the case of an agent or a shape, remove allows to remove an attribute from the attributes map of the receiver. However, for agents, it will only remove attributes that have been added dynamically, not the ones defined in the species or in its built-in parent.global {   init {      create speciesRemove;      speciesRemove sR &lt;- speciesRemove(0); \t// sR.a now equals 100      remove key:\"a\" from: sR; \t// sR.a now equals nil   }}species speciesRemove {   int a &lt;- 100; }  This statement can not be used on matrix.  See also: add, put,Embedments  The remove statement is of type: Single statement  The remove statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer,  The remove statement embeds statements:returnFacets  value (any type), (omissible) : an expression that is returnedDefinitionAllows to immediately stop and tell which value to return from the evaluation of the surrounding action or top-level statement (reflex, init, etc.). Usually used within the declaration of an action. For more details about actions, see the following [Section161 section].Usages  Example:string foo {     return \"foo\";}reflex {    string foo_result &lt;- foo(); \t// foos_result is now equals to \"foo\"}  In the specific case one wants an agent to ask another agent to execute a statement with a return, it can be done similarly to:// In Species A:string foo_different {     return \"foo_not_same\";}/// ....// In Species B:reflex writing {    string temp &lt;- some_agent_A.foo_different []; \t// temp is now equals to \"foo_not_same\" }Embedments  The return statement is of type: Single statement  The return statement can be embedded into: action, Behavior, Sequence of statements or action,  The return statement embeds statements:ruleFacets  name (an identifier), (omissible) : The name of the rule  belief (546704): The mandatory belief  desire (546704): The mandatory desire  emotion (546706): The mandatory emotion  new_belief (546704): The belief that will be added  new_beliefs (list): The belief that will be added  new_desire (546704): The desire that will be added  new_desires (list): The desire that will be added  new_emotion (546706): The emotion that will be added  new_emotions (list): The emotion that will be added  new_uncertainties (list): The uncertainty that will be added  new_uncertainty (546704): The uncertainty that will be added  parallel (any type in [boolean, int]): setting this facet to ‘true’ will allow ‘perceive’ to use concurrency with a parallel_bdi architecture; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet is true by default.  priority (any type in [float, int]): The priority of the predicate added as a desire  remove_belief (546704): The belief that will be removed  remove_beliefs (list): The belief that will be removed  remove_desire (546704): The desire that will be removed  remove_desires (list): The desire that will be removed  remove_emotion (546706): The emotion that will be removed  remove_emotions (list): The emotion that will be removed  remove_intention (546704): The intention that will be removed  remove_uncertainties (list): The uncertainty that will be removed  remove_uncertainty (546704): The uncertainty that will be removed  threshold (float): Threshold linked to the emotion.  uncertainty (546704): The mandatory uncertainty  when (boolean):Definitionenables to add a desire or a belief or to remove a belief, a desire or an intention if the agent gets the belief or/and desire or/and condition mentioned.Usages  Other examples of use:    rule belief: new_predicate(\"test\") when: flip(0.5) new_desire: new_predicate(\"test\")      Embedments  The rule statement is of type: Single statement  The rule statement can be embedded into: Species, Model,  The rule statement embeds statements:runFacets  name (string), (omissible) :  of (string):  core (int):  end_cycle (int):  seed (int):  with_output (map):  with_param (map):Embedments  The run statement is of type: Sequence of statements or action  The run statement can be embedded into: Behavior, Single statement, Species, Model,  The run statement embeds statements:saveFacets  data (any type), (omissible) : any expression, that will be saved in the file  attributes (map): Allows to specify the attributes of a shape file (or other files that accept attributes). The keys of the map are the names of the attributes that will be present in the file, the values are whatever expression neeeded to define their value  crs (any type): the name of the projection, e.g. crs:”EPSG:4326” or its EPSG id, e.g. crs:4326. Here a list of the CRS codes (and EPSG id): http://spatialreference.org  header (boolean): an expression that evaluates to a boolean, specifying whether the save will write a header if the file does not exist  rewrite (boolean): an expression that evaluates to a boolean, specifying whether the save will ecrase the file or append data at the end of it. Default is true  to (string): an expression that evaluates to an string, the path to the file  type (an identifier), takes values in: {shp, text, csv, asc, geotiff, image}: an expression that evaluates to an string, the type of the output file (it can be only “shp”, “asc”, “geotiff”, “image”, “text” or “csv”)  with (map): Allows to define the attributes of a shape file. Keys of the map are the attributes of agents to save, values are the names of attributes in the shape fileDefinitionAllows to save data in a file. The type of file can be “shp”, “asc”, “geotiff”, “text” or “csv”.Usages  Its simple syntax is:save data to: output_file type: a_type_file;  To save data in a text file:save (string(cycle) + \"-&gt;\"  + name + \":\" + location) to: \"save_data.txt\" type: \"text\";  To save the values of some attributes of the current agent in csv file:save [name, location, host] to: \"save_data.csv\" type: \"csv\";  To save the values of all attributes of all the agents of a species into a csv (with optional attributes):save species_of(self) to: \"save_csvfile.csv\" type: \"csv\" header: false;  To save the geometries of all the agents of a species into a shapefile (with optional attributes):save species_of(self) to: \"save_shapefile.shp\" type: \"shp\" with: [name::\"nameAgent\", location::\"locationAgent\"] crs: \"EPSG:4326\";  To save the grid_value attributes of all the cells of a grid into an ESRI ASCII Raster file:save grid to: \"save_grid.asc\" type: \"asc\";  To save the grid_value attributes of all the cells of a grid into geotiff:save grid to: \"save_grid.tif\" type: \"geotiff\";  To save the grid_value attributes of all the cells of a grid into png (with a worldfile):save grid to: \"save_grid.png\" type: \"image\";  The save statement can be use in an init block, a reflex, an action or in a user command. Do not use it in experiments.Embedments  The save statement is of type: Single statement  The save statement can be embedded into: Behavior, Sequence of statements or action,  The save statement embeds statements:save_batchFacets  to (a label):  data (any type), (omissible) :  rewrite (boolean):Embedments  The save_batch statement is of type: Batch method  The save_batch statement can be embedded into: Experiment,  The save_batch statement embeds statements:setFacets  name (any type), (omissible) : the name of an existing variable or attribute to be modified  value (any type): the value to affect to the variable or attributeDefinitionAllows to assign a value to the variable or attribute specifiedUsagesEmbedments  The set statement is of type: Single statement  The set statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer,  The set statement embeds statements:setupFacetsDefinitionThe setup statement is used to define the set of instructions that will be executed before every [#test test].Usages  As every test should be independent from the others, the setup will mainly contain initialization of variables that will be used in each test.species Tester {    int val_to_test;    setup {        val_to_test &lt;- 0;    }    test t1 {       // [set of instructions, including asserts]    }}  See also: test, assert,Embedments  The setup statement is of type: Sequence of statements or action  The setup statement can be embedded into: Species, Experiment, Model,  The setup statement embeds statements:simulateFacets  comodel (file), (omissible) :  repeat (int):  reset (boolean):  share (list):  until (boolean):  with_experiment (string):  with_input (map):  with_output (map):DefinitionAllows an agent, the sender agent (that can be the [Sections161#global world agent]), to ask another (or other) agent(s) to perform a set of statements. It obeys the following syntax, where the target attribute denotes the receiver agent(s):Usages  Other examples of use:    ask receiver_agent(s) {   // [statements]}      Embedments  The simulate statement is of type: Single statement  The simulate statement can be embedded into: chart, Experiment, Species, Behavior, Sequence of statements or action,  The simulate statement embeds statements:socializeFacets  name (an identifier), (omissible) : the identifier of the socialize statement  agent (agent): the agent value of the created social link  dominance (float): the dominance value of the created social link  familiarity (float): the familiarity value of the created social link  liking (float): the appreciation value of the created social link  solidarity (float): the solidarity value of the created social link  when (boolean): A boolean value to socialize only with a certain conditionDefinitionenables to directly add a social link from a perceived agent.Usages  Other examples of use:    socialize;      Embedments  The socialize statement is of type: Single statement  The socialize statement can be embedded into: Behavior, Sequence of statements or action,  The socialize statement embeds statements:solveFacets  equation (an identifier), (omissible) : the equation system identifier to be numerically solved  cycle_length (int): length of simulation cycle which will be synchronize with step of integrator (default value: 1)  discretizing_step (int): number of discrete between 2 steps of simulation (default value: 0)  integrated_times (list): time interval inside integration process  integrated_values (list): list of variables’s value inside integration process  max_step (float): maximal step, (used with dp853 method only), (sign is irrelevant, regardless of integration direction, forward or backward), the last step can be smaller than this value  method (an identifier), takes values in: {Euler, ThreeEighthes, Midpoint, Gill, Luther, rk4, dp853, AdamsBashforth, AdamsMoulton, DormandPrince54, GraggBulirschStoer, HighamHall54}: integrate method (can be only “Euler”, “ThreeEighthes”, “Midpoint”, “Gill”, “Luther”, “rk4” or “dp853”, “AdamsBashforth”, “AdamsMoulton”, “DormandPrince54”, “GraggBulirschStoer”,  “HighamHall54”) (default value: “rk4”)  min_step (float): minimal step, (used with dp853 method only), (sign is irrelevant, regardless of integration direction, forward or backward), the last step can be smaller than this value  scalAbsoluteTolerance (float): allowed absolute error (used with dp853 method only)  scalRelativeTolerance (float): allowed relative error (used with dp853 method only)  step (float): integration step, use with most integrator methods (default value: 1)  time_final (float): target time for the integration (can be set to a value smaller than t0 for backward integration)  time_initial (float): initial timeDefinitionSolves all equations which matched the given name, with all systems of agents that should solved simultaneously.Usages  Other examples of use:    solve SIR method: \"rk4\" step:0.001;      Embedments  The solve statement is of type: Single statement  The solve statement can be embedded into: Behavior, Sequence of statements or action,  The solve statement embeds statements:speciesFacets  name (an identifier), (omissible) : the identifier of the species  cell_height (float): (grid only), the height of the cells of the grid  cell_width (float): (grid only), the width of the cells of the grid  compile (boolean):  control (22): defines the architecture of the species (e.g. fsm…)  edge_species (species): In the case of a species defining a graph topology for its instances (nodes of the graph), specifies the species to use for representing the edges  file (file): (grid only), a bitmap file that will be loaded at runtime so that the value of each pixel  can be assigned to the attribute ‘grid_value’  frequency (int): The execution frequency of the species (default value: 1). For instance, if frequency is set to 10, the population of agents will be executed only every 10 cycles.  height (int): (grid only),  the height of the grid (in terms of agent number)  mirrors (any type in [list, species]): The species this species is mirroring. The population of this current species will be dependent of that of the species mirrored (i.e. agents creation and death are entirely taken in charge by GAMA with respect to the demographics of the species mirrored). In addition, this species is provided with an attribute called ‘target’, which allows each agent to know which agent of the mirrored species it is representing.  neighbors (int): (grid only), the chosen neighborhood (4, 6 or 8)  neighbours (int): (grid only), the chosen neighborhood (4, 6 or 8)  parallel (any type in [boolean, int]): (experimental) setting this facet to ‘true’ will allow this species to use concurrency when scheduling its agents; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet has a default set in the preferences (Under Performances &gt; Concurrency)  parent (species): the parent class (inheritance)  schedules (container): A container of agents (a species, a dynamic list, or a combination of species and containers) , which represents which agents will be actually scheduled when the population is scheduled for execution. For instance, ‘species a schedules: (10 among a)’ will result in a population that schedules only 10 of its own agents every cycle. ‘species b schedules: []’ will prevent the agents of ‘b’ to be scheduled. Note that the scope of agents covered here can be larger than the population, which allows to build complex scheduling controls; for instance, defining ‘global schedules: [] {…} species b schedules: []; species c schedules: b + world; ‘ allows to simulate a model where the agents of b are scheduled first, followed by the world, without even having to create an instance of c.  skills (list): The list of skills that will be made available to the instances of this species. Each new skill provides attributes and actions that will be added to the ones defined in this species  topology (topology): The topology of the population of agents defined by this species. In case of nested species, it can for example be the shape of the macro-agent. In case of grid or graph species, the topology is automatically computed and cannot be redefined  torus (boolean): is the topology toric (defaut: false). Needs to be defined on the global species.  use_individual_shapes (boolean): (grid only),(true by default). Allows to specify whether or not the agents of the grid will have distinct geometries. If set to false, they will all have simpler proxy geometries  use_neighbors_cache (boolean): (grid only),(true by default). Allows to turn on or off the use of the neighbors cache used for grids. Note that if a diffusion of variable occurs, GAMA will emit a warning and automatically switch to a caching version  use_regular_agents (boolean): (grid only),(true by default). Allows to specify if the agents of the grid are regular agents (like those of any other species) or minimal ones (which can’t have sub-populations, can’t inherit from a regular species, etc.)  width (int): (grid only), the width of the grid (in terms of agent number)DefinitionThe species statement allows modelers to define new species in the model. global and grid are speciel cases of species: global being the definition of the global agent (which has automatically one instance, world) and grid being a species with a grid topology.Usages  Here is an example of a species definition with a FSM architecture and the additional skill moving:species ant skills: [moving] control: fsm {  In the case of a species aiming at mirroring another one:species node_agent mirrors: list(bug) parent: graph_node edge_species: edge_agent {  The definition of the single grid of a model will automatically create gridwidth x gridheight agents:grid ant_grid width: gridwidth height: gridheight file: grid_file neighbors: 8 use_regular_agents: false {   Using a file to initialize the grid can replace width/height facets:grid ant_grid file: grid_file neighbors: 8 use_regular_agents: false { Embedments  The species statement is of type: Species  The species statement can be embedded into: Model, Environment, Species,  The species statement embeds statements:stateFacets  name (an identifier), (omissible) : the identifier of the state  final (boolean): specifies whether the state is a final one (i.e. there is no transition from this state to another state) (default value= false)  initial (boolean): specifies whether the state is the initial one (default value = false)DefinitionA state, like a reflex, can contains several statements that can be executed at each time step by the agent.Usages  Here is an exemple integrating 2 states and the statements in the FSM architecture:\tstate s_init initial: true {\t\tenter { write \"Enter in\" + state; }\t\t\twrite \"Enter in\" + state;\t\t}\t\twrite state;\t\ttransition to: s1 when: (cycle &gt; 2) {\t\t\twrite \"transition s_init -&gt; s1\";\t\t}\t\texit {\t\t\twrite \"EXIT from \"+state;\t\t}\t}\tstate s1 {\tenter {write 'Enter in '+state;}\twrite state;\texit {write 'EXIT from '+state;}}  See also: enter, exit, transition,Embedments  The state statement is of type: Behavior  The state statement can be embedded into: fsm, Species, Experiment, Model,  The state statement embeds statements: enter,  exit,statusFacets  message (any type), (omissible) : Allows to display a necessarily short message in the status box in the upper left corner. No formatting characters (carriage returns, tabs, or Unicode characters) should be used, but a background color can be specified. The message will remain in place until it is replaced by another one or by nil, in which case the standard status (number of cycles) will be displayed again  color (rgb):DefinitionThe statement makes the agent output an arbitrary message in the status box.Usages  Outputting a messagestatus ('This is my status ' + self) color: #yellow;Embedments  The status statement is of type: Single statement  The status statement can be embedded into: Behavior, Sequence of statements or action, Layer,  The status statement embeds statements:switchFacets  value (any type), (omissible) : an expressionDefinitionThe “switch… match” statement is a powerful replacement for imbricated “if … else …” constructs. All the blocks that match are executed in the order they are defined. The block prefixed by default is executed only if none have matched (otherwise it is not).Usages  The prototypical syntax is as follows:switch an_expression {        match value1 {...}        match_one [value1, value2, value3] {...}        match_between [value1, value2] {...}        default {...}}  Example:switch 3 {   match 1 {write \"Match 1\"; }   match 2 {write \"Match 2\"; }   match 3 {write \"Match 3\"; }   match_one [4,4,6,3,7]  {write \"Match one_of\"; }   match_between [2, 4] {write \"Match between\"; }   default {write \"Match Default\"; }}  See also: match, default, if,Embedments  The switch statement is of type: Sequence of statements or action  The switch statement can be embedded into: Behavior, Sequence of statements or action, Layer,  The switch statement embeds statements: default,  match,tabuFacets  name (an identifier), (omissible) :  aggregation (a label), takes values in: {min, max}: the agregation method  iter_max (int): number of iterations  maximize (float): the value the algorithm tries to maximize  minimize (float): the value the algorithm tries to minimize  tabu_list_size (int): size of the tabu listDefinitionThis algorithm is an implementation of the Tabu Search algorithm. See the wikipedia article and [batch161 the batch dedicated page].Usages  As other batch methods, the basic syntax of the tabu statement uses method tabu instead of the expected tabu name: id :method tabu [facet: value];  For example:method tabu iter_max: 50 tabu_list_size: 5 maximize: food_gathered;Embedments  The tabu statement is of type: Batch method  The tabu statement can be embedded into: Experiment,  The tabu statement embeds statements:taskFacets  name (an identifier), (omissible) : the identifier of the task  weight (float): the priority level of the taskDefinitionAs reflex, a task is a sequence of statements that can be executed, at each time step, by the agent. If an agent owns several tasks, the scheduler chooses a task to execute based on its current priority weight value.UsagesEmbedments  The task statement is of type: Behavior  The task statement can be embedded into: weighted_tasks, sorted_tasks, probabilistic_tasks, Species, Experiment, Model,  The task statement embeds statements:testFacets  name (an identifier), (omissible) : identifier of the testDefinitionThe test statement allows modeler to define a set of assertions that will be tested. Before the execution of the embedded set of instructions, if a setup is defined in the species, model or experiment, it is executed. In a test, if one assertion fails, the evaluation of other assertions continue (if GAMA is configured in the preferences that the program does not stop at the first exception).Usages  An example of use:species Tester {    // set of attributes that will be used in test    setup {        // [set of instructions... in particular initializations]    }    test t1 {       // [set of instructions, including asserts]    }}  See also: setup, assert,Embedments  The test statement is of type: Behavior  The test statement can be embedded into: Species, Experiment, Model,  The test statement embeds statements: assert,traceFacetsDefinitionAll the statements executed in the trace statement are displayed in the console.UsagesEmbedments  The trace statement is of type: Sequence of statements or action  The trace statement can be embedded into: Behavior, Sequence of statements or action, Layer,  The trace statement embeds statements:transitionFacets  to (an identifier): the identifier of the next state  when (boolean), (omissible) : a condition to be fulfilled to have a transition to another given stateDefinitionIn an FSM architecture, transition specifies the next state of the life cycle. The transition occurs when the condition is fulfilled. The embedded statements are executed when the transition is triggered.Usages  In the following example, the transition is executed when after 2 steps:\tstate s_init initial: true {\t\twrite state;\t\ttransition to: s1 when: (cycle &gt; 2) {\t\t\twrite \"transition s_init -&gt; s1\";\t\t}\t}  See also: enter, state, exit,Embedments  The transition statement is of type: Sequence of statements or action  The transition statement can be embedded into: Sequence of statements or action, Behavior,  The transition statement embeds statements:unconscious_contagionFacets  emotion (546706): the emotion that will be copied with the contagion  name (an identifier), (omissible) : the identifier of the unconscious contagion  charisma (float): The charisma value of the perceived agent (between 0 and 1)  receptivity (float): The receptivity value of the current agent (between 0 and 1)  threshold (float): The threshold value to make the contagion  when (boolean): A boolean value to get the emotion only with a certain conditionDefinitionenables to directly copy an emotion presents in the perceived specie.Usages  Other examples of use:    unconscious_contagion emotion:fearConfirmed; unconscious_contagion emotion:fearConfirmed charisma: 0.5 receptivity: 0.5;      Embedments  The unconscious_contagion statement is of type: Single statement  The unconscious_contagion statement can be embedded into: Behavior, Sequence of statements or action,  The unconscious_contagion statement embeds statements:user_commandFacets  name (a label), (omissible) : the identifier of the user_command  action (26): the identifier of the action to be executed. This action should be accessible in the context in which the user_command is defined (an experiment, the global section or a species). A special case is allowed to maintain the compatibility with older versions of GAMA, when the user_command is declared in an experiment and the action is declared in ‘global’. In that case, all the simulations managed by the experiment will run the action in response to the user executing the command  color (rgb): The color of the button to display  continue (boolean): Whether or not the button, when clicked, should dismiss the user panel it is defined in. Has no effect in other contexts (menu, parameters, inspectors)  when (boolean): the condition that should be fulfilled (in addition to the user clicking it) in order to execute this action  with (map): the map of the parameters::values required by the actionDefinitionAnywhere in the global block, in a species or in an (GUI) experiment, user_command statements allows to either call directly an existing action (with or without arguments) or to be followed by a block that describes what to do when this command is run.Usages  The general syntax is for example:user_command kill_myself action: some_action with: [arg1::val1, arg2::val2, ...];  See also: user_init, user_panel, user_input,Embedments  The user_command statement is of type: Sequence of statements or action  The user_command statement can be embedded into: user_panel, Species, Experiment, Model,  The user_command statement embeds statements: user_input,user_initFacets  name (an identifier), (omissible) : The name of the panel  initial (boolean): Whether or not this panel will be the initial oneDefinitionUsed in the user control architecture, user_init is executed only once when the agent is created. It opens a special panel (if it contains user_commands statements). It is the equivalent to the init block in the basic agent architecture.Usages  See also: user_command, user_init, user_input,Embedments  The user_init statement is of type: Behavior  The user_init statement can be embedded into: Species, Experiment, Model,  The user_init statement embeds statements: user_panel,user_inputFacets  returns (a new identifier): a new local variable containing the value given by the user  name (a label), (omissible) : the displayed name  among (list): the set of acceptable values for the variable  init (any type): the init value  max (float): the maximum value  min (float): the minimum value  slider (boolean): Whether to display a slider or not when applicable  type (a datatype identifier): the variable typeDefinitionIt allows to let the user define the value of a variable.Usages  Other examples of use:    user_panel \"Advanced Control\" {  user_input \"Location\" returns: loc type: point &lt;- {0,0};  create cells number: 10 with: [location::loc];}        See also: user_command, user_init, user_panel,Embedments  The user_input statement is of type: Single statement  The user_input statement can be embedded into: user_command,  The user_input statement embeds statements:user_panelFacets  name (an identifier), (omissible) : The name of the panel  initial (boolean): Whether or not this panel will be the initial oneDefinitionIt is the basic behavior of the user control architecture (it is similar to state for the FSM architecture). This user_panel translates, in the interface, in a semi-modal view that awaits the user to choose action buttons, change attributes of the controlled agent, etc. Each user_panel, like a state in FSM, can have a enter and exit sections, but it is only defined in terms of a set of user_commands which describe the different action buttons present in the panel.Usages  The general syntax is for example:user_panel default initial: true {\tuser_input 'Number' returns: number type: int &lt;- 10;\task (number among list(cells)){ do die; }\ttransition to: \"Advanced Control\" when: every (10);}user_panel \"Advanced Control\" {\tuser_input \"Location\" returns: loc type: point &lt;- {0,0};\tcreate cells number: 10 with: [location::loc];}  See also: user_command, user_init, user_input,Embedments  The user_panel statement is of type: Behavior  The user_panel statement can be embedded into: fsm, user_first, user_last, user_init, user_only, Species, Experiment, Model,  The user_panel statement embeds statements: user_command,usingFacets  topology (topology), (omissible) : the topologyDefinitionusing is a statement that allows to set the topology to use by its sub-statements. They can gather it by asking the scope to provide it.Usages  All the spatial operations are topology-dependent (e.g. neighbors are not the same in a continuous and in a grid topology). So using statement allows modelers to specify the topology in which the spatial operation will be computed.float dist &lt;- 0.0;using topology(grid_ant) {\td (self.location distance_to target.location);}Embedments  The using statement is of type: Sequence of statements or action  The using statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer,  The using statement embeds statements:Variable_containerFacets  name (a new identifier), (omissible) : The name of the attribute  category (a label): Soon to be deprecated. Declare the parameter in an experiment instead  const (boolean): Indicates whether this attribute can be subsequently modified or not  fill_with (any type):  function (any type): Used to specify an expression that will be evaluated each time the attribute is accessed. This facet is incompatible with both ‘init:’ and ‘update:’  index (a datatype identifier):  init (any type): The initial value of the attribute  of (a datatype identifier):  on_change (any type): Provides a block of statements that will be executed whenever the value of the attribute changes  parameter (a label): Soon to be deprecated. Declare the parameter in an experiment instead  size (any type in [int, point]):  type (a datatype identifier):  update (any type): An expression that will be evaluated each cycle to compute a new value for the attribute  value (any type):DefinitionAllows to declare an attribute of a species or an experimentUsagesEmbedments  The Variable_container statement is of type: Variable (container)  The Variable_container statement can be embedded into: Species, Experiment, Model,  The Variable_container statement embeds statements:Variable_numberFacets  name (a new identifier), (omissible) : The name of the attribute  among (list): A list of constant values among which the attribute can take its value  category (a label): Soon to be deprecated. Declare the parameter in an experiment instead  const (boolean): Indicates whether this attribute can be subsequently modified or not  function (any type in [int, float]): Used to specify an expression that will be evaluated each time the attribute is accessed. This facet is incompatible with both ‘init:’ and ‘update:’  init (any type in [int, float]): The initial value of the attribute  max (any type in [int, float]): The maximum value this attribute can take.  min (any type in [int, float]): The minimum value this attribute can take  on_change (any type): Provides a block of statements that will be executed whenever the value of the attribute changes  parameter (a label): Soon to be deprecated. Declare the parameter in an experiment instead  step (int):  type (a datatype identifier): The type of the attribute, either ‘int’ or ‘float’  update (any type in [int, float]): An expression that will be evaluated each cycle to compute a new value for the attribute  value (any type in [int, float]):DefinitionAllows to declare an attribute of a species or experimentUsagesEmbedments  The Variable_number statement is of type: Variable (number)  The Variable_number statement can be embedded into: Species, Experiment, Model,  The Variable_number statement embeds statements:Variable_regularFacets  name (a new identifier), (omissible) : The name of the attribute  among (list): A list of constant values among which the attribute can take its value  category (a label): Soon to be deprecated. Declare the parameter in an experiment instead  const (boolean): Indicates whether this attribute can be subsequently modified or not  function (any type): Used to specify an expression that will be evaluated each time the attribute is accessed. This facet is incompatible with both ‘init:’ and ‘update:’  index (a datatype identifier): The type of the index used to retrieve elements if the type of the attribute is a container type  init (any type): The initial value of the attribute  of (a datatype identifier): The type of the elements contained in the type of this attribute if it is a container type  on_change (any type): Provides a block of statements that will be executed whenever the value of the attribute changes  parameter (a label): Soon to be deprecated. Declare the parameter in an experiment instead  type (a datatype identifier): The type of this attribute. Can be combined with facets ‘of’ and ‘index’ to describe container types  update (any type): An expression that will be evaluated each cycle to compute a new value for the attribute  value (any type):DefinitionAllows to declare an attribute of a species or an experimentUsagesEmbedments  The Variable_regular statement is of type: Variable (regular)  The Variable_regular statement can be embedded into: Species, Experiment, Model,  The Variable_regular statement embeds statements:warnFacets  message (string), (omissible) : the message to display as a warning.DefinitionThe statement makes the agent output an arbitrary message in the error view as a warning.Usages  Emmitting a warningwarn 'This is a warning from ' + self;Embedments  The warn statement is of type: Single statement  The warn statement can be embedded into: Behavior, Sequence of statements or action, Layer,  The warn statement embeds statements:writeFacets  message (any type), (omissible) : the message to display. Modelers can add some formatting characters to the message (carriage returns, tabs, or Unicode characters), which will be used accordingly in the console.  color (rgb): The color with wich the message will be displayed. Note that different simulations will have different (default) colors to use for this purpose if this facet is not specifiedDefinitionThe statement makes the agent output an arbitrary message in the console.Usages  Outputting a messagewrite 'This is a message from ' + self;Embedments  The write statement is of type: Single statement  The write statement can be embedded into: Behavior, Sequence of statements or action, Layer,  The write statement embeds statements:",
        "url":"/wiki/Statements.html"
      }
      ,
    
      "wiki-statistics-regression-html": {
        "title": "Regression",
        "content": "RegressionAuthor : Patrick TaillandierA model which shows how to use the regressionCode of the model :model example_regressionglobal {\t//Regression variable that will store the function\tregression location_fct;\tfloat x_val &lt;- 50.0;\tfloat y_val &lt;- 50.0;\t\tfloat val &lt;- -1.0;\tinit {\t\tloop i from: 0 to: 18{\t\t\tif (i != 10) {\t\t\t\tcreate dummy with:[location::{i * 5 + 2 - rnd(4), i*5 + 2 - rnd(4), i*5 + 2 - rnd(4)}];\t\t\t\t}\t\t}\t}\t\t//Reflex to compute the regression\treflex do_regression {\t\tmatrix&lt;float&gt; instances &lt;- 0.0 as_matrix {3,length(dummy)};\t\tloop i from: 0 to: length(dummy) -1 {\t\t\tdummy ag &lt;- dummy[i];\t\t\tinstances[1,i] &lt;- ag.location.x;\t\t\tinstances[2,i] &lt;- ag.location.y;\t\t\tinstances[0,i] &lt;- ag.location.z;\t\t}\t\t//Compute the function of regression\t\tlocation_fct  &lt;- build(instances);\t\twrite \"learnt function: \" + location_fct;\t\t\t\t//Predict the value using the function resulting before\t\tval &lt;-  predict(location_fct, [x_val, y_val]);\t\twrite \"value : \" + val;\t}}species dummy {\taspect default {\t\tdraw sphere(2) color: #blue;\t}}experiment main type: gui {\tparameter \"Point to test, x value\" var: x_val ;\tparameter \"Point to test, y value\" var: y_val ;\toutput {\t\tdisplay map type: opengl {\t\t\tspecies dummy;\t\t\tgraphics \"new Point \" {\t\t\t\tif (location_fct != nil) {\t\t\t\t\tdraw sphere(2) color: #red at: {x_val,y_val,val};\t\t\t\t\t\t\t\t\t\t//Draw the function as a line\t\t\t\t\tdraw line([{100,100,predict(location_fct, [100,100])},{-10,-10,predict(location_fct, [-10,-10])}]) color: #black;\t\t\t\t}\t\t\t\t\t\t\t}\t\t}\t}}",
        "url":"/wiki/Statistics-Regression.html"
      }
      ,
    
      "wiki-statistics-html": {
        "title": "Statistics",
        "content": "StatisticsThis sub-section is composed of the following models :  Regression",
        "url":"/wiki/Statistics.html"
      }
      ,
    
      "wiki-sugarscape-sugarscape-html": {
        "title": "sugarscape",
        "content": "sugarscape_Author : _A model with animal moving on a grid to find sugar. The animal agents have a life duration and die if it is reached or if they don’t have anymore sugar.Code of the model :model sugarscape  global {\t// Parameters \t\t//Growth rate of the sugar\tint sugarGrowthRate &lt;- 1;\t//Minimum age of death\tint minDeathAge &lt;- 60;\t//Maximum age of death\tint maxDeathAge &lt;- 100;\t//Metabolism maximum\tint maxMetabolism &lt;- 3;\t\t//Maximum and Minimum initial sugar\tint maxInitialSugar &lt;- 25 ;\tint minInitialSugar &lt;- 5;\t//Maximum range\tint maxRange &lt;- 6;\tbool replace &lt;- true;\t//Number of agents\tint numberOfAgents &lt;- 400;\t\t\t// Environment\tgeometry shape &lt;- rectangle(50, 50);\t\t\tfile&lt;int&gt; types  &lt;- file&lt;int&gt;('../images/sugarscape.pgm');\trgb FFFFAA const: true &lt;- rgb('#FFFFAA');\trgb FFFF55 const: true &lt;- rgb('#FFFF55');\trgb dark_yellow const: true &lt;- rgb('#EEB422');\trgb less_red const: true &lt;- rgb('#FF5F5F');\t\tinit {\t\t\t\t//Create the animal\t\tcreate animal number: numberOfAgents;\t\t\t\t//Ask to each sugar cell to set its sugar\t\task sugar_cell {\t\t\tmaxSugar &lt;- (types at {grid_x,grid_y});\t\t\tsugar &lt;- maxSugar;\t\t\tcolor &lt;- [#white,FFFFAA,FFFF55,#yellow,dark_yellow] at sugar;\t\t}\t}}\t//Grid species representing the sugar cells\tgrid sugar_cell width: 50 height: 50 neighbors: 4 use_individual_shapes: false use_regular_agents: false{ \t\t//Maximum sugar\t\tint maxSugar;\t\t//Sugar contained in thecell\t\tint sugar update: sugar + sugarGrowthRate max: maxSugar;\t\trgb color update: [#white,FFFFAA,FFFF55,#yellow,dark_yellow] at sugar;\t\tmap&lt;int,list&lt;sugar_cell&gt;&gt; neighbours;\t\t\t\t//Initialization of the neighbours\t\tinit {\t\t\tloop i from: 1 to: maxRange {\t\t\t\tneighbours[i] &lt;- self neighbors_at i; \t\t\t}\t\t}\t}\t\t//Species animal representing the animal agentsspecies animal {\t//Color of the animal\trgb color  &lt;- #red;\t//Speed of the animal\tfloat speed  &lt;- 1.0;\t//Metabolism of the animal\tint metabolism  min: 1 &lt;- rnd(maxMetabolism);\t//Perception range of the animal\tint vision  min: 1 &lt;- rnd(maxRange);\t//Maximal age of the animal\tint maxAge  min: minDeathAge max: maxDeathAge &lt;- rnd (maxDeathAge - minDeathAge) + minDeathAge;\t//Size of the animal\tfloat size  &lt;- 0.5;\t//Sugar of the animal\tint sugar min: 0 &lt;- (rnd (maxInitialSugar - minInitialSugar)) + minInitialSugar update: sugar - metabolism;\t//Age of the animal\tint age max: maxAge &lt;- 0 update: int(age + step);\t//Place of the animal\tsugar_cell place ; \t\t//Launched at the initialization of the animal agent\tinit {\t\t//Set the place as one of the sugar cell\t\tplace &lt;- one_of(sugar_cell);\t\tlocation &lt;- place.location;\t}\t//Move the agent to another place and collect the sugar of the previous place\treflex basic_move { \t\tsugar &lt;- sugar + place.sugar;\t\tplace.sugar &lt;- 0;\t\tlist&lt;sugar_cell&gt; neighbours &lt;- place.neighbours[vision];\t\tlist&lt;sugar_cell&gt; poss_targets &lt;- (neighbours) where (each.sugar &gt; 0);\t\t//If no sugar is found in the neighbours cells, move randomly\t\tplace &lt;- empty(poss_targets) ? one_of (neighbours) : one_of (poss_targets);\t\tlocation &lt;- place.location;\t}\t//Reflex to kill the animal once it reaches its maximal age or it doesn't have sugar anymore\treflex end_of_life when: (sugar = 0) or (age = maxAge) {\t\tif replace {\t\t\tcreate animal ;\t\t}\t\tdo die;\t}\taspect default {\t\tdraw circle(0.5) color: #red;\t}}experiment sugarscape type: gui{\tparameter 'Growth rate of sugar:' var: sugarGrowthRate category: 'Environment';\tparameter 'Minimum age of death:' var: minDeathAge &lt;- 60 category: 'Agents';\tparameter 'Maximum age of death:' var: maxDeathAge &lt;- 100 category: 'Agents';\tparameter 'Maximum metabolism:' var: maxMetabolism &lt;- 3 category: 'Agents';\tparameter 'Maximum initial sugar per cell:'  var: maxInitialSugar &lt;- 25 category: 'Environment';\tparameter 'Minimum initial sugar per cell:' var: minInitialSugar &lt;- 5 category: 'Environment';\tparameter 'Maximum range of vision:' var: maxRange &lt;- 6 category: 'Agents';\tparameter 'Replace dead agents ?' var: replace &lt;- true category: 'Agents';\tparameter 'Number of agents:' var: numberOfAgents &lt;- 400 category: 'Agents';\t\toutput {\t\tdisplay grille {\t\t\tgrid sugar_cell;\t\t\tspecies animal;\t\t}\t\tdisplay chart refresh: every(5) {\t\t\tchart 'Energy' type: pie background: #lightgray style: exploded {\t\t\t\tdata \"strong\" value: (animal as list) count (each.sugar &gt; 8) color: #green;\t\t\t\tdata \"weak\" value: (animal as list) count (each.sugar &lt; 9) color: #red;\t\t\t}\t\t}\t\tdisplay chart2 refresh: every(5) {\t\t\tchart 'Energy' type: histogram background: #lightgray {\t\t\t\tdata \"strong\" value: (animal as list) count (each.sugar &gt; 8)  color: #green;\t\t\t\tdata \"weak\" value: (animal as list) count (each.sugar &lt; 9)  color: #red;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Sugarscape-Sugarscape.html"
      }
      ,
    
      "wiki-sugarscape-html": {
        "title": "Sugarscape",
        "content": "SugarscapeThis sub-section is composed of the following models :  sugarscape",
        "url":"/wiki/Sugarscape.html"
      }
      ,
    
      "wiki-syntax-models-casting-html": {
        "title": "Casting Syntax",
        "content": "Casting SyntaxAuthor : A. Drogoul &amp; P. Taillandierdifferent ways of transforming objects and agents in GAML.Code of the model :model Castingspecies to_int {\tinit {\t\twrite sample(int(1));\t\twrite sample(int(1.0));\t\twrite sample(int(\"1\"));\t\twrite sample(int(\"1.0\"));\t\twrite sample(int(°pink));\t\twrite sample(int(true));\t\twrite sample(int(self));\t\twrite sample(int([]));\t\twrite sample(int([0]));\t\twrite sample(int({0,0,0}));\t\twrite sample(int(0::0));\t\twrite sample(int([0::0]));\t\twrite sample(int(#AABBCC));\t\twrite sample(int(°meter));\t\t\t\t\t}}species to_float{\tinit {\t\twrite sample(float(1));\t\twrite sample(float(1.0));\t\twrite sample(float(\"1\"));\t\twrite sample(float(\"1.0\"));\t\twrite sample(float(°pink));\t\twrite sample(float(true));\t\twrite sample(float(self));\t\twrite sample(float([]));\t\twrite sample(float([0]));\t\twrite sample(float(0::0));\t\twrite sample(float([0::0]));\t\twrite sample(float({0,0,0}));\t\twrite sample(float(#AABBCC));\t\twrite sample(float(°meter));\t\t\t\t\t}}species to_string{\tinit {\t\twrite sample(string(1));\t\twrite sample(string(1.0));\t\twrite sample(string(\"1\"));\t\twrite sample(string(\"1.0\"));\t\twrite sample(string(°pink));\t\twrite sample(string(true));\t\twrite sample(string(self));\t\twrite sample(string([]));\t\twrite sample(string([0]));\t\twrite sample(string({0,0,0}));\t\twrite sample(string(#AABBCC));\t\twrite sample(string(°meter));\t\t\t\t\t}}species to_point{\tinit {\t\twrite sample(point(1));\t\twrite sample(point(1.0));\t\twrite sample(point(\"1\"));\t\twrite sample(point(\"1.0\"));\t\twrite sample(point(°pink));\t\twrite sample(point(true));\t\twrite sample(point(self));\t\twrite sample(point([]));\t\twrite sample(point([0]));\t\twrite sample(point(0::0));\t\twrite sample(point([0::0]));\t\twrite sample(point({0,0,0}));\t\twrite sample(point(#AABBCC));\t\twrite sample(point(°meter));\t\t\t\t\t}}species to_list{\tinit {\t\twrite sample(list(1));\t\twrite sample(list(1.0));\t\twrite sample(list(\"1\"));\t\twrite sample(list(\"1.0\"));\t\twrite sample(list(°pink));\t\twrite sample(list(true));\t\twrite sample(list(self));\t\twrite sample(list([]));\t\twrite sample(list([0]));\t\twrite sample(list(0::0));\t\twrite sample(list([0::0]));\t\t\twrite sample(list({0,0,0}));\t\twrite sample(list(#AABBCC));\t\twrite sample(list(°meter));\t\t\t\t\t}}species to_pair{\tinit {\t\twrite sample(pair(1));\t\twrite sample(pair(1.0));\t\twrite sample(pair(\"1\"));\t\twrite sample(pair(\"1.0\"));\t\twrite sample(pair(°pink));\t\twrite sample(pair(true));\t\twrite sample(pair(self));\t\twrite sample(pair([]));\t\twrite sample(pair([0]));\t\twrite sample(pair(0::0));\t\twrite sample(pair([0::0]));\t\twrite sample(pair({0,0,0}));\t\twrite sample(pair(#AABBCC));\t\twrite sample(pair(°meter));\t\t\t\t\t}}species to_map{\tinit {\t\twrite sample(map&lt;float, int&gt;(°meter));\t\twrite sample(map(1));\t\twrite sample(map(1.0));\t\twrite sample(map(\"1\"));\t\twrite sample(map(\"1.0\"));\t\twrite sample(map(°pink));\t\twrite sample(map(true));\t\twrite sample(map(self));\t\twrite sample(map([]));\t\twrite sample(map([0]));\t\twrite sample(map(0::0));\t\twrite sample(map([0::0]));\t\twrite sample(map({0,0,0}));\t\twrite sample(map(#AABBCC));\t\twrite sample(map&lt;int,string&gt;(1));\t\t\t\t\t}}experiment Casting type: gui{\tuser_command \"to int\" {create to_int;}\tuser_command \"to float\" {create to_float;}\tuser_command \"to string\" {create to_string;}\tuser_command \"to point\" {create to_point;}\tuser_command \"to list\" {create to_list;}\tuser_command \"to pair\" {create to_pair;}\tuser_command \"to map\" {create to_map;}}",
        "url":"/wiki/Syntax-models-Casting.html"
      }
      ,
    
      "wiki-syntax-models-lists-html": {
        "title": "Lists",
        "content": "ListsAuthor : Alexis DrogoulExamples of the syntax and various operators used to manipulate the ‘list’ data type. Read the comments and run the model to get a better idea on how to use lists in GAML.Code of the model :model Lists/* Insert your model definition here */species declaring_list_attributes {\t\t/**\t * Declarations of list attributes\t */\t // The simplest declaration identifies empty_list as a list that can contain any type of objects. \t // Its default value will be [] (the empty list) if it is not initialized.\tlist empty_list;\t// To provide it with an initial value, use the '&lt;-' (or 'init:') facet\tlist explicit_empty_list &lt;- [];\t// lists can also be provided with a default size, in which case they are filled with the nil element\tlist list_of_size_10 &lt;-[];// list_size(10); // =&gt; [nil,nil,nil,nil,nil,nil,nil,nil,nil,nil]\t// to fill them with a given initial value, use the 'list_with' operator\tlist list_of_size_10_with_0 &lt;- list_with(10, 0); // =&gt; [0,0,0,0,0,0,0,0,0,0]\t\t// lists can be declared so that they only accept a given type of contents.\t// For instance, empty_list_of_int will only accept integer elements\tlist&lt;int&gt; empty_list_of_int ;\t\t// the value passed to 'list_with' is verified and casted to the contents type of the list if necessary\tlist&lt;int&gt; list_of_int_size_10_filled_with_string&lt;- list&lt;int&gt;(list_with(10,'1')); // list_of_int_size_10_filled_with_string is filled with the casting of '1' to int, i.e. 1\tlist&lt;string&gt; list_of_string_size_10_filled_with_string &lt;- list_with(10,'1'); // while list_of_string_size_10_filled_with_string is filled with the string '1'\t// the casting is also realized if the list is initialized with a value\tlist&lt;int&gt; list_of_int_with_init_of_string &lt;- list&lt;int&gt;(['10', '20']); // =&gt; [10,20]\tlist&lt;float&gt; list_of_float_with_init_of_string &lt;- list&lt;float&gt;(list_of_string_size_10_filled_with_string); // =&gt; [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0]\t// When the casting is not obvious, the default value is used\tlist&lt;float&gt; list_of_float_with_impossible_casting &lt;- list&lt;float&gt;(['A','B']); \t// lists can of course contain lists\tlist&lt;list&gt; list_of_lists &lt;- list_with (5,[]);\t// untyped lists can contain heterogeneous objects\tlist untyped_list &lt;- ['5',5,[5]];\t// the casting applies to all elements when a contents type is defined (note the default last value of 0)\tlist&lt;int&gt; recasted_list_with_int &lt;- list&lt;int&gt;(untyped_list); //=&gt; [5,5,0]\t\tinit {\t\twrite \"\";\t\twrite \"== DECLARING LISTS ==\";\t\twrite \"\";\t\twrite sample(empty_list);\t\twrite sample(explicit_empty_list);\t\twrite sample(list_of_size_10);\t\twrite sample(list_of_size_10_with_0);\t\twrite sample(empty_list_of_int);\t\twrite sample(list_of_int_size_10_filled_with_string);\t\twrite sample(list_of_string_size_10_filled_with_string);\t\twrite sample(list_of_int_with_init_of_string);\t\twrite sample(list_of_float_with_init_of_string);\t\twrite sample(list_of_float_with_impossible_casting);\t\twrite sample(list_of_lists);\t\twrite sample(untyped_list);\t\twrite sample(recasted_list_with_int);\t\twrite \"\";\t\t// Declaring temporary variables of type list follows the same pattern\t\t// but there are fewer facets available (notably, \"size:\" or \"fill_with:\").\t\tlist&lt;string&gt; list_of_string &lt;- ['A','B','C'];\t\t// lists are not always declared litterally and can be obtained from various elements\t\t// by using the casting 'list()' operator\t\t// for instance, list(species_name) will return a list of all the instances of species_name\t\tcreate test_species number:4;\t\tlist&lt;test_species&gt; my_agents &lt;- list(test_species);\t\twrite sample(my_agents);\t\tlist&lt;string&gt; my_names &lt;- my_agents collect each.name;\t\twrite sample(my_names);\t\t// 'create' can directly declare (and return) a list of the agents created. For instance:\t\tcreate test_species number: 5 returns: my_agents2;\t\twrite (sample(my_agents2));\t\t// Some special casting operations are applied to specific types, like points...\t\twrite sample(list(any(my_agents).location));\t\t// ... colors ...\t\twrite sample(list(°pink));\t\t// ... or strings\t\twrite sample(list(\"This is a string\"));\t\t \t}}species test_species{}species accessing_list_elements {\tlist&lt;int&gt; l1 &lt;- [1,2,3,4,5,6,7,8,9,10];\tlist&lt;string&gt; l2 &lt;- ['this','is','a','list', 'of','strings'];\tinit {\t\twrite \"\";\t\twrite \"== ACCESSING LIST ELEMENTS ==\";\t\twrite \"\";\t\twrite sample(l1);\t\twrite sample(l2);\t\twrite sample(first(l1));\t\twrite sample(last(l1));\t\twrite sample(l1 at 1);\t\twrite sample(l1[1]);\t\twrite sample(length(l1));\t\twrite sample(mean(l1));\t\twrite sample(max(l1));\t\twrite sample(min(l1));\t\twrite sample(any(l1));\t\twrite sample(3 among l2);\t\twrite sample(l1 contains 1);\t\twrite sample(l1 contains_all [1,4,6, 14]);\t\twrite sample(l1 contains_any [1,23]);\t\twrite sample(reverse(l2));\t\twrite sample(l1 collect (each + 1));\t\twrite sample(l1 collect (norm({each, each, each})));\t\twrite sample(l1 where (each &gt; 5));\t\twrite sample(l1 count (each &gt; 5));\t\twrite sample(l1 group_by (even(each)));\t\twrite sample(l2 index_by (each + \"_index\"));\t\twrite sample(l1 index_of 100);\t\twrite sample(l2 last_index_of 'is');\t\twrite sample(l2 sort_by each);\t\twrite sample(l2 sort_by length(each));\t\twrite sample(l2 first_with (first(each)  = 'o'));\t\twrite sample(l2 where (length(each) = 2) );\t\twrite sample(l2 with_min_of (length(each)));\t\twrite sample(l2 with_max_of (length(each)));\t\twrite sample(l2 min_of (length(each)));\t\twrite sample(l2 max_of (length(each))); \t\twrite sample(copy_between(l2,1,3));\t\twrite sample(copy_between(l2, 1, length(l2) - 1));\t}}species combining_lists {\tlist&lt;int&gt; l1 &lt;- [1,2,3,4,5,6,7,8,9,10];\tlist&lt;int&gt; l2 &lt;- [1,3,5,7,9];\tinit {\t\twrite \"\";\t\twrite \"== COMBINING LISTS ==\";\t\twrite \"\";\t\twrite sample(list&lt;list&lt;string&gt;&gt;([[1,2,3]]));\t\twrite sample(l1);\t\twrite sample(l2);\t\twrite sample(l1 + l2);\t\twrite sample(l1 - l2);\t\twrite sample(l1 inter l2);\t\twrite sample(l1 union l2);\t\twrite sample(interleave ([l1,l2]));\t\tlist&lt;string&gt; l3 &lt;- list&lt;string&gt;(l1 + l2);\t\twrite \"list&lt;string&gt; l3 &lt;- l1 + l2; \" + sample(l3);\t\twrite sample(l1 as list&lt;float&gt;);\t}}species modifying_lists {\tinit {\t\twrite \"\";\t\twrite \"== MODIFYING LISTS ==\";\t\twrite \"\";\t\ttrace {\t\t// Besides assigning a new value to a list, lists can be manipulated using\t\t// the \"add\", \"remove\" and \"put\" statements. \t\t// Let's define an empty list supposed to contain integer elements\t\tlist&lt;int&gt; l1;\t\t// and add some stuff to it using \"add\"\t\tadd 1 to: l1;\t\tadd 2 to: l1;\t\tadd 3 to: l1;\t\twrite sample(l1);\t\t// the same can be done with the compact syntax introduced in GAMA 1.6 for \"add\"\t\tl1 &lt;+ 4;\t\tl1 &lt;+ 5;\t\twrite sample(l1);\t\t// tired of writing lines of add ? The \"all:\" facet is here to serve:\t\tadd all: [6, 7, 8, 9] to: l1;\t\t// or, in a more compact way:\t\tl1 &lt;&lt;+ [10,11,12,13];\t\twrite sample(l1);\t\t// automatic casting applies to any element added to the list \t\tl1 &lt;+ (int(\"14\"));\t\t// as well as any container of elements\t\tl1 &lt;&lt;+ (list&lt;int&gt;([\"15\", 16.0]));\t\twrite sample(l1);\t\t// elements are by default added to the end of the list\t\t// but they can be introduced at specific positions using the \"at:\" facet\t\tadd 0 to: l1 at: 0;\t\t// or\t\tl1[0] +&lt;- 0;\t\t// what about replacing some elements once they have been added ?\t\t// \"put\" can be used for that purpose\t\tput -2 at: 0 in: l1;\t\t// or, more elegantly:\t\tl1[0] &lt;- -2;\t\t// Trying to put an element outside the bounds of the list will yield an error\t\t// l1[20] &lt;- 10; will return the error \"Index 20 out of bounds of l1\"\t\twrite sample(l1);\t\t// And what about replacing all the values with a new one ?\t\tl1[] &lt;- 0;\t\twrite sample(l1);\t\t// Well, l1 is a bit boring now, isnt't it ?\t\t// Let's fill it again with fresh values\t\tloop i from: 0 to: length(l1) -1 {\t\t\tl1[i] &lt;- rnd(3);\t\t}\t\twrite(sample(l1));\t\t// To remove values from it, the \"remove\" statement (and its compact forms) can be used\t\t// For instance, let's try to remove its first element\t\tremove first(l1) from: l1;\t\t// it can also be written\t\tl1 &gt;- first(l1);\t\twrite(sample(l1));\t\t// To remove all occurrences of a specific element, \"all:\" (or \"&gt;&gt;-\") can be used\t\t// For instance:\t\tl1 &gt;&gt;- 2;\t\tl1 &gt;&gt;- 1;\t\t// or, written using the long syntactic form\t\tremove all: 1 from: l1;\t\twrite sample(l1);\t\t// To remove all the elements present in a given container, the same syntax can be used\t\tl1 &gt;&gt;- [0,3];\t\twrite (\"After l1 &gt;&gt;- [0,3] : \" + sample( l1));\t\t// By all means, l1 should now be empty! Let's fill it again\t\tloop times: 20 {\t\t\tl1 &lt;+ rnd(3);\t\t}\t\twrite(sample(l1));\t\t// It is also possible to remove an index rather than a value (this will remove the \t\t// value present at this index )\t\tl1[] &gt;- 2;\t\twrite(\"After l1[] &gt;- 2 : \" + sample(l1));\t\t// Removing several indexes can be written using a syntax similar to the one used\t\t// for removing values\t\tl1[] &gt;&gt;- [1,2,4];\t\twrite(\"After l1[] &gt;&gt;- [1,2,4] : \" + sample(l1));\t\t// Random things to try out\t\t// Using casting back and forth: all number now vary from 1000 to 31000\t\tl1 &lt;- list&lt;int&gt;(l1 collect (string(each) + \"1000\"));\t\twrite sample(l1);\t\t// Removing elements based on a criteria\t\tl1 &gt;&gt;- l1 select (each &gt; 20000);\t\t// Removing duplicates\t\tl1 &lt;- remove_duplicates(l1);\t\t// Another way (see \"../Maps.gaml\")\t\tl1 &lt;- map(l1).values; \t\twrite(sample(l1));\t}}\t}species looping_on_lists {\tinit {\t\twrite \"\";\t\twrite \"== LOOPING ON LISTS ==\";\t\twrite \"\";\t\t// Besides iterator operators (like \"collect\", \"where\", etc.), which provide \t\t// functional iterations (i.e. filters), one can loop over lists using the imperative\t\t// statement 'loop'\t\tlist&lt;string&gt; l1 &lt;- list(\"This is a list of strings\");\t\twrite sample(l1);\t\tint i &lt;- 0;\t\tlist l2 &lt;- [];\t\t// Here, the value of 's' will be that of each element of the list\t\tloop s over: l1 {\t\t\ti &lt;- i + 1;\t\t\tl2 &lt;&lt; \"Word #\" + i + \": \" + s;\t\t}\t\twrite sample(l2);\t\t// 'loop' can also directly use an integer index (remember lists have a zero-based index)\t\tl2 &lt;- [];\t\tloop i from: 0 to: length(l1) - 1 step:2 {\t\t\tl2 &lt;&lt; l1[i];\t\t}\t\twrite sample(l2);\t\t// Finally, list containing agents can be the support of implicit loops in the 'ask' statement\t\tcreate test_species number: 5 returns: my_agents;\t\tl2 &lt;- [];\t\task my_agents{\t\t\t// attributes of each agent can be directly accessed\t\t\tl2 &lt;&lt; name;\t\t}\t\twrite sample(l2);\t\t// ... which is formally equivalent to:\t\tl2 &lt;- [];\t\tl2 &lt;&lt;+ my_agents collect each.name;\t\twrite sample(l2);\t\t// ... or, even simpler (since the casting of an agent to string returns its name)\t\tlist&lt;string&gt; l3 &lt;- list&lt;string&gt;(my_agents);\t\twrite sample(l3);\t\t// Powerful filter expressions can be built by combining the various 'iterator' operators\t\tl3 &lt;- list&lt;string&gt;(my_agents where even(int(each))) collect (\"Agent \" + each + \" has an even id\");\t\twrite sample(l3);\t}}experiment Lists type: gui {\tuser_command \"Declaring lists\" {create declaring_list_attributes;}\tuser_command \"Accessing lists\" {create accessing_list_elements;}\tuser_command \"Combining lists\" {create combining_lists;}\tuser_command \"Modifying lists\" {create modifying_lists;}\tuser_command \"Looping on lists\" {create looping_on_lists;}\t}",
        "url":"/wiki/Syntax-models-Lists.html"
      }
      ,
    
      "wiki-syntax-models-maps-html": {
        "title": "Maps",
        "content": "MapsAuthor : Alexis DrogoulExamples of the syntax and various operators used to manipulate the ‘map’ data type. Read the comments and run the model to get a better idea on how to use maps in GAML.Code of the model :model Maps/* Maps is a data structure consisting of a list of pair&lt;key, value&gt; where each key is unique */species declaring_map_attributes {\t\t/**\t * Declarations of map attributes\t */\t // The simplest declaration identifies empty_map as a map that can contain any type of objects. \t // Its default value will be [] (the empty list/map) if it is not initialized.\tmap empty_map;\t// To provide it with a literal initial value, use the '&lt;-' (or 'init:') facet and pass a map\tmap explicit_empty_map &lt;- [];\t// Or, more explicitely\tmap explicit_empty_map2 &lt;- map([]);\t// Values can be declared litterally in this map, which is nothing more than a list of pair objects\tmap explicit_filled_map &lt;- [\"First\"::1, \"Second\"::2];\t// If a map is initialized with a list that contains non-pair objects, the pairs element::element are added to the map\tmap map_initialized_with_list &lt;- map&lt;int, int&gt;([1,2,3,4]);\t// maps can be declared so that they only accept a given type of keys and values\t// For instance, empty_map_of_int will accept string keys and integer values\tmap&lt;string, int&gt; empty_map_of_int;\t// The appropriate casting is realized if the map is initialized with a list of values\tmap&lt;string, int&gt; map_of_int_with_init_of_string &lt;- map&lt;string, int&gt;(['10', '20']); // =&gt; ['10'::10,'20'::20]\t// or with another map\tmap&lt;int, float&gt; map_of_float_with_init_of_map &lt;- map&lt;int, float&gt;(map_initialized_with_list); \t// When the casting is not obvious, the default values are used\t// Here, the list is first casted to return pairs, and they are casted to pair&lt;string, float&gt;\tmap&lt;string, float&gt; map_of_float_with_impossible_casting &lt;- map&lt;string, float&gt;(['A','B']); \t// maps can of course contain maps\tmap&lt;string, map&gt; map_of_maps &lt;- map&lt;string, map&gt;(['A'::[], 'B'::[]]);\t// untyped maps can contain heterogeneous objects\tmap untyped_map &lt;- [10::'5','11'::5,[12]::[5]];\t// the casting applies to all elements when a key and contents type is defined\tmap&lt;int, string&gt; recasted_map_with_int_and_string &lt;- map&lt;int, string&gt;(untyped_map); //=&gt; [5,5,0]\t\tinit {\t\twrite \"\";\t\twrite \"== DECLARING MAPS ==\";\t\twrite \"\";\t\twrite sample(empty_map);\t\twrite sample(explicit_empty_map);\t\twrite sample(empty_map_of_int);\t\twrite sample(explicit_filled_map);\t\twrite sample(map_initialized_with_list);\t\twrite sample(map_of_int_with_init_of_string);\t\twrite sample(map_of_float_with_init_of_map);\t\twrite sample(map_of_float_with_impossible_casting);\t\twrite sample(map_of_maps);\t\twrite sample(untyped_map);\t\twrite sample(recasted_map_with_int_and_string);\t\twrite \"\";\t\t// Declaring temporary variables of type map follows the same pattern\t\tmap&lt;int,string&gt; map_of_string &lt;- [1::'A',2::'B',3::'C'];\t\t// maps are not always declared litterally and can be obtained from various elements\t\t// by using the casting 'map()' operator\t\t// for instance, map(species_name) will return a list of all the agents of species_name\t\t// using pairs of agent::agent. If the key is explicit, it is used in the casting:\t\tcreate test_species number:4;\t\tmap&lt;string, test_species&gt; my_agents &lt;- map&lt;string, test_species&gt;(test_species);\t\twrite sample(my_agents);\t\t// Some special casting operations are applied to specific types, like agents (returns a copy of their attributes)\t\twrite sample(map(any(my_agents)));\t\t// The 'as_map(pair)' iterator operator also provides a way to build more complex maps\t\twrite sample(list(\"This is a string\") as_map (length(each)::each));\t\t// As well as \"group_by\" or \"index_by\"\t\twrite sample(my_agents index_by (each distance_to {0,0}));\t\twrite sample([1,2,3,4,5,6,7] group_by ((each mod 3) = 0)); \t}}species test_species{}species accessing_map_elements {\tmap&lt;int, int&gt; l1 &lt;- map&lt;int, int&gt;([1,2,3,4,5,6,7,8,9,10]);\tmap&lt;int, string&gt; l2 &lt;- [1::'this',2::'is',3::'a',4::'list', 5::'of',6::'strings'];\tinit {\t\twrite \"\";\t\twrite \"== ACCESSING MAPS ELEMENTS ==\";\t\twrite \"\";\t\twrite sample(l1);\t\twrite sample(l2);\t\twrite sample(first(l1));\t\twrite sample(last(l1));\t\twrite sample(l1 at 1);\t\twrite sample(l1[1]);\t\twrite sample(length(l1));\t\twrite sample(mean(l1));\t\twrite sample(max(l1));\t\twrite sample(min(l1));\t\twrite sample(any(l1));\t\twrite sample(3 among l1);\t\twrite sample(l1 contains 1);\t\twrite sample(l1 contains_all [1,4,6, 14]);\t\twrite sample(l1 contains_any [1,23]);\t\twrite sample(reverse(l2));\t\twrite sample(l1 collect (each + 1));\t\twrite sample(l1 collect (norm({each, each, each})));\t\twrite sample(l1 where (each &gt; 5));\t\twrite sample(l1 count (each &gt; 5));\t\twrite sample(l1 group_by (even(each)));\t\twrite sample(l2 index_by (each + \"_index\"));\t\twrite sample(l1 index_of 100);\t\twrite sample(l2 last_index_of 'is');\t\twrite sample(l2 sort_by each);\t\twrite sample(l2 sort_by length(each));\t\twrite sample(l2 first_with (first(each)  = 'o'));\t\twrite sample(l2 where (length(each) = 2) );\t\twrite sample(l2 with_min_of (length(each)));\t\twrite sample(l2 with_max_of (length(each)));\t\twrite sample(l2 min_of (length(each)));\t\twrite sample(l2 max_of (length(each)));\t}}species combining_maps {\tmap&lt;int, int&gt; l1 &lt;- map&lt;int, int&gt;([1,2,3,4,5,6,7,8,9,10]);\tmap&lt;int, int&gt; l2 &lt;- map&lt;int, int&gt;([1,3,5,7,9]);\tinit {\t\twrite \"\";\t\twrite \"== COMBINING MAPS ==\";\t\twrite \"\";\t\twrite sample(l1);\t\twrite sample(l2);\t\twrite sample(l1 + l2);\t\twrite sample(l1 - l2);\t\twrite sample(l1 inter l2);\t\twrite sample(l1 union l2);\t\tmap&lt;string&gt; l3 &lt;- map&lt;int, string&gt;(l1 + l2);\t\twrite \"map&lt;string&gt; l3 &lt;- l1 + l2; \" + sample(l3);\t}}species modifying_maps {\tinit {\t\twrite \"\";\t\twrite \"== MODIFYING MAPS ==\";\t\twrite \"\";\t\t// Besides assigning a new value to a map, maps can be manipulated using\t\t// the \"add\", \"remove\" and \"put\" statements. \t\t// Let's define an empty list supposed to contain integer keys and values\t\ttrace { map&lt;int, int&gt; m1 &lt;- [0::0]; \t\t// and add some stuff to it using \"add\"\t\tadd 1::1 to: m1;\t\tadd 2::2 to: m1;\t\tadd 3::3 to: m1;\t\twrite sample(m1);\t\t// the same can be done with the compact syntax introduced in GAMA 1.6.1 for \"add\"\t\tm1 &lt;+ 4::4;\t\tm1 &lt;+ 5::5;\t\twrite sample(m1);\t\t// tired of writing lines of add ? The \"all:\" facet is here to serve:\t\tadd [6, 7, 8, 9] to: m1 all: true;\t\t// or, in a more compact way:\t\tm1 &lt;&lt;+ [10,11,12,13];\t\twrite sample(m1);\t\t// automatic casting applies to any element added to the map\t\tm1 &lt;+ int(\"14\");\t\t// as well as any container of elements\t\tm1 &lt;&lt;+ map&lt;int, int&gt;([15::\"15\", 16::16.0]);\t\twrite sample(m1);\t\t// elements are by default added to the map while their keys are unique\t\t// So, what about replacing some elements once they have been added ?\t\t// \"put\" can be used for that purpose\t\tput -2 at: 0 in: m1;\t\t// or, more simply:\t\tm1[0] &lt;- -3;\t\t// Trying to put an element outside the \"bounds\" of the map will of course not yield an error\t\t m1[20] &lt;- 10; \t\twrite sample(m1);\t\t// And what about replacing all the values with a new one ?\t\tm1[] &lt;- 0;\t\twrite(\"m1[] &lt;- 0;\");\t\twrite sample(m1);\t\t// Well, m1 is a bit boring now, isnt't it ?\t\t// Let's fill it again with fresh values\t\tloop i over: m1.keys {\t\t\tm1[i] &lt;- rnd(3);\t\t}\t\twrite(sample(m1));\t\t// To remove values from it, the \"remove\" statement (and its compact \"&gt;-\" form) can be used\t\t// WARNING: this form operation on the *values* of the map (i.e. it will remove the first pair\t\t// whose value = 0\t\tremove 0 from: m1;\t\t// it can also be written\t\tm1 &gt;- 0;\t\twrite(sample(m1));\t\t// To remove all occurrences of pairs with a specific value, \"all:\" (or \"&gt;&gt;-\") can be used\t\t// For instance:\t\tm1 &gt;&gt;- 2;\t\t// or, written using the long syntactic form\t\tremove 1 from: m1 all: true;\t\twrite sample(m1);\t\t// To remove keys instead, the same syntax can be used, but on the keys of the map (i.e. map[])\t\tm1[] &gt;- 1; // This will remove the (unique) pair whose key = 1\t\t// The equivalent long syntax is\t\tremove key: 1 from: m1;\t\t// To remove a set of keys, the following syntax can be used\t\tm1[] &gt;&gt;- [2,3,4]; \t\t// And to remove all the keys present in a given map (using the 'keys' attribute)\t\tm1[] &gt;&gt;- m1.keys;\t\twrite sample(m1);\t\t// By all means, m1 should now be empty! Let's fill it again\t\tint i &lt;- 0;\t\tloop times: 20 {\t\t\ti &lt;- i + 1;\t\t\tm1 &lt;+ i::rnd(3);\t\t}\t\t// Random things to try out\t\t// Using the 'pairs' attribute: all number now vary from 1000 to 1003\t\tm1 &lt;- m1.pairs as_map (each.key::((each.value) + 1000));\t\twrite sample(m1);\t\t// Removing values based on a criteria\t\tm1 &gt;&gt;- m1 select (each &gt; 1001);\t\twrite(sample(m1));\t}\t}\t}species looping_on_maps {\tinit {\t\twrite \"\";\t\twrite \"== LOOPING ON MAPS ==\";\t\twrite \"\";\t\t// Besides iterator operators (like \"collect\", \"where\", etc.), which provide \t\t// functional iterations (i.e. filters), one can loop over maps using the imperative\t\t// statement 'loop'\t\tlist&lt;string&gt; strings &lt;- list(\"This a list of string\");\t\twrite sample(strings);\t\tmap&lt;string, string&gt; l1 &lt;- strings as_map (first(each)::each);\t\twrite sample(l1);\t\tint i &lt;- 0;\t\tlist l2 &lt;- [];\t\t// Here, the value of 's' will be that of each value of each pairs of the list\t\tloop s over: l1 { // equivalent to 'loop s over: l1.values'\t\t\ti &lt;- i + 1;\t\t\tl2 &lt;&lt; \"Word #\" + i + \": \" + s;\t\t}\t\twrite sample(l2);\t\t// To loop on the keys of l1, simply use its 'keys' attribute\t\tl2 &lt;- [];\t\t i &lt;- 0;\t\tloop s over: l1.keys{\t\t\ti &lt;- i + 1;\t\t\tl2 &lt;&lt; \"Key #\" + i + \": \" + s;\t\t}\t\twrite(sample(l2));\t\t// Looping on indexes allows to gain access to each element in turn\t\tl2 &lt;- [];\t\tloop i over: l1.keys {\t\t\tl2 &lt;+ l1[i];\t\t}\t\twrite sample(l2);\t\t// Finally, maps containing agents can be the support of implicit loops in the 'ask' statement\t\tcreate test_species number: 5 returns: my_agents;\t\tmap&lt;int, test_species&gt; map_of_agents &lt;- map&lt;int, test_species&gt;(my_agents);\t\twrite(sample(map_of_agents));\t\tl2 &lt;- [];\t\task map_of_agents{\t\t\t// attributes of each agent can be directly accessed\t\t\tl2 &lt;&lt; name;\t\t}\t\twrite sample(l2);\t\t// Of course, this can be done more simply like this\t\tl2 &lt;- map_of_agents collect each.name;\t\t}\t}experiment Maps type: gui {\tuser_command \"Declaring maps\" {create declaring_map_attributes;}\tuser_command \"Accessing maps\" {create accessing_map_elements;}\tuser_command \"Combining maps\" {create combining_maps;}\tuser_command \"Modifying maps\" {create modifying_maps;}\tuser_command \"Looping on maps\" {create looping_on_maps;}\t}",
        "url":"/wiki/Syntax-models-Maps.html"
      }
      ,
    
      "wiki-syntax-models-syntax-1-6-html": {
        "title": "Syntax",
        "content": "SyntaxAuthor : Alexis DrogoulAn overview of the new syntactic constructs that have been introduced in GAMA 1.6Code of the model :@no_warningmodel syntax/** * The global section can now sport skills and control, just like other agents.  * The example below shows a potentially moving world that can be controlled by a finite state machine. */global skills: [moving] control: fsm {/** * EQUATIONS */ \tfloat x;\tfloat y;\tfloat t;\tequation eq {\t\tdiff(x, t) = x / 2;\t\tdiff(y, t) = x + y * 2;\t}\treflex solving {solve eq step: 1 method: rk4;}\t/**  * ATTRIBUTES */// Attributes can be declared in different ways, ranging from \"classic\"...\tlist&lt;int&gt; a1 const: true &lt;- [1, 2, 3] of: int;\tlist a2 &lt;- [1, 2, 3] of: int;\t// ... to \"compact\" Java-like syntax.\tlist&lt;int&gt; a3 &lt;- [1, 2, 3];\t// The declaration of a default size/value in containers is now working correctly\tlist&lt;float&gt; f &lt;- list_with(2000,0.0);\t// Functions can be declared using the regular facet \"-&gt;\" / \"function:\" \tint b1 -&gt; { 100 + length(a1) };\tint b2 function: { 100 + length(a1) };\t// ... or using a block (like a statement -- note the absence of semi-column at the end)\tint b3 {\t\t100 + length(a1)\t}\tstate first_state initial: true {\t//...\t}\tinit {\t\tcreate species0 number: 20;\t}\t\t/**\t * UNITS\t */// The usage of units is improved ( \"#\" being replaced by \"°\"), and they can be combined\tfloat c &lt;- 10 °meter;\tfloat speed &lt;- 10 °meter / °sec;\t// Attributes can (finally!) be named after unit names\tfloat meter &lt;- 10.0;\t// Some mathematical constants have been introduced alongside units\tfloat pi_4 &lt;- °pi / 4;\tfloat e &lt;- °e;\t/**\t  * ACTIONS\t  */\t// Actions can also be declared in different ways. Classic:\taction dummy1 type: list of: int {\t\targ a type: int default: 100;\t\targ b type: float;\t\treturn [a, int(b)];\t}\t// Semi-classic (prefixed by the type)\tlist dummy2 of: int {\t\targ a type: int default: 100;\t\targ b type: float;\t\treturn [a, int(b)];\t}\t//Compact\tlist&lt;int&gt; dummy1 (int a &lt;- 100, float b) {\t\treturn [a, int(b)];\t}\t// An action that returns nothing can still be called \"action\"\taction dummy_void {\t\twrite \"dummy_void\";\t}\t/**\t * DEALING WITH VARIABLES\t */\treflex variables {\t// Temporary variables can use the same syntax as attributes. The classic form:\t\t//let name: t1 type: int value: length(a1);\t\t// is equivalent to the more compact one:\t\tint t2 &lt;- length(a1);\t\t// Assigning a value to variables is also sporting a new syntax \t\tset t2 value: 100;\t\t// ... can be replaced by \t\tset t2 &lt;- 100;\t\t// ... or even by\t\tt2 &lt;- 100;\t\t// Species can now act as direct containers of their agents..\t\tlist&lt;species0&gt; spec_with_location &lt;- species0 select (each.location = { 0, 0 });\t\tspecies0 agent0 &lt;- species0[10];\t\twrite string(agent0);\t\t// ...  and agents as direct containers of their attributes (mimicking the internal attributes map). This \"virtual map\" will now contain, in addition to the attributes, \t\t// all the variables loaded from CSV, SQL or shape files (some stored in the agent itself, others in the shape).\t\tagent0[\"departure\"] &lt;- { 0, 0 };\t\twrite string(agent0);\t\t// Keys are not necessarily strings, by the way ! A warning is emitted in such cases, but it is just a warning.\t\tagent0[0] &lt;- 0;\t\t// Accesses can be combined\t\tspecies0[10].name &lt;- \"A new name\"; // which is equivalent to (spec at 10).name = \"A new name\";\t\t// Points can be used (with or without curly parentheses) to access agents in species\t\tspecies0 agent1 &lt;- species0[10, 10]; // returns the agent closest to point {10,10} for a \"regular\" species\t\t// The behavior is a bit tweaked for grids, to allow for a \"natural\" access\t\tmy_grid cell0 &lt;- my_grid[10, 10]; // Here, it is the cell at {10, 10} in the matrix of cells\t\t// Shapes also act as containers of CVS/Shapefile attributes (in case they are loaded without being attributed to an agent), as well as 3D properties (for the display).\t\tagent0.name &lt;- string(agent0.shape[\"ID\"]);\t\tgeometry geom &lt;- square(100);\t\tgeom[\"type\"] &lt;- \"cube\";\t\t\t\t\t\t// All these attributes can be accessed using the casting of agents to map\t\twrite string(map(agent0));\t\t//This access can be used everywhere, easing the use of shape files (and data files in general)\t\tlist&lt;geometry&gt; shapes &lt;- list&lt;geometry&gt;(file(\"something.shp\"));\t\t// If we suppose val1, val2, etc. are defined in the shape file\t\tfloat max &lt;- min(shapes collect float(each[\"val1\"]));\t\t//To allow for an easier access in case the modeler only uses agents, agents' attributes can \"pass through\" towards their shape's attributes \t\t//(in case the same attribute has not been defined in the agent, of course)\t\tcreate species0 from: shapes;\t\tmax &lt;- min(species0 collect float(each[\"val1\"])); // equivalent to each.shape[\"val1\"]. \t\t//This last sentence only works, however, for *reading* values.\t\tany(species0)[\"val1\"] &lt;- 100; // will result in the creation of a new attribute in the agent (not in its shape)\t\tany(species0).shape[\"val1\"] &lt;- 100; // will be correct in that case\t\t// Container variables have seen their usability clearly improved \t\tmap m &lt;- map([]);\t\tlist&lt;int&gt; l &lt;- [1, 2, 3, 4, 5];\t\t// Adding a value\t\tadd 1 to: l;\t\t// ... can now be written\t\tl &lt;+ 1;\t\t// Removing a value\t\tremove 1 from: l;\t\tremove \"type\" from: geom;\t\t// ... can now be written\t\tl &gt;- 1;\t\tgeom &gt;- \"type\";\t\tany(species0)[] &gt;- \"name\"; // removes the \"name\" attribute from a random agent. Can be dangerous in some cases... \t\t// Setting/putting a value\t\tput \"a\" at: 'key' in: m;\t\tput 1 at: 0 in: l;\t\t// ... can now be written\t\tm['key'] &lt;- \"a\";\t\tl[0] &lt;- 1;\t\tlist&lt;list&gt; ll &lt;- [];\t\tll &lt;+ []; // [[]]\t\tll[0] &lt;+ 10; // [[10]]\t}\t// TODO Species can now be written within the \"global\" section (to enforce the idea that the top-level species are indeed contained in the world)\tspecies inside_global {\t}\t/**\t  * INVOCATION OF ACTIONS\t  */\treflex calling_actions {\t// IN IMPERATIVE MODE (i.e. in a statement)\t// The classic way\t\tdo dummy1 with: [a::10, b::100.0];\t\t// Another by distributing the arguments\t\tdo dummy1 a: 10 b: 100.0;\t\t// The new alternative one \t\tdo dummy1(a: 10, b: 100.0);\t\task any(species1) {\t\t\tdo goto(target: { 10, 10 }, speed: 100);\t\t}\t\t// ... which has been introduced to unify the functional/imperative use of actions.\t\t// And finally the new functional way, probably reserved to simple calls (as all the arguments must be passed).\t\tdo dummy1(10, 100.0);\t\t// IN FUNCTIONAL MODE (i.e. as part of expressions)\t\t// The \"classic\" way of calling actions. Note that in that case, dummy1 is used like a binary operator (callee on the left, argument map on the right)\t\tlist d1 &lt;- self dummy1 [a::10, b::100.0];\t\t// First improvement, argument maps can now be simplified, which results in a functional syntax with named arguments\t\tlist d2 &lt;- self dummy1 (b: 100.0); // a is not passed as it has a default value.\t\t// To improve the readability of this way of calling actions, the dotted notation is now allowed as well \t\tlist d3 &lt;- self.dummy1(a: 100, b: 100.0);\t\tfloat s &lt;- any(species1).compute_speed_using_an_action(max: 100);\t\t// Finally, the functional syntax is also introduced. In that case, all the arguments need to be passed as they are not named.\t\t// This unifies the way of calling operators and actions furthermore. \t\t// The action can be called as a n_ary operator, and in that case, the callee is implicitely the agent that executes the call\t\tlist d4 &lt;- dummy1(10, 100.0);\t\t// And it can also be called using the \"dotted\" syntax, in which case the callee needs to be explicit (can be \"self\" of course)\t\tpath p &lt;- world.move(100, 45, shape); // speed, heading, bounds\t\t/** \t \t *  As a summary, the syntaxes kept for future developments of models will likely be:  \t \t */// CALLING WITH NAMED ARGUMENTS + OPTIONAL DOTTED SYNTAX IN EXPRESSIONS + IMPLICIT CALLEE IN CASE OF SELF\t\t// This method is convenient as it allows to pass only some arguments (if defaults are defined, which is implicitely the case in primitives), \t\t// but also to pass them in any order\t\tdo wander(speed: 100, amplitude: 10);\t\tpath p1 &lt;- path(self.wander(amplitude: 10, speed: 100));\t\tpath p2 &lt;- path(self wander (speed: 100, bounds: square(10)));\t\tpath p3 &lt;- path(wander(speed: 100));\t\tpath p4 &lt;- path(wander());\t\t// CALLING WITH COMPLETE ARGUMENTS + OPTIONAL DOTTED SYNTAX IN EXPRESSIONS + IMPLICIT CALLEE IN CASE OF SELF\t\t// This method is convenient as it follows the functional syntax of operators and then allows to declare \"quasi-operators\" in species, even to redefine existing ones.\t\tdo wander(100, 100, self.shape); // speed, amplitude, bounds as defined in primitive wander\t\tint d5 &lt;- self.max(10, 100);\t\tint d6 &lt;- self max (10, 100);\t\tint d7 &lt;- max(10, 100);\t\tlist others &lt;- filter(species1);\t\t// As a side note, the new syntax for arguments maps is not only usable in action calls, but also in create, for instance\t\tcreate species0 with: (location: { 100, 100 }, name: \"\");\t}\t// The ternary operator \"(condition) ? statement_if_condition_true : statement_if_condition_false\" can be used as follow :\tint max (int i, int j) {\t\treturn i &gt; j ? i : j;\t}\tlist&lt;agent&gt; filter (container&lt;agent&gt; my_agents) {\t\treturn my_agents where (each.location = nil);\t}\t/**\t  * USE OF OPERATORS \t  */\treflex operators {\t// All the operators can now be written using a function-like form\t// It is true for unary operators (as before)\t\tbool a &lt;- flip(0.4);\t\t// .. but also for binary ones (in addition to the classic way)\t\tint b &lt;- div(100, 23) + 100 div 23;\t\tgeometry c1 &lt;- union(square(1), circle(10));\t\t// The only exception to this rule is that of the built-in operators (like \"and\"/\"or\") and the ones whose names are not alphanumeric (like \"+\")\t\t// The big news is that operators are now allowed to be written using any number of parameters (not 1 or 2)\t\t// Here is an example with the \"between\" operator (written specially in Java to test this feature)\t\t// @operator(value = \"between\", can_be_const = true)\t\t// public static Boolean between(final Integer a, final Integer inf, final Integer sup) {\t\t//    \tif ( inf &gt; sup ) { return false; }\t\t//\t\treturn a &gt;= sup ? false : a &gt; inf; \t\t// }\t\tbool e1 &lt;- between(5, 1, 10);\t}\t/**\t  * DEFINITION OF ASPECTS\t  */\taspect default {\t// draw now accepts any kind of arguments and decides what to do based on the type of the argument\t\tdraw circle(1);\t\tdraw name;\t\tdraw file(\"image.jpg\");\t\t// special units (that take a value in the drawing scope) have been introduced to allow for a better control of the display\t\t// This statement will draw a circle of radius 10 pixels, whatever the level of zoom and size of the display\t\tdraw circle(10 °px);\t\tdraw \"Display dimensions: \" + °display_width + \" \" + °display_height;\t}}/** Species can \"mirror\" a list of agents (or another species). That is, their population is dynamically computed after the list or species mirrored.* Their instances, which are actually \"proxy\" agents, possess an attribute called \"target\" that points towards the agent they mirror. Very useful for building graphs, for instance.* The update of the population tries to preserve, as much as possible, the existing mapping (that is, proxy agents do not change targets if they do not die or disappear from the list) */species species0 {\tfloat speed &lt;- float(rnd(1000));}species species1 mirrors: species0 skills: [moving] {\tpoint location update: target.location + { 10, 10 };\tfloat speed1 update: self compute_speed_using_an_action (); // No parameter as \"max\" is defaulted\tfloat speed2 update: compute_speed_using_a_functional_attribute;\tfloat compute_speed_using_a_functional_attribute {\t\tspeed of target\t}\tfloat compute_speed_using_an_action (int max &lt;- 100) {\t\treturn min([max, int(speed of target)]);\t}\tinit {\t\twrite \"I am \" + self.name + \" and my target is \" + target.name;\t}}grid my_grid width: 100 height: 100 {}experiment exp1 type: gui {\toutput {\t\tdisplay Display type: opengl {\t\t// Layers include a new keyword, \"graphics\", that allows to draw arbitrary shapes using the syntax found in the aspects of species\t\t// The same capability will be soon added to species/agents layers (in order to define on-the-fly aspects without changing the species itself)\t\t\tgraphics 'G' {\t\t\t\tdraw sphere(10) at: { 50, 50 };\t\t\t\tif (true) {\t\t\t\t\tdraw \"true\";\t\t\t\t} else {\t\t\t\t\tdraw \"false\";\t\t\t\t}\t\t\t}\t\t}\t}}",
        "url":"/wiki/Syntax-models-Syntax-(1.6).html"
      }
      ,
    
      "wiki-syntax-models-html": {
        "title": "Syntax models",
        "content": "Syntax modelsThis sub-section is composed of the following models :      Casting Syntax        Lists        Maps        Syntax  ",
        "url":"/wiki/Syntax-models.html"
      }
      ,
    
      "wiki-syntax-html": {
        "title": "Syntax",
        "content": "SyntaxThis section is composed of the following sub-section :  Syntax models",
        "url":"/wiki/Syntax.html"
      }
      ,
    
      "wiki-threed-html": {
        "title": "3D Tutorial",
        "content": "3D TutorialThis tutorial introduces the 3D features offered by GAMA.Model Overview&lt;img src=’http://img.youtube.com/vi/6ZlBU6xTcfw/0.jpg’ width=’425’ height=344 /&gt;Step ListThis tutorial is composed of 3 steps corresponding to 3 models. For each step we present its purpose, an explicit formulation and the corresponding GAML code.  Basic model  Moving cells  Moving cells with neighbours",
        "url":"/wiki/ThreeD.html"
      }
      ,
    
      "wiki-threed-step1-html": {
        "title": "1. Basic Model",
        "content": "1. Basic ModelIn this first step, we will see how to define a 3D environment and populate it.FormulationInitialize a 3D world with a population of cells placed randomly in a 3D 100x100x100 cube.  Definition of the cells species  Definition of the nb_cells parameter  Creation of nb_cells cells agents randomly located in the 3D environment size: 100x100x100.Model DefinitionIn this model we define one species of agent: the cells agents. The agents will be just displayed as a blue sphere of radius 1.species cells{                        aspect default {    draw sphere(1) color:#blue;     }}Global SectionGlobal variableDefinition of a global variable nb_cells of type int representing the number of cells agents.global {   int nb_cells &lt;-100;}Model initializationDefinition of the init block in order to create nb_cells cells agents. By default an agent is created with a random location in x and y, and a z value equal to 0. In our case we want to place the cells randomly in the 3D environment so we set a random value for x, y and z.create cells number: nb_cells {  location &lt;- {rnd(100), rnd(100), rnd(100)};}ExperimentIn our model, we define a basic gui experiment called Tuto3D :experiment Tuto3D type: gui {}InputDefinition of a parameter from the the global variable nb_cells :experiment Tuto3D type: gui {   parameter \"Initial number of cells: \" var: nb_cells min: 1 max: 1000 category: \"Cells\";\t}OutputIn our model, we define a display to draw the cells agents in a 3D environment.output {  display View1 type:opengl {    species cells;  }}Complete ModelThis model is available in the model library (under Tutorials &gt; 3D) and the GIT version of the model can be found here Model 01.gamlmodel Tuto3Dglobal {  int nb_cells &lt;-100;\t  init {     create cells number: nb_cells {       location &lt;- {rnd(100), rnd(100), rnd(100)};           }   }  }   species cells{                        aspect default {    draw sphere(1) color:#blue;     }}experiment Tuto3D  type: gui {  parameter \"Initial number of cells: \" var: nb_cells min: 1 max: 1000 category: \"Cells\" ;\t  output {    display View1 type:opengl {      species cells;    }  }}",
        "url":"/wiki/ThreeD_step1.html"
      }
      ,
    
      "wiki-threed-step2-html": {
        "title": "2. Moving Cells",
        "content": "2. Moving CellsThis second step model adds the moving3D skills to the cell agents and simply makes move the cells agent by defining a reflex that will call the action move. We will also add additional visual information to the display.Formulation  Redefining the shape of the world with a 3D Shape.  Attaching new skills (moving3D) to cells agent.  Modify cells aspect  Add a graphics layer&lt;img src=’http://img.youtube.com/vi/_QqUbC0MWRU/0.jpg’ width=’425’ height=344 /&gt;Model DefinitionGlobal SectionGlobal variableWe use a new global variable called _environmentSize_that to define the size of our 3D environment.In the global section we define the new variableint environmentSize &lt;-100;Then we redefine the shape of the world (by default the shape of the world is a 100x100 square) as cube that will have the size defined by the environment_size variable. To do so we change the shape of the world in the global section:geometry shape &lt;- cube(environmentSize);\tModel initializationWhen we create the cells agent we want to place them randomly in the 3D environement. To do so we set the location with a random value for x, y and z between 0 and environmentSize.create cells number: nb_cells {   location &lt;- {rnd(environmentSize), rnd(environmentSize), rnd(environmentSize)};       }Moving3D skillsIn the previous example, we only created cells agent that did not have any behavior. In this step we want to make move the cells agent. To do so we add a moving3D skills to the cells.More information on built-in skills proposed by Gama can be found herespecies cells skills:[moving3D]{...  \t}Then we define a new reflex for the species cells that consists in calling the action move bundled in moving3D skills.reflex move{  do move;}\t                    Finally we modify a bit the aspect of the sphere to set its size according to the environmentSize global variable previously defined.aspect default {  draw sphere(environmentSize*0.01) color:#blue;   }ExperimentThe experiment is the same as the previous one except that we will display the bounds of the environment by using the graphics layer.graphics \"env\"{  draw cube(environmentSize) color: #black empty:true;\t}Outputoutput {  display View1 type:opengl{    graphics \"env\"{      draw cube(environmentSize) color: #black empty:true;\t    }    species cells;    }}Complete ModelThe GIT version of the model can be found here Model 02.gamlmodel Tuto3D   global {  int nb_cells &lt;-100;  int environmentSize &lt;-100;  geometry shape &lt;- cube(environmentSize);\t  init {     create cells number: nb_cells {       location &lt;- {rnd(environmentSize), rnd(environmentSize), rnd(environmentSize)};           }   }  }   species cells skills:[moving3D]{  \t  reflex move{  \tdo move;  }\t                      aspect default {    draw sphere(environmentSize*0.01) color:#blue;     }}experiment Tuto3D  type: gui {  parameter \"Initial number of cells: \" var: nb_cells min: 1 max: 1000 category: \"Cells\" ;  output {    display View1 type:opengl{      graphics \"env\"{      \tdraw cube(environmentSize) color: #black empty:true;\t      }      species cells;    }  }}",
        "url":"/wiki/ThreeD_step2.html"
      }
      ,
    
      "wiki-threed-step3-html": {
        "title": "3. Connections",
        "content": "3. ConnectionsFormulation  Mapping the network of connection&lt;img src=’http://img.youtube.com/vi/6ZlBU6xTcfw/0.jpg’ width=’425’ height=344 /&gt;Model DefinitionIn this final step we will display edges between cells that are within a given distance.Cells updateWe add a new reflex to collect the neighbours of the cell that are within a certain distance :species cells skills:[moving3D]{...reflex computeNeighbours {                neighbours &lt;- cells select ((each distance_to self) &lt; 10);        }  \t}Then we update the cell aspect as follows. For each elements (cells) of the neighbours list we draw a line between this neighbour’s location and the current cell’s location.aspect default {  draw sphere(environmentSize*0.01) color:#orange;  loop pp over: neighbors {    draw line([self.location,pp.location]);  }\t}Complete ModelThe GIT version of the model can be found here Model 03.gamlmodel Tuto3Dglobal {  int nb_cells &lt;-100;  int environmentSize &lt;-100;  geometry shape &lt;- cube(environmentSize);\t  init {     create cells number: nb_cells {       location &lt;- {rnd(environmentSize), rnd(environmentSize), rnd(environmentSize)};           }   }  }     species cells skills: [moving3D] {  \trgb color;\tlist&lt;cells&gt; neighbors;\tint offset;\t\treflex move {      do wander;\t\t}\t\t\treflex computeNeighbors {      neighbors &lt;- cells select ((each distance_to self) &lt; 10);    }\t\t\taspect default {\t\tdraw sphere(environmentSize*0.01) color:#orange;\t\tloop pp over: neighbors {\t\t\tdraw line([self.location,pp.location]);\t\t}\t    }}experiment Tuto3D  type: gui {  parameter \"Initial number of cells: \" var: nb_cells min: 1 max: 1000 category: \"Cells\" ;  output {    display View1 type:opengl background:rgb(10,40,55){      graphics \"env\"{      \tdraw cube(environmentSize) color: #black empty:true;\t      }      species cells;    }  }  }",
        "url":"/wiki/ThreeD_step3.html"
      }
      ,
    
      "wiki-toy-models-html": {
        "title": "Toy Models",
        "content": "Toy ModelsThis section is composed of the following sub-section :      Ants (Foraging and Sorting)        Articles        Boids        Circle        Clock        Co-model Example        Epidemiology        Evacuation        Flood Simulation        Learning        Life        Multi-level data analysis        Predator Prey        Segregation (Schelling)        Soccer        Sugarscape        Traffic        Urban Growth        Voronoi        Vote  ",
        "url":"/wiki/Toy-Models.html"
      }
      ,
    
      "wiki-traffic-lwr-traffic-flow-model-html": {
        "title": "Trafic Group (R2D2) MAPS7 - LWR Model",
        "content": "Trafic Group (R2D2) MAPS7 - LWR ModelAuthor : A. Banos, N. Corson, C. Pivano, L. Rajaonarivo, P. TaillandierThe LWR model was proposed by Lighthill and Whitham (1955) and by Richards (1956). It describes the trafic at a global level considering the speed, concentration and flows without taking into account the individual behavior af vehicles. Speed, concentration and flow are the three components of the LWR model. This models reproduces flow of traffic and congestion in specific conditions (homogeneous traffic), going from one equilibrium state to another (see the fundamental diagramm of traffic, which gives flow according to concentration).In this model, a road is divided into sections and we arbitrarily give to the middle section a lower speed and critical concentration.Code of the model :model TraficGroupglobal {\t\t\tfloat road_size &lt;- 10 #km ; \t\t\t\t\t\t// Size of the road\t\tgeometry shape &lt;- rectangle (road_size, 200 #m) ; \t// The world is a rectangle with a length equals to the size of the road and a height of 200m\t\t\tfloat time_step &lt;- 1.0 ; \t\t\t\t\t\t\t// Time step \tint nb_sections &lt;- 10 ; \t\t\t\t\t\t\t// Number of sections of the road\tfloat section_size &lt;- road_size / nb_sections ; \t// Size of a section\t\tfloat car_size &lt;- 4 #m ;\t\t\t\t\t\t\t\t\t// Size of a car\tfloat nb_max_cars_on_section &lt;- section_size / car_size ;\t// Maximum number of cars on one section \t\t   init{\t   \t\t\t   \t\t// Creation of the nb_sections sections which compose the road. \t   \t\t\t\t   loop i from: 0 to: (nb_sections - 1){\t\t   \t  create section with: [shape:: line([{i * section_size , 100},{(i +1) * section_size , 100}])];\t\t   }\t\t   \t\t\t   \t// For each section, as we need to have information concerning the previous and the next one, we define which section is the previous and which is the next.\t\t   \t// The previous section is the one which last point corresponds to the first point of the actual section. \t\t   \t// The next section is the one which first point corresponds to the last point of the actual section. \t\t   \t\t    \task section{\t    \t\tprevious &lt;- section first_with (last(each.shape.points) = first(self.shape.points)) ;\t    \t\tnext &lt;- section first_with (first(each.shape.points) = last(self.shape.points)) ;\t    \t}\t\t    \t// For each section, we define a critical concentration (see the fundamental diagram), a maximum speed, a concentration and a flow (which are = 0 at initialization). \t    \t// A fundamental relation about trafic gives : flow = concentration * speed.\t    \t\t    \task section{\t    \t\tcritical_concentration &lt;- 125.0 ; //Kc\t\t\t\tmax_speed &lt;- 50 #km/#h; // Vl\t\t\t\tcurrent_concentration &lt;- 0.0 ;\t\t\t\tcurrent_flow &lt;- current_concentration * max_speed ;\t\t\t\tmax_flow &lt;- critical_concentration * max_speed ; \t    \t}\t    \t\t    \t\t    \t// The concentration and flow ot first section are initialized.\t    \t\t    \task section[0]{\t    \t\tcurrent_concentration &lt;- nb_max_cars_on_section ;\t\t\t\tcurrent_flow &lt;- current_concentration * max_speed ;\t    \t}\t    \t\t    \t// The middle section is supposed to have a different maximum speed and a different critical concentration so that we can observe congestion phenomenon.\t    \t// This middle section is green.\t    \t\t    \task section[int(nb_sections/2)] {\t    \t\t\tcritical_concentration &lt;- 10.0 ; \t    \t\t\tmax_flow &lt;- critical_concentration * max_speed ; \t\t\t\t    max_speed &lt;- 10 #km/#h; \t\t\t\t\tcolor &lt;- #green;\t    \t}    \t}    \t   // To update flow and concentration at each time step in each section, we use an offer and a demand function.    // These functions define the welcome capacity (offer) and the emission capacity (demand) of a section.       reflex offer_function {\t     ask section {\t\t\t  if current_concentration &lt;= critical_concentration {\t\t\t  \toffer &lt;- max_flow ;\t\t\t  }\t\t\t  else {\t\t\t  \toffer &lt;- max([0 , (- max_flow / critical_concentration) * current_concentration + 2 * max_flow ]);\t\t\t  }\t\t  \t  }\t}\t\treflex demand_function {\t\task section{\t\t\t  if current_concentration &lt;= critical_concentration {\t\t\t  \t\tdemand &lt;- max([0 , ( max_flow / critical_concentration) * current_concentration]) ;\t\t\t  }\t\t\t  else {\t\t\t  \t\tdemand &lt;- max_flow ;\t\t\t  }\t\t}\t}\t\t// The flow and concentration are then updated according to the offer and demand functions of the current section, but also of the next and previous ones.\t\t// During a time step, the flow of a section take the minimum value between its demand and the offer of the next section.\t// The flow of the last section is equal to its demand.\t\t\treflex update_flow{\t\task section  {\t\t\tfloat next_offer &lt;-  (self.next != nil) ? (self.next).offer : self.demand;\t\t\tcurrent_flow &lt;- min([self.demand, next_offer]);\t\t}\t}\t\t\t// After a time step, the concentration is updated from the current concentration, according to the incoming and outgoing concentrations.\t// The first section concentration on ly takes into account the outgoing concentration of vehicles.\t\treflex update_concentration{\t\task section   {\t\t\tfloat previous_flow &lt;- (self.previous != nil) ? (self.previous).current_flow : 0.0;\t\t\tcurrent_concentration &lt;- current_concentration + time_step/section_size *(previous_flow - self.current_flow) ;\t\t}\t\t}\t\t// When there is less than one car left on the road, the simulation stops.\t\treflex stop_simulation when: sum(section collect each.current_concentration) &lt; 1.0 {\t\tdo pause;\t}}// A road is divided into sections. // Each section has a concentration, a flow, an offer and a demand, a critical concentration, a maximum speed and a maximum flow, // and a previous and a next section.species section {\tfloat current_concentration  ;\tfloat current_flow  ;\t\tfloat offer ;\tfloat demand  ;\t\trgb color;\t\tfloat critical_concentration ; \tfloat max_speed ; \tfloat max_flow ; \tsection previous ;\tsection next ;\t\t// The width of a section depends on its concentration.\t\taspect shape_section {\t\tdraw shape + (1 + 15 * ln (current_concentration + 1)) color: color;\t\t\t} }experiment TraficGroup type: gui {\t// Users can chose the number of sections and the time step.    parameter 'Number of sections' var: nb_sections category: \"Section parameter\";    parameter 'Time step - DeltaT' var: time_step category: \"Time parameter\";        \toutput {\t\t\t\t// A monitor gives the number of cars on the road at every time step.\t\t\t\tmonitor \"Sum Concentrations\" value: sum(section collect each.current_concentration);\t\t\t\t// A display shows the road. Section width depend on their concentration.\t\t\t\tdisplay TheRoad{\t\t\tspecies section aspect: shape_section ;\t\t}\t\t\t\t// The greeen time series correspond to the middle section (on which concentration and maximum speed are lower).\t\t// The red time series correspond to the section just before the middle one.\t\t\t\t\t\tdisplay Concentrations {\t\t\tchart \"Concentrations\" type: series  {\t\t\t\tdata 'Section 0' value: section[0].current_concentration color: #gray marker: false ;\t\t\t\t\t\t\t\tdata 'Section 1' value: section[1].current_concentration color: #gray marker: false;\t\t\t\tdata 'Section 2' value: section[2].current_concentration color: #gray marker: false;\t\t\t\tdata 'Section 3' value: section[3].current_concentration color: #gray marker: false;\t\t\t\t\t\t\t\tdata 'Section 4' value: section[int(nb_sections/2 - 1 ) ].current_concentration color: #red marker: false;\t\t\t\tdata 'Section 5' value: section[int(nb_sections/2)].current_concentration color: #green marker: false;\t\t\t\tdata 'Section 6' value: section[6].current_concentration color: #gray marker: false;\t\t\t\t\t\t\t\tdata 'Section 7' value: section[7].current_concentration color: #gray marker: false;\t\t\t\tdata 'Section 8' value: section[8].current_concentration color: #gray marker: false;\t\t\t\tdata 'Section 9' value: section[9].current_concentration color: #gray marker: false;\t\t\t\t}\t\t\t}\t\t\t\t\t\tdisplay Flows {\t\t\t    chart \"Flows\" type: series  {\t\t\t\tdata 'Section 0' value: section[0].current_flow color: #gray marker: false;\t\t\t\t\t\t\t\tdata 'Section 1' value: section[1].current_flow color: #gray marker: false;\t\t\t\tdata 'Section 2' value: section[2].current_flow color: #gray marker: false;\t\t\t\tdata 'Section 3' value: section[3].current_flow color: #gray marker: false;\t\t\t\t\t\t\t\tdata 'Section 4' value: section[int(nb_sections/2 - 1)].current_flow color: #red marker: false;\t\t\t\tdata 'Section 5' value: section[int(nb_sections/2)].current_flow color: #green marker: false;\t\t\t\tdata 'Section 6' value: section[6].current_flow color: #gray marker: false;\t\t\t\t\t\t\t\tdata 'Section 7' value: section[7].current_flow color: #gray marker: false;\t\t\t\tdata 'Section 8' value: section[8].current_flow color: #gray marker: false;\t\t\t\tdata 'Section 9' value: section[9].current_flow color: #gray marker: false;\t\t\t\t}\t\t\t}\t}}",
        "url":"/wiki/Traffic-LWR-Traffic-Flow-Model.html"
      }
      ,
    
      "wiki-traffic-simple-traffic-model-html": {
        "title": "Traffic",
        "content": "TrafficAuthor : Patrick TaillandierA simple road network model: the speed on a road depends on the number of people on this road (the highest, the slowest)Code of the model :model trafficglobal {\t//Shapefile of the buildings\tfile building_shapefile &lt;- file(\"../includes/buildings.shp\");\t//Shapefile of the roads\tfile road_shapefile &lt;- file(\"../includes/roads.shp\");\t//Shape of the environment\tgeometry shape &lt;- envelope(road_shapefile);\t//Step value\tfloat step &lt;- 10 #s;\t//Graph of the road network\tgraph road_network;\t//Map containing all the weights for the road network graph\tmap&lt;road,float&gt; road_weights;\t\tinit {\t\t//Initialization of the building using the shapefile of buildings\t\tcreate building from: building_shapefile;\t\t//Initialization of the road using the shapefile of roads\t\tcreate road from: road_shapefile;\t\t\t\t//Creation of the people agents\t\tcreate people number: 1000{\t\t\t//People agents are located anywhere in one of the building\t\t\tlocation &lt;- any_location_in(one_of(building));      \t}      \t//Weights of the road      \troad_weights &lt;- road as_map (each::each.shape.perimeter);      \troad_network &lt;- as_edge_graph(road);\t}\t//Reflex to update the speed of the roads according to the weights\treflex update_road_speed  {\t\troad_weights &lt;- road as_map (each::each.shape.perimeter / each.speed_coeff);\t\troad_network &lt;- road_network with_weights road_weights;\t}}//Species to represent the people using the skill movingspecies people skills: [moving]{\t//Target point of the agent\tpoint target;\t//Probability of leaving the building\tfloat leaving_proba &lt;- 0.05; \t//Speed of the agent\tfloat speed &lt;- 5 #km/#h;\trgb color &lt;- rnd_color(255);\t//Reflex to leave the building to another building\treflex leave when: (target = nil) and (flip(leaving_proba)) {\t\ttarget &lt;- any_location_in(one_of(building));\t}\t//Reflex to move to the target building moving on the road network\treflex move when: target != nil {\t\tdo goto target: target on: road_network recompute_path: false move_weights: road_weights;\t\tif (location = target) {\t\t\ttarget &lt;- nil;\t\t}\t\t}\t\taspect default {\t\tdraw circle(5) color: color;\t}}//Species to represent the buildingsspecies building {\taspect default {\t\tdraw shape color: #gray;\t}}//Species to represent the roadsspecies road {\t//Capacity of the road considering its perimeter\tfloat capacity &lt;- 1 + shape.perimeter/30;\t//Number of people on the road\tint nb_people &lt;- 0 update: length(people at_distance 1);\t//Speed coefficient computed using the number of people on the road and the capicity of the road\tfloat speed_coeff &lt;- 1.0 update:  exp(-nb_people/capacity) min: 0.1;\t\taspect default {\t\tdraw (shape + 3 * speed_coeff) color: #red;\t}}experiment trafic type: gui {\tfloat minimum_cycle_duration &lt;- 0.01;\toutput {\t\tdisplay carte type: opengl{\t\t\tspecies building refresh: false;\t\t\tspecies road ;\t\t\tspecies people ;\t\t}\t}}",
        "url":"/wiki/Traffic-Simple-traffic-model.html"
      }
      ,
    
      "wiki-traffic-html": {
        "title": "Traffic",
        "content": "TrafficThis sub-section is composed of the following models :      Trafic Group (R2D2) MAPS7 - LWR Model        Traffic  ",
        "url":"/wiki/Traffic.html"
      }
      ,
    
      "wiki-trainingsession-html": {
        "title": "Training Session",
        "content": "Training SessionModeling for supporting decision in urban management issues7-11 December 2015 - Siem Reap (Cambodia)This training session took place at the Apsara Authorities, where we introduced how to build a model with agent-based approach, using GAMA. In a new and very fast growing city such as Siem Reap, some measures have to be taken to anticipate the future of the city, and modeling is a science that can give some solutions to face those problems.The training session was divided into 2 parts :  A theoretical part (3 days) dealing with the following subjects :          Urban issues and introduction to Agent-Based Modeling      Presentation of the modeling methodology      Introduction to GAMA with a model on urban segregation      GIS datas and graphs to model urban mobility      GIS, Raster datas and graphs to model urban growth      Use of experiments to calibrate and explore models        A practical part (2 days) to build a model about urban mobility in Siem Reap (by groups of 4/5 people)||||—|—|Trainers : Drogoul Alexis, Gaudou Benoit, Trung Quang, Philippon Damien, Mazars Julien.Here the link to download the different projects (Gama version : 1.61)A Glance at Sustainable Urban Development (JTD)July 2014 - Da lat (Vietnam)The JTD (Journées de Tam Dao) is an annual gathering of french-talkers researchers during the summer for one week, dealing with a specific subject related to sustainable development. For this 8th JTD, the topic was about sustainable urban development, and a workshop has been made especially about how to use tools as GAMA to build models in order to explore and understand urban spatial dynamics.Trainers : Drogoul Alexis, Banos Arnaud, Huỳnh Quang Nghi, Trương Chí Quang, Võ Đức Ân.Here is the link to download the pdf report of the JTD 2014 : https://drive.google.com/file/d/0B2Go6pohIhQcbERhczZRd253UUU/view.The perception and Management of Risk (JTD)July 2013 - Da lat (Vietnam)The JTD (Journées de Tam Dao) is an annual gathering of french-talkers researchers during the summer for one week, dealing with a specific subject related to sustainable development. For this 7th JTD, the topic was about the perception and management of risks, and a workshop has been made especially about how to use tools as GAMA to build models in order to understand past crises to better understand the present.Trainers : Alexis Drogoul, Benoit Gaudou, Nasser Gasmi, Arnaud Grignard, Patrick Taillandier, Olivier Tessier, Võ Đức ÂnHere is the link to download the pdf report of the JTD 2013 : https://drive.google.com/file/d/0B2Go6pohIhQcNXFwVllHd2pFdlk/view.Water and its many Issues (JTD)July 2012 - VietnamThe JTD (Journées de Tam Dao) is an annual gathering of french-talkers researchers during the summer for one week, dealing with a specific subject related to sustainable development. For this 6th JTD, the topic was about the perception and management of risks, and a workshop has been made especially about how to use tools as GAMA to build models with an agent-based approach.Trainers : Alexis Drogoul, Benoit Gaudou, Arnaud Grignard, Patrick Taillandier, Vỗ Đức ÂnHere is the link to download the pdf report of the JTD 2012 : https://docs.google.com/file/d/0B2Go6pohIhQcUWRKU2hPelNqQmc/view.",
        "url":"/wiki/TrainingSession.html"
      }
      ,
    
      "wiki-troubleshooting-html": {
        "title": "Troubleshooting",
        "content": "TroubleshootingThis page exposes some of the most common problems a user may encounter when running GAMA — and offers advices and workarounds for them. It will be regularly enriched with new contents. Note also that the Issues section of the website might contain precious information on crashes and bugs encountered by other users. If neither the workarounds described here nor the solutions provided by other users allow to solve your particular problem, please submit a new issue report to the developers.Table of contents  Troubleshooting          Table of contents      On Ubuntu (&amp; Linux Systems)                  Workaround if GAMA crashes when displaying web contents          Workaround if GAMA does not display the menus (the ‘Edit’ menu is the only one working)                    On Windows      On MacOS X                  Workaround in case of glitches in the UI          Workaround in case of corrupted icons in menus under El Capitan                    Memory problems      Submitting an Issue      On Ubuntu (&amp; Linux Systems)Workaround if GAMA crashes when displaying web contentsIn case GAMA crashes whenever trying to display a web page or the pop-up online documentation, you may try to edit the file Gama.ini and add the line -Dorg.eclipse.swt.browser.DefaultType=mozilla to it. This workaround is described here: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=705420 and in Issue 700 (on Google Code).Workaround if GAMA does not display the menus (the ‘Edit’ menu is the only one working)If, when selecting a menu, nothing happens (or, in the case of the ‘Agents’ menu, all population submenus appear empty), it is likely that you have run into this issue: https://bugs.eclipse.org/bugs/show_bug.cgi?id=330563. The only workaround known is to launch GAMA from the command line (or from a shell script) after having told Ubuntu to attach its menu back to its main window. For example (if you are in the directory where the “Gama” executable is present):export UBUNTU_MENUPROXY=0./GamaNo fix can be provided from the GAMA side for the moment.On WindowsNo common trouble…On MacOS XWorkaround in case of glitches in the UIThe only problems reported so far on MacOS X (from Lion to Yosemite) concern visual glitches in the UI and problems with displays, either not showing or crashing the JVM. Most (all ?) of these problems are usually related to the fact that GAMA does not run under the correct version of Java Virtual Machine. In that case, follow these instructions to install the correct version.Workaround in case of corrupted icons in menus under El CapitanFor some particular configurations (in particular some particular graphic cards), the icons of the menus (e.g. Edit menu) may be corrupted. This bug is documented for all RCP products under El Capitan. See these references:https://bugs.eclipse.org/bugs/show_bug.cgi?id=479590https://trac.filezilla-project.org/ticket/10669These is nothing we can do now except using the workaround that consists in switching the language of the OS to English (in System Preferences, Language &amp; Region).Memory problemsThe most common causes of problems when running GAMA are memory problems. Depending on your activities, on the size of the models you are editing, on the size of the experiments you are running, etc., you have a chance to require more memory than what is currently allocated to GAMA. A typical GAMA installation  will need between 40 and 200MB of memory to run “normally” and launch small models.Memory problems are easy to detect: on the bottom right corner of its window, GAMA will always display the status of the current memory. The first number represents the memory currently used (in MB), the second (always larger) the memory currently allocated by the JVM. And the little trash icon allows to “garbage collect” the memory still used by agents that are not used anymore (if any). If GAMA appears to hang or crash and if you can see that the two numbers are very close, it means that the memory required by GAMA exceeds the memory allocated.There are two ways to circumvent this problem: the first one is to increase the memory allocated to GAMA by the Java Virtual Machine. The second, detailed on this page is to try to optimize your models to reduce their memory footprint at runtime.To increase the memory allocated, first locate the file called Gama.ini. On Windows and Ubuntu, it is located next to the executable. On MacOS X, you have to right-click on Gama.app, choose “Display Package Contents…”, and you will find Gama.ini in Contents/MacOS.This file typically looks like the following (some options/keywords may vary depending on the system), and we are interested in two JVM arguments:-Xms supplies the minimal amount of memory the JVM should allocate to GAMA, -Xmx the maximal amount. By changing these values (esp. the second one, of course, for example to 4096M, or 4g), saving the file and relaunching GAMA, you can probably solve your problem. Note that 32 bits versions of GAMA will not accept to run with a value of -Xmx greater than 1500M. See here for additional information on these two options.Submitting an IssueIf you think you have found a new bug/issue in GAMA, it is time to create an issue report here ! Alternatively, you can click the Issues tab on the project site, search if a similar problem has already been reported (and, maybe, solved) and, if not, enter a new issue with as much information as possible:  A complete description of the problem and how it occurred.  The GAMA model or code you are having trouble with. If possible, attach a complete model.  Screenshots or other files that help describe the issue.Two files may be particularly interesting to attach to your issue: the configuration details and the error log. Both can be obtained quite easily from within GAMA itself in a few steps. First, click the “About GAMA…” menu item (under the “Gama” menu on MacOS X, “Help” menu on Linux &amp; Windows)  In the dialog that appears, you will find a button called “Installation Details”.Click this button and a new dialog appears with several tabs.To provide a complete information about the status of your system at the time of the error, you can(1) copy and paste the text found in the tab “Configuration” into your issue. Although, it is preferable to attach it as a text file (using textEdit, Notepad or Emacs e.g.) as it may be too long for the comment section of the issue form.(2) click the “View error log” button, which will bring you to the location, in your file system, of a file called “log”, which you can then attach to your issue as well.",
        "url":"/wiki/Troubleshooting.html"
      }
      ,
    
      "wiki-tutorials-html": {
        "title": "Tutorials",
        "content": "TutorialsWe propose some tutorials that are designed to allow modelers to become progressively autonomous with the GAMA platform. These tutorials cover different aspects of GAMA (Grid environment, GIS integration, 3D, multi-level modeling, equation-based models…). It is a good idea to keep a copy of the reference of the GAML language around when undertaking one of these tutorials.  Predator Prey  Road Traffic  3D Tutorial  Luneray’s flu  Incremental ModelPredator Prey tutorialThis tutorial introduces the basic concepts of GAMA and the use of grids. It is based on the classic predator prey model (see for instance a formal definition here). It is particularly adapted to beginners that want to quickly learn how to build a simple model in GAMA.Road TrafficThis tutorial introduces the use of GIS data. It is based on a mobility and daily activity model. It is particularly adapted to modelers that want to quickly learn how to integrate GIS data in their model and to use a road shapefile for the movement of their agents.3D TutorialThis tutorial introduces the use of 3D in GAMA. In particular, it offers a quick overview of the 3D capabilities of the platform and how to integrate 3D features in models.Luneray’s flu tutorialThis tutorial dedicated to beginners introduces the basic concepts of GAMA and proposes a brief overview of many features.  It concerns a model of disease spreading in the small city of Luneray. In particular, it presents how to integrate GIS data and use GIS, to use a road shapefile for the movement of agents, and to define a 3D display.Incremental ModelThis tutorial proposes is an advance version of the Luneray’s tutorial. It concerns a model of disease spreading in a small city. In particular, it presents how to integrate GIS data and use GIS, to use a road shapefile for the movement of agents, to define a 3D display, to define a multi-level model and use differential equations.",
        "url":"/wiki/Tutorials.html"
      }
      ,
    
      "wiki-unit-test-basic-example-html": {
        "title": "Example of Unit Test",
        "content": "Example of Unit TestAuthor : Benoit GaudouA model which shows how to use the unit test to show the possible errors you have to go in the Views, Preferences, Simulation, in “Errors” Uncheck “stop at the first error”, to show all the errors.Code of the model :model test_unitTest_frameworkglobal {\tinit {\t\tcreate test_species number: 1;\t}}//Species to do the different unit testsspecies test_species {\tint a &lt;- 0;\t\t//Setup a to 10 launched before each test\tsetup {\t\ta &lt;- 10;\t\twrite \"SetUp : a = \" + a;\t}\t//First test executing comparison between numbers\ttest t1 {     \tassert 100 + 100 equals: 200;    \t\tassert 100 + 100 equals: 201;\t}\t\t//Second test executing comparison between list and type\ttest t2 {    \tassert any([1,2,3]) is_not: nil;    \tassert any([1,2,3]) is int;    \tassert any([1,2,3]) is_not: 5;    \tassert any([1,2,3]) is float;    \tassert any([1,2,3]) is string;\t}\t//test the incrementation of a\ttest incement_a {   \t\ta&lt;- a + 10;    \t\twrite \"a: \" + a;\t}\t\t//Third test for lists\ttest t3 { \t\tlist&lt;int&gt; aa;\t \tassert aa[0] raises: \"error\";\t \tassert aa[0] raises: \"\";\t \tassert a raises: \"error\";\t}}experiment new type: gui {}",
        "url":"/wiki/Unit-Test-Basic-Example.html"
      }
      ,
    
      "wiki-unit-test-two-species-example-html": {
        "title": "Example of Unit Test",
        "content": "Example of Unit TestAuthor : Benoit GaudouThe model creates 10 agents at initialization, kills one agent at each step.  With the assert we want to ensure that the test_species1 population always contains more than 5 agents.  After four steps the population is below 6 so Errors are raisen. You have to go in the Views, Preferences, Simulation, in “Errors” Uncheck “stop at the first error”, to show all the errors.Code of the model :model test_unitTest_frameworkglobal {\tinit {\t\t//Create agents : one to test the population of test_species1 and the test_species1 agents\t\tcreate test_species2 number: 1;\t\tcreate test_species1 number: 10;\t}\t//At each step, one of the agents of test_species1 dies\treflex one_should_die {\t\task one_of(test_species1){\t\t\tdo die;\t\t}\t}}species test_species2 {\t//The step is computed each step to test if there is still at least 5 agents of test_species1\ttest t1 {     \tassert (length(test_species1) &gt; 5) equals: true;\t}}species test_species1 {}experiment new type: gui {}",
        "url":"/wiki/Unit-Test-Two-Species-(Example).html"
      }
      ,
    
      "wiki-unit-test-html": {
        "title": "Unit Test",
        "content": "Unit TestThis sub-section is composed of the following models :      Example of Unit Test        Example of Unit Test  ",
        "url":"/wiki/Unit-Test.html"
      }
      ,
    
      "wiki-unitsandconstants-html": {
        "title": "Units and constants",
        "content": "Units and constantsThis file is automatically generated from java files. Do Not Edit It.IntroductionUnits can be used to qualify the values of numeric variables. By default, unqualified values are considered as:  meters for distances, lengths…  seconds for durations  cubic meters for volumes  kilograms for massesSo, an expression like:float foo &lt;- 1;will be considered as 1 meter if foo is a distance, or 1 second if it is a duration, or 1 meter/second if it is a speed. If one wants to specify the unit, it can be done very simply by adding the unit symbol (° or #) followed by an unit name after the numeric value, like:float foo &lt;- 1 °centimeter;orfloat foo &lt;- 1 #centimeter;In that case, the numeric value of foo will be automatically translated to 0.01 (meter). It is recommended to always use float as the type of the variables that might be qualified by units (otherwise, for example in the previous case, they might be truncated to 0). Several units names are allowed as qualifiers of numeric variables. These units represent the basic metric and US units. Composed and derived units (like velocity, acceleration, special volumes or surfaces) can be obtained by combining these units using the * and / operators. For instance:float one_kmh &lt;- 1 °km / °h const: true;float one_millisecond &lt;-1 °sec / 1000;float one_cubic_inch &lt;- 1 °sqin * 1 °inch;... etc ...Table of ContentsConstants  #e, value= 2.718281828459045, Comment: The e constant  #infinity, value= Infinity, Comment: A constant holding the positive infinity of type (Java Double.POSITIVE_INFINITY)  #max_float, value= 1.7976931348623157E308, Comment: A constant holding the largest positive finite value of type float (Java Double.MAX_VALUE)  #max_int, value= 2.147483647E9, Comment: A constant holding the maximum value an int can have (Java Integer.MAX_VALUE)  #min_float, value= 4.9E-324, Comment: A constant holding the smallest positive nonzero value of type float (Java Double.MIN_VALUE)  #min_int, value= -2.147483648E9, Comment: A constant holding the minimum value an int can have (Java Integer.MIN_VALUE)  #nan, value= NaN, Comment: A constant holding a Not-a-Number (NaN) value of type float (Java Double.POSITIVE_INFINITY)  #pi, value= 3.141592653589793, Comment: The PI constant  #to_deg, value= 57.29577951308232, Comment: A constant holding the value to convert radians into degrees  #to_rad, value= 0.017453292519943295, Comment: A constant holding the value to convert degrees into radiansGraphics units  #bold, value= 1, Comment: This constant allows to build a font with a bold face. Can be combined with #italic  #camera_location, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current position of the camera as a point  #camera_orientation, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current orientation of the camera as a point  #camera_target, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current target of the camera as a point  #display_height, value= 1.0, Comment: This constant is only accessible in a graphical context: display, graphics…  #display_width, value= 1.0, Comment: This constant is only accessible in a graphical context: display, graphics…  #flat, value= 2, Comment: This constant represents a flat line buffer end cap style  #horizontal, value= 3, Comment: This constant represents a layout where all display views are aligned horizontally  #italic, value= 2, Comment: This constant allows to build a font with an italic face. Can be combined with #bold  #none, value= 0, Comment: This constant represents the absence of a predefined layout  #pixels (#px), value= 1.0, Comment: This unit, only available when running aspects or declaring displays,  returns a dynamic value instead of a fixed one. px (or pixels), returns the value of one pixel on the current view in terms of model units.  #plain, value= 0, Comment: This constant allows to build a font with a plain face  #round, value= 1, Comment: This constant represents a round line buffer end cap style  #split, value= 2, Comment: This constant represents a layout where all display views are split in a grid-like structure  #square, value= 3, Comment: This constant represents a square line buffer end cap style  #stack, value= 1, Comment: This constant represents a layout where all display views are stacked  #user_location, value= No Default Value, Comment: This unit contains in permanence the location of the mouse on the display in which it is situated. The latest location is provided when it is out of a display  #vertical, value= 4, Comment: This constant represents a layout where all display views are aligned vertically  #zoom, value= 1.0, Comment: This unit, only available when running aspects or declaring displays, returns the current zoom level of the display as a positive float, where 1.0 represent the neutral zoom (100%)Length units  #cm (#centimeter,#centimeters), value= 0.009999999776482582, Comment: centimeter unit  #dm (#decimeter,#decimeters), value= 0.10000000149011612, Comment: decimeter unit  #foot (#feet,#ft), value= 0.3047999931871891, Comment: foot unit  #inch (#inches), value= 0.025399999432265757, Comment: inch unit  #km (#kilometer,#kilometers), value= 1000.0, Comment: kilometer unit  #m (#meter,#meters), value= 1.0, Comment: meter: the length basic unit  #mile (#miles), value= 1609.344, Comment: mile unit  #mm (#milimeter,#milimeters), value= 9.999999776482583E-4, Comment: millimeter unit  #yard (#yards), value= 0.9144, Comment: yard unitSurface units  #m2, value= 1.0, Comment: square meter: the basic unit for surfaces  #sqft (#square_foot,#square_feet), value= 0.09290303584691051, Comment: square foot unit  #sqin (#square_inch,#square_inches), value= 6.451599711591008E-4, Comment: square inch unit  #sqmi (#square_mile,#square_miles), value= 2589988.110336, Comment: square mile unitTime units  #custom, value= CUSTOM, Comment: custom: a custom date/time pattern that can be defined in the preferences of GAMA and reused in models  #cycle (#cycles), value= 1, Comment: cycle: the discrete measure of time in the simulation. Used to force a temporal expression to be expressed in terms of cycles rather than seconds  #day (#days), value= 86400.0, Comment: day time unit: defines an exact duration of 24 hours  #epoch, value= No Default Value, Comment: The epoch default starting date as defined by the ISO format (1970-01-01T00:00Z)  #h (#hour,#hours), value= 3600.0, Comment: hour time unit: defines an exact duration of 60 minutes  #iso_local, value= ISO_LOCAL_DATE_TIME, Comment: iso_local: the standard ISO 8601 output / parsing format for local dates (i.e. with no time-zone information)  #iso_offset, value= ISO_OFFSET_DATE_TIME, Comment: iso_offset: the standard ISO 8601 output / parsing format for dates with a time offset  #iso_zoned, value= ISO_ZONED_DATE_TIME, Comment: iso_zoned: the standard ISO 8601 output / parsing format for dates with a time zone  #minute (#minutes,#mn), value= 60.0, Comment: minute time unit: defined an exact duration of 60 seconds  #month (#months), value= 2592000.0, Comment: month time unit: does not define an exact duration. The duration will depend on the step/date at which this unit is computed.  #msec (#millisecond,#milliseconds,#ms), value= 0.001, Comment: millisecond time unit: defines an exact duration of 0.001 second  #now, value= 1.0, Comment: This value represents the current date  #sec (#second,#seconds,#s), value= 1.0, Comment: second: the time basic unit, with a fixed value of 1. All other durations are expressed with respect to it  #week (#weeks), value= 604800.0, Comment: week time unit: defines an exact duration of  7 days  #year (#years,#y), value= 3.1104E7, Comment: year time unit: does not define an exact duration. The duration will depend on the step/date at which this unit is computed.Volume units  #cl (#centiliter,#centiliters), value= 1.0E-5, Comment: centiliter unit  #dl (#deciliter,#deciliters), value= 1.0E-4, Comment: deciliter unit  #hl (#hectoliter,#hectoliters), value= 0.1, Comment: hectoliter unit  #l (#liter,#liters,#dm3), value= 0.001, Comment: liter unit  #m3, value= 1.0, Comment: cube meter: the basic unit for volumesWeight units  #gram (#grams), value= 0.001, Comment: gram unit  #kg (#kilo,#kilogram,#kilos), value= 1.0, Comment: second: the basic unit for weights  #longton (#lton), value= 1016.0469088000001, Comment: short ton unit  #ounce (#oz,#ounces), value= 0.028349523125, Comment: ounce unit  #pound (#lb,#pounds,#lbm), value= 0.45359237, Comment: pound unit  #shortton (#ston), value= 907.18474, Comment: short ton unit  #stone (#st), value= 6.35029318, Comment: stone unit  #ton (#tons), value= 1000.0, Comment: ton unitColorsIn addition to the previous units, GAML provides a direct access to the 147 named colors defined in CSS (see http://www.cssportal.com/css3-color-names/). E.g,rgb my_color &lt;- °teal;  #aliceblue, value= r=240, g=248, b=255, alpha=1  #antiquewhite, value= r=250, g=235, b=215, alpha=1  #aqua, value= r=0, g=255, b=255, alpha=1  #aquamarine, value= r=127, g=255, b=212, alpha=1  #azure, value= r=240, g=255, b=255, alpha=1  #beige, value= r=245, g=245, b=220, alpha=1  #bisque, value= r=255, g=228, b=196, alpha=1  #black, value= r=0, g=0, b=0, alpha=1  #blanchedalmond, value= r=255, g=235, b=205, alpha=1  #blue, value= r=0, g=0, b=255, alpha=1  #blueviolet, value= r=138, g=43, b=226, alpha=1  #brown, value= r=165, g=42, b=42, alpha=1  #burlywood, value= r=222, g=184, b=135, alpha=1  #cadetblue, value= r=95, g=158, b=160, alpha=1  #chartreuse, value= r=127, g=255, b=0, alpha=1  #chocolate, value= r=210, g=105, b=30, alpha=1  #coral, value= r=255, g=127, b=80, alpha=1  #cornflowerblue, value= r=100, g=149, b=237, alpha=1  #cornsilk, value= r=255, g=248, b=220, alpha=1  #crimson, value= r=220, g=20, b=60, alpha=1  #cyan, value= r=0, g=255, b=255, alpha=1  #darkblue, value= r=0, g=0, b=139, alpha=1  #darkcyan, value= r=0, g=139, b=139, alpha=1  #darkgoldenrod, value= r=184, g=134, b=11, alpha=1  #darkgray, value= r=169, g=169, b=169, alpha=1  #darkgreen, value= r=0, g=100, b=0, alpha=1  #darkgrey, value= r=169, g=169, b=169, alpha=1  #darkkhaki, value= r=189, g=183, b=107, alpha=1  #darkmagenta, value= r=139, g=0, b=139, alpha=1  #darkolivegreen, value= r=85, g=107, b=47, alpha=1  #darkorange, value= r=255, g=140, b=0, alpha=1  #darkorchid, value= r=153, g=50, b=204, alpha=1  #darkred, value= r=139, g=0, b=0, alpha=1  #darksalmon, value= r=233, g=150, b=122, alpha=1  #darkseagreen, value= r=143, g=188, b=143, alpha=1  #darkslateblue, value= r=72, g=61, b=139, alpha=1  #darkslategray, value= r=47, g=79, b=79, alpha=1  #darkslategrey, value= r=47, g=79, b=79, alpha=1  #darkturquoise, value= r=0, g=206, b=209, alpha=1  #darkviolet, value= r=148, g=0, b=211, alpha=1  #deeppink, value= r=255, g=20, b=147, alpha=1  #deepskyblue, value= r=0, g=191, b=255, alpha=1  #dimgray, value= r=105, g=105, b=105, alpha=1  #dimgrey, value= r=105, g=105, b=105, alpha=1  #dodgerblue, value= r=30, g=144, b=255, alpha=1  #firebrick, value= r=178, g=34, b=34, alpha=1  #floralwhite, value= r=255, g=250, b=240, alpha=1  #forestgreen, value= r=34, g=139, b=34, alpha=1  #fuchsia, value= r=255, g=0, b=255, alpha=1  #gainsboro, value= r=220, g=220, b=220, alpha=1  #ghostwhite, value= r=248, g=248, b=255, alpha=1  #gold, value= r=255, g=215, b=0, alpha=1  #goldenrod, value= r=218, g=165, b=32, alpha=1  #gray, value= r=128, g=128, b=128, alpha=1  #green, value= r=0, g=128, b=0, alpha=1  #greenyellow, value= r=173, g=255, b=47, alpha=1  #grey, value= r=128, g=128, b=128, alpha=1  #honeydew, value= r=240, g=255, b=240, alpha=1  #hotpink, value= r=255, g=105, b=180, alpha=1  #indianred, value= r=205, g=92, b=92, alpha=1  #indigo, value= r=75, g=0, b=130, alpha=1  #ivory, value= r=255, g=255, b=240, alpha=1  #khaki, value= r=240, g=230, b=140, alpha=1  #lavender, value= r=230, g=230, b=250, alpha=1  #lavenderblush, value= r=255, g=240, b=245, alpha=1  #lawngreen, value= r=124, g=252, b=0, alpha=1  #lemonchiffon, value= r=255, g=250, b=205, alpha=1  #lightblue, value= r=173, g=216, b=230, alpha=1  #lightcoral, value= r=240, g=128, b=128, alpha=1  #lightcyan, value= r=224, g=255, b=255, alpha=1  #lightgoldenrodyellow, value= r=250, g=250, b=210, alpha=1  #lightgray, value= r=211, g=211, b=211, alpha=1  #lightgreen, value= r=144, g=238, b=144, alpha=1  #lightgrey, value= r=211, g=211, b=211, alpha=1  #lightpink, value= r=255, g=182, b=193, alpha=1  #lightsalmon, value= r=255, g=160, b=122, alpha=1  #lightseagreen, value= r=32, g=178, b=170, alpha=1  #lightskyblue, value= r=135, g=206, b=250, alpha=1  #lightslategray, value= r=119, g=136, b=153, alpha=1  #lightslategrey, value= r=119, g=136, b=153, alpha=1  #lightsteelblue, value= r=176, g=196, b=222, alpha=1  #lightyellow, value= r=255, g=255, b=224, alpha=1  #lime, value= r=0, g=255, b=0, alpha=1  #limegreen, value= r=50, g=205, b=50, alpha=1  #linen, value= r=250, g=240, b=230, alpha=1  #magenta, value= r=255, g=0, b=255, alpha=1  #maroon, value= r=128, g=0, b=0, alpha=1  #mediumaquamarine, value= r=102, g=205, b=170, alpha=1  #mediumblue, value= r=0, g=0, b=205, alpha=1  #mediumorchid, value= r=186, g=85, b=211, alpha=1  #mediumpurple, value= r=147, g=112, b=219, alpha=1  #mediumseagreen, value= r=60, g=179, b=113, alpha=1  #mediumslateblue, value= r=123, g=104, b=238, alpha=1  #mediumspringgreen, value= r=0, g=250, b=154, alpha=1  #mediumturquoise, value= r=72, g=209, b=204, alpha=1  #mediumvioletred, value= r=199, g=21, b=133, alpha=1  #midnightblue, value= r=25, g=25, b=112, alpha=1  #mintcream, value= r=245, g=255, b=250, alpha=1  #mistyrose, value= r=255, g=228, b=225, alpha=1  #moccasin, value= r=255, g=228, b=181, alpha=1  #navajowhite, value= r=255, g=222, b=173, alpha=1  #navy, value= r=0, g=0, b=128, alpha=1  #oldlace, value= r=253, g=245, b=230, alpha=1  #olive, value= r=128, g=128, b=0, alpha=1  #olivedrab, value= r=107, g=142, b=35, alpha=1  #orange, value= r=255, g=165, b=0, alpha=1  #orangered, value= r=255, g=69, b=0, alpha=1  #orchid, value= r=218, g=112, b=214, alpha=1  #palegoldenrod, value= r=238, g=232, b=170, alpha=1  #palegreen, value= r=152, g=251, b=152, alpha=1  #paleturquoise, value= r=175, g=238, b=238, alpha=1  #palevioletred, value= r=219, g=112, b=147, alpha=1  #papayawhip, value= r=255, g=239, b=213, alpha=1  #peachpuff, value= r=255, g=218, b=185, alpha=1  #peru, value= r=205, g=133, b=63, alpha=1  #pink, value= r=255, g=192, b=203, alpha=1  #plum, value= r=221, g=160, b=221, alpha=1  #powderblue, value= r=176, g=224, b=230, alpha=1  #purple, value= r=128, g=0, b=128, alpha=1  #red, value= r=255, g=0, b=0, alpha=1  #rosybrown, value= r=188, g=143, b=143, alpha=1  #royalblue, value= r=65, g=105, b=225, alpha=1  #saddlebrown, value= r=139, g=69, b=19, alpha=1  #salmon, value= r=250, g=128, b=114, alpha=1  #sandybrown, value= r=244, g=164, b=96, alpha=1  #seagreen, value= r=46, g=139, b=87, alpha=1  #seashell, value= r=255, g=245, b=238, alpha=1  #sienna, value= r=160, g=82, b=45, alpha=1  #silver, value= r=192, g=192, b=192, alpha=1  #skyblue, value= r=135, g=206, b=235, alpha=1  #slateblue, value= r=106, g=90, b=205, alpha=1  #slategray, value= r=112, g=128, b=144, alpha=1  #slategrey, value= r=112, g=128, b=144, alpha=1  #snow, value= r=255, g=250, b=250, alpha=1  #springgreen, value= r=0, g=255, b=127, alpha=1  #steelblue, value= r=70, g=130, b=180, alpha=1  #tan, value= r=210, g=180, b=140, alpha=1  #teal, value= r=0, g=128, b=128, alpha=1  #thistle, value= r=216, g=191, b=216, alpha=1  #tomato, value= r=255, g=99, b=71, alpha=1  #transparent, value= r=0, g=0, b=0, alpha=0  #turquoise, value= r=64, g=224, b=208, alpha=1  #violet, value= r=238, g=130, b=238, alpha=1  #wheat, value= r=245, g=222, b=179, alpha=1  #white, value= r=255, g=255, b=255, alpha=1  #whitesmoke, value= r=245, g=245, b=245, alpha=1  #yellow, value= r=255, g=255, b=0, alpha=1  #yellowgreen, value= r=154, g=205, b=50, alpha=1",
        "url":"/wiki/UnitsAndConstants.html"
      }
      ,
    
      "wiki-unitsandconstantspdf-html": {
        "title": "Units and constants",
        "content": "Units and constantsThis file is automatically generated from java files. Do Not Edit It.IntroductionUnits can be used to qualify the values of numeric variables. By default, unqualified values are considered as:  meters for distances, lengths…  seconds for durations  cubic meters for volumes  kilograms for massesSo, an expression like:float foo &lt;- 1;will be considered as 1 meter if foo is a distance, or 1 second if it is a duration, or 1 meter/second if it is a speed. If one wants to specify the unit, it can be done very simply by adding the unit symbol (° or #) followed by an unit name after the numeric value, like:float foo &lt;- 1 °centimeter;orfloat foo &lt;- 1 #centimeter;In that case, the numeric value of foo will be automatically translated to 0.01 (meter). It is recommended to always use float as the type of the variables that might be qualified by units (otherwise, for example in the previous case, they might be truncated to 0). Several units names are allowed as qualifiers of numeric variables. These units represent the basic metric and US units. Composed and derived units (like velocity, acceleration, special volumes or surfaces) can be obtained by combining these units using the * and / operators. For instance:float one_kmh &lt;- 1 °km / °h const: true;float one_millisecond &lt;-1 °sec / 1000;float one_cubic_inch &lt;- 1 °sqin * 1 °inch;... etc ...Table of ContentsConstants  \\#e, value= 2.718281828459045, Comment: The e constant  \\#infinity, value= Infinity, Comment: A constant holding the positive infinity of type (Java Double.POSITIVE_INFINITY)  \\#max_float, value= 1.7976931348623157E308, Comment: A constant holding the largest positive finite value of type float (Java Double.MAX_VALUE)  \\#max_int, value= 2.147483647E9, Comment: A constant holding the maximum value an int can have (Java Integer.MAX_VALUE)  \\#min_float, value= 4.9E-324, Comment: A constant holding the smallest positive nonzero value of type float (Java Double.MIN_VALUE)  \\#min_int, value= -2.147483648E9, Comment: A constant holding the minimum value an int can have (Java Integer.MIN_VALUE)  \\#nan, value= NaN, Comment: A constant holding a Not-a-Number (NaN) value of type float (Java Double.POSITIVE_INFINITY)  \\#pi, value= 3.141592653589793, Comment: The PI constant  \\#to_deg, value= 57.29577951308232, Comment: A constant holding the value to convert radians into degrees  \\#to_rad, value= 0.017453292519943295, Comment: A constant holding the value to convert degrees into radiansGraphics units  \\#bold, value= 1, Comment: This constant allows to build a font with a bold face. Can be combined with #italic  \\#camera_location, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current position of the camera as a point  \\#camera_orientation, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current orientation of the camera as a point  \\#camera_target, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current target of the camera as a point  \\#display_height, value= 1.0, Comment: This constant is only accessible in a graphical context: display, graphics…  \\#display_width, value= 1.0, Comment: This constant is only accessible in a graphical context: display, graphics…  \\#flat, value= 2, Comment: This constant represents a flat line buffer end cap style  \\#horizontal, value= 3, Comment: This constant represents a layout where all display views are aligned horizontally  \\#italic, value= 2, Comment: This constant allows to build a font with an italic face. Can be combined with #bold  \\#none, value= 0, Comment: This constant represents the absence of a predefined layout  \\#pixels (#px), value= 1.0, Comment: This unit, only available when running aspects or declaring displays,  returns a dynamic value instead of a fixed one. px (or pixels), returns the value of one pixel on the current view in terms of model units.  \\#plain, value= 0, Comment: This constant allows to build a font with a plain face  \\#round, value= 1, Comment: This constant represents a round line buffer end cap style  \\#split, value= 2, Comment: This constant represents a layout where all display views are split in a grid-like structure  \\#square, value= 3, Comment: This constant represents a square line buffer end cap style  \\#stack, value= 1, Comment: This constant represents a layout where all display views are stacked  \\#user_location, value= No Default Value, Comment: This unit contains in permanence the location of the mouse on the display in which it is situated. The latest location is provided when it is out of a display  \\#vertical, value= 4, Comment: This constant represents a layout where all display views are aligned vertically  \\#zoom, value= 1.0, Comment: This unit, only available when running aspects or declaring displays, returns the current zoom level of the display as a positive float, where 1.0 represent the neutral zoom (100%)Length units  \\#cm (#centimeter,#centimeters), value= 0.009999999776482582, Comment: centimeter unit  \\#dm (#decimeter,#decimeters), value= 0.10000000149011612, Comment: decimeter unit  \\#foot (#feet,#ft), value= 0.3047999931871891, Comment: foot unit  \\#inch (#inches), value= 0.025399999432265757, Comment: inch unit  \\#km (#kilometer,#kilometers), value= 1000.0, Comment: kilometer unit  \\#m (#meter,#meters), value= 1.0, Comment: meter: the length basic unit  \\#mile (#miles), value= 1609.344, Comment: mile unit  \\#mm (#milimeter,#milimeters), value= 9.999999776482583E-4, Comment: millimeter unit  \\#yard (#yards), value= 0.9144, Comment: yard unitSurface units  \\#m2, value= 1.0, Comment: square meter: the basic unit for surfaces  \\#sqft (#square_foot,#square_feet), value= 0.09290303584691051, Comment: square foot unit  \\#sqin (#square_inch,#square_inches), value= 6.451599711591008E-4, Comment: square inch unit  \\#sqmi (#square_mile,#square_miles), value= 2589988.110336, Comment: square mile unitTime units  \\#custom, value= CUSTOM, Comment: custom: a custom date/time pattern that can be defined in the preferences of GAMA and reused in models  \\#cycle (#cycles), value= 1, Comment: cycle: the discrete measure of time in the simulation. Used to force a temporal expression to be expressed in terms of cycles rather than seconds  \\#day (#days), value= 86400.0, Comment: day time unit: defines an exact duration of 24 hours  \\#epoch, value= No Default Value, Comment: The epoch default starting date as defined by the ISO format (1970-01-01T00:00Z)  \\#h (#hour,#hours), value= 3600.0, Comment: hour time unit: defines an exact duration of 60 minutes  \\#iso_local, value= ISO_LOCAL_DATE_TIME, Comment: iso_local: the standard ISO 8601 output / parsing format for local dates (i.e. with no time-zone information)  \\#iso_offset, value= ISO_OFFSET_DATE_TIME, Comment: iso_offset: the standard ISO 8601 output / parsing format for dates with a time offset  \\#iso_zoned, value= ISO_ZONED_DATE_TIME, Comment: iso_zoned: the standard ISO 8601 output / parsing format for dates with a time zone  \\#minute (#minutes,#mn), value= 60.0, Comment: minute time unit: defined an exact duration of 60 seconds  \\#month (#months), value= 2592000.0, Comment: month time unit: does not define an exact duration. The duration will depend on the step/date at which this unit is computed.  \\#msec (#millisecond,#milliseconds,#ms), value= 0.001, Comment: millisecond time unit: defines an exact duration of 0.001 second  \\#now, value= 1.0, Comment: This value represents the current date  \\#sec (#second,#seconds,#s), value= 1.0, Comment: second: the time basic unit, with a fixed value of 1. All other durations are expressed with respect to it  \\#week (#weeks), value= 604800.0, Comment: week time unit: defines an exact duration of  7 days  \\#year (#years,#y), value= 3.1104E7, Comment: year time unit: does not define an exact duration. The duration will depend on the step/date at which this unit is computed.Volume units  \\#cl (#centiliter,#centiliters), value= 1.0E-5, Comment: centiliter unit  \\#dl (#deciliter,#deciliters), value= 1.0E-4, Comment: deciliter unit  \\#hl (#hectoliter,#hectoliters), value= 0.1, Comment: hectoliter unit  \\#l (#liter,#liters,#dm3), value= 0.001, Comment: liter unit  \\#m3, value= 1.0, Comment: cube meter: the basic unit for volumesWeight units  \\#gram (#grams), value= 0.001, Comment: gram unit  \\#kg (#kilo,#kilogram,#kilos), value= 1.0, Comment: second: the basic unit for weights  \\#longton (#lton), value= 1016.0469088000001, Comment: short ton unit  \\#ounce (#oz,#ounces), value= 0.028349523125, Comment: ounce unit  \\#pound (#lb,#pounds,#lbm), value= 0.45359237, Comment: pound unit  \\#shortton (#ston), value= 907.18474, Comment: short ton unit  \\#stone (#st), value= 6.35029318, Comment: stone unit  \\#ton (#tons), value= 1000.0, Comment: ton unitColorsIn addition to the previous units, GAML provides a direct access to the 147 named colors defined in CSS (see http://www.cssportal.com/css3-color-names/). E.g,rgb my_color &lt;- °teal;  \\#aliceblue, value= r=240, g=248, b=255, alpha=1  \\#antiquewhite, value= r=250, g=235, b=215, alpha=1  \\#aqua, value= r=0, g=255, b=255, alpha=1  \\#aquamarine, value= r=127, g=255, b=212, alpha=1  \\#azure, value= r=240, g=255, b=255, alpha=1  \\#beige, value= r=245, g=245, b=220, alpha=1  \\#bisque, value= r=255, g=228, b=196, alpha=1  \\#black, value= r=0, g=0, b=0, alpha=1  \\#blanchedalmond, value= r=255, g=235, b=205, alpha=1  \\#blue, value= r=0, g=0, b=255, alpha=1  \\#blueviolet, value= r=138, g=43, b=226, alpha=1  \\#brown, value= r=165, g=42, b=42, alpha=1  \\#burlywood, value= r=222, g=184, b=135, alpha=1  \\#cadetblue, value= r=95, g=158, b=160, alpha=1  \\#chartreuse, value= r=127, g=255, b=0, alpha=1  \\#chocolate, value= r=210, g=105, b=30, alpha=1  \\#coral, value= r=255, g=127, b=80, alpha=1  \\#cornflowerblue, value= r=100, g=149, b=237, alpha=1  \\#cornsilk, value= r=255, g=248, b=220, alpha=1  \\#crimson, value= r=220, g=20, b=60, alpha=1  \\#cyan, value= r=0, g=255, b=255, alpha=1  \\#darkblue, value= r=0, g=0, b=139, alpha=1  \\#darkcyan, value= r=0, g=139, b=139, alpha=1  \\#darkgoldenrod, value= r=184, g=134, b=11, alpha=1  \\#darkgray, value= r=169, g=169, b=169, alpha=1  \\#darkgreen, value= r=0, g=100, b=0, alpha=1  \\#darkgrey, value= r=169, g=169, b=169, alpha=1  \\#darkkhaki, value= r=189, g=183, b=107, alpha=1  \\#darkmagenta, value= r=139, g=0, b=139, alpha=1  \\#darkolivegreen, value= r=85, g=107, b=47, alpha=1  \\#darkorange, value= r=255, g=140, b=0, alpha=1  \\#darkorchid, value= r=153, g=50, b=204, alpha=1  \\#darkred, value= r=139, g=0, b=0, alpha=1  \\#darksalmon, value= r=233, g=150, b=122, alpha=1  \\#darkseagreen, value= r=143, g=188, b=143, alpha=1  \\#darkslateblue, value= r=72, g=61, b=139, alpha=1  \\#darkslategray, value= r=47, g=79, b=79, alpha=1  \\#darkslategrey, value= r=47, g=79, b=79, alpha=1  \\#darkturquoise, value= r=0, g=206, b=209, alpha=1  \\#darkviolet, value= r=148, g=0, b=211, alpha=1  \\#deeppink, value= r=255, g=20, b=147, alpha=1  \\#deepskyblue, value= r=0, g=191, b=255, alpha=1  \\#dimgray, value= r=105, g=105, b=105, alpha=1  \\#dimgrey, value= r=105, g=105, b=105, alpha=1  \\#dodgerblue, value= r=30, g=144, b=255, alpha=1  \\#firebrick, value= r=178, g=34, b=34, alpha=1  \\#floralwhite, value= r=255, g=250, b=240, alpha=1  \\#forestgreen, value= r=34, g=139, b=34, alpha=1  \\#fuchsia, value= r=255, g=0, b=255, alpha=1  \\#gainsboro, value= r=220, g=220, b=220, alpha=1  \\#ghostwhite, value= r=248, g=248, b=255, alpha=1  \\#gold, value= r=255, g=215, b=0, alpha=1  \\#goldenrod, value= r=218, g=165, b=32, alpha=1  \\#gray, value= r=128, g=128, b=128, alpha=1  \\#green, value= r=0, g=128, b=0, alpha=1  \\#greenyellow, value= r=173, g=255, b=47, alpha=1  \\#grey, value= r=128, g=128, b=128, alpha=1  \\#honeydew, value= r=240, g=255, b=240, alpha=1  \\#hotpink, value= r=255, g=105, b=180, alpha=1  \\#indianred, value= r=205, g=92, b=92, alpha=1  \\#indigo, value= r=75, g=0, b=130, alpha=1  \\#ivory, value= r=255, g=255, b=240, alpha=1  \\#khaki, value= r=240, g=230, b=140, alpha=1  \\#lavender, value= r=230, g=230, b=250, alpha=1  \\#lavenderblush, value= r=255, g=240, b=245, alpha=1  \\#lawngreen, value= r=124, g=252, b=0, alpha=1  \\#lemonchiffon, value= r=255, g=250, b=205, alpha=1  \\#lightblue, value= r=173, g=216, b=230, alpha=1  \\#lightcoral, value= r=240, g=128, b=128, alpha=1  \\#lightcyan, value= r=224, g=255, b=255, alpha=1  \\#lightgoldenrodyellow, value= r=250, g=250, b=210, alpha=1  \\#lightgray, value= r=211, g=211, b=211, alpha=1  \\#lightgreen, value= r=144, g=238, b=144, alpha=1  \\#lightgrey, value= r=211, g=211, b=211, alpha=1  \\#lightpink, value= r=255, g=182, b=193, alpha=1  \\#lightsalmon, value= r=255, g=160, b=122, alpha=1  \\#lightseagreen, value= r=32, g=178, b=170, alpha=1  \\#lightskyblue, value= r=135, g=206, b=250, alpha=1  \\#lightslategray, value= r=119, g=136, b=153, alpha=1  \\#lightslategrey, value= r=119, g=136, b=153, alpha=1  \\#lightsteelblue, value= r=176, g=196, b=222, alpha=1  \\#lightyellow, value= r=255, g=255, b=224, alpha=1  \\#lime, value= r=0, g=255, b=0, alpha=1  \\#limegreen, value= r=50, g=205, b=50, alpha=1  \\#linen, value= r=250, g=240, b=230, alpha=1  \\#magenta, value= r=255, g=0, b=255, alpha=1  \\#maroon, value= r=128, g=0, b=0, alpha=1  \\#mediumaquamarine, value= r=102, g=205, b=170, alpha=1  \\#mediumblue, value= r=0, g=0, b=205, alpha=1  \\#mediumorchid, value= r=186, g=85, b=211, alpha=1  \\#mediumpurple, value= r=147, g=112, b=219, alpha=1  \\#mediumseagreen, value= r=60, g=179, b=113, alpha=1  \\#mediumslateblue, value= r=123, g=104, b=238, alpha=1  \\#mediumspringgreen, value= r=0, g=250, b=154, alpha=1  \\#mediumturquoise, value= r=72, g=209, b=204, alpha=1  \\#mediumvioletred, value= r=199, g=21, b=133, alpha=1  \\#midnightblue, value= r=25, g=25, b=112, alpha=1  \\#mintcream, value= r=245, g=255, b=250, alpha=1  \\#mistyrose, value= r=255, g=228, b=225, alpha=1  \\#moccasin, value= r=255, g=228, b=181, alpha=1  \\#navajowhite, value= r=255, g=222, b=173, alpha=1  \\#navy, value= r=0, g=0, b=128, alpha=1  \\#oldlace, value= r=253, g=245, b=230, alpha=1  \\#olive, value= r=128, g=128, b=0, alpha=1  \\#olivedrab, value= r=107, g=142, b=35, alpha=1  \\#orange, value= r=255, g=165, b=0, alpha=1  \\#orangered, value= r=255, g=69, b=0, alpha=1  \\#orchid, value= r=218, g=112, b=214, alpha=1  \\#palegoldenrod, value= r=238, g=232, b=170, alpha=1  \\#palegreen, value= r=152, g=251, b=152, alpha=1  \\#paleturquoise, value= r=175, g=238, b=238, alpha=1  \\#palevioletred, value= r=219, g=112, b=147, alpha=1  \\#papayawhip, value= r=255, g=239, b=213, alpha=1  \\#peachpuff, value= r=255, g=218, b=185, alpha=1  \\#peru, value= r=205, g=133, b=63, alpha=1  \\#pink, value= r=255, g=192, b=203, alpha=1  \\#plum, value= r=221, g=160, b=221, alpha=1  \\#powderblue, value= r=176, g=224, b=230, alpha=1  \\#purple, value= r=128, g=0, b=128, alpha=1  \\#red, value= r=255, g=0, b=0, alpha=1  \\#rosybrown, value= r=188, g=143, b=143, alpha=1  \\#royalblue, value= r=65, g=105, b=225, alpha=1  \\#saddlebrown, value= r=139, g=69, b=19, alpha=1  \\#salmon, value= r=250, g=128, b=114, alpha=1  \\#sandybrown, value= r=244, g=164, b=96, alpha=1  \\#seagreen, value= r=46, g=139, b=87, alpha=1  \\#seashell, value= r=255, g=245, b=238, alpha=1  \\#sienna, value= r=160, g=82, b=45, alpha=1  \\#silver, value= r=192, g=192, b=192, alpha=1  \\#skyblue, value= r=135, g=206, b=235, alpha=1  \\#slateblue, value= r=106, g=90, b=205, alpha=1  \\#slategray, value= r=112, g=128, b=144, alpha=1  \\#slategrey, value= r=112, g=128, b=144, alpha=1  \\#snow, value= r=255, g=250, b=250, alpha=1  \\#springgreen, value= r=0, g=255, b=127, alpha=1  \\#steelblue, value= r=70, g=130, b=180, alpha=1  \\#tan, value= r=210, g=180, b=140, alpha=1  \\#teal, value= r=0, g=128, b=128, alpha=1  \\#thistle, value= r=216, g=191, b=216, alpha=1  \\#tomato, value= r=255, g=99, b=71, alpha=1  \\#transparent, value= r=0, g=0, b=0, alpha=0  \\#turquoise, value= r=64, g=224, b=208, alpha=1  \\#violet, value= r=238, g=130, b=238, alpha=1  \\#wheat, value= r=245, g=222, b=179, alpha=1  \\#white, value= r=255, g=255, b=255, alpha=1  \\#whitesmoke, value= r=245, g=245, b=245, alpha=1  \\#yellow, value= r=255, g=255, b=0, alpha=1  \\#yellowgreen, value= r=154, g=205, b=50, alpha=1",
        "url":"/wiki/UnitsAndConstantsPDF.html"
      }
      ,
    
      "wiki-updating-html": {
        "title": "Updating GAMA",
        "content": "Updating GAMAUnless you are using the version of GAMA built from the sources available in the GIT repository of the project (see here), you are normally running a specific release of GAMA that sports a given version number (e.g. GAMA 1.6.1, GAMA 1.7, etc.). When new features were developed, or when serious issues were fixed, the release you had on your disk, prior to GAMA 1.6.1, could not benefit from them. Since this version, however, GAMA has been enhanced to support a self_update mechanism, which allows to import from the GAMA update site additional plugins (offering new features) or updated versions of the plugins that constitute the core of GAMA.Table of contents  Updating GAMA          Manual Update      Automatic Update      Manual UpdateTo activate this feature, you have to invoke the “Check for Updates” or “Install New Software…” menu commands in the “Help” menu.The first one will only check if the existing plugins have any updates available, while the second will, in addition, scan the update site to detect any new plugins that might be added to the current installation.In general, it is preferable to use the second command, as more options (including that of desinstalling some plugins) are provided. Once invoked, it makes the following dialog appear:GAMA expects the user to enter a so-called update site. You can copy and paste the following line (or choose it from the drop-down menu as this address is built inside GAMA):http://updates.gama-platform.orgGAMA will then scan the entire update site, looking both for new plugins (the example below) and updates to existing plugins. The list available in your installation will of course be different from the one displayed here.Choose the ones you want to install (or update) and click “Next…”. A summary page will appear, indicating which plugins will actually be installed (since some plugins might require additional plugins to run properly), followed by a license page that you have to accept. GAMA will then proceed to the installation (that can be cancelled any time) of the plugins chosen.During the course of the installation, you might receive the following warning, that you can dismiss by clicking “OK”.Once the plugins are installed, GAMA will ask you whether you want to restart or not. It is always safer to do so, so select “Yes” and let it close by itself, register the new plugins and restart.Automatic UpdateGAMA offers a mechanism to monitor the availability of updates to the plugins already installed. To install this feature, open the preferences of GAMA and choose the button “Advanced…”, which gives access to additional preferences.In the dialog that appears, navigate to “Install/Update &gt; Automatic Updates”. Then, enable the option using the check-box on the top of the dialog and choose the best settings for your workflow. Clicking on “OK” will save these preferences and dismiss the dialog.From now on, GAMA will continuously support you in having an up-to-date version of the platform, provided you accept the updates.",
        "url":"/wiki/Updating.html"
      }
      ,
    
      "wiki-urban-growth-raster-model-html": {
        "title": "Cellular Automaton Based Urban Growth",
        "content": "Cellular Automaton Based Urban GrowthAuthor : Truong Chi Quang, Patrick Taillandier, Benoit Gaudou &amp; Alexis Drogoulmodel based on the one proposed by (Raimbault et al., 2014): At each simulation step the nb_plots_to_build empty plots with the highest constructability are built The constructability is computed from 3 criteria: the density of construction in the neighborhood, the distance to a road, the distance to the city center (using the road network).Code of the model :model raster3global{ \t//File for the ascii grid\tfile asc_grid &lt;- grid_file(\"../includes/cantho_1999_v6.asc\");\t//Shapefile for the road\tfile road_shapefile &lt;- shape_file(\"../includes/roads15_3.shp\");\t//Shapefile for the city\tfile city_center_shapefile &lt;- shape_file(\"../includes/city center.shp\");\t//Shape of the environment\tgeometry shape &lt;- envelope(asc_grid);\t//Graph of the roads\tgraph roads_network;\t\t// Dynamic list of the cells to consider at each cycle\tlist&lt;plot&gt; empty_plots &lt;- plot where (each.grid_value = 0.0) update: shuffle(plot where (each.grid_value = 0.0));\t\tlist&lt;rgb&gt; plot_colors &lt;- [ \t\t#lightgray, //empty\t\t#orange, // 1 built\t\t#blue // 2 River-lake\t];\t//Radius of density\tint density_radius &lt;- 4;\t//Weight of density\tfloat weight_density &lt;- 0.05;\t//Weight of the road distance\tfloat weight_road_dist &lt;- 0.5;\t//Weight of the city center distance\tfloat weight_cc_dist &lt;- 0.3;\t//Number of plot allowing to build a building\tint nb_plots_to_build &lt;- 195;\tinit\t{\t\t//Creation of the roads using the shapefile of the road\t\tcreate roads from: road_shapefile;\t\t//Creation of the city center using the city center shapefile\t\tcreate city_center from: city_center_shapefile;\t\t//Creation of the graph of the road network\t\troads_network &lt;- as_edge_graph(roads);\t\t\t\t//Each road has to compute its distance from the city center\t\task roads {\t\t\tdo compute_cc_dist;\t\t}\t\t//Compute the city distance for each plot\t\task empty_plots {\t\t\tdo compute_distances;\t\t}\t\t//Normalization of the distance\t\tdo normalize_distances;\t}\t//Action to normalize the distance\taction normalize_distances {\t\t//Maximum distance from the road of all the plots\t\tfloat max_road_dist &lt;- empty_plots max_of each.dist_route;\t\t//Maximum distance from the city center for all the plots\t\tfloat max_cc_dist &lt;- empty_plots max_of each.dist_cv;\t\t//Normalization of  each empty plot according to the maximal value of each attribute\t\task empty_plots {\t\t\tdist_cv &lt;- 1 - dist_cv / max_cc_dist;\t\t\tdist_route &lt;- 1 - dist_route / max_road_dist;\t\t}\t}\t\t\t//Reflex representing the global dynamic of the model\treflex dynamique_globale when: weight_density != 0 or weight_road_dist != 0 or weight_cc_dist != 0 {\t\t//Ask to each empty plot to compute its constructability\t\task empty_plots {\t\t\tconstructability &lt;- compute_constructability();\t\t}\t\tlist&lt;plot&gt; ordered_plots &lt;- empty_plots sort_by (each.constructability);\t\tordered_plots &lt;- nb_plots_to_build last ordered_plots;\t\t//Build on each empty plot having the highest constructability\t\task ordered_plots\t\t{\t\t\tdo build;\t\t}\t}\t}//Species representing the city centerspecies city_center {\taspect default {\t\tdraw circle(300) color: #cyan;\t}\t}//Species representing the roadsspecies roads{\tfloat dist_cv;\t//Action to compute the city center distance for the road\taction compute_cc_dist {\t\tusing topology(roads_network)\t\t{\t\t\tdist_cv &lt;- self distance_to first(city_center);\t\t}\t}\taspect default {\t\tdraw shape color: #black;\t\t}}//Grid species to represent the different building plotsgrid plot file: asc_grid use_individual_shapes: false use_regular_agents: false neighbors: 4{\trgb color &lt;- grid_value = -1 ? #white : plot_colors[int(grid_value)];\t//Distance from the road\tfloat dist_route &lt;- 0.0;\t//Distance from the city center\tfloat dist_cv &lt;- 0.0;\t//Constructability of the plot\tfloat constructability;\t\t//Action to compute all the distances for the cell\taction compute_distances\t{\t\troads route_pp &lt;- roads closest_to self;\t\tdist_route &lt;- (self distance_to route_pp) using topology(world);\t\tdist_cv &lt;- dist_route + route_pp.dist_cv;\t}\t//Action to build on the cell\taction build\t{\t\tgrid_value &lt;- 1.0;\t\tcolor &lt;- plot_colors[1];\t}\t//Action to compute the constructability of the plot cell\tfloat compute_constructability\t{\t\t//Get all the neighbours plots\t\tlist&lt;plot&gt; voisins &lt;- (self neighbors_at density_radius);\t\t//Compute the density of all the neighbours plots\t\tfloat densite &lt;- (voisins count (each.grid_value = 1.0)) / length(voisins);\t\treturn (densite * weight_density + dist_route * weight_road_dist + dist_cv * weight_cc_dist) / (weight_density + weight_road_dist + weight_cc_dist);\t}\t\t\t}experiment raster type: gui { \tparameter \"Weight of the density criteria\" var: weight_density; \tparameter \"Weight of the distance to roads criteria\" var: weight_road_dist; \tparameter \"Weight of the distance to city center criteria\" var: weight_cc_dist; \toutput { \t\tdisplay map type: opengl {\t\t\tgrid plot;\t\t\tspecies roads;\t\t\tspecies city_center;\t\t}\t}}",
        "url":"/wiki/Urban-Growth-raster-model.html"
      }
      ,
    
      "wiki-urban-growth-html": {
        "title": "Urban Growth",
        "content": "Urban GrowthThis sub-section is composed of the following models :  Cellular Automaton Based Urban Growth",
        "url":"/wiki/Urban-Growth.html"
      }
      ,
    
      "wiki-user-interaction-event-layer-html": {
        "title": "Event Feature",
        "content": "Event FeatureAuthor : Arnaud Grignard &amp; Patrick TaillandierModel which shows how to use the event layer to trigger an action according to an event occuring in the display. The experiment has two displays : one for the changing color event, one for the changing shape event.Code of the model :model event_layer_modelglobal{//number of agents to create\tint nbAgent &lt;- 500;\tinit\t{\t//creation of the agents\t\tcreate cell number: nbAgent\t\t{\t\t\tcolor &lt;- °green;\t\t}\t}\t//Action to change the color of the agents, according to the point to know which agents we're in intersection with the point\taction change_color (point loc, list&lt;cell&gt; selected_agents)\t{\t//change the color of the agents\t\task selected_agents\t\t{\t\t\tcolor &lt;- color = °green ? °pink : °green;\t\t}\t}\t//Action to change the shape of the agents, according to the point to know which agents we're in intersection with the point\taction change_shape (point loc, list&lt;cell&gt; selected_agents)\t{\t\task selected_agents\t\t{\t\t//change the bool attribute is_square to change the shape in the display\t\t\tis_square &lt;- not (is_square);\t\t}\t}}//Species cells moving randomlyspecies cell skills: [moving]{\trgb color;\tbool is_square &lt;- false;\treflex mm\t{\t\tdo wander amplitude: 30;\t}\taspect default\t{\t\tdraw is_square ? square(2) : circle(1) color: color;\t}}experiment Displays type: gui{\toutput\t{\t\tdisplay View_change_color\t\t{\t\t\tspecies cell aspect: default;\t\t\t//event, launches the action change_color if the event mouse_down (ie. the user clicks on the layer event) is triggered\t\t\tevent [mouse_down] action: change_color;\t\t}\t\tdisplay View_change_shape type: opengl\t\t{\t\t\tspecies cell;\t\t\t//event, launches the action change_shape if the event mouse_down (ie. the user clicks on the layer event) is triggered\t\t\tevent [mouse_down] action: change_shape;\t\t}\t}}",
        "url":"/wiki/User-Interaction-Event-Layer.html"
      }
      ,
    
      "wiki-user-interaction-moving-agents-html": {
        "title": "MovingAgents",
        "content": "MovingAgentsAuthor : drogoulShows how to move agents using two event layers : Click to grab an group of agents, click again to drop them. Press the keys “k” to kill the agents in the selection, and “d” to duplicate them.Code of the model :model MovingAgentsglobal{\tlist&lt;being&gt; moved_agents ;\tgeometry shape &lt;- square(1000);\tpoint target;\tgeometry zone &lt;- circle(100);\tbool can_drop;\tinit\t{\t\tcreate being number: 100;\t}\taction kill (list&lt;agent&gt; selectedAgent, point mousePosition)\t{\t\task moved_agents\t\t{\t\t\tdo die;\t\t}\t\tmoved_agents &lt;- list&lt;being&gt;([]);\t}\taction duplicate (list&lt;agent&gt; selectedAgent, point mousePosition)\t{\t\tgeometry available_space &lt;- (zone at_location target) - (union(moved_agents) + 10);\t\tcreate being number: length(moved_agents) with: (location: any_location_in(available_space));\t}\taction click (list&lt;agent&gt; selectedAgent, point mousePosition)\t{\t\tif (empty(moved_agents))\t\t{\t\t\tlist&lt;being&gt; selected_agents &lt;- being inside (zone at_location mousePosition);\t\t\tmoved_agents &lt;- selected_agents;\t\t\task selected_agents\t\t\t{\t\t\t\tdifference &lt;- mousePosition - location;\t\t\t\tcolor &lt;- # olive;\t\t\t}\t\t} else if (can_drop)\t\t{\t\t\task moved_agents\t\t\t{\t\t\t\tcolor &lt;- # burlywood;\t\t\t}\t\t\tmoved_agents &lt;- list&lt;being&gt;([]);\t\t}\t}\taction move (list&lt;agent&gt; selectedAgent, point mousePosition)\t{\t\tcan_drop &lt;- true;\t\ttarget &lt;- mousePosition;\t\tlist&lt;being&gt; other_agents &lt;- (being inside (zone at_location mousePosition)) - moved_agents;\t\tgeometry occupied &lt;- geometry(other_agents);\t\task moved_agents\t\t{\t\t\tlocation &lt;- mousePosition - difference;\t\t\tif (occupied intersects self)\t\t\t{\t\t\t\tcolor &lt;- # red;\t\t\t\tcan_drop &lt;- false;\t\t\t} else\t\t\t{\t\t\t\tcolor &lt;- # olive;\t\t\t}\t\t}\t}}species being skills: [moving]{\tgeometry shape &lt;- square(10);\tpoint difference &lt;- { 0, 0 };\trgb color &lt;- # burlywood;\treflex r\t{\t\tif (!(moved_agents contains self))\t\t{\t\t\tdo wander amplitude: 30;\t\t}\t}\taspect default\t{\t\tdraw shape color: color at: location;\t}}experiment \"Click and Move\" type: gui{\tfont regular &lt;- font(\"Helvetica\", 14, # bold);\toutput\t{\t\tdisplay \"Click and Move [OPENGL]\" type: opengl\t\t{\t\t\tgraphics \"Empty target\" \t\t\t{\t\t\t\tif (empty(moved_agents))\t\t\t\t{\t\t\t\t\tdraw zone at: target empty: false border: false color: #wheat;\t\t\t\t}\t\t\t}\t\t\tspecies being;\t\t\tevent mouse_move action: move;\t\t\tevent mouse_up action: click;\t\t\tevent 'k' action: kill;\t\t\tevent 'c' action: duplicate;\t\t\tgraphics \"Full target\" \t\t\t{\t\t\t\tint size &lt;- length(moved_agents);\t\t\t\tif (size &gt; 0)\t\t\t\t{\t\t\t\t\trgb c1 &lt;- rgb(#darkseagreen, 120);\t\t\t\t\trgb c2 &lt;- rgb(#firebrick, 120);\t\t\t\t\tdraw zone at: target empty: false border: false color: (can_drop ? c1 : c2);\t\t\t\t\tdraw string(size) at: target + { -30, -30 } font: regular color: # white;\t\t\t\t\tdraw \"'k': kill\" at: target + { -30, 0 } font: regular color: # white;\t\t\t\t\tdraw \"'c': copy\" at: target + { -30, 30 } font: regular color: # white;\t\t\t\t}\t\t\t}\t\t}\t\t\t\tdisplay \"Click and Move [JAVA2D]\" type: java2D\t\t{\t\t\tgraphics \"Empty target\" \t\t\t{\t\t\t\tif (empty(moved_agents))\t\t\t\t{\t\t\t\t\tdraw zone at: target empty: false border: false color: #wheat;\t\t\t\t}\t\t\t}\t\t\tspecies being;\t\t\tevent mouse_move action: move;\t\t\tevent mouse_up action: click;\t\t\tevent 'k' action: kill;\t\t\tevent 'c' action: duplicate;\t\t\tgraphics \"Full target\" \t\t\t{\t\t\t\tint size &lt;- length(moved_agents);\t\t\t\tif (size &gt; 0)\t\t\t\t{\t\t\t\t\trgb c1 &lt;- rgb(#darkseagreen, 120);\t\t\t\t\trgb c2 &lt;- rgb(#firebrick, 120);\t\t\t\t\tdraw zone at: target empty: false border: false color: (can_drop ? c1 : c2);\t\t\t\t\tdraw string(size) at: target + { -30, -30 } font: regular color: # white;\t\t\t\t\tdraw \"'k': kill\" at: target + { -30, 0 } font: regular color: # white;\t\t\t\t\tdraw \"'c': copy\" at: target + { -30, 30 } font: regular color: # white;\t\t\t\t}\t\t\t}\t\t}\t\t\t\t\t\t\t}}",
        "url":"/wiki/User-Interaction-Moving-Agents.html"
      }
      ,
    
      "wiki-user-interaction-user-command-html": {
        "title": "User Command",
        "content": "User CommandAuthor : Patrick TaillandierModel which shows how to use the user commands in order to create agents in the display. The user has two possibilities : create one agent, or create a number of agents, with the possibility to change their shape and a pink color. The user also has the possibility to change the color and the shapes of the agents.Code of the model :model usercommandglobal {\t//Number of agent to initialise\tint nbAgent &lt;- 1;\t\tinit {\t\t//Create the agent\t\tcreate cell number: nbAgent {\t\t\tcolor &lt;-°green;\t\t}\t}\t\t//These commands are displayed in the world layer\t//User command to create an agent according to the location where the user right click\tuser_command \"Create an agent\" {   \t\tcreate cell number: nbAgent with: [location::user_location]  {   \t\t\tcolor &lt;-°green;   \t\t} \t}\t//User command to create a given number of agents according\tuser_command \"Create agents\" {\t\t map input_values &lt;- user_input([\"Number\" :: nbAgent, \"shape\" :: \"circle\"]);     \t create cell number: int(input_values at \"Number\") with: [color:: °pink, is_square:: string(input_values at \"shape\") = \"square\"];\t}\t}//Species that will be usedspecies cell {\trgb color;\t\tbool is_square &lt;- false; \t\t//These commands will be displayed in the cells layer, after right clicking on a agent\tuser_command \"change color\"action: change_color;\tuser_command \"change shape\" action: change_shape;\t\t//Action to change the color of the agent triggered by change color user command\taction change_color     {     color &lt;- color = °green ? °pink : °green;    } \t//Action to change the shape of the agent triggered by change shape user command    action change_shape    {       is_square &lt;- not (is_square);    }\taspect default {\t\tdraw is_square ? square(2): circle(1) color: color;\t}}experiment Displays type: gui {\toutput {\t\tdisplay map { \t\t\tspecies cell;\t\t}\t}}",
        "url":"/wiki/User-Interaction-User-Command.html"
      }
      ,
    
      "wiki-user-interaction-user-control-architecture-html": {
        "title": "User Command",
        "content": "User CommandAuthor : Patrick TaillandierModel which shows how to use the advanced user control, to create and kill agents.Code of the model :model user_controlglobal {\tint nbAgent &lt;- 10;\tbool advanced_user_control &lt;- false;\tinit {\t\tcreate cell number: nbAgent {\t\t\tcolor &lt;-°green;\t\t}\t\tcreate user;\t}}species cell {\trgb color;\t\taspect default {\t\tdraw circle(1) color: color;\t}}species user control:user_only {   user_panel \"Default\" initial: true {      transition to: \"Basic Control\" when: every (10) and !advanced_user_control;      transition to: \"Advanced Control\" when: every(10) and advanced_user_control;   }      user_panel \"Basic Control\" {      user_command \"Kill one cell\" {         ask (one_of(cell)){            do die;         }      }      user_command \"Create one cell\" {        create cell { \t\t\tcolor &lt;-°green; \t\t}      }       transition to: \"Default\" when: true;                       }   user_panel \"Advanced Control\" {      user_command \"Kill cells\" color: #red continue: true{        user_input \"Number\" returns: number type: int &lt;- 10;        ask (number among list(cell)){           do die;        }      }      user_command \"Create cells\" color: #green {        user_input \"Number\" returns: number type: int &lt;- 10;        create cell number: number ;      }       transition to: \"Default\" when: true;           }}experiment Displays type: gui {\tparameter \"advanced user control\" var: advanced_user_control &lt;- false;\toutput { \t\tdisplay map { \t\t\tspecies cell;\t\t}\t}}",
        "url":"/wiki/User-Interaction-User-Control-Architecture.html"
      }
      ,
    
      "wiki-user-interaction-html": {
        "title": "User Interaction",
        "content": "User InteractionThis sub-section is composed of the following models :      Event Feature        MovingAgents        User Command        User Command  ",
        "url":"/wiki/User-Interaction.html"
      }
      ,
    
      "wiki-usingbdi-html": {
        "title": "Using BDI",
        "content": "Using BDIInstallYou need to run the Git version.The plugin need to be add with Eclipse doing the following:  In ummisco.gama.feature.core open the feature.xml file.  In plug-ins click add the msi.gaml.architecture.simplebdiActeur ProjetA website (still in construction) of the ACTEUR project can be found here http://acteur-anr.fr/An introduction to cognitive agentThe belief-desire-intention software model (usually referred to simply, but ambiguously, as BDI) is a software model developed for programming intelligent agents.  Belief: State of the agent.  Desire: Objectives that the agent would like to accomplish.  Intention: What the agent has chosen to do.          Plan: Sequences of actions that an agent can perform to achieve one or more of its intensions.      Basic Example: A fire rescue model using cognitive agentWe introduce a simple example to illustrate the use of the BDI architecture.This simple model consists in creating “cognitive” agent whose goal is to extinguish a fire. In a first approximation we consider only one static water area and fire area. The aim is not to have a realistic model but to illustrate how to give a “cognitive” behavior to an agent using the BDI architecture.First let’s create a BDI agent using the key control simple_bdi (A description of all existing control architectures is available here.)Species Helicopter creationspecies helicopter skills:[moving] control: simple_bdi{...}AttributesThe species helicopter needs 2 attributes to represent the water value and its speed.float waterValue;float speed &lt;- 10.0;PredicatesThe predicate are the structure that are used to define a belief, a desire or an intention.In this model we choose to declare 3 different predicates.predicate patrol_desire &lt;- new_predicate(\"patrol\") with_priority 1;predicate water_predicate &lt;- new_predicate(\"has water\", true) with_priority 3;predicate no_water_predicate &lt;- new_predicate(\"has water\", false) ;The new_predicate() tool creates a predicate. It needs a name (string type) and it can contain a map of values, a priority (double type) or a truth value (boolean type).The with_priority tool add a priority to a predicate. The priority is used as an argument when the agent has to choose between two predicates (to choose an intention for example).InitializationThe initialization consists in setting the attribute waterValue to 1 and to add one desire. Three optional parameters are also set. The first desire added in the desire base is the patrol_desire saying that the helicopter wants to patrol. The optional parameters are specific to the BDI plug-in. You can specify the commitment of an agent to his intentions and his plans with the variables intention_persistence and plan_persistence that are floats between 0.0 (no commitment) and 1.0. The variable probabilistic_choice is a boolean that enables the agent to use a probabilistic choice (when true) or a deterministic choice (when false) when trying to find a plan or an intention.waterValue &lt;-1.0;do add_desire(patrol_desire);intention_persistence &lt;- 1.0;plan_persistence &lt;- 1.0;probabilistic_choice &lt;- false;\tPerceptionAt each iteration, the helicopter has two perceptions to do. The first one is about itself. The helicopter needs to perceive if it has water or not. If it has water, it adds the belief corresponding belief and removes the belief that it does not have water. And if it does not have water, that is the contrary.perceive target:self{\tif(waterValue&gt;0){\t\tdo add_belief(water_predicate);\t\tdo remove_belief(no_water_predicate);\t}\tif(waterValue&lt;=0){\t\tdo add_belief(no_water_predicate);\t\tdo remove_belief(water_predicate);\t}}The second perception is about the fires. Here, the fires are represented with the species fireArea. The helicopter has a radius of perception of 10 meters. If it perceives a fire, it will focus on the location of this fire. The focus tool create a belief with the same name as the focus (here, “fireLocation”) and will store the value of the focused variable (here, the variable location from the specie fireArea) with a priority of 10 in this example. Once the fire is perceived, the helicopter removes its intention of patrolling.perceive target:fireArea in: 10{\tfocus fireLocation var:location priority:10;\task myself{\t\tdo remove_intention(patrol_desire, true);\t}}RulesThe agent can use rules to create desires from beliefs. In this example, the agent has two rules. The first rule is to have a desire corresponding to the belief of a location of a fire. It means that when the agent has the belief that there is a fire in a particular location, it will have the desire to extinguish it. This permits to have the location value in the desire base.The second rule is to create the desire to have water when the agent has the belief that it not has water.rule belief: new_predicate(\"fireLocation\") new_desire: get_belief_with_name(\"fireLocation\");rule belief: no_water_predicate new_desire: water_predicate;PlanPatrollingThis plan will be used when the agent has the intention to patrol.plan patrolling intention: patrol_desire{  do wander;}stopFireThis plan is executed when the agent has the intention to extinguish a fire.plan stopFire intention: new_predicate(\"fireLocation\") {\tpoint target_fire &lt;- point(get_current_intention().values[\"location_value\"] );\tif(waterValue&gt;0){\t\tif (self distance_to target_fire &lt;= 1) {\t\t\tfireArea current_fire &lt;- fireArea first_with (each.location = target_fire);\t\t\tif (current_fire != nil) {\t\t\t\t waterValue &lt;- waterValue - 1.0;\t\t\t\t current_fire.size &lt;-  current_fire.size - 1;\t\t\t\t if ( current_fire.size &lt;= 0) {\t\t\t\t\task  current_fire {do die;}\t\t\t\t\tdo remove_belief(get_current_intention());\t\t\t\t\tdo remove_intention(get_current_intention(), true);\t\t\t\t\tdo add_desire(patrol_desire);\t\t\t\t}\t\t\t} else {\t\t\t\tdo remove_belief(get_current_intention());\t\t\t\tdo remove_intention(get_current_intention(), true);\t\t\t\tdo add_desire(patrol_desire);\t\t\t}\t\t} else {\t\t\tdo goto target: target_fire;\t\t}\t} else {\t\tdo add_subintention(get_current_intention(),water_predicate,true);\t\tdo current_intention_on_hold();\t}}gotoTakeWaterThis plan is executed when the agent has the intention to have water.plan gotoTakeWater intention: water_predicate {    \twaterArea wa &lt;- first(waterArea);        do goto target: wa);    \tif (self distance_to wa &lt;= 1) {    \t\twaterValue &lt;- waterValue + 2.0;\t}}Plans can have other options. They can have a priority (with the facet priority), a boolean condition to start (with the facet when) or a boolean condition to stop (with the facet finished_when).Rest of the codeAspect of the helicopteraspect base {\tdraw circle(1) color: #black;\t}FireArea Speciesspecies fireArea{        float size &lt;-1.0;\t        aspect base {          draw circle(size) color: #red;        }}WaterArea Speciesspecies waterArea{\tfloat size &lt;-10.0;\taspect base {\t  draw circle(size) color: #blue;\t\t\t}}",
        "url":"/wiki/UsingBDI.html"
      }
      ,
    
      "wiki-usingdatabase-html": {
        "title": "Using Database Access",
        "content": "Using Database AccessDatabase features of GAMA provide a set of actions on Database Management Systems (DBMS) and Multi-Dimensional Database for agents in GAMA. Database features are implemented in the irit.gaml.extensions.database plug-in with these features:  Agents can execute SQL queries (create, Insert, select, update, drop, delete) to various kinds of DBMS.  Agents can execute MDX (Multidimensional Expressions) queries to select multidimensional objects, such as cubes, and return multidimensional cellsets that contain the cube’s data .These features are implemented in two kinds of component: skills (SQLSKILL, MDXSKILL) and agent (AgentDB)SQLSKILL and AgentDB provide almost the same features (a same set of actions on DBMS) but with certain slight differences:  An agent of species AgentDB will maintain a unique connection to the database during the whole simulation. The connection is thus initialized when the agent is created.  In contrast, an agent of a species with the SQLSKILL skill will open a connection each time he wants to execute a query. This means that each action will be composed of three running steps:          Make a database connection.      Execute SQL statement.      Close database connection.                  An agent with the SQLSKILL spends lot of time to create/close the connection each time it needs to send a query; it saves the database connection (DBMS often limit the number of simultaneous connections). In contrast, an AgentDB agent only needs to establish one database connection and it can be used for any actions. Because it does not need to create and close database connection for each action: therefore, actions of AgentDB agents are executed faster than actions of SQLSKILL ones but we must pay a connection for each agent.                      With an inheritance agent of species AgentDB  or an agent of a species using SQLSKILL, we can query data from relational database for creating species, defining environment or analyzing or storing simulation results into RDBMS. On the other hand, an agent of species with MDXKILL supports the OLAP technology to query data from data marts (multidimensional database).The database features help us to have more flexibility in management of simulation models and analysis of simulation results.Description  Plug-in: irit.gaml.extensions.database  Author: TRUONG Minh Thai, Frederic AMBLARD, Benoit GAUDOU, Christophe SIBERTIN-BLANCSupported DBMSThe following DBMS are currently supported:  SQLite  MySQL Server  PostgreSQL Server  SQL Server  Mondrian OLAP Server  SQL Server Analysis ServicesNote that, other DBMSs require a dedicated server to work while SQLite on only needs a file to be accessed.All the actions can be used independently from the chosen DBMS. Only the connection parameters are DBMS-dependent.SQLSKILLDefine a species that uses the SQLSKILL skillExample of declaration:species toto skills: [SQLSKILL] {\t//insert your descriptions here}Agents with such a skill can use additional actions (defined in the skill)Map of connection parameters for SQLIn the actions defined in the SQLSkill, a parameter containing the connection parameters is required. It is a map with the following key::value pairs:| Key | Optional | Description ||:——-|:——–|:——————————————————–|| dbtype | No | DBMS type value. Its value is a string. We must use “mysql” when we want to connect to a MySQL. That is the same for “postgres”, “sqlite” or “sqlserver” (ignore case sensitive) || host  | Yes | Host name or IP address of data server. It is absent when we work with SQlite. || port  | Yes | Port of connection. It is not required when we work with SQLite.|| database | No | Name of database. It is the file name including the path when we work with SQLite. || user  | Yes | Username. It is not required when we work with SQLite. || passwd | Yes | Password. It is not required when we work with SQLite. || srid    | Yes | srid (Spatial Reference Identifier)  corresponds to a spatial reference system. This value is specified when GAMA connects to spatial database. If it is absent then GAMA uses spatial reference system defined in Preferences-&gt;External configuration. |Table 1: Connection parameter descriptionExample: Definitions of connection parameter// POSTGRES connection parametermap &lt;string, string&gt;  POSTGRES &lt;- [     'host'::'localhost',     'dbtype'::'postgres',     'database'::'BPH',     'port'::'5433',     'user'::'postgres',     'passwd'::'abc'];//SQLitemap &lt;string, string&gt;  SQLITE &lt;- [    'dbtype'::'sqlite',    'database'::'../includes/meteo.db'];// SQLSERVER connection parametermap &lt;string, string&gt; SQLSERVER &lt;- [    'host'::'localhost',    'dbtype'::'sqlserver',    'database'::'BPH',    'port'::'1433',    'user'::'sa',    'passwd'::'abc'];// MySQL connection parametermap &lt;string, string&gt;  MySQL &lt;- [    'host'::'localhost',    'dbtype'::'MySQL',    'database'::'', // it may be a null string    'port'::'3306',    'user'::'root',    'passwd'::'abc'];Test a connection to databaseSyntax:  testConnection (params: connection_parameter)The action tests the connection to a given database.      Return: boolean. It is:              true: the agent can connect to the DBMS (to the given Database with given name and password)        false: the agent cannot connect              Arguments:              params: (type = map) map of connection parameters              Exceptions: GamaRuntimeException  Example: Check a connection to MySQLif (self testConnection(params:MySQL)){\twrite \"Connection is OK\" ;}else{\twrite \"Connection is false\" ;}\tSelect data from databaseSyntax:  select (param: connection_parameter, select: selection_string,values: value_list)The action creates a connection to a DBMS and executes the select statement. If the connection or selection fails then it throws a GamaRuntimeException.      Return: list &lt; list &gt;. If the selection succeeds, it returns a list with three elements:              The first element is a list of column name.        The second element is a list of column type.        The third element is a data set.              Arguments:              params: (type = map) map containing the connection parameters        select: (type = string) select string. The selection string can contain question marks.        values: List of values that are used to replace question marks in appropriate. This is an optional parameter.              Exceptions: GamaRuntimeException  Example: select data from table pointsmap &lt;string, string&gt;   PARAMS &lt;- ['dbtype'::'sqlite', 'database'::'../includes/meteo.db'];list&lt;list&gt; t &lt;- list&lt;list&gt; (self select(params:PARAMS, \t\t                 select:\"SELECT * FROM points ;\"));Example: select data from table point with question marks from table pointsmap &lt;string, string&gt;   PARAMS &lt;- ['dbtype'::'sqlite', 'database'::'../includes/meteo.db'];list&lt;list&gt; t &lt;- list&lt;list&gt; (self select(params: PARAMS,                                            select: \"SELECT temp_min FROM points where (day&gt;? and day&lt;?);\"                                           values: [10,20] ));Insert data into databaseSyntax:  insert (param: connection_parameter,  into:  table_name, columns: column_list, values: value`_list)_The action creates a connection to a DBMS and executes the insert statement. If the connection or insertion fails then it throws a_GamaRuntimeException.      Return: intIf the insertion succeeds, it returns a number of records inserted by the insert.    Arguments:*params: (type = map) map containing the connection parameters.*into: (type = string) table name.*columns: (type=list)  list of column names of table. It is an optional argument. If it is not applicable then all columns of table are selected.*values: (type=list) list of values that are used to insert into table corresponding to columns. Hence the columns and values must have same size.    Exceptions:_GamaRuntimeException  Example: Insert data into table registrationmap&lt;string, string&gt; PARAMS &lt;- ['dbtype'::'sqlite', 'database'::'../../includes/Student.db'];do insert (params: PARAMS,                into: \"registration\",                values: [102, 'Mahnaz', 'Fatma', 25]);do insert (params: PARAMS,                 into: \"registration\",                 columns: [\"id\", \"first\", \"last\"],                 values: [103, 'Zaid tim', 'Kha']);int n &lt;- insert (params: PARAMS,                         into: \"registration\",                        columns: [\"id\", \"first\", \"last\"],                        values: [104, 'Bill', 'Clark']);Execution update commandsSyntax:  executeUpdate (param: connection_parameter,  updateComm:  table_name, values: value_list)The action executeUpdate executes an update command (create/insert/delete/drop) by using the current database connection of the agent. If the database connection does not exist or the update command fails then it throws a GamaRuntimeException. Otherwise it returns an integer value.      Return: int. If the insertion succeeds, it returns a number of records inserted by the insert.    Arguments:              params: (type = map) map containing the connection parameters        updateComm: (type = string) SQL command string. It may be commands: create, update, delete and drop with or without question marks.        columns: (type=list)  list of column names of table.        values: (type=list) list of values that are used to replace question marks if appropriate. This is an optional parameter.              Exceptions: GamaRuntimeException  Examples: Using action executeUpdate do sql commands (create, insert, update, delete and drop).map&lt;string, string&gt; PARAMS &lt;- ['dbtype'::'sqlite',  'database'::'../../includes/Student.db'];// Create tabledo executeUpdate (params: PARAMS,                               updateComm: \"CREATE TABLE registration\"                                              + \"(id INTEGER PRIMARY KEY, \"                                              + \" first TEXT NOT NULL, \" + \" last TEXT NOT NULL, \"                                              + \" age INTEGER);\");// Insert into do executeUpdate (params: PARAMS ,                               updateComm: \"INSERT INTO registration \" + \"VALUES(100, 'Zara', 'Ali', 18);\");do insert (params: PARAMS, into: \"registration\",                columns: [\"id\", \"first\", \"last\"],                values: [103, 'Zaid tim', 'Kha']);// executeUpdate with question marksdo executeUpdate (params: PARAMS,                             updateComm: \"INSERT INTO registration \" + \"VALUES(?, ?, ?, ?);\" ,                               values: [101, 'Mr', 'Mme', 45]);//update int n &lt;-  executeUpdate (params: PARAMS,                                        updateComm: \"UPDATE registration SET age = 30 WHERE id IN (100, 101)\" );// deleteint n &lt;- executeUpdate (params: PARAMS,                                       updateComm: \"DELETE FROM registration where id=? \",                                        values: [101] );// Drop tabledo executeUpdate (params: PARAMS, updateComm: \"DROP TABLE registration\");MDXSKILLMDXSKILL plays the role of an OLAP tool using select to query data from OLAP server to GAMA environment and then species can use the queried data for any analysis purposes.Define a species that uses the MDXSKILL skillExample of declaration:\tspecies olap skills: [MDXSKILL]\t {  \t\t//insert your descriptions here\t\t\t }       ...Agents with such a skill can use additional actions (defined in the skill)Map of connection parameters for MDXIn the actions defined in the SQLSkill, a parameter containing the connection parameters is required. It is a map with following key::value pairs:            Key      Optional      Description                  olaptype      No      OLAP Server type value. Its value is a string. We must use “SSAS/XMLA” when we want to connect to an SQL Server Analysis Services by using XML for Analysis. That is the same for “MONDRIAN/XML” or “MONDRIAN” (ignore case sensitive)              dbtype      No      DBMS type value. Its value is a string. We must use “mysql” when we want to connect to a MySQL. That is the same for “postgres” or “sqlserver” (ignore case sensitive)              host      No      Host name or IP address of data server.              port      No      Port of connection. It is no required when we work with SQLite.              database      No      Name of database. It is file name include path when we work with SQLite.              catalog      Yes      Name of catalog. It is an optional parameter. We do not need to use it when we connect to SSAS via XMLA and its file name includes the path when we connect a ROLAP database directly by using Mondrian API (see Example as below)              user      No      Username.              passwd      No      Password.      Table 2: OLAP Connection parameter descriptionExample: Definitions of OLAP connection parameter//Connect SQL Server Analysis Services via XMLA\tmap&lt;string,string&gt; SSAS &lt;- [\t\t\t\t'olaptype'::'SSAS/XMLA',\t\t\t\t'dbtype'::'sqlserver',\t\t\t\t'host'::'172.17.88.166',\t\t\t\t'port'::'80',\t\t\t\t'database'::'olap',\t\t\t\t'user'::'test',\t\t\t\t'passwd'::'abc'];//Connect Mondriam server via XMLA\tmap&lt;string,string&gt;  MONDRIANXMLA &lt;- [\t\t\t\t'olaptype'::\"MONDRIAN/XMLA\",\t\t\t\t'dbtype'::'postgres',\t\t\t\t'host'::'localhost',\t\t\t\t'port'::'8080',\t\t\t\t'database'::'MondrianFoodMart',\t\t\t\t'catalog'::'FoodMart',\t\t\t\t'user'::'test',\t\t\t\t'passwd'::'abc'];//Connect a ROLAP server using Mondriam API\t\tmap&lt;string,string&gt;  MONDRIAN &lt;- [\t\t\t\t'olaptype'::'MONDRIAN',\t\t\t\t'dbtype'::'postgres',\t\t\t\t'host'::'localhost',\t\t\t\t'port'::'5433',\t\t\t\t'database'::'foodmart',\t\t\t\t'catalog'::'../includes/FoodMart.xml',\t\t\t\t'user'::'test',                                'passwd'::'abc'];Test a connection to OLAP databaseSyntax:  testConnection (params: connection_parameter)The action tests the connection to a given OLAP database.      Return: boolean.  It is:              true: the agent can connect to the DBMS (to the given Database with given name and password)        false: the agent cannot connect              Arguments:              params: (type = map) map of connection parameters              Exceptions: GamaRuntimeException  Example: Check a connection to MySQLif (self testConnection(params:MONDIRANXMLA)){\twrite \"Connection is OK\";}else{\twrite \"Connection is false\";}\tSelect data from OLAP databaseSyntax:  select (param: connection_parameter, onColumns: column_string, onRows: row_string from: cube_string, where: condition_string, values: value_list)The action creates a connection to an OLAP database and executes the select statement. If the connection or selection fails then it throws a GamaRuntimeException.      Return: list &lt; list &gt;.  If the selection succeeds, it returns a list with three elements:              The first element is a list of column name.        The second element is a list of column type.        The third element is a data set.              Arguments:              params: (type = map) map containing the connection parameters        onColumns: (type = string) declare  the select string on columns. The selection string can contain question marks.        onRows: (type = string) declare the selection string on rows. The selection string can contain question marks.        from: (type = string) specify cube where data is selected. The cube_string can contain question marks.        where_: (type = string) specify the selection conditions. The condiction_string can contains question marks. This is an optional parameter.*values: List of values that are used to replace question marks if appropriate. This is an optional parameter.              Exceptions:_GamaRuntimeException  Example: select data from SQL Server Analysis Service via XMLAif (self testConnection[ params::SSAS]){\tlist l1  &lt;- list(self select (params: SSAS ,\t\tonColumns: \" { [Measures].[Quantity], [Measures].[Price] }\",\t\tonRows:\" { { { [Time].[Year].[All].CHILDREN } * \"\t\t+ \" { [Product].[Product Category].[All].CHILDREN } * \"\t\t+\"{ [Customer].[Company Name].&amp;[Alfreds Futterkiste], \" \t\t+\"[Customer].[Company Name].&amp;[Ana Trujillo Emparedadosy helados], \" \t\t+ \"[Customer].[Company Name].&amp;[Antonio Moreno Taquería] } } } \" ,\t\tfrom : \"FROM [Northwind Star] \"));\twrite \"result1:\"+ l1;}else {\twrite \"Connect error\";}Example: select data from Mondrian via XMLA with question marks in selectionif (self testConnection(params:MONDRIANXMLA)){\tlist&lt;list&gt; l2  &lt;- list&lt;list&gt; (self select(params: MONDRIANXMLA, \tonColumns:\" {[Measures].[Unit Sales], [Measures].[Store Cost], [Measures].[Store Sales]} \",\tonRows:\"  Hierarchize(Union(Union(Union({([Promotion Media].[All Media],\" \t+\" [Product].[All Products])}, \"\t+\" Crossjoin([Promotion Media].[All Media].Children, \"\t+\" {[Product].[All Products]})), \"\t+\" Crossjoin({[Promotion Media].[Daily Paper, Radio, TV]}, \"\t+\" [Product].[All Products].Children)), \"\t+\" Crossjoin({[Promotion Media].[Street Handout]}, \" \t+\" [Product].[All Products].Children)))  \",\tfrom:\" from [?] \" ,\twhere :\" where [Time].[?] \" ,\tvalues:[\"Sales\",1997]));\twrite \"result2:\"+ l2;}else {\twrite \"Connect error\";}AgentDBAgentBD is a built-in species, which supports behaviors that look like actions in SQLSKILL but differs slightly with SQLSKILL in that it uses  only one connection for several actions. It means that AgentDB makes a connection to DBMS and keeps that connection for its later operations with DBMS.Define a species that is an inheritance of agentDBExample of declaration:species agentDB parent: AgentDB {  \t//insert your descriptions here} Connect to databaseSyntax:  Connect (param: connection_parameter)This action makes a connection to DBMS. If a connection is established then it will assign the connection object into a built-in attribute of species (conn) otherwise it throws a GamaRuntimeException.      Return: connection    Arguments:              params: (type = map) map containing the connection parameters              Exceptions: GamaRuntimeExceptionExample: Connect to PostgreSQL  // POSTGRES connection parametermap &lt;string, string&gt;  POSTGRES &lt;- [                                        'host'::'localhost',                                        'dbtype'::'postgres',                                        'database'::'BPH',                                        'port'::'5433',                                        'user'::'postgres',                                        'passwd'::'abc'];ask agentDB {      do connect (params: POSTGRES);}Check agent connected a database or notSyntax:  isConnected (param: connection_parameter)This action checks if an agent is connecting to database or not.      Return: Boolean.   If agent is connecting to a database then isConnected returns true; otherwise it returns false.    Arguments:              params: (type = map) map containing the connection parameters            Example: Using action executeUpdate do sql commands (create, insert, update, delete and drop).ask agentDB {\tif (self isConnected){              write \"It already has a connection\";\t}else{              do connect (params: POSTGRES);        } }Close the current connectionSyntax:  closeThis action closes the current database connection of species. If species does not has a database connection then it throws a GamaRuntimeException.      Return: nullIf the current connection of species is close then the action return null value; otherwise it throws a GamaRuntimeException.  Example:ask agentDB {\tif (self isConnected){\t      do close;\t}}Get connection parameterSyntax:  getParameterThis action returns the connection parameter of species.      Return: map &lt; string, string &gt;  Example:ask agentDB {\tif (self isConnected){\t\twrite \"the connection parameter: \" +(self getParameter);        }}Set connection parameterSyntax:  setParameter (param: connection_parameter)This action sets the new values for connection parameter and closes the current connection of species. If it can not close the current connection then it will throw GamaRuntimeException. If the species wants to make the connection to database with the new values then action connect must be called.      Return: null    Arguments:              params: (type = map) map containing the connection parameters              Exceptions: GamaRuntimeException  Example:ask agentDB {\tif (self isConnected){             do setParameter(params: MySQL);             do connect(params: (self getParameter));        }}Retrieve data from database by using AgentDBBecause of the connection to database of AgentDB is kept alive then AgentDB can execute several SQL queries with only one connection. Hence AgentDB can do actions such as select, insert, executeUpdate with the same parameters of those actions of SQLSKILL except params parameter is always absent.Examples:map&lt;string, string&gt; PARAMS &lt;- ['dbtype'::'sqlite', 'database'::'../../includes/Student.db'];ask agentDB {   do connect (params: PARAMS);   // Create table   do executeUpdate (updateComm: \"CREATE TABLE registration\" \t+ \"(id INTEGER PRIMARY KEY, \"         + \" first TEXT NOT NULL, \" + \" last TEXT NOT NULL, \"         + \" age INTEGER);\");   // Insert into    do executeUpdate ( updateComm: \"INSERT INTO registration \"         + \"VALUES(100, 'Zara', 'Ali', 18);\");   do insert (into: \"registration\", \t columns: [\"id\", \"first\", \"last\"], \t values: [103, 'Zaid tim', 'Kha']);   // executeUpdate with question marks   do executeUpdate (updateComm: \"INSERT INTO registration VALUES(?, ?, ?, ?);\",  \t values: [101, 'Mr', 'Mme', 45]);   //select    list&lt;list&gt; t &lt;- list&lt;list&gt; (self select( \t select:\"SELECT * FROM registration;\"));    //update     int n &lt;-  executeUpdate (updateComm: \"UPDATE registration SET age = 30 WHERE id IN (100, 101)\");     // delete     int n &lt;- executeUpdate ( updateComm: \"DELETE FROM registration where id=? \",  values: [101] );     // Drop table      do executeUpdate (updateComm: \"DROP TABLE registration\");}Using database features to define environment or create speciesIn Gama, we can use results of select action of SQLSKILL or AgentDB to create species or define boundary of environment in the same way we do with shape files. Further more, we can also save simulation data that are generated by simulation including geometry data to database.Define the boundary of the environment from database  Step 1: specify select query by declaration a map object with keys as below:            Key      Optional      Description                  dbtype      No      DBMS type value. Its value is a string. We must use “mysql” when we want to connect to a MySQL. That is the same for “postgres”, “sqlite” or “sqlserver” (ignore case sensitive)              host      Yes      Host name or IP address of data server. It is absent when we work with SQlite.              port      Yes      Port of connection. It is not required when we work with SQLite.              database      No      Name of database. It is the file name including the path when we work with SQLite.              user      Yes      Username. It is  not required when we work with SQLite.              passwd      Yes      Password. It is  not required when we work with SQLite.              srid      Yes      srid (Spatial Reference Identifier)  corresponds to a spatial reference system. This value is specified when GAMA connects to spatial database. If it is absent then GAMA uses spatial reference system defined in Preferences-&gt;External configuration.              select      No      Selection string      Table 3: Select boundary parameter descriptionExample:map&lt;string,string&gt; BOUNDS &lt;- [\t\t//'srid'::'32648',\t'host'::'localhost',\t\t\t\t\t\t\t\t        'dbtype'::'postgres',\t'database'::'spatial_DB',\t'port'::'5433',\t\t\t\t\t\t\t\t        'user'::'postgres',\t'passwd'::'tmt',\t'select'::'SELECT ST_AsBinary(geom) as geom FROM bounds;' ];  Step 2: define boundary of environment by using the map object in first step.geometry shape &lt;- envelope(BOUNDS);Note: We can do the same way if we work with MySQL, SQLite, or SQLServer and we must convert Geometry format in GIS database to binary format.Create agents from the result of a select actionIf we are familiar with how to create agents from a shapefile then it becomes very simple to create agents from select result. We can do as below:  Step 1: Define a species with SQLSKILL or AgentDBspecies toto skills: SQLSKILL {\t//insert your descriptions here\t}\t  Step 2: Define a connection and selection parametersglobal {\tmap&lt;string,string&gt;  PARAMS &lt;- ['dbtype'::'sqlite','database'::'../includes/bph.sqlite'];\tstring location &lt;- 'select ID_4, Name_4, ST_AsBinary(geometry) as geom from vnm_adm4                                       where id_2=38253 or id_2=38254;';\t...}        Step 3: Create species by using selected resultsinit {   create toto { \t  create locations from: list(self select (params: PARAMS, \t\t                                                   select: LOCATIONS))                                    with:[ id:: \"id_4\", custom_name:: \"name_4\", shape::\"geom\"];\t}   ...}Save Geometry data to databaseIf we are familiar with how to create agents from a shapefile then it becomes very simple to create agents from select result. We can do as below:  Step 1: Define a species with SQLSKILL or AgentDBspecies toto skills: SQLSKILL {  \t//insert your descriptions here}   Step 2: Define a connection and create GIS database and tablesglobal {\tmap&lt;string,string&gt; PARAMS &lt;-  ['host'::'localhost', 'dbtype'::'Postgres', 'database'::'',                                                             'port'::'5433', 'user'::'postgres', 'passwd'::'tmt'];\tinit {\t\tcreate toto ;\t\task toto {\t\t\tif (self testConnection[ params::PARAMS]){\t\t\t    // create GIS database\t \t\t\t    do executeUpdate(params:PARAMS, \t\t                updateComm: \"CREATE DATABASE spatial_db with TEMPLATE = template_postgis;\");  \t\t\t    \tremove key: \"database\" from: PARAMS;\t\t\t\tput \"spatial_db\" key:\"database\" in: PARAMS;\t\t\t\t//create table                            do executeUpdate params: PARAMS \t\t\t\t  updateComm : \"CREATE TABLE buildings \"+\t\t\t\t  \"( \"  +                   \t               \" name character varying(255), \" +                                        \" type character varying(255), \" +                                        \" geom GEOMETRY \" +                                    \")\";\t\t\t}else { \t\t\t\twrite \"Connection to MySQL can not be established \"; \t\t\t}\t\t\t}\t}}  Step 3: Insert geometry data to GIS databaseask building {   ask DB_Accessor {\tdo insert(params: PARAMS,                         into: \"buildings\",\t\t\tcolumns: [\"name\", \"type\",\"geom\"],\t\t\tvalues: [myself.name,myself.type,myself.shape];   }}",
        "url":"/wiki/UsingDatabase.html"
      }
      ,
    
      "wiki-usingdrivingskill-html": {
        "title": "Advanced Driving Skill",
        "content": "Advanced Driving SkillThis page aims at presenting how to use the advanced driving skill in models.The use of the advanced driving skill requires to use 3 skills:  Advanced driving skill: dedicated to the definition of the driver species. It provides the driver agents with variables and actions allowing to move an agent on a graph network and to tune its behavior.  Road skill: dedicated to the definition of roads. It provides the road agents with variables and actions allowing to registers agents on the road.  RoadNode skill: dedicated to the definition of node. It provides the node agents with variables allowing to take into account the intersection of roads and the traffic signals.Table of contents  Advanced Driving Skill          Structure of the network: road and roadNode skills      Advanced driving skill      Application example      Structure of the network: road and roadNode skillsThe advanced driving skill is versatile enough to be usable with most of classic road GIS data, in particular OSM data. We use a classic format for the roads and nodes. Each road is a polyline composed of road sections (segments). Each road has a target node and a source node. Each node knows all its input and output roads. A road is considered as directed. For bidirectional roads, 2 roads have to be defined corresponding to both directions. Each road will be the linked_road of the other. Note that for some GIS data, only one road is defined for bidirectional roads, and the nodes are not explicitly defined. In this case, it is very easy, using the GAML language, to create the reverse roads and the corresponding nodes (it only requires few lines of GAML).images/roads_structure.PNGA lane can be composed of several lanes and the vehicles will be able to change at any time its lane. Another property of the road that will be taken into account is the maximal authorized speed on it. Note that even if the user of the plug-in has no information about these values for some of the roads (the OSM data are often incomplete), it is very easy using the GAML language to fill the missing value by a default value. It is also possible to change these values dynamically during the simulation (for example, to take into account that after an accident, a lane of a road is closed or that the speed of a road is decreased by the authorities).images/roads.PNGThe road skill provides the road agents with several variables that will define the road properties:  lanes: integer, number of lanes.  maxspeed: float; maximal authorized speed on the road.  linked_road: road agent; reverse road (if there is one).  source_node: node agent; source node of the road.  target_node: node agent; target node of the road.It provides as well the road agents with one read only variable:  agents_on: list of list (of driver agents); for each lane, the list of driver agents on the road.The*roadNode skillprovides the road agents with several variables that will define the road properties:  **roads_in**: list of road agents; the list of road agents that have this node for target node.  **roads_out: list of road agents; the list of road agents that have this node for source node.  *stop: list of list of road agents; list of stop signals, and for each stop signal, the list of concerned roads.**It provides as well the road agents with one read only variable:  block: map: key: driver agent, value: list of road agents; the list of driver agents blocking the node, and for each agent, the list of concerned roads.Advanced driving skillEach driver agent has a planned trajectory that consists in a succession of edges. When the driver agent enters a new edge, it first chooses its lane according to the traffic density, with a bias for the rightmost lane. The movement on an edge is inspired by the Intelligent Driver Model. The drivers have the possibility to change their lane at any time (and not only when entering a new edge).The advanced driving skill provides the driver agents with several variables that will define the car properties and the personality of the driver:  final_target: point; final location that the agent wants to reach (its goal).  vehicle_length: float; length of the vehicle.  max_acceleration: float; maximal acceleration of the vehicle.  max_speed: float; maximal speed of the vehicle.  right_side_driving: boolean; do drivers drive on the right side of the road?  speed_coef: float; coefficient that defines if the driver will try to drive above or below the speed limits.  security_distance_coeff: float; coefficient for the security distance. The security distance will depend on the driver speed and on this coefficient.  proba_lane_change_up: float; probability to change lane to a upper lane if necessary (and if possible).  proba_lane_change_down: float; probability to change lane to a lower lane if necessary (and if possible).  proba_use_linked_road: float; probability to take the reverse road if necessary (if there is a reverse road).  proba_respect_priorities: float; probability to respect left/right (according to the driving side) priority at intersections.  proba_respect_stops: list of float; probabilities to respect each type of stop signals (traffic light, stop sign…).  proba_block_node: float; probability to accept to block the intersecting roads to enter a new road.It provides as well the driver agents with several read only variables:  speed: float; speed expected according to the road max_value, the car properties, the personality of the driver and its real_speed.  real_speed: float; real speed of the car (that takes into account the other drivers and the traffic signals).  current_path: path (list of roads to follow); the path that the agent is currently following.  current_target: point; the next target to reach (sub-goal). It corresponds to a node.  targets: list of points; list of locations (sub-goals) to reach the final target.  current_index: integer; the index of the current goal the agent has to reach.  on_linked_road: boolean; is the agent on the linked road?Of course, the values of these variables can be modified at any time during the simulation. For example, the probability to take a reverse road (proba_use_linked_road) can be increased if the driver is stucked for several minutes behind a slow vehicle.In addition, the advanced driving skill provides the driver agents with several actions:  compute_path: arguments: a graph and a target node. This action computes from a graph the shortest path to reach a given node.  drive: no argument. This action moves the driver on its current path according to the traffic condition and the driver properties (vehicle properties and driver personality).the drive action works as follow: while the agent has the time to move (remaining_time &gt; 0), it first defines the speed expected. This speed is computed from the max_speed of the road, the current real_speed, the max_speed, the max_acceleration and the speed_coef of the driver (see Equation 1).speed_driver = Min(max_speed_driver, Min(real_speed_driver + max_acceleration_driver,max_speed_road * speed_coef_driver))Then, the agent moves toward the current target and compute the remaining time. During the movement, the agents can change lanes (see below). If the agent reaches its final target, it stops; if it reaches its current target (that is not the final target), it tests if it can cross the intersection to reach the next road of the current path. If it is possible, it defines its new target (target node of the next road) and continues to move.images/drive_action.pngThe function that defines if the agent crosses or not the intersection to continue to move works as follow: first, it tests if the road is blocked by a driver at the intersection (if the road is blocked, the agent does not cross the intersection). Then, if there is at least one stop signal at the intersection (traffic signal, stop sign…), for each of these signals, the agent tests its probability to respect or not the signal (note that the agent has a specific probability to respect each type of signals). If there is no stopping signal or if the agent does not respect it, the agent checks if there is at least one vehicle coming from a right (or left if the agent drives on the left side) road at a distance lower than its security distance. If there is one, it tests its probability to respect this priority. If there is no vehicle from the right roads or if it chooses to do not respect the right priority, it tests if it is possible to cross the intersection to its target road without blocking the intersection (i.e. if there is enough space in the target road). If it can cross the intersection, it crosses it; otherwise, it tests its probability to block the node: if the agent decides nevertheless to cross the intersection, then the perpendicular roads will be blocked at the intersection level (these roads will be unblocked when the agent is going to move).images/stop_at_intersection.pngConcerning the movement of the driver agents on the current road, the agent moves from a section of the road (i.e. segment composing the polyline) to another section according to the maximal distance that the agent can moves (that will depend on the remaining time). For each road section, the agent first computes the maximal distance it can travel according the remaining time and its speed. Then, the agent computes its security distance according to its speed and its security_distance_coeff. While its remaining distance is not null, the agent computes the maximal distance it can travel (and the corresponding lane), then it moves according to this distance (and update its current lane if necessary). If the agent is not blocked by another vehicle and can reach the end of the road section, it updates its current road section and continues to move.images/follow_driving.pngThe computation of the maximal distance an agent can move on a road section consists in computing for each possible lane the maximal distance the agent can move. First, if there is a lower lane, the agent tests the probability to change its lane to a lower one. If it decides to test the lower lane, the agent computes the distance to the next vehicle on this lane and memorizes it. If this distance corresponds to the maximal distance it can travel, it chooses this lane; otherwise it computes the distance to the next vehicle on its current lane and memorizes it if it is higher than the current memorized maximal distance. Then if the memorized distance is lower than the maximal distance the agent can travel and if there is an upper lane, the agents tests the probability to change its lane to a upper one. If it decides to test the upper lane, the agent computes the distance to the next vehicle on this lane and memorizes it if it is higher than the current memorized maximal distance. At last, if the memorized distance is still lower than the maximal distance it can travel, if the agent is on the highest lane and if there is a reverse road, the agent tests the probability to use the reverse road (linked road). If it decides to use the reverse road, the agent computes the distance to the next vehicle on the lane 0 of this road and memorizes the distance if it is higher than the current memorized maximal distance.images/define_max_dist.pngApplication exampleWe propose a simple model to illustrate the driving skill. We define a driver species. When a driver agent reaches its destination, it just chooses a new random final target. In the same way, we did not define any specific behavior to avoid traffic jam for the driver agents: once they compute their path (all the driver agents use for that the same road graph with the same weights), they never re-compute it even if they are stucked in a traffic jam. Concerning the traffic signals, we just consider the traffic lights (without any pre-processing: we consider the raw OSM data). One step of the simulation represents 1 second. At last, in order to clarify the explanation of the model, we chose to do not present the parts of the GAML code that concern the simulation visualization.images//sim_snapshot.pngThe following code shows the definition of species to represent the road infrastructure:species road skills: [skill_road] {   string oneway;}species node skills: [skill_road_node] {  bool is_traffic_signal;  int time_to_change &lt;- 100;  int counter &lt;- rnd (time_to_change) ;\t  reflex dynamic when: is_traffic_signal {    counter &lt;- counter + 1;    if (counter &gt;= time_to_change) {       counter &lt;- 0;      stop[0] &lt;-empty(stop[0])? roads_in : [];    }   }}In order to use our driving skill, we just have to add the skill_road_node to the node species and the skill_road to the road species. In addition, we added to the road species a variable called oneway that will be initialized from the OSM data and that represents the traffic direction (see the OSM map features for more details). Concerning the node, we defined 3 new attributes:  is_traffic_signal: boolean; is the node a traffic light?  time_to_change: integer; represents for the traffic lights the time to pass from the red light to the green light (and vice versa).  counter: integer;  number of simulation steps since the last change of light color (used by the traffic light nodes).In addition, we defined for the node species a reflex (behavior) called dynamic that will be activated only for traffic light nodes and that will increment the counter value. If this counter is higher than time_to_change, this variable is set to 0, and the node change the value of the stop variable: if the traffic light was green (i.e. there is no road concerns by this stop sign), the list of block roads is set by all the roads that enter the node; if the traffic light was red (i.e. there is at least one road concerns by this stop sign), the list of block roads is set to an empty list.The following code shows the definition of driver species:species driver skills: [advanced_driving] {   reflex time_to_go when: final_target = nil {    current_path &lt;- compute_path(        graph: road_network, target: one_of(node));  }  reflex move when: final_target != nil {    do drive;  }} In order to use our driving plug-in, we just have to add the advanced_driving to the driver species. For this species, we defined two reflexes:  time_to_go: activated when the agent has no final target. In this reflex, the agent will randomly choose one of the nodes as its final target, and computed the path to reach this target using the  road_network graph. Note that it will have been possible to take into account the knowledge that each agent has concerning the road network by defining a new variable of type map (dictionary) containing for each road a given weight that will reflect the driver knowledge concerning the network (for example, the known traffic jams, its favorite roads….) and to use this map for the path computation.  move: activated when the agent has a final target. In this reflex, the agent will drive in direction of its final target.We describe in the following code how we initialize the simulation:init {    create node from: file(\"nodes.shp\") with:[    is_traffic_signal::read(\"type\")=\"traffic_signals\"];      create road from: file(\"roads.shp\")     with:[lanes::int(read(\"lanes\")),     maxspeed::float(read(\"maxspeed\")),     oneway::string(read(\"oneway\"))]     {      switch oneway {        match \"no\" {          create road {            lanes &lt;- myself.lanes;            shape &lt;- polyline(reverse              (myself.shape.points));            maxspeed &lt;- myself.maxspeed;            linked_road &lt;- myself;            myself.linked_road &lt;- self;          }        }        match \"-1\" {          shape &lt;- polyline(reverse(shape.points));        }      }    }\t  }      map general_speed_map &lt;-  road as_map      (each::(each.shape.perimeter/(each.maxspeed)));        road_network &lt;-  (as_driving_graph(road, node))       with_weights general_speed_map;     create driver number: 10000 {     location &lt;- one_of(node).location;    vehicle_length &lt;- 3.0;    max_acceleration &lt;- 0.5 + rnd(500) / 1000;    speed_coeff &lt;- 1.2 - (rnd(400) / 1000);    right_side_driving &lt;- true;    proba_lane_change_up &lt;- rnd(500) / 500;    proba_lane_change_down &lt;- 0.5+ (rnd(250) / 500);    security_distance_coeff &lt;- 3 - rnd(2000) / 1000);      proba_respect_priorities &lt;- 1.0 - rnd(200/1000);    proba_respect_stops &lt;- [1.0 - rnd(2) / 1000];    proba_block_node &lt;- rnd(3) / 1000;    proba_use_linked_road &lt;- rnd(10) / 1000;  }\t}\tIn this code, we create the node agents from the node shapefile (while reading the attributes contained in the shapefile), then we create in the same way the road agents. However, for the road agents, we use the oneway variable to define if we should or not reverse their geometry (oneway = “-1”) or create a reverse road (oneway = “no”). Then, from the road and node agents, we create a graph (while taking into account the maxspeed of the road for the weights of the edges). This graph is the one that will be used by all agents to compute their path to their final target. Finally, we create 1000 driver agents. At initialization, they are randomly placed on the nodes; their vehicle has a length of 3m; the maximal acceleration of their vehicle is randomly drawn between 0.5 and 1; the speed coefficient of the driver is randomly drawn between 0.8 and 1.2; they are driving on the right side of the road; their probability of changing lane for a upper lane is randomly drawn between 0 and 1.0; their probability of changing lane for a lower lane is randomly drawn between 0.5 and 1.0; the security distance coefficient is randomly drawn between 1 and 3; their probability to respect priorities is randomly drawn between 0.8 and 1; their probability to respect light signal is randomly drawn between 0.998 and 1; their probability to block a node is randomly drawn between 0 and 0.003;  their probability to use the reverse road is randomly drawn between 0 and 0.01;The complete code of the model with the data can be found here",
        "url":"/wiki/UsingDrivingSkill.html"
      }
      ,
    
      "wiki-usingfipaacl-html": {
        "title": "Using FIPA ACL",
        "content": "Using FIPA ACLThe communicating skill offers some actions and built-in variables which enable agents to communicate with each other using the FIPA interaction protocol. This document describes the built-in variables and actions of this skill. Examples are found in the models library bundled with GAMA.##Variables  accept_proposals (list): A list of ‘accept_proposal’ performative messages of the agent’s mailbox having .  agrees (list): A list of ‘accept_proposal’ performative messages.  cancels (list): A list of ‘cancel’ performative messages.  cfps (list): A list of ‘cfp’ (call for proposal) performative messages.  conversations (list): A list containing the current conversations of agent. Ended conversations are automatically removed from this list.  failures (list): A list of ‘failure’ performative messages.  informs (list): A list of ‘inform’ performative messages.  messages (list): The mailbox of the agent, a list of messages of all types of performatives.  proposes (list): A list of ‘propose’ performative messages .  queries (list): A list of ‘query’ performative messages.  refuses (list): A list of ‘propose’ performative messages.  reject_proposals (list): A list of ‘reject_proposals’ performative messages.  requests (list): A list of ‘request’ performative messages.  requestWhens (list): A list of ‘request-when’ performative messages.  subscribes (list): A list of ‘subscribe’ performative messages.Actions####accept_proposalReplies a message with an ‘accept_proposal’ performative message  returns: unknown  message (message): The message to be replied  content (list): The content of the replying message####agreeReplies a message with an ‘agree’ performative message.  returns: unknown  message (message): The message to be replied  content (list): The content of the replying message####cancelReplies a message with a ‘cancel’ peformative message.  returns: unknown  message (message): The message to be replied  content (list): The content of the replying message####cfpReplies a message with a ‘cfp’ performative message.  returns: unknown  message (message): The message to be replied  content (list): The content of the replying message####end_conversationReplies a message with an ‘end_conversation’ peprformative message. This message marks the end of a conversation. In a ‘no-protocol’ conversation, it is the responsible of the modeler to explicitly send this message to mark the end of a conversation/interaction protocol.  returns: unknown  message (message): The message to be replied  content (list): The content of the replying message####failureReplies a message with a ‘failure’ performative message.  returns: unknown  message (message): The message to be replied  content (list): The content of the replying message####informReplies a message with an ‘inform’ performative message.  returns: unknown  message (message): The message to be replied  content (list): The content of the replying message####proposeReplies a message with a ‘propose’ performative message.  returns: unknown  message (message): The message to be replied  content (list): The content of the replying message####queryReplies a message with a ‘query’ performative message.  returns: unknown  message (message): The message to be replied  content (list): The content of the replying message####refuseReplies a message with a ‘refuse’ performative message.  returns: unknown  message (message): The message to be replied  content (list): The content of the replying message####reject_proposalReplies a message with a ‘reject_proposal’ performative message.  returns: unknown  message (message): The message to be replied  content (list): The content of the replying message####replyReplies a message. This action should be only used to reply a message in a ‘no-protocol’ conversation and with a ‘user defined performative’. For performatives supported by GAMA (i.e., standard FIPA performatives), please use the ‘action’ with the same name of ‘performative’. For example, to reply a message with a ‘request’ performative message, the modeller should use the ‘request’ action.  returns: unknown  message (message): The message to be replied  performative (string): The performative of the replying message  content (list): The content of the replying message####requestReplies a message with a ‘request’ performative message.  returns: unknown  message (message): The message to be replied  content (list): The content of the replying message####sendStarts a conversation/interaction protocol.  returns: msi.gaml.extensions.fipa.Message  receivers (list): A list of receiver agents  content (list): The content of the message. A list of any GAML type  performative (string): A string, representing the message performative  protocol (string): A string representing the name of interaction protocol####start_conversationStarts a conversation/interaction protocol.  returns: msi.gaml.extensions.fipa.Message  receivers (list): A list of receiver agents  content (list): The content of the message. A list of any GAML type  performative (string): A string, representing the message performative  protocol (string): A string representing the name of interaction protocol####subscribeReplies a message with a ‘subscribe’ performative message.  returns: unknown  message (message): The message to be replied  content (list): The content of the replying message            //: # (endConcept      fipa_acl)      ",
        "url":"/wiki/UsingFIPAACL.html"
      }
      ,
    
      "wiki-validationofmodels-html": {
        "title": "Validation of Models",
        "content": "Validation of ModelsWhen editing a model, GAMA will continuously validate (i.e. compile) what the modeler is entering and indicate, with specific visual affordances, various information on the state of the model. This information ranges from documentation items to errors indications. We will review some of them in this section.Table of contents  Validation of Models          Syntactic errors      Semantic errors      Semantic warnings      Semantic information      Semantic documentation      Changing the visual indicators      Errors in imported files      Cleaning models      Syntactic errorsThese errors are produced when the modeler enters a sentence that has no meaning in the grammar of GAML (see the documentation of the language). It can either be a non-existing symbol (like “globals” (instead of global) in the example below), a wrong punctuation scheme, or any other construct that puts the parser in the incapacity of producing a correct syntax tree. These errors are extremely common when editing models (since incomplete keywords or sentences are continuously validated). GAMA will report them using several indicators: the icon of the file in the title of the editor will sport an error icon and the gutter of the editor (i.e. the vertical space beside the line numbers) will use error markers to report two or more errors: one on the statement defining the model, and one (or more) in the various places where the parser has failed to produce the syntax tree. In addition, the toolbar over the editor will turn red and indicate that errors have been detected.Hovering over one of these markers indicates what went wrong during the syntactic validation. Note that these errors are sometimes difficult to interpret, since the parser might fail in places that are not precisely those where a wrong syntax is being used (it will usually fail after).Semantic errorsWhen syntactic errors are eliminated, the validation enters a so-called semantic phase, during which it ensures that what the modeler has written makes sense with respect to the various rules of the language. To understand the difference between the two phases, take a look at the following example.This sentence below is syntactically correct:species my_species parent: my_species;But it is semantically incorrect because a species cannot be parent of itself. No syntactic errors will be reported here, but the validation will fail with a semantic error.Semantic errors are reported in a way similar to syntactic errors, except that no marker are displayed beside the model statement. The compiler tries to report them as precisely as possible, underlining the places where they have been found and outputting hopefully meaningful error messages. In the example below, for instance, we use a wrong number of arguments for defining a square geometry. Although the sentence is syntactically correct, GAMA will nevertheless issue an error and prevent the model from being experimentable.The message accompanying this error can be obtained by hovering over the error marker found in the gutter (multiple messages can actually be produced for a same error, see below).While the editor is in a so-called dirty state (i.e. the model has not been saved), errors are only reported locally (in the editor itself). However, as soon as the user saves a model containing syntactic or semantic errors, they are “promoted” to become workspace errors, and, as such, indicated in other places: the file icon in the Navigator, and a new line in the Errors view.Semantic warningsThe semantic validation phase does not only report errors. It also outputs various indicators that can help the modeler in verifying the correctness of his/her model. Among them are warnings. A warning is an indication that something is not completely right in the way the model is written, although it can probably be worked around by GAMA when the model will be executed. For instance, in the example below, we pass a string argument to the facet “number:” of the “create” statement. GAMA will emit a warning in such a case, indicating that “number:” expects an integer, and that the string passed will be casted to int when the model will be executed. Warnings are to be considered seriously, as they usually indicate some flaws in the logic of the model.Hovering over the warning marker will allow the modeler to have access to the explanation and hopefully fix the cause of the warning.Semantic informationBesides warnings, another type of harmless feedback is produce by the semantic validation phase: information markers. They are used to indicate useful information to the modeler, for example that an attribute has been redefined in a sub-species, or that some operation will take place when running the model (for instance, the truncation of a float to an int). The visual affordance used in this case is voluntarily discrete (a small “i” in the editor’s gutter).As with the other types of markers, information markers unveil their messages when being hovered.Semantic documentationThe last type of output of the semantic validation phase consists in a complete documentation of the various elements present in the model, which the user can retrieve by hovering over the different symbols. Note that although the best effort is being made in producing a complete and consistent documentation, it may happen that some symbols do not produce anything. In that case, please report a new Issue here.Changing the visual indicatorsThe default visual indicators depicted in the examples above to report errors, warnings and information can be customized to be less (or more) intrusive. This can be done by choosing the “Preferences…” item of the editor contextual menu and navigating to “General &gt; Editors &gt; Text Editors &gt; Annotations”. There, you will find the various markers used, and you will be able to change how they are displayed in the editor’s view. For instance, if you prefer to highlight errors in the text, you can change it here.Which will result in the following visual feedback for errors:Errors in imported filesFinally, even if your model has been cleansed of all errors, it may happen that it refuses to launch because it imports another model that cannot be compiled. In the following screenshot, “My First Model.gaml” imports “My Imported Model.gaml”, which sports a syntactic error.In such a case, the importing model refuses to compile (although it is itself valid) and to propose experiments. There are cases, however, where the same importation can work. Consider the following example, where, this time, “My Imported Model.gaml” sports a semantic error in the definition of the global ‘shape’ attribute. Without further modifications, the use case is similar to the first one.However, if “My First Model.gaml” happens to redefine the shape attribute (in global), it is now considered as valid. All the valid sections of “My Imported Model.gaml” are effectively imported, while the erroneous definition is superseded by the new one.This process is described by the information marker next to the redefinition.Cleaning modelsIt may happen that the metadata that GAMA maintains about the different projects (which includes the various markers on files in the workspace, etc.) becomes corrupted from time to time. This especially happens if you frequently switch workspaces, but not only. In those (hopefully rare) cases, GAMA may report incorrect errors for perfectly legible files.When such odd behaviors are detected, or if you want to regularly keep your metadata in a good shape, you can clean all your project, by clicking on the button “Clear and validate all projects” (in the syntax errors view).",
        "url":"/wiki/ValidationOfModels.html"
      }
      ,
    
      "wiki-variablesandattributes-html": {
        "title": "Variables and Attributes",
        "content": "Variables and AttributesVariables and attributes represent named data that can be used in an expression. They can be accessed depending on their scope:  the scope of attributes declared in a species is itself, its child species and its micro-species.  the scope of temporary variables is the one in which they have been declared, and all its sub-scopes.Outside its scope of validity, an expression cannot use a variable or an attribute directly. However, attributes can be used in a remote fashion by using a dotted notation on a given agent (see here).Table of contents  Variables and Attributes          Direct Access      Remote Access      Direct AccessWhen an agent wants to use either one of the variables declared locally, one of the attributes declared in its species (or parent species), one of the attributes declared in the macro-species of its species, it can directly invoke its name and the compiler will do the rest (i.e. finding the variable or attribute in the right scope).For instance, we can have a look at the following example:species animal {   float energy &lt;- 1000 min: 0 max: 2000 update: energy - 0.001;   int age_in_years &lt;- 1 update: age_in_years + int (time / 365);      action eat (float amount &lt;- 0) {       float gain &lt;- amount / age_in_years;       energy &lt;- energy + gain;   }   reflex feed {      int food_found &lt;- rnd(100);      do eat (amount: food_found);    }}  Species declaration          Everywhere in the species declaration, we are able to directly name and use:              time, a global built-in variable,      energy and age_in_years, the two species attributes.                  Nevertheless, in the species declaration, but outside of the action eat and the reflex feed, we cannot name the variables:                    amount, the argument of eat action,      gain, a local variable defined into the eat action,      food_found, the local variable defined into the feed reflex.        Eat action declaration          In the eat action declaration, we can directly name and use:              time, a global built-in variable,      energy and age_in_years, the two species attributes,      amount, which is an argument to the action eat,      gain, a temporary variable within the action.                  We cannot name and use the variables:                    food_found, the local variable defined into the feed reflex.        feed reflex declaration          Similarly, in the feed reflex declaration, we can directly name and use:              time, a global built-in variable,      energy and age_in_years, the two species variables,      food_found, the local variable defined into the reflex.                  But we cannot access to variables:                    amount, the argument of eat action,      gain, a local variable defined into the eat action.      Remote AccessWhen an expression needs to get access to the attribute of an agent which does not belong to its scope of execution, a special notation (similar to that used in Java) has to be used:remote_agent.variablewhere remote_agent can be the name of an agent, an expression returning an agent, self, myself or each. For instance, if we modify the previous species by giving its agents the possibility to feed another agent found in its neighbourhood, the result would be:species animal {   float energy &lt;- 1000 min: 0 max: 2000 update: energy - 0.001;   int age_in_years &lt;- 1 update: age_in_years + int (time / 365);   action eat (float amount &lt;- 0.0) {       float gain &lt;- amount / age_in_years;       energy &lt;- energy + gain;   }   action feed (animal target){       if (agent_to_feed != nil) and (agent_to_feed.energy &lt; energy { // verifies that the agent exists and that it need to be fed            ask agent_to_feed {                do eat amount: myself.energy / 10; // asks the agent to eat 10% of our own energy            }            energy &lt;- energy - (energy / 10); // reduces the energy by 10%       }   }   reflex {       animal candidates &lt;- agents_overlapping (10 around agent.shape); gathers all the neighbours       agent_to_feed value: candidates with_min_of (each.energy); //grabs one agent with the lowest energy        do feed target: agent_to_feed; // tries to feed it   }}In this example, agent_to_feed.energy, myself.energy and each.energy show different remote accesses to the attribute energy. The dotted notation used here can be employed in assignments as well. For instance, an action allowing two agents to exchange their energy could be defined as:action random_exchange {//exchanges our energy with that of the closest agent     animal one_agent &lt;- agent_closest_to (self)/&gt;     float temp  &lt;-one_agent.energy; // temporary storage of the agent's energy     one_agent.energy &lt;- energy; // assignment of the agent's energy with our energy     energy &lt;- temp;}",
        "url":"/wiki/VariablesAndAttributes.html"
      }
      ,
    
      "wiki-voronoi-voronoi-html": {
        "title": "Voronoi",
        "content": "Voronoi_Author : _A model showing how to clusterize space using the closest center as the kernel of our cluster. The space is discretized using a grid, each cell computing its distance from a center to know in which cluster it is.Code of the model :model voronoi global {\t// Parameters \t//Number of points\tint num_points &lt;- 4 min: 1 max: 1000;\t//Size of the environment\tint env_width &lt;- 100 min: 10 max: 400;\tint env_height &lt;- 100 min: 10 max: 400;\t\t// Environment\tgeometry shape &lt;- rectangle(env_width, env_height);\t\tinit { \t\twrite 'This model shows how Voronoi-like shapes can be drawn on a regular surface. A set of mobile agents is placed on a grid. Each agent possesses an attribute called *inside_color*. Each step, the agents move randomly and the grid cells paint themselves using the *inside_color* of the nearest agent. Dynamical boundaries then appear on the screen without any further calculations.';\t\t//Creation of all the points\t\tcreate center number: num_points ;  \t}   } //Grid for the voronoi clusteringgrid cell width: env_width height: env_height neighbors: 8 use_regular_agents: false {\t// Note: since GAMA 1.7, the topology needs to be specified for this computation to use continuous distances\tcenter closest_center &lt;- nil update: (center closest_to self.location) using topology(world);\trgb color &lt;- #white update: (closest_center).color;}//Species representing the center of a Voronoi pointspecies center skills: [moving] { \trgb color &lt;- rgb([rnd (255),rnd (255),rnd (255)]); \t//Make the center of the cluster wander in the environment       \treflex wander {\t\tdo wander amplitude: 90;\t}  \taspect base {\t\tdraw square(1.0) color: color;\t}}experiment voronoi type: gui{ \tparameter 'Number of points:' var: num_points;\tparameter 'Width of the environment:' var: env_width;\tparameter 'Height of the environment:' var: env_height;\t\toutput {\t\tdisplay Voronoi type: opengl {\t\t\tgrid cell  ;\t\t\tspecies center aspect: base ;\t\t}\t}\t}",
        "url":"/wiki/Voronoi-Voronoi.html"
      }
      ,
    
      "wiki-voronoi-html": {
        "title": "Voronoi",
        "content": "VoronoiThis sub-section is composed of the following models :  Voronoi",
        "url":"/wiki/Voronoi.html"
      }
      ,
    
      "wiki-vote-vote-html": {
        "title": "vote",
        "content": "vote_Author : MAPS TEAM (Frederic Amblard, Thomas Louail, Romain Reulier, Paul Salze et Patrick Taillandier) _Modeling of an electionCode of the model : model voteglobal {\t//Shape of the environment\tgeometry shape &lt;- rectangle({200, 200});\t\t//Number of electors\tint nb_electors &lt;- 1500;\t//Number of candidates\tint nb_candidates &lt;- 7;\t//Weight of each candidates\tint weight_candidates &lt;- 50;\t//Threshold for the attraction candidates\tint threshold_attraction_candidates &lt;- 80;\t//Threshold for the repulsion candidates\tint threshold_repulsion_candidates &lt;- 200;\t//Threshold for the attraction electors\tint threshold_attraction_electors &lt;- 20;\t\t//Distance traveled\tfloat distance_traveled &lt;- 7.0;\t//Distribution of the electors\tstring distribution_electors &lt;- \"Uniform\" among: [\"Uniform\", \"Normal\"];\t//Distribution of candidates\tstring distribution_candidates &lt;- \"Polygon\" among: [\"Random\", \"Polygon\", \"Line\", \"Diagonal\"];\t//Strategy of the candidates\tstring strategy_candidates &lt;- \"No strategy\" among: [\"No strategy\", \"Search electors\", \"Distinction\", \"Group\", \"Go closer to the best\",\"Random\" ];\t//Count of max group\tint cpt_Group_max &lt;- 5;\t//Count  of group\tint cpt_Group &lt;- cpt_Group_max;\t\tfloat entropy;\t\t//List of all the active candidates\tlist&lt;candidate&gt; active_candidates ;\t\tinit {\t\t//Creation of the elector\t\tcreate elector number: nb_electors;\t\tdo creation_candidates;\t}\t//Action to create the candidates according to the distribution of candidates\taction creation_candidates {\t\tswitch distribution_candidates { \t\t\tmatch \"Polygon\" {\t\t\t\tlist&lt;point&gt; liste_points &lt;- list(nb_candidates points_at 50.0);\t\t\t\tint cpt &lt;- 0;\t\t\t\tcreate candidate number: nb_candidates{\t\t\t\t\t color &lt;- rgb (rnd(255), rnd(255), rnd(255)); \t\t\t\t\t location &lt;- liste_points at cpt;\t\t\t\t\t cpt &lt;- cpt + 1; \t\t\t\t}\t\t\t}\t\t\tmatch \"Line\" {\t\t\t\tint cpt  &lt;- 0;\t\t\t\tcreate candidate number: nb_candidates{\t\t\t\t\tcolor &lt;- rgb ([rnd(255), rnd(255), rnd(255)]); \t\t\t\t\tfloat x_cord  &lt;- 200 * cpt / nb_candidates;\t\t\t\t\tfloat y_cord &lt;- 100.0;\t\t\t\t\tlocation &lt;- {x_cord, y_cord};\t\t\t\t\tcpt &lt;- cpt + 1;\t\t\t\t}\t\t\t}\t\t\tmatch \"Diagonal\" {\t\t\t\tint cpt &lt;- 0;\t\t\t\tcreate candidate number: nb_candidates{\t\t\t\t\tcolor &lt;- rgb ([rnd(255), rnd(255), rnd(255)]); \t\t\t\t\tfloat x_cord &lt;- 200 * cpt / nb_candidates;\t\t\t\t\tfloat y_cord &lt;- x_cord;\t\t\t\t\tlocation &lt;- {x_cord, y_cord};\t\t\t\t\tcpt &lt;- cpt + 1;\t\t\t\t}\t\t\t}\t\t}\t\t//Initialization of all the active candidates as the list of candidates\t\tactive_candidates &lt;- list(copy(candidate));\t\t}\t//Reflex representing the dynamics of the models\treflex dynamique {\t\t//For each elector, ask to move\t\task elector {\t\t\tdo moving;\t\t}\t\t//For each candidate, ask to move\t\task active_candidates{\t\t\tdo moving;\t\t\tmy_electors &lt;- list&lt;elector&gt;([]);\t\t}\t\t//For each elector, do its definition\t\task elector {\t\t\tdo definition_candidate;\t\t}\t\tint nb_electors_max &lt;- 0;\t\tcandidate candidat_elected &lt;- nil; \t\t\t\t//Ask to all the active candidates to compute their percentage of vote and set the number of maximum electors to know which candidate is elected\t\task active_candidates{ \t\t\tint nb_el &lt;- length(my_electors) ;\t\t\tpercentage_vote &lt;- (nb_el/nb_electors * 100) with_precision 2;\t\t\tif (nb_el &gt; nb_electors_max) {\t\t\t\tnb_electors_max &lt;- nb_el;\t\t\t \tcandidat_elected &lt;- self;\t\t\t}\t\t}\t\t//update of the state of the candidate\t\task candidate {\t\t\tis_elected &lt;- false; \t\t}\t\task candidat_elected {\t\t\tis_elected &lt;- true; \t\t}\t}\t//Reflex to show the final results\treflex resultats_finaux when: time = 72 {\t\tcandidate elected &lt;- active_candidates with_max_of (each.percentage_vote);\t\t//Display a window telling who is the winner and halt the model\t\tdo tell message: \"The winner is \" + elected.name; \t\tdo halt;\t}\t\t//Reflex to compute the creation of group when one candidate chooses this strategy\treflex creation_Group when: (strategy_candidates in [\"Group\", \"Random\"]) {\t\t if (cpt_Group = cpt_Group_max) {\t\t \t//Kill all the group of electors\t\t \task Group_electors as list {\t\t \t\tdo die;\t\t \t}\t\t \t//Compute the list of elector according to their distance\t\t\tlist&lt;list&lt;elector&gt;&gt; Groups;\t\t\tgeometry geoms &lt;- union(elector collect ((each.shape) buffer ([\"distance\"::float(threshold_attraction_electors) , \"quadrantSegments\"::4, \"endCapStyle\"::1])));\t\t\tloop geom over: geoms.geometries { \t\t\t\tif (geom != nil and !empty(geom.points)) {\t\t\t\t\tlist&lt;elector&gt; els  &lt;- (elector inside geom); \t\t\t\t\tadd els to: Groups;\t\t\t\t}\t\t\t}\t\t\t//Create new groups of electors according to the list of electors\t\t\tloop gp over: Groups {\t\t\t \tcreate Group_electors {\t\t\t\t\t effectif &lt;- length(gp);\t\t\t \t\t electors_dans_Group &lt;- gp;\t\t\t \t\t location &lt;- mean(electors_dans_Group collect (each.location)) ;\t\t\t \t}\t\t\t }\t \t\t}\t\tcpt_Group &lt;- cpt_Group - 1;\t\tif (cpt_Group = 0) { cpt_Group &lt;- cpt_Group_max;}\t\t}\t//Reflex to compute the entropy\treflex calcule_entropy {\t\tentropy &lt;- 0.0;\t\t//Compute the abstinence rate\t\tfloat abst &lt;- (nb_electors - sum (active_candidates  collect (length(each.my_electors)))) / nb_electors;\t\tif (abst &gt; 0) {\t\t\tentropy &lt;- entropy - (abst * ln(abst));\t\t}\t\t//Ask to all the active candidates their number of electors to compute the entropy\t\task active_candidates {\t\t\tfloat p &lt;- length(my_electors) / nb_electors;\t\t\tif (p &gt; 0) {\t\t\t\tentropy &lt;- entropy - (p * ln(p));\t\t\t}\t\t}\t\tentropy &lt;- entropy / ln (length(active_candidates) + 1);\t}}//Species representing a group of electorsspecies Group_electors {\tint effectif &lt;- 0;\t//List of all the elector agents in the group\tlist&lt;elector&gt; electors_dans_Group ;\taspect default {\t\tdraw square(2) color: #orange;\t} \t}//Species representing the elector moving species elector skills: [moving]{\t\tinit {\t\t//At initialization, place the elector in a certain place according to the distribution of electors\t\tif (distribution_electors = \"Normal\") {\t\t\tfloat x_cord &lt;- max([0.0, min([200.0, gauss ({100, 35})])]);\t\t\tfloat y_cord &lt;- max([0.0, min([200.0, gauss ({100, 35})])]);\t\t\tlocation &lt;- {x_cord, y_cord};\t\t}\t}\trgb color &lt;- #white;\t//Candidate chosen by the elector\tcandidate my_candidate;  \t\taspect base {\t\tdraw triangle(2) color: color ;\t} \t//Action to define the candidate\taction definition_candidate {\t\t//The candidate chosen is the one closest to the elector in the attraction range\t\tmy_candidate &lt;- active_candidates with_min_of (self distance_to each);\t\tmy_candidate &lt;- (self distance_to my_candidate &lt; threshold_attraction_candidates) ? my_candidate : nil;\t\tif (my_candidate != nil) {\t\t\tadd self to: my_candidate.my_electors; \t\t\tcolor &lt;- my_candidate.color;\t\t}\t}\t//Action to move the elector\taction moving {\t\t//Make the agent move closer to another elector, representing the influence of this one\t\tif ( rnd(100) &gt; (weight_candidates)) {\t\t\telector my_elector &lt;- shuffle(elector) first_with ((self distance_to each) &lt; threshold_attraction_electors);\t\t\tif (my_elector != nil) {\t\t\t\tdo goto target:my_elector speed: distance_traveled;\t\t\t} \t\t} else {\t\t\t//Move the elector closer to one of the candidate to represent its repulsion or attraction\t\t\tcandidate the_candidate &lt;- one_of(candidate) ;\t\t\tif (the_candidate != nil) {\t\t\t\tfloat dist &lt;- self distance_to the_candidate;\t\t\t\tif dist &lt; threshold_attraction_candidates {\t\t\t\t\tdo goto target: the_candidate speed: distance_traveled;\t\t\t\t} else if dist &gt; threshold_repulsion_candidates {\t\t\t\t\tdo goto target: location + location - the_candidate.location speed: distance_traveled;\t\t\t\t}\t\t\t}\t\t}\t\t\t} \t}//Species candidate using the skill movingspecies candidate skills:[moving]{\trgb color &lt;- rgb([100 + rnd(155),100 + rnd(155),100 + rnd(155)]);\t//Boolean to know if the candidate is active\tbool active &lt;- true;\t//Float representing the percentage of vote for the candidate\tfloat percentage_vote; \t//List of all the electors of the candidate\tlist my_electors of: elector;\t//Boolean to know if the candidate is elected\tbool is_elected &lt;- false;\taspect default {\t\tdraw circle(3) color: color;\t} \taspect dynamic {\t\tif (active) {\t\t\tfloat radius  &lt;- 1 + (percentage_vote / 4.0);\t\t\tif (is_elected) {\t\t\t\tdraw square( radius *1.5) color: #red; \t\t\t\tdraw circle(radius) color: color;\t\t\t} else {\t\t\t\tdraw circle(radius) color: color;\t\t\t}\t\t\tdraw string(percentage_vote) size: 5 color: #white;\t\t}\t}\t//Action to move the candidate according to its strategy\taction moving {\t\tswitch strategy_candidates {\t\t\tmatch \"No strategy\" {}\t\t\tmatch \"Search electors\" {do strategy_1;}\t\t\tmatch \"Distinction\" {do strategy_2;}\t\t\tmatch \"Group\" {do strategy_3;}\t\t\tmatch \"Go closer to the best\" {do strategy_4;}\t\t\tmatch \"Random\" { \t\t\t\tswitch (rnd(4)) {\t\t\t\t\tmatch 0 {}\t\t\t\t\tmatch 1 {do strategy_1;}\t\t\t\t\t\tmatch 2 {do strategy_2;}\t\t\t\t\t\tmatch 3 {do strategy_3;}\t\t\t\t\t\tmatch 4 {do strategy_4;}\t\t\t\t\t\t}\t\t\t}\t\t}\t}\t\taction strategy_1 {\t\t//go closer to electors\t\telector my_elector &lt;- shuffle(elector) first_with ((self distance_to each) &lt; threshold_attraction_electors);\t\tif (my_elector != nil) {\t\t\tdo goto target:my_elector speed: distance_traveled;\t\t} \t}\t\taction strategy_2 {\t\t//go in opposite directions to other candidates\t\tlist&lt;candidate&gt; cands &lt;- list(copy(candidate));\t\tremove self from: cands;\t\tcandidate the_candidate &lt;- one_of(cands) ;\t\tif (the_candidate != nil) {\t\t\tdo goto target: (location + location - the_candidate.location) speed: distance_traveled;\t\t\t}\t}\t\taction strategy_3 {\t\t//go closer to a group of electors\t\tGroup_electors mon_Group  &lt;- (Group_electors where ((self distance_to each) &lt; threshold_attraction_electors)) with_max_of (each.effectif);\t\tif (mon_Group != nil) {\t\t\tdo goto target:mon_Group speed: distance_traveled;\t\t} \t}\t\taction strategy_4 {\t\t//go toward the candidate with max of votes\t\tcandidate the_candidate &lt;- candidate with_max_of (percentage_vote) ;\t\tif (the_candidate != nil) {\t\t\tdo goto target:the_candidate speed: distance_traveled;\t\t\t}\t}\t}experiment vote type: gui {\t/** Insert here the definition of the input and output of the model */\tparameter \"Number of electors : \" var: nb_electors category: \"elector\";\tparameter \"Moving speed of electors toward another electors : \" var: distance_traveled category: \"elector\";\tparameter \"Attraction distance between electors : \" var: threshold_attraction_electors category: \"elector\";\tparameter \"Number of candidates : \" var: nb_candidates category: \"Candidate\";\tparameter \"Attraction distance between candidates and electors : \" var: threshold_attraction_candidates category: \"elector\";\t\tparameter \"Repulsion distance between candidates : \" var: threshold_repulsion_candidates category: \"elector\";\tparameter \"weight of candidates : \" var: weight_candidates category: \"Candidate\";\t\tparameter \"Distribution type of electors : \" var: distribution_electors category: \"elector\";\tparameter \"Distribution type of  candidates : \" var: distribution_candidates category: \"Candidate\";\tparameter \"Strategy of candidates : \" var: strategy_candidates category: \"Candidate\";\t\toutput {\t\tdisplay main background: #black { \t\t\tspecies elector aspect: base;\t\t\tspecies candidate aspect: dynamic;\t\t\tspecies Group_electors;\t\t\t\t\t}\t\tdisplay votants {\t\t\tchart \"Distribution of electors\" type: pie background: #white  {\t\t\t \tloop cand over: candidate {\t\t\t \t\tdata  cand.name value:cand.percentage_vote color: cand.color ;\t\t\t \t}\t\t\t\t}\t\t\t\t\t\t}\t\tdisplay indicateurs {\t\t\tchart \"Shannon Entropy\" type: series background: #white size: {1,0.5} position: {0, 0} {\t\t\t\tdata \"entropy\" value: entropy color: #blue ;\t\t\t}\t\t\tchart \"Opinion distribution\" type: series background: #white size: {1,0.5} position: {0, 0.5} {\t\t\t\tdata \"Space area covered\" value: (union(candidate collect (each.shape buffer threshold_attraction_candidates))).area / 40000 color: #blue ;\t\t\t}\t\t}\t}}",
        "url":"/wiki/Vote-Vote.html"
      }
      ,
    
      "wiki-vote-html": {
        "title": "Vote",
        "content": "VoteThis sub-section is composed of the following models :  vote",
        "url":"/wiki/Vote.html"
      }
      ,
    
      "wiki-websitegeneration-html": {
        "title": "How to write the Website Content",
        "content": "How to write the Website ContentIn this page, we will explain all about the convention we use to write and generate the website content and the wiki content.Since the release of GAMA 1.7, with the new GAMA website, we have two contents:  The wiki content is hosted in github, witch directly interpret the markdown format of the files to display them in a proper way. This wiki, since it is a wiki, can be edited by any user. It is then, in constant changes.  The website content is the content of the real GAMA website. It is a verified and fixed version of the documentation (usually a re-generation of the website content is done when there is a new release of the software)Index  Requirements  gama.wiki tree structure  Good practices when writing markdown files          Title      Hypertext Links      Images Links      Insert Metadatas        Website Generation Workflow          Website Database      Loading the Database        Manage concepts keywordsRequirementsTo generate automatically the documentation, the GAMA Git version is required. See Install Git version for more details.Among all the GAMA plugins, only one is related to documentation generation:  msi.gama.documentation: it contains some useful java scripts to help you to write a correct documentation.In addition, the folder containing the wiki files is required. In the GitHub architecture, the wiki documentation is stored in a separate Git repository https://github.com/gama-platform/gama.wiki.git. A local clone of this repository should thus be created:  Open the Git perspective:          Windows &gt; Open Perspective &gt; Other…      Choose Git        Click on “Clone a Git repository”          In Source Git repository window:              Fill in the URI label with: https://github.com/gama-platform/gama.wiki.git      Other fields will be automatically filled in.      * In Branch Selection windows,      check the master branch      Next      * In Local Destination windows,      Choose the directory in which the gama Git repository has been cloned      Everything else should be unchecked      Finish        In the Git perspective and the Git Repositories view, Right-Click on “Working Directory” inside the gama.wiki repository, and choose “Import projects”          In the Select a wizard to use for importing projects window:              “Import existing projects” should be checked      “Working Directory” should be selected      * In Import Projects window:      Uncheck « Search for nested project »      Check the project gama.wiki      Finish        Go back to the Java perspective: a gama.wiki plugin should have been added.gama.wiki tree structureThe “gama.wiki” plugin contains all the wiki content, and almost all the website content. It contains a folder content which contains the following folders:  Tutorials          LearnGAMLStepByStep: contains the linear documentation to learn about the concepts of GAML      Recipes: contains short pieces of documentation answering a specific problematic      Tutorials: contains applicative tutorials        References          ModelLibrary: contains the model library (only present in the website)      PlatformDocumentation: contains the documentation dealing with how to use the platform      GAMLReferences: contains GAML references      PluginDocumentation: contains the documentation of the additional plugins        Community          Projects: contains a presentation of the projects where GAMA is involved (only present in the website)      Training: contains a presentation of the training sessions organized by the GAMA team (only present in the website)        WikiOnly: contains the content only present in the wiki, and not in the website          DevelopingExtensions: contains explanations about how to extend the platform        resources: contains all the additional resources needed (images, pdf…)For the rest of this document, the highest level of tree structure (“Tutorials”/”References”/”Community”/”WikiOnly”) will be named as tabs. The level just under will be named as sections, and the level under will be named as sub-section.All this content is written using the markdown format.All the images resources are included in the resources/images folder. They are actually under different sub-folders. From the markdown page, you can call the resource with the relative path resource/images/sub_folder/image_name.png.If a section/sub-section contains one of several sub-division, then those sub-divisions will be stored in a folder with the name of the corresponding section/sub-section, and this section/sub-section folder will be associated with a markdown file with the same name (indeed, a section/sub-section has its own page).If a section/sub-section has no sub-division, then this section/sub-section is simply defined with a markdown file containing the content wanted.Notice that there is some content which is present only in the wiki (the “WikiOnly” content), some content present only in the website (the model library, most of the community content…). In fact, the wiki tree structure is determined by the file Sidebar, while the website tree structure is determined by the file _WebsiteTreeStructure.Good practices when writing markdown filesTitleEach markdown files has to start with a title in the markdown format (like # title). This is this title which will be displayed in the tree structure of the website.Hypertext LinksEven if the repository how have a more complexe tree structure, you don’t have to (and you must not !) speficy the relative or absolute path to the target page, just naming the page will work : [text_displayed](the_name_of_the_md_file)Images LinksAs already said in the previous paragraph, images have to be in an “resources/images/folder_name” folder next to your md file, so that you can write the relative path more easily.Insert MetadatasMetadatas in content files are written as comments, with the following syntax:[//]: # (name_of_the_medatada|value_of_the_metadata)Medatadas are not displayed in the wiki and the website content. For the website generation, metadatas are used in order to build the database, most of all to manage the search engine, and the learning graph.Here is the list of metadata we use in the content files:      keyword : will write an invisible anchor in this exact place in the website. When the user will do a research about this word, he can access directly to this anchor.        startConcept/endConcept : used to delimit a concept. The value of those two metadatas is the name of the concept. All the concepts are listed in the file “DependencyGraph”, in the content folder in your wiki repository.  keywordThe value of the keyword has to have this structure : keyword_category_keyword_name (indeed, several keywords can have the same name ! The type of the keyword has to be specified).Here is the list of the several keyword categories : concept, operator, statement, species, architecture, type, constant and skill.Example of metadata : [//]: # (keyword|concept_3D), or [//]: # (keyword|operator_int).startConcept/endConceptThe value of the keyword have to be one of the values defined in the file learningConcept.xml.Notice that a concept in the meaning of keyword is not the same as a concept (or learning concept) in the learning graph ! Please read the part concerning the database to learn more about it.Website generation workflowThis part is not implemented yet, it is under construction.The gama.documentation pluginThis plugin is used to generate GAML documentation automatically in the markdown format, and copy paste the content to the wiki folder.The plugin is also used to generate the model library in the markdown format, with the source code, a quick description, and an image (screenshot). In the same time, the plugin generates a html page (an “abstract”) and put it directly in the model folder (in order to be loaded directly from GAMA).The documentation plugin contains also 2 other scripts which helps to create content:learningGraphDatabaseGeneratorThe learningGraphDatabaseGenerator script is used to generate the “nodesDatabase.js” file, which is read to visualize the learning graph. This script needs the “learningGraph.xml” file as input. Each learning concepts has an id, a name, a very short description, a position (position in x and y in %, between 0 and 1. This value is then multiplied by the coeff in the learningGraphDatabaseGenerator), and a list of prerequisite learning concepts. A category of learning concept (also defined in the learningGraph.xml file) has an id, a position (position in x and y), a position for the hallow (position in x and y of the big circle displayed when a category is selected), a size for the hallow, a color, a name, and the list of learningConcept associated.modelLibraryGeneratorThe modelLibraryGenerator script is used to generate all the markdown files of the model library. This script  Parse all the models of the model library, and build an “input” xml file for a headless execution (this file is deleted at the end of the execution).          By default, this will ask to execute all the experiments for each model, and take a screenshot of the 10th cycle for each display.      You can change this default behavior by changing the file “modelScreenshot.xml”, in the wiki repo (see description below)        Execute the headless  Copy-paste all the generated images in the write folder, with the write names.  Browse a second time all the models, build the md file, including the screenshot computed from the headless execution, and analyzing the header of each model to extract the title, author and tags. Each md files respects the following format : path_from_model_with_underscore_instead_of_slash_without_strange_char + “.md”. (ex : “Features/3D/3D Visualization/models/3D camera and trajectories.gaml” becomes “Features_3D_Visualization_models_3D_camera_and_trajectories.md”.)Format of the xml file to “tune up” the screenshot generation :&lt;xmlFile&gt;  &lt;experiment id=\"name_of_the_file_without_extention\"+\" \"+\"model_name\"+\" \"+\"experiment_name\"&gt;    &lt;display name=\"display_name_1\" cycle_number=\"number_of_the_cycle_for_the_screenshot\"/&gt;    &lt;display name=\"display_name_2\" cycle_number=\"number_of_the_cycle_for_the_screenshot\"/&gt;  &lt;/experiment&gt;&lt;/xmlFile&gt;TODOThe gama.wiki repositoryThis repository contains in on hand the content auto generated by the documentation plugin, and in the other hand a handmade content. All the content is in the markdown format, organized through a specific tree structure, sometime containing metadatas.The website repositoryThis repository contains:  A copy of the content of the wiki repo (copy/pasted manually to freeze a specific commit of the wiki)  A Database management system  A script used to interpret the metadatas from the content, in order to load the database  Some pages which are not in the wiki repo, and some heavy resources (such as videos)Website databaseKeywordA keyword is a keyword that can be used for search, either manually (the user enters the wanted keyword in the searchbar of the website) or automatically (through the search tab in the navigation panel)A keyword in attached with a category (among the following names : concept, type, operator, statement, species, architecture, constant, action, attribute, skill, facet).  A keyword that is a concept can be linked with other keywords (ex : the keyword “BDI” will be linked with the keywords “eval_when”, “get_priority”…)  A keyword that is a facet is linked to a statement or a species keyword (ex : the keyword “torus” will be linked with the keyword “global”).  A keyword that is an action or an attribute is linked either to a skill keyword (if it is actually an action or an attribute of a skill), an architecture keyword (if it is an action or a behavior of an architecture), or a species keyword (if it is a built-in action or attribute).  A keyword that is a statement can be linked to an architecture.A keyword is composed of:  id (unique id)  name (the word which is searched by the user)  idCategory (id of the category)A cagegory is composed of:  id (unique id)  name (the name of the category)AliasAn other database is used to join an alias to an existing keyword. Ex : the word “alias” will be changed as “die”.An alias is composed of:  id (unique id)  name (name of the alias. ex : “kill”)  attachedKeywordName (name of the keyword attached. ex : “die”)Note that an alias does not know the id of the keyword, but only the name of the attached keyword(s). Indeed, the alias “integer” will give the keyword name “int”, but several keywords correspond to the keyword name “int” (it can be the type “int”, or the cast operator “int”)WebpageA webpage can be either a page of the model library, a page of the gaml reference, or an other page of the documentation.A webpage is composed of:  id (unique id)  name (name of the webpage)  webpageCategory (the name of the category of the webpage, a value among modelPage, docPage, gamlRefPage_).The tables webpage and keyword are linked through an association table. This association table contains also an anchor (an anchor has an unique value) to the wanted paged.Note that only the keywords which have the category concept, species, type, operator, skill and constant can be attached to a webpage.The keywords which have the category action, attribute and facet forward to the attached keyword.The keywords which have the category statement are attached to a webpage only if they are not attached to another keyword. If they are attached to another keyword (an architecture keyword), then the statement keyword forward to the attached keyword.LearningConceptLearningConcept is used to build the learning graph (notice that a “learning concept” and a “keyword concept” is not the same thing !)A LearningConcept is composed with:  id (unique id)  name (name of the learning concept)A LearningConcept is linked to a webpage through an association table. This table is composed also with two anchors that are used to delimit the position of the learning concept in a page (the beginning position and the ending position).A LearningConcept can be associated to other LearningConcepts through an association table, used to spefify the “prerequisite concepts”.Loading the DatabaseThe database is loaded from a gathering of independent files. Some of those files are handmade written, other are generated automatically.Role of the documentation generation script in the construction of the databaseAs explained in the explication of the documentation generation pages, the documentation generation script is used to generate the gaml references and the model library pages (in the markdown format with metadatas), but also to build two files category.txt and keyword.xml.The file category.txt is a very simple file, listing the different keyword categories. This file will be used to build the Category table.Format of the file:concept, type, statement, species, architecture, operator, skill, constant, action, attribute, facetThe file keyword.xml is an xml file that contains all the possible keywords (all except some keywords written manually directly in the documentation pages). The GAML words can be found directly using the code of GAMA. The concept words can be found using the code of GAMA (thanks to the tag “category”) and also by using the tags in the header of the model files. This xml file will be used to build the Keyword and the AssociationKeywordCategory tables.Format of the file:&lt;keyword id:keywordname_keywordcategory&gt;  &lt;name&gt;keywordname&lt;/name&gt;  &lt;category&gt;keywordcategory&lt;/category&gt;  &lt;associatedKeywordList&gt;    &lt;associatedKeyword&gt;keywordId1&lt;/associatedKeyword&gt;    &lt;associatedKeyword&gt;keywordId2&lt;/associatedKeyword&gt;  &lt;/associatedKeywordList&gt;&lt;/keyword&gt;Note that:      The list associatedKeywordList contains only one element for the facet keywords, one of no element for the action or attribute keywords (none when the action/attribute is a built-in), several or no elements for the concept keywords, and none for the other type of keywords.        The id is build with the value of the attribute “name” and with the value of the attribute “category” for every keywords except the statement, facet, action and attribute keywords, which need also the value of the associatedKeyword linked. Ex : the id of the facet “torus” will be “facet_torus_statement_global”.  Preparation of the repository before the generation of the databaseAfter the generation of the markdown content in the wiki repository, two other files have to be built manually : the files alias.txt and learningConcept.xml.The alias.txt file contains all the connexions between alias and keyword name. It will be used to build the Alias table.Format of the file :aliasName1:remplacedWord1aliasName2:remplacedWord2kill:dieThe learningConcept.xml file is used to list the learning concepts, and to connect them to their prerequisite concepts. It will be used to build the LearningConcept and the AssociationLearningConcept tables.Format of the file :&lt;learningConcept id:learningConceptName&gt;  &lt;name&gt;learningConceptName&lt;/name&gt;  &lt;prerequisiteList&gt;    &lt;prerequisite&gt;learningConcept1&lt;/prerequisite&gt;    &lt;prerequisite&gt;learningConcept2...&lt;/prerequisite&gt;  &lt;/prerequisiteList&gt;&lt;/learningConcept&gt;Note that the value of the attribute “name” can be used as an unique id.Role of the website content generation script in the construction of the databaseAfter copy-paste the content to the website folder, a script is used to build the database and to generate website content.The Category, Alias, LearningConcept and AssociationLearningConcept tables are loaded easily from the files category.txt, alias.txt, and learningConcept.xml.The Keyword and AssociationKeywordCategory tables are loaded from the keyword.xml file. Note that those two tables are not entirely loaded yet, because other keywords can be presents in the header of other files.The markdown files are converted one by one into html format.                              When a metadata startConcept/endConcept is found (syntax : [//]: # (beginAnchor          name_of_learning_concept)), the metadata is replaced with an anchor in the page (with an unique id), and the AssociationWebpageConcept table is updated.                                                  When a metadata keyword is found (syntax :  [//]: # (keyword          name_of_keyword_category_name_of_keyword)), the metadata is replaced with an anchor in the page (with an unique id), and the AssociationWebpageKeyword table is updated (the Keyword and AssociationKeywordCategory are updated if the keyword does not exist yet in the table).                    Manage concepts keywordsALL the concepts must be declared in the “IConcept” java class. If you want to add a new concept, please check before if your the concept you want to add cannot be remplaced by one of the existing concept. If it is the case, you can add your word as if it was an alias, pointing to the existing concept. Note that all the alias are listed in the alias.txt file. If you realy think that the concept has to be added, please add it to the IConcept file, and also to (one or several) of the lists CONCEPTS_NOT_FOR_GAML_REF, CONCEPTS_NOT_FOR_MODEL_LIBRARY, CONCEPTS_DEDICATED_TO_SYNTAX in the ConceptManager class if needed.Most of the keywords of the website (used for the search) are managed automatically. But the “concepts” keywords have to be (partially) hand-made managed. You can add the concepts with 3 differents methods :In the Documentation“Documentation” here designs all the content manually written in the wiki. All those pages can contain “concepts” through the metadata format :[//]: # (keyword|concept_name_of_concept)You can either :  place those metadatas anywhere in the page if you want to point directly in this part of the page if the user makes a search  place those metadatas above the title : doing this, the “automatic search” (left navigation panel) will be made with this concept. You have to be really sure this concept is the main concept of the page to place it there.In the Model libraryDirectly from the gaml files of the model library, you can add the concept you want through the “Tags” in the header of the model.Exemple :/*** Name: 3D Display model of differents shapes and a special Object* Author: * Description: Model presenting a 3D display of differents shapes (pyramid, cone, cylinder, sphere and a teapot object) to represent the same agents but with*       different aspects. Five experiments are possible, one for each of the shapes presented previously. In each experiment, the agents move to create a big circle but flee*       from their closest neighbour. * Tags: 3d, shape, neighbors*/Note that if you don’t want this model to have a page in the website, you can name it starting with the character _.In the GAML ReferencesYou can add a concept to a gaml word by using the syntax concept = { IConcept.MY_CONCEPT }.Exemple :@operator(value = \"flip\",\tconcept = { IConcept.RANDOM }The following text has been automatically generated from “mainCheckConcepts”______ last update : 2017/02/28 14:21:42List of concepts to use for model library (except Syntax):3d, agent_location, agent_movement, algorithm, architecture, asc, batch, bdi, camera, chart, clustering, color, communication, comodel, comparison, csv, database, date, dem, dgs, diffusion, dxf, edge, elevation, equation, fipa, fsm, geometry, gis, graph, graph_weight, graphic, grid, gui, headless, hydrology, image, inheritance, inspector, light, load_file, math, mirror, monitor, multi_criteria, multi_level, multi_simulation, neighbors, network, nil, node, obj, obstacle, osm, overlay, physics_engine, r, raster, regression, save_file, scheduler, serialize, shape, shapefile, shortest_path, skill, sound, spatial_computation, spatial_relation, spatial_transformation, sport, statistic, svg, system, task_based, test, text, texture, tif, topology, transport, txt, xmlList of concepts to use exclusively in Syntax models:arithmetic, attribute, cast, condition, container, filter, list, logical, loop, map, matrix, string, ternaryList of concepts to use for GAML worlds:3d, action, agent_location, agent_movement, algorithm, architecture, arithmetic, asc, attribute, batch, bdi, behavior, camera, cast, chart, clustering, color, communication, comodel, comparison, condition, constant, container, csv, cycle, database, date, dem, dgs, diffusion, dimension, display, dxf, edge, elevation, equation, experiment, file, filter, fipa, fsm, geometry, gis, graph, graph_weight, graphic, graphic_unit, grid, gui, headless, hydrology, image, inspector, length_unit, light, list, load_file, logical, loop, map, math, matrix, mirror, monitor, multi_criteria, multi_level, multi_simulation, neighbors, network, nil, node, obj, obstacle, optimization, osm, overlay, parameter, physics_engine, point, r, random, random_operator, raster, regression, save_file, scheduler, serialize, shape, shapefile, shortest_path, skill, sound, spatial_computation, spatial_relation, spatial_transformation, species, statistic, string, surface_unit, svg, system, task_based, ternary, test, text, texture, tif, time, time_unit, topology, transport, txt, type, volume_unit, weight_unit, xml            Concept name      in Doc      in GAML Ref      in Model Lib      TOTAL                  3d      2      17      39      58              action      3      5      _      9              agent_location      1      21      0      22              agent_movement      0      2      23      25              algorithm      1      8      2      11              architecture      2      11      1      14              arithmetic      0      33      0      33              asc      0      2      2      4              attribute      2      6      _      9              autosave      2      _      _      2              background      1      _      _      1              batch      3      8      4      15              bdi      1      51      0      52              behavior      3      7      _      10              camera      1      1      2      4              cast      1      17      1      19              chart      0      5      5      10              clustering      0      5      3      8              color      1      17      4      22              communication      0      3      0      3              comodel      0      0      8      8              comparison      0      6      2      8              condition      1      7      0      8              constant      0      13      _      13              container      1      60      1      62              csv      2      4      3      9              cycle      2      2      _      4              database      1      3      17      21              date      1      48      2      51              dem      0      0      1      1              dgs      0      0      1      1              diffusion      1      1      14      16              dimension      2      35      _      37              display      2      25      _      29              distribution      1      _      _      1              dxf      0      2      1      3              edge      1      15      1      17              elevation      0      0      7      7              enumeration      1      _      _      1              equation      2      7      15      24              experiment      2      3      _      5              facet      1      _      _      1              file      1      44      _      47              filter      1      12      0      13              fipa      1      4      11      16              fsm      1      0      0      1              geometry      2      96      0      98              gis      0      5      24      29              global      1      _      _      1              graph      1      55      32      88              graph_weight      1      3      0      4              graphic      1      10      1      12              graphic_unit      1      6      _      7              grid      4      10      33      47              gui      3      9      24      36              halt      1      _      _      1              headless      0      1      0      1              hydrology      0      0      1      1              image      0      4      0      4              import      1      _      _      1              inheritance      1      _      1      2              init      3      _      _      3              inspector      1      2      1      4              layer      1      _      _      1              length_unit      0      9      _      9              light      2      1      4      7              list      0      9      2      11              load_file      4      1      18      23              logical      1      7      0      8              loop      1      2      2      5              map      0      15      1      16              math      1      41      20      62              matrix      2      22      8      32              mirror      1      0      2      3              model      1      _      _      1              monitor      1      1      1      3              multi_criteria      0      4      1      5              multi_level      1      3      9      13              multi_simulation      1      0      2      3              neighbors      1      5      1      7              network      0      1      0      1              nil      1      0      0      1              node      1      20      1      22              obj      0      0      2      2              obstacle      0      1      3      4              opengl      3      _      _      3              operator      1      _      _      1              optimization      3      1      _      4              osm      1      2      2      5              output      2      _      _      7              overlay      0      0      1      1              parameter      2      1      _      3              pause      1      _      _      1              permanent      1      _      _      1              physics_engine      0      0      4      4              point      0      29      _      29              probability      1      _      _      1              pseudo_variable      1      _      _      1              r      1      2      0      3              random      3      10      _      13              random_operator      0      0      _      0              raster      0      0      4      4              reflex      1      _      _      1              refresh      2      _      _      2              regression      0      2      1      3              save_file      0      2      8      10              scheduler      2      2      0      4              serialize      0      0      0      0              shape      3      21      1      25              shapefile      2      2      34      38              shortest_path      1      6      4      11              skill      2      17      42      61              sound      0      4      0      4              spatial_computation      0      73      7      80              spatial_relation      0      32      0      32              spatial_transformation      0      24      2      26              species      1      20      _      21              sport      0      _      2      2              statistic      0      66      5      71              string      0      27      0      27              surface_unit      0      4      _      4              svg      0      2      0      2              system      1      11      0      12              task_based      1      4      0      5              ternary      1      2      1      4              test      0      4      2      6              text      2      10      0      12              texture      0      1      3      4              tif      0      2      1      3              time      2      20      _      22              time_unit      0      13      _      13              topology      3      9      4      16              torus      1      _      _      1              transport      1      5      6      12              txt      0      0      1      1              type      0      53      _      53              update      1      _      _      1              volume_unit      0      5      _      5              weight_unit      0      8      _      8              world      1      _      _      1              write      1      _      _      1              xml      0      4      0      4      ",
        "url":"/wiki/WebsiteGeneration.html"
      }
      ,
    
      "wiki-whatsnext-html": {
        "title": "What's next ?",
        "content": "What’s next ?Now you have a runnable GAMA on your computer, and you know a bit more about how to use the platform, you are ready to navigate through the website. Use the new powerful functionnalities of the website :  Try the search engine of the website to find quickly the notion you want to learn.  Navigate through the website by 3 different ways :          !images/general/icon_default_navigation.png The classic navigation : to have a classic top-down navigation.      !images/general/icon_learning_graph_navigation.png The learning path navigation : select the concept you want to learn, and a learning path will be build just for you, in order to assimilate this concept more quickly !      !images/general/icon_search_navigation.png The search related navigation : for each page, some suggestions of related pages (dealing with the same concepts, or presenting the same GAML world) allows you to have a more transversal navigation.      ",
        "url":"/wiki/WhatsNext.html"
      }
      ,
    
      "wiki-workspaceprojectsandmodels-html": {
        "title": "Workspace, Projects and Models",
        "content": "Workspace, Projects and ModelsThe workspace is a directory in which GAMA stores all the current projects on which the user is working, links to other projects, as well as some meta-data like preference settings, current status of the different projects, error markers, and so on.Except when running in headless mode, GAMA cannot function without a valid workspace.The workspace is organized in 3 categories, which are themselves organized into projects.The projects present in the workspace can be either directly stored within it (as sub-directories), which is usually the case when the user creates a new project, or linked from it (so the workspace will only contain a link to the directory of the project, supposed to be somewhere in the filesystem or on the network). A same project can be linked from different workspaces.GAMA models files are stored in these projects, which may contain also other files (called resources) necessary for the models to function. A project may of course contain several model files, especially if they are importing each other, if they represent different views on the same topic, or if they share the same resources.Learning how to navigate in the workspace, how to switch workspace or how to import, export is a necessity to use GAMA correctly. It is the purpose of the following sections.            Navigating in the Workspace                  Changing Workspace                  Importing Models      ",
        "url":"/wiki/WorkspaceProjectsAndModels.html"
      }
      ,
    
      "wiki-writingmodels-html": {
        "title": "Writing Models",
        "content": "Writing ModelsModels in GAMA play the same role as classes in Java or C++: they represent both the knowledge about a particular phenomenon a user wants to simulate and the way(s) to simulate it. A model is nothing more than a text file (or a collection of text files that refer to each other), which contains instructions in a specific language called GAML (for “GAMA Modeling Language”).A model can then be theoretically edited using any text processor and later loaded into GAMA to run experiments. However, because of the richness of the language, using a dedicated tool (with online help, live validation) is clearly the best way to write correct models.The GUI version of GAMA offers such an integrated model development environment, which is composed of a set of coupled tools to support modelers in the edition, validation, and management of models. An optional graphical modeling editor can also be installed on top of these tools to support higher-level modeling activities (similar to what a UML editor with Java bindings may provide to a Java development environment).This chapter contains a description of these different tools and a comprehensive guide to the GAML language, including a complete reference of all the built-in structures and facilities offered in its current version.Please proceed to one of these sections :            Editing Models                  GAML Language                  GAML Reference                  Optimizing Models      ",
        "url":"/wiki/WritingModels.html"
      }
      ,
    
      "about": {
        "title": "About",
        "content": "This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at jekyllrb.comYou can find the source code for the Jekyll new theme at:jekyll /minimaYou can find the source code for Jekyll atjekyll /jekyll",
        "url":"/about/"
      }
      ,
    
      "contribute-html": {
        "title": "Search",
        "content": "  Search    ",
        "url":"/contribute.html"
      }
      ,
    
      "download-html": {
        "title": "Download",
        "content": "    \t\t   ",
        "url":"/download.html"
      }
      ,
    
      "": {
        "title": "Home",
        "content": "                                                              GAMA PLATFORM                      DOWNLOAD                                                Multiple application domains             GAMA has been developed with a very general approach, and can be used for many applications domains. Some additional plugins had been developed to fit with particular needs.        Example of domains where GAMA is mostly present :        Transport        Urban growth        Epidemiology        Environment        Some training sessions about topics such as \"urban management\", \"epidemiology\" are also provided by the team. Since GAMA is an open-source software that continues to grow, if you have any particular needs of improvement, feel free to share it to its active community !                                                    High level and intuitive language      Thanks to its high-level and intuitive language, GAMA has been developed to be used by non-computer scientists. You can declare your species, giving them some special behaviors, create them in your world, and display them in less than 10 minutes.        GAML is the language used in GAMA, coded in Java. It is an agent-based language, that provides you the possibility to build your model with several paradigms of modeling.         Once your model is ready, some features allows you to explore and calibrate it, using the parameters you defined as input of your simulation.        We provides you a continual support through the active mailing list where the team will answer your questions. Besides, you can learn GAML on your own, following the step by step tutorial, or personal learning path in order reach the point you are interested in.                          GIS and Data-Driven models                  GAMA (GIS Agent-based Modeling Architecture) provides you, since its creation, the possibility to load easily GIS (Geographic Information System).            You can import a large number of data, such as text, files, CSV, shapefile, OSM (open street map data), grid, images, SVG, but also 3D files, such as 3DS or OBJ, with their texture.            Some advanced features provides you the possibility to connect GAMA to databases, and also to use powerful statistical tools such as R.            GAMA has been used in large-scale projects, using a great number of agents (up to millions of agents).                                                     Declarative user interface      GAMA provides you the possibility to have multiple displays for the same model. You can add as much visual representations as you want for the same model, in order to highlight a certain aspect of your simulation. Add easily new visual aspects to your agents.        Advanced 3D displays are provided : you can control lights, cameras, and also adding textures to your 3D objects. In an other hand, dedicated statements allows you to define easily charts, such as series, histogram, or pies.        During the simulations, some advanced features are available to inspect the population of your agents. To make your model more interactive, you can add easily some user-controlled action panels, or mouse events.          ______________________________________GAMA is developed by several teams under the umbrella of the IRD/UPMC international research unit [UMMISCO](http://www.ummisco.ird.fr/):* [MSI Research Team](http://www.ifi.auf.org/site/content/view/35/46/lang,french/), Vietnam National University, Hanoi, Vietnam (2007 - 2015)* [UMR 6228 IDEES](http://www.umr-idees.fr), CNRS/University of Rouen, France (2010 - 2015)* [UMR 5505 IRIT](http://www.irit.fr), CNRS/University of Toulouse 1, France (2010 - 2015)* [DREAM Research Team](http://www.cit.ctu.edu.vn), University of Can Tho, Vietnam (2011 - 2015)* [UMR 8623 LRI](http://www.lri.fr), CNRS/University Paris-Sud, France (2011 - 2015)---",
        "url":"/"
      }
      ,
    
      "news-html": {
        "title": "News",
        "content": "        \t{% for post in site.posts %}            {% capture modulo %}{{ forloop.index0 | modulo :3 }}{% endcapture %}            {% if modulo == '0' and forloop.index0>0%}                                    {% endif %}                            {{ post.title }}          {{ post.date | date: \"%B %e, %Y\" }} - {{ post.author }} -  {{ post.categories| join: ' '  }}  \t\t\t                          {{ post.content | strip_html | truncatewords: 20 }}                                  \t        {% endfor %}\t                                            \t                                                                                                                                                                                                                                                                                             ",
        "url":"/news.html"
      }
      ,
    
      "assets-main-css": {
        "title": "",
        "content": "@import \"minima\";",
        "url":"/assets/main.css"
      }
      ,
    
      "feed-xml": {
        "title": "",
        "content": "{% if page.xsl %}{% endif %}Jekyll{{ site.time | date_to_xmlschema }}{{ '/' | absolute_url | xml_escape }}{% if site.title %}{{ site.title | smartify | xml_escape }}{% elsif site.name %}{{ site.name | smartify | xml_escape }}{% endif %}{% if site.description %}{{ site.description | xml_escape }}{% endif %}{% if site.author %}{{ site.author.name | default: site.author | xml_escape }}{% if site.author.email %}{{ site.author.email | xml_escape }}{% endif %}{% if site.author.uri %}{{ site.author.uri | xml_escape }}{% endif %}{% endif %}{% assign posts = site.posts | where_exp: \"post\", \"post.draft != true\" %}{% for post in posts limit: 10 %}{{ post.title | smartify | strip_html | normalize_whitespace | xml_escape }}{{ post.date | date_to_xmlschema }}{{ post.last_modified_at | default: post.date | date_to_xmlschema }}{{ post.id | absolute_url | xml_escape }}{{ post.content | strip | xml_escape }}{% assign post_author = post.author | default: post.authors[0] | default: site.author %}{% assign post_author = site.data.authors[post_author] | default: post_author %}{% assign post_author_email = post_author.email | default: nil %}{% assign post_author_uri = post_author.uri | default: nil %}{% assign post_author_name = post_author.name | default: post_author %}{{ post_author_name | default: \"\" | xml_escape }}{% if post_author_email %}{{ post_author_email | xml_escape }}{% endif %}{% if post_author_uri %}{{ post_author_uri | xml_escape }}{% endif %}{% if post.category %}{% endif %}{% for tag in post.tags %}{% endfor %}{% if post.excerpt and post.excerpt != empty %}{{ post.excerpt | strip_html | normalize_whitespace | xml_escape }}{% endif %}{% assign post_image = post.image.path | default: post.image %}{% if post_image %}{% unless post_image contains \"://\" %}{% assign post_image = post_image | absolute_url | xml_escape  %}{% endunless %}{% endif %}{% endfor %}",
        "url":"/feed.xml"
      }
      
    
  }