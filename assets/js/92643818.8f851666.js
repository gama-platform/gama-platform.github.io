"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[15232],{3905:(e,n,a)=>{a.d(n,{Zo:()=>f,kt:()=>_});var t=a(67294);function s(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function r(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function l(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?r(Object(a),!0).forEach((function(n){s(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function o(e,n){if(null==e)return{};var a,t,s=function(e,n){if(null==e)return{};var a,t,s={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(s[a]=e[a]);return s}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var i=t.createContext({}),c=function(e){var n=t.useContext(i),a=n;return e&&(a="function"==typeof e?e(n):l(l({},n),e)),a},f=function(e){var n=c(e.components);return t.createElement(i.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},b=t.forwardRef((function(e,n){var a=e.components,s=e.mdxType,r=e.originalType,i=e.parentName,f=o(e,["components","mdxType","originalType","parentName"]),p=c(a),b=s,_=p["".concat(i,".").concat(b)]||p[b]||d[b]||r;return a?t.createElement(_,l(l({ref:n},f),{},{components:a})):t.createElement(_,l({ref:n},f))}));function _(e,n){var a=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var r=a.length,l=new Array(r);l[0]=b;var o={};for(var i in n)hasOwnProperty.call(n,i)&&(o[i]=n[i]);o.originalType=e,o[p]="string"==typeof e?e:s,l[1]=o;for(var c=2;c<r;c++)l[c]=a[c];return t.createElement.apply(null,l)}return t.createElement.apply(null,a)}b.displayName="MDXCreateElement"},61528:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>f,contentTitle:()=>i,default:()=>_,frontMatter:()=>o,metadata:()=>c,toc:()=>p});var t=a(87462),s=a(63366),r=(a(67294),a(3905)),l=["components"],o={"^title":"TreesAndSeasons"},i=void 0,c={unversionedId:"TreesAndSeasons",id:"TreesAndSeasons",title:"TreesAndSeasons",description:"Path: Library models/Toy Models/Art/L-Trees/models/Tree and Seasons.gaml",source:"@site/../docs/TreesAndSeasons.md",sourceDirName:".",slug:"/TreesAndSeasons",permalink:"/wiki/next/TreesAndSeasons",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/TreesAndSeasons/_edit",tags:[],version:"current",frontMatter:{"^title":"TreesAndSeasons"}},f={},p=[],d={toc:p},b="wrapper";function _(e){var n=e.components,a=(0,s.Z)(e,l);return(0,r.kt)(b,(0,t.Z)({},d,a,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("img",{width:"960",alt:"Annotation 2023-04-14 181339_TreesAndSeasons",src:"https://user-images.githubusercontent.com/4437331/232099298-c58976d0-36fc-4ac3-b5f9-147113bd5489.png"}),(0,r.kt)("p",null,"Path: Library models/Toy Models/Art/L-Trees/models/Tree and Seasons.gaml"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'\n/**\n *  Author: Tri Nguyen-Huu\n *  Description: growing tree using L-systems.\n */\nmodel tree\n\nglobal {\n    float rigidity;\n    int max_level <- 8;\n    float min_energy <- 300.0;\n    float main_split_angle_alpha <- 30.0;\n    float secondary_split_angle_alpha <- 90.0;\n    float main_split_angle_beta <- 20.0;\n    float secondary_split_angle_beta <- 90.0;\n    float length_max <- 100.0;\n    float width_ini <- 1.0;\n    float level_step <- 0.8;\n    seasons season;\n    float width <- shape.width;\n    float height <- shape.height;\n    float env_size <- 0.5 * length_max / (1 - level_step);\n    point seed_pos <- {width / 2, height / 2};\n\n    init {\n        create plant_seed {\n            location <- seed_pos;\n            write location;\n        }\n\n        create seasons number: 1 {\n            season <- self;\n        }\n    }\n}\n\nspecies seasons {\n    int season_duration <- 600;\n    int shift_cycle <- season_duration * 4 update: season_duration * 4 + int(cycle - floor(season_duration / 2));\n    list<string> season_list <- ["winter", "spring", "summer", "autumn"];\n    string current_season <- "winter" update: season_list[(cycle div season_duration) mod 4];\n    int current_day <- 0 update:  cycle mod season_duration;\n    int shift_current_day <- 0 update: shift_cycle mod season_duration;\n    float energy <- 0.0 update: energy_map[current_season];\n    int se <- 0 update: (shift_cycle div season_duration) mod 4;\n    int next_se <- 1 update: (se + 1) mod 4;\n    int ns_se <- 0 update: (cycle div season_duration) mod 4;\n    int ns_next_se <- 1 update: (ns_se + 1) mod 4;\n    list<rgb> sky_color_list <- [rgb(238, 238, 238), rgb(129, 207, 224), rgb(25, 181, 254), rgb(254, 224, 144)];\n    list<rgb> leaf_color_list <- [rgb(150, 40, 27), rgb(134, 174, 83), rgb(30, 130, 76), rgb(192, 57, 43)];\n    list<rgb> ground_color_list <- [rgb(236, 240, 241), rgb(46, 204, 113), rgb(38, 166, 91), rgb(95, 104, 40)];\n    //      list<rgb> branch_color_list <- [rgb(97,73,52),rgb(90,139,140),rgb(90,139,140),rgb(90,139,140)];\n    list<rgb> branch_color_list <- [rgb(77, 67, 62), rgb(60, 45, 32), rgb(115, 77, 64), rgb(90, 68, 48)];\n    list<rgb> fruit_color_list <- [rgb(102, 62, 81), rgb(200, 247, 197), rgb(135, 211, 124), rgb(211, 84, 0)];\n    rgb sky_color <- sky_color_list[0];\n    rgb leaf_color <- leaf_color_list[0];\n    rgb ground_color <- ground_color_list[0];\n    rgb branch_color <- branch_color_list[0];\n    rgb fruit_color <- fruit_color_list[0];\n    map<string, float> energy_map <- ["winter"::0.0, "spring"::0.3, "summer"::0.08, "autumn"::0];\n\n    init {\n        do change_color;\n    }\n\n    action change_color {\n        leaf_color <- blend(leaf_color_list[se], leaf_color_list[next_se], 1 - shift_current_day / season_duration);\n        sky_color <- blend(sky_color_list[se], sky_color_list[next_se], 1 - shift_current_day / season_duration);\n        ground_color <- blend(ground_color_list[se], ground_color_list[next_se], 1 - shift_current_day / season_duration);\n        branch_color <- blend(branch_color_list[ns_se], branch_color_list[ns_next_se], 1 - current_day / season_duration);\n        float scale <- 500.0;\n        fruit_color <- blend(fruit_color_list[ns_se], fruit_color_list[ns_next_se], exp(-current_day / scale));\n    }\n\n    reflex update {\n        do change_color;\n    }\n\n}\n\nspecies tree_part {\n    tree_part parent <- nil;\n    point vector <- {0, 0, 0};\n    point base <- {0, 0, 0};\n    point end <- {0, 0, 0};\n    float alpha <- 0.0;\n    float beta <- 0.0;\n    float level <- 1.0;\n    list children <- nil;\n    float energy <- 0.0;\n}\n\nspecies plant_seed parent: tree_part {\n    bool has_tree <- false;\n    point end -> self.location;\n    point vector <- {0, 0, 1};\n\n    reflex create_tree when: (!has_tree and season.current_season = "spring") {\n        create trunk {\n            base <- myself.location;\n            self.end <- self.base;\n            alpha <- rnd(100) * 360 / 100;\n            beta <- 90.0;\n            level <- 1.0;\n            parent <- myself;\n        }\n\n        has_tree <- true;\n    }\n\n    aspect default {\n        draw\n        polygon([location + {env_size / 2, 0, -1}, location + {0.5 * env_size / 2, 0.86 * env_size / 2, -1}, location + {-0.5 * env_size / 2, 0.86 * env_size / 2, -1}, location + {-env_size / 2, 0, -1}, location + {-0.5 * env_size / 2, -0.86 * env_size / 2, -1}, location + {0.5 * env_size / 2, -0.86 * env_size / 2, -1}])\n        color: season.ground_color border: season.ground_color;\n        draw cone3D(6, 6) at: location color: rgb(108, 122, 137);\n        draw polygon([location + {0, 0, 3}, location + {env_size / 6, 0, 0}, location + {0.5 * env_size / 6, 0.86 * env_size / 6, 0}]) color: rgb(135, 121, 78) border:\n        rgb(135, 121, 78);\n        draw polygon([location + {0, 0, 3}, location + {0.5 * env_size / 6, 0.86 * env_size / 6, 0}, location + {-0.5 * env_size / 6, 0.86 * env_size / 6, 0}]) color: rgb(115, 101, 58)\n        border: rgb(115, 101, 58);\n        draw polygon([location + {0, 0, 3}, location + {-0.5 * env_size / 6, 0.86 * env_size / 6, 0}, location + {-env_size / 6, 0, 0}]) color: rgb(115, 101, 58) border:\n        rgb(115, 101, 58);\n        draw polygon([location + {0, 0, 3}, location + {-env_size / 6, 0, 0}, location + {-0.5 * env_size / 6, -0.86 * env_size / 6, 0}]) color: rgb(135, 121, 78) border:\n        rgb(135, 121, 78);\n        draw polygon([location + {0, 0, 3}, location + {-0.5 * env_size / 6, -0.86 * env_size / 6, 0}, location + {0.5 * env_size / 6, -0.86 * env_size / 6, 0}]) color:\n        rgb(135, 121, 78) border: rgb(135, 121, 78);\n        draw polygon([location + {0, 0, 3}, location + {0.5 * env_size / 6, -0.86 * env_size / 6, 0}, location + {env_size / 6, 0, 0}]) color: rgb(135, 121, 78) border:\n        rgb(135, 121, 78);\n    }\n\n}\n\nspecies burgeon parent: tree_part {\n\n    reflex growth {\n        energy <- energy + first(season).energy;\n    }\n\n    reflex bloom when: flip(energy / 1) {\n        branch tmp <- nil;\n        create branch number: 1 {\n            tmp <- self;\n            self.level <- myself.level;\n            self.base <- myself.base;\n            self.end <- self.base;\n            self.alpha <- myself.alpha;\n            self.beta <- myself.beta;\n            self.parent <- myself.parent;\n            if myself.parent != nil {\n                myself.parent.children <- myself.parent.children + tmp;\n            }\n\n        }\n\n        create leaf {\n            self.level <- myself.level;\n            self.parent <- tmp;\n            self.alpha <- myself.alpha;\n            self.beta <- myself.beta;\n            self.base <- tmp.end;\n            self.end <- self.base + {5 * cos(beta) * cos(alpha), 5 * cos(beta) * sin(alpha), 5 * sin(beta)};\n            tmp.children <- tmp.children + self;\n            self.creation_cycle <- cycle;\n        }\n\n        do die;\n    }\n\n}\n\nspecies trunk parent: tree_part {\n    float length <- 0.0;\n    float width <- 0.0;\n    bool can_split <- true;\n\n    aspect default {\n        draw line([base, end], width) color: season.branch_color; // border: #red;\n    }\n\n    reflex growth {\n        base <- parent.end;\n        energy <- energy + first(season).energy;\n        float level_correction <- 1.8 * 0.3 ^ level;\n        length <- level_correction * (length_max * (1 - min([1, exp(-energy / 1000)])));\n        width <- length / level_correction / 13.0;\n        end <- base + {length * cos(beta) * cos(alpha), length * cos(beta) * sin(alpha), length * sin(beta)};\n    }\n\n    reflex split when: can_split and (level < max_level) and (min_energy < energy) {\n        float branch1_alpha <- rnd(100) / 100 * 360;\n        float branch1_beta <- 30 + rnd(100) / 100 * 40;\n        float branch2_alpha <- rnd(100) / 100 * 360;\n        float branch2_beta <- 30 + rnd(100) / 100 * 40;\n        can_split <- false;\n        create burgeon number: 1 {\n            self.level <- myself.level + 1.9;\n            self.base <- myself.end;\n            self.end <- self.base;\n            self.alpha <- branch1_alpha;\n            self.beta <- branch1_beta;\n            self.parent <- myself;\n        }\n\n        if flip(0.7) {\n            create burgeon number: 1 {\n                self.level <- myself.level + 2.1;\n                self.base <- myself.end;\n                self.end <- self.base;\n                self.alpha <- branch2_alpha;\n                self.beta <- branch2_beta;\n                self.parent <- myself;\n            }\n\n        }\n\n        create trunk number: 1 {\n            self.level <- myself.level + 0.3;\n            self.base <- myself.end;\n            self.end <- self.end;\n            self.alpha <- myself.alpha - 10 + rnd(200) / 10;\n            self.beta <- myself.beta - 10 + rnd(200) / 10;\n            self.parent <- myself;\n        }\n\n    }\n\n}\n\nspecies branch parent: tree_part {\n    float length <- 0.0;\n    float width <- 0.0;\n    bool can_split <- true;\n\n    reflex growth {\n        base <- parent.end;\n        energy <- energy + first(season).energy;\n        length <- level_step ^ level * (length_max * (1 - min([1, exp(-energy / 1000)])));\n        width <- length / 10 * (4 + max_level - level) / (4 + max_level);\n        end <- base + {length * cos(beta) * cos(alpha), length * cos(beta) * sin(alpha), length * sin(beta)};\n    }\n\n    aspect default {\n        draw line([base, end], width) color: season.branch_color; // border: #green;\n        if (season.current_season = "winter") and (abs(beta) < 50) {\n            draw line([base + {0, 0, 1.2 * width}, end + {0, 0, 1.2 * width}], width * sin(180 * season.current_day / season.season_duration)) color: #white;\n        }\n\n    }\n\n}\n\nspecies leaf {\n    int creation_cycle <- -1;\n    float level <- 1.0;\n    branch parent;\n    point base;\n    point end;\n    float alpha <- 0.0;\n    float beta <- 0.0;\n    float fall <- 0.0;\n    int fall_shift <- int(rnd(season.season_duration / 2.5));\n    float size <- 3.0;\n    pair<float, point> rota <- rotation_composition(float(rnd(180))::{1, 0, 0}, float(rnd(180))::{0, 1, 0}, float(rnd(180))::{0, 0, 1}); //////////////////////////\n    aspect default {\n        draw line([base, end], min([parent.width, 1])) color: season.leaf_color;\n        //          draw circle(size) at: (end - {0,0,fall*end.z}) color: season.leaf_color border: season.leaf_color;\n        draw circle(size) rotate: rota at: (end - {0, 0, fall * end.z}) color: season.leaf_color; // border: #black; //season.leaf_color;\n    }\n\n    reflex update {\n        base <- parent.end;\n        end <- base + {5 * cos(beta) * cos(alpha), 5 * cos(beta) * sin(alpha), 5 * sin(beta)};\n        if (season.current_season = "autumn") {\n            fall <- 1 - exp(-max([0, 5 * (season.current_day - fall_shift) / season.season_duration * 3]));\n        } else if (season.current_season = "winter") {\n            size <- 3 * (season.season_duration - season.current_day) / season.season_duration;\n        } else if (season.current_season = "spring") {\n            fall <- 0.0;\n            size <- 3 * season.current_day / season.season_duration;\n        }\n\n    }\n\n    reflex split when: (level < max_level) and flip(1 - exp(level * (min_energy - parent.energy) / 50)) {\n        int side1 <- -1 + 2 * rnd(1);\n        int side2 <- -1 + 2 * rnd(1);\n        int side3 <- -1 + 2 * rnd(1);\n        int side4 <- -1 + 2 * rnd(1);\n        float factor <- secondary_split_angle_alpha / 100;\n        float branch1_alpha <- parent.alpha + side1 * rnd(100) / 100 * main_split_angle_alpha;\n        float branch2_alpha <- parent.alpha - side1 * rnd(100) * factor;\n        float branch3_alpha <- parent.alpha + side3 * rnd(100) * factor;\n        float branch4_alpha <- parent.alpha - side3 * rnd(100) * factor;\n        int sideb <- -1 + 2 * rnd(1);\n         factor <- secondary_split_angle_beta / 100;\n        float branch1_beta <- parent.beta + sideb * rnd(100) / 100 * main_split_angle_beta;\n        float branch2_beta <- -20 + rnd(100) * factor;\n        float branch3_beta <- -20 + rnd(100) * factor;\n        float branch4_beta <- -20 + rnd(100) * factor;\n        create burgeon number: 1 {\n            self.level <- myself.parent.level + 1;\n            self.base <- myself.base;\n            self.end <- self.base;\n            self.alpha <- branch1_alpha;\n            self.beta <- branch1_beta;\n            self.parent <- myself.parent;\n        }\n\n        create burgeon number: 1 {\n            self.level <- myself.parent.level + 1.2;\n            self.base <- myself.base;\n            self.end <- self.base;\n            self.alpha <- branch2_alpha;\n            self.beta <- branch2_beta;\n            self.parent <- myself.parent;\n        }\n\n        if flip(0.6) {\n            create burgeon number: 1 {\n                self.level <- myself.parent.level + 1.7;\n                self.base <- myself.base;\n                self.end <- self.base;\n                self.alpha <- branch3_alpha;\n                self.beta <- branch3_beta;\n                self.parent <- myself.parent;\n            }\n\n        }\n\n        if flip(0.3) {\n            create burgeon number: 1 {\n                self.level <- myself.parent.level + 2;\n                self.base <- myself.base;\n                self.end <- self.base;\n                self.alpha <- branch4_alpha;\n                self.beta <- branch4_beta;\n                self.parent <- myself.parent;\n            }\n\n        }\n\n        if flip(0.8) {\n            create burgeon number: 1 {\n                self.level <- myself.parent.level + 3.5;\n                self.base <- myself.base;\n                self.end <- self.base;\n                self.alpha <- branch4_alpha;\n                self.beta <- branch4_beta;\n                self.parent <- myself.parent;\n            }\n\n        }\n\n        if flip(0.9) {\n            create fruit number: (1 + rnd(2)) {\n                self.base <- myself.base;\n                self.end <- myself.base + {3 * cos(beta) * cos(alpha), 3 * cos(beta) * sin(alpha), 3 * sin(beta)};\n                self.parent <- myself.parent;\n                self.alpha <- myself.alpha + (-1 + 2 * rnd(1)) * 30;\n                self.beta <- -40.0 + rnd(80);\n            }\n\n        }\n\n        self.parent.children <- self.parent.children - self;\n        do die;\n    }\n\n}\n\nspecies fruit {\n    branch parent;\n    point base;\n    point end;\n    float alpha;\n    float beta;\n    float fall <- 0.0;\n    int fall_shift <- int(rnd(season.season_duration / 2.5)); //unused\n    aspect default {\n        if (season.current_season = "spring") {\n            draw line([base, end], 0.1) color: season.leaf_color;\n            draw circle(1 * sin(180 * season.current_day / season.season_duration)) at: end color: #pink border: #pink;\n        } else if (season.current_season = "summer") {\n            draw line([base, end], 0.1) color: season.leaf_color;\n            draw sphere(1 * sin(90 * season.current_day / season.season_duration)) at: end color: season.fruit_color border: season.fruit_color;\n        }\n\n    }\n\n    reflex update {\n        base <- parent.end;\n        if (season.current_season = "spring") {\n            end <- base + {3 * cos(beta) * cos(alpha), 3 * cos(beta) * sin(alpha), 3 * sin(beta)};\n        } else if (season.current_season = "summer") {\n            float beta2 <- -90 + (beta + 90) * exp(-season.current_day / 100);\n            end <- base + {3 * cos(beta2) * cos(alpha), 3 * cos(beta2) * sin(alpha), 3 * sin(beta2)};\n        }\n\n    }\n\n}\n\nexperiment "Random" type: gui autorun: true {\n    output {\n        display \'Tree\' type: 3d background: season.sky_color axes: false toolbar: false fullscreen: true {\n            light #ambient intensity: 150;\n            rotation angle: cycle/1000000 dynamic: true;\n            camera #default location: {50.0,450,250} target: {50.0,50.0,40+80*(1-exp(-cycle/50000))} dynamic: true;\n            species branch aspect: default;\n            species leaf aspect: default;\n            species trunk aspect: default;\n            species plant_seed aspect: default;\n            species fruit aspect: default;\n        }\n\n    }\n\n}\n\nexperiment "4 simulations" type: gui autorun: true {\n\n    init {\n        create simulation number: 3  {\n            self.seed <- rnd(1000.0);\n        }\n    }\n\n    output {\n        display \'Tree\' type: 3d background: season.sky_color axes: false toolbar: false {\n            light #ambient intensity: 150;  \n            rotation angle: cycle/1000000 dynamic: true;\n            camera #default location: {50.0,450,250} target: {50.0,50.0,40+80*(1-exp(-cycle/50000))} dynamic: true;\n            species branch aspect: default;\n            species leaf aspect: default;\n            species trunk aspect: default;\n            species plant_seed aspect: default;\n            species fruit aspect: default;\n        }\n\n        layout #split toolbars: false tabs: false parameters: false consoles: false navigator: false controls: false tray: false;\n    }\n\n}\n\nexperiment L_Tri type: gui autorun: true {\n    float minimum_cycle_duration <- 0.0005;\n    float seed <- 0.05387546426306633;\n    output {\n        display \'Tree\' type: 3d background: season.sky_color axes: false toolbar: true {\n            light #ambient intensity: 150;\n            rotation angle: cycle/1000000 dynamic: true;\n            camera #default location: {50.0,450,250} target: {50.0,50.0,40+80*(1-exp(-cycle/50000))} dynamic: true;\n            species branch aspect: default;\n            species leaf aspect: default;\n            species trunk aspect: default;\n            species plant_seed aspect: default;\n            species fruit aspect: default;\n        }\n\n    }\n\n}\n\n')))}_.isMDXComponent=!0}}]);