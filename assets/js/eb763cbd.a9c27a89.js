"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[82089],{5811:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/types_hierarchy-bf9a542b1a3c6e2bb6ef50843afbdf34.png"},25889:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"DataTypes","title":"Types","description":"A variable\'s or expression\'s type (or data type) determines the values it can take, plus the operations that can be performed on or with it. GAML is a statically-typed language, which means that the type of an expression is always known at compile time, and is even enforced with casting operations.","source":"@site/versioned_docs/version-2025-06/DataTypes.md","sourceDirName":".","slug":"/DataTypes","permalink":"/wiki/DataTypes","draft":false,"unlisted":false,"editUrl":"https://github.com/gama-platform/gama/wiki/DataTypes/_edit","tags":[],"version":"2025-06","frontMatter":{"title":"Types"},"sidebar":"main","previous":{"title":"Statements","permalink":"/wiki/Statements"},"next":{"title":"File Types","permalink":"/wiki/FileTypes"}}');var s=t(74848),a=t(28453);const r={title:"Types"},l=void 0,o={},d=[{value:"Primitive built-in types",id:"primitive-built-in-types",level:2},{value:"bool",id:"bool",level:3},{value:"float",id:"float",level:3},{value:"int",id:"int",level:3},{value:"string",id:"string",level:3},{value:"Complex built-in types",id:"complex-built-in-types",level:2},{value:"agent",id:"agent",level:3},{value:"container",id:"container",level:3},{value:"conversation",id:"conversation",level:3},{value:"date",id:"date",level:3},{value:"field",id:"field",level:3},{value:"file",id:"file",level:3},{value:"geometry",id:"geometry",level:3},{value:"graph",id:"graph",level:3},{value:"list",id:"list",level:3},{value:"map",id:"map",level:3},{value:"matrix",id:"matrix",level:3},{value:"message",id:"message",level:3},{value:"pair",id:"pair",level:3},{value:"path",id:"path",level:3},{value:"point",id:"point",level:3},{value:"rgb",id:"rgb",level:3},{value:"species",id:"species",level:3},{value:"Species names as types",id:"species-names-as-types",level:3},{value:"topology",id:"topology",level:3},{value:"unknown",id:"unknown",level:3},{value:"Defining custom types",id:"defining-custom-types",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["A variable's or expression's ",(0,s.jsx)(n.em,{children:"type"})," (or ",(0,s.jsx)(n.em,{children:"data type"}),") determines the values it can take, plus the operations that can be performed on or with it. GAML is a statically-typed language, which means that the type of an expression is always known at compile time, and is even enforced with casting operations.\nThere are 4 categories of types:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"primitive types, declared as keyword in the language,"}),"\n",(0,s.jsx)(n.li,{children:"complex types, also declared as keyword in the language,"}),"\n",(0,s.jsx)(n.li,{children:"parametric types, a refinement of complex types (mainly children of container) that is dynamically constructed using an enclosing type, a contents type and a key type,"}),"\n",(0,s.jsx)(n.li,{children:"species types, dynamically constructed from the species declarations made by the modeler (and the built-in species present)."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The hierarchy of types in GAML (only primitive and complex types are displayed here, of course, as the other ones are model-dependent) is the following:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"images/types_hierarchy.png",src:t(5811).A+"",width:"727",height:"426"})}),"\n",(0,s.jsx)(n.h2,{id:"primitive-built-in-types",children:"Primitive built-in types"}),"\n",(0,s.jsx)(n.h3,{id:"bool",children:"bool"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," primitive datatype providing two values: ",(0,s.jsx)(n.code,{children:"true"})," or ",(0,s.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Litteral declaration:"})," both ",(0,s.jsx)(n.code,{children:"true"})," or ",(0,s.jsx)(n.code,{children:"false"})," are interpreted as boolean constants."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Other declarations:"})," expressions that require a boolean operand often directly apply a casting to bool to their operand. It is a convenient way to directly obtain a bool value."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"bool (0) -> false\n"})}),"\n",(0,s.jsx)(n.h3,{id:"float",children:"float"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," primitive datatype holding floating point values, its absolute value is comprised between 4.9E-324 and 1.8E308."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Comments:"})," this datatype is internally backed up by the Java double datatype."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Litteral declaration:"})," decimal notation 123.45 or exponential notation 123e45 are supported."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Other declarations:"})," expressions that require an integer operand often directly apply a casting to float to their operand. Using it is a way to obtain a float constant."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"float (12) -> 12.0\n"})}),"\n",(0,s.jsx)(n.h3,{id:"int",children:"int"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," primitive datatype holding integer values comprised between -2147483648 and 2147483647 (i.e. between ",(0,s.jsx)(n.code,{children:"-2^31"})," and ",(0,s.jsx)(n.code,{children:"2^31 - 1"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Comments:"})," this datatype is internally backed up by the Java int datatype."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Litteral declaration:"})," decimal notation like 1, 256790 or hexadecimal notation like #1209FF are automatically interpreted."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Other declarations:"})," expressions that require an integer operand often directly apply a casting to int to their operand. Using it is a way to obtain an integer constant."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"int (234.5) -> 234.\n"})}),"\n",(0,s.jsx)(n.h3,{id:"string",children:"string"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," a datatype holding a sequence of characters."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Comments:"})," this datatype is internally backed up by the Java String class. However, contrary to Java, strings are considered as a primitive type, which means they do not contain character objects. This can be seen when casting a string to a list using the list operator: the result is a list of one-character strings, not a list of characters."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Litteral declaration:"})," a sequence of characters enclosed in quotes, like 'this is a string' . If one wants to literally declare strings that contain quotes, one has to double these quotes in the declaration. Strings accept escape characters like ",(0,s.jsx)(n.code,{children:"\\n"})," (newline), ",(0,s.jsx)(n.code,{children:"\\r"})," (carriage return), ",(0,s.jsx)(n.code,{children:"\\t"})," (tabulation), as well as any Unicode character (",(0,s.jsx)(n.code,{children:"\\uXXXX"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Other declarations:"})," see string"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Example:"})," see ",(0,s.jsx)(n.a,{href:"OperatorsAA#strings-related-operators",children:"string operators"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"complex-built-in-types",children:"Complex built-in types"}),"\n",(0,s.jsx)(n.p,{children:"Contrarily to primitive built-in types, complex types have often various attributes. They can be accessed in the same way as attributes of agents:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"complex_type nom_var <- init_var;\nltype_attr attr_var <- nom_var.attr_name;\n"})}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'file fileText <- file("../data/cell.Data");\nbool fileTextReadable <- fileText.readable;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"agent",children:"agent"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," a generic datatype that represents an agent whatever its actual species."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Built-in attributes:"})," these attributes are common to any agent of the simulation","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"location (type = point): the location of the agent"}),"\n",(0,s.jsx)(n.li,{children:"shape (type = geometry): the shape of the agent"}),"\n",(0,s.jsx)(n.li,{children:"name (type = string): name of the agent (not necessarily unique in its population)"}),"\n",(0,s.jsx)(n.li,{children:"peers (type = list of agents of the same species): the population of agents of the same species, in the same host, minus the receiver agent"}),"\n",(0,s.jsx)(n.li,{children:"host (type = agent): the agent that hosts the population of the agent"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Comments:"})," This datatype is barely used since species name can be directly used as datatypes themselves."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Declaration:"})," the agent casting operator can be applied to any unknown object to cast it as an agent."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"container",children:"container"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," a generic datatype that represents a collection of data."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Comments:"}),"  a container variable can be a list, a matrix, a map... Conversely, each list, matrix, and map is a kind of container. In consequence, every container can be used in container-related operators."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"See also:"})," ",(0,s.jsx)(n.a,{href:"OperatorsAA#containers-related-operators",children:"Container operators"})]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Declaration:"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'container c  <- [1,2,3];\ncontainer c  <- matrix [[1,2,3],[4,5,6]];\ncontainer c  <- map ["x"::5, "y"::12];\ncontainer c  <- list species1;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"conversation",children:"conversation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," a datatype that represents a conversation between agents in a  FIPA-ACL interaction. It contains in particular all the exchanged messages."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Built-in attributes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"messages (type = list of messages): the list of messages that compose this conversation"}),"\n",(0,s.jsx)(n.li,{children:"protocol (type = string): the name of the protocol followed by the conversation"}),"\n",(0,s.jsx)(n.li,{children:"initiator (type = agent): the agent that has initiated this conversation"}),"\n",(0,s.jsx)(n.li,{children:"participants (type = list of agents): the list of agents that participate to this conversation"}),"\n",(0,s.jsx)(n.li,{children:"ended (type = bool): whether this conversation has ended or not"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"date",children:"date"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," a datatype that represents a date (day, month, year, and time). Any date variable can be created in the model. 2 built-in variables exist in a model: ",(0,s.jsx)(n.code,{children:"starting_date"})," (containing the date at the start of the simulation), ",(0,s.jsx)(n.code,{children:"current_date"})," (the date at the current step of the simulation, it is updated automatically from ",(0,s.jsx)(n.code,{children:"starting_date"}),", ",(0,s.jsx)(n.code,{children:"step"})," and ",(0,s.jsx)(n.code,{children:"time"}),"). In addition, the constant ",(0,s.jsx)(n.code,{children:"#now"})," contains the current (real) date. Many operators can be used on dates (such as ",(0,s.jsx)(n.code,{children:"+"}),", ",(0,s.jsx)(n.code,{children:"-"}),", ",(0,s.jsx)(n.code,{children:"add_years"}),"...)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Built-in attributes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"year (type = int): the year component of the date"}),"\n",(0,s.jsx)(n.li,{children:"month (type = int): the month component of the date (1-12)"}),"\n",(0,s.jsx)(n.li,{children:"day (type = int): the day component of the date (1-31)"}),"\n",(0,s.jsx)(n.li,{children:"hour (type = int): the number of hours in the current day of this date (0-23)"}),"\n",(0,s.jsx)(n.li,{children:"minute (type = int): the number of minutes in the current hour of this date (0-59)"}),"\n",(0,s.jsx)(n.li,{children:"second (type = int): the number of seconds in the current minute of this date (0-59)"}),"\n",(0,s.jsx)(n.li,{children:"day_of_year (type = int): the current day number in the year of this date (1-366)"}),"\n",(0,s.jsx)(n.li,{children:"day_of_week (type = int): the index of the day in the current week (with Monday being 1)"}),"\n",(0,s.jsx)(n.li,{children:"second_of_day (type = int): the index of seconds in the day of this date (0-86399)"}),"\n",(0,s.jsx)(n.li,{children:"minute_of_day (type = int): the index of the minute in the day of this date  (0-1439)"}),"\n",(0,s.jsx)(n.li,{children:"week_of_year (type = int): the index of the week in the current year (1-52)"}),"\n",(0,s.jsx)(n.li,{children:"days_in_month (type = int): the number of days in the current month of this date (28-31)"}),"\n",(0,s.jsx)(n.li,{children:"days_in_year (type = int): the number of days in the current year of this date (365-366)"}),"\n",(0,s.jsx)(n.li,{children:"leap (type = bool): returns true if the year is a leap year"}),"\n",(0,s.jsx)(n.li,{children:"date (type = date): returns a new date object with only the year-month-day components of this date"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Declaration:"})," a date can be created using different sets of information."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The simplest one consists in using a list of int values: [year, month of the year, day of the month, hour of the day, minute of the hour, second of the minute] or simply [year, month of the year, day of the month] (time is set to 0 in this case)."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"date my_date <- date([2010,3,23,17,30,10]); // the 23th of March 2010, at 17:30:10\ndate my_date2 <- date([2010,3,23]); // the 23th of March 2010, at 00:00:00\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Another way consists in using a string with the good format. The following one is perhaps the most complete, with year, month, day, hour, minute, second, and also the time zone."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'date my_date <- date("2010-3-23T17:30:10+07:00"); \n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"But the following ones can also be used:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'// without time zone:\nmy_date3 <- date("2010-03-23 17:30:10"); \n//Dates (without time)\nmy_date3 <- date("20100323");\nmy_date3 <- date("2010-03-23");\n// Dates using some patterns:\nmy_date3 <- date("03 23 2010","MM dd yyyy");\nmy_date3 <- date("01 23 20","HH mm ss");\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," date creation format has been defined in an ISO norm. More examples can be found here: ",(0,s.jsx)(n.a,{href:"https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns",children:"https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"See also"}),": ",(0,s.jsx)(n.a,{href:"OperatorsAA#date-related-operators",children:"Date operators"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"field",children:"field"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," Fields are two-dimensional matrices holding float values. They can be easily created from arbitrary sources (grid, raster or DEM files, matrices grids) and of course by hand. The values they hold are accessible by agents like grids are, using their current location. They can be the target of the 'diffuse' statement and can be displayed using the 'mesh' layer definition. As such, they represent a lightweight alternative to grids, as they hold spatialized discrete values without having to build agents, which can be particularly interesting for models with large raster data. Several fields can of course be defined, and it makes sense to define them in the global section as, for the moment, they cover by default the whole environment, exactly like grids, and are created alongside them."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Built-in attributes:"})," a field is a kind of matrix, it thus inherits from the matrix's attributes.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"dimension (type = point): the dimension (columns x rows) of the receiver matrix"}),"\n",(0,s.jsx)(n.li,{children:"columns (type = int): the number of columns of the receiver matrix"}),"\n",(0,s.jsx)(n.li,{children:"rows (type = int): the number of rows of the receiver matrix"}),"\n",(0,s.jsx)(n.li,{children:"cell_size (type = point): the dimension of an individual cell as a point (width, height). Setting it will only change the interpretation made by the field of the values it contains, but not the values themselves."}),"\n",(0,s.jsx)(n.li,{children:"bands (type = list of field): The list of bands that are optionally present in the field. The first band is the primary field itself, and each of these bands is a field w/o bands"}),"\n",(0,s.jsx)(n.li,{children:"no_data (type = float): the value that indicates the absence of data. Setting it will only change the interpretation made by the field of the values it contains, but not the values themselves."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"See also:"})," ",(0,s.jsx)(n.a,{href:"OperatorsAA#grid-related-operators",children:"Field operators"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Declaration:"})," a field can be created from a raster datafile (such as .asc of .tif files), a matrix or be specifying its dimensions.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"a field can be created from a raster datafile"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'// Initialize a field from a asc simple raster file\nfield field_from_asc <- field(grid_file("includes/grid.asc"));\n\n// initialize using a tiff raster file\nfield field_from_tiff  <-  field(grid_file("includes/Lesponne.tif"));\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"a field can be created manually:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// Init from a user defined matrix\nfield field_from_matrix  <- field(matrix([[1,2,3],[4,5,6],[7,8,9]]));\n\n//  init an empty field of a given size\nfield empty_field_from_size <- field(10,10);\n\n// init a field for of a given value\nfield full_field_from_size<- field(10,10,1.0);  \n\n// init a field of given size, with a given value and no data\nfield full_field_from_size_with_nodata <- field (1,1,1.0,0.0);\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"a field can be created from a grid of cells, the value stored will be the grid's grid_value attribute"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"global {\n  field field_from_grid <- field(matrix(cell));\n}\ngrid cell width: 100 height: 100 {\n  float grid_value <- rnd(1.0,self distance_to world.location);\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"file",children:"file"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," a datatype that represents a file."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Built-in attributes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"name (type = string): the name of the represented file (with its extension)"}),"\n",(0,s.jsx)(n.li,{children:"extension(type = string): the extension of the file"}),"\n",(0,s.jsxs)(n.li,{children:["path (type = string): the absolute path of the file","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"readable (type = bool, read-only): a flag expressing whether the file is readable"}),"\n",(0,s.jsx)(n.li,{children:"writable (type = bool, read-only): a flag expressing whether the file is writable"}),"\n",(0,s.jsx)(n.li,{children:"exists (type = bool, read-only): a flag expressing whether the file exists"}),"\n",(0,s.jsx)(n.li,{children:"is_folder (type = bool, read-only): a flag expressing whether the file is folder"}),"\n",(0,s.jsx)(n.li,{children:"contents (type = container): a container storing the content of the file"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Comments:"})," a variable with the ",(0,s.jsx)(n.code,{children:"file"})," type can handle any kind of file (text, image or shape files...). The type of the ",(0,s.jsx)(n.code,{children:"content"})," attribute will depend on the kind of file. Note that the allowed kinds of file are the followings:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["text files: files with the extensions .txt, .data, .csv, .text, .tsv, .asc. The ",(0,s.jsx)(n.code,{children:"content"})," is by default a list of string."]}),"\n",(0,s.jsxs)(n.li,{children:["image files: files with the extensions .pgm, .tif, .tiff, .jpg, .jpeg, .png, .gif, .pict, .bmp. The ",(0,s.jsx)(n.code,{children:"content"})," is by default a matrix of int."]}),"\n",(0,s.jsxs)(n.li,{children:["shapefiles: files with the extension .shp. The ",(0,s.jsx)(n.code,{children:"content"})," is by default a list of geometry."]}),"\n",(0,s.jsxs)(n.li,{children:["properties files: files with the extension .properties. The ",(0,s.jsx)(n.code,{children:"content"})," is by default a map of string::string."]}),"\n",(0,s.jsxs)(n.li,{children:["folders. The ",(0,s.jsx)(n.code,{children:"content"})," is by default a list of string."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Remark:"})," Files are also a particular kind of container and can thus be read, written or iterated using the container operators and commands."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"See also:"})," ",(0,s.jsx)(n.a,{href:"OperatorsAA#files-related-operators",children:"File operators"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Declaration:"})," a file can be created using the generic ",(0,s.jsx)(n.code,{children:"file"})," (that opens a file in read only mode and tries to determine its contents), ",(0,s.jsx)(n.code,{children:"folder"})," or the ",(0,s.jsx)(n.code,{children:"new_folder"})," (to open an existing folder or create a new one) unary operators. But things can be specialized with the combination of the ",(0,s.jsx)(n.code,{children:"read"}),"/",(0,s.jsx)(n.code,{children:"write"})," and ",(0,s.jsx)(n.code,{children:"image"}),"/",(0,s.jsx)(n.code,{children:"text"}),"/",(0,s.jsx)(n.code,{children:"shapefile"}),"/",(0,s.jsx)(n.code,{children:"properties"})," unary operators."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"folder(a_string)  // returns a file managing a existing folder\nfile(a_string) // returns any kind of file in read-only mode\nread(text(a_string)) // returns a text file in read-only mode\nread(image(a_string)) // does the same with an image file.\nwrite(properties(a_string)) // returns a property file which is available for writing \n                            // (if it exists, contents will be appended unless it is cleared \n                            // using the standard container operations).\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"geometry",children:"geometry"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," a datatype that represents a vector geometry, i.e. a list of georeferenced points."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Built-in attributes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"location (type = point): the centroid of the geometry"}),"\n",(0,s.jsx)(n.li,{children:"area (type = float): the area of the geometry"}),"\n",(0,s.jsx)(n.li,{children:"perimeter (type = float): the perimeter of the geometry"}),"\n",(0,s.jsx)(n.li,{children:"holes (type = list of geometry): the list of the hole inside the given geometry"}),"\n",(0,s.jsx)(n.li,{children:"contour (type = geometry): the exterior ring of the given geometry and of his holes"}),"\n",(0,s.jsx)(n.li,{children:"envelope (type = geometry): the geometry bounding box"}),"\n",(0,s.jsx)(n.li,{children:"width (type = float): the width of the bounding box"}),"\n",(0,s.jsx)(n.li,{children:"height (type = float): the height of the bounding box"}),"\n",(0,s.jsx)(n.li,{children:"points (type = list of point): the set of the points composing the geometry"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Comments:"})," a geometry can be either a point, a polyline or a polygon. Operators working on geometries handle transparently these three kinds of geometry. The envelope (a.k.a. the bounding box) of the geometry depends on the kind of geometry:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If this Geometry is the empty geometry, it is an empty point."}),"\n",(0,s.jsx)(n.li,{children:"If the Geometry is a point, it is a non-empty point."}),"\n",(0,s.jsx)(n.li,{children:"Otherwise, it is a Polygon whose points are (minx, miny), (maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny)."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"See also:"})," ",(0,s.jsx)(n.a,{href:"OperatorsAA#spatial-operators",children:"Spatial operators"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Declaration:"})," geometries can be built from a point, a list of points, or by using specific operators (circle, square, triangle...)."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"geometry varGeom <- circle(5);\ngeometry polygonGeom <- polygon([{3,5}, {5,6},{1,4}]);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"graph",children:"graph"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," a datatype that represents a graph composed of vertices linked by edges."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Built-in attributes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"edges(type = list of agent/geometry): the list of all edges"}),"\n",(0,s.jsx)(n.li,{children:"vertices(type = list of agent/geometry): the list of all vertices"}),"\n",(0,s.jsx)(n.li,{children:"circuit (type = path): an approximate minimal traveling salesman tour (hamiltonian cycle)"}),"\n",(0,s.jsx)(n.li,{children:"spanning_tree (type = list of agent/geometry): minimum spanning tree of the graph, i.e. a sub-graph such as every vertex lies in the tree, and as much edges lies in it but no cycles (or loops) are formed."}),"\n",(0,s.jsx)(n.li,{children:"connected(type = bool): test whether the graph is connected"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Remark:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"graphs are also a particular kind of container and can thus be manipulated using the container operators and commands."}),"\n",(0,s.jsx)(n.li,{children:"This algorithm used to compute the circuit requires that the graph be complete and the triangle inequality exists (if x,y,z are vertices then d(x,y)+d(y,z)>=d(x,z) for all x,y,z) then this algorithm will guarantee a hamiltonian cycle such that the total weight of the cycle is less than or equal to double the total weight of the optimal hamiltonian cycle."}),"\n",(0,s.jsx)(n.li,{children:"The computation of the spanning tree uses an implementation of the Kruskal's minimum spanning tree algorithm. If the given graph is connected it computes the minimum spanning tree, otherwise it computes the minimum spanning forest."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"See also:"})," ",(0,s.jsx)(n.a,{href:"OperatorsAA#graph-related-operators",children:"Graph operators"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Declaration:"})," graphs can be built from a list of vertices (agents or geometries) or from a list of edges (agents or geometries) by using specific operators. They are often used to deal with a road network and are built from a shapefile."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"create road from: shape_file_road;\ngraph the_graph <- as_edge_graph(road);\n\ngraph([1,9,5])        --: ([1: in[] + out[], 5: in[] + out[], 9: in[] + out[]], [])\ngraph([node(0), node(1), node(2)]      // if node is a species\ngraph(['a'::345, 'b'::13])  --:  ([b: in[] + out[b::13], a: in[] + out[a::345], 13: in[b::13] + out[], 345: in[a::345] + out[]], [a::345=(a,345), b::13=(b,13)])\ngraph(a_graph)  --: a_graph\ngraph(node1)    --: null\n"})}),"\n",(0,s.jsx)(n.h3,{id:"list",children:"list"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," a composite datatype holding an ordered collection of values."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Comments:"})," lists are more or less equivalent to instances of ArrayList in Java (although they are backed up by a specific class). They grow and shrink as needed, can be accessed via an index (see @ or index_of), support set operations (like union and difference), and provide the modeller with a number of utilities that make it easy to deal with collections of agents (see, for instance, shuffle, reverse,where,sort_by,...)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Remark:"})," lists can contain values of any datatypes, including other lists. Note, however, that due to limitations in the current parser, lists of lists cannot be declared literally; they have to be built using assignments. Lists are also a particular kind of container and can thus be manipulated using the container operators and commands."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Litteral declaration:"})," a set of expressions separated by commas, enclosed in square brackets, like [12, 14, 'abc', self]. An empty list is noted ",(0,s.jsx)(n.code,{children:"[]"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Other declarations:"})," lists can be built literally from a point, or a string, or any other element by using the list casting operator."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"list (1) -> [1]\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"list<int> myList <- [1,2,3,4]; \nmyList[2] => 3\n"})}),"\n",(0,s.jsx)(n.h3,{id:"map",children:"map"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," a composite datatype holding an ordered collection of pairs (a key, and its associated value)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Built-in attributes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"keys (type = list): the list of all keys"}),"\n",(0,s.jsx)(n.li,{children:"values (type = list): the list of all values"}),"\n",(0,s.jsx)(n.li,{children:"pairs (type = list of pairs): the list of all pairs key::value"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Comments:"})," maps are more or less equivalent to instances of Hashtable in Java (although they are backed up by a specific class)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Remark:"})," maps can contain values of any datatypes, including other maps or lists. Maps are also a particular kind of container and can thus be manipulated using the container operators and commands."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Litteral declaration:"})," a set of pair expressions separated by commas, enclosed in square brackets; each pair is represented by a key and a value separated by ",(0,s.jsx)(n.code,{children:"::"}),". An example of map is ",(0,s.jsx)(n.code,{children:"[agentA::'big', agentB::'small', agentC::'big']"}),". An empty map is noted ",(0,s.jsx)(n.code,{children:"[]"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Other declarations:"})," lists can be built literally from a point, or a string, or any other element by using the map casting operator."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"map (1) -> [1::1]\nmap ({1,5}) -> [x::1, y::5]\n[]   // empty map \n"})}),"\n",(0,s.jsx)(n.h3,{id:"matrix",children:"matrix"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," a composite datatype that represents either a two-dimension array (matrix) or a one-dimension array (vector), holding any type of data (including other matrices)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Built-in attributes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"dimension (type = point): the dimension (columns x rows) of the receiver matrix"}),"\n",(0,s.jsx)(n.li,{children:"columns (type = int): the number of columns of the receiver matrix"}),"\n",(0,s.jsx)(n.li,{children:"rows (type = int): the number of rows of the receiver matrix"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Comments:"})," Matrices are fixed-size structures that can be accessed by index (point for two-dimension matrices, integer for vectors)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Litteral declaration:"})," Matrices cannot be defined literally. One-dimension matrices can be built by using the matrix casting operator applied on a list. Two-dimensions matrices need to be declared as variables first, before being filled."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'//builds a one-dimension matrix, of size 5\nmatrix mat1 <- matrix ([10, 20, 30, 40, 50]);\n//  builds a two-dimensions matrix with 10 columns and 5 rows, where each cell is initialized to 0.0\nmatrix mat2 <- 0.0 as_matrix({10,5}); \n// builds a two-dimensions matrix with 2 columns and 3 rows, with initialized cells\nmatrix mat3 <- matrix([["c11","c12","c13"],["c21","c22","c23"]]);     \n    -> c11;c21\n       c12;c22\n       c13;c23\n'})}),"\n",(0,s.jsx)(n.h3,{id:"message",children:"message"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," a datatype containing a message (sent during a communication, such as the one sent/received in a FIPA interaction)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Built-in attributes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"contents (type = unknown): the contents of this message, as a list of arbitrary objects"}),"\n",(0,s.jsx)(n.li,{children:"sender (type = unknown): the sender that has sent this message"}),"\n",(0,s.jsx)(n.li,{children:"unread (type = bool): whether this message is unread or not"}),"\n",(0,s.jsx)(n.li,{children:"emission_timestamp (type = int): the emission time stamp of this message (I.e. at what cycle it has been emitted)"}),"\n",(0,s.jsx)(n.li,{children:"recention_timestamp (type = int): the reception time stamp of this message (I.e. at what cycle it has been received)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"pair",children:"pair"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," a datatype holding a key and its associated value."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Built-in attributes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"key (type = unknown, read-only): the key of the pair, i.e. the first element of the pair"}),"\n",(0,s.jsx)(n.li,{children:"value (type = unknown, read-only): the value of the pair, i.e. the second element of the pair"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Remark:"})," pairs are also a particular kind of container and can thus be manipulated using container operators and commands."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Litteral declaration:"})," a pair is defined by a key and a value separated by ",(0,s.jsx)(n.code,{children:"::"}),". The type of the key and value can also be specified."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'pair testPair <- "key"::56;\npair<string,int> pairWithType <- "tot"::23;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"path",children:"path"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," a datatype representing a path linking two agents or geometries in a graph."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Built-in attributes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"source (type = point): the source point, i.e. the first point of the path"}),"\n",(0,s.jsx)(n.li,{children:"target (type = point): the target point, i.e. the last point of the path"}),"\n",(0,s.jsx)(n.li,{children:"graph (type = graph): the current topology (in the case it is a spatial graph), null otherwise"}),"\n",(0,s.jsx)(n.li,{children:"edges (type = list of agents/geometries): the edges of the graph composing the path"}),"\n",(0,s.jsx)(n.li,{children:"vertices (type = list of agents/geometries): the vertices of the graph composing the path"}),"\n",(0,s.jsx)(n.li,{children:"segments (type = list of geometries): the list of the geometries composing the path"}),"\n",(0,s.jsx)(n.li,{children:"shape (type = geometry) : the global geometry of the path (polyline)"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Comments:"})," the path created between two agents/geometries or locations will strongly depend on the topology in which it is created."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Remark:"})," a path is ",(0,s.jsx)(n.strong,{children:"immutable"}),", i.e. it can not be modified after it is created."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Declaration:"})," paths are very barely defined literally. We can nevertheless use the ",(0,s.jsx)(n.code,{children:"path"})," unary operator on a list of points to build a path. Operators dedicated to the computation of paths (such as path_to or path_between) are often used to build a path."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"path([{1,5},{2,9},{5,8}]) // a path from {1,5} to {5,8} through {2,9}\n       \ngeometry rect <- rectangle(5);\ngeometry poly <- polygon([{10,20},{11,21},{10,21},{11,22}]);\npath pa <- rect path_to poly;  // built a path between rect and poly, in the topolopy   \n                               // of the current agent (i.e. a line in a& continuous topology, \n                               // a path in a graph  in a graph topology )\n\na_topology path_between a_container_of_geometries // idem with an explicit topology and the possibility \n                                                  // to have more than 2 geometries \n                                                  // (the path is then built incrementally)\n\n\npath_between (a_graph, a_source, a_target) // idem with a the given graph as topology\n\n"})}),"\n",(0,s.jsx)(n.h3,{id:"point",children:"point"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," a datatype normally holding two positive float values. Represents the absolute coordinates of agents in the model."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Built-in attributes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"x (type = float): coordinate of the point on the x-axis"}),"\n",(0,s.jsx)(n.li,{children:"y (type = float): coordinate of the point on the y-axis"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Comments:"})," point coordinates should be positive, if a negative value is used in its declaration, the point is built with the absolute value."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Remark:"})," points are particular cases of geometries and containers. Thus they have also all the built-in attributes of both the geometry and the container datatypes and can be used with every kind of operator or command admitting geometry and container."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Litteral declaration:"})," two numbers, separated by a comma, enclosed in braces, like {12.3, 14.5}"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Other declarations:"})," points can be built literally from a list, or from an integer or float value by using the point casting operator."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"point ([12,123.45]) -> {12.0, 123.45} \npoint (2) -> {2.0, 2.0}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"rgb",children:"rgb"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," a datatype that represents a color in the RGB space."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Built-in attributes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"red(type = int): the red component of the color"}),"\n",(0,s.jsx)(n.li,{children:"green(type = int): the green component of the color"}),"\n",(0,s.jsx)(n.li,{children:"blue(type = int): the blue component of the color"}),"\n",(0,s.jsx)(n.li,{children:"darker(type = rgb): a new color that is a darker version of this color"}),"\n",(0,s.jsx)(n.li,{children:"brighter(type = rgb): a new color that is a brighter version of this color"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Remark:"})," rgb is also a particular kind of container and can thus be manipulated using the container operators and commands."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Litteral declaration:"})," there exist a lot of ways to declare a color. We use the ",(0,s.jsx)(n.code,{children:"rgb"})," casting operator applied to:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"a string. The allowed color names are the constants defined in the Color Java class, i.e.: black, blue, cyan, darkGray, lightGray, gray, green, magenta, orange, pink, red, white, yellow."}),"\n",(0,s.jsx)(n.li,{children:"a list. The integer value associated to the three first elements of the list are used to define the three red (element 0 of the list), green (element 1 of the list) and blue (element 2 of the list) components of the color."}),"\n",(0,s.jsx)(n.li,{children:'a map. The red, green, blue components take the value associated to the keys "r", "g", "b" in the map.'}),"\n",(0,s.jsx)(n.li,{children:"an integer <- the decimal integer is translated into a hexadecimal <- OxRRGGBB. The red (resp. green, blue) component of the color takes the value RR (resp. GG, BB) translated in decimal."}),"\n",(0,s.jsxs)(n.li,{children:["Since GAMA 1.6.1, colors can be directly obtained like units, by using the \xb0 or # symbol followed by the name in lowercase of one of the 147 CSS colors (see ",(0,s.jsx)(n.a,{href:"http://www.cssportal.com/css3-color-names/",children:"http://www.cssportal.com/css3-color-names/"}),")."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Declaration:"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'rgb cssRed <- #red;   // Since 1.6.1\nrgb testColor <- rgb(\'white\');                 // rgb [255,255,255]\nrgb test <- rgb(3,5,67);                     // rgb [3,5,67]\nrgb te <- rgb(340);                            // rgb [0,1,84]\nrgb tete <- rgb(["r"::34, "g"::56, "b"::345]); // rgb [34,56,255]\n'})}),"\n",(0,s.jsx)(n.h3,{id:"species",children:"species"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Definition: a generic datatype that represents a species"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Built-in attributes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"topology (type=topology): the topology is which lives the population of agents"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:'Comments: this datatype is actually a "meta-type". It allows to manipulate (in a rather limited fashion, however) the species themselves as any other values.'}),"\n",(0,s.jsx)(n.li,{children:"Litteral declaration: the name of a declared species is already a literal declaration of species."}),"\n",(0,s.jsx)(n.li,{children:"Other declarations: the species casting operator, or its variant called species_of can be applied to an agent in order to get its species."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"species-names-as-types",children:"Species names as types"}),"\n",(0,s.jsx)(n.p,{children:"Once a species has been declared in a model, it automatically becomes a datatype. This means that:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"It can be used to declare variables, parameters or constants,"}),"\n",(0,s.jsx)(n.li,{children:"It can be used as an operand to commands or operators that require species parameters,"}),"\n",(0,s.jsx)(n.li,{children:"It can be used as a casting operator (with the same capabilities as the built-in type agent)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'In the simple following example, we create a set of "humans" and initialize a random "friendship network" among them. See how the name of the species, human, is used in the create command, as an argument to the list casting operator, and as the type of the variable named friend.'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"global {\n    init {\n         create human number: 10;\n         ask human {\n               friend <- one_of (human - self);\n         }\n     }\n}\n\nspecies human {\n    human friend <- nil;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"topology",children:"topology"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," a topology is basically on neighborhoods, distance,... structures in which agents evolves. It is the environment or the context in which all these values are computed. It also provides the access to the spatial index shared by all the agents. And it maintains a (eventually dynamic) link with the 'environment' which is a geometrical border."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Built-in attributes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"places(type = container): the collection of places (geometry) defined by this topology."}),"\n",(0,s.jsx)(n.li,{children:"environment(type = geometry): the environment of this topology (i.e. the geometry that defines its boundaries)"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Comments:"})," the attributes ",(0,s.jsx)(n.code,{children:"places"})," depends on the kind of the considered topology.  For continuous topologies, it is a list with their environment. For discrete topologies, it can be any of the container supporting the inclusion of geometries (list, graph, map, matrix)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Remark:"})," There exist various kinds of topology: continuous topology and discrete topology (e.g. grid, graph...)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Declaration:"})," To create a topology, we can use the ",(0,s.jsx)(n.code,{children:"topology"})," unary casting operator applied to:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"an agent: returns a continuous topology built from the agent's geometry"}),"\n",(0,s.jsx)(n.li,{children:"a species name: returns the topology defined for this species population"}),"\n",(0,s.jsx)(n.li,{children:"a geometry: returns a continuous topology built on this geometry"}),"\n",(0,s.jsx)(n.li,{children:"a geometry container (list, map, shapefile): returns an half-discrete (with corresponding places), half-continuous topology (to compute distances...)"}),"\n",(0,s.jsx)(n.li,{children:"a geometry matrix (i.e. a grid): returns a grid topology which computes specifically neighborhood and distances"}),"\n",(0,s.jsx)(n.li,{children:"a geometry graph: returns a graph topology which computes specifically neighborhood and distances\nMore complex topologies can also be built using dedicated operators, e.g. to decompose a geometry..."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"unknown",children:"unknown"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Definition:"})," a wildcard type representing any values whose specific type cannot be determined at compile time. Acts as a placeholder for any GAMA type when the actual type is unresolved or generic."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Comment:"})," The ",(0,s.jsx)(n.code,{children:"unknown"})," type functions as GAMA's wildcard type, quite similarly to ",(0,s.jsx)(n.code,{children:"?"})," in Java generics. It's mainly used internally when the type system encounters generic parameters, untyped Java objects, or returned values that could be of any type."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-gaml",children:'global {\n\tunknown aBool <- true;\n\tunknown aGeometry <- circle(5);\n\t\n\tunknown aFunction {\n\t\treturn flip(0.5) ? "a string" : 42;\n\t}\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"defining-custom-types",children:"Defining custom types"}),"\n",(0,s.jsx)(n.p,{children:'Sometimes, besides the species of agents that compose the model, it can be necessary to declare custom datatypes. Species serve this purpose as well, and can be seen as "classes" that can help to instantiate simple "objects". In the following example, we declare a new kind of "object", bottle, that lacks the skills habitually associated with agents (moving, visible, etc.), but can nevertheless group together attributes and behaviors within the same closure. The following example demonstrates how to create the species:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"species bottle {\n    float volume <- 0.0 max:1 min:0.0;\n    bool is_empty -> {volume = 0.0};\n    action fill {\n         volume <- 1.0;\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"How to use this species to create new bottles:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"create bottle {\n    volume <- 0.5;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"And how to use bottles as any other agent in a species (a drinker owns a bottle; when he gets thirsty, it drinks a random quantity from it; when it is empty, it refills it):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"species drinker {\n     ...\n    bottle my_bottle<- nil;\n    float quantity <- rnd (100) / 100;\n    bool thirsty <- false update: flip (0.1);\n    ...\n    action drink {\n         if condition: ! bottle.is_empty {\n              bottle.volume <-bottle.volume - quantity;\n              thirsty <- false;\n         }\n    }\n    ...\n    init {\n          create bottle return: created_bottle;\n              volume <- 0.5;\n          }\n          my_bottle <- first(created_bottle);\n    }\n    ...\n    reflex filling_bottle when: bottle.is_empty {\n         ask  my_bottle {\n              do fill;\n         }\n    }\n    ...\n    reflex drinking when: thirsty {\n         do drink;\n    }\n}\n"})})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var i=t(96540);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);