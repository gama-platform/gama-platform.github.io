"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[87851],{3905:(n,e,t)=>{t.d(e,{Zo:()=>p,kt:()=>g});var r=t(67294);function o(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function i(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){o(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function s(n,e){if(null==n)return{};var t,r,o=function(n,e){if(null==n)return{};var t,r,o={},a=Object.keys(n);for(r=0;r<a.length;r++)t=a[r],e.indexOf(t)>=0||(o[t]=n[t]);return o}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(r=0;r<a.length;r++)t=a[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(o[t]=n[t])}return o}var c=r.createContext({}),l=function(n){var e=r.useContext(c),t=e;return n&&(t="function"==typeof n?n(e):i(i({},e),n)),t},p=function(n){var e=l(n.components);return r.createElement(c.Provider,{value:e},n.children)},d="mdxType",m={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},u=r.forwardRef((function(n,e){var t=n.components,o=n.mdxType,a=n.originalType,c=n.parentName,p=s(n,["components","mdxType","originalType","parentName"]),d=l(t),u=o,g=d["".concat(c,".").concat(u)]||d[u]||m[u]||a;return t?r.createElement(g,i(i({ref:e},p),{},{components:t})):r.createElement(g,i({ref:e},p))}));function g(n,e){var t=arguments,o=e&&e.mdxType;if("string"==typeof n||o){var a=t.length,i=new Array(a);i[0]=u;var s={};for(var c in e)hasOwnProperty.call(e,c)&&(s[c]=e[c]);s.originalType=n,s[d]="string"==typeof n?n:o,i[1]=s;for(var l=2;l<a;l++)i[l]=t[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},9136:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>p,contentTitle:()=>c,default:()=>g,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var r=t(87462),o=t(63366),a=(t(67294),t(3905)),i=["components"],s={"^title":"Agent Based Clustering"},c=void 0,l={unversionedId:"Agent_Based_Clustering",id:"Agent_Based_Clustering",title:"Agent_Based_Clustering",description:"Path: Library models/Toy Models/Learning/models/Mas KMeans.gaml",source:"@site/../docs/Agent_Based_Clustering.md",sourceDirName:".",slug:"/Agent_Based_Clustering",permalink:"/wiki/next/Agent_Based_Clustering",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/Agent_Based_Clustering/_edit",tags:[],version:"current",frontMatter:{"^title":"Agent Based Clustering"}},p={},d=[],m={toc:d},u="wrapper";function g(n){var e=n.components,t=(0,o.Z)(n,i);return(0,a.kt)(u,(0,r.Z)({},m,t,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("img",{width:"960",alt:"Annotation 2023-04-16 045308_kMEANS",src:"https://user-images.githubusercontent.com/4437331/232264009-7ebc282c-2652-418c-a8ae-4390945d9edb.png"}),(0,a.kt)("p",null,"Path: Library models/Toy Models/Learning/models/Mas KMeans.gaml"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'\n/**\n* Name: Agent Based Clustering\n* Author: Jean-Danie Zucker with Patrick Taillandier\'s and Arnaud Grignard\'s Help\n* Description: This model displays the step to stpe algorithm of k-means\n* See for  https://en.wikipedia.org/wiki/K-means_clustering ...\n* Clustering\n* The k-medoid could be added\n* To be added stop the simulation when convergence is reached\n* To be added an overlay\n* To be added position the points at the begining usug user interaction model...\n*/\nmodel MASKMEANS\n\n\nglobal\n{\n// the number of classes to create (kmeans)\n// It corresponds to the centroids\n    int k ;\n    // the number of points\n    int N ;\n    //number of dimensions\n    int dimensions <- 2;\n    float globalIntraDistance <- 0.0;\n    bool converged <- false;\n    font regular <- font("Helvetica", 14, # bold);\n    init\n    {\n        //create datapoints agents\n        create datapoints number: N\n        {\n            if (dimensions = 3)\n            {\n                location <- { rnd(100), rnd(100), rnd(100) };\n            }\n\n            if (dimensions = 2)\n            {\n                location <- { rnd(100), rnd(100) };\n            }\n\n        }\n        //create centroid agents\n        create centroids number: k\n        {\n            if (dimensions = 3)\n            {\n                location <- { rnd(100), rnd(100), rnd(100) };\n            }\n\n            if (dimensions = 2)\n            {\n                location <- { rnd(100), rnd(100) };\n            }\n\n        }\n        int K <- length(centroids);\n        if (K > 0) {loop i from:0 to: K-1 { ask centroids[i] { color_kmeans  <- hsb(i/K,1,1); }}}\n                    \n                    \n            //give a random color to each centroid (i.e. to each datapoints agents of the group)\n            //      loop c over: centroids { rgb col <- rnd_color(255); ask c { color_kmeans <- col;}}\n        \n    \n    }\n    \n    reflex pauseAtConvergence when: converged { do pause;\n        \n    }\n    reflex assign_points_to_centroid when: even(cycle)\n    {\n        // The "assignment" step is also referred to as expectation step,\n        ask centroids\n        {\n            mypoints <- list<datapoints> ([]);\n        }\n\n        loop pt over: datapoints\n        {\n            ask pt\n            {\n                if not empty(centroids) {\n                    mycenter <- centroids closest_to self;\n                    color_kmeans <- mycenter.color_kmeans;\n                    add self to: mycenter.mypoints;\n                }\n            }\n\n        }\n\n    }\n\n    reflex update_centroids when: not even(cycle)\n    {\n    // the "update step" as maximization step,\n    // making this algorithm a variant of the generalized expectation-maximization algorithm.\n\n    //We give a random color to each group (i.e. to each datapoints agents of the group)\n        ask centroids where (not empty(each.mypoints))\n        {\n            location <- mean(mypoints collect each.location);\n            float oldist <- myIntraDistance;\n            myIntraDistance <- mypoints sum_of (each distance_to self);\n            converged <- (oldist-myIntraDistance) with_precision(2) = 0;\n        }\n        \n        globalIntraDistance <- centroids sum_of (each.myIntraDistance);\n    }\n\n}\n\nspecies datapoints\n{\n    rgb color_kmeans <- rgb(225,225,225)    ;\n    centroids mycenter;\n    aspect kmeans_aspect2D\n    {\n        draw circle(2) color: color_kmeans border:color_kmeans-25;\n    }\n\n    aspect kmeans_aspect3D\n    {\n        draw sphere(2) color: color_kmeans ;\n    }\n\n}\n\nspecies centroids\n{\n    rgb color_kmeans <-  rgb(225,225,225);\n    list<datapoints> mypoints;\n    float myIntraDistance <- 0.0;\n    aspect kmeans_aspect2D\n    {\n        // explicitly loops over a copy of the points to avoid concurrency issues with the simulation\n        loop pt over: copy(mypoints)\n        {\n            draw line([location, pt]) + 0.1 color: color_kmeans;\n        }\n        draw cross(3, 0.5) color: color_kmeans border:color_kmeans-25;\n    }\n\n    aspect kmeans_aspect3D\n    {\n        loop pt over: mypoints\n        {\n            draw line([location, pt], 0.2) color: color_kmeans;\n        }\n        draw cube(5) color: color_kmeans border: # black;\n        \n    }\n\n}\n\nexperiment clustering2D type: gui\n{\n    parameter "Number of clusters to split the data into" var: k init:4 category: "KMEANS";\n    parameter "Number of points to be clustered" var: N init: 500;\n    \n        \n    point target <- { 20, 95 };\n    output\n    {\n        \n        display map_kmeans \n        {\n\n            graphics "Full target"\n            {\n                draw rectangle(120, 4) color: # yellow  at: { 50, 2 };\n                draw rectangle(120, 4) color: # yellow at: target + { 30, 2 };\n                if (not even(cycle))\n                {\n                // the "update step" as maximization step, (a mean is done to recenter)\n                    if ! (globalIntraDistance = 0) {\n                        draw "Current step was an estimation Step (each point is assigned the color of his nearest centroid" at:{ 12, 2 } font: regular color: # green;\n                        draw "Current sum of cluster intra-distance " + globalIntraDistance with_precision(1)  at:{ 12, 4 } font: regular color: # black;\n                        }\n                    if converged {draw "Algorithm has converged !" + " cycle "+ cycle at:{ 60, 4 } font: regular color: # red;}\n                    draw "Next step is a maximisation step the centroid will move to the center of its  associated points" at: target + { 0, 3 } font: regular color: # red;\n                } else\n                {\n                    if ! (globalIntraDistance = 0) {\n                        draw "Current step was a maximisation step the centroid moved to the center of its associated points" at: { 12, 2 } font: regular color: # red;\n                        draw "Current sum of cluster intra-distance " + globalIntraDistance with_precision(1)  at:{ 12, 4 } font: regular color: # black;\n                        }\n                    if converged {draw "Algorithm has converged !"  at:{ 60, 4 } font: regular color: # red;}\n                    draw "Next step is an estimation Step (each point is assigned the color of his nearest centroid" at: target + { 0, 3 } font: regular color: # green;\n                }\n\n            }\n            species datapoints aspect: kmeans_aspect2D transparency:0.4;\n            species centroids aspect: kmeans_aspect2D;\n\n        }\n\n    }\n}\n\nexperiment clustering3D type: gui \n{\n    parameter "Number of clusters to split the data into" var: k init:4 min: 0 max: 10 category: "KMEANS";\n    parameter "Number of points to be clustered" var: N init:1000 ;\n    parameter "Number of dimensions (2D or 3D)" var: dimensions init: 3 min: 2 max: 3;\n    font regular <- font("Helvetica", 14, # bold);\n    point target <- { 20, 95 };\n    \n    // The display is explicitly synchronized to avoid concurrency issues (if the points are changed in the simulation while being displayed)\n    output synchronized: true\n    {\n        display map_kmeans type: 3d\n        {\n            species datapoints aspect: kmeans_aspect3D transparency:0.4;\n            species centroids aspect: kmeans_aspect3D;\n        }\n\n    }\n\n}\n\n')))}g.isMDXComponent=!0}}]);