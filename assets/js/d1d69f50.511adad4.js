"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[49825],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=i.createContext({}),s=function(e){var t=i.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=s(e.components);return i.createElement(p.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),u=s(n),m=a,f=u["".concat(p,".").concat(m)]||u[m]||c[m]||o;return n?i.createElement(f,l(l({ref:t},d),{},{components:n})):i.createElement(f,l({ref:t},d))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,l=new Array(o);l[0]=m;var r={};for(var p in t)hasOwnProperty.call(t,p)&&(r[p]=t[p]);r.originalType=e,r[u]="string"==typeof e?e:a,l[1]=r;for(var s=2;s<o;s++)l[s]=n[s];return i.createElement.apply(null,l)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},32474:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>p,default:()=>f,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var i=n(87462),a=n(63366),o=(n(67294),n(3905)),l=["components"],r={title:"2. Definition of monitors and chart outputs"},p=void 0,s={unversionedId:"LuneraysFlu_step2",id:"LuneraysFlu_step2",title:"2. Definition of monitors and chart outputs",description:"This second step illustrates how to create monitors and charts to follows the evolution of variables and to add an ending condition to the simulation.",source:"@site/../docs/LuneraysFlu_step2.md",sourceDirName:".",slug:"/LuneraysFlu_step2",permalink:"/wiki/next/LuneraysFlu_step2",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/LuneraysFlu_step2/_edit",tags:[],version:"current",frontMatter:{title:"2. Definition of monitors and chart outputs"},sidebar:"tuto",previous:{title:"1. Creation of a first basic disease spreading model",permalink:"/wiki/next/LuneraysFlu_step1"},next:{title:"3. Importation of GIS data",permalink:"/wiki/next/LuneraysFlu_step3"}},d={},u=[{value:"Formulation",id:"formulation",level:2},{value:"Model Definition",id:"model-definition",level:2},{value:"global section",id:"global-section",level:3},{value:"global variables",id:"global-variables",level:4},{value:"Ending condition",id:"ending-condition",level:4},{value:"experiment",id:"experiment",level:3},{value:"monitor",id:"monitor",level:4},{value:"Chart",id:"chart",level:4},{value:"Complete Model",id:"complete-model",level:2}],c={toc:u},m="wrapper";function f(e){var t=e.components,r=(0,a.Z)(e,l);return(0,o.kt)(m,(0,i.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This second step illustrates how to create monitors and charts to follows the evolution of variables and to add an ending condition to the simulation."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Result of the Luneray Flu model 2.",src:n(76938).Z,width:"3584",height:"2118"})),(0,o.kt)("h2",{id:"formulation"},"Formulation"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Add three new global dynamic variables to follow the evolution of the number of infected people agents, of not infected people agents and of the rate of infected people."),(0,o.kt)("li",{parentName:"ul"},"Define an ending condition for the simulation"),(0,o.kt)("li",{parentName:"ul"},"Define a monitor to follow the rate of infected people agents"),(0,o.kt)("li",{parentName:"ul"},"Define a chart to follow the rate of infected people agents")),(0,o.kt)("h2",{id:"model-definition"},"Model Definition"),(0,o.kt)("h3",{id:"global-section"},"global section"),(0,o.kt)("h4",{id:"global-variables"},"global variables"),(0,o.kt)("p",null,"GAMA offers the possibility to define a dynamic variable that will be recomputed at each simulation step by using the ",(0,o.kt)("em",{parentName:"p"},"update")," facet when defining a variable. When an agent is activated, first, it recomputes each of its variables with an update facet (in their definition order), then it activates each of its reflexes (in their definition order)."),(0,o.kt)("p",null,"To better follow the evolution of sick people, we add three new global variables to the model:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"nb_people_infected")," of type ",(0,o.kt)("inlineCode",{parentName:"li"},"int")," with ",(0,o.kt)("inlineCode",{parentName:"li"},"nb_infected_init")," as init value and updated at each simulation step by the number of infected people"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"nb_people_not_infected")," of type ",(0,o.kt)("inlineCode",{parentName:"li"},"int")," with ",(0,o.kt)("inlineCode",{parentName:"li"},"(nb_people - nb_infected_init)")," as init value and updated at each simulation step by the number of not infected people"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"infected_rate")," of type ",(0,o.kt)("inlineCode",{parentName:"li"},"float")," updated at each simulation step by the number of infected people divided by the number of people.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"global{\n    //... other attributes\n    int nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n    int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n    float infected_rate update: nb_people_infected/nb_people;\n    //... init\n}\n")),(0,o.kt)("p",null,"We used the ",(0,o.kt)("a",{parentName:"p",href:"Operators#count"},"count")," operator that allows to count the number of elements of a list for which the left condition is true. The keyword ",(0,o.kt)("inlineCode",{parentName:"p"},"each")," represents each element of the list."),(0,o.kt)("h4",{id:"ending-condition"},"Ending condition"),(0,o.kt)("p",null,"The simplest way to add an ending condition to a model is to add a global reflex that is activated at the end of the simulation that will pause the simulation (use of the ",(0,o.kt)("inlineCode",{parentName:"p"},"pause")," global action)."),(0,o.kt)("p",null,"In our model, we add a new reflex called ",(0,o.kt)("inlineCode",{parentName:"p"},"end_simulation")," that will be activated when the infected rate is 1.0 (i.e. all the people agents are infected) and that will apply the ",(0,o.kt)("inlineCode",{parentName:"p"},"pause")," action. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"global {\n    //.. variable and init definition\n    \n    reflex end_simulation when: infected_rate = 1.0 {\n    do pause;\n    }\n} \n")),(0,o.kt)("h3",{id:"experiment"},"experiment"),(0,o.kt)("h4",{id:"monitor"},"monitor"),(0,o.kt)("p",null,"GAMA provides modelers with the possibility to define ",(0,o.kt)("a",{parentName:"p",href:"DefiningMonitorsAndInspectors#monitors"},"monitors"),". A monitor allows to follow the value of an arbitrary expression in GAML. It will appear, in the User Interface, in a small window on its own and be recomputed every time step (or according to its ",(0,o.kt)("inlineCode",{parentName:"p"},"refresh")," facet). "),(0,o.kt)("p",null,"Definition of a monitor:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"value"),": mandatory, the expression whose value will be displayed by the monitor."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"refresh"),": bool, optional: if the expression is true, compute (default is true).")),(0,o.kt)("p",null,"For our model, we define a monitor to follow the value of the ",(0,o.kt)("inlineCode",{parentName:"p"},"infected_rate")," variable:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'experiment main_experiment type:gui{\n    //...parameters\n    output {\n    monitor "Infected people rate" value: infected_rate;\n        \n        //...display\n    }\n}\n')),(0,o.kt)("h4",{id:"chart"},"Chart"),(0,o.kt)("p",null,"In GAMA, ",(0,o.kt)("a",{parentName:"p",href:"DefiningCharts"},"charts")," are considered as a display layer.\nGAMA can display 3 main types of charts using the ",(0,o.kt)("inlineCode",{parentName:"p"},"type")," facet:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"histogram")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"pie")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"series"),"/",(0,o.kt)("inlineCode",{parentName:"li"},"xy"),"/",(0,o.kt)("inlineCode",{parentName:"li"},"scatter"),": both display series with lines or dots, with 3 subtypes :",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"series"),": to display the evolution of one/several variables (vs time or not)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"xy"),": to specify both x and y value. To allow stacked plots, only one y value for each x value."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"scatter"),": free x and y values for each series.")))),(0,o.kt)("p",null,"In our model, we define a new display called ",(0,o.kt)("inlineCode",{parentName:"p"},"chart_display")," that will be refreshed every 10 simulation steps. In this display, we add a series chart with 2 layers of data:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"susceptible: the number of people that are not infected (in green)"),(0,o.kt)("li",{parentName:"ul"},"infected: the number of people that are infected (in red)")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'experiment main_experiment type:gui{\n    //...parameters\n    output {\n    //...display and monitors\n        \n    display chart_display refresh:every(10 #cycles) {\n        chart "Disease spreading" type: series {\n        data "susceptible" value: nb_people_not_infected color: #green;\n        data "infected" value: nb_people_infected color: #red;\n        }\n    }\n    }\n}\n')),(0,o.kt)("h2",{id:"complete-model"},"Complete Model"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-gaml",metastring:"reference",reference:!0},"https://github.com/gama-platform/gama/blob/GAMA_1.9.0/msi.gama.models/models/Tutorials/Luneray%20flu/models/model2.gaml\n")))}f.isMDXComponent=!0},76938:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/luneray2-d7f412ead5661b8799825f22b62982ac.png"}}]);