"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[83228],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>g});var i=n(67294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,i,l=function(e,t){if(null==e)return{};var n,i,l={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var p=i.createContext({}),s=function(e){var t=i.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=s(e.components);return i.createElement(p.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,l=e.mdxType,a=e.originalType,p=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),u=s(n),m=l,g=u["".concat(p,".").concat(m)]||u[m]||c[m]||a;return n?i.createElement(g,o(o({ref:t},d),{},{components:n})):i.createElement(g,o({ref:t},d))}));function g(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var a=n.length,o=new Array(a);o[0]=m;var r={};for(var p in t)hasOwnProperty.call(t,p)&&(r[p]=t[p]);r.originalType=e,r[u]="string"==typeof e?e:l,o[1]=r;for(var s=2;s<a;s++)o[s]=n[s];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8062:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>p,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var i=n(87462),l=n(63366),a=(n(67294),n(3905)),o=["components"],r={title:"6. Multi-Level"},p=void 0,s={unversionedId:"IncrementalModel_step6",id:"version-1.8.2-RC2/IncrementalModel_step6",title:"6. Multi-Level",description:"This step illustrates how to define a multi-level model.",source:"@site/versioned_docs/version-1.8.2-RC2/IncrementalModel_step6.md",sourceDirName:".",slug:"/IncrementalModel_step6",permalink:"/wiki/IncrementalModel_step6",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/IncrementalModel_step6/_edit",tags:[],version:"1.8.2-RC2",frontMatter:{title:"6. Multi-Level"},sidebar:"tuto",previous:{title:"5. Visualizing in 3D",permalink:"/wiki/IncrementalModel_step5"},next:{title:"7. Differential Equations",permalink:"/wiki/IncrementalModel_step7"}},d={},u=[{value:"Formulation",id:"formulation",level:2},{value:"Model Definition",id:"model-definition",level:2},{value:"building",id:"building",level:3},{value:"global variables",id:"global-variables",level:3},{value:"Complete Model",id:"complete-model",level:2}],c={toc:u};function m(e){var t=e.components,r=(0,l.Z)(e,o);return(0,a.kt)("wrapper",(0,i.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This step illustrates how to define a multi-level model."),(0,a.kt)("h2",{id:"formulation"},"Formulation"),(0,a.kt)("p",null,"We propose to let the buildings manage what happens when the people are inside buildings. In this context, we will use the multi-level properties of GAMA: when a people agent will be inside a building, it will be captured by it and its species will be modified. It will be not anymore the people agent that will decide when to leave the building, but the building itself that will release it."),(0,a.kt)("p",null,"We will need to:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Define a micro-species of people inside the building species (",(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"people_in_building")),")."),(0,a.kt)("li",{parentName:"ul"},"Define two new behaviors for building: ",(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"let_people_leave"))," and ",(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"let_people_enter")),"."),(0,a.kt)("li",{parentName:"ul"},"Modify the aspect of the building."),(0,a.kt)("li",{parentName:"ul"},"Modify some global variables for counting the number of infected people.")),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Incremental model 6: application of multi-level modeling.",src:n(15532).Z,width:"1612",height:"831"})),(0,a.kt)("h2",{id:"model-definition"},"Model Definition"),(0,a.kt)("h3",{id:"building"},"building"),(0,a.kt)("p",null,"First, we define a new species called ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"people_in_building"))," inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"building")," species. Thus, a building could have agents of this species as ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"members"))," and control them. The ",(0,a.kt)("inlineCode",{parentName:"p"},"people_in_building")," species has for parent the ",(0,a.kt)("inlineCode",{parentName:"p"},"people")," species, which means that a ",(0,a.kt)("inlineCode",{parentName:"p"},"people_in_building")," agent has all the attributes, aspects and behaviors of a ",(0,a.kt)("inlineCode",{parentName:"p"},"people")," agent."),(0,a.kt)("p",null,"In our case, we want a people agent inside a building does not do anything. Thus, we use the ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"schedules"))," facet of the species to remove the ",(0,a.kt)("inlineCode",{parentName:"p"},"people_in_building")," from the scheduler."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"species building {\n    ...\n    species people_in_building parent: people schedules: [] {\n    }\n    ...\n}\n")),(0,a.kt)("p",null,"We define a first ",(0,a.kt)("inlineCode",{parentName:"p"},"reflex")," for the buildings that will be activated at each simulation step and that will allow the building to capture all the people that are inside its geometry and that are not moving (",(0,a.kt)("inlineCode",{parentName:"p"},"target = nil"),"). Capturing agents means putting them inside its ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"members"))," list and changing their species: here the ",(0,a.kt)("inlineCode",{parentName:"p"},"people")," agents become ",(0,a.kt)("inlineCode",{parentName:"p"},"people_in_building")," agents."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"species building {\n    ...\n    reflex let_people_enter {\n    capture (people inside self where (each.target = nil)) as: people_in_building;\n    }\n    ....\n}\n")),(0,a.kt)("p",null,"We define a second reflex for the buildings that will be activated at each simulation step and that will allow the building to release some of the ",(0,a.kt)("inlineCode",{parentName:"p"},"people_in_building")," agents. First, it increments the staying counter of all the ",(0,a.kt)("inlineCode",{parentName:"p"},"people_in_building")," agents. Then it builds the list of leaving people by testing the same probability as before for all the ",(0,a.kt)("inlineCode",{parentName:"p"},"people_in_building")," agents. Finally, if this list is not empty, it releases them as ",(0,a.kt)("inlineCode",{parentName:"p"},"people")," agents (and gives them a new target point)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"species building {\n    ...\n    reflex let_people_leave {\n    ask people_in_building {\n        staying_counter <- staying_counter + 1;\n    }\n\n    release people_in_building where (flip(each.staying_counter / staying_coeff)) as: people in: world {\n        target <- any_location_in(one_of(building));\n    }\n    }\n    ....\n}\n")),(0,a.kt)("p",null,"At last, we refine the aspect of the buildings: if there are no people inside the building, we draw it with gray color. If the number of ",(0,a.kt)("inlineCode",{parentName:"p"},"people_in_building")," infected is higher than the number of ",(0,a.kt)("inlineCode",{parentName:"p"},"people_in_building")," not infected, we draw it in red; otherwise in green. The number of infected ",(0,a.kt)("inlineCode",{parentName:"p"},"people_in_building")," and its total number will be computed once a step (through the ",(0,a.kt)("inlineCode",{parentName:"p"},"update")," facet of ",(0,a.kt)("inlineCode",{parentName:"p"},"building")," attribute)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"species building {\n    int nb_infected <- 0 update: self.people_in_building count each.is_infected;\n    int nb_total <- 0 update: length(self.people_in_building);\n\n    aspect default {\n    draw shape color: nb_total = 0 ? #gray : (float(nb_infected) / nb_total > 0.5 ? #red : #green) border: #black depth: height;\n    }\n}\n\n")),(0,a.kt)("h3",{id:"global-variables"},"global variables"),(0,a.kt)("p",null,"In order to take into account the people that are inside the buildings for the computation of ",(0,a.kt)("inlineCode",{parentName:"p"},"nb_people_infected"),", we first build the list of ",(0,a.kt)("inlineCode",{parentName:"p"},"people_in_building"),". As ",(0,a.kt)("inlineCode",{parentName:"p"},"people_in_building")," is microspecies of ",(0,a.kt)("inlineCode",{parentName:"p"},"building"),", we cannot compute it directly like for the other species, we then aggregate all the list ",(0,a.kt)("inlineCode",{parentName:"p"},"people_in_building")," of all building in a single list (",(0,a.kt)("inlineCode",{parentName:"p"},"list_people_in_buildings"),"). Then, we compute the number of infected people as the number of people infected outside the building + the number of people infected inside them."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"global  {\n    ...\n    list<people_in_building> list_people_in_buildings update: (building accumulate each.people_in_building);\n    int nb_people_infected <- nb_infected_init update: (people + list_people_in_buildings) count (each.is_infected);\n    ...\n}\n")),(0,a.kt)("h2",{id:"complete-model"},"Complete Model"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gaml",metastring:"reference",reference:!0},"https://github.com/gama-platform/gama/blob/GAMA_1.8.2/msi.gama.models/models/Tutorials/Incremental%20Model/models/Incremental%20Model%206.gaml\n")))}m.isMDXComponent=!0},15532:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/Incremental_model6-b8cc74623e015e8a3c3250562171e774.jpg"}}]);