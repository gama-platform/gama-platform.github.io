"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[12445],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>h});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=n.createContext({}),s=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=s(e.components);return n.createElement(p.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=s(a),c=r,h=m["".concat(p,".").concat(c)]||m[c]||d[c]||i;return a?n.createElement(h,o(o({ref:t},u),{},{components:a})):n.createElement(h,o({ref:t},u))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=c;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[m]="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=a[s];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},85192:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>p,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>m});var n=a(87462),r=a(63366),i=(a(67294),a(3905)),o=["components"],l={title:"Basic programming concepts in GAML"},p=void 0,s={unversionedId:"BasicProgrammingConceptsInGAML",id:"version-1.8.1/BasicProgrammingConceptsInGAML",title:"Basic programming concepts in GAML",description:"[//]: # (startConcept|programming_basis)",source:"@site/versioned_docs/version-1.8.1/BasicProgrammingConceptsInGAML.md",sourceDirName:".",slug:"/BasicProgrammingConceptsInGAML",permalink:"/wiki/1.8.1/BasicProgrammingConceptsInGAML",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/BasicProgrammingConceptsInGAML/_edit",tags:[],version:"1.8.1",frontMatter:{title:"Basic programming concepts in GAML"},sidebar:"side",previous:{title:"Organization of a model",permalink:"/wiki/1.8.1/ModelOrganization"},next:{title:"Manipulate basic species",permalink:"/wiki/1.8.1/ManipulateBasicSpecies"}},u={},m=[{value:"Index",id:"index",level:2},{value:"Variables",id:"variables",level:2},{value:"Basic types",id:"basic-types",level:3},{value:"The point type",id:"the-point-type",level:3},{value:"A world about dimensions",id:"a-world-about-dimensions",level:3},{value:"Declare variables using facet",id:"declare-variables-using-facet",level:2},{value:"Operators in GAMA",id:"operators-in-gama",level:2},{value:"Mathematical operators",id:"mathematical-operators",level:3},{value:"Logical operators",id:"logical-operators",level:3},{value:"Comparison operators",id:"comparison-operators",level:3},{value:"Type casting operators",id:"type-casting-operators",level:3},{value:"Other operators",id:"other-operators",level:3},{value:"Conditional structures",id:"conditional-structures",level:2},{value:"Loop",id:"loop",level:2},{value:"Manipulate containers",id:"manipulate-containers",level:2},{value:"Random values",id:"random-values",level:2}],d={toc:m},c="wrapper";function h(e){var t=e.components,a=(0,r.Z)(e,o);return(0,i.kt)(c,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In this part, we will focus on the very basic structures in GAML, such as how to declare a variable, how to use loops, or how to manipulate lists.\nWe will overfly quickly all those basic programming concepts, admitting that you already have some basics in coding."),(0,i.kt)("h2",{id:"index"},"Index"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#variables"},"Variables"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#basic-types"},"Basic types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#the-point-type"},"The point type")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#a-word-about-dimensions"},"A word about dimensions")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#declare-variables-using-facet"},"Declare variables using facet")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#operators-in-gama"},"Operators in GAMA"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#logical-operators"},"Logical operators")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#comparison-operators"},"Comparison operators")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#type-casting-operators"},"Type casting operators")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#other-operators"},"Other operators")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#conditional-structures"},"Conditional structures")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#loop"},"Loop")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#manipulate-containers"},"Manipulate containers")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#random-values"},"Random values"))),(0,i.kt)("h2",{id:"variables"},"Variables"),(0,i.kt)("p",null,"Variables are declared very easily in GAML, starting with the keyword for ",(0,i.kt)("a",{parentName:"p",href:"DataTypes"},"the type"),", following by the name you want for your variable.\nNB: The declaration has to be inside the ",(0,i.kt)("inlineCode",{parentName:"p"},"global"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"experiment"),", or the ",(0,i.kt)("inlineCode",{parentName:"p"},"species")," scope."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"typeName myVariableName;\n")),(0,i.kt)("h3",{id:"basic-types"},"Basic types"),(0,i.kt)("p",null,'All the "basic" types are present in GAML:',(0,i.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"float"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," (see ",(0,i.kt)("a",{parentName:"p",href:"DataTypes"},"the data type page")," for information about all the available datatype).\nThe operator for the affectation in GAML is ",(0,i.kt)("inlineCode",{parentName:"p"},"<-")," (the operator ",(0,i.kt)("inlineCode",{parentName:"p"},"=")," is used to test the equality)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"int integerVariable <- 3;\nfloat floatVariable <- 2.5;\nstring stringVariable <- \"test\"; // you can also write simple ' : <- 'test'\nbool booleanVariable <- true; // or false\n")),(0,i.kt)("p",null,"To follow the behavior of a variable, we can ",(0,i.kt)("inlineCode",{parentName:"p"},"write")," their value in the console. Let's go back to our basic skeleton of a model, and let's create a reflex in the global scope (to be short, a reflex is a procedure that is executed in each step. We will ",(0,i.kt)("a",{parentName:"p",href:"DefiningActionsAndBehaviors"},"come back to this concept later"),"). The ",(0,i.kt)("inlineCode",{parentName:"p"},"write")," statement works very easily, simply writing down the keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"write")," and the name of the variable we want to be displayed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"model firstModel\n\nglobal {\n    int integerVariable <- 3;\n    float floatVariable <- 2.5;\n    string stringVariable <- \"test\"; // you can also write simple ' : <- 'test'\n    bool booleanVariable <- true; // or false\n    \n    reflex writeDebug {\n     write integerVariable;\n     write floatVariable;\n     write stringVariable;\n     write booleanVariable;\n    }\n}\n\nexperiment myExperiment {}\n")),(0,i.kt)("p",null,"The statement ",(0,i.kt)("inlineCode",{parentName:"p"},"write")," is overloaded for each type of variable (even for the more complex type, such as containers)."),(0,i.kt)("p",null,"Note that before being initialized, a variable has the value ",(0,i.kt)("inlineCode",{parentName:"p"},"nil"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'reflex update {\n    string my_string;\n    write my_string; // this will write "nil".\n    int my_int;\n    write my_int; // this will write "0", which is the default value for int.\n}\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"nil")," is also a literal you can use to initialize your variables (you can learn more about the concept of literal in this ",(0,i.kt)("a",{parentName:"p",href:"Literals"},"page"),")."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'reflex update {\n    string my_string <- "a string";\n    my_string <- nil;\n    write my_string; // this will write "nil".\n    int my_int <- 6;\n    my_int <- nil;\n    write my_int; // this will write "0", which is the default value for int.\n}\n')),(0,i.kt)("h3",{id:"the-point-type"},"The point type"),(0,i.kt)("p",null,"Another variable type you should know is the ",(0,i.kt)("inlineCode",{parentName:"p"},"point")," type. This type of variable is used to describe coordinates. It is in fact a complex variable, composed of two float variables (or three if you are working in 3D). To declare it, you have to use the curly bracket ",(0,i.kt)("inlineCode",{parentName:"p"},"{"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"point p <- {0.2,2.4};\n")),(0,i.kt)("p",null,"The first field is related to the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," value, and the second one to the ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," value. You can easily get this value as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"point p <- {0.2,2.4};\nwrite p.x; // the output will be 0.2\nwrite p.y; // the output will be 2.4\n")),(0,i.kt)("p",null,"You cannot modify directly the value. But if you want, you can do a simple operation to get what you want:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"point p <- {0.2,2.4};\np <- p + {0.0,1.0};\nwrite p.y; // the output will be 3.4\n")),(0,i.kt)("h3",{id:"a-world-about-dimensions"},"A world about dimensions"),(0,i.kt)("p",null,"When manipulating float values, you can specify the dimension (also ",(0,i.kt)("a",{parentName:"p",href:"UnitsAndConstants"},"called unit"),") of your value. Dimensions are preceded by # or \xb0 (exactly the same)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"float a <- 5\xb0m;\nfloat b <- 4#cm;\nfloat c <- a + b; // c is equal to 5.0399999 (it's not equal to 5.04 because it is a float value, not as precise as int)\n")),(0,i.kt)("h2",{id:"declare-variables-using-facet"},"Declare variables using facet"),(0,i.kt)("p",null,"Facets are used to describe the behavior of a variable during its declaration, by adding the keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"facet")," just after the variable name, followed by the value you want for the facet (or also just after the initial value). See ",(0,i.kt)("a",{parentName:"p",href:"Statements#variable_number"},"the page related to the variable declaration for all the facets"),". "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"type variableName <- initialValue facet1:valueForFacet1 facet2:valueForFacet2;\n// or:\ntype variableName facet1:valueForFacet1 facet2:valueForFacet2;\nvariableName <- initialValue;\n")),(0,i.kt)("p",null,"You can use the facet ",(0,i.kt)("inlineCode",{parentName:"p"},"update")," if you want the value of your variable to change at every simulation step. For example, to increment your integer variable each step, you can do as follow:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'int integerVariable <- 3 min: 0 max: 10 update: integerVariable+1;\n// nb: the operator "++" doesn\'t exist in gaml.\n')),(0,i.kt)("p",null,"You can use the facets ",(0,i.kt)("inlineCode",{parentName:"p"},"min")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"max")," to constraint the value in a specific range of values:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"int integerVariable <- 3 min: 0 max: 10 update: integerVariable+1;\n// the result will be 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - 10 - 10 - ...\n")),(0,i.kt)("p",null,"The facet ",(0,i.kt)("inlineCode",{parentName:"p"},"among")," can also be useful (that can be seen as an enum):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'string fruits <- "banana" among: ["pear","apple","banana"];\n')),(0,i.kt)("h2",{id:"operators-in-gama"},"Operators in GAMA"),(0,i.kt)("p",null,"In GAML language, you can use a lot of different operators. ",(0,i.kt)("strong",{parentName:"p"},"An operator is a function, i.e. a way to get the result of a computation.")," All of them are listed in this ",(0,i.kt)("a",{parentName:"p",href:"Exhaustive-list-of-GAMA-Keywords"},"page"),", but here are the most useful ones:"),(0,i.kt)("h3",{id:"mathematical-operators"},"Mathematical operators"),(0,i.kt)("p",null,"The basic arithmetical operators, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"+"),"(add), ",(0,i.kt)("inlineCode",{parentName:"p"},"-"),"(substract), ",(0,i.kt)("inlineCode",{parentName:"p"},"*"),"(multiply), ",(0,i.kt)("inlineCode",{parentName:"p"},"/"),"(divide), ",(0,i.kt)("inlineCode",{parentName:"p"},"^"),"(power) are used this way: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// FirstOperand BinaryOperator SecondOperand \n//   --\x3e ex: 5 * 3; // return 15\n\nint fif <- 5 * 3;\n")),(0,i.kt)("p",null,"Some other operators, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"cos"),"(cosinus), ",(0,i.kt)("inlineCode",{parentName:"p"},"sin"),"(sinus), ",(0,i.kt)("inlineCode",{parentName:"p"},"tan"),"(tangent), ",(0,i.kt)("inlineCode",{parentName:"p"},"sqrt"),"(square root), ",(0,i.kt)("inlineCode",{parentName:"p"},"round"),"(rounding) etc... are used this way:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// UnaryOperator(Operand) \n//   --\x3e ex: sqrt(49); // return 7.0\n\nfloat sq <- sqrt(49);\n")),(0,i.kt)("h3",{id:"logical-operators"},"Logical operators"),(0,i.kt)("p",null,"Logical operators such as ",(0,i.kt)("inlineCode",{parentName:"p"},"and"),"(and), ",(0,i.kt)("inlineCode",{parentName:"p"},"or"),"(inclusive or) are used the same way as basic arithmetical operators. The operator ",(0,i.kt)("inlineCode",{parentName:"p"},"!"),"(negation) has to be placed just before the operand. They return a boolean result."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// FirstOperand Operator SecondOperand \n//   --\x3e ex: true or false; // return true\n\n// NegationOperator Operand \n//   --\x3e ex: !(true or false); // return false\n")),(0,i.kt)("h3",{id:"comparison-operators"},"Comparison operators"),(0,i.kt)("p",null,"The comparison operators ",(0,i.kt)("inlineCode",{parentName:"p"},"!="),"(different than), ",(0,i.kt)("inlineCode",{parentName:"p"},"<"),"(smaller than), ",(0,i.kt)("inlineCode",{parentName:"p"},"<="),"(smaller of equal), ",(0,i.kt)("inlineCode",{parentName:"p"},"="),"(equal), ",(0,i.kt)("inlineCode",{parentName:"p"},">"),"(bigger than), ",(0,i.kt)("inlineCode",{parentName:"p"},">="),"(bigger or equal) are used the same way as basic arithmetical operators:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// FirstOperand Operator SecondOperand \n//   --\x3e ex: 5 < 3; // return false\n\nbool cmp <- 5 < 3;\n")),(0,i.kt)("h3",{id:"type-casting-operators"},"Type casting operators"),(0,i.kt)("p",null,"You can cast an operand to a special type using casting operator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Operator(Operand); \n//  --\x3e ex: int(2.1); // return 2\n\nint intTwo <- int(2.1);\n")),(0,i.kt)("h3",{id:"other-operators"},"Other operators"),(0,i.kt)("p",null,"A lot of other operators exist in GAML. The standard way to use those operators is as followed:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Operator(FirstOperand,SecondOperand,...) --\x3e ex: rnd(1,8);\n")),(0,i.kt)("p",null,"Some others are used in a more intuitive way:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"FirstOperand Operator SecondOperand --\x3e ex: 2[6,4,5] contains(5);\n")),(0,i.kt)("h2",{id:"conditional-structures"},"Conditional structures"),(0,i.kt)("p",null,"You can write conditionals with ",(0,i.kt)("a",{parentName:"p",href:"Statements#if"},"if/else")," in GAML:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'if (integerVariable<0) {\n    write "my value is negative !! The exact value is " + integerVariable;\n}\nelse if (integerVariable>0) {\n    write "my value is positive !! The exact value is " + integerVariable;\n}\nelse if (integerVariable=0) {\n    write "my value is equal to 0 !!";\n}\nelse {\n    write "hey... This is not possible, right ?";\n}\n')),(0,i.kt)("p",null,"GAML also accepts ternary operator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'stringVariable <- (booleanVariable) ? "booleanVariable = true" : "booleanVariable = false";\n')),(0,i.kt)("h2",{id:"loop"},"Loop"),(0,i.kt)("p",null,"Loops in GAML are designed by the ",(0,i.kt)("a",{parentName:"p",href:"Statements#loop"},"keyword ",(0,i.kt)("inlineCode",{parentName:"a"},"loop")),". As for variables, a loop have multiple facets to determine its behavior:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The facet ",(0,i.kt)("inlineCode",{parentName:"li"},"times"),", to repeat a fixed number of times a set of statements:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'loop times: 2 {\n    write "helloWorld";\n} \n// the output will be helloWorld - helloWorld\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The facet ",(0,i.kt)("inlineCode",{parentName:"li"},"while"),", to repeat a set of statements while a condition is true:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"loop while: true {\n}\n// infinity loop\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The facet ",(0,i.kt)("inlineCode",{parentName:"li"},"from")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"to"),", to repeat a set of statements while an index iterates over a range of values with a fixed step of 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"loop i from: 0 to: 5 { \n    write i;\n}\n// the output will be 0 - 1 - 2 - 3 - 4 - 5\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The facet ",(0,i.kt)("inlineCode",{parentName:"li"},"from")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"to")," combine with the facet ",(0,i.kt)("inlineCode",{parentName:"li"},"step")," to choose the step:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"loop i from: 0 to: 5 step: 2 {\n    write i;\n}\n// the output will be 0 - 2 - 4\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The facet ",(0,i.kt)("inlineCode",{parentName:"li"},"over")," to browse containers, as we will see in the next part.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"loop i over: [0, 2, 4] {\n    write i;\n}\n// the output will be 0 - 2 - 4\n")),(0,i.kt)("p",null,"Nb: you can interrupt a loop at any time by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"break")," statement."),(0,i.kt)("h2",{id:"manipulate-containers"},"Manipulate containers"),(0,i.kt)("p",null,'We saw in the previous parts "simple" types of variable. You also have multiple containers types, such as list, matrix, map, pair... In this section, we will only focus on the container ',(0,i.kt)("inlineCode",{parentName:"p"},"list")," (you can learn the other by reading the ",(0,i.kt)("a",{parentName:"p",href:"DataTypes#complex-built-in-types"},"section about datatypes"),")."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"How to declare a list?")),(0,i.kt)("p",null,"To declare a list, you can either or not specify the type of the data of its elements:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'list<int> listOfInt <- [5,4,9,8];\nlist listWithoutType <- [2,4.6,"oij",["hoh",0.0]];\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"How to know the number of elements of a list?")),(0,i.kt)("p",null,"To know the number of elements of a list, you can use the operator ",(0,i.kt)("inlineCode",{parentName:"p"},"length")," that returns the number of elements (note that this operator also works with strings)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'int numberOfElements <- length([12,13]); // will return 2\nint numberOfElements <- length([]); // will return 0\nint numberOfElements <- length("stuff"); // will return 5\n')),(0,i.kt)("p",null,"There is another operator, ",(0,i.kt)("inlineCode",{parentName:"p"},"empty"),", that returns you a boolean telling you if the list is empty or not."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'bool isEmpty <- empty([12,13]); // will return false\nbool isEmpty <- empty([]); // will return true\nbool isEmpty <- empty("stuff"); // will return false\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"How to get an element from a list?")),(0,i.kt)("p",null,"To get an element from a list by its index, you have to use the operator ",(0,i.kt)("inlineCode",{parentName:"p"},"at"),' (nb: it is indeed an operator and not a facet, so no ":" after the keyword).'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"int theFirstElementOfTheList <- [5,4,9,8] at 0; // this will return 5\nint theThirdElementOfTheList <- [5,4,9,8] at 2; // this will return 9\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"How to know the index of an element of a list?")),(0,i.kt)("p",null,"You can know the index of the first occurrence of a value in a list using the operator ",(0,i.kt)("inlineCode",{parentName:"p"},"index_of"),".\nYou can know the index of the last occurrence of a value in a list using the operator ",(0,i.kt)("inlineCode",{parentName:"p"},"last_index_of"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"int result <- [4,2,3,4,5,4] last_index_of 4;  // result equals 5\nint result <- [4,2,3,4,5,4] index_of 4;  // result equals 0\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"How to know if an element exists in a list?")),(0,i.kt)("p",null,"You can use the operator ",(0,i.kt)("inlineCode",{parentName:"p"},"contains")," (return a boolean):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"bool result <- [{1,2}, {3,4}, {5,6}] contains {3,4};  // result equals true\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"How to insert/remove an element to/from a list?")),(0,i.kt)("p",null,"For those operation, you can use dedicated statements. The statements ",(0,i.kt)("inlineCode",{parentName:"p"},"add")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"put")," are used to insert/modify an element, while the statement ",(0,i.kt)("inlineCode",{parentName:"p"},"remove")," is used to remove an element. Here are some examples of how to use those 3 statements with the most common facets:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"list<int> list_int <- [1,5,7,6,7];\n\nremove from:list_int index:1; // remove the 2nd element of the list\nwrite list_int; // the output is : [1,7,6,7]\nremove item:7 from:list_int; // remove the 1st occurrence of 7\nwrite list_int; // the output is : [1,6,7]\n\nadd item:9 to: list_int at: 2; // add 9 in the 3rd position\nwrite list_int; // the output is : [1,6,9,7]\nadd 0 to: list_int; // add 0 in the last position\nwrite list_int; // the output is : [1,6,9,7,0]\n\nput 3 in: list_int at: 0; // put 3 in the 1st position\nwrite list_int; // the output is : [3,6,9,7,0]\nput 2 in: list_int key: 2; // put 2 in the 3rd position\nwrite list_int; // the output is : [3,6,2,7,0]\n")),(0,i.kt)("p",null,"Note that the ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"-")," operators can be used to add an element at the end of a list and to remove the last element of a list:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"list<int> list_int <- [1,5,7,6,7];\n\nlist_int <- list_int + 8;\nwrite list_int;  // the output is : [1,5,7,6,7,8]\nlist_int <- list_int - 7;\nwrite list_int;  // the output is : [1,5,7,6,8]\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"How to add 2 lists?")),(0,i.kt)("p",null,"You can add 2 lists by creating a third one and browsing the 2 first one, but you can do it much easily by using the operator ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," : "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"list<int> list_int1 <- [1,5,7,6,7];\nlist<int> list_int2 <- [6,9];\nlist<int> list_int_result <- list_int1 + list_int2;\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"How to browse a list?")),(0,i.kt)("p",null,"You can use the facet ",(0,i.kt)("inlineCode",{parentName:"p"},"over")," of a loop:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"list<int> exampleOfList <- [4,2,3,4,5,4];\nloop i over: exampleOfList {\n    write i;\n}\n// the output will be 4 - 2 - 3 - 4 - 5 - 4\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"How to filter a list?")),(0,i.kt)("p",null,"If you want to get all the elements of a list that fulfill a particular condition, you need the operator where. In the condition, you can design all the elements of a particular list by using the pseudo-variable ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"each"))," as followed:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"list<int> exampleOfList <- [4,2,3,4,5,4] where (each <= 3); \n// the list is now [2,3]\n")),(0,i.kt)("p",null,"Other useful operators for the manipulation of lists:"),(0,i.kt)("p",null,"Here are some other operators which can be useful to manipulate lists: ",(0,i.kt)("inlineCode",{parentName:"p"},"sort"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"sort_by"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"shuffle"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"reverse"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"collect"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"accumulate"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"among"),". Please read the GAML Reference if you want to know more about those operators."),(0,i.kt)("h2",{id:"random-values"},"Random values"),(0,i.kt)("p",null,"When you will implement your model, you will have to manipulate some random values quite often. "),(0,i.kt)("p",null,"To get a random value in a range of value, use the operator ",(0,i.kt)("a",{parentName:"p",href:"OperatorsNR#rnd"},(0,i.kt)("inlineCode",{parentName:"a"},"rnd")),". You can use this operator in many ways:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"int var0 <- rnd (2);    // var0 equals 0, 1 or 2\nfloat var1 <- rnd (1000) / 1000;    // var1 equals a float between 0 and 1 with a precision of 0.001\nfloat var2 <- rnd(3.4);     // var4 equals a random float between 0.0 and 3.4\npoint var3 <- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}, 1);    // var2 equals a point with x = 2.0, y equal to 2.0, 3.0 or 4.0 and z between 0.0 and 10.0 every 1.0\nfloat var4 <- rnd (2.0, 4.0, 0.5);  // var3 equals a float number between 2.0 and 4.0 every 0.5\nint var5 <- rnd (2, 4);     // var7 equals 2, 3 or 4\nint var6 <- rnd (2, 12, 4);     // var5 equals 2, 6 or 10\npoint var7 <- rnd ({2.5,3, 0.0});   // var6 equals {x,y} with x in [0.0,2.0], y in [0.0,3.0], z = 0.0\npoint var8 <- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0});   // var8 equals a point with x = 2.0, y between 2.0 and 4.0 and z between 0.0 and 10.0\nfloat var9 <- rnd (2.0, 4.0);   // var9 equals a float number between 2.0 and 4.0\n")),(0,i.kt)("p",null,"Use the operator ",(0,i.kt)("a",{parentName:"p",href:"OperatorsDH#flip"},(0,i.kt)("inlineCode",{parentName:"a"},"flip"))," if you want to pick a boolean value with a certain probability:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"bool result <- flip(0.2); // result will have 20% of chance to be true\n")),(0,i.kt)("p",null,"You can use randomness in list, by using the operator ",(0,i.kt)("a",{parentName:"p",href:"OperatorsSZ#shuffle"},(0,i.kt)("inlineCode",{parentName:"a"},"shuffle")),", or also by using the operator ",(0,i.kt)("a",{parentName:"p",href:"OperatorsAA#among"},(0,i.kt)("inlineCode",{parentName:"a"},"among"))," to pick randomly one (or several) element of your list:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"list TwoRandomValuesFromTheList <- 2 among [5,4,9,8];\n// the list will be for example [5,9].\n")),(0,i.kt)("p",null,"You can use probabilistic laws, using operators such as ",(0,i.kt)("a",{parentName:"p",href:"OperatorsDH#gauss"},(0,i.kt)("inlineCode",{parentName:"a"},"gauss")),", ",(0,i.kt)("a",{parentName:"p",href:"OperatorsNR#poisson"},(0,i.kt)("inlineCode",{parentName:"a"},"poisson")),", ",(0,i.kt)("a",{parentName:"p",href:"OperatorsBC#binomial"},(0,i.kt)("inlineCode",{parentName:"a"},"binomial")),", or ",(0,i.kt)("a",{parentName:"p",href:"OperatorsSZ#truncated_gauss"},(0,i.kt)("inlineCode",{parentName:"a"},"truncated_gauss"))," (we invite you to read the documentation for those operators)."))}h.isMDXComponent=!0}}]);