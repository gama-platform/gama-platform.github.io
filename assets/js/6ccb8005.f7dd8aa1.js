"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[77434],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=s(n),m=a,h=c["".concat(p,".").concat(m)]||c[m]||u[m]||o;return n?r.createElement(h,i(i({ref:t},d),{},{components:n})):r.createElement(h,i({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[c]="string"==typeof e?e:a,i[1]=l;for(var s=2;s<o;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},77723:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>p,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});var r=n(87462),a=n(63366),o=(n(67294),n(3905)),i=["components"],l={title:"Operators (I to M)"},p=void 0,s={unversionedId:"OperatorsIM",id:"OperatorsIM",title:"Operators (I to M)",description:"----",source:"@site/../docs/OperatorsIM.md",sourceDirName:".",slug:"/OperatorsIM",permalink:"/wiki/next/OperatorsIM",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/OperatorsIM/_edit",tags:[],version:"current",frontMatter:{title:"Operators (I to M)"},sidebar:"side",previous:{title:"Operators (D to H)",permalink:"/wiki/next/OperatorsDH"},next:{title:"Operators (N to R)",permalink:"/wiki/next/OperatorsNR"}},d={},c=[{value:"Definition",id:"definition",level:2},{value:"Priority between operators",id:"priority-between-operators",level:2},{value:"Using actions as operators",id:"using-actions-as-operators",level:2},{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Operators by categories",id:"operators-by-categories",level:2},{value:"Types-related operators",id:"types-related-operators",level:3},{value:"Operators",id:"operators",level:2}],u={toc:c},m="wrapper";function h(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)(m,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("hr",null),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"This file is automatically generated from java files. Do Not Edit It.")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"definition"},"Definition"),(0,o.kt)("p",null,"Operators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function. "),(0,o.kt)("p",null,"Most of them use a classical prefixed functional syntax (i.e. ",(0,o.kt)("inlineCode",{parentName:"p"},"operator_name(operand1, operand2, operand3)"),", see below), with the exception of arithmetic (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"/"),"), logical (",(0,o.kt)("inlineCode",{parentName:"p"},"and"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"or"),"), comparison (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},">"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"<"),"), access (",(0,o.kt)("inlineCode",{parentName:"p"},"."),", ",(0,o.kt)("inlineCode",{parentName:"p"},"[..]"),") and pair (",(0,o.kt)("inlineCode",{parentName:"p"},"::"),") operators, which require an infixed notation (i.e. ",(0,o.kt)("inlineCode",{parentName:"p"},"operand1 operator_symbol operand1"),"). "),(0,o.kt)("p",null,"The ternary functional if-else operator, ",(0,o.kt)("inlineCode",{parentName:"p"},"? :"),", uses a special infixed syntax composed with two symbols (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"operand1 ? operand2 : operand3"),"). Two unary operators (",(0,o.kt)("inlineCode",{parentName:"p"},"-")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"!"),") use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"}," - 10"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"! (operand1 or operand2)"),"). "),(0,o.kt)("p",null,"Finally, special constructor operators (",(0,o.kt)("inlineCode",{parentName:"p"},"{...}")," for constructing points, ",(0,o.kt)("inlineCode",{parentName:"p"},"[...]")," for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"{1,2,3}"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"[operand1, operand2, ..., operandn]")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"[key1::value1, key2::value2... keyn::valuen]"),")."),(0,o.kt)("p",null,"With the exception of these special cases above, the following rules apply to the syntax of operators:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"if they only have one operand, the functional prefixed syntax is mandatory (e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},"operator_name(operand1)"),")"),(0,o.kt)("li",{parentName:"ul"},"if they have two arguments, either the functional prefixed syntax (e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},"operator_name(operand1, operand2)"),") or the infixed syntax (e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},"operand1 operator_name operand2"),") can be used."),(0,o.kt)("li",{parentName:"ul"},"if they have more than two arguments, either the functional prefixed syntax (e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},"operator_name(operand1, operand2, ..., operand)"),") or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},"operand1 operator_name(operand2, ..., operand)"),") can be used.")),(0,o.kt)("p",null,"All of these alternative syntaxes are completely equivalent."),(0,o.kt)("p",null,"Operators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the ",(0,o.kt)("inlineCode",{parentName:"p"},"shuffle")," operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"priority-between-operators"},"Priority between operators"),(0,o.kt)("p",null,"The priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first."),(0,o.kt)("p",null,"GAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the constructor operators, like ",(0,o.kt)("inlineCode",{parentName:"li"},"::"),", used to compose pairs of operands, have the lowest priority of all operators (e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},"a > b :: b > c")," will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, ",(0,o.kt)("inlineCode",{parentName:"li"},"[a > 10, b > 5]")," will return a list of boolean values."),(0,o.kt)("li",{parentName:"ul"},"it is followed by the ",(0,o.kt)("inlineCode",{parentName:"li"},"?:")," operator, the functional if-else (e.g. ",(0,o.kt)("inlineCode",{parentName:"li"}," a > b ? a + 10 : a - 10")," will return the result of the if-else)."),(0,o.kt)("li",{parentName:"ul"},"next are the logical operators, ",(0,o.kt)("inlineCode",{parentName:"li"},"and")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"or")," (e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},"a > b or b > c")," will return the value of the test)"),(0,o.kt)("li",{parentName:"ul"},"next are the comparison operators (i.e. ",(0,o.kt)("inlineCode",{parentName:"li"},">"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"<"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"<="),", ",(0,o.kt)("inlineCode",{parentName:"li"},">="),", ",(0,o.kt)("inlineCode",{parentName:"li"},"="),", ",(0,o.kt)("inlineCode",{parentName:"li"},"!="),")"),(0,o.kt)("li",{parentName:"ul"},"next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)"),(0,o.kt)("li",{parentName:"ul"},"next the unary operators ",(0,o.kt)("inlineCode",{parentName:"li"},"-")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"!")),(0,o.kt)("li",{parentName:"ul"},"next the access operators ",(0,o.kt)("inlineCode",{parentName:"li"},".")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"[]")," (e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},"{1,2,3}.x > 20 + {4,5,6}.y")," will return the result of the comparison between the x and y ordinates of the two points)"),(0,o.kt)("li",{parentName:"ul"},"and finally the functional operators, which have the highest priority of all.")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"using-actions-as-operators"},"Using actions as operators"),(0,o.kt)("p",null,"Actions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand."),(0,o.kt)("p",null,"For instance, if the following species is defined:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"species spec1 {\n        int min(int x, int y) {\n                return x > y ? x : y;\n        }\n}\n")),(0,o.kt)("p",null,"Any agent instance of spec1 can use ",(0,o.kt)("inlineCode",{parentName:"p"},"min")," as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"global {\n        init {\n                create spec1;\n                spec1 my_agent <- spec1[0];\n                int the_min <- my_agent min(10,20); // or min(my_agent, 10, 20);\n        }\n}\n")),(0,o.kt)("p",null,"If the action doesn't have any operands, the syntax to use is ",(0,o.kt)("inlineCode",{parentName:"p"},"my_agent the_action()"),". Finally, if it does not return a value, it might still be used but is considering as returning a value of type ",(0,o.kt)("inlineCode",{parentName:"p"},"unknown")," (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"unknown result <- my_agent the_action(op1, op2);"),")."),(0,o.kt)("p",null,"Note that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent)."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"table-of-contents"},"Table of Contents"),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"operators-by-categories"},"Operators by categories"),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"types-related-operators"},"Types-related operators"),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"operators"},"Operators"))}h.isMDXComponent=!0}}]);