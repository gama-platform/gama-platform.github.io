"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[75894],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},m="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=s(n),u=i,f=m["".concat(p,".").concat(u)]||m[u]||h[u]||o;return n?a.createElement(f,r(r({ref:t},c),{},{components:n})):a.createElement(f,r({ref:t},c))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=u;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[m]="string"==typeof e?e:i,r[1]=l;for(var s=2;s<o;s++)r[s]=n[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},55364:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>p,default:()=>f,frontMatter:()=>l,metadata:()=>s,toc:()=>m});var a=n(87462),i=n(63366),o=(n(67294),n(3905)),r=["components"],l={title:"Defining Batch Experiments"},p=void 0,s={unversionedId:"BatchExperiments",id:"version-1.9.1/BatchExperiments",title:"Defining Batch Experiments",description:"Batch experiments allow to execute numerous successive simulation runs. They are used to explore the parameter space of a model or to optimize a set of model parameters. Exploration methods are detailed in this page.",source:"@site/versioned_docs/version-1.9.1/BatchExperiments.md",sourceDirName:".",slug:"/BatchExperiments",permalink:"/wiki/BatchExperiments",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/BatchExperiments/_edit",tags:[],version:"1.9.1",frontMatter:{title:"Defining Batch Experiments"},sidebar:"main",previous:{title:"Run Several Simulations",permalink:"/wiki/RunSeveralSimulations"},next:{title:"Exploration  calibration methods",permalink:"/wiki/ExplorationMethods"}},c={},m=[{value:"The batch experiment facets",id:"the-batch-experiment-facets",level:2},{value:"Action <code>_step_</code> and reflexes",id:"action-_step_-and-reflexes",level:2},{value:"Permanent",id:"permanent",level:2},{value:"Parameter sets in parallel",id:"parameter-sets-in-parallel",level:2}],h={toc:m},u="wrapper";function f(e){var t=e.components,n=(0,i.Z)(e,r);return(0,o.kt)(u,(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Batch experiments allow to execute numerous successive simulation runs. They are used to explore the parameter space of a model or to optimize a set of model parameters. ",(0,o.kt)("a",{parentName:"p",href:"ExplorationMethods"},"Exploration methods are detailed in this page.")),(0,o.kt)("p",null,"A Batch experiment is defined by:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"experiment exp_title type: batch until: condition {\n   [parameter to explore]\n   [exploration method]\n   [reflex]\n   [permanent]\n}\n")),(0,o.kt)("h2",{id:"the-batch-experiment-facets"},"The batch experiment facets"),(0,o.kt)("p",null,"Batch experiments have the following three facets:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"until"),": (expression) Specifies when to stop each simulation. Its value is a condition on variables defined in the model. The run will stop when the condition is evaluated to true. If omitted, the first simulation run will go forever, preventing any subsequent run to take place (unless a halt command is used in the model itself)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"repeat"),": (integer) Specifies the number of simulations replications for each parameter configuration (a set of values assigned to the parameters). This means that several simulation will be run with the same parameter values, however a different random seed will be used for the pseudo-random number generator for each simulation. This allows to get some statistical power from the experiments conducted for stochastic models. The default value is 1."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"keep_seed"),": (boolean) If true, the same series of random seeds will be used from one parameter configuration to another. The default value is false.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"experiment my_batch_experiment type: batch repeat: 5 keep_seed: true until: (cycle = 300) {\n   [parameter to explore]\n   [exploration method]\n}\n")),(0,o.kt)("h2",{id:"action-_step_-and-reflexes"},"Action ",(0,o.kt)("inlineCode",{parentName:"h2"},"_step_")," and reflexes"),(0,o.kt)("p",null,"As for any species, ",(0,o.kt)("inlineCode",{parentName:"p"},"experiment")," can define as many ",(0,o.kt)("inlineCode",{parentName:"p"},"reflex")," as needed. In a ",(0,o.kt)("inlineCode",{parentName:"p"},"batch")," experiment, they will be executed at the end of each bunch of simulations (set of replications) for a given parameters configuration. Note that at the experiment level, you have access to all the species and all the global variables and to all the simulations (variable ",(0,o.kt)("inlineCode",{parentName:"p"},"simulations"),")."),(0,o.kt)("p",null,"To be complete, each experiment (as any agent) will call at each step (i.e. the end of the replications set) the ",(0,o.kt)("inlineCode",{parentName:"p"},"_step_")," action: this action is in charge of executing the behavior of the experiment agent, that is by default the execution of each of its ",(0,o.kt)("inlineCode",{parentName:"p"},"reflex"),". It is possible to redefine the action ",(0,o.kt)("inlineCode",{parentName:"p"},"_step_"),", but this should be used with care since this inhibits the reflexes."),(0,o.kt)("p",null,"For instance, the following experiment runs the simulation 5 times, and saves the people agents in a single shapefile at the end of the 5 simulations."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'experiment \'Run 5 simulations\' type: batch repeat: 5 keep_seed: true until: ( time > 1000 ) {\n    int cpt <- 0;\n\n    reflex save_people {\n        save people type:"shp" to:"people_shape" + cpt + ".shp" with: [is_infected::"INFECTED", is_immune::"IMMUNE"];\n        cpt <- cpt + 1;\n    }\n}\n')),(0,o.kt)("p",null,"The same can be done using the ",(0,o.kt)("inlineCode",{parentName:"p"},"action _step_ {")," instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"reflex save_people {"),"."),(0,o.kt)("p",null,"But if now we want to save information from the 5 simulations and save 1 shapefile per replication, we need to use the built-in attribute ",(0,o.kt)("inlineCode",{parentName:"p"},"simulations"),". To save 1 shapefile per simulation run, we thus need to write:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'experiment \'Run 5 simulations\' type: batch repeat: 5 keep_seed: true until: ( time > 1000 ) {\n    reflex end_of_runs {\n    int cpt <- 0;\n        ask simulations {\n            save people type: "shp" to: "result/people_shape" + cpt + ".shp" with: [is_infected::"INFECTED", is_immune::"IMMUNE"];\n            cpt <- cpt + 1;\n        }\n    }\n}\n')),(0,o.kt)("p",null,"If now we want to save in a file aggregated values over the five simulations, such as the average number of infected people over the five simulations, we need to write:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'experiment \'Run 5 simulations\' type: batch repeat: 5 keep_seed: true until: ( cycle > 1000 ) {\n    reflex t {\n        save [cycle, simulations mean_of each.nb_infected] to: "result.txt" type: "csv";\n    }\n}\n')),(0,o.kt)("h2",{id:"permanent"},"Permanent"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"permanent")," statement allows the modeler to define an output block that will not be re-initialized at the beginning of each simulation but will be filled instead at the end of each simulation.\nFor instance, this ",(0,o.kt)("inlineCode",{parentName:"p"},"permanent")," section will plot for each simulation the end value of the ",(0,o.kt)("inlineCode",{parentName:"p"},"food_gathered")," variable (defined as a global variable in the model)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'permanent {\n    display Ants background: #white refresh: every(1#cycle) {\n        chart "Food Gathered" type: series {\n            data "Food" value: food_gathered;\n        }\n    }\n}\n')),(0,o.kt)("p",null,"It can be particularly useful when exploring values of parameters to plot their influence over some metric. For example here is a model based on Thomas Schelling's model of residential segregation (described in many library models) where we use batch to explore the parameter ",(0,o.kt)("inlineCode",{parentName:"p"},"number_of_groups"),". For each value of this parameter we will run 10 simulations to mitigate the impact of randomness. We will then use the ",(0,o.kt)("inlineCode",{parentName:"p"},"permanent")," statement to display the average happiness after 50 simulation steps in function of the number of groups in which the population is split:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'/**\n* Name: NewModel\n* Based on the internal empty template. \n* Author: baptiste\n* Tags: \n*/\n\n\nmodel shelling_exploration\n\n\nglobal {\n    //Different colors for the group\n    list colors <- [rgb ("yellow"), rgb ("red"), rgb ("blue"), \n        rgb ("orange"), rgb ("green"), rgb ("pink"), rgb ("magenta") , rgb ("cyan")\n    ] of: rgb;\n\n    \n    //Number of groups\n    int number_of_groups <- 2 max: 8 parameter: "Number of groups:" category: "Population";\n    //Density of the people\n    float density_of_people <- 0.7 parameter: "Density of people:" category: "Population" min: 0.01 max: 0.99;\n    //Percentage of similar wanted for segregation\n    float percent_similar_wanted <- 0.5 min: float (0) max: float (1) parameter: "Desired percentage of similarity:" category: "Population";\n    //Dimension of the grid\n    int dimensions <- 40 max: 400 min: 10 parameter: "Width and height of the environment:" category: "Environment";\n    //Neighbours distance for the perception of the agents\n    int neighbours_distance <- 2 max: 10 min: 1 parameter: "Distance of perception:" category: "Population";\n    //Number of people agents\n    int number_of_people <- 0;\n    //Number of happy people\n    int sum_happy_people <- 0 update: all_people count (each.is_happy);\n    //Number of similar neighbours\n    int sum_similar_neighbours <- 0 update: sum (all_people collect each.similar_nearby);\n    //Number of neighbours\n    int sum_total_neighbours <- 1 update: sum (all_people collect each.total_nearby) min: 1;\n    //List of all the places\n    list<space> all_places ;\n    //List of all the people\n    list<base> all_people;  \n    //List of all the free places\n    list<space> free_places ;\n    \n    //Shape of the world\n    geometry shape <- square(dimensions);\n    \n    \n\n    //Initialization of the model\n    init {\n        //Initialization of the places\n        do initialize_places;\n        //Computation of the number of people according to the density of people\n        number_of_people <- int( length (all_places) * density_of_people);\n        //Initialization of the people\n        do initialize_people;\n    }\n    \n    \n    //Action to initialize the people agents\n    action initialize_people { \n        create people number: number_of_people; \n        all_people <- people as list ;  \n    } \n    //Action to initialize the places\n    action initialize_places { \n        all_places <- shuffle (space);\n        free_places <- all_places;  \n    } \n}\n\n//Species base representing the people agents\nspecies base {\n    rgb color;\n    //List of all the neighbours agents\n    list<base> my_neighbours;\n    //computation of the similar neighbours\n    int similar_nearby -> \n        (my_neighbours count (each.color = color))\n    ;\n    //Computation of the total neighbours nearby\n    int total_nearby -> \n        length (my_neighbours)\n    ;\n    //Boolean to know if the agent is happy or not\n    bool is_happy -> similar_nearby >= (percent_similar_wanted * total_nearby ) ;\n}\n\n\n\n\n//Grid to discretize space, each cell representing a free space for the people agents\ngrid space width: dimensions height: dimensions neighbors: 8 use_regular_agents: false frequency: 0{\n    rgb color  <- #black;\n}\n\n//Species representing the people agents\nspecies people parent: base  {\n    //Color of the people agent\n    rgb color <- colors at (rnd (number_of_groups - 1));\n    //List of all the neighbours of the agent\n    list<people> my_neighbours -> people at_distance neighbours_distance ;\n    //Cell representing the place of the agent\n    space my_place;\n    init {\n        //The agent will be located on one of the free places\n        my_place <- one_of(free_places);\n        location <- my_place.location; \n        //As one agent is in the place, the place is removed from the free places\n        free_places >> my_place;\n    } \n    //Reflex to migrate the people agent when it is not happy \n    reflex migrate when: !is_happy {\n        //Add the place to the free places as it will move to another place\n        free_places << my_place;\n        //Change the place of the agent\n        my_place <- one_of(free_places);\n        location <- my_place.location; \n        //Remove the new place from the free places\n        free_places >> my_place;\n    }\n    \n}\n\n\nexperiment explo type:batch until:cycle>50 repeat:10 parallel:10{\n    \n    parameter "nb groups" var:number_of_groups min:2 max:8;\n    \n    method exploration;\n    \n    \n    permanent {\n        display Comparison background: #white {\n            chart "Number of happy people" type: xy {\n                data "Groups "  value:{number_of_groups, simulations mean_of (each.sum_happy_people)} ;\n                \n            }\n        }\n    }   \n}\n\n')),(0,o.kt)("p",null,"Which gives us a result that looks something like this:\n",(0,o.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/6374469/224968198-bec9c2df-7799-4e0b-ad20-a4b49d819549.png",alt:"image"})),(0,o.kt)("h2",{id:"parameter-sets-in-parallel"},"Parameter sets in parallel"),(0,o.kt)("p",null,"There is an option in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Preferences...")," menu of Gama to allow multiple replications to be executed in parallel, that is to fully use assigned cores to computation. In that case, ",(0,o.kt)("inlineCode",{parentName:"p"},"permanent")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"reflex")," blocks in the ",(0,o.kt)("inlineCode",{parentName:"p"},"experiment")," will only be triggered once at the end of the whole set of simulations, rather than after each set of replications. Therefor, this option should only be used when doing none GUI batch experiment"))}f.isMDXComponent=!0}}]);