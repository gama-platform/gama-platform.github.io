"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[89519],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>f});var o=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var d=o.createContext({}),p=function(e){var t=o.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},s=function(e){var t=p(e.components);return o.createElement(d.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,d=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),c=p(n),u=i,f=c["".concat(d,".").concat(u)]||c[u]||m[u]||a;return n?o.createElement(f,r(r({ref:t},s),{},{components:n})):o.createElement(f,r({ref:t},s))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,r=new Array(a);r[0]=u;var l={};for(var d in t)hasOwnProperty.call(t,d)&&(l[d]=t[d]);l.originalType=e,l[c]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<a;p++)r[p]=n[p];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},74732:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>d,default:()=>u,frontMatter:()=>l,metadata:()=>p,toc:()=>c});var o=n(87462),i=n(63366),a=(n(67294),n(3905)),r=["components"],l={title:"2. Vegetation Dynamic"},d=void 0,p={unversionedId:"PredatorPrey_step2",id:"version-1.8.1/PredatorPrey_step2",title:"2. Vegetation Dynamic",description:'This second step presents the idea of environment or topological space. Defining a "vegetation" environment allows to define the movement of the preys through dynamic variables (use of the update facet). We will also discover more about displays.',source:"@site/versioned_docs/version-1.8.1/PredatorPrey_step2.md",sourceDirName:".",slug:"/PredatorPrey_step2",permalink:"/wiki/1.8.1/PredatorPrey_step2",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/PredatorPrey_step2/_edit",tags:[],version:"1.8.1",frontMatter:{title:"2. Vegetation Dynamic"},sidebar:"tuto",previous:{title:"1. Basic Model",permalink:"/wiki/1.8.1/PredatorPrey_step1"},next:{title:"3. Prey Agent Behavior",permalink:"/wiki/1.8.1/PredatorPrey_step3"}},s={},c=[{value:"Formulation",id:"formulation",level:2},{value:"Model Definition",id:"model-definition",level:2},{value:"grid",id:"grid",level:3},{value:"prey agents",id:"prey-agents",level:3},{value:"display",id:"display",level:3},{value:"Complete Model",id:"complete-model",level:2}],m={toc:c};function u(e){var t=e.components,n=(0,i.Z)(e,r);return(0,a.kt)("wrapper",(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,'This second step presents the idea of environment or topological space. Defining a "vegetation" environment allows to define the movement of the preys through dynamic variables (use of the ',(0,a.kt)("em",{parentName:"p"},"update")," facet). We will also discover more about displays."),(0,a.kt)("h2",{id:"formulation"},"Formulation"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Definition of a grid (for the vegetation)"),(0,a.kt)("li",{parentName:"ul"},"Definition of a dynamic for each cell (food production)"),(0,a.kt)("li",{parentName:"ul"},"Display of the cell color according to the quantity of food"),(0,a.kt)("li",{parentName:"ul"},"Localization of the prey agents on the cells (at its center)")),(0,a.kt)("h2",{id:"model-definition"},"Model Definition"),(0,a.kt)("h3",{id:"grid"},"grid"),(0,a.kt)("p",null,"In GAMA, grids are specific agent species with a particular topology. First, a grid allows yet constrains the movement of other (moving) agents but they can have variables and behaviors."),(0,a.kt)("p",null,"A grid is defined as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"grid grid_name width: nb_cols height: nb_lines neighbors: 4/6/8 {\n    ...\n}\n")),(0,a.kt)("p",null,"With:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"width"),": number of cells along the x-axis"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"height"),": number of cells along the y-axis"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"neighbors"),": neighborhood type (4 - Von Neumann, 6 - hexagon or 8 - Moore)")),(0,a.kt)("p",null,"In our model, we define a grid species, called ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"vegetation_cell"))," composed of 50x50 cells and with a Von Neumann neighborhood.\nIn order for each grid agents (or cell of the grid) to represent the vegetation, we provide them with four variables:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"max_food"),": maximum food that a cell can contain -> type: ",(0,a.kt)("inlineCode",{parentName:"li"},"float")," ; init value: ",(0,a.kt)("inlineCode",{parentName:"li"},"1.0"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"food_prod"),": food produced at each simulation step -> type: ",(0,a.kt)("inlineCode",{parentName:"li"},"float")," ; init value: random number between 0 and 0.01."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"food"),": current quantity of food -> type: ",(0,a.kt)("inlineCode",{parentName:"li"},"float")," ; init value: random number between 0 and 1.0; at each simulation step: food <- food + food_prod."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"color"),": color of the cell -> type: ",(0,a.kt)("inlineCode",{parentName:"li"},"rgb")," ; init value: color computed according to the food value: more the food value is close to 1.0, greener the color is, more the food value is close to 0,  whiter the color is; update: computation of the new color depending on the current level of food (at each simulation step).")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"update")," facet allows to give a behavior to the agents. Indeed, at each simulation step, each agent is activated (by default, in its creation order) and first applies for each dynamic variable (in their definition order) its update expression. In the present case, it allows us to link the displayed color of the cell to its food level."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"grid vegetation_cell width: 50 height: 50 neighbors: 4 {\n    float max_food <- 1.0 ;\n    float food_prod <- rnd(0.01) ;\n    float food <- rnd(1.0) update: food + food_prod max: max_food;\n    rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) \n         update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) ;\n}\n")),(0,a.kt)("p",null,"There are several ways to define colors in GAML:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"the simplest way consists in using the symbol ",(0,a.kt)("inlineCode",{parentName:"li"},"#")," + the color name (for a limited set of  ",(0,a.kt)("a",{parentName:"li",href:"Exhaustive-list-of-GAMA-Keywords#constants-and-colors"},"colors"),"): ",(0,a.kt)("inlineCode",{parentName:"li"},"#blue"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"#red"),"..."),(0,a.kt)("li",{parentName:"ul"},"Another way consists in defining the 3 RGB integer values: rgb(red, green, blue) with red, green and blue between 0 and 255 (as we used in the current model): ",(0,a.kt)("inlineCode",{parentName:"li"},"rgb(0,0,0)"),"  for black, ",(0,a.kt)("inlineCode",{parentName:"li"},"rgb(255,255,255)")," for white, ",(0,a.kt)("inlineCode",{parentName:"li"},"rgb(255,0,0)")," for red, ",(0,a.kt)("inlineCode",{parentName:"li"},"rgb(0,255,0)")," for green, or  ",(0,a.kt)("inlineCode",{parentName:"li"},"rgb(0,0,255)")," for blue.")),(0,a.kt)("h3",{id:"prey-agents"},"prey agents"),(0,a.kt)("p",null,"In order to relate our prey agents to the vegetation cell grid, we add them with one new attribute: ",(0,a.kt)("inlineCode",{parentName:"p"},"my_cell")," of type ",(0,a.kt)("inlineCode",{parentName:"p"},"vegetation_cell")," and for init value one of the ",(0,a.kt)("inlineCode",{parentName:"p"},"vegetation_cell")," (chosen randomly)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"species prey {\n    ...\n    vegetation_cell my_cell <- one_of (vegetation_cell) ;\n} \n")),(0,a.kt)("p",null,"It is possible to obtain the list of all agents of a given species by using the name of the species while ",(0,a.kt)("inlineCode",{parentName:"p"},"one_of")," to pick one element randomly from this list."),(0,a.kt)("p",null,"We linked each prey agent to a ",(0,a.kt)("inlineCode",{parentName:"p"},"vegetation_cell")," but we need to locate them onto the cell. To do so, we set the prey ",(0,a.kt)("inlineCode",{parentName:"p"},"location")," as equals to the ",(0,a.kt)("inlineCode",{parentName:"p"},"location")," of the vegetation cell (i.e. its centroid), we use in the ",(0,a.kt)("inlineCode",{parentName:"p"},"init")," block the ",(0,a.kt)("inlineCode",{parentName:"p"},"<-")," statement that allows to modify the value of a variable:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"species prey {\n    ...\n    init {\n        location <- my_cell.location;\n    }\n}\n")),(0,a.kt)("h3",{id:"display"},"display"),(0,a.kt)("p",null,"In order to visualize the vegetation, we need to add it to the display. We use for that the statement ",(0,a.kt)("inlineCode",{parentName:"p"},"grid")," with the optional facet ",(0,a.kt)("inlineCode",{parentName:"p"},"lines")," to draw the border of the cells. Note that grid agents have built-in aspect thus it is not necessary to define one: it is a square with the ",(0,a.kt)("inlineCode",{parentName:"p"},"color")," attribute as value."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"   output {\n       display main_display {\n           grid vegetation_cell lines: #black;\n           species prey aspect: base ;\n       }\n   }\n")),(0,a.kt)("p",null,"Note that the layers in a display work like layers in a GIS; the drawing order will be respected. In our model, the prey agents will be drawn above the vegetation","_","cell grid thus they need to be declared afterward."),(0,a.kt)("h2",{id:"complete-model"},"Complete Model"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'model prey_predator\n\nglobal {\n    int nb_preys_init <- 200;\n    init {\n    create prey number: nb_preys_init ;\n    }\n}\n\nspecies prey {\n    float size <- 1.0 ;\n    rgb color <- #blue;\n    vegetation_cell my_cell <- one_of (vegetation_cell) ;\n        \n    init {\n    location <- my_cell.location;\n    }\n        \n    aspect base {\n    draw circle(size) color: color ;\n    }\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n    float max_food <- 1.0 ;\n    float food_prod <- rnd(0.01) ;\n    float food <- rnd(1.0) max: max_food update: food + food_prod ;\n    rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) \n         update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) ;\n}\n\nexperiment prey_predator type: gui {\n    parameter "Initial number of preys: " var: nb_preys_init min: 1 max: 1000 category: "Prey" ;\n    output {\n    display main_display {\n        grid vegetation_cell lines: #black ;\n        species prey aspect: base ;\n    }\n    }\n}\n')))}u.isMDXComponent=!0}}]);