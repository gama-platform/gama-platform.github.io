"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[67331],{3905:(e,n,a)=>{a.d(n,{Zo:()=>_,kt:()=>f});var t=a(67294);function r(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function o(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function i(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?o(Object(a),!0).forEach((function(n){r(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function l(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},o=Object.keys(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=t.createContext({}),s=function(e){var n=t.useContext(p),a=n;return e&&(a="function"==typeof e?e(n):i(i({},n),e)),a},_=function(e){var n=s(e.components);return t.createElement(p.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},m=t.forwardRef((function(e,n){var a=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,_=l(e,["components","mdxType","originalType","parentName"]),c=s(a),m=r,f=c["".concat(p,".").concat(m)]||c[m]||d[m]||o;return a?t.createElement(f,i(i({ref:n},_),{},{components:a})):t.createElement(f,i({ref:n},_))}));function f(e,n){var a=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=m;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[c]="string"==typeof e?e:r,i[1]=l;for(var s=2;s<o;s++)i[s]=a[s];return t.createElement.apply(null,i)}return t.createElement.apply(null,a)}m.displayName="MDXCreateElement"},15787:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>_,contentTitle:()=>p,default:()=>f,frontMatter:()=>l,metadata:()=>s,toc:()=>c});var t=a(87462),r=a(63366),o=(a(67294),a(3905)),i=["components"],l={"^title":"pedestrian complex environment"},p=void 0,s={unversionedId:"pedestrian_complex_environment",id:"pedestrian_complex_environment",title:"pedestrian_complex_environment",description:"Path: Plugin models/Pedestrian Skill/models/Complex environment-walk.gaml",source:"@site/../docs/pedestrian_complex_environment.md",sourceDirName:".",slug:"/pedestrian_complex_environment",permalink:"/wiki/next/pedestrian_complex_environment",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/pedestrian_complex_environment/_edit",tags:[],version:"current",frontMatter:{"^title":"pedestrian complex environment"}},_={},c=[],d={toc:c},m="wrapper";function f(e){var n=e.components,a=(0,r.Z)(e,i);return(0,o.kt)(m,(0,t.Z)({},d,a,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("img",{width:"960",alt:"Annotation 2023-04-15 185631_ComplexEnvWalk",src:"https://user-images.githubusercontent.com/4437331/232240816-36f550f0-676f-4c26-a031-29dc2ba1859f.png"}),(0,o.kt)("p",null,"Path: Plugin models/Pedestrian Skill/models/Complex environment-walk.gaml"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'\n/***\n* Name: pedestrian_complex_environment\n* Author: Patrick Taillandier\n* Description: show how to use the pedestrian skill for complex envorinment - require to generate pedestrian paths before - see model "Generate Pedestrian path.gaml" \n* Tags: pedestrian, gis, shapefile, graph, agent_movement, skill, transport\n***/\n\nmodel pedestrian_complex_environment\n\nglobal {\n    \n    file wall_shapefile <- file("../includes/walls.shp");\n    \n    shape_file free_spaces_shape_file <- shape_file("../includes/free spaces.shp");\n    shape_file open_area_shape_file <- shape_file("../includes/open area.shp");\n    shape_file pedestrian_paths_shape_file <- shape_file("../includes/pedestrian paths.shp");\n\n    \n    graph network;\n    \n    geometry shape <- envelope(wall_shapefile);\n    \n    bool display_free_space <- false parameter: true;\n    bool display_force <- false parameter: true;\n    bool display_target <- false parameter: true;\n    bool display_circle_min_dist <- true parameter: true;\n    \n    float P_shoulder_length <- 0.45 parameter: true;\n    float P_proba_detour <- 0.5 parameter: true ;\n    bool P_avoid_other <- true parameter: true ;\n    float P_obstacle_consideration_distance <- 3.0 parameter: true ;\n    float P_pedestrian_consideration_distance <- 3.0 parameter: true ;\n    float P_tolerance_target <- 0.1 parameter: true;\n    bool P_use_geometry_target <- true parameter: true;\n    \n    \n    string P_model_type <- "simple" among: ["simple", "advanced"] parameter: true ; \n    \n    float P_A_pedestrian_SFM_advanced parameter: true <- 0.16 category: "SFM advanced" ;\n    float P_A_obstacles_SFM_advanced parameter: true <- 1.9 category: "SFM advanced" ;\n    float P_B_pedestrian_SFM_advanced parameter: true <- 0.1 category: "SFM advanced" ;\n    float P_B_obstacles_SFM_advanced parameter: true <- 1.0 category: "SFM advanced" ;\n    float P_relaxion_SFM_advanced  parameter: true <- 0.5 category: "SFM advanced" ;\n    float P_gama_SFM_advanced parameter: true <- 0.35 category: "SFM advanced" ;\n    float P_lambda_SFM_advanced <- 0.1 parameter: true category: "SFM advanced" ;\n    float P_minimal_distance_advanced <- 0.25 parameter: true category: "SFM advanced" ;\n    \n    float P_n_prime_SFM_simple parameter: true <- 3.0 category: "SFM simple" ;\n    float P_n_SFM_simple parameter: true <- 2.0 category: "SFM simple" ;\n    float P_lambda_SFM_simple <- 2.0 parameter: true category: "SFM simple" ;\n    float P_gama_SFM_simple parameter: true <- 0.35 category: "SFM simple" ;\n    float P_relaxion_SFM_simple parameter: true <- 0.54 category: "SFM simple" ;\n    float P_A_pedestrian_SFM_simple parameter: true <-4.5category: "SFM simple" ;\n    \n    float step <- 0.1;\n    int nb_people <- 250;\n\n    geometry open_area ;\n    \n    init {\n        open_area <- first(open_area_shape_file.contents);\n        create wall from:wall_shapefile;\n        create pedestrian_path from: pedestrian_paths_shape_file {\n            list<geometry> fs <- free_spaces_shape_file overlapping self;\n            free_space <- fs first_with (each covers shape); \n        }\n        \n\n        network <- as_edge_graph(pedestrian_path);\n        \n        ask pedestrian_path {\n            do build_intersection_areas pedestrian_graph: network;\n        }\n    \n        create people number:nb_people{\n            location <- any_location_in(one_of(open_area));\n            obstacle_consideration_distance <-P_obstacle_consideration_distance;\n            pedestrian_consideration_distance <-P_pedestrian_consideration_distance;\n            shoulder_length <- P_shoulder_length;\n            avoid_other <- P_avoid_other;\n            proba_detour <- P_proba_detour;\n            \n            use_geometry_waypoint <- P_use_geometry_target;\n            tolerance_waypoint<- P_tolerance_target;\n            pedestrian_species <- [people];\n            obstacle_species<-[wall];\n            \n            pedestrian_model <- P_model_type;\n            \n        \n            if (pedestrian_model = "simple") {\n                A_pedestrians_SFM <- P_A_pedestrian_SFM_simple;\n                relaxion_SFM <- P_relaxion_SFM_simple;\n                gama_SFM <- P_gama_SFM_simple;\n                lambda_SFM <- P_lambda_SFM_simple;\n                n_prime_SFM <- P_n_prime_SFM_simple;\n                n_SFM <- P_n_SFM_simple;\n            } else {\n                A_pedestrians_SFM <- P_A_pedestrian_SFM_advanced;\n                A_obstacles_SFM <- P_A_obstacles_SFM_advanced;\n                B_pedestrians_SFM <- P_B_pedestrian_SFM_advanced;\n                B_obstacles_SFM <- P_B_obstacles_SFM_advanced;\n                relaxion_SFM <- P_relaxion_SFM_advanced;\n                gama_SFM <- P_gama_SFM_advanced;\n                lambda_SFM <- P_lambda_SFM_advanced;\n                minimal_distance <- P_minimal_distance_advanced;\n            \n            }\n        }   \n    }\n    \n    reflex stop when: empty(people) {\n        do pause;\n    }\n    \n}\n\nspecies pedestrian_path skills: [pedestrian_road]{\n    aspect default { \n        draw shape  color: #gray;\n    }\n    aspect free_area_aspect {\n        if(display_free_space and free_space != nil) {\n            draw free_space color: #lightpink border: #black;\n        }\n        \n    }\n}\n\nspecies wall {\n    geometry free_space;\n    float high <- rnd(10.0, 20.0);\n    \n    aspect demo {\n        draw shape border: #black depth: high texture: ["../includes/top.png","../includes/texture5.jpg"];\n    }\n    \n    aspect default {\n        draw shape + (P_shoulder_length/2.0) color: #gray border: #black;\n    }\n}\n\nspecies people skills: [pedestrian]{\n    rgb color <- rnd_color(255);\n    float speed <- gauss(5,1.5) #km/#h min: 2 #km/#h;\n\n    reflex move  {\n        if (final_waypoint = nil) {\n            do compute_virtual_path pedestrian_graph:network target: any_location_in(open_area) ;\n        }\n        do walk ;\n    }   \n    \n    aspect default {\n        \n        if display_circle_min_dist and minimal_distance > 0 {\n            draw circle(minimal_distance).contour color: color;\n        }\n        \n        draw triangle(shoulder_length) color: color rotate: heading + 90.0;\n        \n        if display_target and current_waypoint != nil {\n            draw line([location,current_waypoint]) color: color;\n        }\n        if  display_force {\n            loop op over: forces.keys {\n                if (species(agent(op)) = wall ) {\n                    draw line([location, location + point(forces[op])]) color: #red end_arrow: 0.1;\n                }\n                else if ((agent(op)) = self ) {\n                    draw line([location, location + point(forces[op])]) color: #blue end_arrow: 0.1;\n                } \n                else {\n                    draw line([location, location + point(forces[op])]) color: #green end_arrow: 0.1;\n                }\n            }\n        }   \n    }\n}\n\n\nexperiment normal_sim type: gui {\n    float minimum_cycle_duration <- 0.02;\n        output {\n        display map type: 3d{\n            species wall refresh: false;\n            species pedestrian_path aspect:free_area_aspect transparency: 0.5 ;\n            species pedestrian_path refresh: false;\n            species people;\n        }\n    }\n}\n\n')))}f.isMDXComponent=!0}}]);