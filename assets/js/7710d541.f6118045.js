"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[61657],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>f});var a=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=a.createContext({}),l=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=l(e.components);return a.createElement(c.Provider,{value:n},e.children)},p="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),p=l(t),m=o,f=p["".concat(c,".").concat(m)]||p[m]||g[m]||r;return t?a.createElement(f,s(s({ref:n},d),{},{components:t})):a.createElement(f,s({ref:n},d))}));function f(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,s=new Array(r);s[0]=m;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i[p]="string"==typeof e?e:o,s[1]=i;for(var l=2;l<r;l++)s[l]=t[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},55878:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>f,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=t(87462),o=t(63366),r=(t(67294),t(3905)),s=["components"],i={"^title":"MODAVI"},c=void 0,l={unversionedId:"MODAVI",id:"MODAVI",title:"MODAVI",description:"Path: Library models/Multi-level Data Analysis/models/MODAVI.gaml",source:"@site/../docs/MODAVI.md",sourceDirName:".",slug:"/MODAVI",permalink:"/wiki/next/MODAVI",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/MODAVI/_edit",tags:[],version:"current",frontMatter:{"^title":"MODAVI"}},d={},p=[],g={toc:p},m="wrapper";function f(e){var n=e.components,t=(0,o.Z)(e,s);return(0,r.kt)(m,(0,a.Z)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("img",{width:"960",alt:"Annotation 2023-04-16 034343_MultiLevelDataAnalysis",src:"https://user-images.githubusercontent.com/4437331/232261840-cc7cd0ee-89d8-4c0d-af0b-db7c8e5e4c2e.png"}),(0,r.kt)("p",null,"Path: Library models/Multi-level Data Analysis/models/MODAVI.gaml"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"\n/**\n* Name: Modavi\n* Author: Arnaud Grignard\n* Description: From a reference model with node of a given class, a spatial graph is created \n*  (or a barabasi graph if spatialGraph is set to false) in the advanced view to \n*  represent the interaction in the reference model.\n*  An abstract view/controller is created to summarize the interaction in the advanced view\n*  in a macro graph and control the reference model by defining an action (user_command) \n*  for each macroNode and macroEdge.\n* Tags: 3d, graph, gui\n*/\n\nmodel modavi\n \nglobal {\n    //Graph of the agents\n    graph<node_agent,edge_agent> my_graph ;\n    \n    //Number of agents to create\n    int nbAgent parameter: 'Number of Agents' min: 1 <- 100 category: 'Model';\n    //Number of value per class\n    int nbValuePerClass parameter: 'Number of value per class' min: 1 max:100 <- 15 category: 'Model';\n    //Boolean to know if we display a spatial graph or not\n    bool spatialGraph parameter: 'Spatial Graph' <- true category: 'Model';\n    //Distance to link two node agents\n    float distance parameter: 'Distance' min: 1.0<- 10.0 category: 'Model';\n    //Threshold\n    int threshold parameter: 'Threshold' min: 0 <- 0 category: 'Model';\n\n    //Size of a node agent\n    int nodeSize parameter: 'Node size' min: 1 <- 1 category: 'Aspect';\n    //Size of a macro node agent\n    int macroNodeSize parameter: 'Macro Node size' min: 1 <- 2 category: 'Aspect';\n    \n    //Number of type of class\n    int nbTypeOfClass <-1;\n    \n    //Zoom factor\n    int zoomFactor <- nbTypeOfClass;\n\n    //List of the different interaction matrices\n    list<matrix<int>> interactionMatrix <-list_with(nbTypeOfClass,matrix([0]));\n    //Number maximum of edges\n    int nbEdgeMax;\n    \n    //Reflex to update the interaction matrix list\n    reflex updateInteractionMatrix{\n        //Ask for each edge agent to update it sources and destination to create the matrix\n        ask edge_agent{\n            loop i from:0 to: nbTypeOfClass-1{                                                          \n                src <- my_graph source_of(self);\n                dest <- my_graph target_of(self);\n                int tmp <- (interactionMatrix[i]  at {(src.classVector[i]-1),(dest.classVector[i]-1)});\n                interactionMatrix[i][src.classVector[i]-1,dest.classVector[i]-1] <- (tmp+1);\n            }\n        }\n    }\n    \n    //Reflex to compute te maximum number of edges\n    reflex computeNbEdgeMax{\n        //Number maximum of edges\n        nbEdgeMax <-1;\n        //Ask for each macro edge its aggregated link list number\n        ask macroEdge{\n            if(nbAggregatedLinkList[0] > nbEdgeMax){\n                nbEdgeMax <-nbAggregatedLinkList[0];\n            }   \n        }\n    }\n\n    //Initialization of the model\n    init {\n        //Initialization of the matrix\n        do InitInteractionMatrix;\n        //If we want a spatial graph in that case we create a graph according to their distance, else we create a barabasi albert graph\n        if(spatialGraph){\n            create node_agent number:nbAgent;\n            my_graph <- graph<node_agent, edge_agent>(as_distance_graph(node_agent, distance, edge_agent)); \n            \n        }\n        else{\n          my_graph <- graph<node_agent, edge_agent>(generate_barabasi_albert(nbAgent * 0.5,5,nbAgent,false,node_agent,edge_agent)); \n        }\n        \n        //For each node agent, we compute its class value\n        ask node_agent as list{\n            loop i from:0 to:nbTypeOfClass-1{\n                classVector[i] <- rnd(nbValuePerClass-1)+1;\n            }       \n        }\n\n        int i<-1;\n        //Creation of the macronode according to the number of value per class\n        create macroNode number: nbValuePerClass{    \n            class <-i;\n            location <- {(cos (((class-1)/nbValuePerClass)*360)*50 +50),(sin (((class-1)/nbValuePerClass)*360)*50+50),0};\n            color <- hsb (i/nbValuePerClass,1.0,1.0);\n            do updatemyNodes;\n            i<-i+1; \n        }\n        //We finally create the macroGraph\n        create macroGraph;\n     }\n     //Action to initialize the interaction Matrix according to the number of type of classes\n     action InitInteractionMatrix{\n         loop i from:0 to:nbTypeOfClass-1{\n                interactionMatrix[i] <- 0 as_matrix({nbValuePerClass,nbValuePerClass});\n          } \n    }\n}\n\n\n    //Species to represent the node_agent\n    species node_agent  {\n        //Color of the node agent\n        rgb color;\n        //List of the class\n        list<int> classVector <- list_with (nbTypeOfClass,0);\n        //List of the position\n        list<point> posVector <- list_with (nbTypeOfClass,{0,0});\n        //List of the color\n        list<rgb> colorList <- list_with (nbTypeOfClass, rgb(0,0,0));\n                                \n        //Shuffle the classes of the node_agent\n        reflex shuffleClass{\n            loop i from:0 to: nbTypeOfClass-1{\n                classVector[i] <- rnd(nbValuePerClass-1)+1;\n            }   \n        }\n        \n        aspect real {            \n            draw sphere(nodeSize) color: colorList[0];\n        } \n                                \n        aspect coloredByClass{\n            loop i from:0 to: nbTypeOfClass-1{\n                colorList[i]<- hsb (classVector[i]/nbValuePerClass,1.0,1.0);                    \n                posVector[i] <- {(location.x+i*110)*(1/zoomFactor),(location.y)*(1/zoomFactor),0};  \n                draw sphere(nodeSize/zoomFactor) color: colorList[i] at: posVector[i] ;   \n            }\n        }\n    \n    }\n    \n    //Species edge_agent to represent the edge of the graph\n    species edge_agent { \n        rgb color;\n        //Source of the edge\n        node_agent src;\n        //Target of the edge\n        node_agent dest;\n             \n        aspect base {\n            draw shape color: rgb(125,125,125);\n        }   \n        \n        aspect edgeGenericSpatialized{\n            loop i from:0 to: nbTypeOfClass-1{\n              if ((src != nil) and (dest !=nil) ){\n                draw line( [ (src.posVector[i]) , (dest.posVector[i])] ) color:rgb(125,125,125);\n              }\n            }\n        }\n    }\n    //Species representing the macro node agents\n    species macroNode{\n        rgb color;\n        int class;\n        //List of all the aggregated nodes\n        list<int> nbAggregatedNodes <- list_with(nbTypeOfClass,0);\n        //List of all the position\n        list<point> posVector <-list_with(nbTypeOfClass,{0,0});\n         \n        //Update the nodes of the agents\n        reflex update{\n            do updatemyNodes;\n        }\n        //For each classes, find all the nodes with the same classes\n        action updatemyNodes{\n            loop i from:0 to: nbTypeOfClass-1{          \n                nbAggregatedNodes[i]<-0;\n                ask node_agent as list{\n                  if    (classVector[i] = myself.class) {\n                    myself.nbAggregatedNodes[i] <- myself.nbAggregatedNodes[i]+1;\n                  }  \n                }\n            }       \n        } \n        \n        aspect sphere{\n            draw sphere((nbAggregatedNodes[0]/10)*macroNodeSize) color: color at: point([location.x,location.y]) ;\n        }\n        \n        aspect Generic{\n            loop i from:0 to: nbTypeOfClass-1\n            {\n            posVector[i] <- {(location.x+i*150)*(1/zoomFactor),(location.y)*(1/zoomFactor),0};  \n            draw sphere((nbAggregatedNodes[i]/10)*macroNodeSize*(1/zoomFactor)) color: color at: posVector[i] ;\n            }\n        }\n        \n        //This action only works when having nbTypeOfClass=1\n        action removeMicroNode{\n            ask node_agent as list{\n                  if    (classVector[0] = myself.class) {\n                      do die;\n                  }  \n             }\n        }\n        \n        user_command \"Remove all micro node\" action: removeMicroNode;\n    }\n    \n    //Species macroEdge representing the macro edges agents\n    species macroEdge  { \n        rgb color <- #black;\n        //Source of the macroedge\n        macroNode src;\n        //Destination of the macroedge\n        macroNode dest;\n        //List of all the aggregated links\n        list<int> nbAggregatedLinkList <- list_with(nbTypeOfClass,0);\n        \n        aspect base {\n            loop i from:0 to: nbTypeOfClass-1{\n                if(nbAggregatedLinkList[i]>threshold){\n                draw (line([src.posVector[i],dest.posVector[i]]) buffer ((nbAggregatedLinkList[i])/((length(edge_agent)))*nbEdgeMax)) color: rgb(125,125,125) border:rgb(125,125,125);  \n                }\n            }\n        }\n        \n        //Action to remove a micro edge\n        action removeMicroEdge{\n            ask edge_agent as list{\n                  if    ((self.src.classVector[0] =  myself.src.class) and (self.dest.classVector[0] =  myself.dest.class)) {\n                      do die;\n                  }  \n             }\n        }\n        \n        user_command \"Remove all micro edge\" action: removeMicroEdge;   \n    }\n    \n    //Species macroGraph representing the macro graph composed of macroNode and macroEdge\n    species macroGraph {\n        \n\n    //Reflex to update the graph by killing all the previous edges first \n   reflex updateAllMacroEdge {  \n        ask macroEdge as list{\n            do die;\n        }\n        \n        loop h from:0 to: nbTypeOfClass-1{\n            loop i from: 0 to: nbValuePerClass-1{\n              loop j from: 0 to: nbValuePerClass-1{\n                int tmp <- interactionMatrix[h] at {i,j}; \n\n                if(i!=j){\n                    create macroEdge{\n                      nbAggregatedLinkList[h] <- tmp;\n                      src <- macroNode[i];\n                      dest <- macroNode[j];\n                    }     \n                }      \n              }\n            }\n        }\n    }\n    //Reflex to initialize the matrix\n    reflex initMatrix{\n        loop i from:0 to:nbTypeOfClass-1{\n          interactionMatrix[i] <- 0 as_matrix({nbValuePerClass,nbValuePerClass});   \n        }   \n      } \n    }\n\n\n\nexperiment MODAVI type: gui {\n    output synchronized: true {         \n        display MODAVI type:3d axes:false {\n            camera #default location:{world.shape.width*1.5, world.shape.height,world.shape.width*4} target:{world.shape.width*1.5, world.shape.height,0};\n            graphics 'ReferenceModel'{\n                draw \"Reference model\" at:{200,50,0} size:5 color: #black perspective:false;\n            }\n            species node_agent aspect: real position:{100,0,0.01} ;\n            \n            graphics 'View1'{\n                draw \"Advanced view\" at:{50,210,0} size:5 color: #black perspective:false;\n            }\n            species node_agent aspect: coloredByClass position: {0,100,0.02};\n            species edge_agent aspect: edgeGenericSpatialized position: {0,100,0.02};\n            \n            graphics 'AbstractView'{\n                draw \"Abstract view/controller\" at:{250,210,0} size:5 color: #black perspective:false;\n            }\n            species macroNode aspect:Generic position: {200,100,0.01};\n            species macroEdge aspect:base position: {200,100,0.01}; \n        }\n    }       \n}\n\n")))}f.isMDXComponent=!0}}]);