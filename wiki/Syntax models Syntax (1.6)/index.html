<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Syntax · GAMA-Platform</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="GAMA"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Syntax · GAMA-Platform"/><meta property="og:type" content="website"/><meta property="og:url" content="https://gama-platform.github.io/"/><meta property="og:description" content="GAMA"/><meta property="og:image" content="https://gama-platform.github.io//resources/images/general/GamaPlatform.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://gama-platform.github.io//resources/images/general/GamaPlatform.png"/><link rel="shortcut icon" href="/img/gama-logo.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.4.4/fuse.min.js"></script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script type="text/javascript" src="/js/searchEngine.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/gama-logo_white.png" alt="GAMA-Platform"/><h2 class="headerTitleWithLogo">GAMA-Platform</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/wiki/Home" target="_self">Documentation</a></li><li class=""><a href="/wiki/Tutorials" target="_self">Tutorials</a></li><li class=""><a href="/download" target="_self">Download</a></li><li class=""><a href="/wiki/Contribute" target="_self">Contribute</a></li><li class=""><a target="_self"></a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Syntax</h1></header><article><div><span><p><em>Author : Alexis Drogoul</em></p>
<p>An overview of the new syntactic constructs that have been introduced in GAMA 1.6</p>
<p>Code of the model :</p>
<pre><code class="hljs">
@no_warning
<span class="hljs-builtin">model</span> syntax

<span class="hljs-comment">/**
 * The global section can now sport skills and control, just like other agents. 
 * The example below shows a potentially moving world that can be controlled by a finite state machine.
 */</span>
<span class="hljs-class">global <span class="hljs-title">skills</span>: [<span class="hljs-title">moving</span>] <span class="hljs-title">control</span>: <span class="hljs-title">fsm</span> </span>{

<span class="hljs-comment">/**
 * EQUATIONS
 */</span> 
    <span class="hljs-literal">float</span> x;
    <span class="hljs-literal">float</span> y;
    <span class="hljs-literal">float</span> t;
    equation eq {
        diff(x, t) = x / 2;
        diff(y, t) = x + y * 2;
    }

    <span class="hljs-class">reflex <span class="hljs-title">solving</span> </span>{solve eq step: 1 method: rk4;}

    <span class="hljs-comment">/** 
 * ATTRIBUTES
 */</span>

<span class="hljs-comment">// Attributes can be declared in different ways, ranging from "classic"...</span>
    <span class="hljs-literal">list</span>&lt;<span class="hljs-literal">int</span>&gt; a1 const: true &lt;- [1, 2, 3] of: <span class="hljs-literal">int</span>;
    <span class="hljs-literal">list</span> a2 &lt;- [1, 2, 3] of: <span class="hljs-literal">int</span>;
    <span class="hljs-comment">// ... to "compact" Java-like syntax.</span>
    <span class="hljs-literal">list</span>&lt;<span class="hljs-literal">int</span>&gt; a3 &lt;- [1, 2, 3];

    <span class="hljs-comment">// The declaration of a default size/value in containers is now working correctly</span>
    <span class="hljs-literal">list</span>&lt;<span class="hljs-literal">float</span>&gt; f &lt;- list_with(2000,0.0);

    <span class="hljs-comment">// Functions can be declared using the regular facet "-&gt;" / "function:" </span>
    <span class="hljs-literal">int</span> b1 -&gt; { 100 + length(a1) };
    <span class="hljs-literal">int</span> b2 function: { 100 + length(a1) };
    <span class="hljs-comment">// ... or using a block (like a statement -- note the absence of semi-column at the end)</span>
    <span class="hljs-literal">int</span> b3 {
        100 + length(a1)
    }
    state first_state initial: true {
    <span class="hljs-comment">//...</span>

    }
    init {
        create species0 number: 20;
    }
    

    <span class="hljs-comment">/**
     * UNITS
     */</span>
<span class="hljs-comment">// The usage of units is improved ( "#" being replaced by "°"), and they can be combined</span>
    <span class="hljs-literal">float</span> c &lt;- 10 °meter;
    <span class="hljs-literal">float</span> speed &lt;- 10 °meter / °sec;

    <span class="hljs-comment">// Attributes can (finally!) be named after unit names</span>
    <span class="hljs-literal">float</span> meter &lt;- 10.0;

    <span class="hljs-comment">// Some mathematical constants have been introduced alongside units</span>
    <span class="hljs-literal">float</span> pi_4 &lt;- °pi / 4;
    <span class="hljs-literal">float</span> e &lt;- °e;

    <span class="hljs-comment">/**
      * ACTIONS
      */</span>
    <span class="hljs-comment">// Actions can also be declared in different ways. Classic:</span>
    action dummy1 type: <span class="hljs-literal">list</span> of: <span class="hljs-literal">int</span> {
        arg a type: <span class="hljs-literal">int</span> default: 100;
        arg b type: <span class="hljs-literal">float</span>;
        return [a, <span class="hljs-literal">int</span>(b)];
    }
    <span class="hljs-comment">// Semi-classic (prefixed by the type)</span>
    <span class="hljs-literal">list</span> dummy2 of: <span class="hljs-literal">int</span> {
        arg a type: <span class="hljs-literal">int</span> default: 100;
        arg b type: <span class="hljs-literal">float</span>;
        return [a, <span class="hljs-literal">int</span>(b)];
    }
    <span class="hljs-comment">//Compact</span>
    <span class="hljs-literal">list</span>&lt;<span class="hljs-literal">int</span>&gt; dummy1 (<span class="hljs-literal">int</span> a &lt;- 100, <span class="hljs-literal">float</span> b) {
        return [a, <span class="hljs-literal">int</span>(b)];
    }

    <span class="hljs-comment">// An action that returns nothing can still be called "action"</span>
    action dummy_void {
        write <span class="hljs-string">"dummy_void"</span>;
    }

    <span class="hljs-comment">/**
     * DEALING WITH VARIABLES
     */</span>
    <span class="hljs-class">reflex <span class="hljs-title">variables</span> </span>{

    <span class="hljs-comment">// Temporary variables can use the same syntax as attributes. The classic form:</span>
        <span class="hljs-comment">//let name: t1 type: int value: length(a1);</span>
        <span class="hljs-comment">// is equivalent to the more compact one:</span>
        <span class="hljs-literal">int</span> t2 &lt;- length(a1);

        <span class="hljs-comment">// Assigning a value to variables is also sporting a new syntax </span>
        set t2 value: 100;
        <span class="hljs-comment">// ... can be replaced by </span>
        set t2 &lt;- 100;
        <span class="hljs-comment">// ... or even by</span>
        t2 &lt;- 100;

        <span class="hljs-comment">// Species can now act as direct containers of their agents..</span>
        <span class="hljs-literal">list</span>&lt;species0&gt; spec_with_location &lt;- species0 select (each.location = { 0, 0 });
        species0 agent0 &lt;- species0[10];
        write <span class="hljs-literal">string</span>(agent0);

        <span class="hljs-comment">// ...  and agents as direct containers of their attributes (mimicking the internal attributes map). This "virtual map" will now contain, in addition to the attributes, </span>
        <span class="hljs-comment">// all the variables loaded from CSV, SQL or shape files (some stored in the agent itself, others in the shape).</span>
        agent0[<span class="hljs-string">"departure"</span>] &lt;- { 0, 0 };
        write <span class="hljs-literal">string</span>(agent0);

        <span class="hljs-comment">// Keys are not necessarily strings, by the way ! A warning is emitted in such cases, but it is just a warning.</span>
        agent0[0] &lt;- 0;

        <span class="hljs-comment">// Accesses can be combined</span>
        species0[10].name &lt;- <span class="hljs-string">"A new name"</span>; <span class="hljs-comment">// which is equivalent to (spec at 10).name = "A new name";</span>

        <span class="hljs-comment">// Points can be used (with or without curly parentheses) to access agents in species</span>
        species0 agent1 &lt;- species0[10, 10]; <span class="hljs-comment">// returns the agent closest to point {10,10} for a "regular" species</span>
        <span class="hljs-comment">// The behavior is a bit tweaked for grids, to allow for a "natural" access</span>
        my_<span class="hljs-class">grid <span class="hljs-title">cell0</span> &lt;- <span class="hljs-title">my_grid</span>[10, 10]; // <span class="hljs-title">Here</span>, <span class="hljs-title">it</span> <span class="hljs-title">is</span> <span class="hljs-title">the</span> <span class="hljs-title">cell</span> <span class="hljs-title">at</span> </span>{10, 10} in the <span class="hljs-literal">matrix</span> of cells

        <span class="hljs-comment">// Shapes also act as containers of CVS/Shapefile attributes (in case they are loaded without being attributed to an agent), as well as 3D properties (for the display).</span>
        agent0.name &lt;- <span class="hljs-literal">string</span>(agent0.shape[<span class="hljs-string">"ID"</span>]);
        <span class="hljs-literal">geometry</span> geom &lt;- square(100);
        geom[<span class="hljs-string">"type"</span>] &lt;- <span class="hljs-string">"cube"</span>;
        
        
        <span class="hljs-comment">// All these attributes can be accessed using the casting of agents to map</span>
        write <span class="hljs-literal">string</span>(<span class="hljs-literal">map</span>(agent0));

        <span class="hljs-comment">//This access can be used everywhere, easing the use of shape files (and data files in general)</span>
        <span class="hljs-literal">list</span>&lt;<span class="hljs-literal">geometry</span>&gt; shapes &lt;- <span class="hljs-literal">list</span>&lt;<span class="hljs-literal">geometry</span>&gt;(<span class="hljs-literal">file</span>(<span class="hljs-string">"something.shp"</span>));

        <span class="hljs-comment">// If we suppose val1, val2, etc. are defined in the shape file</span>
        <span class="hljs-literal">float</span> max &lt;- min(shapes collect <span class="hljs-literal">float</span>(each[<span class="hljs-string">"val1"</span>]));

        <span class="hljs-comment">//To allow for an easier access in case the modeler only uses agents, agents' attributes can "pass through" towards their shape's attributes </span>
        <span class="hljs-comment">//(in case the same attribute has not been defined in the agent, of course)</span>
        create species0 from: shapes;
        max &lt;- min(species0 collect <span class="hljs-literal">float</span>(each[<span class="hljs-string">"val1"</span>])); <span class="hljs-comment">// equivalent to each.shape["val1"]. </span>
        <span class="hljs-comment">//This last sentence only works, however, for *reading* values.</span>
        any(species0)[<span class="hljs-string">"val1"</span>] &lt;- 100; <span class="hljs-comment">// will result in the creation of a new attribute in the agent (not in its shape)</span>
        any(species0).shape[<span class="hljs-string">"val1"</span>] &lt;- 100; <span class="hljs-comment">// will be correct in that case</span>

        <span class="hljs-comment">// Container variables have seen their usability clearly improved </span>
        <span class="hljs-literal">map</span> m &lt;- <span class="hljs-literal">map</span>([]);
        <span class="hljs-literal">list</span>&lt;<span class="hljs-literal">int</span>&gt; l &lt;- [1, 2, 3, 4, 5];

        <span class="hljs-comment">// Adding a value</span>
        add 1 to: l;
        <span class="hljs-comment">// ... can now be written</span>
        l &lt;+ 1;

        <span class="hljs-comment">// Removing a value</span>
        remove 1 from: l;
        remove <span class="hljs-string">"type"</span> from: geom;

        <span class="hljs-comment">// ... can now be written</span>
        l &gt;- 1;
        geom &gt;- <span class="hljs-string">"type"</span>;
        any(species0)[] &gt;- <span class="hljs-string">"name"</span>; <span class="hljs-comment">// removes the "name" attribute from a random agent. Can be dangerous in some cases... </span>

        <span class="hljs-comment">// Setting/putting a value</span>
        put <span class="hljs-string">"a"</span> at: 'key' in: m;
        put 1 at: 0 in: l;
        <span class="hljs-comment">// ... can now be written</span>
        m['key'] &lt;- <span class="hljs-string">"a"</span>;
        l[0] &lt;- 1;
        <span class="hljs-literal">list</span>&lt;<span class="hljs-literal">list</span>&gt; ll &lt;- [];
        ll &lt;+ []; <span class="hljs-comment">// [[]]</span>
        ll[0] &lt;+ 10; <span class="hljs-comment">// [[10]]</span>

    }

    <span class="hljs-comment">// TODO Species can now be written within the "global" section (to enforce the idea that the top-level species are indeed contained in the world)</span>
    <span class="hljs-class">species <span class="hljs-title">inside_global</span> </span>{
    }

    <span class="hljs-comment">/**
      * INVOCATION OF ACTIONS
      */</span>
    <span class="hljs-class">reflex <span class="hljs-title">calling_actions</span> </span>{
    <span class="hljs-comment">// IN IMPERATIVE MODE (i.e. in a statement)</span>
    <span class="hljs-comment">// The classic way</span>
        do dummy1 with: [a::10, b::100.0];

        <span class="hljs-comment">// Another by distributing the arguments</span>
        do dummy1 a: 10 b: 100.0;

        <span class="hljs-comment">// The new alternative one </span>
        do dummy1(a: 10, b: 100.0);
        ask any(species1) {
            do goto(target: { 10, 10 }, speed: 100);
        }
        <span class="hljs-comment">// ... which has been introduced to unify the functional/imperative use of actions.</span>

        <span class="hljs-comment">// And finally the new functional way, probably reserved to simple calls (as all the arguments must be passed).</span>
        do dummy1(10, 100.0);

        <span class="hljs-comment">// IN FUNCTIONAL MODE (i.e. as part of expressions)</span>
        <span class="hljs-comment">// The "classic" way of calling actions. Note that in that case, dummy1 is used like a binary operator (callee on the left, argument map on the right)</span>
        <span class="hljs-literal">list</span> d1 &lt;- self dummy1 [a::10, b::100.0];

        <span class="hljs-comment">// First improvement, argument maps can now be simplified, which results in a functional syntax with named arguments</span>
        <span class="hljs-literal">list</span> d2 &lt;- self dummy1 (b: 100.0); <span class="hljs-comment">// a is not passed as it has a default value.</span>

        <span class="hljs-comment">// To improve the readability of this way of calling actions, the dotted notation is now allowed as well </span>
        <span class="hljs-literal">list</span> d3 &lt;- self.dummy1(a: 100, b: 100.0);
        <span class="hljs-literal">float</span> s &lt;- any(species1).compute_speed_using_an_action(max: 100);

        <span class="hljs-comment">// Finally, the functional syntax is also introduced. In that case, all the arguments need to be passed as they are not named.</span>
        <span class="hljs-comment">// This unifies the way of calling operators and actions furthermore. </span>

        <span class="hljs-comment">// The action can be called as a n_ary operator, and in that case, the callee is implicitely the agent that executes the call</span>
        <span class="hljs-literal">list</span> d4 &lt;- dummy1(10, 100.0);

        <span class="hljs-comment">// And it can also be called using the "dotted" syntax, in which case the callee needs to be explicit (can be "self" of course)</span>
        <span class="hljs-literal">path</span> p &lt;- world.move(100, 45, shape); <span class="hljs-comment">// speed, heading, bounds</span>


        <span class="hljs-comment">/**
         *  As a summary, the syntaxes kept for future developments of models will likely be: 
         */</span>

<span class="hljs-comment">// CALLING WITH NAMED ARGUMENTS + OPTIONAL DOTTED SYNTAX IN EXPRESSIONS + IMPLICIT CALLEE IN CASE OF SELF</span>
        <span class="hljs-comment">// This method is convenient as it allows to pass only some arguments (if defaults are defined, which is implicitely the case in primitives), </span>
        <span class="hljs-comment">// but also to pass them in any order</span>
        do wander(speed: 100, amplitude: 10);
        <span class="hljs-literal">path</span> p1 &lt;- <span class="hljs-literal">path</span>(self.wander(amplitude: 10, speed: 100));
        <span class="hljs-literal">path</span> p2 &lt;- <span class="hljs-literal">path</span>(self wander (speed: 100, bounds: square(10)));
        <span class="hljs-literal">path</span> p3 &lt;- <span class="hljs-literal">path</span>(wander(speed: 100));
        <span class="hljs-literal">path</span> p4 &lt;- <span class="hljs-literal">path</span>(wander());

        <span class="hljs-comment">// CALLING WITH COMPLETE ARGUMENTS + OPTIONAL DOTTED SYNTAX IN EXPRESSIONS + IMPLICIT CALLEE IN CASE OF SELF</span>
        <span class="hljs-comment">// This method is convenient as it follows the functional syntax of operators and then allows to declare "quasi-operators" in species, even to redefine existing ones.</span>
        do wander(100, 100, self.shape); <span class="hljs-comment">// speed, amplitude, bounds as defined in primitive wander</span>
        <span class="hljs-literal">int</span> d5 &lt;- self.max(10, 100);
        <span class="hljs-literal">int</span> d6 &lt;- self max (10, 100);
        <span class="hljs-literal">int</span> d7 &lt;- max(10, 100);
        <span class="hljs-literal">list</span> others &lt;- filter(species1);

        <span class="hljs-comment">// As a side note, the new syntax for arguments maps is not only usable in action calls, but also in create, for instance</span>
        create species0 with: (location: { 100, 100 }, name: <span class="hljs-string">""</span>);
    }

    <span class="hljs-comment">// The ternary operator "(condition) ? statement_if_condition_true : statement_if_condition_false" can be used as follow :</span>
    <span class="hljs-literal">int</span> max (<span class="hljs-literal">int</span> i, <span class="hljs-literal">int</span> j) {
        return i &gt; j ? i : j;
    }

    <span class="hljs-literal">list</span>&lt;<span class="hljs-literal">agent</span>&gt; filter (<span class="hljs-literal">container</span>&lt;<span class="hljs-literal">agent</span>&gt; my_agents) {
        return my_agents where (each.location = nil);
    }

    <span class="hljs-comment">/**
      * USE OF OPERATORS 
      */</span>
    <span class="hljs-class">reflex <span class="hljs-title">operators</span> </span>{

    <span class="hljs-comment">// All the operators can now be written using a function-like form</span>
    <span class="hljs-comment">// It is true for unary operators (as before)</span>
        <span class="hljs-literal">bool</span> a &lt;- flip(0.4);
        <span class="hljs-comment">// .. but also for binary ones (in addition to the classic way)</span>
        <span class="hljs-literal">int</span> b &lt;- div(100, 23) + 100 div 23;
        <span class="hljs-literal">geometry</span> c1 &lt;- union(square(1), circle(10));
        <span class="hljs-comment">// The only exception to this rule is that of the built-in operators (like "and"/"or") and the ones whose names are not alphanumeric (like "+")</span>

        <span class="hljs-comment">// The big news is that operators are now allowed to be written using any number of parameters (not 1 or 2)</span>
        <span class="hljs-comment">// Here is an example with the "between" operator (written specially in Java to test this feature)</span>
        <span class="hljs-comment">// @operator(value = "between", can_be_const = true)</span>
        <span class="hljs-comment">// public static Boolean between(final Integer a, final Integer inf, final Integer sup) {</span>
        <span class="hljs-comment">//      if ( inf &gt; sup ) { return false; }</span>
        <span class="hljs-comment">//      return a &gt;= sup ? false : a &gt; inf; </span>
        <span class="hljs-comment">// }</span>
        <span class="hljs-literal">bool</span> e1 &lt;- between(5, 1, 10);
    }
    <span class="hljs-comment">/**
      * DEFINITION OF ASPECTS
      */</span>
    aspect default {
    <span class="hljs-comment">// draw now accepts any kind of arguments and decides what to do based on the type of the argument</span>
        draw circle(1);
        draw name;
        draw <span class="hljs-literal">file</span>(<span class="hljs-string">"image.jpg"</span>);

        <span class="hljs-comment">// special units (that take a value in the drawing scope) have been introduced to allow for a better control of the display</span>
        <span class="hljs-comment">// This statement will draw a circle of radius 10 pixels, whatever the level of zoom and size of the display</span>
        draw circle(10 °px);
        draw <span class="hljs-string">"Display dimensions: "</span> + °display_width + <span class="hljs-string">" "</span> + °display_height;
    }

}

<span class="hljs-comment">/** Species can "mirror" a list of agents (or another species). That is, their population is dynamically computed after the list or species mirrored.
* Their instances, which are actually "proxy" agents, possess an attribute called "target" that points towards the agent they mirror. Very useful for building graphs, for instance.
* The update of the population tries to preserve, as much as possible, the existing mapping (that is, proxy agents do not change targets if they do not die or disappear from the list) */</span>
<span class="hljs-class">species <span class="hljs-title">species0</span> </span>{
    <span class="hljs-literal">float</span> speed &lt;- <span class="hljs-literal">float</span>(rnd(1000));
}

<span class="hljs-class">species <span class="hljs-title">species1</span> <span class="hljs-title">mirrors</span>: <span class="hljs-title">species0</span> <span class="hljs-title">skills</span>: [<span class="hljs-title">moving</span>] </span>{
    <span class="hljs-literal">point</span> location update: target.location + { 10, 10 };
    <span class="hljs-literal">float</span> speed1 update: self compute_speed_using_an_action (); <span class="hljs-comment">// No parameter as "max" is defaulted</span>
    <span class="hljs-literal">float</span> speed2 update: compute_speed_using_a_functional_attribute;
    <span class="hljs-literal">float</span> compute_speed_using_a_functional_attribute {
        speed of target
    }
    <span class="hljs-literal">float</span> compute_speed_using_an_action (<span class="hljs-literal">int</span> max &lt;- 100) {
        return min([max, <span class="hljs-literal">int</span>(speed of target)]);
    }

    init {
        write <span class="hljs-string">"I am "</span> + self.name + <span class="hljs-string">" and my target is "</span> + target.name;
    }

}

<span class="hljs-class">grid <span class="hljs-title">my_grid</span> <span class="hljs-title">width</span>: 100 <span class="hljs-title">height</span>: 100 </span>{
}

<span class="hljs-class">experiment <span class="hljs-title">exp1</span> <span class="hljs-title">type</span>: <span class="hljs-title">gui</span> </span>{
    output {
        <span class="hljs-class">display <span class="hljs-title">Display</span> <span class="hljs-title">type</span>: <span class="hljs-title">opengl</span> </span>{
        <span class="hljs-comment">// Layers include a new keyword, "graphics", that allows to draw arbitrary shapes using the syntax found in the aspects of species</span>
        <span class="hljs-comment">// The same capability will be soon added to species/agents layers (in order to define on-the-fly aspects without changing the species itself)</span>
            graphics 'G' {
                draw sphere(10) at: { 50, 50 };
                <span class="hljs-keyword">if</span> (true) {
                    draw <span class="hljs-string">"true"</span>;
                } else {
                    draw <span class="hljs-string">"false"</span>;
                }

            }

        }

    }

}
</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/gama-logo.png" alt="GAMA-Platform" width="66" height="58"/></a><div><h5>Networks</h5><a href="https://www.youtube.com/channel/UCWJ1kWGDDI-9u2f2uD0gcaQ" target="_blank"><i class="fab fa-youtube"></i> Youtube</a><a href="https://www.linkedin.com/company/gama-platform" target="_blank"><i class="fab fa-linkedin"></i> LinkedIn</a><a href="https://twitter.com/gamaplatform" target="_blank"><i class="fab fa-twitter"></i> Twitter</a><a href="https://www.facebook.com/GamaPlatform/" target="_blank"><i class="fab fa-facebook"></i> Facebook</a></div><div><h5>Mailing list</h5><a href="https://groups.google.com/forum/#!forum/gama-platform" target="_blank"><i class="fas fa-envelope"></i> For Users<br/>gama-platform@googlegroups.com</a><a href="https://groups.google.com/forum/#!forum/gama-dev" target="_blank"><i class="fas fa-envelope"></i> For Developers<br/>gama-dev@googlegroups.com</a></div><div><h5>Ecosystem</h5><a href="https://github.com/gama-platform/gama"><i class="fab fa-github"></i> GitHub Gama</a><a href="https://github.com/gama-platform/gama.experimental"><i class="fas fa-puzzle-piece"></i> Gama Experimental Plugins</a><a href="https://github.com/gama-platform/gama.models.experimental"><i class="fas fa-scroll"></i> Gama Experimental Models</a></div></section><section class="copyright">Copyright © 2019 GAMA-Platform</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: 'undefined',
                indexName: 'undefined',
                inputSelector: '#search_input_react'
              });
            </script></body></html>