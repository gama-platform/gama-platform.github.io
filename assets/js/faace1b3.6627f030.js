"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[80955],{94823:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>r});const i=JSON.parse('{"id":"IncrementalModel_step7","title":"7. Differential Equations","description":"This step illustrates how to use differential equations.","source":"@site/versioned_docs/version-1.8.1/IncrementalModel_step7.md","sourceDirName":".","slug":"/IncrementalModel_step7","permalink":"/wiki/1.8.1/IncrementalModel_step7","draft":false,"unlisted":false,"editUrl":"https://github.com/gama-platform/gama/wiki/IncrementalModel_step7/_edit","tags":[],"version":"1.8.1","frontMatter":{"title":"7. Differential Equations"},"sidebar":"tuto","previous":{"title":"6. Multi-Level","permalink":"/wiki/1.8.1/IncrementalModel_step6"},"next":{"title":"Luneray\'s flu","permalink":"/wiki/1.8.1/LuneraysFlu"}}');var l=t(74848),o=t(28453);const a={title:"7. Differential Equations"},s=void 0,d={},r=[{value:"Formulation",id:"formulation",level:2},{value:"Model Definition",id:"model-definition",level:2},{value:"global variables",id:"global-variables",level:3},{value:"building",id:"building",level:3},{value:"Complete Model",id:"complete-model",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.p,{children:"This step illustrates how to use differential equations."}),"\n",(0,l.jsx)(n.h2,{id:"formulation",children:"Formulation"}),"\n",(0,l.jsxs)(n.p,{children:["We are interested in the spreading of the disease inside the buildings. In order to model it, we will use ",(0,l.jsx)(n.a,{href:"Equations",children:"differential equations"}),". So, we will need to:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Add two global variables to define the building epidemic properties (",(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"beta"})}),") and numerical integration parameter (",(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"h"})}),")."]}),"\n",(0,l.jsxs)(n.li,{children:["Add new variables for the buildings (",(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"I"})}),", ",(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"S"})}),", ",(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"T"})}),", ",(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"t"})}),", ",(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"I_to1"})}),") to manage epidemic;"]}),"\n",(0,l.jsx)(n.li,{children:"Define differential equations for disease spreading inside buildings."}),"\n",(0,l.jsx)(n.li,{children:"Add one behavior for buildings for the spreading of the disease."}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.img,{alt:"Incremental model 7: final step introducing a mathematical model for disease spread in buildings.",src:t(44472).A+"",width:"1612",height:"831"})}),"\n",(0,l.jsx)(n.h2,{id:"model-definition",children:"Model Definition"}),"\n",(0,l.jsx)(n.h3,{id:"global-variables",children:"global variables"}),"\n",(0,l.jsxs)(n.p,{children:["We define two new global variables used in the disease spreading dynamic inside the buildings: (i) ",(0,l.jsx)(n.code,{children:"beta"})," is the contamination rate,  and ",(0,l.jsx)(n.code,{children:"h"})," is the integration step (used in the ",(0,l.jsx)(n.code,{children:"solve"})," statement)."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"global  {\n    ...\n    float beta <- 0.01;\n    float h <- 0.1;\n    ...\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"building",children:"building"}),"\n",(0,l.jsx)(n.p,{children:"In order to define the disease spread dynamics, we define several variables that will be used by the differential equations:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"I"})}),": float, number of people infected in the building."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"S"})}),": float, number of people not infected in the building."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"T"})}),": float, the total number of people in the building."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"t"})}),": float, the current time of the equation system integration."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"I_to1"})}),": float, the remaining number of people infected (float number lower between 0 and 1 according to the differential equations)."]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"species building {\n    ...\n    float I;\n    float S;\n    float T;\n    float t;   \n    float I_to1; \n    ...\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Then, we define the differential equations system that will be used for the disease spreading dynamic. Note that to define a differential equation system we use the block ",(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"equation"})})," + name. These equations are the classic ones used by SI mathematical models."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"species building {\n    ....\n    equation SI{ \n\tdiff(S,t) = (- beta * S * I / T) ;\n\tdiff(I,t) = (  beta * S * I / T) ;\n    }\n    ...\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["At last, we define a new reflex for the building called ",(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"epidemic"})})," that will be activated only when there is someone inside the building. This reflex first computes the number of people inside the building (",(0,l.jsx)(n.code,{children:"T"}),"), then the number of not infected people (",(0,l.jsx)(n.code,{children:"S"}),") and finally the number of infected ones (",(0,l.jsx)(n.code,{children:"I"}),")."]}),"\n",(0,l.jsxs)(n.p,{children:["If there is at least one people infected and one people not infected, the differential equations is integrated (according to the integration step value ",(0,l.jsx)(n.code,{children:"h"}),") with the method Runge-Kutta 4 to compute the new value of infected people. We then sum the old value of ",(0,l.jsx)(n.code,{children:"I_to1"})," with the number of people newly infected (this value is a float and not an integer). Finally, we cast this value as an integer, ask the corresponding number of not infected people to become infected, and decrement this integer value to ",(0,l.jsx)(n.code,{children:"I\\_to1"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"species building {\n    ...\n    reflex epidemic when: nb_total > 0 {\n\tT <- float(nb_total);\n\tS <- float(nb_total - nb_infected);\n\tI <- T - S;\n\tfloat I0 <- I;\n\tif (I > 0 and S > 0) {\n\t    solve SI method: #rk4 step_size: h;\n\t    I_to1 <- I_to1 + (I - I0);\n\t    int I_int <- min([int(S), int(I_to1)]);\n\t    I_to1 <- I_to1 - I_int;\n\t    ask (I_int among (people_in_building where (!each.is_infected))) {\n\t\tis_infected <- true;\n\t    }\n\t}\n    }\n    ...\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"complete-model",children:"Complete Model"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:'/**\n* Name: Differential Equation\n* Author: GAMA Team\n* Description: 7th part of the tutorial : Incremental Model\n* Tags: tutorial, chart, graph, 3d, light, multi-Level, equation\n*/\nmodel model7\n\nglobal {\n    int nb_people <- 500;\n    float agent_speed <- 5.0 #km / #h;\n    float step <- 1 #minutes;\n    float infection_distance <- 2.0 #m;\n    float proba_infection <- 0.05;\n    int nb_infected_init <- 5;\n    file roads_shapefile <- file("../includes/road.shp");\n    file buildings_shapefile <- file("../includes/building.shp");\n    geometry shape <- envelope(roads_shapefile);\n    graph road_network;\n    float staying_coeff update: 10.0 ^ (1 + min([abs(current_date.hour - 9), abs(current_date.hour - 12), abs(current_date.hour - 18)]));\n    float beta <- 0.01;\n    float h <- 0.1;\n    list<people_in_building> list_people_in_buildings update: (building accumulate each.people_in_building);\n    int nb_people_infected <- nb_infected_init update: (people + list_people_in_buildings) count (each.is_infected);\n    int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n    bool is_night <- true update: current_date.hour < 7 or current_date.hour > 20;\n    float infected_rate update: nb_people_infected / nb_people;\n\n    init {\n\tcreate road from: roads_shapefile;\n\troad_network <- as_edge_graph(road);\n\tcreate building from: buildings_shapefile;\n\tcreate people number: nb_people {\n\t    speed <- agent_speed;\n\t    building bd <- one_of(building);\n\t    location <- any_location_in(bd);\n\t}\n\n\task nb_infected_init among people {\n\t    is_infected <- true;\n\t}\n    }\n\n    reflex end_simulation when: infected_rate = 1.0 {\n\tdo pause;\n    }\n}\n\nspecies people skills: [moving] {\n    bool is_infected <- false;\n    point target;\n    int staying_counter;\n\n    reflex move when: target != nil {\n\tdo goto target: target on: road_network;\n\tif (location = target) {\n\t    target <- any_location_in(one_of(building));\n\t    target <- nil;\n\t    staying_counter <- 0;\n\t}\n    }\n\n    reflex infect when: is_infected {\n\task people at_distance infection_distance {\n\t    if flip(proba_infection) {\n\t\tis_infected <- true;\n\t    }\n\t}\n    }\n\n    aspect circle {\n\tdraw circle(5) color: is_infected ? #red : #green;\n    }\n\n    aspect sphere3D {\n\tdraw sphere(3) at: {location.x, location.y, location.z + 3} color: is_infected ? #red : #green;\n    }\n}\n\nspecies road {\n    geometry display_shape <- shape + 2.0;\n\n    aspect default {\n\tdraw display_shape color: #black depth: 3.0;\n    }\n}\n\nspecies building {\n    int nb_infected <- 0 update: self.people_in_building count each.is_infected;\n    int nb_total <- 0 update: length(self.people_in_building);\n    float height <- rnd(10 #m, 20 #m);\n    float I;\n    float S;\n    float T;\n    float t;\n    float I_to1;\n\n    species people_in_building parent: people schedules: [] { }\n\n    reflex let_people_leave {\n\task self.people_in_building {\n\t    staying_counter <- staying_counter + 1;\n\t}\n\n\trelease people_in_building where (flip((each).staying_counter / staying_coeff)) as: people in: world {\n\t    target <- any_location_in(one_of(building));\n\t}\n    }\n\n    reflex let_people_enter {\n\tcapture (people inside self) where (each.target = nil) as: people_in_building;\n    }\n\n    equation SI {\n\tdiff(S, t) = (-beta * S * I / T);\n\tdiff(I, t) = (beta * S * I / T);\n    }\n\n    reflex epidemic when: nb_total > 0 {\n\tT <- float(nb_total);\n\tS <- float(nb_total - nb_infected);\n\tI <- T - S;\n\tfloat I0 <- I;\n\tif (I > 0 and S > 0) {\n\t    solve SI method: #rk4 step_size: h;\n\t    I_to1 <- I_to1 + (I - I0);\n\t    int I_int <- min([int(S), int(I_to1)]);\n\t    I_to1 <- I_to1 - I_int;\n\t    ask (I_int among (people_in_building where (!each.is_infected))) {\n\t\tis_infected <- true;\n\t    }\n\t}\n    }\n\n    aspect default {\n\tdraw shape color: nb_total = 0 ? #gray : (float(nb_infected) / nb_total > 0.5 ? #red : #green) border: #black depth: height;\n    }\n}\n\nexperiment main_experiment type: gui {\n    parameter "Infection distance" var: infection_distance;\n    parameter "Proba infection" var: proba_infection min: 0.0 max: 1.0;\n    parameter "Nb people infected at init" var: nb_infected_init;\n    output {\n\tmonitor "Current hour" value: current_date.hour;\n\tmonitor "Infected people rate" value: infected_rate;\n\tdisplay map_3D type: opengl {\n\t    light 1 color: (is_night ? 50 : 255);\n\t    image "../includes/soil.jpg";\n\t    species road;\n\t    species people aspect: sphere3D;\n\t    species building transparency: 0.5;\n\t}\n\tdisplay chart refresh: every(10 #cycles) {\n\t    chart "Disease spreading" type: series {\n\t\tdata "susceptible" value: nb_people_not_infected color: #green marker: false;\n\t\tdata "infected" value: nb_people_infected color: #red marker: false;\n\t    }\n\t}\n    }\n}\n'})})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},44472:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/incremental_model-81a4bac86041bbb55c67c907acae6bc7.jpg"},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var i=t(96540);const l={},o=i.createContext(l);function a(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);