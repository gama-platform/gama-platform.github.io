"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[21149],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>g});var l=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);t&&(l=l.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,l)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,l,a=function(e,t){if(null==e)return{};var n,l,a={},r=Object.keys(e);for(l=0;l<r.length;l++)n=r[l],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(l=0;l<r.length;l++)n=r[l],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=l.createContext({}),c=function(e){var t=l.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=c(e.components);return l.createElement(s.Provider,{value:t},e.children)},d="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return l.createElement(l.Fragment,{},t)}},u=l.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,h=o(e,["components","mdxType","originalType","parentName"]),d=c(n),u=a,g=d["".concat(s,".").concat(u)]||d[u]||f[u]||r;return n?l.createElement(g,i(i({ref:t},h),{},{components:n})):l.createElement(g,i({ref:t},h))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[d]="string"==typeof e?e:a,i[1]=o;for(var c=2;c<r;c++)i[c]=n[c];return l.createElement.apply(null,i)}return l.createElement.apply(null,n)}u.displayName="MDXCreateElement"},35719:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>s,default:()=>g,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var l=n(87462),a=n(63366),r=(n(67294),n(3905)),i=["components"],o={"^title":"HydrologicaModel"},s=void 0,c={unversionedId:"HydrologicaModel",id:"HydrologicaModel",title:"HydrologicaModel",description:"Path: Library models/Toy Models/Flood Simulation/models/Hydrological Model.gaml",source:"@site/../docs/HydrologicaModel.md",sourceDirName:".",slug:"/HydrologicaModel",permalink:"/wiki/next/HydrologicaModel",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/HydrologicaModel/_edit",tags:[],version:"current",frontMatter:{"^title":"HydrologicaModel"}},h={},d=[],f={toc:d},u="wrapper";function g(e){var t=e.components,n=(0,a.Z)(e,i);return(0,r.kt)(u,(0,l.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("img",{width:"960",alt:"Annotation 2023-04-14 180134_HydrologicalModel",src:"https://user-images.githubusercontent.com/4437331/232097257-1eb0e670-4fc1-4b69-8bc0-98aae359bf34.png"}),(0,r.kt)("p",null,"Path: Library models/Toy Models/Flood Simulation/models/Hydrological Model.gaml"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'\n/**\n* Name: Hydrological Model\n* Author: Patrick Taillandier\n* Description: A model showing how to represent a flooding system with dykes and buildings. It uses \n*   a grid to discretize space, and has a 3D display. The water can flow from one cell to another considering \n*   the height of the cells, and the water pressure. It is also possible to delete dyke by clicking on one of them \n*   in the display.\n* Tags: shapefile, gis, grid, 3d, gui, hydrology\n*/\n\nmodel hydro\n\nglobal {\n    \n   //Shapefile for the river\n   file river_shapefile <- file("../includes/RedRiver.shp");\n   //Shapefile for the dykes\n   file dykes_shapefile <- file("../includes/Dykes.shp");\n   //Shapefile for the buildings\n   file buildings_shapefile <- file("../includes/Building.shp");\n   \n   //Data elevation file\n   file dem_file <- file("../includes/mnt50.asc");  \n   //Diffusion rate\n   float diffusion_rate <- 0.6;\n   //Height of the dykes\n   float dyke_height <- 15.0;\n   //Width of the dyke\n   float dyke_width <- 15.0;\n    \n   //Shape of the environment using the dem file\n   geometry shape <- envelope(dykes_shapefile);\n   \n   //List of the drain and river cells\n   list<cell> drain_cells;\n   list<cell> river_cells;\n   \n   \n  \n   float step <- 1#h;\n   \n   init {\n     //Initialization of the cells\n      do init_cells;\n     //Initialization of the water cells\n      do init_water;\n     //Initialization of the river cells\n     river_cells <- cell where (each.is_river);\n     //Initialization of the drain cells\n      drain_cells <- cell where (each.is_drain);\n     //Initialization of the obstacles (buildings and dykes)\n      do init_obstacles;\n      //Set the height of each cell\n      ask cell {\n         obstacle_height <- compute_highest_obstacle();\n         do update_color;\n      }\n   }\n   //Action to initialize the altitude value of the cell according to the dem file\n   action init_cells {\n      ask cell  {\n         altitude <- grid_value;\n         neighbour_cells <- (self neighbors_at 1) ;\n      }\n   }\n   //action to initialize the water cells according to the river shape file and the drain\n   action init_water {\n      geometry river <- geometry(river_shapefile);\n      ask cell overlapping river  {\n         water_height <- 10.0;\n         is_river <- true;\n         is_drain <- grid_y = matrix(cell).rows - 1;\n      }\n   }\n   //initialization of the obstacles (the buildings and the dykes)\n   action init_obstacles{\n      create buildings from: buildings_shapefile  {\n         do update_cells;\n      }\n      create dyke from: dykes_shapefile;\n      ask dyke  {\n          shape <-  shape + dyke_width;\n            do update_cells;\n      }\n   }\n   //Reflex to add water among the water cells\n   reflex adding_input_water {\n      float water_input <- rnd(100)/100;\n      ask river_cells {\n         water_height <- water_height + water_input;\n      }\n   }\n   //Reflex to flow the water according to the altitute and the obstacle\n   reflex flowing {\n      ask (cell sort_by ((each.altitude + each.water_height + each.obstacle_height))) {\n        already <- false;\n         do flow;\n      }\n   }\n   //Reflex to update the color of the cell\n   reflex update_cell_color {\n      ask cell  {\n         do update_color;\n      }\n   }\n   //Reflex for the drain cells to drain water\n   reflex draining {\n      ask drain_cells {\n         water_height <- 0.0;\n      }\n   }\n   \n}\n//Species which represent the obstacle\n   species obstacle  {\n      //height of the obstacle\n      float height min: 0.0;\n      //Color of the obstacle\n      rgb color;\n      //Pressure of the water\n      float water_pressure update: compute_water_pressure();\n      \n      //List of cells concerned\n      list<cell> cells_concerned ;\n      //List of cells in the neighbourhood \n      list<cell> cells_neighbours;\n      \n      //Action to compute the water pressure\n      float compute_water_pressure {\n        //If the obstacle doesn\'t have height, then there will be no pressure\n         if (height = 0.0) {\n            return 0.0;\n         } else {\n            //The leve of the water is equals to the maximul level of water in the neighbours cells\n            float water_level <- cells_neighbours max_of (each.water_height);\n            //Return the water pressure as the minimal value between 1 and the water level divided by the height\n            return min([1.0,water_level / height]);\n         } \n      }\n      \n      //Action to update the cells\n      action update_cells {\n        //All the cells concerned by the obstacle are the ones overlapping the obstacle\n         cells_concerned <- (cell overlapping self);\n            ask cells_concerned {\n            //Add the obstacles to the obstacles of the cell\n            add myself to: obstacles;\n            water_height <- 0.0;\n         }\n         //Cells neighbours are all the neighbours cells of the cells concerned\n         cells_neighbours <- cells_concerned + cells_concerned accumulate (each.neighbour_cells);\n         //The height is now computed\n         do compute_height();\n         if (height > 0.0) {   \n            //We compute the water pressure again\n            water_pressure <- compute_water_pressure();\n         } else {water_pressure <- 0.0;}\n      }\n      action compute_height;\n      aspect geometry {\n         int val <- int( 255 * water_pressure);\n         color <- rgb(val,255-val,0);\n         draw shape color: color depth: height*5 border: color;\n      }\n   }\n   //Species buildings which is derivated from obstacle\n   species buildings parent: obstacle schedules: [] {\n     //The building has a height randomly chosed between 2 and 10\n      float height <- 2.0 + rnd(8);\n   }\n   //Species dyke which is derivated from obstacle\n   species dyke parent: obstacle {\n    \n       int counter_wp <- 0;\n       int breaking_threshold <- 24;\n      \n      //Action to represent the break of the dyke\n       action break{\n         ask cells_concerned  {\n            do update_after_destruction(myself);\n         }\n         do die;\n      }\n      //Action to compute the height of the dyke as the dyke_height without the mean height of the cells it overlaps\n      action compute_height\n       {\n           height <- dyke_height - mean(cells_concerned collect (each.altitude));\n      \n      }\n      \n      //Reflex to break the dynamic of the water\n      reflex breaking_dynamic {\n        if (water_pressure = 1.0) {\n            counter_wp <- counter_wp + 1;\n            if (counter_wp > breaking_threshold) {\n                do break;\n            }\n        } else {\n            counter_wp <- 0;\n        }\n      }\n      //user command which allows the possibility to destroy the dyke for the user\n      user_command "Destroy dyke" action: break; \n   }\n   //Grid cell to discretize space, initialized using the dem file\n   grid cell file: dem_file neighbors: 8 frequency: 0  use_regular_agents: false use_individual_shapes: false use_neighbors_cache: false schedules: []  {\n      //Altitude of the cell\n      float altitude;\n      //Height of the water in the cell\n      float water_height <- 0.0 min: 0.0;\n      //Height of the cell\n      float height;\n      //List of the neighbour cells\n      list<cell> neighbour_cells ;\n      //Boolean to know if it is a drain cell\n      bool is_drain <- false;\n      //Boolean to know if it is a river cell\n      bool is_river <- false;\n      //List of all the obstacles overlapping the cell\n      list<obstacle> obstacles;\n      //Height of the obstacles\n      float obstacle_height <- 0.0;\n      bool already <- false;\n      \n      //Action to compute the highest obstacle among the obstacles\n      float compute_highest_obstacle {\n         if (empty(obstacles))\n         {\n            return 0.0; \n         } else {\n            return obstacles max_of(each.height);\n         }\n      }\n      //Action to flow the water \n      action flow {\n        //if the height of the water is higher than 0 then, it can flow among the neighbour cells\n         if (water_height > 0) {\n            //We get all the cells already done\n            list<cell> neighbour_cells_al <- neighbour_cells where (each.already);\n            //If there are cells already done then we continue\n            if (!empty(neighbour_cells_al)) {\n               //We compute the height of the neighbours cells according to their altitude, water_height and obstacle_height\n               ask neighbour_cells_al {height <- altitude + water_height + obstacle_height;}\n               //The height of the cell is equals to its altitude and water height\n               height <-  altitude +  water_height;\n               //The water of the cells will flow to the neighbour cells which have a height less than the height of the actual cell\n               list<cell> flow_cells <- (neighbour_cells_al where (height > each.height)) ;\n               //If there are cells, we compute the water flowing\n               if (!empty(flow_cells)) {\n                  loop flow_cell over: shuffle(flow_cells) sort_by (each.height){\n                     float water_flowing <- max([0.0, min([(height - flow_cell.height), water_height * diffusion_rate])]); \n                     water_height <- water_height - water_flowing;\n                     flow_cell.water_height <-flow_cell.water_height +  water_flowing;\n                     height <- altitude + water_height;\n                  }   \n               }\n            }\n         }\n         already <- true;\n      }  \n      //Update the color of the cell\n      action update_color { \n         int val_water <- 0;\n         val_water <- max([0, min([255, int(255 * (1 - (water_height / 12.0)))])]) ;  \n         color <- rgb([val_water, val_water, 255]);\n         grid_value <- water_height + altitude;\n      }\n      //action to compute the destruction of the obstacle\n      action update_after_destruction(obstacle the_obstacle){\n         remove the_obstacle from: obstacles;\n         obstacle_height <- compute_highest_obstacle();\n      }\n       \n   }\n\n\nexperiment Run type: gui {\n   parameter "Shapefile for the river" var:river_shapefile category:"Water data";\n   parameter "Shapefile for the dykes" var:dykes_shapefile category:"Obstacles";\n   parameter "Shapefile for the buildings" var:buildings_shapefile category:"Obstacles";\n   parameter "Height of the dykes" var:dyke_height category:"Obstacles";\n   parameter "Diffusion rate" var:diffusion_rate category:"Water dynamic";\n   output { \n   //layout vertical([0::5000,1::5000]) tabs:false editors: false;\n      display map type: 3d {\n         grid cell triangulation: true;\n         species buildings aspect: geometry refresh: false;\n         species dyke aspect: geometry ;\n      }\n      display chart_display refresh: every(24#cycles)  type: 2d  { \n         chart "Pressure on Dykes" type: series legend_font: font("Helvetica", 18)  label_font: font("Helvetica", 20, #bold)  title_font: font("Helvetica", 24, #bold){\n            data "Mean pressure on dykes " value: mean(dyke collect (each.water_pressure)) style: line color: #magenta  ;\n            data "Rate of dykes with max pressure" value: (dyke count (each.water_pressure = 1.0))/ length(dyke) style: line color: #red ;\n            data "Rate of dykes with high pressure" value: (dyke count (each.water_pressure > 0.5))/ length(dyke) style: line color: #orange ;\n            data "Rate of dykes with low pressure" value: (dyke count (each.water_pressure < 0.25))/ length(dyke) style: line color: #green ;\n         }\n      }\n   }\n}\n\n\n')))}g.isMDXComponent=!0}}]);