"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[96374],{53504:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"OptimizingModels","title":"Optimizing Models","description":"[//]: # (startConcept|optimizing_tips)","source":"@site/../docs/OptimizingModels.md","sourceDirName":".","slug":"/OptimizingModels","permalink":"/wiki/next/OptimizingModels","draft":false,"unlisted":false,"editUrl":"https://github.com/gama-platform/gama/wiki/OptimizingModels/_edit","tags":[],"version":"current","frontMatter":{"title":"Optimizing Models"},"sidebar":"main","previous":{"title":"Analysing code performance","permalink":"/wiki/next/AnalysingCodePerformance"},"next":{"title":"Multi-Paradigm Modeling","permalink":"/wiki/next/MultiParadigmModeling"}}');var i=n(74848),r=n(28453);const a={title:"Optimizing Models"},o=void 0,l={},c=[{value:"Scheduling",id:"scheduling",level:2},{value:"Grid",id:"grid",level:2},{value:"Optimization Facets",id:"optimization-facets",level:3},{value:"use_regular_agents",id:"use_regular_agents",level:4},{value:"use_individual_shapes",id:"use_individual_shapes",level:4},{value:"Parallel execution",id:"parallel-execution",level:3},{value:"Operators",id:"operators",level:2},{value:"List operators",id:"list-operators",level:3},{value:"first_with",id:"first_with",level:4},{value:"where / count",id:"where--count",level:4},{value:"Spatial operators",id:"spatial-operators",level:3},{value:"container of agents in <code>closest_to</code>, <code>at_distance</code>, <code>overlapping</code>, <code>inside</code>",id:"container-of-agents-in-closest_to-at_distance-overlapping-inside",level:4},{value:"Accelerate <strong><code>closest_to</code></strong> with a first spatial filtering",id:"accelerate-closest_to-with-a-first-spatial-filtering",level:4},{value:"Displays",id:"displays",level:2},{value:"shape",id:"shape",level:3},{value:"circle vs square / sphere vs cube",id:"circle-vs-square--sphere-vs-cube",level:3},{value:"OpenGL refresh facets",id:"opengl-refresh-facets",level:3},{value:"Manipulating containers and species",id:"manipulating-containers-and-species",level:2},{value:"parallel",id:"parallel",level:3},{value:"Iterating over containers",id:"iterating-over-containers",level:3},{value:"Big string manipulation",id:"big-string-manipulation",level:2},{value:"Threads",id:"threads",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"This page aims at presenting some tips to optimize the memory footprint or the execution time of a model in GAMA."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.em,{children:[(0,i.jsx)(t.strong,{children:"Note"}),": The optimizations presented here are only general ideas that work most of the time, but every model is different and sometimes those optimizations won't work or even produce worse execution time. It is thus highly recommended that you try them yourself on your setup and that you build test environment with the tools explained in the previous page (",(0,i.jsx)(t.a,{href:"AnalysingCodePerformance",children:"analysing code performance"}),") to make sure that they are useful ",(0,i.jsx)(t.strong,{children:"to your model"}),"."]})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.em,{children:"Note 2: Some previously known optimizations from GAMA 1.6.1 and above, have become obsolete because they have been included in the compiler. They have, then, been removed from this page. For instance, writing 'rgb(0,0,0)' is now compiled directly as '#black'."})}),"\n",(0,i.jsx)(t.h2,{id:"scheduling",children:"Scheduling"}),"\n",(0,i.jsxs)(t.p,{children:['If you have a species of agents that, once created, are not supposed to do anything more (i.e. no behavior, no reflex, their actions triggered by other agents, their attributes being simply read and written by other agents), such as a "data" grid, or agents representing a "background" (from a shape file, etc.), consider using the ',(0,i.jsx)(t.code,{children:"schedules: []"})," facet on the definition of their species. This trick allows to tell GAMA to not schedule any of these agents."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"grid my_grid height: 100 width: 100 schedules: []  {\n      ...\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"schedules"})," facet is dynamically computed (even if the agents are not scheduled), so, if you happen to define agents that only need to be scheduled every x cycles, or depending on a condition, you can also write ",(0,i.jsx)(t.code,{children:"schedules"})," to implement this. For instance, the following species will see its instances scheduled every 10 steps and only if a certain condition is met:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"species my_species schedules: (every 10) ? (condition ? my_species : []) : []  {\n     ...\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"In the same way, modelers can use the frequency facet to define when the agents of a species are going to be activated. By setting this facet to 0, the agents are never activated."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"species my_species frequency: 0 {\n     ...\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"grid",children:"Grid"}),"\n",(0,i.jsx)(t.h3,{id:"optimization-facets",children:"Optimization Facets"}),"\n",(0,i.jsx)(t.p,{children:"In this section, we present some facets that allow to optimize the use of grid (in particular in terms of memories). Note that all these facet can be combined (see the Life model from the Models library)."}),"\n",(0,i.jsx)(t.h4,{id:"use_regular_agents",children:"use_regular_agents"}),"\n",(0,i.jsx)(t.p,{children:'If false, then a special class of agents is used. This special class of agents used less memories but has some limitation: the agents cannot inherit from a "normal" species, they cannot have sub-populations, their name cannot be modified, etc.'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"grid cell width: 50 height: 50 use_regular_agents: false ;\n"})}),"\n",(0,i.jsx)(t.h4,{id:"use_individual_shapes",children:"use_individual_shapes"}),"\n",(0,i.jsx)(t.p,{children:"If false, then only one geometry is used for all agents. This facet allows to gain a lot of memory, but should not be used if the geometries of the agents are often activated (for instance, by an aspect)."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"grid cell width: 50 height: 50 use_individual_shapes: false ;\t\n"})}),"\n",(0,i.jsx)(t.h3,{id:"parallel-execution",children:"Parallel execution"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"grid"})," statement can also specify whether the agents of the grid are computed in parallel, using the facet ",(0,i.jsx)(t.code,{children:"parallel"}),". This could increase (depending on the computation) the execution time.\nFor more details about the pros and cons of doing so, please refer to the ",(0,i.jsx)(t.a,{href:"#parallel",children:"parallel"})," section."]}),"\n",(0,i.jsx)(t.h2,{id:"operators",children:"Operators"}),"\n",(0,i.jsx)(t.p,{children:"In GAMA, as in any other languages, some operators or order of execution of operators are more efficient than others. This section is dedicated to identify common mistakes and provide better alternative in the use of operators."}),"\n",(0,i.jsx)(t.h3,{id:"list-operators",children:"List operators"}),"\n",(0,i.jsx)(t.h4,{id:"first_with",children:"first_with"}),"\n",(0,i.jsxs)(t.p,{children:["It is sometimes necessary to randomly select an element of a list that verifies a given condition.\nMany modelers use the ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"one_of"})})," and the ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"where"})})," operators to do this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"bug one_big_bug <- one_of (bug where (each.size > 10));\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Whereas it is often more optimized to use the ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"shuffle"})})," operator to shuffle the list, then the ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"first_with"})})," operator to select the first element that verifies the condition:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"bug one_big_bug <- shuffle(bug) first_with (each.size > 10);\n"})}),"\n",(0,i.jsx)(t.h4,{id:"where--count",children:"where / count"}),"\n",(0,i.jsx)(t.p,{children:"It is quite common to want to count the number of elements of a list or a container that verify a condition.\nThe obvious to do it is:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"int n <- length(my_container where (each.size > 10));\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This will however create an intermediary list before counting it, and this operation can be time consuming if the number of elements is important. To alleviate this problem, GAMA includes an operator called ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"count"})})," that will count the elements that verify the condition by iterating directly on the container (no useless list created):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"int n <- my_container count (each.size > 10);\n"})}),"\n",(0,i.jsx)(t.h3,{id:"spatial-operators",children:"Spatial operators"}),"\n",(0,i.jsxs)(t.h4,{id:"container-of-agents-in-closest_to-at_distance-overlapping-inside",children:["container of agents in ",(0,i.jsx)(t.code,{children:"closest_to"}),", ",(0,i.jsx)(t.code,{children:"at_distance"}),", ",(0,i.jsx)(t.code,{children:"overlapping"}),", ",(0,i.jsx)(t.code,{children:"inside"})]}),"\n",(0,i.jsxs)(t.p,{children:["Several spatial query operators (such as ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"closest_to"})}),", ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"at_distance"})}),", ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"overlapping"})})," or ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"inside"})}),") allow to restrict the agents being queried to a container of agents. For instance, one can write:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"agent closest_agent <- a_container_containing_agents closest_to self;\n"})}),"\n",(0,i.jsx)(t.p,{children:"This expression is formally equivalent to :"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"agent closest_agent <- a_container_containing_agent with_min_of (each distance_to self);\n"})}),"\n",(0,i.jsxs)(t.p,{children:["But it is much faster ",(0,i.jsx)(t.strong,{children:"if your container is large"}),", as it will query the agents using a spatial index (instead of browsing through the whole container). Note that in some cases, when you have a small number of agents, the first syntax will be faster. The same applies to the other operators."]}),"\n",(0,i.jsx)(t.p,{children:"Now consider a very common case: you need to restrict the agents being queried, not to a container, but to a species (which, actually, acts as a container in most cases). For instance, you want to know which predator is the closest to the current agent. If we apply the pattern above, we would write:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"predator closest_predator <- predator with_min_of (each distance_to self);\n"})}),"\n",(0,i.jsx)(t.p,{children:"or"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"predator closest_predator <- list(predator) closest_to self;\n"})}),"\n",(0,i.jsxs)(t.p,{children:["But these two operators can be painfully slow if your species has many instances (even in the second form). In that case, always prefer using ",(0,i.jsx)(t.strong,{children:"directly"})," the species as the left member:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"predator closest_ predator <- predator closest_to self;\n"})}),"\n",(0,i.jsx)(t.p,{children:"Not only is the syntax clearer, but the speed gain can be phenomenal because, in that case, the list of instances is not used (we just check if the agent is an instance of the left species)."}),"\n",(0,i.jsx)(t.p,{children:"However, what happens if one wants to query instances belonging to 2 or more species? If we follow our reasoning, the immediate way to write it would be (if predator 1 and predator 2 are two species):"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"agent closest_agent <- (list(predator1) + list(predator2)) closest_to self; \n"})}),"\n",(0,i.jsx)(t.p,{children:"or, more simply:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"agent closest_agent <- (predator1 + predator2) closest_to self;\n"})}),"\n",(0,i.jsx)(t.p,{children:'The first syntax suffers from the same problem than the previous syntax: GAMA has to browse through the list (created by the concatenation of the species populations) to filter agents. The solution, then, is again to use directly the species, as GAMA is clever enough to create a temporary "fake" population out of the concatenation of several species, which can be used exactly like a list of agents, but provides the advantages of a species population (no iteration made during filtering).'}),"\n",(0,i.jsxs)(t.h4,{id:"accelerate-closest_to-with-a-first-spatial-filtering",children:["Accelerate ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"closest_to"})})," with a first spatial filtering"]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"closest_to"})})," operator can sometimes be slow if numerous agents are concerned by this query. If the modeler is just interested in a small subset of agents, it is possible to apply a first spatial filtering on the agent list by using the ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"at_distance"})})," operator."]}),"\n",(0,i.jsx)(t.p,{children:"For example, if the modeler wants first to do a spatial filtering of 10m:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"agent closest_agent <- (predator1 at_distance 10) closest_to self;\n"})}),"\n",(0,i.jsx)(t.p,{children:"To be sure to find an agent, the modeler can use a test statement:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"agent closest_agent <- (predator1 at_distance 10) closest_to self;\nif (closest_agent = nil) {closest_agent  <- predator1 closest_to self;}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"displays",children:"Displays"}),"\n",(0,i.jsx)(t.h3,{id:"shape",children:"shape"}),"\n",(0,i.jsxs)(t.p,{children:["It is quite common to want to display an agent as a circle or a square. A common mistake is to mix up the shape to draw and the geometry of the agent in the model. If the modeler just wants to display a particular shape, he/she should not modify the agent geometry (i.e. its ",(0,i.jsx)(t.code,{children:"shape"})," attribute, which is a point by default), but just specify the shape to draw in the agent aspect."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"species bug {\n     int size <- rnd(100);\n\t\n      aspect circle {\n          draw circle(2) color: #blue;\n      }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"circle-vs-square--sphere-vs-cube",children:"circle vs square / sphere vs cube"}),"\n",(0,i.jsx)(t.p,{children:'Note that in OpenGL (3D) and Java2D (2D), the two rendering subsystems used in GAMA, creating and drawing a circle geometry is more time consuming than creating and drawing a square (or a rectangle). In the same way, drawing a sphere is more time consuming than drawing a cube. Hence, if you want to optimize your model displays and if the rendering does not explicitly need "rounded" agents, try to use squares/cubes rather than circles/spheres.'}),"\n",(0,i.jsx)(t.h3,{id:"opengl-refresh-facets",children:"OpenGL refresh facets"}),"\n",(0,i.jsxs)(t.p,{children:["In OpenGL display, it is possible to specify that it is not necessary to refresh a layer with the facet ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"refresh"})}),". If in a species, the properties used for visualization (location, shape or color) are never modified, you can set ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"refresh"})})," to false. Example:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"display city_display_opengl type: opengl{\n     species building aspect: base refresh: false;\n     species road aspect: base refresh: false;\n     species people aspect: base;\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"manipulating-containers-and-species",children:"Manipulating containers and species"}),"\n",(0,i.jsx)(t.p,{children:"Manipulating containers (lists, maps etc.) and agents are usually the core of a model and the most critical parts of the code in terms of performances."}),"\n",(0,i.jsx)(t.h3,{id:"parallel",children:"parallel"}),"\n",(0,i.jsxs)(t.p,{children:["It is possible to execute the reflexes of agents of a species in parallel threads. This can greatly improve the execution time of a model as by default agents are executed one after another. To activate parallel execution of agents you just need to set the ",(0,i.jsx)(t.code,{children:"parallel"})," facet of the ",(0,i.jsx)(t.code,{children:"species"})," (or ",(0,i.jsx)(t.code,{children:"grid"}),") to true:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"species dummy_species parallel:true{\n\n}\ngrid my_grid parallel:true{\n\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note:"})," By default this option is not activated because we ",(0,i.jsx)(t.strong,{children:"cannot guaranty the reproducibility of an experiment"})," if it is. It implies that we do not know in advance which agent is going to be executed first, this also means that if your agents are meant to be executed in a certain order, this could break your model.\nTake for example this model where each cell of a grid has an effect on its neighbouring cells ,here disabling them, each disabled cell will be represented by the red color and enabled cells by the green color:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'model parallel\n\ngrid my_grid parallel:false width:5 height:5 {\n\t\n\tbool to_be_executed <- true;\n\trgb color <- #green update:to_be_executed ? #green : #red;\n\treflex cancel_neighbours {\n\t\tif to_be_executed{\n\t\t\twrite "I am cell \'" + name + "\' and my reflexes are executed";\n\t\t\tloop c over:neighbors{\n\t\t\t\tc.to_be_executed <- false;\n\t\t\t}\t\t\t\n\t\t}\n\t\tto_be_executed <- true; // we reset for the next cycle\n\t}\n}\n\nexperiment a {\n\t\n\toutput{\n\t\tdisplay main type:2d antialias:false{\t\t\t\n\t\t\tgrid my_grid border:#black;\n\t\t}\n\t\t\n\t}\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["With parallel set to ",(0,i.jsx)(t.code,{children:"false"})," (the default) the order of execution of each cell is always the same and can be predicted to yield this display after the first cycle:\n",(0,i.jsx)(t.img,{src:"https://github.com/user-attachments/assets/8f968b7c-930f-4f15-a03d-260432417a39",alt:"image"}),"\nBut if you change its value to ",(0,i.jsx)(t.code,{children:"true"})," you can end up with this:\n",(0,i.jsx)(t.img,{src:"https://github.com/user-attachments/assets/6a8c0f96-c71d-4a0f-bce4-bfef87cb7375",alt:"image"}),"\nAnd it can change every cycle (or not) and there's no way to know in advance how it's going to look."]}),"\n",(0,i.jsx)(t.h3,{id:"iterating-over-containers",children:"Iterating over containers"}),"\n",(0,i.jsx)(t.p,{children:"In gama there are multiple ways of iterating over containers and agents:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["the ",(0,i.jsx)(t.code,{children:"ask"})," statement to iterate over agents"]}),"\n",(0,i.jsxs)(t.li,{children:["the ",(0,i.jsx)(t.code,{children:"loop"})," statement to iterate over anything, with its multiple syntaxes:","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"times"})," iterates a certain number of times"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"over"})," iterates directly over a list"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"from"})," and ",(0,i.jsx)(t.code,{children:"to"})," provide an index to iterate in a range of values"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"until"})," iterates until a certain condition is met"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["the different container operators (such as ",(0,i.jsx)(t.code,{children:"collect"})," or ",(0,i.jsx)(t.code,{children:"where"}),") provide shortcuts for generic list manipulation tasks"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["In general the specialized operators (see ",(0,i.jsx)(t.a,{href:"OperatorsAA#containers-related-operators",children:"this page"})," in the documentation for the full list) are way more efficient, followed by ",(0,i.jsx)(t.code,{children:"ask"})," and the loop ",(0,i.jsx)(t.code,{children:"over"}),", then comes the other loop syntaxes.\nSo as a general rule of thumb you should ",(0,i.jsx)(t.strong,{children:"use as much as possible the container-related operators"})," instead of the generic ",(0,i.jsx)(t.code,{children:"loop"})," and ",(0,i.jsx)(t.code,{children:"ask"})," statements.\nHere is an example model that showcases the difference in execution time of the different methods to sum the value of a property of all the agents in the simulation:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'model accessinglistitems\n\nglobal{\n\tint nb_agents <- 50000;\t\n}\n\nspecies b{\n\t\n\tint v;\n\t\n\tinit {\n\t\tv <- rnd(0, 10);\n\t}\n}\n\nexperiment e {\n\n\tparameter "number of agents" var:nb_agents;\n\n\treflex fill_list_from_agents {\n\t\t\n\t\twrite "Start benchmarking with " + nb_agents + " agents";\n\t\t\n\t\t// we reset the agents\n\t\task b{\n\t\t\tdo die;\n\t\t}\n\t\tcreate b number:nb_agents;\n\t\t\n\t\tint s1 <- 0;\n\t\tbenchmark "sum with loop over" repeat:100{\n\t\t\ts1 <- 0;\n\t\t\tloop obj over:b{\n\t\t\t\ts1 <- s1 + obj.v;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint s2 <- 0;\n\t\tbenchmark "sum with loop from to" repeat:100{\n\t\t\tint to <- length(b)-1;\n\t\t\ts2 <- 0;\n\t\t\tloop i from:0 to:to{\n\t\t\t\ts2 <- s2 + b[i].v;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint s3 <- 0;\n\t\tbenchmark "sum with loop times" repeat:100{\n\t\t\tint to <- length(b);\n\t\t\tint i <- 0;\n\t\t\ts3 <- 0;\n\t\t\tloop times:to{\n\t\t\t\ts3 <- s3 + b[i].v;\n\t\t\t\ti <- i + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint s4 <- 0;\n\t\tbenchmark "sum with ask"  repeat:100{\n\t\t\ts4 <- 0;\n\t\t\task b{\n\t\t\t\ts4 <- s4 + v;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint s5 <- 0;\n\t\tbenchmark "sum with collect" repeat:100{\n\t\t\ts5 <- sum(b collect (each.v));\n\t\t}\n\t\t\n\t\t// we check that all methods yield the same result\n\t\tassert s1 = s2;\n\t\tassert s2 = s3;\n\t\tassert s3 = s4;\n\t\tassert s4 = s5;\n\t\t\n\t}\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"Which gives results similar to this:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:"https://github.com/user-attachments/assets/6baa35bb-0dc6-4957-bcc8-b59827c3545c",alt:"image"})}),"\n",(0,i.jsx)(t.h2,{id:"big-string-manipulation",children:"Big string manipulation"}),"\n",(0,i.jsx)(t.p,{children:"String manipulation, and especially concatenation (adding two strings together) is harmless for performances in normal condition, but once strings become big enough (thousands of characters), every operation becomes extremely costly. Moreover, the execution time of concatenation seem to be an exponential function of the size of the string.\nTake for example this model:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"model stringconcat\n\nexperiment test {\n\t\n\treflex concat {\n\t\tstring s;\n\t\tint nb_concat <- 100;\n\t\tloop times:nb_concat{\n\t\t\ts <- s + rnd(0,10);\n\t\t}\n\t\t\n\t}\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We are simply concatenating random digits into a string, ending up with a 100 character string.\nSo far so good, this is good enough and works flawlessly on most machines. Now change ",(0,i.jsx)(t.code,{children:"nb_concat"})," to ",(0,i.jsx)(t.code,{children:"100000"})," and the operation starts to be non-negligible (for example it takes more than half a second on my computer).\nWe can modify a bit the model to have a precise value of how long it takes:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'model stringconcat\n\nexperiment test {\n\t\n\t\n\taction concatenate_string(int nb){\n\t\tstring s <- \'\';\t\t\t\n\t\tloop times:nb{\n\t\t\ts <- s + rnd(0,10);\n\t\t}\n\t}\n\treflex concat {\n\t\t\n\t\tbenchmark "concatenating 100 000 times" repeat:10  {\n\t\t\tdo concatenate_string(100000);\t\t\t\n\t\t}\n\t\t\n\t\tbenchmark "concatenating 200 000 times" repeat:10  {\n\t\t\tdo concatenate_string(200000);\t\t\t\n\t\t}\n\t\t\n\t\tbenchmark "concatenating 300 000 times" repeat:10  {\n\t\t\tdo concatenate_string(300000);\t\t\t\n\t\t}\n\t\t\n\t}\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"With that model you should notice that 200 000  characters is significantly slower than 100 000, in my case it was more than 4 times slower, and 300 000 even more as it was almost 10 times slower. Results on my computer looked like this:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"center"},children:"100 000 characters"}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:"200 000 characters"}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:"300 000 characters"})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"619"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"2563"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"5749"})]})})]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:"https://github.com/user-attachments/assets/fd31d76a-875b-4bd3-9e36-ce19aa7c3f11",alt:"image"})}),"\n",(0,i.jsx)(t.p,{children:"This can be particularly annoying because creating big string is itself a way to optimize outputing data from a model (it is often faster to write a big string once than small strings many times)."}),"\n",(0,i.jsxs)(t.p,{children:["To help with string concatenation, it is advised to use the ",(0,i.jsx)(t.a,{href:"OperatorsBC#concatenate",children:"concatenate"})," operator: instead of concatenating many times your text into one string, append each small string into a list of string, and when all the component are collected, merge them only once with the operator.\nLet's modify the previous model to see how it works:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'model stringconcat\n\nexperiment test {\n\t\n\t\n\taction concatenate_string(int nb){\n\t\tlist<string> list_strings <- [];\t\t\t\n\t\tloop times:nb{\n\t\t\tlist_strings <+ string(rnd(0,10));\n\t\t}\n\t\tstring s <- concatenate(list_strings);\n\t}\n\treflex concat {\n\t\t\n\t\tbenchmark "concatenating 100 000 times" repeat:10  {\n\t\t\tdo concatenate_string(100000);\t\t\t\n\t\t}\n\t\t\n\t\tbenchmark "concatenating 200 000 times" repeat:10  {\n\t\t\tdo concatenate_string(200000);\t\t\t\n\t\t}\n\t\t\n\t\tbenchmark "concatenating 300 000 times" repeat:10  {\n\t\t\tdo concatenate_string(300000);\t\t\t\n\t\t}\n\t\t\n\t}\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"On the same computer as in the previous example I get those results:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"center"},children:"100 000 characters"}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:"200 000 characters"}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:"300 000 characters"})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"15"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"35"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"45"})]})})]}),"\n",(0,i.jsx)(t.p,{children:"Now let's compare them:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"center"},children:"100 000 characters"}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:"200 000 characters"}),(0,i.jsx)(t.th,{style:{textAlign:"center"},children:"300 000 characters"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"619"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"2563"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"5749"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"15"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"35"}),(0,i.jsx)(t.td,{style:{textAlign:"center"},children:"45"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:"https://github.com/user-attachments/assets/8a02a277-6f96-404a-ad0d-01df23bc3696",alt:"image"})}),"\n",(0,i.jsx)(t.p,{children:"Not only it is orders of magnitude faster, but it is also growing linearly instead of exponentially which is more sustainable in case I want to concatenate even bigger strings in the future."}),"\n",(0,i.jsx)(t.h2,{id:"threads",children:"Threads"}),"\n",(0,i.jsxs)(t.p,{children:["Since GAMA 1.9.1, a new skill has been added to implement ",(0,i.jsx)(t.a,{href:"BuiltInSkills#thread",children:"threads"})," in agents. The idea is not to give full control of threads to parallelize operations inside the simulation (though this could be achieved too), but to provide a way to communicate with the outside without blocking the execution of your simulation.\nGAMA simulation running mostly on one thread, having some heavy asynchronous operation running in a separate thread could greatly improve the simulation time, for example you can use threads to push the state of your simulation to an external web API every 10 minutes.\n",(0,i.jsx)(t.strong,{children:"Note:"})," Using threads to interact with your simulation could completely break its reproducibility in a similar way as it is explained in ",(0,i.jsx)(t.a,{href:"#parallel",children:"the parallel section"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(96540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);