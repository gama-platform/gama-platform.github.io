"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[21432],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,p=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),m=s(n),u=i,f=m["".concat(p,".").concat(u)]||m[u]||c[u]||l;return n?a.createElement(f,o(o({ref:t},d),{},{components:n})):a.createElement(f,o({ref:t},d))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,o=new Array(l);o[0]=u;var r={};for(var p in t)hasOwnProperty.call(t,p)&&(r[p]=t[p]);r.originalType=e,r[m]="string"==typeof e?e:i,o[1]=r;for(var s=2;s<l;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},21428:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>p,default:()=>f,frontMatter:()=>r,metadata:()=>s,toc:()=>m});var a=n(87462),i=n(63366),l=(n(67294),n(3905)),o=["components"],r={title:"1. Simple SI Model"},p=void 0,s={unversionedId:"IncrementalModel_step1",id:"version-1.8.1/IncrementalModel_step1",title:"1. Simple SI Model",description:"This first step Illustrates how to write a model in GAMA. In particular, it describes how to structure a model and how to define species - that are the key components of GAMA models.",source:"@site/versioned_docs/version-1.8.1/IncrementalModel_step1.md",sourceDirName:".",slug:"/IncrementalModel_step1",permalink:"/wiki/1.8.1/IncrementalModel_step1",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/IncrementalModel_step1/_edit",tags:[],version:"1.8.1",frontMatter:{title:"1. Simple SI Model"},sidebar:"tuto",previous:{title:"Incremental Model",permalink:"/wiki/1.8.1/IncrementalModel"},next:{title:"2. Charts",permalink:"/wiki/1.8.1/IncrementalModel_step2"}},d={},m=[{value:"Formulation",id:"formulation",level:2},{value:"Model Definition",id:"model-definition",level:2},{value:"model structure",id:"model-structure",level:3},{value:"species",id:"species",level:3},{value:"Internal state",id:"internal-state",level:4},{value:"global section",id:"global-section",level:3},{value:"global variables",id:"global-variables",level:4},{value:"Model initialization",id:"model-initialization",level:4},{value:"experiment",id:"experiment",level:3},{value:"input",id:"input",level:4},{value:"output",id:"output",level:4},{value:"Complete Model",id:"complete-model",level:2}],c={toc:m},u="wrapper";function f(e){var t=e.components,r=(0,i.Z)(e,o);return(0,l.kt)(u,(0,a.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"This first step Illustrates how to write a model in GAMA. In particular, it describes how to structure a model and how to define species - that are the key components of GAMA models."),(0,l.kt)("h2",{id:"formulation"},"Formulation"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Definition of the ",(0,l.kt)("strong",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"strong"},"people"))," species with a variable (",(0,l.kt)("inlineCode",{parentName:"li"},"is_infected"),") , an aspect (",(0,l.kt)("inlineCode",{parentName:"li"},"base"),") and two behaviors (",(0,l.kt)("inlineCode",{parentName:"li"},"move")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"infect"),")."),(0,l.kt)("li",{parentName:"ul"},"Definition of ",(0,l.kt)("inlineCode",{parentName:"li"},"nb_infected_init"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"distance"),"_infection",(0,l.kt)("inlineCode",{parentName:"li"},"and"),"proba_infection` parameters."),(0,l.kt)("li",{parentName:"ul"},"Creation of ",(0,l.kt)("strong",{parentName:"li"},"500")," ",(0,l.kt)("inlineCode",{parentName:"li"},"people")," agents randomly located in the environment (size: 500x500)."),(0,l.kt)("li",{parentName:"ul"},"Definition a display to visualize the people agents.")),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Incremental model 1: display of people agents taking into account the infectious state of the agents.",src:n(22974).Z,width:"660",height:"505"})),(0,l.kt)("h2",{id:"model-definition"},"Model Definition"),(0,l.kt)("h3",{id:"model-structure"},"model structure"),(0,l.kt)("p",null,"A GAMA model is composed of three types of sections:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"strong"},"global")),': this section, that is unique, defines the "world" agent, a special agent of a GAMA model. It represents all that is global to the model: dynamics, variables, actions. In addition, it allows to initialize the simulation (init block).'),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"strong"},"species")),": these sections define the species of agents composing the model."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"strong"},"experiment")),": these sections define a context of the execution of the simulations. In particular, it defines the input (parameters) and output (displays, files...) of a model.")),(0,l.kt)("p",null,"More details about the different sections of a GAMA model can be found ",(0,l.kt)("a",{parentName:"p",href:"ModelOrganization"},"here"),"."),(0,l.kt)("h3",{id:"species"},"species"),(0,l.kt)("p",null,"A ",(0,l.kt)("a",{parentName:"p",href:"RegularSpecies"},"species")," represents a \xabprototype\xbb of agents: it defines their common properties."),(0,l.kt)("p",null,"A species definition requires the definition of three different elements :"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the internal state of its agents (attributes)"),(0,l.kt)("li",{parentName:"ul"},"their behavior"),(0,l.kt)("li",{parentName:"ul"},"how they are displayed (aspects)")),(0,l.kt)("h4",{id:"internal-state"},"Internal state"),(0,l.kt)("p",null,"An ",(0,l.kt)("a",{parentName:"p",href:"RegularSpecies#declaration"},"attribute")," is defined as follows: the type of the attribute and name. Numerous types of attributes are available: ",(0,l.kt)("inlineCode",{parentName:"p"},"int")," (integer), ",(0,l.kt)("inlineCode",{parentName:"p"},"float")," (floating-point number), ",(0,l.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"bool")," (boolean, ",(0,l.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"false"),"), ",(0,l.kt)("inlineCode",{parentName:"p"},"point")," (coordinates), ",(0,l.kt)("inlineCode",{parentName:"p"},"list"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"pair"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"map"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"file"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"matrix"),", species of agents, ",(0,l.kt)("inlineCode",{parentName:"p"},"rgb")," (color), ",(0,l.kt)("inlineCode",{parentName:"p"},"graph"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"path"),"..."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Optional facets: ",(0,l.kt)("inlineCode",{parentName:"li"},"<-")," (initial value), ",(0,l.kt)("inlineCode",{parentName:"li"},"update")," (value recomputed at each step of the simulation), ",(0,l.kt)("inlineCode",{parentName:"li"},"function:{..}")," (value computed each time the variable is used), ",(0,l.kt)("inlineCode",{parentName:"li"},"min"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"max"))),(0,l.kt)("p",null,'In addition to the attributes the modeler explicitly defines, species "inherits" other attributes called "built-in" variables:'),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A name (",(0,l.kt)("inlineCode",{parentName:"li"},"name"),"): the identifier of the species."),(0,l.kt)("li",{parentName:"ul"},"A shape (",(0,l.kt)("inlineCode",{parentName:"li"},"shape"),"): the default shape of the agents to be constructed after the species. It can be ",(0,l.kt)("em",{parentName:"li"},"a point, a polygon, etc."),"."),(0,l.kt)("li",{parentName:"ul"},"A location (",(0,l.kt)("inlineCode",{parentName:"li"},"location"),"): the centroid of its shape.")),(0,l.kt)("p",null,"We will give a variable to ",(0,l.kt)("inlineCode",{parentName:"p"},"people")," agents: ",(0,l.kt)("inlineCode",{parentName:"p"},"is_infected")," (bool):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"species people skills:[moving]{     \n    bool is_infected <- false;\n}\n")),(0,l.kt)("p",null,"Concerning the display of an agent, ",(0,l.kt)("a",{parentName:"p",href:"RegularSpecies#the-aspect-statement"},"aspects")," have to be defined. An aspect represents a possible way to display the agents of a species: ",(0,l.kt)("inlineCode",{parentName:"p"},"aspect aspect_name {...}"),".\nIn the block of an aspect, it is possible to ",(0,l.kt)("inlineCode",{parentName:"p"},"draw"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A geometry: for instance, the shape of the agent."),(0,l.kt)("li",{parentName:"ul"},"An image: to draw icons."),(0,l.kt)("li",{parentName:"ul"},"A text: to draw a text.")),(0,l.kt)("p",null,"We define here one aspect of this species. In this model, we want to display for each people agent a circle of radius 5 and red or green according to the value of ",(0,l.kt)("inlineCode",{parentName:"p"},"is_infected")," (if infected: red, green otherwise). We then use the keyword ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"draw"))," with a ",(0,l.kt)("inlineCode",{parentName:"p"},"circle")," shape. To define the color that depends on ",(0,l.kt)("inlineCode",{parentName:"p"},"is_infected"),", we use the tertiary operator ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"condition ? val1 : val2")),". If the condition is true, this operator will return ",(0,l.kt)("inlineCode",{parentName:"p"},"val1"),", otherwise ",(0,l.kt)("inlineCode",{parentName:"p"},"val2"),". Note that it is possible to get a color value by using the symbol ",(0,l.kt)("inlineCode",{parentName:"p"},"#")," + color name: e.g. ",(0,l.kt)("inlineCode",{parentName:"p"},"#blue"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"#red"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"#white"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"#yellow"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"#magenta"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"#pink"),"..."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"species people skills:[moving] {        \n    ...\n    aspect default {\n    draw circle(5) color: is_infected ? #red : #green;\n    }\n}\n")),(0,l.kt)("p",null,"Concerning the behavior of agents, the simplest way to define it is through reflexes. A ",(0,l.kt)("inlineCode",{parentName:"p"},"reflex")," is a block of statements (that can be defined in global or any species) that will be automatically executed at each simulation step if its condition is true. A reflex is defined as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"    reflex reflex_name when: condition {...}\n")),(0,l.kt)("p",null,"The ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"when"))," facet is optional: when it is omitted, the reflex is activated at each time step. Note that if several reflexes are defined for a species, the reflexes will be activated following their definition order."),(0,l.kt)("p",null,"We define a first reflex called ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"move"))," that allows the people agents to move using the ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"wander"))," action (provided by the ",(0,l.kt)("inlineCode",{parentName:"p"},"moving")," skill) that allows to randomly move (with taking into account the agent ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"speed")),")."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"species people skills: [moving] {\n    ...\n    reflex move {\n    do wander;\n    }\n}\n")),(0,l.kt)("p",null,"Note that an action is a capability available to the agents of a species (what they can do). It is a block of statements that can be used and reused whenever needed. Some actions, called primitives, are directly coded in Java: for instance, the ",(0,l.kt)("strong",{parentName:"p"},"wander")," action defined in the ",(0,l.kt)("strong",{parentName:"p"},"moving")," skill."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"An action can accept arguments. For instance, write takes an argument called message."),(0,l.kt)("li",{parentName:"ul"},"An action can return a result.")),(0,l.kt)("p",null,"There are two ways to call an action: using a statement or as part of an expression"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"for actions that do not return a result:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"do action_name arg1: v1 arg2: v2;\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"for actions that return a result:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"my_var <- self action_name (arg1:v1, arg2:v2);\n")),(0,l.kt)("p",null,"The second reflex we have to define is the ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"infect"))," one. This reflex will be activated only if ",(0,l.kt)("inlineCode",{parentName:"p"},"is_infected")," is true. This reflex consists is asking all the people agents at a distance lower or equal to ",(0,l.kt)("inlineCode",{parentName:"p"},"infection_distance")," to become infected with a probability ",(0,l.kt)("inlineCode",{parentName:"p"},"proba_infection"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"species people skills:[moving]{     \n    ...\n    reflex infect when: is_infected{\n    ask people at_distance infection_distance {\n        if flip(proba_infection) {\n            is_infected <- true;\n        }\n    }\n    }\n    ...\n}\n")),(0,l.kt)("p",null,"Note that we used the ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"ask"))," statement. This statement allows to make a remote agent executes a list of statements. We used as well the ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"flip"))," operator that allows to test a probability."),(0,l.kt)("h3",{id:"global-section"},"global section"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"global")," section represents the definition of the species of a specific agent (called ",(0,l.kt)("inlineCode",{parentName:"p"},"world"),").\nThe world agent represents everything that is global to the model: dynamics, variables...\nIt allows to init simulations (",(0,l.kt)("inlineCode",{parentName:"p"},"init")," block): the world is always created and initialized first when a simulation is launched. The geometry (shape) of the world agent is by default a square with 100m for side size, but can be redefined if necessary. In the same way, the modeler can redefine the ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"step"))," variable that represents the duration of a simulation step and that is by default 1 second."),(0,l.kt)("h4",{id:"global-variables"},"global variables"),(0,l.kt)("p",null,"For our model, we define 5 global variables: ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"nb_people"))," (int, init value: 500), ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"infection_distance"))," (float value, init value: 2 meters), ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"proba_infection"))," (float, init value: 0.05), ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"nb_infected_init"))," (int, init value: 5) and ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"agent_speed"))," (float, init value: 5 #km/#h). In addition, we redefine the geometry of the world by a square of 500 meters size and a simulation step of 1 minute."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"global { \n    int nb_people <- 500;\n    float agent_speed <- 5.0 #km/#h;\n    float infection_distance <- 2.0 #m;\n    float proba_infection <- 0.05;\n    int nb_infected_init <- 5;\n    float step <- 1 #minutes;\n    geometry shape<-square(500 #m);\n}\n")),(0,l.kt)("h4",{id:"model-initialization"},"Model initialization"),(0,l.kt)("p",null,"The init section of the global block allows to initialize the model.\nThe statement ",(0,l.kt)("inlineCode",{parentName:"p"},"create")," allows to create agents of a specific species: ",(0,l.kt)("inlineCode",{parentName:"p"},"create species\\_name")," + :"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"number"),": number of agents to create (int, 1 by default)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"from"),": GIS file to use to create the agents (string or file)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"returns"),": list of created agents (list)")),(0,l.kt)("p",null,"For our model, the definition of the ",(0,l.kt)("inlineCode",{parentName:"p"},"init")," block in order to create ",(0,l.kt)("inlineCode",{parentName:"p"},"nb_people")," people agents. We set the init value of the ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"speed"))," variable (given by the ",(0,l.kt)("inlineCode",{parentName:"p"},"moving")," skill) to the value of the global variable ",(0,l.kt)("inlineCode",{parentName:"p"},"agent_speed")," (i.e. 5km/h)."),(0,l.kt)("p",null,"In addition, we ask ",(0,l.kt)("inlineCode",{parentName:"p"},"nb_infected_init")," people to become infected (use of the ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"nb among list"))," to randomly draw nb elements of the list)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"global{ \n    ...\n    init{\n    create people number:nb_people {\n        speed <- agent_speed;\n    }\n    ask nb_infected_init among people {\n        is_infected <- true;\n    }\n    }\n}\n")),(0,l.kt)("h3",{id:"experiment"},"experiment"),(0,l.kt)("p",null,"An ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"experiment"))," block defines how a model can be simulated (executed). Several experiments can be defined for a model. They are defined using : ",(0,l.kt)("inlineCode",{parentName:"p"},"experiment exp\\_name type: gui/batch {"),"[input]",(0,l.kt)("inlineCode",{parentName:"p"}," "),"[output]",(0,l.kt)("inlineCode",{parentName:"p"},"}"),"."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"gui: experiment with a graphical interface, which displays its input parameters and outputs."),(0,l.kt)("li",{parentName:"ul"},"batch: Allows to setup a series of simulations (w/o graphical interface).")),(0,l.kt)("p",null,"In our model, we define a gui experiment called main_experiment :"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"experiment main_experiment type: gui {\n}\n")),(0,l.kt)("h4",{id:"input"},"input"),(0,l.kt)("p",null,"Experiments can define (input) parameters. A parameter definition allows to make the value of a global variable definable by the user through the graphic interface."),(0,l.kt)("p",null,"A parameter is defined as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"parameter title var: global_var category: cat;\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"title"),": string to display"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"var"),": reference to a global variable (defined in the global section)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"category"),": string used to \xabstore\xbb the operators on the UI - optional"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"<-"),": init value - optional"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"min"),": min value - optional"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"max"),": min value - optional")),(0,l.kt)("p",null,"Note that the ",(0,l.kt)("inlineCode",{parentName:"p"},"init"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"min")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"max")," values can be defined in the global variable definition."),(0,l.kt)("p",null,"In the experiment, we define three parameters from the global variables ",(0,l.kt)("inlineCode",{parentName:"p"},"infection_distance"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"proba_infection")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"nb_infected_init"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'experiment main_experiment type: gui{\n    parameter "Infection distance" var: infection_distance;\n    parameter "Proba infection" var: proba_infection min: 0.0 max: 1.0;\n    parameter "Nb people infected at init" var: nb_infected_init ;\n    ...\n}\n')),(0,l.kt)("h4",{id:"output"},"output"),(0,l.kt)("p",null,"The ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"output"))," block is defined in an experiment and defines how to visualize a simulation (with one or more ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"display"))," blocks that define separate windows). Each display can be refreshed independently by defining the facet ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"refresh"))," (expecting a boolean expression, the display will be refreshed every time the expression is evaluated to true. This expression can be described in terms of nb of simulation, with e.g. ",(0,l.kt)("inlineCode",{parentName:"p"},"every(5#cycle)"),")."),(0,l.kt)("p",null,"Each display can include different layers (like in a GIS):"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"All the agents of a species: ",(0,l.kt)("inlineCode",{parentName:"li"},"species  my_species aspect: my_aspect;"),"."),(0,l.kt)("li",{parentName:"ul"},"Agents lists: ",(0,l.kt)("inlineCode",{parentName:"li"},"agents layer_name value: agents_list aspect: my_aspect;"),"."),(0,l.kt)("li",{parentName:"ul"},"Images: ",(0,l.kt)("inlineCode",{parentName:"li"},"image image_file_name;"),"."),(0,l.kt)("li",{parentName:"ul"},"Charts: see later.")),(0,l.kt)("p",null,"Note that it is possible to define a ",(0,l.kt)("a",{parentName:"p",href:"Defining3DDisplays#opengl-display"},"opengl display")," (for 3D display) by using the facet ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("inlineCode",{parentName:"strong"},"type: opengl")),"."),(0,l.kt)("p",null,"In our model, we define a display to draw the ",(0,l.kt)("inlineCode",{parentName:"p"},"people")," agents with their ",(0,l.kt)("inlineCode",{parentName:"p"},"default")," aspect. (note that, if the ",(0,l.kt)("inlineCode",{parentName:"p"},"aspect")," facet is omitted, the aspect named ",(0,l.kt)("inlineCode",{parentName:"p"},"default")," will be used)"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"experiment main_experiment type: gui{\n    ...\n    output {\n    display map {\n        species people ; // 'default' aspect is used automatically          \n    }\n    }\n}\n")),(0,l.kt)("h2",{id:"complete-model"},"Complete Model"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'model SI_city\n\nglobal {\n    int nb_people <- 500;\n    float agent_speed <- 5.0 #km/#h;    \n    float infection_distance <- 2.0 #m;\n    float proba_infection <- 0.05;\n    int nb_infected_init <- 5;\n    float step <- 1 #minutes;\n    geometry shape <- envelope(square(500 #m));\n\n    init {\n    create people number: nb_people {\n        speed <- agent_speed;\n    }\n\n    ask nb_infected_init among people {\n        is_infected <- true;\n    }\n    }\n}\n\nspecies people skills: [moving] {\n    bool is_infected <- false;\n\n    reflex move {\n    do wander;\n    }\n\n    reflex infect when: is_infected {\n    ask people at_distance infection_distance {\n        if (flip(proba_infection)) {\n        is_infected <- true;\n        }\n    }\n    }\n\n    aspect default {\n    draw circle(5) color: is_infected ? #red : #green;\n    }\n}\n\nexperiment main_experiment type: gui {\n    parameter "Infection distance" var: infection_distance;\n    parameter "Proba infection" var: proba_infection min: 0.0 max: 1.0;\n    parameter "Nb people infected at init" var: nb_infected_init;\n    \n    output {\n    display map {\n        species people; // \'default\' aspect is used automatically           \n    }\n    }\n}\n')))}f.isMDXComponent=!0},22974:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/Incremental_model1-b99edbb47188bc8e6b7d2fc4231a15aa.jpg"}}]);