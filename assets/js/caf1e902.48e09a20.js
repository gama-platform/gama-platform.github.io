"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[32692],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=o.createContext({}),s=function(e){var t=o.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=s(e.components);return o.createElement(p.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},f=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=s(n),f=a,h=c["".concat(p,".").concat(f)]||c[f]||u[f]||i;return n?o.createElement(h,r(r({ref:t},d),{},{components:n})):o.createElement(h,r({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=f;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[c]="string"==typeof e?e:a,r[1]=l;for(var s=2;s<i;s++)r[s]=n[s];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}f.displayName="MDXCreateElement"},73487:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>p,default:()=>f,frontMatter:()=>l,metadata:()=>s,toc:()=>c});var o=n(87462),a=n(63366),i=(n(67294),n(3905)),r=["components"],l={title:"4. Use of a graph to constraint the movements of people"},p=void 0,s={unversionedId:"LuneraysFlu_step4",id:"version-1.8.1/LuneraysFlu_step4",title:"4. Use of a graph to constraint the movements of people",description:"This fourth step illustrates how to use a graph to constraint the movements of agents",source:"@site/versioned_docs/version-1.8.1/LuneraysFlu_step4.md",sourceDirName:".",slug:"/LuneraysFlu_step4",permalink:"/wiki/1.8.1/LuneraysFlu_step4",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/LuneraysFlu_step4/_edit",tags:[],version:"1.8.1",frontMatter:{title:"4. Use of a graph to constraint the movements of people"},sidebar:"tuto",previous:{title:"3. Importation of GIS data",permalink:"/wiki/1.8.1/LuneraysFlu_step3"},next:{title:"5. Definition of 3D displays",permalink:"/wiki/1.8.1/LuneraysFlu_step5"}},d={},c=[{value:"Formulation",id:"formulation",level:2},{value:"Model Definition",id:"model-definition",level:2},{value:"global section",id:"global-section",level:3},{value:"global variables",id:"global-variables",level:4},{value:"people species",id:"people-species",level:3},{value:"Variables",id:"variables",level:4},{value:"Behavior",id:"behavior",level:4},{value:"Complete Model",id:"complete-model",level:2}],u={toc:c};function f(e){var t=e.components,l=(0,a.Z)(e,r);return(0,i.kt)("wrapper",(0,o.Z)({},u,l,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This fourth step illustrates how to use a graph to constraint the movements of agents"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Result of the Luneray Flu model 4.",src:n(36749).Z,width:"3584",height:"2118"})),(0,i.kt)("h2",{id:"formulation"},"Formulation"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Define a new global variable: the road network (graph)."),(0,i.kt)("li",{parentName:"ul"},"Build the road network graph from the road agents"),(0,i.kt)("li",{parentName:"ul"},"Add new attribute to the people agents (target)"),(0,i.kt)("li",{parentName:"ul"},"Define a new reflex for people agents: stay."),(0,i.kt)("li",{parentName:"ul"},"Modify the move reflex of the people agents.")),(0,i.kt)("h2",{id:"model-definition"},"Model Definition"),(0,i.kt)("h3",{id:"global-section"},"global section"),(0,i.kt)("h4",{id:"global-variables"},"global variables"),(0,i.kt)("p",null,"In this model, we want people agents to move from buildings to buildings by using the shortest path in the road network. In order to compute this shortest path, we need to use a graph structure."),(0,i.kt)("p",null,"We thus define a new global variable called ",(0,i.kt)("inlineCode",{parentName:"p"},"road_network")," of type ",(0,i.kt)("inlineCode",{parentName:"p"},"graph")," that will represent the road network."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"global{\n    //... other attributes\n    graph road_network;\n    \n    //... init\n}\n")),(0,i.kt)("p",null,"In order to compute the graph from the road network, we use, just after having created the road agents, the ",(0,i.kt)("a",{parentName:"p",href:"OperatorsAA#as_edge_graph"},"as_edge_graph")," operator. This operator automatically built a graph from a set of polylines. Each extremity point of the lines will become a node in the graph, and each polyline an edge. By default, the graph is not oriented and the weights of the edges are the perimeters of the polylines. It is of course possible to change through the use of some operators.  "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"global {\n    // world variable definition\n\n    init{\n    create road from: roads_shapefile;\n    road_network <- as_edge_graph(road);        \n    create building from: buildings_shapefile;\n    create people number:nb_people {\n        location <- any_location_in(one_of(building));              \n    }\n    ask nb_infected_init among people {\n        is_infected <- true;\n    }\n    }\n}\n")),(0,i.kt)("h3",{id:"people-species"},"people species"),(0,i.kt)("p",null,"We want to modify the behavior of the people agents in order to make them move from buildings to buildings by using the shortest path in the road network. "),(0,i.kt)("h4",{id:"variables"},"Variables"),(0,i.kt)("p",null,"In order to implement this behavior, we will add two variables to our people species:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"target")," of type ",(0,i.kt)("inlineCode",{parentName:"li"},"point")," that will be the location where the agent wants to go")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"species people skills:[moving]{\n    //...the other attributes\n    point target;\n    //....\n}\n")),(0,i.kt)("h4",{id:"behavior"},"Behavior"),(0,i.kt)("p",null,"First, we add a new reflex called ",(0,i.kt)("inlineCode",{parentName:"p"},"stay")," that will be activated when the agent is in a house (i.e. its target is null) and that will define with a probability of 0.05 if the agent has to go or not. If the agent has to go, it will randomly choose a new target (a random location inside one of the building). "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"reflex stay when: target = nil {\n    if flip(0.05) {\n    target <- any_location_in (one_of(building));\n    }\n}\n")),(0,i.kt)("p",null,"Then, we modify the ",(0,i.kt)("inlineCode",{parentName:"p"},"move")," reflex. This one will be only activated when the agent will have to move (target not null). Instead of using the ",(0,i.kt)("inlineCode",{parentName:"p"},"wander")," action of the ",(0,i.kt)("inlineCode",{parentName:"p"},"moving")," skill, we use the ",(0,i.kt)("inlineCode",{parentName:"p"},"goto")," one that allows to make an agent moves toward a given target. In addition, it is possible to add a facet ",(0,i.kt)("inlineCode",{parentName:"p"},"on")," to precise on which topology the agent will have to move on. In our case, the topology is the road network.\nWhen the agent reaches its destination (location = target), it sets its target to null."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"reflex move when: target != nil{\n    do goto target: target on: road_network;\n    if (location = target) {\n    target <- nil;\n    } \n}\n")),(0,i.kt)("h2",{id:"complete-model"},"Complete Model"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'\nmodel model4\n\nglobal {\n    int nb_people <- 2147;\n    int nb_infected_init <- 5;\n    float step <- 5 #mn;\n    file roads_shapefile <- file("../includes/roads.shp");\n    file buildings_shapefile <- file("../includes/buildings.shp");\n    geometry shape <- envelope(roads_shapefile);    \n    graph road_network;\n    \n    int nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n    int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n    float infected_rate update: nb_people_infected/nb_people;\n    \n    init{\n        create road from: roads_shapefile;\n        road_network <- as_edge_graph(road);        \n        create building from: buildings_shapefile;\n        create people number:nb_people {\n            location <- any_location_in(one_of(building));                \n        }\n        ask nb_infected_init among people {\n            is_infected <- true;\n        }\n    }\n\n    reflex end_simulation when: infected_rate = 1.0 {\n        do pause;\n    }    \n}\n\nspecies people skills:[moving]{        \n    float speed <- (2 + rnd(3)) #km/#h;\n    bool is_infected <- false;\n    point target;\n    \n    reflex stay when: target = nil {\n        if flip(0.05) {\n            target <- any_location_in (one_of(building));\n        }\n    }\n        \n    reflex move when: target != nil{\n        do goto target: target on: road_network;\n        if (location = target) {\n            target <- nil;\n        } \n    }\n\n    reflex infect when: is_infected{\n        ask people at_distance 10 #m {\n            if flip(0.05) {\n                is_infected <- true;\n            }\n        }\n    }\n    \n    aspect circle {\n        draw circle(10) color:is_infected ? #red : #green;\n    }\n}\n\nspecies road {\n    aspect geom {\n        draw shape color: #black;\n    }\n}\n\nspecies building {\n    aspect geom {\n        draw shape color: #gray;\n    }\n}\n\nexperiment main type: gui {\n    parameter "Nb people infected at init" var: nb_infected_init min: 1 max: 2147;\n\n    output {\n        monitor "Infected people rate" value: infected_rate;\n        \n        display map {\n            species road aspect:geom;\n            species building aspect:geom;\n            species people aspect:circle;            \n        }\n        \n        display chart_display refresh: every(10 #cycles) {\n            chart "Disease spreading" type: series {\n                data "susceptible" value: nb_people_not_infected color: #green;\n                data "infected" value: nb_people_infected color: #red;\n            }\n        }\n    }\n}\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"LuneraysFlu_step5"},"Next step: Definition of 3D displays")))}f.isMDXComponent=!0},36749:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/luneray4-d824dfe8c141feab51ee0d86831948b3.png"}}]);