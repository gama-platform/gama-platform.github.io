"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2446],{71178:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>h});var i=n(74848),o=n(28453);const a={title:"Analysing code performance"},s=void 0,r={id:"AnalysingCodePerformance",title:"Analysing code performance",description:"[//]: # (keyword|concept_optimization)",source:"@site/../docs/AnalysingCodePerformance.md",sourceDirName:".",slug:"/AnalysingCodePerformance",permalink:"/wiki/next/AnalysingCodePerformance",draft:!1,unlisted:!1,editUrl:"https://github.com/gama-platform/gama/wiki/AnalysingCodePerformance/_edit",tags:[],version:"current",frontMatter:{title:"Analysing code performance"},sidebar:"main",previous:{title:"Runtime Concepts",permalink:"/wiki/next/RuntimeConcepts"},next:{title:"Optimizing Models",permalink:"/wiki/next/OptimizingModels"}},l={},h=[{value:"Some general concepts and tips before starting",id:"some-general-concepts-and-tips-before-starting",level:2},{value:"Randomness",id:"randomness",level:3},{value:"Exponential processes",id:"exponential-processes",level:3},{value:"Using GAML to get the duration of some code&#39;s execution time",id:"using-gaml-to-get-the-duration-of-some-codes-execution-time",level:2},{value:"The <code>duration</code> variable",id:"the-duration-variable",level:3},{value:"Using <code>gama.machine_time</code>",id:"using-gamamachine_time",level:3},{value:"Using the <code>benchmark</code> statement",id:"using-the-benchmark-statement",level:3},{value:"Using the <code>benchmark</code> facet of an experiment",id:"using-the-benchmark-facet-of-an-experiment",level:3},{value:"How to proceed in practice",id:"how-to-proceed-in-practice",level:2},{value:"Having an overview of the model&#39;s execution time step by step",id:"having-an-overview-of-the-models-execution-time-step-by-step",level:3},{value:"Stable duration throughout the simulation",id:"stable-duration-throughout-the-simulation",level:4},{value:"Step duration increases during the simulation",id:"step-duration-increases-during-the-simulation",level:4},{value:"Some steps are significantly longer than the rest",id:"some-steps-are-significantly-longer-than-the-rest",level:4},{value:"Chaotic step durations",id:"chaotic-step-durations",level:4},{value:"Identifying the problem in the code",id:"identifying-the-problem-in-the-code",level:3},{value:"isolating the code in a simpler model",id:"isolating-the-code-in-a-simpler-model",level:4},{value:"Looking for exponential behaviour",id:"looking-for-exponential-behaviour",level:4},{value:"benchmarking",id:"benchmarking",level:4},{value:"comparing to alternative code",id:"comparing-to-alternative-code",level:4},{value:"What to pay the most attention to",id:"what-to-pay-the-most-attention-to",level:2}];function c(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"It is a common mistake when trying to optimize any piece of code to go in head first and try to optimize everything possible. The problem with this approach is that basically everything could be optimized in a computer program and that the task of optimizing itself can be very time consuming. So before even optimizing a model, it is important to analyse it, in order to know which part has the most impact on the simulation duration and to have precise data on your initial execution time to be able to assess your progression."}),"\n",(0,i.jsx)(t.h2,{id:"some-general-concepts-and-tips-before-starting",children:"Some general concepts and tips before starting"}),"\n",(0,i.jsx)(t.h3,{id:"randomness",children:"Randomness"}),"\n",(0,i.jsxs)(t.p,{children:["In gaml, many operators have an implicit use of randomness (for example the ",(0,i.jsx)(t.a,{href:"OperatorsNR#one_of",children:"one_of"})," operator) and this can of course impact the simulation duration.\nDepending on your case, you may need to set the random generator to a certain seed during the analysis part, to make sure that every time the simulation is ran, it will get exactly the same data and operations done, and thus comparisons of execution time are more fair/stable.\nYou can do so by adding this line of code in your experiment or in your global:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'float seed <- 1.0; // put any number you want apart from 0 which would mean "pick a random (different) seed for every simulation"\n'})}),"\n",(0,i.jsx)(t.p,{children:'In other cases, randomness plays a "real" role in your model, and you may want to take that randomness into account in your optimization. In this case, the right approach would be to repeat the tests a certain amount of time that you think is reasonable to "neutralize" the effect of randomness and to get an idea of what would be the "average" behaviour, or what could be the extrema.'}),"\n",(0,i.jsx)(t.p,{children:"In any cases, it is important to keep in mind that randomness exists in GAMA and to be mindful of it when analysing execution time as it can have an impact."}),"\n",(0,i.jsx)(t.h3,{id:"exponential-processes",children:"Exponential processes"}),"\n",(0,i.jsx)(t.p,{children:"In reality, most of the real (unexpected) problems regarding execution time are caused by exponential processes. Those are the ones we are trying to spot when analysing the code most of the time.\nBy exponential process you have to understand anything that has an execution time that grows faster than linearly (meaning that grows proportionally) in function of its parameters."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:(0,i.jsx)(t.strong,{children:"For example:"})})," if in my simulation I have 100 agents of the same species and I run it again with 200 agents, I would expect the simulation time to approximately double too. If it is not the case and the simulation takes 10 times longer to execute then there's probably a reflex and/or an action somewhere in the model that has an exponential growth of its processing time in function of the number of agents, and this reflex/action is something you really want to monitor. Of course in this case it could also be something else like a part of the code that only triggers when the number of agents is greater than 150."]}),"\n",(0,i.jsx)(t.p,{children:"Sometimes it is possible to switch an algorithm of exponential complexity for a linear one, but sometimes it is simply not possible as the nature of the problem we try to address is exponential. But knowing that some part of the code have an exponential growth is still very valuable as it can help to mitigate its effect on the overall execution time. If we go back to the previous example: maybe we can determine a number of agents under which the execution time is still reasonable and adapt the simulation to keep the number of agents under that number."}),"\n",(0,i.jsx)(t.h2,{id:"using-gaml-to-get-the-duration-of-some-codes-execution-time",children:"Using GAML to get the duration of some code's execution time"}),"\n",(0,i.jsx)(t.p,{children:"Analysing a model or a piece of code's performance always comes down to assessing the time it took to do something.\nTo do so, we have a few options in gaml:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Getting the total duration of the previous cycle"}),"\n",(0,i.jsx)(t.li,{children:"Processing yourself the elapsed time between two parts of the code using the machine time"}),"\n",(0,i.jsx)(t.li,{children:'Using gaml statements to "benchmark" a precise piece of code'}),"\n",(0,i.jsx)(t.li,{children:"Getting a detailed report on every duration of every line of code executed"}),"\n"]}),"\n",(0,i.jsxs)(t.h3,{id:"the-duration-variable",children:["The ",(0,i.jsx)(t.code,{children:"duration"})," variable"]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.a,{href:"GlobalSpecies#duration",children:(0,i.jsx)(t.code,{children:"duration"})})," variable can be used to get the time that the previous step took to execute. At the first step of the simulation it will be 0, then at the next step it will be the time that the first step took etc.\nIt is very useful to easily get an idea of the duration of steps, but if we need to get the duration of the initialization phase, or of some piece of code that is happening inside one step we will need another tool."]}),"\n",(0,i.jsxs)(t.h3,{id:"using-gamamachine_time",children:["Using ",(0,i.jsx)(t.code,{children:"gama.machine_time"})]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.a,{href:"GlobalSpecies#machine_time",children:(0,i.jsx)(t.code,{children:"machine_time"})})," variable is a more versatile tool, it just returns the current time on the computer running the simulation. Using this we can process the duration of anything we want in the simulation."]}),"\n",(0,i.jsx)(t.p,{children:"For example to get (an approximation of) the duration of the initialization of a model, we could write:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-gaml",children:'global{\n    float init_time <- gama.machine_time;\n\t// plenty of other variable declarations\n    init{\n        // init code\n        // ...\n        write "Initialization took: " + (gama.machine_time - init_time) + "ms";\n    }\n}\n'})}),"\n",(0,i.jsxs)(t.h3,{id:"using-the-benchmark-statement",children:["Using the ",(0,i.jsx)(t.code,{children:"benchmark"})," statement"]}),"\n",(0,i.jsxs)(t.p,{children:["In addition to this, gaml provides a statement, ",(0,i.jsx)(t.a,{href:"Statements#benchmark",children:"benchmark"}),", that could be used to execute code a certain number of time and that will print in the console the minimum, maximum and average duration of those executions. This could be useful to quickly test different parts of the code or alternative codes one after another.\nExecuting the code multiple times is a common technique in the code optimization world as it is sometimes necessary to eliminate (or assess) the impact of randomness in the given code (as talked about in the section on ",(0,i.jsx)(t.a,{href:"#Randomness",children:"randomness"}),") or on the computer: for example maybe some hidden task starts just at the same moment and impacts the performances of 1 execution.\nHere is an example of the use of the benchmark statement to compare two alternative codes:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-gaml",children:'benchmark message:"concatenation standard" repeat:10{\n\tstring result <- \'\';\n\tloop times:nb_concat{\n\t\tresult <- result + rnd(0,10);\n\t}\n}\n\nbenchmark message:"concatenation optimized" repeat:10{\n\tlist<string> content;\n\tloop times:nb_concat{\n\t\tcontent <+ string(rnd(0,10));\n\t}\n\tstring result <- concatenate(content);\t\t\t\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"and the result in the console would look something like this:"}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"concatenation standard (over 10 iteration(s)): min = 591.1828 ms (iteration #4) | max = 681.7818 ms (iteration #0) | average = 607.1486699999999ms"}),"\n"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"concatenation optimized (over 10 iteration(s)): min = 15.3127 ms (iteration #3) | max = 16.3495 ms (iteration #8) | average = 15.753850000000003ms"}),"\n"]}),"\n",(0,i.jsxs)(t.h3,{id:"using-the-benchmark-facet-of-an-experiment",children:["Using the ",(0,i.jsx)(t.code,{children:"benchmark"})," facet of an experiment"]}),"\n",(0,i.jsxs)(t.p,{children:["This is a more advanced use, the experiment in gaml have a facet called ",(0,i.jsx)(t.code,{children:"benchmark"})," which can be turned to true, in that case every executed line of code will be recorded in a csv along with its number of call and cumulated execution time."]}),"\n",(0,i.jsx)(t.h2,{id:"how-to-proceed-in-practice",children:"How to proceed in practice"}),"\n",(0,i.jsx)(t.h3,{id:"having-an-overview-of-the-models-execution-time-step-by-step",children:"Having an overview of the model's execution time step by step"}),"\n",(0,i.jsx)(t.p,{children:"When you want to optimize a model but don't know where to start, a good (and easy to implement) starting point is to check the global shape of execution time during your simulation.\nFor that we are going to record each step's duration and plot it to get an idea of what's going on during the execution."}),"\n",(0,i.jsx)(t.p,{children:"To do so, simply add this reflex into your global block:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-gama",children:'reflex save_step_duration when: cycle>0 {\n\tsave [cycle, duration] to:"durations.csv" format:"csv" rewrite:false;\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"This way you will have every step duration saved in a csv file that you can analyse later on.\nOnce you have the csv file you can open it in your favourite spreadsheet to visualise it. From there, there are a few possibilities:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"The durations are always pretty much the same, no big variation"}),"\n",(0,i.jsx)(t.li,{children:"The durations globally increase during the whole simulation"}),"\n",(0,i.jsx)(t.li,{children:"The durations have a baseline but sometimes there are steps that are significantly longer than that baseline"}),"\n",(0,i.jsx)(t.li,{children:"The durations are chaotic, once low then high, there's no real baseline"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Each of these cases call for a different approach"}),"\n",(0,i.jsx)(t.h4,{id:"stable-duration-throughout-the-simulation",children:"Stable duration throughout the simulation"}),"\n",(0,i.jsxs)(t.p,{children:["Congratulation, your model is already stable which means it is probably already well thought! Now it may be harder for you as there are no real clue as to what to improve first, but the good news is that probably any improvement anywhere in the code will reflect in the global model's execution time. See the section about ",(0,i.jsx)(t.a,{href:"#What-to-pay-the-most-attention-to",children:"the things to look for"})," that often cost a lot of execution time."]}),"\n",(0,i.jsx)(t.h4,{id:"step-duration-increases-during-the-simulation",children:"Step duration increases during the simulation"}),"\n",(0,i.jsx)(t.p,{children:"That kind of result points toward an increase of the simulation complexity during its lifespan: as the simulation progresses there are more and more things to process.\nThis is typical of either the number of agent continuously increasing or cumulative data being held and used for processing."}),"\n",(0,i.jsx)(t.h4,{id:"some-steps-are-significantly-longer-than-the-rest",children:"Some steps are significantly longer than the rest"}),"\n",(0,i.jsxs)(t.p,{children:["This means that under certain condition, your model will execute intensive code that is normally not executed. To find exactly what it is, you can inspect the ",(0,i.jsx)(t.code,{children:"when"})," facets of your reflexes and the ",(0,i.jsx)(t.code,{children:"if"})," and ",(0,i.jsx)(t.code,{children:"loop while:"})," conditions in your reflexes and actions.\nIf those longer steps happen with some form of regularity (for example every 100 steps) it is very probable that it is linked to some behaviour triggered by time or cycle condition, you can look up for ",(0,i.jsx)(t.code,{children:"every"}),", ",(0,i.jsx)(t.code,{children:"#now"})," or ",(0,i.jsx)(t.code,{children:"cycle"})," keyword use in the code."]}),"\n",(0,i.jsx)(t.h4,{id:"chaotic-step-durations",children:"Chaotic step durations"}),"\n",(0,i.jsx)(t.p,{children:"This may be the hardest case to analyse, as the complexity seems to come from a combination of \"unstable\" things.\nA good approach here could be to try and isolate different parts of the code. Let's say that your model has two main dynamics that interact together, in that case what you want to do is to try and analyse each one separately.\nTo do so, you will probably need to recreate two new models each only containing one of those dynamics. If both dynamics cannot function without the other you could mimic the other with a very simple functions that for example always return the same thing, or return values that you already processed in a previous simulation so it doesn't cost anything in execution time."}),"\n",(0,i.jsx)(t.p,{children:"If there are no such things in your model as different dynamics then you could go a step further and log for each reflex and/or action when it is called and the duration of the call. This way you could identify the cost of each action/reflex on the overall simulation duration and work from there to optimize only the actions/reflexes that matter the most."}),"\n",(0,i.jsxs)(t.p,{children:["Another thing you can try is to register individually all reflex/action calls as well as their duration to try and get a better idea of what is happening. Alternatively you could use the ",(0,i.jsx)(t.code,{children:"benchmark"})," facet of the experiment as described previously, but that may be too much details for now."]}),"\n",(0,i.jsx)(t.h3,{id:"identifying-the-problem-in-the-code",children:"Identifying the problem in the code"}),"\n",(0,i.jsx)(t.h4,{id:"isolating-the-code-in-a-simpler-model",children:"isolating the code in a simpler model"}),"\n",(0,i.jsx)(t.h4,{id:"looking-for-exponential-behaviour",children:"Looking for exponential behaviour"}),"\n",(0,i.jsx)(t.h4,{id:"benchmarking",children:"benchmarking"}),"\n",(0,i.jsx)(t.h4,{id:"comparing-to-alternative-code",children:"comparing to alternative code"}),"\n",(0,i.jsx)(t.h2,{id:"what-to-pay-the-most-attention-to",children:"What to pay the most attention to"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"every kind of loop (including the ask statements)"}),"\n",(0,i.jsx)(t.li,{children:"number of agents and interactions"}),"\n",(0,i.jsx)(t.li,{children:"accumulating data"}),"\n",(0,i.jsx)(t.li,{children:"reading and writing files"}),"\n",(0,i.jsx)(t.li,{children:"big string concatenation"}),"\n",(0,i.jsx)(t.li,{children:"any process that has an exponential nature"}),"\n",(0,i.jsx)(t.li,{children:"network code"}),"\n",(0,i.jsx)(t.li,{children:"displays/charts"}),"\n",(0,i.jsx)(t.li,{children:"platform settings"}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(96540);const o={},a=i.createContext(o);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);