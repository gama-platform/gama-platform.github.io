"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[65817],{3905:(e,i,n)=>{n.d(i,{Zo:()=>_,kt:()=>b});var t=n(67294);function o(e,i,n){return i in e?Object.defineProperty(e,i,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[i]=n,e}function l(e,i){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);i&&(t=t.filter((function(i){return Object.getOwnPropertyDescriptor(e,i).enumerable}))),n.push.apply(n,t)}return n}function a(e){for(var i=1;i<arguments.length;i++){var n=null!=arguments[i]?arguments[i]:{};i%2?l(Object(n),!0).forEach((function(i){o(e,i,n[i])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(i){Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(n,i))}))}return e}function r(e,i){if(null==e)return{};var n,t,o=function(e,i){if(null==e)return{};var n,t,o={},l=Object.keys(e);for(t=0;t<l.length;t++)n=l[t],i.indexOf(n)>=0||(o[n]=e[n]);return o}(e,i);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)n=l[t],i.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var d=t.createContext({}),s=function(e){var i=t.useContext(d),n=i;return e&&(n="function"==typeof e?e(i):a(a({},i),e)),n},_=function(e){var i=s(e.components);return t.createElement(d.Provider,{value:i},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var i=e.children;return t.createElement(t.Fragment,{},i)}},p=t.forwardRef((function(e,i){var n=e.components,o=e.mdxType,l=e.originalType,d=e.parentName,_=r(e,["components","mdxType","originalType","parentName"]),m=s(n),p=o,b=m["".concat(d,".").concat(p)]||m[p]||c[p]||l;return n?t.createElement(b,a(a({ref:i},_),{},{components:n})):t.createElement(b,a({ref:i},_))}));function b(e,i){var n=arguments,o=i&&i.mdxType;if("string"==typeof e||o){var l=n.length,a=new Array(l);a[0]=p;var r={};for(var d in i)hasOwnProperty.call(i,d)&&(r[d]=i[d]);r.originalType=e,r[m]="string"==typeof e?e:o,a[1]=r;for(var s=2;s<l;s++)a[s]=n[s];return t.createElement.apply(null,a)}return t.createElement.apply(null,n)}p.displayName="MDXCreateElement"},60295:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>_,contentTitle:()=>d,default:()=>b,frontMatter:()=>r,metadata:()=>s,toc:()=>m});var t=n(87462),o=n(63366),l=(n(67294),n(3905)),a=["components"],r={"^title":"MondrianCity"},d=void 0,s={unversionedId:"MondrianCity",id:"MondrianCity",title:"MondrianCity",description:"Path: Library models/Toy Models/Evacuation/models/Continuous Move.gaml",source:"@site/../docs/MondrianCity.md",sourceDirName:".",slug:"/MondrianCity",permalink:"/wiki/next/MondrianCity",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/MondrianCity/_edit",tags:[],version:"current",frontMatter:{"^title":"MondrianCity"}},_={},m=[],c={toc:m},p="wrapper";function b(e){var i=e.components,n=(0,o.Z)(e,a);return(0,l.kt)(p,(0,t.Z)({},c,n,{components:i,mdxType:"MDXLayout"}),(0,l.kt)("img",{width:"959",alt:"Annotation 2023-04-15 125541_MondrianCity",src:"https://user-images.githubusercontent.com/4437331/232210514-d99820bb-15a2-4c1a-b448-66c65d3de3f5.png"}),(0,l.kt)("p",null,"Path: Library models/Toy Models/Evacuation/models/Continuous Move.gaml"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'\n/***\n* Name: Mondrian City\n* Author: Arnaud Grignard, Tri Nguyen-Huu and Patrick Taillandier \n* Description: An abstract mobilty Model represented in a Mondrian World. \n* Tags: art, interaction, mobility\n***/\n\nmodel Mondrian_City\n\n\nglobal{\n    \n    float weight_mobility1;\n    float weight_mobility2;\n    float weight_mobility3;\n    int population_level;\n\n    \n    float spacing <- 0.75;\n    float line_width <- 0.65;\n    bool dynamical_width <- true;\n    \n    float building_scale <- 0.65; \n    bool show_cells <- false;\n    bool show_building <- true;\n    bool show_road <- true;\n    bool show_agent <- true;\n         \n    int grid_height <- 6;\n    int grid_width <- 6;\n    float environment_height <- 5000.0;\n    float environment_width <- 5000.0;\n    int global_people_size <-50;\n            \n    float computed_line_width;\n    float road_width;\n    float block_size;\n    \n    bool on_modification_cells <- false update: show_cells != show_cells_prev;\n    bool show_cells_prev <- show_cells update: show_cells ;\n    bool on_modification_bds <- false update: false;    \n        \n    map<string,int> max_traffic_per_mode <- ["mobility1"::50, "mobility2"::50, "walk"::50];\n    map<string,int> mode_order <- ["mobility1"::0, "mobility2"::1, "walk"::2]; \n    map<string,rgb> color_per_mode <- ["mobility1"::rgb(52,152,219), "mobility2"::rgb(192,57,43), "walk"::rgb(161,196,90), "mobility3"::#magenta];\n    map<string,geometry> shape_per_mode <- ["mobility1"::circle(global_people_size*0.225), "mobility2"::circle(global_people_size*0.21), "walk"::circle(global_people_size*0.2), "mobility3"::circle(global_people_size*0.21)];\n    \n    map<string,point> offsets <- ["mobility1"::{0,0}, "mobility2"::{0,0}, "walk"::{0,0}];\n    map<string,list<rgb>> colormap_per_mode <- ["mobility1"::[rgb(107,213,225),rgb(255,217,142),rgb(255,182,119),rgb(255,131,100),rgb(192,57,43)], "mobility2"::[rgb(107,213,225),rgb(255,217,142),rgb(255,182,119),rgb(255,131,100),rgb(192,57,43)], "walk"::[rgb(107,213,225),rgb(255,217,142),rgb(255,182,119),rgb(255,131,100),rgb(192,57,43)]];\n    map<string,rgb> color_per_id <- ["residentialS"::#blue,"residentialM"::#white,"residentialL"::#cyan,"officeS"::#yellow,"officeM"::#red,"officeL"::#green];\n    map<string,float> nb_people_per_size <- ["S"::10.0, "M"::50.0, "L"::100.0];\n    map<string,float> proba_choose_per_size <- ["S"::0.1, "M"::0.5, "L"::1.0];\n    map<int, list<string>> id_to_building_type <- [1::["residential","S"],2::["residential","M"],3::["residential","L"],4::["office","S"],5::["office","M"],6::["office","L"]];\n        \n    float weight_mobility1_prev <- weight_mobility1;\n    float weight_mobility2_prev <- weight_mobility2;\n    float weight_mobility3_prev <- weight_mobility3;\n    \n    list<building> residentials;\n    map<building, float> offices;\n\n    map<string,graph> graph_per_mode;\n    float road_capacity <- 10.0;\n    geometry shape<-rectangle(environment_width, environment_height);\n    float step <- sqrt(shape.area) /2000.0 ;\n    \n    map<string,list<float>> speed_per_mobility <- ["mobility1"::[20.0,40.0], "mobility2"::[5.0,15.0], "walk"::[3.0,7.0], "mobility3"::[15.0,30.0]];\n    \n    init {\n        list<geometry> lines;\n        float cell_w <- first(cell).shape.width;\n        float cell_h <- first(cell).shape.height;\n        loop i from: 0 to: grid_width {\n            lines << line([{i*cell_w,0}, {i*cell_w,environment_height}]);\n        }\n        loop i from: 0 to: grid_height {\n            lines << line([{0, i*cell_h}, {environment_width,i*cell_h}]);\n        }\n        create road from: split_lines(lines) {\n            create road with: [shape:: line(reverse(shape.points))];\n        }\n        do update_graphs;\n        block_size <- min([first(cell).shape.width,first(cell).shape.height]);\n    }\n    \n    action update_graphs {\n        loop mode over: ["walk", "mobility1", "mobility2"] {\n            graph_per_mode[mode] <- directed(as_edge_graph(road where (mode in each.allowed_mobility)));\n        }\n    }\n    \n    reflex update_mobility  {\n        if(weight_mobility1_prev != weight_mobility1) or (weight_mobility2_prev != weight_mobility2) or (weight_mobility3_prev != weight_mobility3) {\n            ask people {\n                know_mobility3 <- flip(weight_mobility3);\n                has_mobility1 <- flip(weight_mobility1);\n                has_mobility2 <- flip(weight_mobility2);\n                \n                do choose_mobility;\n                do mobility;\n            }\n        }\n        weight_mobility1_prev <- weight_mobility1;\n        weight_mobility2_prev <- weight_mobility2;\n        weight_mobility3_prev <-weight_mobility3;\n        \n    }\n        \n    reflex randomGridUpdate when:every(1000#cycle){\n        do randomGrid;\n    } \n        \n    reflex compute_traffic_density{\n        ask road {traffic_density <- ["mobility1"::[0::0,1::0], "mobility2"::[0::0,1::0], "walk"::[0::0,1::0], "mobility3"::[0::0,1::0]];}\n\n        ask people{\n            if current_path != nil and current_path.edges != nil{\n                ask list<road>(current_path.edges){\n                    traffic_density[myself.mobility_mode][myself.heading_index]  <- traffic_density[myself.mobility_mode][myself.heading_index] + 1;\n                }\n            }\n        }\n    }\n    \n    reflex precalculate_display_variables{\n        road_width <- block_size * 2/3 * (1-building_scale);\n        computed_line_width <- line_width * road_width/10;\n        loop t over: mode_order.keys{\n            offsets[t] <- {0.5*road_width*spacing*(mode_order[t]+0.5)/(length(mode_order)-0.5),0.5*road_width*spacing*(mode_order[t]+0.5)/(length(mode_order)-0.5)};\n        }       \n    }\n        \n    action manage_road{\n        road selected_road <- first(road overlapping (circle(sqrt(shape.area)/100.0) at_location #user_location));\n        if (selected_road != nil) {\n            bool with_mobility1 <- "mobility1" in selected_road.allowed_mobility;\n            bool with_mobility2 <- "mobility2" in selected_road.allowed_mobility;\n            bool with_pedestrian <- "walk" in selected_road.allowed_mobility;\n            map input_values <- user_input_dialog([enter("mobility1 allowed",with_mobility1),enter("mobility2 allowed",with_mobility2),enter("pedestrian allowed",with_pedestrian)]);\n            if (with_mobility1 != input_values["mobility1 allowed"]) {\n                if (with_mobility1) {selected_road.allowed_mobility >> "mobility1";}\n                else {selected_road.allowed_mobility << "mobility1";}\n                \n            }\n            if (with_mobility2 != input_values["mobility2 allowed"]) {\n                if (with_mobility2) {selected_road.allowed_mobility >> "mobility2";}\n                else {selected_road.allowed_mobility << "mobility2";}\n            }\n            if (with_pedestrian != input_values["pedestrian allowed"]) {\n                if (with_pedestrian) {selected_road.allowed_mobility >> "walk";}\n                else {selected_road.allowed_mobility << "walk";}\n            }\n            point pt1 <- first(selected_road.shape.points);\n            point pt2 <- last(selected_road.shape.points);\n            road reverse_road <- road first_with ((first(each.shape.points) = pt2) and (last(each.shape.points) = pt1));\n            if (reverse_road != nil) {\n                reverse_road.allowed_mobility <-  selected_road.allowed_mobility;\n            }\n            do update_graphs;\n        }   \n    }\n    \n    action createCell(int id, int x, int y){\n        list<string> types <- id_to_building_type[id];\n        string type <- types[0];\n        string size <- types[1];\n        cell current_cell <- cell[x,y];\n        bool new_building <- true;\n        if (current_cell.my_building != nil) {\n            building build <- current_cell.my_building;\n            new_building <- (build.type != type) or (build.size != size);\n        }\n        if (new_building) {\n            if (type = "residential") {\n                ask current_cell {do new_residential(size);}\n            } else if (type = "office") {\n                ask current_cell {do new_office(size);}\n            }\n        }\n    } \n    \n   action randomGrid{\n    int id;\n    loop i from: 0 to: 5 {\n        loop j from: 0 to: 5 {\n            if (flip(0.5)){\n                id <- 1+rnd(5); \n            }else{\n                id<--1;\n            }           \n            if (id > 0) {\n             do createCell(id, j, i);\n            }\n            cell current_cell <- cell[j,i];\n            current_cell.is_active <- id<0?false:true;\n            if (id<=0){                 \n                ask current_cell{ do erase_building;}\n            }\n        }\n    }\n   }        \n}\n\n\nspecies building {\n    string size <- "S" among: ["S", "M", "L"];\n    string type <- "residential" among: ["residential", "office"];\n    list<people> inhabitants;\n    rgb color;\n    geometry bounds;\n\n    action initialize(cell the_cell, string the_type, string the_size) {\n        the_cell.my_building <- self;\n        type <- the_type;\n        size <- the_size;\n        do define_color;\n        shape <- the_cell.shape;\n        if (type = "residential") {residentials << self;}\n        else if (type = "office") {\n            offices[self] <- proba_choose_per_size[size];\n        }\n        bounds <- the_cell.shape + 0.5 - shape;\n            \n    }\n    \n    reflex populate when: (type = "residential"){\n        int pop <- int(population_level/100 * nb_people_per_size[size]);\n        if length(inhabitants) < pop{\n            create people number: 1 with: [location::any_location_in(bounds)] {\n                origin <- myself;\n                origin.inhabitants << self;\n                \n                do reinit_destination;\n            }\n        }\n        if length(inhabitants) > pop{\n            people tmp <- one_of(inhabitants);\n            inhabitants >- tmp;\n            ask tmp {do die;}\n        }\n    }\n    \n    action remove {\n        if (type = "office") {\n            offices[] >- self;\n            ask people {\n                do reinit_destination;\n            }\n        } else {\n            ask inhabitants {\n                do die;\n            }\n        }\n        cell(location).my_building <- nil;\n        do die;\n        \n    }\n    action define_color {\n        color <- color_per_id[type+size];\n    }\n    aspect default {\n        if show_building {draw shape scaled_by building_scale*1.1 wireframe:true color: color;}\n    }\n}\n\nspecies road {\n    int nb_people;\n    map<string,map<int,int>> traffic_density <- ["mobility1"::[0::0,1::0], "mobility2"::[0::0,1::0], "walk"::[0::0,1::0], "mobility3"::[0::0,1::0]];\n    rgb color <- rnd_color(255);\n    list<string> allowed_mobility <- ["walk","mobility2","mobility1"];\n\n    init {\n    }\n    \n    int total_traffic{\n        return sum(traffic_density.keys collect(sum(traffic_density[each])));\n    }\n    \n    \n    int total_traffic_per_mode(string m){\n        return sum(traffic_density[m]);\n    }\n    \n    \n    rgb color_map(rgb c, float scale){\n        return rgb(255+scale * (c.red - 255),255+scale * (c.green - 255),255+scale * (c.blue - 255));\n    }\n\n    aspect default {\n        if(show_road){\n            loop t over: mode_order.keys{\n                    float scale <- min([1,traffic_density[t][0] / max_traffic_per_mode[t]]);    \n                    if dynamical_width{\n                        if scale > 0 {draw shape + computed_line_width * scale color: color_per_mode[t] at: self.location+offsets[t];}\n                        scale <- min([1,traffic_density[t][1] / max_traffic_per_mode[t]]);  \n                        if scale > 0 {draw shape + computed_line_width * scale color: color_per_mode[t] at: self.location-offsets[t];}\n                    }else{\n                        if scale > 0 {draw shape + computed_line_width color: color_map(color_per_mode[t],scale) at: self.location+offsets[t];}\n                        scale <- min([1,traffic_density[t][1] / max_traffic_per_mode[t]]);  \n                        if scale > 0 {draw shape + computed_line_width color: color_map(color_per_mode[t],scale) at: self.location-offsets[t];}\n                    }\n                }\n            \n        }\n                \n\n    }\n}\n\nspecies people skills: [moving]{\n\n    int heading_index <- 0;\n    string mobility_mode <- "walk"; \n    float display_size <-sqrt(world.shape.area)* 0.01;\n    building origin;\n    building dest;\n    bool to_destination <- true;\n    point target;\n    bool know_mobility3 <- false;\n    bool has_mobility1 <- flip(weight_mobility1);\n    bool has_mobility2 <- flip(weight_mobility2);\n    float max_dist_walk <- 1000.0;\n    float max_dist_mobility2 <- 3000.0;\n    float max_dist_mobility3 <- 5000.0;\n    action choose_mobility {\n        if (origin != nil and dest != nil) {\n            float dist <- manhattan_distance(origin.location, dest.location);\n            if (dist <= max_dist_walk ) {\n                    mobility_mode <- "walk";\n            } else if (has_mobility2 and dist <= max_dist_mobility2 ) {\n                    mobility_mode <- "mobility2";\n            } else if (know_mobility3 and (dist <= max_dist_mobility3 )) {\n                    mobility_mode <- "mobility3";\n            } else if has_mobility1 {\n                    mobility_mode <- "mobility1";\n            } else {\n                    mobility_mode <- "walk";\n            }\n        speed <- rnd(speed_per_mobility[mobility_mode][0],speed_per_mobility[mobility_mode][1]) #km/#h;\n        }\n    }\n    \n    float manhattan_distance (point p1, point p2) {\n        return abs(p1.x - p2.x) + abs(p1.y - p2.y);\n    }\n    reflex update_heading_index{\n        if (mod(heading+90,360) < 135) or (mod(heading+90,360) > 315){\n                        heading_index <- 0;\n                    } else{\n                        heading_index <- 1;\n                    }\n    }\n    action reinit_destination {\n        dest <- empty(offices) ? nil : offices.keys[rnd_choice(offices.values)];\n        target <- nil;\n    }\n    \n    action mobility {\n        do unregister;\n        do goto target: target on: graph_per_mode[(mobility_mode = "mobility3") ? "mobility2" : mobility_mode] recompute_path: false ;\n        do register;\n    }\n    action update_target {\n        if (to_destination) {target <- any_location_in(dest);}//centroid(dest);}\n        else {target <- any_location_in(origin);}//centroid(origin);}\n        do choose_mobility;\n        do mobility;\n    }\n    \n    action register {\n        if ((mobility_mode = "mobility1") and current_edge != nil) {\n            road(current_edge).nb_people <- road(current_edge).nb_people + 1;\n        }\n    }\n    action unregister {\n        if ((mobility_mode = "mobility1") and current_edge != nil) {\n            road(current_edge).nb_people <- road(current_edge).nb_people - 1;\n        }\n    }\n\n    reflex move when: dest != nil{\n        if (target = nil) {\n            do update_target;\n        }\n        do mobility;\n        if (target = location) {\n            target <- nil;\n            to_destination <- not to_destination;\n            do update_target;\n        }\n    }\n    \n    reflex wander when: dest = nil and origin != nil {\n        do wander bounds: origin.bounds;\n    }\n\n    \n    aspect default{\n        if(show_agent){\n        point offset <- {0,0};\n        if self.current_edge != nil {\n          offset <- offsets[mobility_mode]*(heading_index > 0 ? (-1): 1);   \n        }\n        if (target != nil or dest = nil) {\n            if(mobility_mode ="mobility1"){\n              draw copy(shape_per_mode[mobility_mode])  color: color_per_mode[mobility_mode] border:color_per_mode[mobility_mode] rotate:heading +90 at: location+offset;\n            }else{\n              draw copy(shape_per_mode[mobility_mode])  color: color_per_mode[mobility_mode] rotate:heading +90 at: location+offset;    \n            }\n        }   \n      }\n    }\n}\n\ngrid cell width: grid_width height: grid_height { \n    building my_building;\n    bool is_active <- true;\n    action new_residential(string the_size) {\n        if (my_building != nil and (my_building.type = "residential") and (my_building.size = the_size)) {\n            return;\n        } else {\n            if (my_building != nil ) {ask my_building {do remove;}}\n            create building returns: bds{\n                do initialize(myself, "residential", the_size);\n            }\n        }\n        \n    }\n    action new_office (string the_size) {\n        if (my_building != nil and (my_building.type = "office") and (my_building.size = the_size)) {\n            return;\n        } else {\n            if (my_building != nil) {ask my_building {do remove;}}\n            create building returns: bds{\n                do initialize(myself, "office",the_size);\n            }\n            ask people {\n                do reinit_destination;\n            }\n        }\n    }\n    action erase_building {\n        if (my_building != nil) {ask my_building {do remove;}}\n    }\n    \n    aspect default{\n        if show_cells {draw shape scaled_by (0.5) color: rgb(100,100,100) ;}\n    }\n}\n\nexperiment MondrianCity type: gui autorun: true{\n    float minimum_cycle_duration <- 0.05;\n    parameter "mobility1 level" var: weight_mobility1 min: 0.1 max: 1.0 step: 0.1 colors: [#gamablue] <-0.5;\n    parameter "mobility2 level" var: weight_mobility2 min: 0.1 max: 1.0 step: 0.1 colors: [#gamablue] <-0.5;\n    parameter "mobility3 level" var: weight_mobility3 min: 0.1 max: 1.0 step: 0.1 colors: [#gamablue] <-0.5;\n    parameter "Population level" var: population_level min: 0 max: 100 step: 1 colors: [#gamablue] <-50;\n\n    output synchronized:true{\n        display map background:#black toolbar:false type:3d  axes:false fullscreen:false{\n            species cell aspect:default;\n            species road ;\n            species people;\n            species building;\n            event "a" {show_agent<-!show_agent;}\n            event "r" {show_road<-!show_road;}\n            event "b"  {show_building<-!show_building;}         \n        }       \n    }\n}\n\n')))}b.isMDXComponent=!0}}]);