"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[49082],{28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var i=n(96540);const s={},a=i.createContext(s);function o(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:t},e.children)}},60548:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"BatchExperiments","title":"Defining Batch Experiments","description":"Batch experiments allow to execute numerous successive simulation runs. They are used to explore the parameter space of a model or to optimize a set of model parameters. Exploration methods are detailed in this page.","source":"@site/versioned_docs/version-1.8.1/BatchExperiments.md","sourceDirName":".","slug":"/BatchExperiments","permalink":"/wiki/1.8.1/BatchExperiments","draft":false,"unlisted":false,"editUrl":"https://github.com/gama-platform/gama/wiki/BatchExperiments/_edit","tags":[],"version":"1.8.1","frontMatter":{"title":"Defining Batch Experiments"},"sidebar":"main","previous":{"title":"Run Several Simulations","permalink":"/wiki/1.8.1/RunSeveralSimulations"},"next":{"title":"Exploration Methods","permalink":"/wiki/1.8.1/ExplorationMethods"}}');var s=n(74848),a=n(28453);const o={title:"Defining Batch Experiments"},r=void 0,l={},c=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"The batch experiment facets",id:"the-batch-experiment-facets",level:2},{value:"Action <code>_step_</code> and reflexes",id:"action-_step_-and-reflexes",level:2},{value:"Permanent",id:"permanent",level:2}];function h(e){const t={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["Batch experiments allow to execute numerous successive simulation runs. They are used to explore the parameter space of a model or to optimize a set of model parameters. ",(0,s.jsx)(t.a,{href:"ExplorationMethods",children:"Exploration methods are detailed in this page."})]}),"\n",(0,s.jsx)(t.p,{children:"A Batch experiment is defined by:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"experiment exp_title type: batch until: condition {\n   [parameter to explore]\n   [exploration method]\n   [reflex]\n   [permanent]\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"table-of-contents",children:"Table of contents"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#the-batch-experiment-facets",children:"The batch experiment facets"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsxs)(t.a,{href:"#action-_step_-and-reflexes",children:["Action ",(0,s.jsx)(t.code,{children:"_step_"})," and reflexes"]})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#permanent",children:"Permanent"})}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"the-batch-experiment-facets",children:"The batch experiment facets"}),"\n",(0,s.jsx)(t.p,{children:"Batch experiments have the following three facets:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"until"}),": (expression) Specifies when to stop each simulation. Its value is a condition on variables defined in the model. The run will stop when the condition is evaluated to true. If omitted, the first simulation run will go forever, preventing any subsequent run to take place (unless a halt command is used in the model itself)."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"repeat"}),": (integer) A parameter configuration corresponds to a set of values assigned to each parameter. The attribute repeat specifies the number of times each configuration will be repeated, meaning that as many simulations will be run with the same parameter values. Different random seeds are given to the pseudo-random number generator. This allows to get some statistical power from the experiments conducted. The default value is 1."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"keep_seed"}),": (boolean) If true, the same series of random seeds will be used from one parameter configuration to another. The default value is false."]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"experiment my_batch_experiment type: batch repeat: 5 keep_seed: true until: (cycle = 300) {\n   [parameter to explore]\n   [exploration method]\n}\n"})}),"\n",(0,s.jsxs)(t.h2,{id:"action-_step_-and-reflexes",children:["Action ",(0,s.jsx)(t.code,{children:"_step_"})," and reflexes"]}),"\n",(0,s.jsxs)(t.p,{children:["As for any species, ",(0,s.jsx)(t.code,{children:"experiment"})," can define as many ",(0,s.jsx)(t.code,{children:"reflex"})," as needed. In a ",(0,s.jsx)(t.code,{children:"batch"})," experiment, they will be executed at the end of each bunch of simulations (set of replications) for a given parameters configuration. Note that at the experiment level, you have access to all the species and all the global variables and to all the simulations (variable ",(0,s.jsx)(t.code,{children:"simulations"}),")."]}),"\n",(0,s.jsxs)(t.p,{children:["To be complete, in fact, each experiment (as any agent) will call at each step (i.e. the end of the replications set) the ",(0,s.jsx)(t.code,{children:"_step_"})," action: this action is in charge of executing the behavior of the experiment agent, that is by default the execution of each of its ",(0,s.jsx)(t.code,{children:"reflex"}),". So it is also possible to redefine the action ",(0,s.jsx)(t.code,{children:"_step_"}),", but it will inhibit the reflexes."]}),"\n",(0,s.jsx)(t.p,{children:"For instance, the following experiment runs the simulation 5 times, and, at the end of the 5 simulations, saves the people agents in a shapefile."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'experiment \'Run 5 simulations\' type: batch repeat: 5 keep_seed: true until: ( time > 1000 ) {\n    int cpt <- 0;\n\n    reflex save_people {\n\tsave people type:"shp" to:"people_shape" + cpt + ".shp" with: [is_infected::"INFECTED", is_immune::"IMMUNE"];\n\tcpt <- cpt + 1;\n    }\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["The same can be done using the ",(0,s.jsx)(t.code,{children:"action _step_ {"})," instead of ",(0,s.jsx)(t.code,{children:"reflex save_people {"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["But if now we want to save information from the 5 simulations as save 1 shapefile per replication or save aggregated values over the five simulations, we need to use the built-in attribute ",(0,s.jsx)(t.code,{children:"simulations"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"To save 1 shapefile per simulation run, we thus need to write:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'experiment \'Run 5 simulations\' type: batch repeat: 5 keep_seed: true until: ( time > 1000 ) {\n    reflex end_of_runs {\n\tint cpt <- 0;\n\task simulations {\n\t    save people type: "shp" to: "result/people_shape" + cpt + ".shp" with: [is_infected::"INFECTED", is_immune::"IMMUNE"];\n\t    cpt <- cpt + 1;\n\t}\n    }\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"If now we want to save in a file the average number of infected people over the five simulations."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'experiment \'Run 5 simulations\' type: batch repeat: 5 keep_seed: true until: ( cycle > 1000 ) {\n    reflex t {\n        save [cycle, simulations mean_of each.nb_infected] to: "result.txt" type: "csv";\n    }\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"permanent",children:"Permanent"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"permanent"})," statement allows the modeler to define an output block that will not be re-initialized at the beginning of each simulation but will be filled at the end of each simulation.\nFor instance, this ",(0,s.jsx)(t.code,{children:"permanent"})," section will plot for each simulation the end value of the ",(0,s.jsx)(t.code,{children:"food_gathered"})," variable (defined as a global variable in the model)."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'permanent {\n    display Ants background: #white refresh: every(1#cycle) {\n\tchart "Food Gathered" type: series {\n\t    data "Food" value: food_gathered;\n\t}\n    }\n}\n'})})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);