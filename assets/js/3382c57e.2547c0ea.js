"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7711],{87230:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"DevelopingControlArchitectures","title":"Developing architecture","description":"In addition to existing control architectures, developers can add new ones.","source":"@site/versioned_docs/version-1.8.2-RC2/DevelopingControlArchitectures.md","sourceDirName":".","slug":"/DevelopingControlArchitectures","permalink":"/wiki/1.8.2-RC2/DevelopingControlArchitectures","draft":false,"unlisted":false,"editUrl":"https://github.com/gama-platform/gama/wiki/DevelopingControlArchitectures/_edit","tags":[],"version":"1.8.2-RC2","frontMatter":{"title":"Developing architecture"},"sidebar":"main","previous":{"title":"Developing Species","permalink":"/wiki/1.8.2-RC2/DevelopingSpecies"},"next":{"title":"Index of annotations","permalink":"/wiki/1.8.2-RC2/DevelopingIndexAnnotations"}}');var o=n(74848),s=n(28453);const c={title:"Developing architecture"},l=void 0,r={},a=[{value:"Implementation",id:"implementation",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["In addition to existing ",(0,o.jsx)(t.a,{href:"BuiltInArchitectures",children:"control architectures"}),", developers can add new ones."]}),"\n",(0,o.jsxs)(t.p,{children:["Defining a new control architecture needs to ",(0,o.jsx)(t.a,{href:"DevelopingStatements",children:"create new statements of type behavior"})," and included in species statements and to define how to manage their execution."]}),"\n",(0,o.jsx)(t.h2,{id:"implementation",children:"Implementation"}),"\n",(0,o.jsx)(t.p,{children:"A control architecture is a Java class, that:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["is annotated by the ",(0,o.jsx)(t.a,{href:"DevelopingIndexAnnotations#@skill",children:"@skill"})," annotation,"]}),"\n",(0,o.jsxs)(t.li,{children:["extends the ",(0,o.jsx)(t.code,{children:"AbstractArchitecture"})," class (to get benefits of everything from the ",(0,o.jsx)(t.code,{children:"reflex"}),"-based control architecture, the ",(0,o.jsx)(t.code,{children:"ReflexArchitecture"})," class can be extended instead)."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"AbstractArchitecture"})," extends the ",(0,o.jsx)(t.code,{children:"ISkill"})," and ",(0,o.jsx)(t.code,{children:"IStatement"})," interfaces and add the 2 following methods:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"public abstract boolean init(IScope scope) throws GamaRuntimeException;"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"public abstract void verifyBehaviors(ISpecies context);"})}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"The three main methods to implement are thus:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"public void setChildren(final List<? extends ISymbol> children)"}),": this method will be called at the compilation of the model. It allows to manage all the embeded statements (in ",(0,o.jsx)(t.code,{children:"children"}),") and for example separate the statements that should be executed at the initialization only from the ones that should be executed at each simulation step. Following example allows to test the name of the all the embedded statements:"]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"for ( final ISymbol c : children ) {\n   if( IKeyword.INIT.equals(c.getFacet(IKeyword.KEYWORD).literalValue()) ) {\n"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"public abstract boolean init(IScope scope) throws GamaRuntimeException"}),": this method is called only once, at the initialization of the agent."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"public Object executeOn(final IScope scope) throws GamaRuntimeException"}),": this method is executed at each simulation step. It should manage the execution of the various embedded behaviors (e.g. their order or choose which one will be executed...)."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>l});var i=n(96540);const o={},s=i.createContext(o);function c(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);