"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[39561],{28453(e,n,i){i.d(n,{R:()=>r,x:()=>d});var s=i(96540);const t={},l=s.createContext(t);function r(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(l.Provider,{value:n},e.children)}},36867(e,n,i){i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"AttachingSkills","title":"Attaching Skills","description":"[//]: # (startConcept|attaching_skills)","source":"@site/versioned_docs/version-1.9.3/AttachingSkills.md","sourceDirName":".","slug":"/AttachingSkills","permalink":"/wiki/1.9.3/AttachingSkills","draft":false,"unlisted":false,"editUrl":"https://github.com/gama-platform/gama/wiki/AttachingSkills/_edit","tags":[],"version":"1.9.3","frontMatter":{"title":"Attaching Skills"},"sidebar":"main","previous":{"title":"Interaction between agents","permalink":"/wiki/1.9.3/InteractionBetweenAgents"},"next":{"title":"Inheritance","permalink":"/wiki/1.9.3/Inheritance"}}');var t=i(74848),l=i(28453);const r={title:"Attaching Skills"},d=void 0,o={},c=[{value:"Index",id:"index",level:2},{value:"Skills",id:"skills",level:2},{value:"Attributes:",id:"attributes",level:3},{value:"Actions:",id:"actions",level:3},{value:"<strong><code>follow</code></strong>",id:"follow",level:4},{value:"<strong><code>goto</code></strong>",id:"goto",level:4},{value:"<strong><code>move</code></strong>",id:"move",level:4},{value:"<strong><code>wander</code></strong>",id:"wander",level:4},{value:"<strong><code>wander_3D</code></strong>",id:"wander_3d",level:4},{value:"Other skills",id:"other-skills",level:3},{value:"Example",id:"example",level:3}];function a(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["GAMA allows the modeler to increase the capabilities of the GAMA agents by attaching skills to them through the facet ",(0,t.jsx)(n.code,{children:"skills"}),". Skills are built-in modules that provide a set of related built-in attributes and built-in actions (in addition to those already proposed by GAMA) to the species that declare them. The ",(0,t.jsx)(n.a,{href:"BuiltInSkills",children:"list of the available skills can be found on the dedicated page"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"index",children:"Index"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#the-moving-skill",children:"The moving skill"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#other-skills",children:"Other skills"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#example-of-implementation",children:"Example of implementation"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"skills",children:"Skills"}),"\n",(0,t.jsxs)(n.p,{children:["A declaration of skill is done by filling the ",(0,t.jsx)(n.code,{children:"skills"})," facet in the species definition:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"species my_species skills: [skill1,skill2] {\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["A very useful and common skill is ",(0,t.jsxs)(n.a,{href:"BuiltInSkills#moving",children:["the ",(0,t.jsx)(n.code,{children:"moving"})," skill"]}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"species my_species skills: [moving] {\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Once your species has the moving skill, it earns automatically the following attributes: ",(0,t.jsx)(n.code,{children:"speed"}),", ",(0,t.jsx)(n.code,{children:"heading"}),", ",(0,t.jsx)(n.code,{children:"destination"})," and the following actions: ",(0,t.jsx)(n.code,{children:"move"}),", ",(0,t.jsx)(n.code,{children:"goto"}),", ",(0,t.jsx)(n.code,{children:"follow"}),", ",(0,t.jsx)(n.code,{children:"wander"})," and ",(0,t.jsx)(n.code,{children:"wander_3D"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"attributes",children:"Attributes:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"speed"})})," (float) designs the speed of the agent, in m/s."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"heading"})})," (int) designs the heading of an agent in degrees, which means that is the maximum angle the agent can turn around each step."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"destination"})})," (point) is the updated destination of the agent, with respect to its speed and heading. It's a read-only attribute, you can't change its value."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"actions",children:"Actions:"}),"\n",(0,t.jsx)(n.h4,{id:"follow",children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"follow"})})}),"\n",(0,t.jsx)(n.p,{children:"moves the agent along a given path passed in the arguments."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"returns: path"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"speed"})})," (float): the speed to use for this move (replaces the current value of speed)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"path"})})," (path): a path to be followed."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"move_weights"})})," (map): Weights used for the moving."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"return_path"})})," (boolean): if true, return the path followed (by default: false)"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"goto",children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"goto"})})}),"\n",(0,t.jsx)(n.p,{children:"moves the agent towards the target passed in the arguments."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"returns: path"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"target"})})," (agent,point,geometry): the location or entity towards which to move."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"speed"})})," (float): the speed to use for this move (replaces the current value of speed)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"on"})})," (graph): graph that restrains this move"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"recompute_path"})})," (boolean): if false, the path is not recompute even if the graph is modified (by default: true)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"return_path"})})," (boolean): if true, return the path followed (by default: false)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"move_weights"})})," (map): Weights used for the moving."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"move",children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"move"})})}),"\n",(0,t.jsx)(n.p,{children:"moves the agent forward, the distance being computed with respect to its speed and heading. The value of the corresponding variables are used unless arguments are passed."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"returns: path"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"speed"})})," (float): the speed to use for this move (replaces the current value of speed)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"heading"})})," (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"bounds"})})," (geometry,agent): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"wander",children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"wander"})})}),"\n",(0,t.jsx)(n.p,{children:"Moves the agent towards a random location at the maximum distance (with respect to its speed). The heading of the agent is chosen randomly if no amplitude is specified. This action changes the value of heading."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"returns: void"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"speed"})})," (float): the speed to use for this move (replaces the current value of speed)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"amplitude"})})," (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"bounds"})})," (agent,geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"wander_3d",children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"wander_3D"})})}),"\n",(0,t.jsx)(n.p,{children:"Moves the agent towards a random location (3D point) at the maximum distance (with respect to its speed). The heading of the agent is chosen randomly if no amplitude is specified. This action changes the value of heading."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"returns: path"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"speed"})})," (float): the speed to use for this move (replaces the current value of speed)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"amplitude"})})," (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"z_max"})})," (int): the maximum altitude (z) the geometry can reach"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"bounds"})})," (agent,geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"other-skills",children:"Other skills"}),"\n",(0,t.jsxs)(n.p,{children:["A lot of other skills are available. Some of them can be ",(0,t.jsx)(n.a,{href:"BuiltInSkills",children:"built in skills"}),", integrated by default in GAMA, other are linked to ",(0,t.jsx)(n.a,{href:"Extension",children:"additional plugins"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["This is the list of skills:\n",(0,t.jsx)(n.code,{children:"Advanced_driving"}),", ",(0,t.jsx)(n.code,{children:"communication"}),", ",(0,t.jsx)(n.code,{children:"driving"}),", ",(0,t.jsx)(n.code,{children:"GAMASQL"}),", ",(0,t.jsx)(n.code,{children:"graphic"}),", ",(0,t.jsx)(n.code,{children:"grid"}),", ",(0,t.jsx)(n.code,{children:"MDXSKILL"}),", ",(0,t.jsx)(n.code,{children:"moving"}),", ",(0,t.jsx)(n.code,{children:"moving3D"}),", ",(0,t.jsx)(n.code,{children:"physical3D"}),", ",(0,t.jsx)(n.code,{children:"skill_road"}),", ",(0,t.jsx)(n.code,{children:"skill_road"}),", ",(0,t.jsx)(n.code,{children:"skill_road_node"}),", ",(0,t.jsx)(n.code,{children:"SQLSKILL"})]}),"\n",(0,t.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,t.jsx)(n.p,{children:'We can now build a model using the skill moving. Let\'s design 2 species, one is "species_red", the other is "species_green".\nSpecies_green agents are moving randomly with a certain speed and a certain heading.\nSpecies_red agents wait for a species_green agent to be in a certain range of distance. Once it is the case, the agent move toward the species_green agent. A line link the red_species agent and its target.'}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"images/green_and_red_species.png",src:i(89385).A+"",width:"568",height:"568"})}),"\n",(0,t.jsx)(n.p,{children:"Here is an example of implementation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"model green_and_red_species\n\nglobal{\n    float distance_to_intercept <- 10.0;\n    int number_of_green_species <- 50;\n    int number_of_red_species <- 50;\n\t\n    init {\n\tcreate speciesA number:number_of_green_species;\n\tcreate speciesB number:number_of_red_species;\n    }\n}\n\nspecies speciesA skills:[moving] {\n    init {\n\tspeed <- 1.0;\n    }\n    reflex move {\n\tdo wander amplitude: 90.0;\n    }\n    aspect default {\n\tdraw circle(1) color:#green border: #black;\n    }\n}\n\nspecies speciesB skills:[moving] {\n    speciesA target;\n    init {\n\tspeed <- 0.0;\n\theading <- 90.0;\n    }\n    reflex search_target when: target=nil {\n\task speciesA at_distance(distance_to_intercept) {\n\t    myself.target <- self;\n\t}\n    }\n    reflex follow when: target!=nil {\n\tspeed <- 0.8;\n\tdo goto target: target;\n    }\n    aspect default {\n\tdraw circle(1) color:#red border: #black;\n\tif (target!=nil) {\n\t    draw polyline([self.location,target.location]) color:#black;\n\t}\n    }\n}\n\nexperiment my_experiment type: gui {\n    output{\n\tdisplay myDisplay {\n\t    species speciesA aspect:default;\n\t    species speciesB aspect:default;\n\t}\n    }\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},89385(e,n,i){i.d(n,{A:()=>s});const s=i.p+"assets/images/green_and_red_species-e6d1a01a44a87fe6918e95705f1fbcce.png"}}]);