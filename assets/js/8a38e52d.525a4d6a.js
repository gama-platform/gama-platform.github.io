"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[33699],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var i=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=i.createContext({}),s=function(e){var n=i.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=s(e.components);return i.createElement(p.Provider,{value:n},e.children)},c="mdxType",f={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},u=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=s(t),u=a,m=c["".concat(p,".").concat(u)]||c[u]||f[u]||o;return t?i.createElement(m,r(r({ref:n},d),{},{components:t})):i.createElement(m,r({ref:n},d))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,r=new Array(o);r[0]=u;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[c]="string"==typeof e?e:a,r[1]=l;for(var s=2;s<o;s++)r[s]=t[s];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}u.displayName="MDXCreateElement"},46127:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>p,default:()=>m,frontMatter:()=>l,metadata:()=>s,toc:()=>c});var i=t(87462),a=t(63366),o=(t(67294),t(3905)),r=["components"],l={title:"3. Integration of GIS Data"},p=void 0,s={unversionedId:"IncrementalModel_step3",id:"version-1.8.1/IncrementalModel_step3",title:"3. Integration of GIS Data",description:"This step illustrates how to load and agentry GIS data.",source:"@site/versioned_docs/version-1.8.1/IncrementalModel_step3.md",sourceDirName:".",slug:"/IncrementalModel_step3",permalink:"/wiki/1.8.1/IncrementalModel_step3",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/IncrementalModel_step3/_edit",tags:[],version:"1.8.1",frontMatter:{title:"3. Integration of GIS Data"},sidebar:"tuto",previous:{title:"2. Charts",permalink:"/wiki/1.8.1/IncrementalModel_step2"},next:{title:"4. Movement on Graph",permalink:"/wiki/1.8.1/IncrementalModel_step4"}},d={},c=[{value:"Formulation",id:"formulation",level:2},{value:"Model Definition",id:"model-definition",level:2},{value:"species",id:"species",level:3},{value:"Global variables",id:"global-variables",level:3},{value:"agentification of GIS data",id:"agentification-of-gis-data",level:3},{value:"environment",id:"environment",level:3},{value:"display",id:"display",level:3},{value:"Complete Model",id:"complete-model",level:2}],f={toc:c},u="wrapper";function m(e){var n=e.components,l=(0,a.Z)(e,r);return(0,o.kt)(u,(0,i.Z)({},f,l,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This step illustrates how to load and agentry GIS data."),(0,o.kt)("h2",{id:"formulation"},"Formulation"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Load, agentify and display two layers of GIS data (building and road)."),(0,o.kt)("li",{parentName:"ul"},"Modify the initialization of the people agents to put them inside buildings.")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Incremental model 3: integration of shapefile data inside the model.",src:t(79239).Z,width:"3584",height:"2118"})),(0,o.kt)("h2",{id:"model-definition"},"Model Definition"),(0,o.kt)("h3",{id:"species"},"species"),(0,o.kt)("p",null,"To integrate easily the two data layers, we have to define two species of agents: the ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"building"))," agents and the ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"road"))," ones. These agents will not have a particular behavior, they will just be displayed.\nWe define an aspect for these species. In this model, we want to represent the geometry of the agent, we then use their geometry in the  ",(0,o.kt)("inlineCode",{parentName:"p"},"draw")," statement. In order to draw the geometry of the agent, we use the attribute ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"shape"))," (which is a built-in attribute of all agents)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"species building {\n    aspect default {\n    draw shape color: #gray border: #black;\n    }\n}\n\nspecies road {\n    aspect default {\n    draw shape color: #black;\n    }\n}\n")),(0,o.kt)("h3",{id:"global-variables"},"Global variables"),(0,o.kt)("p",null,"GAMA allows to automatically read GIS data that are formatted as shapefiles. In order to let the user chooses his/her shapefiles, we define two global variables. One allowing the user to choose the road shapefile, one allowing him/her to choose the building shapefile."),(0,o.kt)("p",null,"Definition of the two global variables of type ",(0,o.kt)("inlineCode",{parentName:"p"},"file")," representing the GIS files:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'global {\n    file shape_file_buildings <- file("../includes/building.shp");\n    file shape_file_roads <- file("../includes/road.shp");\n}\n')),(0,o.kt)("h3",{id:"agentification-of-gis-data"},"agentification of GIS data"),(0,o.kt)("p",null,"In GAMA, the agentification of GIS data is very straightforward: it only requires to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"create")," command with the ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"from"))," facet with the shapefile. Each object of the shapefile will be directly used to instantiate one agent of the specified species."),(0,o.kt)("p",null,"We modify the init section of the global block in order to create ",(0,o.kt)("inlineCode",{parentName:"p"},"road")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"building")," agents from the shapefiles. Then, we define the initial location of people as a point inside one of the building."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"global {\n    ...\n    init {\n    create road from: roads_shapefile;\n    create building from: buildings_shapefile;\n    create people number:nb_people {\n        speed <- agent_speed;\n        location <- any_location_in(one_of(building));\n    }\n    ask nb_infected_init among people {\n        is_infected <- true;\n    }\n    }\n} \n")),(0,o.kt)("p",null,"Note that the name of a species can be used to obtain all the agents of a species (here ",(0,o.kt)("inlineCode",{parentName:"p"},"building")," returns the list of all the buildings). We can thus us the ",(0,o.kt)("inlineCode",{parentName:"p"},"one_of")," operator on ",(0,o.kt)("inlineCode",{parentName:"p"},"building")," to pick a random building agent. The ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"any\\_location\\_in"))," operator returns a random point inside a geometry or an agent geometry."),(0,o.kt)("h3",{id:"environment"},"environment"),(0,o.kt)("p",null,"Building a GIS environment in GAMA requires nothing special, just to define the bounds of the environment, i.e. the geometry of the ",(0,o.kt)("inlineCode",{parentName:"p"},"world")," agent. It is possible to use a shapefile to automatically define it by computing its envelope. In this model, we use the road shapefile to define it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"global {\n    ...\n    geometry shape <- envelope(shape_file_roads); \n    ...\n}\n")),(0,o.kt)("h3",{id:"display"},"display"),(0,o.kt)("p",null,"We add to the ",(0,o.kt)("strong",{parentName:"p"},"map")," display the road and building agents. Again, as we named the aspects ",(0,o.kt)("inlineCode",{parentName:"p"},"default")," we can omit to specify them in the ",(0,o.kt)("inlineCode",{parentName:"p"},"species")," inside the ",(0,o.kt)("inlineCode",{parentName:"p"},"display"),"."),(0,o.kt)("p",null,"In the ",(0,o.kt)("inlineCode",{parentName:"p"},"experiment")," block:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"output {\n    display map {\n        species road;\n    species building;\n    species people;         \n    }\n    ...\n}\n")),(0,o.kt)("h2",{id:"complete-model"},"Complete Model"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'model model3\n\nglobal {\n    int nb_people <- 500;\n    float agent_speed <- 5.0 #km / #h;\n    float step <- 1 #minutes;\n    float infection_distance <- 2.0 #m;\n    float proba_infection <- 0.05;\n    int nb_infected_init <- 5;\n    file roads_shapefile <- file("../includes/road.shp");\n    file buildings_shapefile <- file("../includes/building.shp");\n    geometry shape <- envelope(roads_shapefile);\n    int nb_people_infected <- nb_infected_init update: people count (each.is_infected);\n    int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;\n    float infected_rate update: nb_people_infected / nb_people;\n\n    init {\n    create road from: roads_shapefile;\n    create building from: buildings_shapefile;\n    create people number: nb_people {\n        speed <- agent_speed;\n        location <- any_location_in(one_of(building));\n    }\n\n    ask nb_infected_init among people {\n        is_infected <- true;\n    }\n    }\n\n    reflex end_simulation when: infected_rate = 1.0 {\n    do pause;\n    }\n}\n\nspecies people skills: [moving] {\n    bool is_infected <- false;\n\n    reflex move {\n    do wander;\n    }\n\n    reflex infect when: is_infected {\n    ask people at_distance infection_distance {\n        if flip(proba_infection) {\n        is_infected <- true;\n        }\n    }\n    }\n\n    aspect default {\n    draw circle(5) color: is_infected ? #red : #green;\n    }\n}\n\nspecies road {\n    aspect default {\n    draw shape color: #black;\n    }\n}\n\nspecies building {\n    aspect default {\n    draw shape color: #gray border: #black;\n    }\n}\n\nexperiment main_experiment type: gui {\n    parameter "Infection distance" var: infection_distance;\n    parameter "Proba infection" var: proba_infection min: 0.0 max: 1.0;\n    parameter "Nb people infected at init" var: nb_infected_init;\n    output {\n    monitor "Current hour" value: current_date.hour;\n    monitor "Infected people rate" value: infected_rate;\n    display map {\n        species road;\n        species building;\n        species people;\n    }\n\n    display chart refresh: every(10 #cycles) {\n        chart "Disease spreading" type: series style: spline {\n        data "susceptible" value: nb_people_not_infected color: #green marker: false;\n        data "infected" value: nb_people_infected color: #red marker: false;\n        }\n    }\n    }\n}\n')))}m.isMDXComponent=!0},79239:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/Incremental_model3-6c5f4755f5ad6446ca859411b4eed8ff.png"}}]);