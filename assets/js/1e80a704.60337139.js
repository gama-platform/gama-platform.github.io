"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[74317],{28490:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var t=i(74848),s=i(28453);const r={title:"Defining GUI Experiment"},o=void 0,l={id:"DefiningGUIExperiment",title:"Defining GUI Experiment",description:"[//]: # (startConcept|gui_experiments)",source:"@site/versioned_docs/version-1.8.1/DefiningGUIExperiment.md",sourceDirName:".",slug:"/DefiningGUIExperiment",permalink:"/wiki/1.8.1/DefiningGUIExperiment",draft:!1,unlisted:!1,editUrl:"https://github.com/gama-platform/gama/wiki/DefiningGUIExperiment/_edit",tags:[],version:"1.8.1",frontMatter:{title:"Defining GUI Experiment"},sidebar:"main",previous:{title:"Multi-level architecture",permalink:"/wiki/1.8.1/MultiLevelArchitecture"},next:{title:"Defining Parameters",permalink:"/wiki/1.8.1/DefiningParameters"}},a={},c=[{value:"Types of experiments",id:"types-of-experiments",level:2},{value:"Experiment attributes",id:"experiment-attributes",level:2},{value:"Experiment facets",id:"experiment-facets",level:2},{value:"Defining displays layout",id:"defining-displays-layout",level:2},{value:"Defining elements of the GUI experiment",id:"defining-elements-of-the-gui-experiment",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"When you execute your simulation, you will often need to display some information. For each simulation, you can define some inputs, outputs and behaviors:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The inputs will be composed of parameters manipulated by the user for each simulation."}),"\n",(0,t.jsxs)(n.li,{children:["The behaviors will be used to define behavior executed at each step of the ",(0,t.jsx)(n.strong,{children:"experiment"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["The outputs will be composed of displays, monitors. They will be defined inside the scope ",(0,t.jsx)(n.code,{children:"output"}),". The definition of their layout can also be set with the ",(0,t.jsx)(n.code,{children:"layout"})," statement."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"experiment exp_name type: gui {\n    [input]\n    [beahaviors]\n    output {\n        layout [layout_option]\n        [display statements]\n        [monitor statements]\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"types-of-experiments",children:"Types of experiments"}),"\n",(0,t.jsxs)(n.p,{children:["You can define fours types of experiments (through the facet ",(0,t.jsx)(n.code,{children:"type"}),"):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"gui"})})," experiments (the default type) are used to play an experiment and displays its outputs. It is also used when the user wants to interact with the simulations."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"batch"})})," experiments are used to play an experiment several times (usually with other input values), used for model exploration. We will ",(0,t.jsx)(n.a,{href:"BatchExperiments",children:"come back to this notion a bit further in the tutorial"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"test"})})," experiments are used to ",(0,t.jsx)(n.a,{href:"Writing_Tests",children:"write unit tests"})," on a model (used to ensure its quality)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"memorize"})})," experiments are GUI experiments in which ",(0,t.jsx)(n.a,{href:"Save-and-restore-simulations",children:"the simulation state is kept in memory and the user can backtrack to any previous step"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"experiment-attributes",children:"Experiment attributes"}),"\n",(0,t.jsxs)(n.p,{children:["Inside experiment scope, you can access to some built-in attributes which can be useful, such as ",(0,t.jsx)(n.code,{children:"minimum_cycle_duration"}),", to force the duration of one cycle."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"experiment my_experiment type: gui {\n    float minimum_cycle_duration <- 2.0#minute;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In addition, the attributes ",(0,t.jsx)(n.code,{children:"simulations"})," (resp. `simulation) contain the list of all the simulation agents that are running in the current experiment (resp. a single simulation, the last element of the simulation list)."]}),"\n",(0,t.jsx)(n.h2,{id:"experiment-facets",children:"Experiment facets"}),"\n",(0,t.jsxs)(n.p,{children:["Finally, in the case of a GUI experiment, the facet ",(0,t.jsx)(n.code,{children:"autorun"})," and ",(0,t.jsx)(n.code,{children:"benchmark"})," can be used such as:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"experiment name type: gui autorun: true benchmark: true { }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When ",(0,t.jsx)(n.code,{children:"autorun"})," is set to ",(0,t.jsx)(n.code,{children:"true"})," the launch of the experiment will be followed automatically by its run. When ",(0,t.jsx)(n.code,{children:"benchmark"})," is set to true, GAMA records the number of invocations and running time of the statements and operators of the simulations launched in this experiment. The results are automatically saved in a csv file in a folder called 'benchmarks' when the experiment is closed."]}),"\n",(0,t.jsxs)(n.p,{children:["Other built-ins are available, to learn more about, go to the page ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"ExperimentBuiltIn",children:"experiment built-in"})}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"defining-displays-layout",children:"Defining displays layout"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"layout"})," can be added to ",(0,t.jsx)(n.code,{children:"output"})," to specify the layout of the various displays defined below (e.g. ",(0,t.jsx)(n.code,{children:"#nonce"}),", ",(0,t.jsx)(n.code,{children:"#split"}),", ",(0,t.jsx)(n.code,{children:"#stack"}),", ",(0,t.jsx)(n.code,{children:"#vertical"})," or ",(0,t.jsx)(n.code,{children:"#horizontal"}),"). It will also define which elements of the interface are displayed: ",(0,t.jsx)(n.code,{children:"parameters"}),", ",(0,t.jsx)(n.code,{children:"navigator"}),", ",(0,t.jsx)(n.code,{children:"editors"}),", ",(0,t.jsx)(n.code,{children:"consoles"}),", ",(0,t.jsx)(n.code,{children:"toolbars"}),", ",(0,t.jsx)(n.code,{children:"tray"}),", or ",(0,t.jsx)(n.code,{children:"tabs"})," facets (expecting a boolean value)."]}),"\n",(0,t.jsx)(n.h2,{id:"defining-elements-of-the-gui-experiment",children:"Defining elements of the GUI experiment"}),"\n",(0,t.jsxs)(n.p,{children:["In this part, we will focus on the ",(0,t.jsx)(n.strong,{children:"gui experiments"}),". We will start with learning how to ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"DefiningParameters",children:"define input parameters"})}),", then we will study the outputs, such as ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"DefiningDisplaysGeneralities",children:"displays"})}),", ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"DefiningMonitorsAndInspectors",children:"monitors and inspectors"})}),", and ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"DefiningExportFiles",children:"export files"})}),". We will finish this part with how to define ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"DefiningUserInteraction",children:"user commands"})}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var t=i(96540);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);