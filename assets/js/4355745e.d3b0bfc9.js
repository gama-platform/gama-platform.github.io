"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[17411],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},f=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(n),f=r,m=d["".concat(c,".").concat(f)]||d[f]||h[f]||o;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=f;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},35399:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>c,default:()=>m,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var a=n(87462),r=n(63366),o=(n(67294),n(3905)),i=["components"],s={"^title":"City Evacuation"},c=void 0,l={unversionedId:"City_Evacuation",id:"City_Evacuation",title:"City_Evacuation",description:"Path: Plugin models/BDI Architecture/models/CityEscapeBDIEmotions.gaml",source:"@site/../docs/City_Evacuation.md",sourceDirName:".",slug:"/City_Evacuation",permalink:"/wiki/next/City_Evacuation",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/City_Evacuation/_edit",tags:[],version:"current",frontMatter:{"^title":"City Evacuation"}},p={},d=[],h={toc:d},f="wrapper";function m(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)(f,(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("img",{width:"960",alt:"Annotation 2023-04-16 185200_CityEscapeBDI",src:"https://user-images.githubusercontent.com/4437331/232328202-c9830e5b-db67-4975-b25e-35681313c2f1.png"}),(0,o.kt)("p",null,"Path: Plugin models/BDI Architecture/models/CityEscape_BDI_Emotions.gaml"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'\n/**-\n* Name: City Evacuation\n* Author: Mathieu Bourgais & Patrick Taillandier\n* Description:  Example model concerning the  use of the simpleBDI plug-in  with emotions. \n* A technological accident is simulated in one of the buildings of the city center.\n\n* Tags: simple_bdi, emotion, evacuation\n*/\n \nmodel City_Evacuation\n\nglobal {\n    file shapefile_roads <- file("../includes/Rouen roads.shp");\n    file shapefile_hazard <- file("../includes/Technological hazard.shp");\n    file shapefile_shelters <- file("../includes/Escapes.shp");\n    geometry shape <- envelope(shapefile_roads);\n    graph road_network;\n    map<road,float> current_weights;\n    \n    float hazard_distance <- 400.0;\n    float catastrophe_distance <- 100.0;\n    float proba_detect_hazard <- 0.2;\n    float proba_detect_other_escape <- 0.01;\n    float other_distance <- 10.0;\n    \n    init {\n        create road from: shapefile_roads;\n        create hazard from: shapefile_hazard;\n        create catastrophe;\n        create shelter from: shapefile_shelters;\n        \n        //at the begining of the simulation, we add to the people agent the desire to go to their target.\n        create people number: 200{\n            location <- any_location_in(one_of(road));\n            do add_desire(at_target);\n            \n            //the agent has also the desire that there is no catastrophe (we set the piority of this desire to 0 as it is a general desire)\n            do add_desire(nonCatastrophe ,0.0);\n            \n            // we give the agent a random charisma and receptivity (built-in variables linked to the emotions)\n            charisma<-rnd(1.0);\n            receptivity<-rnd(1.0);\n            \n            if(flip(0.9)){\n                fearful<-true;\n            }else{\n                fearful <- false;\n            }\n        }\n        road_network <- as_edge_graph(road);\n        current_weights <- road as_map (each::each.shape.perimeter);\n    }\n    \n    reflex update_speeds when: every(10#cycle){\n        current_weights <- road as_map (each::each.shape.perimeter / each.speed_coeff);\n        road_network <- road_network with_weights current_weights;\n    }\n    \n    reflex stop_sim when: empty(people) {\n        do pause;\n    }\n}\n \nspecies people skills: [moving] control: simple_bdi{\n    point target;\n    float speed <- 30 #km/#h;\n    rgb color <- #blue;\n    bool escape_mode <- false;\n    bool fearful;\n    \n    //in order to simplify the model we define  4 desires as variables\n    predicate at_target <- new_predicate("at_target");\n    predicate in_shelter <- new_predicate("shelter");\n    predicate has_target <- new_predicate("has target");\n    predicate has_shelter <- new_predicate("has shelter");\n\n    //we give them as well 2 beliefs as variables\n    predicate catastropheP <- new_predicate("catastrophe");\n    predicate nonCatastrophe <- new_predicate("catastrophe",false);\n    \n    //at last we define 2 emotion linked to the knowledge of the catastrophe\n    emotion fearConfirmed <- new_emotion("fear_confirmed",catastropheP);\n    emotion fear <- new_emotion("fear",catastropheP);\n    \n    bool noTarget<-true;\n    \n    //we set this built-in variable to true to use the emotional process\n    bool use_emotions_architecture <- true;\n\n    //if the agent perceive that their is something that is not normal (a hazard), it has a probability proba_detect_hazard to suppose (add to its unertainty base) that there is a catastrophe occuring\n    perceive target:hazard in: hazard_distance when: not escape_mode and flip(proba_detect_hazard){\n        focus id:"catastrophe" is_uncertain: true;\n        ask myself {\n            if(fearful){\n                do to_escape_mode;\n            }else{\n                color<-#green;\n            }\n        }\n    }\n\n    //if the agent perceive the catastrophe, it adds a belief about it and pass in escape mode\n    perceive target:catastrophe in:catastrophe_distance{\n        focus id:"catastrophe";\n        ask myself{\n            if(not escape_mode){\n                do to_escape_mode;\n            }\n        }\n    }\n\n    //if the agent perceives other people agents in their neighborhood that have fear, it can be contaminate by this emotion\n    perceive target:people in: other_distance when: not escape_mode {\n        emotional_contagion emotion_detected:fearConfirmed when: fearful;\n        emotional_contagion emotion_detected:new_emotion("fear") charisma: charisma receptivity:receptivity;\n        emotional_contagion emotion_detected:fearConfirmed emotion_created:fear;\n    }\n    emotion joy <- nil;\n    \n    \n    perceive target:people in: other_distance{\n        emotional_contagion emotion_detected: joy;\n        emotional_contagion emotion_detected:fearConfirmed emotion_created:fear;\n    }\n    \n    //if the agent has a fear confirmed, it has the desire to go to a shelter\n    rule emotion:fearConfirmed remove_intention: at_target new_desire:in_shelter strength:5.0;\n    \n    //if the agent has the belief that there is a a catastrophe,  it has the desire to go to a shelter\n    rule belief:new_predicate("catastrophe") remove_intention:at_target new_desire:in_shelter strength:5.0;\n    \n    rule emotion:new_emotion("fear" ,new_predicate("catastrophe")) new_desire:in_shelter remove_intention:at_target when: fearful strength:5.0;\n    \n    //normal move plan\n    plan normal_move intention: at_target  {\n        if (target = nil) {\n            target <- any_location_in(one_of(road));\n        } else {\n            do goto target: target on: road_network move_weights: current_weights recompute_path: false;\n            if (target = location)  {\n                target <- nil;\n                noTarget<-true;\n            }\n        }\n    }\n    \n    //fast evacuation plan in case where the agent has a fear confirmed\n    plan evacuationFast intention: in_shelter emotion: fearConfirmed priority:2 {\n        color <- #yellow;\n        speed <- 60 #km/#h;\n        if (target = nil or noTarget) {\n            target <- (shelter with_min_of (each.location distance_to location)).location;\n            noTarget <- false;\n        }\n        else  {\n            do goto target: target on: road_network move_weights: current_weights recompute_path: false;\n            if (target = location)  {\n                do die;\n            }       \n        }\n    }   \n    \n    //normal evacuation plan\n    plan evacuation intention: in_shelter finished_when: has_emotion(fearConfirmed){\n        color <-#darkred;\n        if (target = nil or noTarget) {\n            target <- (shelter with_min_of (each.location distance_to location)).location;\n            noTarget <- false;\n        }\n        else  {\n            do goto target: target on: road_network move_weights: current_weights recompute_path: false;\n            if (target = location)  {\n                do die;\n            }       \n        }\n    }\n    \n    action to_escape_mode {\n        escape_mode <- true;\n        color <- #darkred;\n        target <- nil;  \n        noTarget <- true;\n        do remove_intention(at_target, true);\n    }\n    \n    \n    aspect default {\n        draw triangle(30) rotate: heading + 90 color: color;\n    }\n}\n\nspecies road {\n    float capacity <- 1 + shape.perimeter/50;\n    int nb_people <- 0 update: length(people at_distance 1);\n    float speed_coeff <- 1.0 update:  exp(-nb_people/capacity) min: 0.1;\n    \n    aspect default {\n        draw shape color: #black;\n    }\n}\n\nspecies shelter {\n    aspect default {\n        draw circle(30) color: rgb(#gamablue,0.8) border: #gamablue depth:10;\n    }\n}\n\nspecies hazard {\n    aspect default {\n        draw circle(hazard_distance) color: rgb(#gamaorange,0.3) border:#gamaorange depth:5;\n    }\n}\n\nspecies catastrophe{\n    init{\n        location <- first(hazard).location;\n    }\n    aspect default{\n        draw circle(catastrophe_distance) color: rgb(#gamared,0.4) border:#gamared depth:10;\n    }\n}\n\nexperiment main type: gui {\n    float minimum_cycle_duration <- 0.02;\n    output {\n        display map type: 3d{\n            species shelter refresh: false;\n            species road refresh: false;\n            species people;\n            species catastrophe;\n            species hazard;\n        }\n    }\n}\n\n\n')))}m.isMDXComponent=!0}}]);