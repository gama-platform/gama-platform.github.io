"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[15632],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>u});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),_=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=_(e.components);return a.createElement(l.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=_(t),m=r,u=p["".concat(l,".").concat(m)]||p[m]||d[m]||o;return t?a.createElement(u,i(i({ref:n},c),{},{components:t})):a.createElement(u,i({ref:n},c))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var _=2;_<o;_++)i[_]=t[_];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},76629:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>_,toc:()=>p});var a=t(87462),r=t(63366),o=(t(67294),t(3905)),i=["components"],s={"^title":"pedestrian simple environment"},l=void 0,_={unversionedId:"pedestrian_simple_environment",id:"pedestrian_simple_environment",title:"pedestrian_simple_environment",description:"Path: Plugin models/Pedestrian Skill/models/Simple environment - walk_to.gaml",source:"@site/../docs/pedestrian_simple_environment.md",sourceDirName:".",slug:"/pedestrian_simple_environment",permalink:"/wiki/next/pedestrian_simple_environment",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/pedestrian_simple_environment/_edit",tags:[],version:"current",frontMatter:{"^title":"pedestrian simple environment"}},c={},p=[],d={toc:p},m="wrapper";function u(e){var n=e.components,t=(0,r.Z)(e,i);return(0,o.kt)(m,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("img",{width:"960",alt:"Annotation 2023-04-16 064607_simpleEnvWalkTo",src:"https://user-images.githubusercontent.com/4437331/232269725-54537a7d-2720-410f-a837-6f1e53b05786.png"}),(0,o.kt)("p",null,"Path: Plugin models/Pedestrian Skill/models/Simple environment - walk_to.gaml"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'\n/***\n* Name: pedestrian_simple_environment\n* Author: Patrick Taillandier\n* Description: \n* Tags: pedestrian, agent_movement, skill, transport\n***/\n\nmodel pedestrian_simple_environment\n\nglobal {\n    float environment_size <- 50.0 parameter: true;\n    float margin <- 2.0;\n    int nb_obstacles <- 0 parameter: true;\n    int nb_people <- 100;\n    string scenario <- "frontal crossing" among: ["big crowd", "frontal crossing", "perpendicular crossing"] ;\n        \n    bool display_free_space <- false parameter: true;\n    bool display_force <- false parameter: true;\n    bool display_circle_min_dist <- true parameter: true;\n    \n    float P_shoulder_length <- 0.45 parameter: true;\n    float P_proba_detour <- 1.0 parameter: true ;\n    bool P_avoid_other <- true parameter: true ;\n    float P_obstacle_consideration_distance <- 5.0 parameter: true ;\n    float P_pedestrian_consideration_distance <- 5.0 parameter: true ;\n    float P_tolerance_waypoint <- 0.1 parameter: true;\n    bool P_use_geometry_waypoint <- true parameter: true;\n    \n    string P_model_type <- "simple" among: ["simple", "advanced"] parameter: true ; \n    \n    float P_A_pedestrian_SFM_advanced parameter: true <- 25.0 category: "SFM advanced" ;\n    float P_A_obstacles_SFM_advanced parameter: true <- 25.0 category: "SFM advanced" ;\n    float P_B_pedestrian_SFM_advanced parameter: true <- 0.5 category: "SFM advanced" ;\n    float P_B_obstacles_SFM_advanced parameter: true <- 0.1 category: "SFM advanced" ;\n    float P_relaxion_SFM_advanced  parameter: true <- 0.1 category: "SFM advanced" ;\n    float P_gama_SFM_advanced parameter: true <- 0.35 category: "SFM advanced" ;\n    float P_lambda_SFM_advanced <- 0.1 parameter: true category: "SFM advanced" ;\n    float P_minimal_distance_advanced <- 0.5 parameter: true category: "SFM advanced" ;\n    \n    \n    float P_n_prime_SFM_simple parameter: true <- 3.0 category: "SFM simple" ;\n    float P_n_SFM_simple parameter: true <- 2.0 category: "SFM simple" ;\n    float P_lambda_SFM_simple <- 2.0 parameter: true category: "SFM simple" ;\n    float P_gama_SFM_simple parameter: true <- 0.35 category: "SFM simple" ;\n    float P_relaxion_SFM_simple parameter: true <- 0.54 category: "SFM simple" ;\n    float P_A_pedestrian_SFM_simple parameter: true <- 4.5category: "SFM simple" ;\n    \n    geometry shape <- square(environment_size);\n    geometry free_space <- copy(shape);\n    geometry left_space;\n    geometry right_space;\n    geometry bottom_space; \n    geometry top_space;\n    \n    float step <- 0.1;\n    \n    init {\n        left_space <- polygon([{0,0}, {0, environment_size}, {environment_size/10, environment_size}, {environment_size/10,0}]);\n        right_space <- polygon([{environment_size,0}, {environment_size, environment_size}, {9 * environment_size/10, environment_size}, {9 * environment_size/10,0}]);\n        bottom_space <- polygon([{0, environment_size}, {0, 9 * environment_size/10}, {environment_size,9*  environment_size/10}, {environment_size, environment_size}]);   \n        top_space <- polygon([{0, 0}, {0, environment_size/10}, {environment_size, environment_size/10}, {environment_size, 0.0}]); \n        \n        create obstacle number:nb_obstacles {\n            location <- any_location_in(square(8*environment_size/10) at_location {environment_size/2, environment_size/2} scaled_by 0.8);\n            shape <- sphere(1+rnd(environment_size/50.0));\n            free_space <- free_space - shape;\n        }\n        \n        create people number: nb_people {\n            obstacle_consideration_distance <- P_obstacle_consideration_distance;\n            obstacle_consideration_distance <- P_obstacle_consideration_distance;\n            pedestrian_consideration_distance <- P_pedestrian_consideration_distance;\n            shoulder_length <- P_shoulder_length;\n            avoid_other <- P_avoid_other;\n            proba_detour <- P_proba_detour;\n            use_geometry_waypoint <- P_use_geometry_waypoint;\n            tolerance_waypoint <- P_tolerance_waypoint;\n            \n            pedestrian_model <- P_model_type;\n            if (pedestrian_model = "simple") {\n                A_pedestrians_SFM <- P_A_pedestrian_SFM_simple;\n                relaxion_SFM <- P_relaxion_SFM_simple;\n                gama_SFM <- P_gama_SFM_simple;\n                lambda_SFM <- P_lambda_SFM_simple;\n                n_prime_SFM <- P_n_prime_SFM_simple;\n                n_SFM <- P_n_SFM_simple;\n            } else {\n                A_pedestrians_SFM <- P_A_pedestrian_SFM_advanced;\n                A_obstacles_SFM <- P_A_obstacles_SFM_advanced;\n                B_pedestrians_SFM <- P_B_pedestrian_SFM_advanced;\n                B_obstacles_SFM <- P_B_obstacles_SFM_advanced;\n                relaxion_SFM <- P_relaxion_SFM_advanced;\n                gama_SFM <- P_gama_SFM_advanced;\n                lambda_SFM <- P_lambda_SFM_advanced;\n                minimal_distance <- P_minimal_distance_advanced;\n            }\n            \n            pedestrian_species <- [people];\n            obstacle_species<-[obstacle];\n            switch scenario {\n                match "frontal crossing" {\n                    int id <- int(self);\n                    location <- any_location_in(even(id) ? left_space : right_space);\n                    current_target <- closest_points_with(location, even(id) ? right_space : left_space)[1];\n                } match "perpendicular crossing" {\n                    int id <- int(self);\n                    location <- any_location_in(even(id) ? left_space : bottom_space);\n                    current_target <- closest_points_with(location, (even(id) ? right_space : top_space))[1];\n                } match "big crowd" {\n                    location <- any_location_in(free_space);\n                    current_target <- any_location_in(world.shape.contour);\n                }\n            }\n        }\n    }\n    \n    reflex end_simulation when: empty(people) {\n        do pause;\n    }\n}\n\nspecies people skills: [pedestrian] schedules: shuffle(people) {\n    rgb color <- rnd_color(255);\n    float speed <- 3 #km/#h;\n    bool avoid_other <- true;\n    point current_target ;\n    reflex move when: current_target != nil{\n        if (nb_obstacles > 0) {\n            do walk_to target: current_target bounds: free_space;\n        } else {\n            do walk_to target: current_target;\n        }\n        if (self distance_to current_target < 0.5) {\n            do die;\n        }\n    }\n    aspect default {\n        if (display_circle_min_dist and minimal_distance > 0) {\n                if not empty(people at_distance minimal_distance) {\n                    draw circle(minimal_distance) color: #red;\n                }\n                \n        }\n        draw triangle(shoulder_length) color: color rotate: heading + 90.0;\n        \n        if  display_force {\n        \n            loop op over: forces.keys {\n                if (species(agent(op)) = obstacle ) {\n                    draw line([location, location + point(forces[op])]) color: #red end_arrow: 0.1;\n                }\n                else if ((agent(op)) = self ) {\n                    draw line([location, location + point(forces[op])]) color: #blue end_arrow: 0.1;\n                } \n                else {\n                    draw line([location, location + point(forces[op])]) color: #green end_arrow: 0.1;\n                }\n            }\n        }   \n    }\n}\n\nspecies obstacle {\n    aspect default {\n        draw shape color: #gray border: #black;\n    }\n}\nexperiment big_crowd type: gui {\n    float minimum_cycle_duration <- 0.02;\n    action _init_ {\n        create simulation with: [scenario :: "big crowd", nb_people::500];\n    }\n    output {\n        display map  {\n            species obstacle;\n            species people;\n        }\n    }\n}\n\nexperiment frontal_crossing type: gui {\n    float minimum_cycle_duration <- 0.02;\n    action _init_ {\n        create simulation with: [scenario :: "frontal crossing", nb_people::100];\n    }\n    output {\n        display map  {\n            graphics "areas" transparency: 0.5{\n                draw right_space color: #green border: #black;\n                draw left_space color: #red border: #black;\n            }\n            species obstacle;\n            species people;\n        }\n    }\n}\nexperiment perpendicular_crossing type: gui {\n    float minimum_cycle_duration <- 0.02;\n    action _init_ {\n        create simulation with: [scenario :: "perpendicular crossing", nb_people::100];\n    }\n    \n    output {\n        display map  {\n            graphics "areas" transparency: 0.7{\n                draw right_space color: #green border: #black;\n                draw left_space color: #red border: #black;\n                draw bottom_space color: #yellow border: #black;\n                draw top_space color: #magenta border: #black;\n            }\n            species obstacle;\n            species people;\n        }\n    }\n}\n\n\n')))}u.isMDXComponent=!0}}]);