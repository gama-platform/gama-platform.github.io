"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[78278],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>u});var o=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,i=function(e,n){if(null==e)return{};var t,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=o.createContext({}),m=function(e){var n=o.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=m(e.components);return o.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},c=o.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=m(t),u=i,h=c["".concat(s,".").concat(u)]||c[u]||p[u]||a;return t?o.createElement(h,r(r({ref:n},d),{},{components:t})):o.createElement(h,r({ref:n},d))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,r=new Array(a);r[0]=c;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var m=2;m<a;m++)r[m]=t[m];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}c.displayName="MDXCreateElement"},49106:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>m,toc:()=>p});var o=t(87462),i=t(63366),a=(t(67294),t(3905)),r=["components"],l={title:"4. Emotions and Personality"},s=void 0,m={unversionedId:"BDIAgents_step4",id:"version-1.8.1/BDIAgents_step4",title:"4. Emotions and Personality",description:"This fourth step consists of adding emotions that will impact the gold miner agent behavior and defining the personality of the agents.",source:"@site/versioned_docs/version-1.8.1/BDIAgents_step4.md",sourceDirName:".",slug:"/BDIAgents_step4",permalink:"/wiki/1.8.1/BDIAgents_step4",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/BDIAgents_step4/_edit",tags:[],version:"1.8.1",frontMatter:{title:"4. Emotions and Personality"},sidebar:"tuto",previous:{title:"3. Social relation",permalink:"/wiki/1.8.1/BDIAgents_step3"},next:{title:"5. Norms, obligation, and enforcement",permalink:"/wiki/1.8.1/BDIAgents_step5"}},d={},p=[{value:"Formulation",id:"formulation",level:2},{value:"Emotions",id:"emotions",level:2},{value:"Personality",id:"personality",level:2},{value:"Model Definition",id:"model-definition",level:2},{value:"Emotions",id:"emotions-1",level:3},{value:"Emotions and personality",id:"emotions-and-personality",level:3},{value:"Complete Model",id:"complete-model",level:2}],c={toc:p};function u(e){var n=e.components,t=(0,i.Z)(e,r);return(0,a.kt)("wrapper",(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This fourth step consists of adding emotions that will impact the gold miner agent behavior and defining the personality of the agents."),(0,a.kt)("h2",{id:"formulation"},"Formulation"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Definition of global emotions"),(0,a.kt)("li",{parentName:"ul"},"Modification of the miner species to integrate emotions and personality")),(0,a.kt)("h2",{id:"emotions"},"Emotions"),(0,a.kt)("p",null,"The BDI architecture of GAMA gives the possibility to generate emotions and to use them in the cognition. The definition of emotions in GAMA is based on the OCC theory of emotions. According to this theory, an emotion is a valued answer to the appraisal of a situation. In GAMA an emotion is represented by a set of 5 elements:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"E"),": the name of the emotion felt by agent i."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"P"),": the predicate that represents the fact about which the emotion is expressed."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"A"),": the agent causing the emotion."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"I"),": the intensity of the emotion."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"D"),": the decay of the emotion's intensity.")),(0,a.kt)("p",null,"The BDI architecture of GAMA integrates a dynamic creation of emotions process that will create emotions according to the mental states of the agent. More precisely, twenty emotions can be created: eight emotions related to events, four emotions related to other agents and eight emotions related to actions. "),(0,a.kt)("p",null,"The complete description of these emotions and their creation rules can be found in ",(0,a.kt)("a",{parentName:"p",href:"https://hal.archives-ouvertes.fr/hal-01573384/document"},"(Bourgais et al., 2017)"),"."),(0,a.kt)("h2",{id:"personality"},"Personality"),(0,a.kt)("p",null,"In order to facilitate the parametrization of the BDI agents, we add the possibility to define all the parameters related to the BDI architecture through the OCEAN model, which proposes to represent the personality of a person according to five factors (corresponding to the 5 variables of the BDI agents):"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"O"),": represents the openness of someone (open-minded/narrow-minded)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"C"),": represents the consciousness of someone (act with preparations/impulsive)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"E"),": represents the extroversion of someone (extrovert/shy)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"A"),": represents the agreeableness of someone (friendly/hostile)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"N"),": represent the degree of control someone has on its emotions (calm/neurotic)")),(0,a.kt)("p",null,"Each of these variables has a value between 0 and 1. 0.5 represents the neutral value, below 0.5, the value is considered negatively and above 0.5, it is considered positively. For example, someone with a value of 1 for ",(0,a.kt)("em",{parentName:"p"},"N")," is considered as calm and someone with a value of 0 for ",(0,a.kt)("em",{parentName:"p"},"A")," is considered as hostile."),(0,a.kt)("h2",{id:"model-definition"},"Model Definition"),(0,a.kt)("h3",{id:"emotions-1"},"Emotions"),(0,a.kt)("p",null,"We add a new global emotion called ",(0,a.kt)("inlineCode",{parentName:"p"},"joy")," that represents the joy emotion."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'global {\n    ...\n    emotion joy <- new_emotion("joy");\n    ...\n}\n')),(0,a.kt)("h3",{id:"emotions-and-personality"},"Emotions and personality"),(0,a.kt)("p",null,"To use emotions (and to activate the automatic emotion generation process), we just have to set the value of the built-in variable ",(0,a.kt)("inlineCode",{parentName:"p"},"use_emotions_architecture")," to true (false by default). In our case, one of the possible desires concerns the predicate ",(0,a.kt)("inlineCode",{parentName:"p"},"has_gold"),", and when an agent fulfill this desire and find a gold nugget (plan ",(0,a.kt)("inlineCode",{parentName:"p"},"get_gold"),"), it gets the belief ",(0,a.kt)("inlineCode",{parentName:"p"},"has_gold"),", and the emotion engine automatically creates a ",(0,a.kt)("inlineCode",{parentName:"p"},"joy")," emotion. "),(0,a.kt)("p",null,"To be able to define the parameter of a BDI agent through the OCEAN model, we have to set the value of the built-in variable ",(0,a.kt)("inlineCode",{parentName:"p"},"use_personality")," to true (false by default). In this model, we chose to use the default value of the ",(0,a.kt)("em",{parentName:"p"},"O"),", ",(0,a.kt)("em",{parentName:"p"},"C"),", ",(0,a.kt)("em",{parentName:"p"},"E"),", ",(0,a.kt)("em",{parentName:"p"},"A")," and ",(0,a.kt)("em",{parentName:"p"},"N")," variables (default value: 0.5). The interest of using the personality in our case is to allow the emotion engine to give a lifetime to the created emotions (otherwise, the emotions would have an infinite lifetime)."),(0,a.kt)("p",null,"In this model, we only use the emotions to define if the miner agents are going to share or not its knowledge about the gold mines. We consider that the miner only shares information if it has a joy emotion (and the agent tells that it is joyfous)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'species miner skills: [moving] control: simple_bdi {\n    ...\n    bool use_emotions_architecture <- true;\n    bool use_personality <- true;\n        \n    perceive target: gold_mine where (each.quantity > 0) in: view_dist {\n    focus mine_at_location var:location;\n    ask myself {\n        if (has_emotion(joy)) { \n                write self.name + " is joyous";\n                do add_desire(predicate:share_information, strength: 5.0);\n            }\n        do remove_intention(find_gold, false);\n    }\n    }\n    ...\n}\n')),(0,a.kt)("h2",{id:"complete-model"},"Complete Model"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'model BDItutorial4\n\nglobal {\n    int nb_mines <- 10; \n    int nb_miners <- 5;\n    market the_market;\n    \n    string mine_at_location <- "mine_at_location";\n    string empty_mine_location <- "empty_mine_location";\n    \n    float step <- 10#mn;\n    \n    //possible predicates concerning miners\n    predicate mine_location <- new_predicate(mine_at_location) ;\n    predicate choose_gold_mine <- new_predicate("choose a gold mine");\n    predicate has_gold <- new_predicate("extract gold");\n    predicate find_gold <- new_predicate("find gold") ;\n    predicate sell_gold <- new_predicate("sell gold") ;\n    predicate share_information <- new_predicate("share information") ;\n    \n    \n    emotion joy <- new_emotion("joy");\n    \n    float inequality <- 0.0 update:standard_deviation(miner collect each.gold_sold);\n    \n    geometry shape <- square(20 #km);\n    init\n    {\n        create market {\n            the_market <- self;    \n        }\n        create gold_mine number: nb_mines;\n        create miner number: nb_miners;\n    }\n    \n    reflex display_social_links{\n        loop tempMiner over: miner{\n                loop tempDestination over: tempMiner.social_link_base{\n                    if (tempDestination !=nil){\n                        bool exists<-false;\n                        loop tempLink over: socialLinkRepresentation{\n                            if((tempLink.origin=tempMiner) and (tempLink.destination=tempDestination.agent)){\n                                exists<-true;\n                            }\n                        }\n                        if(not exists){\n                            create socialLinkRepresentation number: 1{\n                                origin <- tempMiner;\n                                destination <- tempDestination.agent;\n                                if(get_liking(tempDestination)>0){\n                                    my_color <- #green;\n                                } else {\n                                    my_color <- #red;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n    }\n\n    reflex end_simulation when: sum(gold_mine collect each.quantity) = 0 and empty(miner where each.has_belief(has_gold)){\n        do pause;\n    }\n}\n\nspecies gold_mine {\n    int quantity <- rnd(1,20);\n    aspect default {\n        draw triangle(200 + quantity * 50) color: (quantity > 0) ? #yellow : #gray border: #black;    \n    }\n}\n\nspecies market {\n    int golds;\n    aspect default {\n        draw square(1000) color: #black ;\n    }\n}\n\nspecies miner skills: [moving] control:simple_bdi {\n    \n    float view_dist<-1000.0;\n    float speed <- 2#km/#h;\n    rgb my_color<-rnd_color(255);\n    point target;\n    int gold_sold;\n    \n    bool use_social_architecture <- true;\n    bool use_emotions_architecture <- true;\n    bool use_personality <- true;\n    \n    init {\n        do add_desire(find_gold);\n    }\n    \n    perceive target:miner in:view_dist {\n        socialize liking: 1 -  point(my_color.red, my_color.green, my_color.blue) distance_to point(myself.my_color.red, myself.my_color.green, myself.my_color.blue) / ( 255);\n    }\n        \n    perceive target: gold_mine where (each.quantity > 0) in: view_dist {\n        focus id: mine_at_location var: location;\n        ask myself {\n            if (has_emotion(joy)) {\n                write self.name + " is joyous";\n                do add_desire(predicate:share_information, strength: 5.0);\n            }\n            do remove_intention(find_gold, false);\n        }\n    }\n    \n    rule belief: mine_location new_desire: has_gold strength: 2.0;\n    rule belief: has_gold new_desire: sell_gold strength: 3.0;\n    \n    plan lets_wander intention:find_gold {\n        do wander;\n    }\n    \n    plan get_gold intention:has_gold  {\n        if (target = nil) {\n            do add_subintention(get_current_intention(),choose_gold_mine, true);\n            do current_intention_on_hold();\n        } else {\n            do goto target: target ;\n            if (target = location)  {\n                gold_mine current_mine<- gold_mine first_with (target = each.location);\n                if current_mine.quantity > 0 {\n                     do add_belief(has_gold);\n                    ask current_mine {quantity <- quantity - 1;}    \n                } else {\n                    do add_belief(new_predicate(empty_mine_location, ["location_value"::target]));\n                }\n                target <- nil;\n            }\n        }    \n    }\n    \n    plan choose_closest_gold_mine intention: choose_gold_mine instantaneous: true{\n        list<point> possible_mines <- get_beliefs_with_name(mine_at_location) collect (point(get_predicate(mental_state (each)).values["location_value"]));\n        list<point> empty_mines <- get_beliefs_with_name(empty_mine_location) collect (point(get_predicate(mental_state (each)).values["location_value"]));\n        possible_mines <- possible_mines - empty_mines;\n        if (empty(possible_mines)) {\n            do remove_intention(has_gold, true); \n        } else {\n            target <- (possible_mines with_min_of (each distance_to self)).location;\n        }\n        do remove_intention(choose_gold_mine, true); \n    }\n    \n    plan return_to_base intention: sell_gold {\n        do goto target: the_market ;\n        if (the_market.location = location)  {\n            do remove_belief(has_gold);\n            do remove_intention(sell_gold, true);\n            gold_sold <- gold_sold + 1;\n        }\n    }\n    plan share_information_to_friends intention: share_information instantaneous: true{\n        list<miner> my_friends <- list<miner>((social_link_base where (each.liking > 0)) collect each.agent);\n        loop known_gold_mine over: get_beliefs_with_name(mine_at_location) {\n            ask my_friends {\n                do add_belief(known_gold_mine);\n            }\n        }\n        loop known_empty_gold_mine over: get_beliefs_with_name(empty_mine_location) {\n            ask my_friends {\n                do add_belief(known_empty_gold_mine);\n            }\n        }\n        \n        do remove_intention(share_information, true); \n    }\n\n    aspect default {\n        draw circle(200) color: my_color border: #black depth: gold_sold;\n    }\n}\n\nspecies socialLinkRepresentation{\n    miner origin;\n    agent destination;\n    rgb my_color;\n    \n    aspect base{\n        draw line([origin,destination],50.0) color: my_color;\n    }\n}\n\nexperiment GoldBdi type: gui {\n    output {\n        display map type: opengl\n        {\n            species market ;\n            species gold_mine ;\n            species miner;\n        }\n\n        display socialLinks type: opengl{\n        species socialLinkRepresentation aspect: base;\n    }\n\n        display chart {\n        chart "Money" type: series {\n        datalist legend: miner accumulate each.name value: miner accumulate each.gold_sold color: miner accumulate each.my_color;\n        }\n    }\n\n    }\n}\n')),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"BDIAgents"},"Back to the start of the tutorial")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"BDIAgents_step1"},"Creation of the basic model: gold mines and market")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"BDIAgents_step2"},"Definition of the BDI miners")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"BDIAgents_step3"},"Definition of social relations between miners")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"BDIAgents_step5"},"Adding norms, obligations and enforcement"))))}u.isMDXComponent=!0}}]);