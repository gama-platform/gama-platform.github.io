"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[73335],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>c});var i=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,i)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,i,n=function(e,t){if(null==e)return{};var a,i,n={},o=Object.keys(e);for(i=0;i<o.length;i++)a=o[i],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)a=o[i],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=i.createContext({}),m=function(e){var t=i.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},p=function(e){var t=m(e.components);return i.createElement(s.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),h=m(a),u=n,c=h["".concat(s,".").concat(u)]||h[u]||d[u]||o;return a?i.createElement(c,r(r({ref:t},p),{},{components:a})):i.createElement(c,r({ref:t},p))}));function c(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,r=new Array(o);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[h]="string"==typeof e?e:n,r[1]=l;for(var m=2;m<o;m++)r[m]=a[m];return i.createElement.apply(null,r)}return i.createElement.apply(null,a)}u.displayName="MDXCreateElement"},30675:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>c,frontMatter:()=>l,metadata:()=>m,toc:()=>h});var i=a(87462),n=a(63366),o=(a(67294),a(3905)),r=["components"],l={title:"Exploration  calibration methods"},s=void 0,m={unversionedId:"ExplorationMethods",id:"ExplorationMethods",title:"Exploration  calibration methods",description:"[//]: # (startConcept|exploration_methods)",source:"@site/../docs/ExplorationMethods.md",sourceDirName:".",slug:"/ExplorationMethods",permalink:"/wiki/next/ExplorationMethods",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/ExplorationMethods/_edit",tags:[],version:"current",frontMatter:{title:"Exploration  calibration methods"},sidebar:"side",previous:{title:"Defining Batch Experiments",permalink:"/wiki/next/BatchExperiments"},next:{title:"Optimizing Models",permalink:"/wiki/next/OptimizingModelsSection"}},p={},h=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"The <code>method</code> statement",id:"the-method-statement",level:2},{value:"Rationals behind using batch methods",id:"rationals-behind-using-batch-methods",level:2},{value:"Exploration methods",id:"exploration-methods",level:2},{value:"Generic method facets (i.e. parameters):",id:"generic-method-facets-ie-parameters",level:3},{value:"Exhaustive exploration of the parameter space: <code>exhaustive</code>",id:"exhaustive-exploration-of-the-parameter-space-exhaustive",level:3},{value:"random exploration of the parameter space",id:"random-exploration-of-the-parameter-space",level:3},{value:"latin hypercube sampling",id:"latin-hypercube-sampling",level:3},{value:"orthogonal sampling",id:"orthogonal-sampling",level:3},{value:"Analysis Methods",id:"analysis-methods",level:2},{value:"Stochastic Analysis: <code>stochanalysis</code>",id:"stochastic-analysis-stochanalysis",level:3},{value:"Sobol Analysis: <code>sobol</code>",id:"sobol-analysis-sobol",level:3},{value:"Method facets (i.e. parameters):",id:"method-facets-ie-parameters",level:4},{value:"Example:",id:"example",level:4},{value:"Morris Analysis: <code>morris</code>",id:"morris-analysis-morris",level:3},{value:"Calibration Methods",id:"calibration-methods",level:2},{value:"Hill Climbing: <code>hill_climbing</code>",id:"hill-climbing-hill_climbing",level:3},{value:"Algorithm:",id:"algorithm",level:4},{value:"Method facets (i.e. parameters):",id:"method-facets-ie-parameters-1",level:4},{value:"Example:",id:"example-1",level:4},{value:"Simulated Annealing: <code>annealing</code>",id:"simulated-annealing-annealing",level:3},{value:"Algorithm:",id:"algorithm-1",level:4},{value:"Method facets (i.e. parameters):",id:"method-facets-ie-parameters-2",level:4},{value:"Example:",id:"example-2",level:4},{value:"Tabu Search: <code>tabu</code>",id:"tabu-search-tabu",level:3},{value:"Algorithm:",id:"algorithm-2",level:4},{value:"Method facets (i.e. parameters):",id:"method-facets-ie-parameters-3",level:4},{value:"Example:",id:"example-3",level:4},{value:"Reactive Tabu Search: <code>reactive_tabu</code>",id:"reactive-tabu-search-reactive_tabu",level:3},{value:"Method parameters:",id:"method-parameters",level:4},{value:"Example:",id:"example-4",level:4},{value:"Genetic Algorithm: <code>genetic</code>",id:"genetic-algorithm-genetic",level:3},{value:"Method facets (i.e. parameters):",id:"method-facets-ie-parameters-4",level:4},{value:"Example:",id:"example-5",level:4},{value:"Particle Swarm Optimization: <code>pso</code>",id:"particle-swarm-optimization-pso",level:3},{value:"Method facets (i.e. parameters):",id:"method-facets-ie-parameters-5",level:4},{value:"Example:",id:"example-6",level:4}],d={toc:h},u="wrapper";function c(e){var t=e.components,a=(0,n.Z)(e,r);return(0,o.kt)(u,(0,i.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Several methods are currently available in GAMA to explore and calibrate your simulation model."),(0,o.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#the-method-statement"},"The ",(0,o.kt)("inlineCode",{parentName:"a"},"method")," statement")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#rationals-behind-using-batch-methods"},"Various type of methods can be define")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#exploration-methods"},"The exploration method"),(0,o.kt)("blockquote",{parentName:"li"},(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#exhaustive-exploration-of-the-parameter-space-exhaustive"},"Exhaustive sampling: ",(0,o.kt)("inlineCode",{parentName:"a"},"exhaustive"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#random-exploration-of-the-parameter-space"},"Random sampling: ",(0,o.kt)("inlineCode",{parentName:"a"},"uniform"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#latin-hypercube-sampling"},"Latin Hypercube sampling: ",(0,o.kt)("inlineCode",{parentName:"a"},"latinhypercube"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#orthogonal-sampling"},"Othrogonal sampling: ",(0,o.kt)("inlineCode",{parentName:"a"},"orthogonal")))))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#analysis-methods"},"Analysis methods"),(0,o.kt)("blockquote",{parentName:"li"},(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#stochastic-analysis"},"Analysis of stochasticity: ",(0,o.kt)("inlineCode",{parentName:"a"},"stochanalysis"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#sobol-analysis"},"Sobol analysis: ",(0,o.kt)("inlineCode",{parentName:"a"},"sobol"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#morris-analysis"},"Morris analysis: ",(0,o.kt)("inlineCode",{parentName:"a"},"morris"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#beta-analysis"},"Beta analysis: ",(0,o.kt)("inlineCode",{parentName:"a"},"betad")))))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#calibration-methods"},"Calibration methods"),(0,o.kt)("blockquote",{parentName:"li"},(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#hill-climbing-hill-climbing"},"Hill Climbing: ",(0,o.kt)("inlineCode",{parentName:"a"},"hill_climbing"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#simulated-annealing-annealing"},"Simulated Annealing: ",(0,o.kt)("inlineCode",{parentName:"a"},"annealing"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#tabu-search-tabu"},"Tabu Search: ",(0,o.kt)("inlineCode",{parentName:"a"},"tabu"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#reactive-tabu-search-reactive-tabu"},"Reactive Tabu Search: ",(0,o.kt)("inlineCode",{parentName:"a"},"reactive_tabu"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#genetic-algorithm-genetic"},"Genetic Algorithm: ",(0,o.kt)("inlineCode",{parentName:"a"},"genetic"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#particle-swarm-optimization-pso"},"Particle Swarm Optimization: ",(0,o.kt)("inlineCode",{parentName:"a"},"pso"))))))),(0,o.kt)("h2",{id:"the-method-statement"},"The ",(0,o.kt)("inlineCode",{parentName:"h2"},"method")," statement"),(0,o.kt)("p",null,"The optional ",(0,o.kt)("inlineCode",{parentName:"p"},"method")," statement controls the algorithm which drives the batch."),(0,o.kt)("p",null,"If this element is omitted, the batch will run an ",(0,o.kt)("inlineCode",{parentName:"p"},"exploration")," method with default facets, see the ",(0,o.kt)("a",{parentName:"p",href:"#exploration-methods"},"exploration section")," for more details."),(0,o.kt)("p",null,"Examples of the use of ",(0,o.kt)("inlineCode",{parentName:"p"},"method")," statement:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"method exploration;\n")),(0,o.kt)("p",null,"or"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'method genetic \n    pop_dim: 3 crossover_prob: 0.7 mutation_prob: 0.1 \n    nb_prelim_gen: 1 max_gen: 5  \n    minimize: nb_infected \n    aggregation: "max";\n')),(0,o.kt)("h2",{id:"rationals-behind-using-batch-methods"},"Rationals behind using batch methods"),(0,o.kt)("p",null,"Overall Gama provides three uses of batch ",(0,o.kt)("inlineCode",{parentName:"p"},"method")," for ",(0,o.kt)("a",{parentName:"p",href:"#exploration-methods"},"exploration"),", ",(0,o.kt)("a",{parentName:"p",href:"#analysis-methods"},"analysis")," and ",(0,o.kt)("a",{parentName:"p",href:"#calibration-methods"},"calibration"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The first type stands for classical exploration of simulation models by launching simulations for a given set of parameters. The purpose of such approach is to better understand the behavior of the model exploring different scenarios corresponding to a set of points in the parameter space. See the section dedicated to ",(0,o.kt)("a",{parentName:"li",href:"#exhaustive-exploration-of-the-parameter-space-exhaustive"},"exploration"),"."),(0,o.kt)("li",{parentName:"ul"},"The set of methods dedicated to analysis are meant to better understand how the model outputs are determined by stochastic processes and input parameters, what usually is referred to as Sensitivity Analysis. See the section dedicated to ",(0,o.kt)("a",{parentName:"li",href:"#analysis-methods"},"analysis")),(0,o.kt)("li",{parentName:"ul"},"The last set of methods are used to choose a satisfying set of parameter value to achieve as close as possible desired outputs, what usually is referred to as Calibration. See the section dedicated to ",(0,o.kt)("a",{parentName:"li",href:"#calibration-methods"},"calibration"))),(0,o.kt)("h2",{id:"exploration-methods"},"Exploration methods"),(0,o.kt)("p",null,"[TODO]"),(0,o.kt)("h3",{id:"generic-method-facets-ie-parameters"},"Generic method facets (i.e. parameters):"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"sample"),": number of points to explore in the parameter space"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"sampling"),": the methods used to automatically draw points from the parameter space "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"with"),": the explicit list of points (map) to explore (it bypasses the two first facets)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"from"),": the explicit list of points to explore, encoded in a csv file (one point a line, each column a parameter - bypasses the two first facets).")),(0,o.kt)("h3",{id:"exhaustive-exploration-of-the-parameter-space-exhaustive"},"Exhaustive exploration of the parameter space: ",(0,o.kt)("inlineCode",{parentName:"h3"},"exhaustive")),(0,o.kt)("p",null,"This is the default batch exploration method. It explores all the combination of parameter values in a sequential way."),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time > 400 ) {\n    parameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)';\n    parameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;\n}\n")),(0,o.kt)("p",null,"The order of the simulations depends on the order of the parameters. In our example, the first combinations will be the followings:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"evaporation","_","rate = 0.1, diffusion","_","rate = 0.1, (2 times)"),(0,o.kt)("li",{parentName:"ul"},"evaporation","_","rate = 0.1, diffusion","_","rate = 0.4, (2 times)"),(0,o.kt)("li",{parentName:"ul"},"evaporation","_","rate = 0.1, diffusion","_","rate = 0.7, (2 times)"),(0,o.kt)("li",{parentName:"ul"},"evaporation","_","rate = 0.1, diffusion","_","rate = 1.0, (2 times)"),(0,o.kt)("li",{parentName:"ul"},"evaporation","_","rate = 0.2, diffusion","_","rate = 0.1, (2 times)"),(0,o.kt)("li",{parentName:"ul"},"...")),(0,o.kt)("h3",{id:"random-exploration-of-the-parameter-space"},"random exploration of the parameter space"),(0,o.kt)("p",null,"Provide "),(0,o.kt)("h3",{id:"latin-hypercube-sampling"},"latin hypercube sampling"),(0,o.kt)("p",null,"TODO"),(0,o.kt)("h3",{id:"orthogonal-sampling"},"orthogonal sampling"),(0,o.kt)("p",null,"TODO"),(0,o.kt)("h2",{id:"analysis-methods"},"Analysis Methods"),(0,o.kt)("p",null,"TODO"),(0,o.kt)("h3",{id:"stochastic-analysis-stochanalysis"},"Stochastic Analysis: ",(0,o.kt)("inlineCode",{parentName:"h3"},"stochanalysis")),(0,o.kt)("p",null,"TODO"),(0,o.kt)("h3",{id:"sobol-analysis-sobol"},"Sobol Analysis: ",(0,o.kt)("inlineCode",{parentName:"h3"},"sobol")),(0,o.kt)("p",null,"This is an implementation of the Sobol sensitivity analysis exploration. It is based on the implementation of the algorithm provided by ",(0,o.kt)("a",{parentName:"p",href:"http://moeaframework.org"},"http://moeaframework.org")," under the GPL GNU licence."),(0,o.kt)("p",null,"Rational behind the Sobol sensitivity analysis can be found in Saltelli article (",(0,o.kt)("a",{parentName:"p",href:"https://doi.org/10.1016/S0010-4655(02)00280-1"},"https://doi.org/10.1016/S0010-4655(02)00280-1"),"). To put it simple, the procedure randomly drawn N x P points in the parameter space (with N defined by the ",(0,o.kt)("inlineCode",{parentName:"p"},"sample")," parameter and P the number of parameters to explore), execute the set of associated simulation and compute first, second and total ordered sensitivity indexes. Intuitively, those values give an estimated contribution of the parameters to the variability of one or several outputs (the ",(0,o.kt)("inlineCode",{parentName:"p"},"outputs")," list in parameter of the method). "),(0,o.kt)("h4",{id:"method-facets-ie-parameters"},"Method facets (i.e. parameters):"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"outputs"),", the list of output variables to analyse through sobol indexes."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"report"),", the path to the file where the Sobol report will be written."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"results"),", the path to the file where the automatic batch report will be written."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"sample"),", the size of the sample for the sobol sequence.")),(0,o.kt)("h4",{id:"example"},"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'experiment Sobol type: batch keep_seed:true until:( time > 5000 ) {\n    parameter \'Infection rate\' var: infection_rate min:0.0 max:1.0;\n    parameter \'Probability of dying\' var:dying_proba min:0.01 max:0.25;\n    method sobol outputs:["num_dead"] sample:100 report:"Results/sobol.txt" results:"Results/sobol_raw.csv";\n}\n')),(0,o.kt)("h3",{id:"morris-analysis-morris"},"Morris Analysis: ",(0,o.kt)("inlineCode",{parentName:"h3"},"morris")),(0,o.kt)("p",null,"TODO"),(0,o.kt)("h2",{id:"calibration-methods"},"Calibration Methods"),(0,o.kt)("p",null,"TODO : principles"),(0,o.kt)("p",null,"Specific facets dedicated to calibration methods are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"minimize")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"maximize")," (mandatory for optimization methods): a facet defining the expression to be optimized."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"aggregation")," (optional): the possible values are ",(0,o.kt)("inlineCode",{parentName:"li"},"min")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"max")," (string). Each combination of parameter values is tested ",(0,o.kt)("inlineCode",{parentName:"li"},"repeat")," times. The aggregated fitness of one combination is by default the average of fitness values obtained with those repetitions. This aggregated fitness can be turned to the minimum or the maximum of the obtained fitness values using this facet."),(0,o.kt)("li",{parentName:"ul"},"other parameters that are specific to the exploration method (optional): see below for a description of these facets.")),(0,o.kt)("h3",{id:"hill-climbing-hill_climbing"},"Hill Climbing: ",(0,o.kt)("inlineCode",{parentName:"h3"},"hill_climbing")),(0,o.kt)("p",null,"This algorithm is an implementation of the Hill Climbing algorithm. ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Hill_climbing"},"See the Wikipedia article for a more detailed explanation"),". This is a local search method that tries at each step, given a solution ",(0,o.kt)("inlineCode",{parentName:"p"},"s"),", to find a solution ",(0,o.kt)("inlineCode",{parentName:"p"},"s'")," in the neighborhood of ",(0,o.kt)("inlineCode",{parentName:"p"},"s")," that increases (or decreases depending on the aim of the exploration) the fitness. This method is more efficient than the global exploration to find an optimum, but with the risk of finding a local optimum, whereas a global optimum could exist. "),(0,o.kt)("h4",{id:"algorithm"},"Algorithm:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"}," Initialization of an initial solution s \n iter = 0\n While iter <= iter_max, do:\n   Choice of the solution s' in the neighborhood of s that maximize the fitness function\n   If f(s') > f(s)\n     s = s'\n   Else\n     end of the search process\n   EndIf\n   iter = iter + 1\n EndWhile\n")),(0,o.kt)("h4",{id:"method-facets-ie-parameters-1"},"Method facets (i.e. parameters):"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"iter_max"),": number of iterations before stoping the exploration.")),(0,o.kt)("h4",{id:"example-1"},"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time > 400 ) {\n    parameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)';\n    parameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;\n\n    method hill_climbing iter_max: 50 maximize: food_gathered;\n}\n")),(0,o.kt)("h3",{id:"simulated-annealing-annealing"},"Simulated Annealing: ",(0,o.kt)("inlineCode",{parentName:"h3"},"annealing")),(0,o.kt)("p",null,"This algorithm is an implementation of the Simulated Annealing algorithm. ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Simulated_annealing"},"See the Wikipedia article")," for more details. This is a global search method able to find an approximation of a global optimum. The idea is close to the one of slow cooling: given a solution, the algorithm will look for a better one in its neighborhood. This size of the neighborhood (represented by the temperature) will decrease over the execution of the algorithm."),(0,o.kt)("h4",{id:"algorithm-1"},"Algorithm:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"}," Initialization of an initial solution s \n temp = temp_init\n While temp > temp_end, do:\n   iter = 0\n   While iter < nb_iter_cst_temp, do:\n     Random choice of a solution s2 in the neighborhood of s  \n     df = f(s2)-f(s)\n     If df > 0 \n       s = s2\n     Else,\n       rand = random number between 0 and 1\n       If rand < exp(df/temp)\n         s = s2\n       EndIf\n     EndIf\n     iter = iter + 1\n   EndWhile\n   temp = temp * temp_decrease\n EndWhile\n")),(0,o.kt)("h4",{id:"method-facets-ie-parameters-2"},"Method facets (i.e. parameters):"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"temp_init"),": Initial temperature."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"temp_end"),": Final temperature."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"temp_decrease"),": Temperature decrease coefficient."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"nb_iter_cst_temp"),": Number of iterations per level of temperature.")),(0,o.kt)("h4",{id:"example-2"},"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time > 400 ) {\n    parameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)';\n    parameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;\n\n    method annealing \n        temp_init: 100  temp_end: 1 \n        temp_decrease: 0.5 nb_iter_cst_temp: 5 \n        maximize: food_gathered;\n}\n")),(0,o.kt)("h3",{id:"tabu-search-tabu"},"Tabu Search: ",(0,o.kt)("inlineCode",{parentName:"h3"},"tabu")),(0,o.kt)("p",null,"This algorithm is an implementation of the Tabu Search algorithm. ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Tabu_search"},"See the Wikipedia article")," for more details. This is a local search method. To avoid the issue of local optimum, two additional principals are added: (i) ",(0,o.kt)("em",{parentName:"p"},"worsening"),", i.e. the algorithm can sometimes choose a worse solution, (ii) ",(0,o.kt)("em",{parentName:"p"},"prohibitions"),", i.e. solutions that have already been explored will become ",(0,o.kt)("strong",{parentName:"p"},"tabu")," in order to avoid that the algorithm considers them repeatedly."),(0,o.kt)("h4",{id:"algorithm-2"},"Algorithm:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"}," Initialization of an initial solution s \n tabuList = {}\n iter = 0\n While iter <= iter_max, do:\n   Choice of the solution s2 in the neighborhood of s such that:\n     s2 is not in tabuList\n     the fitness function is maximal for s2\n   s = s2\n   If size of tabuList = tabu_list_size\n     removing of the oldest solution in tabuList \n   EndIf\n   tabuList = tabuList + s\n   iter = iter + 1\n EndWhile\n")),(0,o.kt)("h4",{id:"method-facets-ie-parameters-3"},"Method facets (i.e. parameters):"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"iter_max"),": number of iterations."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"tabu_list_size"),": size of the tabu list.")),(0,o.kt)("h4",{id:"example-3"},"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time > 400 ) {\n    parameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)';\n    parameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;\n\n    method tabu \n        iter_max: 50 tabu_list_size: 5 \n        maximize: food_gathered;\n}\n")),(0,o.kt)("h3",{id:"reactive-tabu-search-reactive_tabu"},"Reactive Tabu Search: ",(0,o.kt)("inlineCode",{parentName:"h3"},"reactive_tabu")),(0,o.kt)("p",null,"This algorithm is a simple implementation of the Reactive Tabu Search algorithm (Battiti et al., 1993). This Reactive Tabu Search is an enhanced version of the Tabu search. It adds two new elements to the classic Tabu Search. The first one concerns the size of the tabu list: in the Reactive Tabu Search, this one is not constant anymore but it dynamically evolves according to the context. Thus, when the exploration process visits too often the same solutions, the tabu list is extended in order to favor the diversification of the search process. On the other hand, when the process has not visited an already known solution for a high number of iterations, the tabu list is shortened in order to favor the intensification of the search process. The second new element concerns the adding of cycle detection capacities. Thus, when a cycle is detected, the process applies random movements in order to break the cycle."),(0,o.kt)("h4",{id:"method-parameters"},"Method parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"iter_max"),": number of iterations."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"tabu_list_size_ini"),": initial size of the tabu list."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"tabu_list_size_min"),": minimal size of the tabu list."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"tabu_list_size_max"),": maximal size of the tabu list."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"nb_tests_wthout_col_max"),": number of movements without collision before shortening the tabu list."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"cycle_size_min"),": minimal size of the considered cycles."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"cycle_size_max"),": maximal size of the considered cycles.")),(0,o.kt)("h4",{id:"example-4"},"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time > 400 ) {\n    parameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)';\n    parameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;\n\n    method reactive_tabu \n        iter_max: 50 tabu_list_size_init: 5 tabu_list_size_min: 2 tabu_list_size_max: 10 \n        nb_tests_wthout_col_max: 20 cycle_size_min: 2 cycle_size_max: 20 \n        maximize: food_gathered;\n}\n")),(0,o.kt)("h3",{id:"genetic-algorithm-genetic"},"Genetic Algorithm: ",(0,o.kt)("inlineCode",{parentName:"h3"},"genetic")),(0,o.kt)("p",null,"This is a simple implementation of Genetic Algorithms (GA). ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Genetic_algorithm"},"See the Wikipedia article")," for more details. The principle of GA is to search an optimal solution by applying evolution operators on an initial population of solutions. There are three types of evolution operators:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Crossover: Two solutions are combined in order to produce new solutions."),(0,o.kt)("li",{parentName:"ul"},"Mutation: a solution is modified."),(0,o.kt)("li",{parentName:"ul"},"Selection: only a part of the population is kept. Different techniques can be applied to this selection. Most of them are based on solution quality (fitness).")),(0,o.kt)("p",null,"Representation of the solutions:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Individual solution: {Param1 = val1; Param2 = val2; ...}"),(0,o.kt)("li",{parentName:"ul"},"Gene: Parami = vali")),(0,o.kt)("p",null,"Initial population building: the system builds nb","_","prelim","_","gen random initial populations composed of pop","_","dim individual solutions. Then, the best pop","_","dim solutions are selected to be part of the initial population."),(0,o.kt)("p",null,"Selection operator: roulette-wheel selection: the probability to choose a solution is equal to fitness(solution)/ Sum of the population fitness. A solution can be selected several times. Ex: population composed of 3 solutions with fitness (that we want to maximize) 1, 4 and 5. Their probability to be chosen is equal to 0.1, 0.4 and 0.5."),(0,o.kt)("p",null,"Mutation operator: The value of one parameter is modified. Ex: The solution {Param1 = 3; Param2 = 2} can mute to {Param1 = 3; Param2 = 4}"),(0,o.kt)("p",null,"Crossover operator: A cut point is randomly selected and two new solutions are built by taking the half of each parent solution. Ex: let {Param1 = 4; Param2 = 1} and {Param1 = 2; Param2 = 3} be two solutions. The crossover operator builds two new solutions: {Param1 = 2; Param2 = 1} and {Param1 = 4; Param2 = 3}."),(0,o.kt)("h4",{id:"method-facets-ie-parameters-4"},"Method facets (i.e. parameters):"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"pop_dim"),": size of the population (number of individual solutions)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"crossover_prob"),": crossover probability between two individual solutions."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"mutation_prob"),": mutation probability for an individual solution."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"nb_prelim_gen"),": number of random populations used to build the initial population."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"max_gen"),": number of generations.")),(0,o.kt)("h4",{id:"example-5"},"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"experiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed ) or ( time > 400 ) {\n    parameter 'Evaporation:' var: evaporation_rate among: [ 0.1 , 0.2 , 0.5 , 0.8 , 1.0 ] unit: 'rate every cycle (1.0 means 100%)';\n    parameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;\n    \n    method genetic maximize: food_gathered \n        pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1 \n        nb_prelim_gen: 1 max_gen: 20; \n}\n")),(0,o.kt)("h3",{id:"particle-swarm-optimization-pso"},"Particle Swarm Optimization: ",(0,o.kt)("inlineCode",{parentName:"h3"},"pso")),(0,o.kt)("p",null,"This is an implementation of the Partical Swarm Optimization algorithme (PSO). ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Particle_swarm_optimization"},"See the Wikipedia article")," for more details. It solves a problem by having a population of candidate solutions, here dubbed particles, and moving these particles around in the search-space according to simple mathematical formula over the particle's position and velocity. Each particle's movement is influenced by its local best known position, but is also guided toward the best known positions in the search-space, which are updated as better positions are found by other particles. This is expected to move the swarm toward the best solutions. "),(0,o.kt)("h4",{id:"method-facets-ie-parameters-5"},"Method facets (i.e. parameters):"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"iter_max"),", number of iterations."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"num_particles"),", number of particles."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"weight_cognitive"),", weight for the cognitive component."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"weight_inertia"),", weight for the inertia component."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"weight_social"),", weight for the social component.")),(0,o.kt)("h4",{id:"example-6"},"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"experiment PSO type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n    parameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n    parameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n    method pso num_particles: 3 weight_inertia:0.7 weight_cognitive: 1.5 weight_social: 1.5  iter_max: 5  minimize: num_dead  ; \n}\n")))}c.isMDXComponent=!0}}]);