"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[75066],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},g="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),g=s(n),c=o,h=g["".concat(p,".").concat(c)]||g[c]||d[c]||r;return n?a.createElement(h,i(i({ref:t},m),{},{components:n})):a.createElement(h,i({ref:t},m))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=c;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[g]="string"==typeof e?e:o,i[1]=l;for(var s=2;s<r;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},37640:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>p,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>g});var a=n(87462),o=n(63366),r=(n(67294),n(3905)),i=["components"],l={title:"4. Movement on Graph"},p=void 0,s={unversionedId:"IncrementalModel_step4",id:"version-1.8.2-RC2/IncrementalModel_step4",title:"4. Movement on Graph",description:"This step illustrates how to load a graph and use it for the displacement of our agents.",source:"@site/versioned_docs/version-1.8.2-RC2/IncrementalModel_step4.md",sourceDirName:".",slug:"/IncrementalModel_step4",permalink:"/wiki/IncrementalModel_step4",draft:!1,editUrl:"https://github.com/gama-platform/gama/wiki/IncrementalModel_step4/_edit",tags:[],version:"1.8.2-RC2",frontMatter:{title:"4. Movement on Graph"},sidebar:"tuto",previous:{title:"3. Integration of GIS Data",permalink:"/wiki/IncrementalModel_step3"},next:{title:"5. Visualizing in 3D",permalink:"/wiki/IncrementalModel_step5"}},m={},g=[{value:"Formulation",id:"formulation",level:2},{value:"Model Definition",id:"model-definition",level:2},{value:"global variables",id:"global-variables",level:3},{value:"Initialization",id:"initialization",level:3},{value:"people agent",id:"people-agent",level:3},{value:"Complete Model",id:"complete-model",level:2}],d={toc:g},c="wrapper";function h(e){var t=e.components,l=(0,o.Z)(e,i);return(0,r.kt)(c,(0,a.Z)({},d,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This step illustrates how to load a graph and use it for the displacement of our agents."),(0,r.kt)("h2",{id:"formulation"},"Formulation"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Definition of a global graph to represent the road network."),(0,r.kt)("li",{parentName:"ul"},"Definition of a new global variable: ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"staying_coeff"))," to represent the fact that people move more near 9h, 12h, and 18h."),(0,r.kt)("li",{parentName:"ul"},"Definition of two new variables for the people agents: ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"target"))," and ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"staying_counter"))," (to manage their mobility)."),(0,r.kt)("li",{parentName:"ul"},"Definition of a new reflex for people agents: ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"stay")),"."),(0,r.kt)("li",{parentName:"ul"},"Modification of the ",(0,r.kt)("inlineCode",{parentName:"li"},"move")," reflex of the people agents.")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Incremental tutorial 4: make people move on the roads.",src:n(37162).Z,width:"3584",height:"2118"})),(0,r.kt)("h2",{id:"model-definition"},"Model Definition"),(0,r.kt)("h3",{id:"global-variables"},"global variables"),(0,r.kt)("p",null,"We define two new global variables:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"road_network"))," (graph): represents the graph built from the road network."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"staying_coeff"))," (float): represents the fact that people have more chance to move from their current building near 9h (go to work), 12h (lunchtime) and 18h (go home). This variable is updated at each simulation step (using the ",(0,r.kt)("inlineCode",{parentName:"li"},"update")," facet).")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"global{\n    ....\n    graph road_network;\n    float staying_coeff update: 10.0 ^ (1 + min([abs(current_date.hour - 9), abs(current_date.hour - 12), abs(current_date.hour - 18)]));\n    ....\n}\n")),(0,r.kt)("h3",{id:"initialization"},"Initialization"),(0,r.kt)("p",null,"We need to compute from the ",(0,r.kt)("inlineCode",{parentName:"p"},"road")," agents, a graph for the moving of the ",(0,r.kt)("inlineCode",{parentName:"p"},"people")," agents. The operator ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"as_edge_graph"))," allows doing that. It automatically builds from a set of agents or geometries a graph where the agents are the edges of the graph, a node represent the extremities of the agent geometry. The weight of each edge corresponds to the length of the road."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"global {\n    ...\n    init {\n        ...\n        create road from: roads_shapefile;\n        road_network <- as_edge_graph(road);    \n        ...\n    }\n}\n")),(0,r.kt)("h3",{id:"people-agent"},"people agent"),(0,r.kt)("p",null,"First, we add two new variables for the people agents:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"target"))," (point): the target location that the people want to reach (a point inside a building)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"staying_counter"))," (int): the number of cycles since the agent arrived at its building.")),(0,r.kt)("p",null,"We define a new reflex named ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"stay"))," that is activated when the agent has no target (",(0,r.kt)("inlineCode",{parentName:"p"},"target = nil"),"), i.e. when the agent is inside a building. This reflex increments the ",(0,r.kt)("inlineCode",{parentName:"p"},"staying_counter"),", then it tests the probability to leave that is computed from the ",(0,r.kt)("inlineCode",{parentName:"p"},"staying_counter")," (longer the agent is inside the building, more it has a chance to leave) and the ",(0,r.kt)("inlineCode",{parentName:"p"},"staying_coeff")," (closer to 9h, 12h, and 18h, more the agent has a chance to leave).\nIf the agents decide to leave, it computes a new target as a random point inside one of the buildings (randomly chosen)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"species people skills: [moving] {       \n    ...\n    reflex staying when: target = nil {\n    staying_counter <- staying_counter + 1;\n    if flip(staying_counter / staying_coeff) {\n        target <- any_location_in (one_of(building));\n    }\n    }\n    ...\n}\n")),(0,r.kt)("p",null,"We modify the ",(0,r.kt)("inlineCode",{parentName:"p"},"move")," reflex. Now, this reflex is activated only when the agent has a target (",(0,r.kt)("inlineCode",{parentName:"p"},"target != nil"),"). In this case, the agent moves toward its target using the built-in ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"goto"))," action. Note that we specified a graph (",(0,r.kt)("inlineCode",{parentName:"p"},"road_network"),") to constraint the moving of the agents on the road network with the facet ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"on")),". The agent uses the shortest path (according to the graph) to go to the target point. When the agent arrives at destination (location = location), the target is set to nil (the agent will stop moving) and the ",(0,r.kt)("inlineCode",{parentName:"p"},"staying_counter")," is set to 0."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"species people skills:[moving]{     \n    ...\n    reflex move when: target != nil{\n    do goto target: target on: road_network;\n    if (location = target) {\n        target <- nil;\n        staying_counter <- 0;\n    } \n    }\n}\n")),(0,r.kt)("h2",{id:"complete-model"},"Complete Model"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-gaml",metastring:"reference",reference:!0},"\nhttps://github.com/gama-platform/gama/blob/GAMA_1.8.2/msi.gama.models/models/Tutorials/Incremental%20Model/models/Incremental%20Model%204.gaml\n")))}h.isMDXComponent=!0},37162:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/Incremental_model4-24278ef6edbba133e025c501425bb118.png"}}]);